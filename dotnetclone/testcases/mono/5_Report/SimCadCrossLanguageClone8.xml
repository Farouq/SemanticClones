<clones  >
<clone_pair groupid="661" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="481" endline="487">
<![CDATA[
 
 #End Region
 
     Overridable ReadOnly Property AsString() As String
         Get
             Return "<String representation of " & Me.GetType.FullName & " not implemented>"
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="31" endline="45">
<![CDATA[
 
 		/// <remarks>
 		///   This is different from ToString in that ToString
 		///   is supposed to be there for debugging purposes,
 		///   and is not guaranteed to be useful for anything else,
 		///   AsString() will provide something that can be used
 		///   for round-tripping C# code.  Maybe it can be used
 		///   for IL assembly as well.
 		/// </remarks>
 		public abstract string AsString ();
 
 		override public string ToString ()
 		{
 			return this.GetType ().Name + " (" + AsString () + ")";
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1360" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="799" endline="811">
<![CDATA[
 
 		//
 		// Returns the parameter information based on the name
 		//
 		public int GetParameterIndexByName (string name)
 		{
 			for (int idx = 0; idx < Count; ++idx) {
 				if (parameters [idx].Name == name)
 					return idx;
 			}
 			for (int idx = 0; idx < Count; ++idx) {
 				if (parameters [idx].Name == name)
 					return idx;
 			}
 
 			return -1;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1361" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2691" endline="2713">
<![CDATA[
 
 		//
 		// All unfixed type variables Xi are fixed for which all of the following hold
 		// a, There is at least one type variable Xj that depends on Xi
 		// b, Xi has a non-empty set of bounds
 		// 
 		public bool FixDependentTypes (ResolveContext ec, ref bool fixed_any)
 		{
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (fixed_types[i] != null)
 					continue;
 
 				if (bounds[i] == null)
 					continue;
 
 				if (!FixType (ec, i))
 					return false;
 				
 				fixed_any = true;
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (fixed_types[i] != null)
 					continue;
 
 				if (bounds[i] == null)
 					continue;
 
 				if (!FixType (ec, i))
 					return false;
 				
 				fixed_any = true;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1362" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2682" endline="2690">
<![CDATA[
 
 		public bool FixAllTypes (ResolveContext ec)
 		{
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (!FixType (ec, i))
 					return false;
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (!FixType (ec, i))
 					return false;
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1363" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2529" endline="2538">
<![CDATA[
 
 		public static OpType? GetType (string metadata_name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1364" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="154" endline="169">
<![CDATA[
 		}
 
 		// TODO
 		// IsGenericType -- recursive
 		// HasTypeParameter -- non-recursive
 		public bool IsGenericOrParentIsGeneric {
 			get {
 				var ts = this;
 				do {
 					if (ts.IsGeneric)
 						return true;
 					ts = ts.declaringType;
 				} while (ts != null);
 
 				return false;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1365" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1971" endline="1990">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// Checks all type arguments againts type parameters constraints
 		// NOTE
 		//
 		public bool CheckAll (MemberSpec context, TypeSpec[] targs, TypeParameterSpec[] tparams, Location loc)
 		{
 			for (int i = 0; i < tparams.Length; i++) {
 				if (ignore_inferred_dynamic && targs[i] == InternalType.Dynamic)
 					continue;
 
 				if (!CheckConstraint (context, targs [i], tparams [i], loc))
 					return false;
 			}
 			for (int i = 0; i < tparams.Length; i++) {
 				if (ignore_inferred_dynamic && targs[i] == InternalType.Dynamic)
 					continue;
 
 				if (!CheckConstraint (context, targs [i], tparams [i], loc))
 					return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1366" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2959" endline="2975">
<![CDATA[
 
 		int IsUnfixed (TypeSpec type)
 		{
 			if (!type.IsGenericParameter)
 				return -1;
 
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (tp_args[i] == type) {
 					if (fixed_types[i] != null)
 						break;
 
 					return i;
 				}
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (tp_args[i] == type) {
 					if (fixed_types[i] != null)
 						break;
 
 					return i;
 				}
 			}
 
 			return -1;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1367" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="103" endline="122">
<![CDATA[
 		}
 
 		public bool IsAttribute {
 			get {
 				if (!IsClass)
 					return false;
 
 				var type = this;
 				do {
 					if (type.IsGeneric)
 						return false;
 
 					if (type == TypeManager.attribute_type)
 						return true;
 					
 					type = type.base_type;
 				} while (type != null);
 
 				return false;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1368" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="84" endline="96">
<![CDATA[
 		}
 
 		public CallingConventions CallingConventions {
 			get {
 				CallingConventions cc = parameters.CallingConvention;
 				if (!IsInterface)
 					if ((ModFlags & Modifiers.STATIC) == 0)
 						cc |= CallingConventions.HasThis;
 
 				// FIXME
 			
 				return cc;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1369" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6879" endline="6892">
<![CDATA[
 
 		public static bool IsThisAvailable (ResolveContext ec, bool ignoreAnonymous)
 		{
 			if (ec.IsStatic || ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.BaseInitializer | ResolveContext.Options.ConstantScope))
 				return false;
 
 			if (ignoreAnonymous || ec.CurrentAnonymousMethod == null)
 				return true;
 
 			if (TypeManager.IsStruct (ec.CurrentType) && ec.CurrentIterator == null)
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1373" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="779" endline="788">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1)
         If chr = "X"c Then
             Return Nothing
         Else
             Return GetTypeCodeOfChar(chr)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2061" endline="2070">
<![CDATA[
 
 		bool IsTokenIdentifierEqual (char[] identifier)
 		{
 			for (int i = 0; i < identifier.Length; ++i) {
 				if (identifier[i] != id_builder[i])
 					return false;
 			}
 			for (int i = 0; i < identifier.Length; ++i) {
 				if (identifier[i] != id_builder[i])
 					return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1374" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="779" endline="788">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1)
         If chr = "X"c Then
             Return Nothing
         Else
             Return GetTypeCodeOfChar(chr)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="288" endline="299">
<![CDATA[
 
 		internal int Hash()
 		{
 			int hash = 0;
 			int len = this.Length;
 			for (int i = 0; i < len; i++)
 			{
 				hash *= 37;
 				hash ^= buffer[i];
 			}
 			for (int i = 0; i < len; i++)
 			{
 				hash *= 37;
 				hash ^= buffer[i];
 			}
 			return hash;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1376" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="779" endline="788">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1)
         If chr = "X"c Then
             Return Nothing
         Else
             Return GetTypeCodeOfChar(chr)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="67" endline="78">
<![CDATA[
 
 		static private byte[] Trim (byte[] array) 
 		{
 			for (int i=0; i < array.Length; i++) {
 				if (array [i] != 0x00) {
 					byte[] result = new byte [array.Length - i];
 					Buffer.BlockCopy (array, i, result, 0, result.Length);
 					return result;
 				}
 			}
 			for (int i=0; i < array.Length; i++) {
 				if (array [i] != 0x00) {
 					byte[] result = new byte [array.Length - i];
 					Buffer.BlockCopy (array, i, result, 0, result.Length);
 					return result;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1377" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="779" endline="788">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1)
         If chr = "X"c Then
             Return Nothing
         Else
             Return GetTypeCodeOfChar(chr)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="369" endline="384">
<![CDATA[
 
 		private static bool IsEqual(byte[] b1, byte[] b2)
 		{
 			if (b1.Length != b2.Length)
 			{
 				return false;
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1378" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="779" endline="788">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1)
         If chr = "X"c Then
             Return Nothing
         Else
             Return GetTypeCodeOfChar(chr)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="97" endline="110">
<![CDATA[
 
 		internal static Type[][] Copy(Type[][] types)
 		{
 			if (types == null || types.Length == 0)
 			{
 				return types;
 			}
 			Type[][] newArray = new Type[types.Length][];
 			for (int i = 0; i < newArray.Length; i++)
 			{
 				newArray[i] = Copy(types[i]);
 			}
 			for (int i = 0; i < newArray.Length; i++)
 			{
 				newArray[i] = Copy(types[i]);
 			}
 			return newArray;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1522" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1978" endline="1985">
<![CDATA[
 
     Shared Function CreateArray(Of T)(ByVal Value As T, ByVal Length As Integer) As T()
         Dim result(Length - 1) As T
         For i As Integer = 0 To Length - 1
             result(i) = Value
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="760" endline="773">
<![CDATA[
 
 		protected static Type[][] BindTypeParameters(IGenericBinder binder, Type[][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][] expanded = new Type[types.Length][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1523" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1978" endline="1985">
<![CDATA[
 
     Shared Function CreateArray(Of T)(ByVal Value As T, ByVal Length As Integer) As T()
         Dim result(Length - 1) As T
         For i As Integer = 0 To Length - 1
             result(i) = Value
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="774" endline="787">
<![CDATA[
 
 		protected static Type[][][] BindTypeParameters(IGenericBinder binder, Type[][][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][][] expanded = new Type[types.Length][][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1570" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="169" endline="176">
<![CDATA[
 
     Function IsNamespaceExact(ByVal A As String, ByVal B As String) As Boolean
         For i As Integer = 0 To Me.Count - 1
             Dim ns As [Namespace] = Me.Item(i)
             If ns.Equals(A, B) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="276" endline="287">
<![CDATA[
 
 		internal bool Match(int pos, ByteBuffer bb2, int pos2, int len)
 		{
 			for (int i = 0; i < len; i++)
 			{
 				if (buffer[pos + i] != bb2.buffer[pos2 + i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < len; i++)
 			{
 				if (buffer[pos + i] != bb2.buffer[pos2 + i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1645" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="331" endline="353">
<![CDATA[
 
 
     ''' <summary>
     ''' - Types are defined with the reflection.emit namespace. 
     ''' - Only classes, modules, structures, interfaces, enums, delegates and eventnos (not a type by itself, bu an event might declare a new delegate). They are only defined, nothing else.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineType()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypes() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypes " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineType(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="254" endline="278">
<![CDATA[
 
 		private static ushort ParseVersionPart(string str, ref int pos)
 		{
 			ushort value = 0;
 			while (pos < str.Length)
 			{
 				char c = str[pos];
 				if (c == '.')
 				{
 					pos++;
 					break;
 				}
 				else if (c >= '0' && c <= '9')
 				{
 					value *= 10;
 					value += (ushort)(c - '0');
 					pos++;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (pos < str.Length)
 			{
 				char c = str[pos];
 				if (c == '.')
 				{
 					pos++;
 					break;
 				}
 				else if (c >= '0' && c <= '9')
 				{
 					value *= 10;
 					value += (ushort)(c - '0');
 					pos++;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1727" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="517" endline="533">
<![CDATA[
 
 	static string GetTypeKind (Type t)
 	{
 		if (t.IsEnum)
 			return "enum";
 		if (t.IsClass) {
 			if (t.IsSubclassOf (typeof (System.MulticastDelegate)))
 				return "delegate";
 			else
 				return "class";
 		}
 		if (t.IsInterface)
 			return "interface";
 		if (t.IsValueType)
 			return "struct";
 		return "class";
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2427" endline="2439">
<![CDATA[
 
     Shared Function IntToBin(ByVal Int As ULong) As String
         If Int = 0 Then Return "0"
         IntToBin = ""
         Do Until Int = 0
             If CBool(Int And 1UL) Then
                 IntToBin = "1" & IntToBin
             Else
                 IntToBin = "0" & IntToBin
             End If
             Int >>= 1
         Loop
         Do Until Int = 0
             If CBool(Int And 1UL) Then
                 IntToBin = "1" & IntToBin
             Else
                 IntToBin = "0" & IntToBin
             End If
             Int >>= 1
         Loop
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1754" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="461" endline="481">
<![CDATA[
 
 		private static Type[] NormalizeAndCopy(Type[] array)
 		{
 			if (array == null || array.Length == 0)
 			{
 				return null;
 			}
 			Type[] copy = null;
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			return copy;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2910" endline="2928">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if all types in both arrays are the exact same types.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareTypes(ByVal Types1() As Mono.Cecil.TypeReference, ByVal Types2() As Mono.Cecil.TypeReference) As Boolean
         If Types1 Is Nothing AndAlso Types2 Is Nothing Then
             Return True
         ElseIf Types1 Is Nothing Xor Types2 Is Nothing Then
             Return False
         Else
             If Types1.Length <> Types2.Length Then Return False
             For i As Integer = 0 To Types1.Length - 1
                 If Helper.CompareType(Types1(i), Types2(i)) = False Then Return False
             Next
             Return True
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2047" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="291" endline="311">
<![CDATA[
 
 		private static int ReadCompressedInt(byte[] buffer, ref int offset)
 		{
 			byte b1 = buffer[offset++];
 			if (b1 <= 0x7F)
 			{
 				return b1;
 			}
 			else if ((b1 & 0xC0) == 0x80)
 			{
 				byte b2 = buffer[offset++];
 				return ((b1 & 0x3F) << 8) | b2;
 			}
 			else
 			{
 				byte b2 = buffer[offset++];
 				byte b3 = buffer[offset++];
 				byte b4 = buffer[offset++];
 				return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="878" endline="928">
<![CDATA[
 
     Public Shared Function ConvertToBoolean(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = Source
                 Return True
             Case TypeCode.Byte
                 result = CBool(DirectCast(Source, Byte))
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Boolean")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Boolean")
             Case TypeCode.Decimal
                 result = CBool(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 result = CBool(DirectCast(Source, Double))
                 Return True
             Case TypeCode.Int16
                 result = CBool(DirectCast(Source, Short))
                 Return True
             Case TypeCode.Int32
                 result = CBool(DirectCast(Source, Integer))
                 Return True
             Case TypeCode.Int64
                 result = CBool(DirectCast(Source, Long))
                 Return True
             Case TypeCode.SByte
                 result = CBool(DirectCast(Source, SByte))
                 Return True
             Case TypeCode.Single
                 result = CBool(DirectCast(Source, Single))
                 Return True
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.UInt16
                 result = CBool(DirectCast(Source, UShort))
                 Return True
             Case TypeCode.UInt32
                 result = CBool(DirectCast(Source, UInteger))
                 Return True
             Case TypeCode.UInt64
                 result = CBool(DirectCast(Source, ULong))
                 Return True
             Case TypeCode.DBNull
                 result = CBool(Nothing)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Boolean")
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2117" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1695" endline="1718">
<![CDATA[
 
 		public void SetRange (int offset, int length)
 		{
 			if (offset > Count || offset + length > Count)
 				throw new ArgumentOutOfRangeException ("flow-analysis");
 
 			if (shared == null && vector == null)
 				return;
 
 			int i = 0;
 			if (shared != null) {
 				if (offset + length <= shared.Count) {
 					for (; i < length; ++i)
 						if (!shared [i+offset])
 						    break;
 					for (; i < length; ++i)
 						if (!shared [i+offset])
 						    break;
 					if (i == length)
 						return;
 				}
 				initialize_vector ();
 			}
 			for (; i < length; ++i)
 				vector [i+offset] = true;
 			for (; i < length; ++i)
 				vector [i+offset] = true;
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="793" endline="882">
<![CDATA[
 
     Private Function ResolveUnqualifiedName(ByVal Rs As String(), ByVal TypeArgumentCount As Integer) As Boolean
 
         For Each R As String In Rs
             '---------------------------------------------------------------------------------------------------------
             ' Given an unqualified name R, the following steps describe how to determine to which namespace or type an 
             ' unqualified name refers
             '---------------------------------------------------------------------------------------------------------
 
             '---------------------------------------------------------------------------------------------------------
             '* For each nested type containing the name reference, starting from the innermost type and going to the
             '* outermost, if R matches the name of an accessible nested type or a type parameter in the current type, 
             '* then the unqualified name refers to that type or type parameter.
             '---------------------------------------------------------------------------------------------------------
             If CheckNestedTypesOrTypeParameters(R, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* For each nested namespace containing the name reference, starting from the innermost namespace and 
             '* going to the outermost namespace, do the following
             '*
             '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
             '** unqualified name refers to that type or nested namespace.
             '*
             '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
             '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
             '*
             '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
             '** error occurs.
             '---------------------------------------------------------------------------------------------------------
             If CheckNamespaces(R, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* If the source file has one or more import aliases, and R matches the name of one of them, then 
             '* the unqualified name refers to that import alias.
             '---------------------------------------------------------------------------------------------------------
             Helper.Assert(FromWhere IsNot Nothing)
             'Helper.Assert(FromWhere.HasLocation)
             Helper.Assert(FromWhere.File IsNot Nothing)
             Helper.Assert(FromWhere.File.Imports IsNot Nothing)
 
             If CheckImportsAlias(R, FromWhere.File.Imports, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '*	If the source file containing the name reference has one or more imports
             '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
             '** that type. If R matches the name of an accessible type in more than one import and all are not the 
             '** same entity, a compile-time error occurs.
             '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
             '** namespace. If R matches the name of a namespace in more than one import and all are not the same entity, a 
             '** compile-time error occurs.
             '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible 
             '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches 
             '** the name of accessible nested types in more than one standard module, a compile-time error occurs.
             '---------------------------------------------------------------------------------------------------------
             If CheckImports(R, FromWhere.File.Imports, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* If the compilation environment defines one or more import aliases, and R matches the name of one of 
             '* them, then the unqualified name refers to that import alias.
             '---------------------------------------------------------------------------------------------------------
             If CheckImportsAlias(R, FromWhere.Compiler.CommandLine.Imports.Clauses, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* If the compilation environment defines one or more imports
             '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
             '** that type. If R matches the name of an accessible type in more than one import, a compile-time error 
             '** occurs.
             '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
             '** namespace. If R matches the name of a namespace in more than one import, a compile-time error occurs.
             '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible
             '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches the                 
             '** name of accessible nested types in more than one standard module, a compile-time error occurs.
             '---------------------------------------------------------------------------------------------------------
             If CheckImports(R, FromWhere.Compiler.CommandLine.Imports.Clauses, TypeArgumentCount) Then Return True
         Next
         '---------------------------------------------------------------------------------------------------------
         '* Otherwise, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
 
         FromWhere.Compiler.Report.ShowMessage(Messages.VBNC30451, FromWhere.Location, Rs(0))
 
         '---------------------------------------------------------------------------------------------------------
         '* Note   
         '* An implication of this resolution process is that type members do not shadow namespaces or types 
         '* when resolving namespace or type names.
         '* If the type name is a constructed type name (i.e. it includes a type argument list), then only types 
         '* with the same arity as the type argument list are matched.
         '---------------------------------------------------------------------------------------------------------
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2163" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="25" endline="55">
<![CDATA[
     Sub New(ByVal Parent As EventDeclaration, ByVal Modifiers As Modifiers, ByVal HandlerType As KS, ByVal EventName As Identifier)
         MyBase.new(Parent)
 
         Dim Code As ImplicitCodeBlock
         If (Parent.Modifiers.Is(ModifierMasks.MustOverride) OrElse DeclaringType.IsInterface) Then
             Code = Nothing
         Else
             Select Case HandlerType
                 Case KS.AddHandler
                     Code = New ImplicitCodeBlock(Me, New ImplicitCodeBlock.CodeGenerator(AddressOf CreateAddHandlerCode))
                 Case KS.RemoveHandler
                     Code = New ImplicitCodeBlock(Me, New ImplicitCodeBlock.CodeGenerator(AddressOf CreateRemoveHandlerCode))
                 Case KS.RaiseEvent
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     Code = Nothing
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
 
         MyBase.Init(Modifiers, HandlerType, EventName, New ParameterList(Me), Code)
 
         If DeclaringType.IsValueType Then
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed
         ElseIf DeclaringType.IsInterface Then
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed
         Else
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed Or Mono.Cecil.MethodImplAttributes.Synchronized
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1041" endline="1103">
<![CDATA[
 
 		bool parse_less_than ()
 		{
 		start
 			int the_token = token ();
 			if (the_token == Token.OPEN_BRACKET) {
 				do {
 					the_token = token ();
 				} while (the_token != Token.CLOSE_BRACKET);
 				the_token = token ();
 			} else if (the_token == Token.IN || the_token == Token.OUT) {
 				the_token = token ();
 			}
 			switch (the_token) {
 			case Token.IDENTIFIER
 			case Token.OBJECT
 			case Token.STRING
 			case Token.BOOL
 			case Token.DECIMAL
 			case Token.FLOAT
 			case Token.DOUBLE
 			case Token.SBYTE
 			case Token.BYTE
 			case Token.SHORT
 			case Token.USHORT
 			case Token.INT
 			case Token.UINT
 			case Token.LONG
 			case Token.ULONG
 			case Token.CHAR
 			case Token.VOID
 				break;
 			case Token.OP_GENERICS_GT
 				return true;
 
 			default
 				return false;
 			}
 		again
 			the_token = token ();
 
 			if (the_token == Token.OP_GENERICS_GT)
 				return true;
 			else if (the_token == Token.COMMA || the_token == Token.DOT || the_token == Token.DOUBLE_COLON)
 				goto start;
 			else if (the_token == Token.INTERR_NULLABLE || the_token == Token.STAR)
 				goto again;
 			else if (the_token == Token.OP_GENERICS_LT) {
 				if (!parse_less_than ())
 					return false;
 				goto again;
 			} else if (the_token == Token.OPEN_BRACKET) {
 			rank_specifiers
 				the_token = token ();
 				if (the_token == Token.CLOSE_BRACKET)
 					goto again;
 				else if (the_token == Token.COMMA)
 					goto rank_specifiers;
 				return false;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2164" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="25" endline="55">
<![CDATA[
     Sub New(ByVal Parent As EventDeclaration, ByVal Modifiers As Modifiers, ByVal HandlerType As KS, ByVal EventName As Identifier)
         MyBase.new(Parent)
 
         Dim Code As ImplicitCodeBlock
         If (Parent.Modifiers.Is(ModifierMasks.MustOverride) OrElse DeclaringType.IsInterface) Then
             Code = Nothing
         Else
             Select Case HandlerType
                 Case KS.AddHandler
                     Code = New ImplicitCodeBlock(Me, New ImplicitCodeBlock.CodeGenerator(AddressOf CreateAddHandlerCode))
                 Case KS.RemoveHandler
                     Code = New ImplicitCodeBlock(Me, New ImplicitCodeBlock.CodeGenerator(AddressOf CreateRemoveHandlerCode))
                 Case KS.RaiseEvent
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     Code = Nothing
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
 
         MyBase.Init(Modifiers, HandlerType, EventName, New ParameterList(Me), Code)
 
         If DeclaringType.IsValueType Then
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed
         ElseIf DeclaringType.IsInterface Then
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed
         Else
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed Or Mono.Cecil.MethodImplAttributes.Synchronized
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="192" endline="236">
<![CDATA[
 
 		public static MethodAttributes MethodAttr (Modifiers mod_flags)
 		{
 			MethodAttributes ma = MethodAttributes.HideBySig;
 
 			switch (mod_flags & Modifiers.AccessibilityMask) {
 			case Modifiers.PUBLIC
 				ma |= MethodAttributes.Public;
 				break;
 			case Modifiers.PRIVATE
 				ma |= MethodAttributes.Private;
 				break;
 			case Modifiers.PROTECTED | Modifiers.INTERNAL
 				ma |= MethodAttributes.FamORAssem;
 				break;
 			case Modifiers.PROTECTED
 				ma |= MethodAttributes.Family;
 				break;
 			case Modifiers.INTERNAL
 				ma |= MethodAttributes.Assembly;
 				break;
 			default
 				throw new NotImplementedException (mod_flags.ToString ());
 			}
 
 			if ((mod_flags & Modifiers.STATIC) != 0)
 				ma |= MethodAttributes.Static;
 			if ((mod_flags & Modifiers.ABSTRACT) != 0) {
 				ma |= MethodAttributes.Abstract | MethodAttributes.Virtual;
 			}
 			if ((mod_flags & Modifiers.SEALED) != 0)
 				ma |= MethodAttributes.Final;
 
 			if ((mod_flags & Modifiers.VIRTUAL) != 0)
 				ma |= MethodAttributes.Virtual;
 
 			if ((mod_flags & Modifiers.OVERRIDE) != 0) {
 				ma |= MethodAttributes.Virtual;
 			} else {
 				if ((ma & MethodAttributes.Virtual) != 0)
 					ma |= MethodAttributes.NewSlot;
 			}
 			
 			return ma;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2165" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="130" endline="172">
<![CDATA[
 
     Shared Function TypeCodeToBuiltInType(ByVal tp As TypeCode) As BuiltInDataTypes
         Select Case tp
             Case TypeCode.Boolean
                 Return BuiltInDataTypes.Boolean
             Case TypeCode.Byte
                 Return BuiltInDataTypes.Byte
             Case TypeCode.Char
                 Return BuiltInDataTypes.Char
             Case TypeCode.DateTime
                 Return BuiltInDataTypes.Date
             Case TypeCode.DBNull
                 Throw New InternalException("")
             Case TypeCode.Decimal
                 Return BuiltInDataTypes.Decimal
             Case TypeCode.Double
                 Return BuiltInDataTypes.Double
             Case TypeCode.Empty
                 Throw New InternalException("")
             Case TypeCode.Int16
                 Return BuiltInDataTypes.Short
             Case TypeCode.Int32
                 Return BuiltInDataTypes.Integer
             Case TypeCode.Int64
                 Return BuiltInDataTypes.Long
             Case TypeCode.Object
                 Return BuiltInDataTypes.Object
             Case TypeCode.SByte
                 Return BuiltInDataTypes.SByte
             Case TypeCode.Single
                 Return BuiltInDataTypes.Single
             Case TypeCode.String
                 Return BuiltInDataTypes.String
             Case TypeCode.UInt16
                 Return BuiltInDataTypes.UShort
             Case TypeCode.UInt32
                 Return BuiltInDataTypes.UInteger
             Case TypeCode.UInt64
                 Return BuiltInDataTypes.ULong
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2186" endline="2232">
<![CDATA[
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (oper) {
 			case Operator.Addition
 				return IsCompound ? "AddAssign" 
 			case Operator.BitwiseAnd
 				return IsCompound ? "AndAssign" 
 			case Operator.BitwiseOr
 				return IsCompound ? "OrAssign" 
 			case Operator.Division
 				return IsCompound ? "DivideAssign" 
 			case Operator.ExclusiveOr
 				return IsCompound ? "ExclusiveOrAssign" 
 			case Operator.Equality
 				return "Equal";
 			case Operator.GreaterThan
 				return "GreaterThan";
 			case Operator.GreaterThanOrEqual
 				return "GreaterThanOrEqual";
 			case Operator.Inequality
 				return "NotEqual";
 			case Operator.LeftShift
 				return IsCompound ? "LeftShiftAssign" 
 			case Operator.LessThan
 				return "LessThan";
 			case Operator.LessThanOrEqual
 				return "LessThanOrEqual";
 			case Operator.LogicalAnd
 				return "And";
 			case Operator.LogicalOr
 				return "Or";
 			case Operator.Modulus
 				return IsCompound ? "ModuloAssign" 
 			case Operator.Multiply
 				return IsCompound ? "MultiplyAssign" 
 			case Operator.RightShift
 				return IsCompound ? "RightShiftAssign" 
 			case Operator.Subtraction
 				return IsCompound ? "SubtractAssign" 
 			default
 				throw new NotImplementedException ("Unknown expression type operator " + oper.ToString ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
</clones>
