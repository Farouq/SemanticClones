<clones  >
<clone_pair groupid="1" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="331" endline="340">
<![CDATA[
     ''' <summary>
     ''' GotoNewline defaults to false for this overload.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal ParamArray MessageParameters() As String) As Boolean
         Return AcceptIfNotError(Special, Message, False, MessageParameters)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1405" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_EventHandler IsNot Nothing Then result = m_EventHandler.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1409" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="35" endline="42">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_Arguments IsNot Nothing Then result = m_Arguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1432" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="61" endline="73">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then
             result = m_ParameterList.ResolveTypeReferences AndAlso result
         End If
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1446" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="407" endline="416">
<![CDATA[
 
     Function EmitAttributes() As Boolean
         Dim result As Boolean = True
 
         If m_Attributes IsNot Nothing Then
             result = m_Attributes.GenerateCode(Nothing) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1467" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2120" endline="2129">
<![CDATA[
 
     Shared Function CloneExpressionArray(ByVal Expressions() As Expression, ByVal NewParent As ParsedObject) As Expression()
         Dim result(Expressions.GetUpperBound(0)) As Expression
         For i As Integer = 0 To result.GetUpperBound(0)
             If Expressions(i) IsNot Nothing Then
                 result(i) = Expressions(i).Clone(NewParent)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1469" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="53" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Test IsNot Nothing Then result = m_Test.ResolveTypeReferences AndAlso result
         If m_Cases IsNot Nothing Then result = m_Cases.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1470" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="54" endline="63">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression1 IsNot Nothing Then result = m_Expression1.ResolveTypeReferences AndAlso result
         If m_Expression2 IsNot Nothing Then result = m_Expression2.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1471" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="391" endline="401">
<![CDATA[
 
     Shared Function IsKeyword(ByVal str As Char(), ByVal length As Integer, ByRef Keyword As KS) As Boolean
         Dim special As KS
         special = Enums.GetKS(str, length)
         If special <> KS.None Then
             Keyword = special
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1473" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="41" endline="49">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_FirstPart IsNot Nothing Then result = m_FirstPart.ResolveTypeReferences AndAlso result
         If m_SecondPart IsNot Nothing Then result = m_SecondPart.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1474" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="58" endline="69">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_First IsNot Nothing Then result = m_First.ResolveTypeReferences AndAlso result
         If m_Second IsNot Nothing Then result = m_Second.ResolveTypeReferences AndAlso result
 
         ' If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1481" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="73" endline="82">
<![CDATA[
     End Property
 
     ReadOnly Property AddDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_AddMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_AddMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1483" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="242" endline="261">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Compare one CodeFile to another based on filename.
     ''' </summary>
     ''' <param name="value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Overrides Function Equals(ByVal value As Object) As Boolean
         Dim file As CodeFile = TryCast(value, CodeFile)
         If file IsNot Nothing Then
             If file Is Me Then
                 Return True
             Else
                 Return Microsoft.VisualBasic.Strings.StrComp(m_FileName, file.FileName, Microsoft.VisualBasic.CompareMethod.Text) = 0
             End If
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1490" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="113" endline="128">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             result = m_TypeName.ResolveTypeReferences AndAlso result
         End If
 
         If m_When IsNot Nothing Then
             result = m_When.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1491" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="41" endline="52">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameters IsNot Nothing Then
             result = m_TypeParameters.ResolveTypeReferences AndAlso result
         End If
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1493" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="671" endline="682">
<![CDATA[
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1497" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="155" endline="166">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_GeneratedCode = False Then
             If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.GenerateCode(Info) AndAlso result
 
             m_GeneratedCode = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1498" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="52" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then result = m_Clauses.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1507" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="186" endline="197">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_LoopControlVariable IsNot Nothing Then result = m_LoopControlVariable.ResolveTypeReferences AndAlso result
         If m_InExpression IsNot Nothing Then result = m_InExpression.ResolveTypeReferences AndAlso result
         If m_NextExpression IsNot Nothing Then result = m_NextExpression.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1509" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1512" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="779" endline="788">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1)
         If chr = "X"c Then
             Return Nothing
         Else
             Return GetTypeCodeOfChar(chr)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1515" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ThrowStatement.vb" startline="53" endline="64">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Exception IsNot Nothing Then
             result = m_Exception.ResolveExpression(Info) AndAlso result
             If result = False Then Return result
             result = Helper.VerifyValueClassification(m_Exception, Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1517" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="145" endline="155">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameterConstraints IsNot Nothing Then
             result = m_TypeParameterConstraints.ResolveTypeReferences AndAlso result
             result = DefineParameterConstraints() AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1518" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="59" endline="71">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
 
         If m_Declaration IsNot Nothing Then result = m_Declaration.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1519" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="116" endline="123">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_TypeName, m_ArgumentList, m_VariableInitializer) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1533" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1720" endline="1747">
<![CDATA[
 
     ''' <summary>
     ''' Finds the parent namespace of the specified namespace.
     ''' "NS1.NS2" => "NS1"
     ''' "NS1" => ""
     ''' "" => Nothing
     ''' Nothing =>InternalException()
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetNamespaceParent(ByVal [Namespace] As String) As String
         If [Namespace] Is Nothing Then
             Throw New InternalException("")
         ElseIf [Namespace] = String.Empty Then
             Return Nothing
         Else
             Dim dotIdx As Integer
             dotIdx = [Namespace].LastIndexOf("."c)
             If dotIdx > 0 Then
                 Return [Namespace].Substring(0, dotIdx)
             ElseIf dotIdx = 0 Then
                 Throw New InternalException("A namespace starting with a dot??")
             Else
                 Return String.Empty
             End If
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1534" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="46" endline="53">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedLabel IsNot Nothing Then result = m_ResolvedLabel.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1535" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="797" endline="806">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1 + op2 * 19)
         If chr = "X"c Then
             Return Nothing
         Else
             Return CType(Microsoft.VisualBasic.Asc(chr) - Microsoft.VisualBasic.Asc("A"), TypeCode)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1538" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="51" endline="58">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArraySizeInitModifier IsNot Nothing Then result = m_ArraySizeInitModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1539" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2021" endline="2028">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Cecil.TypeReference(), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Length - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(t, TypeToFind) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1542" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="63" endline="73">
<![CDATA[
 
     Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To Count - 1
             Dim pO As BaseObject = TryCast(CObj(Item(i)), BaseObject)
             If pO IsNot Nothing Then
                 result = pO.ResolveCode(Info) AndAlso result
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1543" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="52" endline="61">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_PreCondition, m_PostCondition) AndAlso result
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1544" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="58" endline="65">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As String) As LiteralTypeCharacters_Characters
         chr = chr.ToUpperInvariant
         For i As Integer = 0 To m_Characters.GetUpperBound(0)
             If m_Characters(i).Equals(chr, StringComparison.Ordinal) Then Return CType(i + 1, LiteralTypeCharacters_Characters)
         Next
         Return LiteralTypeCharacters_Characters.None
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1545" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveTypeReferences AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1546" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="150" endline="159">
<![CDATA[
     End Property
 #End If
 
     Function AcceptSequence(ByVal ParamArray ks As KS()) As Boolean
         For i As Integer = 0 To ks.GetUpperBound(0)
             If Me.PeekToken(i).Equals(ks(i)) = False Then Return False
         Next
         Me.NextToken(ks.GetUpperBound(0) + 1)
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1548" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="405" endline="413">
<![CDATA[
 
     Function AcceptEndOfFile() As Boolean
         If CurrentToken.IsEndOfFile Then
             NextToken()
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1549" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="25" endline="32">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1562" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="311" endline="323">
<![CDATA[
 
     Function ResolveAddressOfExpression(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Dim aoe As AddressOfExpression = TryCast(Me, AddressOfExpression)
 
         If aoe Is Nothing Then
             result = False
         Else
             result = aoe.Resolve(DelegateType) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1563" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="80" endline="88">
<![CDATA[
     End Property
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1564" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\BlockStatement.vb" startline="47" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         '#If DEBUG Then
         '        Dim m1, m2 As MethodInfo
         '        m1 = Me.GetType.GetMethod("ResolveTypeReferences")
         '        m2 = GetType(BlockStatement).GetMethod("ResolveTypeReferences")
         '        Helper.Assert(m1 IsNot m2)
         '#End If
 
         result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1565" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="71" endline="78">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ConstraintList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1566" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1567" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="120" endline="129">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1568" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="398" endline="406">
<![CDATA[
 
     Function GenerateMy() As Boolean
         Dim result As Boolean = True
         Dim generator As New MyGenerator(Me)
 
         result = generator.Generate() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1569" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" startline="35" endline="44">
<![CDATA[
 
     ReadOnly Property AsTypeArray() As Type()
         Get
             Dim t As Type = GetType(System.Collections.Generic.Dictionary(Of ,))
             Dim result(m_TypeParameters.Length - 1) As Type
             For i As Integer = 0 To result.Length - 1
                 'result(i) = m_TypeParameters(i).Parameters
             Next
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1572" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="93" endline="102">
<![CDATA[
     End Property
 
     ReadOnly Property RaiseDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RaiseMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RaiseMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1573" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="417" endline="453">
<![CDATA[
 
     ''' <summary>
     ''' - All code is emitted for fields with initializers.
     ''' - All the code is emitted for each and every method, constructor, operator and property.
     ''' - Classes, modules, structures, methods, constructors, properties, events, operators should implement IEmittable.Emit(Info as EmitInfo)
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Emit() As Boolean
         Dim result As Boolean = True
 
         result = EmitAttributes() AndAlso result
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Yellow
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Emit " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = Emit(type) AndAlso result
         Next
 
         SetFileVersion()
         SetAdditionalAttributes()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1574" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="520" endline="529">
<![CDATA[
 
     Function AcceptAny(ByVal ParamArray Keywords() As KS) As Boolean
         Dim i As Integer
         For i = 0 To Keywords.Length - 1
             If Accept(Keywords(i)) Then
                 Return True
             End If
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1575" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="169" endline="176">
<![CDATA[
 
     Function IsNamespaceExact(ByVal A As String, ByVal B As String) As Boolean
         For i As Integer = 0 To Me.Count - 1
             Dim ns As [Namespace] = Me.Item(i)
             If ns.Equals(A, B) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1576" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="53" endline="63">
<![CDATA[
     End Property
 
     ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Dim exp As Expression = InitializerExpression
             If exp IsNot Nothing Then
                 Return exp.ExpressionType
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1577" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="31" endline="37">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_VariableInitializerList IsNot Nothing Then result = m_VariableInitializerList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1578" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="101" endline="112">
<![CDATA[
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         If tm.CurrentToken = KS.LParenthesis Then
             If tm.PeekToken.Equals(KS.Comma, KS.RParenthesis) Then
                 Return False
             Else
                 Return True
             End If
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1583" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="37" endline="46">
<![CDATA[
 
     Function AsTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
 
         For i As Integer = 0 To Me.Count - 1
             result(i) = Item(i).CecilBuilder
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1609" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="211" endline="218">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = VerifyConstraints() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1611" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="160" endline="173">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_Signature IsNot Nothing Then result = m_Signature.ResolveTypeReferences AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveTypeReferences AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveTypeReferences AndAlso result
 
         If m_MemberImplementsClause IsNot Nothing Then result = m_MemberImplementsClause.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1613" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="138" endline="146">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1614" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="88" endline="95">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_Handlers.Length - 1
             result = m_Handlers(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1615" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="89" endline="100">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1617" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="270" endline="279">
<![CDATA[
 
     Shared Function IsOnMono() As Boolean
         Dim t As Type = GetType(Integer)
 
         If t.GetType().ToString = "System.MonoType" Then
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1618" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="36" endline="43">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1619" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="456" endline="471">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIntegerLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIntegerLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1621" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="52" endline="60">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then result = m_ParameterList.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1622" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2198" endline="2205">
<![CDATA[
 
 
     <Diagnostics.DebuggerHidden()> Shared Function AddError(ByVal Compiler As Compiler, ByVal Location As Span, Optional ByVal Message As String = Nothing) As Boolean
         If Message Is Nothing Then
             Message = "<no message written yet>"
         End If
         Return Compiler.Report.ShowMessage(Messages.VBNC99999, Location, Message)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1623" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2566" endline="2573">
<![CDATA[
 
     Shared Sub SetTypeOrTypeBuilder(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference())
         If Type Is Nothing Then Return
         For i As Integer = 0 To Type.Length - 1
             Helper.Assert(Type(i) IsNot Nothing)
             Type(i) = GetTypeOrTypeBuilder(Compiler, Type(i))
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1624" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" startline="55" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeParameters.Length - 1
             If m_TypeParameters(i) IsNot Nothing Then
                 result = m_TypeParameters(i).ResolveTypeReferences() AndAlso result
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1625" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="146" endline="157">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If m_Condition IsNot Nothing Then result = m_Condition.ResolveTypeReferences AndAlso result
         If m_ElseIfs IsNot Nothing Then result = m_ElseIfs.ResolveTypeReferences AndAlso result
         If m_FalseCode IsNot Nothing Then result = m_FalseCode.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1626" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="53" endline="60">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1627" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="37" endline="44">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_List.Count - 1
             result = m_List(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1628" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="173" endline="190">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim stn As SimpleTypeName
         Dim ctn As ConstructedTypeName
 
         stn = TryCast(m_TypeName, SimpleTypeName)
         If stn IsNot Nothing Then
             result = stn.ResolveCode(Info) AndAlso result
         Else
             ctn = TryCast(m_TypeName, ConstructedTypeName)
             If ctn IsNot Nothing Then
                 result = ctn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1630" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="125" endline="132">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1631" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1633" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="136" endline="149">
<![CDATA[
 
 #If DEBUG Then
     ReadOnly Property TokenSequence() As String
         Get
             Const Range As Integer = 3
             Dim result As String = ""
             For i As Integer = -Range To Range
                 'If Me.IsTokenValid(Me.iCurrentToken + i) Then
                 'result &= "(" & i.ToString & ")
                 result &= Me.PeekToken(i).ToString & " "
                 'End If
             Next
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1634" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="130" endline="139">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveCode(Info) AndAlso result
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1635" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2910" endline="2928">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if all types in both arrays are the exact same types.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareTypes(ByVal Types1() As Mono.Cecil.TypeReference, ByVal Types2() As Mono.Cecil.TypeReference) As Boolean
         If Types1 Is Nothing AndAlso Types2 Is Nothing Then
             Return True
         ElseIf Types1 Is Nothing Xor Types2 Is Nothing Then
             Return False
         Else
             If Types1.Length <> Types2.Length Then Return False
             For i As Integer = 0 To Types1.Length - 1
                 If Helper.CompareType(Types1(i), Types2(i)) = False Then Return False
             Next
             Return True
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1636" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1637" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="170" endline="177">
<![CDATA[
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1638" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="42" endline="51">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         ' result = Helper.ResolveTypeReferences(m_UsingResources) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1639" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="121" endline="130">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         result = Helper.ResolveTypeReferences(m_ConstantExpression) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1642" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="43" endline="50">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info) AndAlso result 'Helper.NotImplemented()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1643" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="32" endline="38">
<![CDATA[
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AttributeArgumentExpression.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1644" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="54" endline="63">
<![CDATA[
 
     Public Function Parse(ByVal RootNamespace As String, ByVal assembly As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = ParseAssemblyDeclaration(RootNamespace, assembly) AndAlso result
 
         result = Compiler.Report.Errors = 0 AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1645" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="152" endline="163">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         result = m_ParameterList.ResolveCode(info) AndAlso result
         If m_TypeParameters IsNot Nothing Then result = m_TypeParameters.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1646" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="532" endline="540">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         'Define type parameters
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1647" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="64" endline="72">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Initializer.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1648" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="46" endline="53">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1649" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="57" endline="66">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Operand.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1650" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="336" endline="350">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Compares this token to any of the specified tokens. 
     ''' Returns true if any token matches.
     ''' </summary>
     ''' <param name="AnySpecial"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Overloads Function Equals(ByVal AnySpecial() As KS) As Boolean
         For i As Integer = 0 To VB.UBound(AnySpecial)
             If Equals(AnySpecial(i)) = True Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1652" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="50" endline="57">
<![CDATA[
 
     Shared Function GetBuiltInType(ByVal chr As LiteralTypeCharacters_Characters) As BuiltInDataTypes
         If chr = LiteralTypeCharacters_Characters.None Then
             Throw New InternalException("")
         Else
             Return m_Types(chr - 1)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1654" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="165" endline="172">
<![CDATA[
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1655" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="109" endline="115">
<![CDATA[
 
     Sub NextToken(ByVal Jump As Integer)
         Helper.Assert(Jump >= 0)
         For i As Integer = 1 To Jump
             NextToken()
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1656" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="166" endline="176">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1669" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="51" endline="59">
<![CDATA[
 
     Public Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         result = AddAttribute() AndAlso result
         result = MyBase.DefineType() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1670" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="222" endline="243">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             'If IsLocalVariable Then
             '    If m_LocalBuilder Is Nothing Then result = DefineLocalVariable(Info) AndAlso result
             '    Helper.Assert(m_LocalBuilder IsNot Nothing)
             '    result = EmitVariableInitializer(Info) AndAlso result
             'ElseIf Me.Modifiers.Is(ModifierMasks.Static) Then
             '    result = EmitStaticInitializer(Info) AndAlso result
             'Else
             '    'Field builder has been defined in DefineMember
             '    'EmitVariableInitializer will be called by the constructor declaration
             'End If
 
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1671" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="228" endline="236">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1672" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="129" endline="147">
<![CDATA[
 
     ''' <summary>
     ''' This creates the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Declaration IsNot Nothing Then
             result = m_Declaration.DefineLocalVariable(Info) AndAlso result
             result = m_Declaration.GenerateCode(Info) AndAlso result
         Else
             'm_LoopVariableBuilder()
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1673" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="96" endline="106">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then
             result = m_Clauses.ResolveStatements(Info) AndAlso result
         End If
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1675" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="96" endline="103">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1676" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="412" endline="419">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = GenerateCodeInternal(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1677" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="486" endline="507">
<![CDATA[
 
     Function GenerateMyLog() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        Private Shared ReadOnly m_LogObjectProvider As ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog) = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)" & VB.vbNewLine & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Application.Log"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Log As Global.Microsoft.VisualBasic.Logging.AspLog" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Return MyProject.m_LogObjectProvider.GetInstance" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         'ProjectCodeCctor.AppendLine("            m_LogObjectProvider = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1678" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LSide.ResolveTypeReferences AndAlso result
         result = m_RSide.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1679" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="58" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1680" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="125" endline="136">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_Event.ResolveExpression(Info) AndAlso result
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Compiler.Helper.AddCheck("The result of the expression must be classified as an event access for an event defined in the class itself; ")
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1689" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="55" endline="62">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1690" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="81" endline="88">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1691" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="49" endline="58">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveTypeReferences AndAlso result
         result = m_RightExpression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1692" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="176" endline="184">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         If m_ConstantExpression IsNot Nothing Then result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1693" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="223" endline="234">
<![CDATA[
 
     Private Function ResolveQualifiedName(ByVal Qualifier As TypeNameResolutionInfo, ByVal R1 As String, ByVal R2 As String, ByVal TypeArgumentCount As Integer) As Boolean
         Dim result As Boolean = True
 
         result = ResolveQualifiedNameInternal(Qualifier, R1, R2 Is Nothing, TypeArgumentCount) AndAlso result
 
         If result = False AndAlso R2 IsNot Nothing Then
             result = ResolveQualifiedNameInternal(Qualifier, R2, True, TypeArgumentCount) 'AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1694" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="105" endline="114">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1695" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1970" endline="1977">
<![CDATA[
 
     Shared Function CreateGenericTypename(ByVal Typename As String, ByVal TypeArgumentCount As Integer) As String
         If TypeArgumentCount = 0 Then
             Return Typename
         Else
             Return String.Concat(Typename, "`", TypeArgumentCount.ToString)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1696" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4863" endline="4877">
<![CDATA[
 
     Private Function ParseTypeVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As New Generic.List(Of TypeVariableDeclaration)
         Dim tmp As Boolean
 
         'Console.Write("ParseTypeVariableDeclarator...")
         tmp = ParseVariableDeclarator(Parent, Modifiers, Info, result, False)
         'Console.WriteLine("tmp
         If tmp = False Then
             'Console.WriteLine("tmp was false")
             Return Nothing
         End If
         'Console.WriteLine("tmp was true")
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1697" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="36" endline="45">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Lock) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1700" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="227" endline="243">
<![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveTypeReferences " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveTypeReferences(type) AndAlso result
         Next
 
         result = m_Attributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1701" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="299" endline="314">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences AndAlso result
         If result = False Then Return result
 
         ReturnType = m_Signature.ReturnType
 
         If m_Code IsNot Nothing Then result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1702" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="61" endline="70">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1703" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="55" endline="62">
<![CDATA[
     End Property
 
     Function FindNamespace(ByVal A As String, ByVal B As String) As [Namespace]
         For i As Integer = 0 To Count - 1
             If Item(i).Equals(A, B) Then Return Item(i)
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1705" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="132" endline="141">
<![CDATA[
     End Property
 
     ReadOnly Property CandidatesLeft() As Integer
         Get
             Dim result As Integer
             For i As Integer = 0 To m_Candidates.Count - 1
                 If m_Candidates(i) IsNot Nothing Then result += 1
             Next
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1706" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="117" endline="125">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AssignStatement.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1707" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="66" endline="88">
<![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         'Dim m_MethodAttributes As MethodAttributes
         'If m_HandlerType = KS.RaiseEvent Then
         '    m_MethodAttributes = m_MethodAttributes Or MethodAttributes.Private
         'Else
         '    m_MethodAttributes = m_MethodAttributes Or Me.Modifiers.GetMethodAttributeScope
         'End If
         'm_MethodAttributes = m_MethodAttributes Or MethodAttributes.SpecialName
         'If DeclaringType.IsInterface Then
         '    m_MethodAttributes = m_MethodAttributes Or Reflection.MethodAttributes.Abstract Or Reflection.MethodAttributes.Virtual Or MethodAttributes.CheckAccessOnOverride Or MethodAttributes.NewSlot
         'End If
         'If Me.IsShared Then
         '    m_MethodAttributes = m_MethodAttributes Or MethodAttributes.Static
         'End If
         'MyBase.Attributes = m_MethodAttributes
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1710" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="157" endline="186">
<![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeDeclarations.Length - 1
             Dim type As TypeDeclaration = m_TypeDeclarations(i)
 
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Green
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveCode " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = type.ResolveCode(Info) AndAlso result
             Compiler.VerifyConsistency(result, type.Location)
         Next
 
         result = m_Attributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1711" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="44" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Target IsNot Nothing Then result = m_Target.ResolveTypeReferences AndAlso result
         If m_Start IsNot Nothing Then result = m_Start.ResolveTypeReferences AndAlso result
         If m_Length IsNot Nothing Then result = m_Length.ResolveTypeReferences AndAlso result
         If m_Source IsNot Nothing Then result = m_Source.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1714" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" startline="47" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_List.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1715" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="181" endline="192">
<![CDATA[
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         'Helper.SetTypeOrTypeBuilder(Compiler, ParameterTypes)
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1716" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="83" endline="92">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1717" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="58" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1718" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="178" endline="187">
<![CDATA[
 
     Public Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then result = m_ImplementsClause.ResolveCode(Info) AndAlso result
 
         Helper.Assert(EventType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1719" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="107" endline="119">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info Is Nothing Then
             Info = New EmitInfo(Me)
         End If
 
         result = DefineHandlesOrImplements() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1720" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="53" endline="61">
<![CDATA[
 
     ReadOnly Property AsExpressions() As Expression()
         Get
             Dim result(Me.Count - 1) As Expression
             For i As Integer = 0 To Me.Count - 1
                 result(i) = Item(i).Expression
             Next
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1721" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3398" endline="3407">
<![CDATA[
 
     Shared Function ArgumentsToExpressions(ByVal Arguments As Generic.List(Of Argument)) As Expression()
         Dim result(Arguments.Count - 1) As Expression
 
         For i As Integer = 0 To Arguments.Count - 1
             result(i) = Arguments(i).Expression
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1722" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="37" endline="45">
<![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If ThirdPart Is Nothing AndAlso TypeOf Condition Is NothingConstantExpression AndAlso TypeOf SecondPart Is NothingConstantExpression Then Return True
             If Not Condition.IsConstant Then Return False
             If Not SecondPart.IsConstant Then Return False
             If ThirdPart IsNot Nothing AndAlso Not ThirdPart.IsConstant Then Return False
             Return True
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1723" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="82" endline="98">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a string array with all the namespaces.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property NamespacesAsString() As String()
         Get
             Dim result(Count - 1) As String
             Dim tmp() As [Namespace] = Me.ToArray
             For i As Integer = 0 To Count - 1
                 result(i) = tmp(i).Name
             Next
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1724" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="530" endline="537">
<![CDATA[
     Function AcceptAll(ByVal ParamArray Specials() As KS) As Boolean
         Dim i As Integer
         AcceptAll = True
         For i = 0 To Specials.Length - 1
             AcceptAll = PeekToken(i).Equals(Specials(i)) AndAlso AcceptAll
         Next
         If AcceptAll Then NextToken(Specials.Length)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1725" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="126" endline="141">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression.IsResolved = False Then
             result = m_Expression.ResolveExpression(Info) AndAlso result
         End If
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
         Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1726" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1978" endline="1985">
<![CDATA[
 
     Shared Function CreateArray(Of T)(ByVal Value As T, ByVal Length As Integer) As T()
         Dim result(Length - 1) As T
         For i As Integer = 0 To Length - 1
             result(i) = Value
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1727" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="38" endline="47">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Condition) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1728" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="36" endline="43">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_WithExpression) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1729" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="34" endline="46">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.LateBoundAccess.Name Is Nothing Then
             result = EmitLateIndexGet(Info) AndAlso result
         Else
             result = EmitLateGet(Info) AndAlso result
         End If
 
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1730" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2087" endline="2094">
<![CDATA[
 
     Shared Function ResolveTypeReferences(ByVal ParamArray Collection As ParsedObject()) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             If obj IsNot Nothing Then result = obj.ResolveTypeReferences AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1811" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="40" endline="48">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1812" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="58" endline="66">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1813" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="59" endline="67">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1814" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="47" endline="56">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.ResolveExpression(info) AndAlso result
 
         Compiler.Helper.AddCheck("The expression must be classified as a value and its type must be implicitly convertible to Integer.")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1815" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="68" endline="75">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1816" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="281" endline="288">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1817" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="67" endline="74">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1818" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="188" endline="195">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1819" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="77" endline="84">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1820" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\LiteralTypeCharacters.vb" startline="66" endline="73">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As LiteralTypeCharacters_Characters) As String
         If chr = LiteralTypeCharacters_Characters.None Then
             Return ""
         Else
             Return m_Characters(chr - 1)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1821" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1822" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1823" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1824" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1826" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="298" endline="307">
<![CDATA[
 
     Friend Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal Types() As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Types.Length = Me.Count)
 
         For i As Integer = 0 To Count - 1
             result = Item(i).GenerateCode(Info.Clone(Me, True, False, Types(i)), Nothing) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1827" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="53" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences() AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1828" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4854" endline="4862">
<![CDATA[
 
     Private Function ParseLocalVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As New Generic.List(Of LocalVariableDeclaration)
         If ParseVariableDeclarator(Parent, Modifiers, Info, result, True) = False Then
             Console.WriteLine("Returned false")
             Return Nothing
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1829" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="32" endline="40">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParameterTypes() As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         If ParameterTypes IsNot Nothing Then
             For Each t As Mono.Cecil.TypeReference In ParameterTypes
                 Add("", t)
             Next
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1832" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="331" endline="353">
<![CDATA[
 
 
     ''' <summary>
     ''' - Types are defined with the reflection.emit namespace. 
     ''' - Only classes, modules, structures, interfaces, enums, delegates and eventnos (not a type by itself, bu an event might declare a new delegate). They are only defined, nothing else.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineType()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypes() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypes " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineType(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1833" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="354" endline="376">
<![CDATA[
 
     ''' <summary>
     ''' - Base classes for classes, modules, structures, enums, interfaces and delegates are set.
     ''' - Implemented interfaces for classes are set.
     ''' - Type parameters for classes and structures are set.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineTypeHierarchy()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypeHierarchy " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineTypeHierarchy(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1834" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="377" endline="406">
<![CDATA[
 
     ''' <summary>
     ''' - All the type's members are defined (methods, constructors, properties, fields, events, operators).
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineMembers() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Green
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineMembers " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = DefineMembers(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1837" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="49" endline="59">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_ArrayElementInitializer IsNot Nothing Then result = m_ArrayElementInitializer.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1838" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="118" endline="127">
<![CDATA[
 
 
     Public Function ResolveEarly() As Boolean
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
         result = ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1839" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="100" endline="114">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         Helper.Assert(VariableType IsNot Nothing)
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1840" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1841" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="59" endline="66">
<![CDATA[
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1842" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="121" endline="128">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1843" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="141" endline="149">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         'vbnc.Helper.Assert(result = (Compiler.Report.Errors = 0))
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1844" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="409" endline="416">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1845" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="50" endline="64">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns the specified argument, or nothing if index is out of range
     ''' </summary>
     ''' <param name="Index"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetArgument(ByVal Index As Integer) As Object
         If m_Arguments IsNot Nothing AndAlso Index < m_Arguments.Length Then
             Return m_Arguments(Index)
         Else
             Return Nothing
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1846" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="92" endline="100">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveCode(Info) AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1847" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="219" endline="228">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveCode(Info) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1848" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="57" endline="65">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Helper.GenerateCodeCollection(m_Clauses, Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1849" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1850" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1853" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="168" endline="178">
<![CDATA[
 
     Overridable Overloads Function ResolveTypeReferences(ByVal ResolveTypeParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         result = m_ParameterList.ResolveTypeReferences AndAlso result
         If ResolveTypeParameters = True AndAlso m_TypeParameters IsNot Nothing Then result = m_TypeParameters.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1854" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="76" endline="85">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         If m_TypeParameter IsNot Nothing Then result = m_TypeParameter.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1855" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="240" endline="251">
<![CDATA[
 
     Private Sub Flatten(ByVal Name As String, ByVal Visibility As MemberVisibility)
         Dim bases As List(Of MemberCache) = GetBaseCache()
 
         If bases.Count = 0 Then
             Flatten(Name, Nothing, Visibility)
         Else
             For i As Integer = 0 To bases.Count - 1
                 Flatten(Name, bases(i), Visibility)
             Next
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1858" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="296" endline="310">
<![CDATA[
 
     Function ResolveMembers() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveMembers " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveMembers(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1859" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="143" endline="161">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim atn As ArrayTypeName
         Dim natn As NonArrayTypeName
 
         atn = TryCast(m_TypeName, ArrayTypeName)
         If atn IsNot Nothing Then
             result = atn.ResolveCode(Info) AndAlso result
         Else
             natn = TryCast(m_TypeName, NonArrayTypeName)
             If natn IsNot Nothing Then
                 result = natn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1860" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Defines.vb" startline="41" endline="55">
<![CDATA[
 
     Function IsDefined(ByVal str As String) As Boolean
         Dim def As Define
         def = Item(str)
         If def Is Nothing Then Return False
 
         If def.Value <> "" Then
             Dim b As Boolean
             If Boolean.TryParse(def.Value, b) Then Return b
             If VB.IsNumeric(def.Value) Then Return CBool(CDbl(def.Value))
             Return False
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1861" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="325" endline="332">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1862" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="62" endline="69">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Expressions) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1863" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="64" endline="71">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Targets.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1864" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="315" endline="322">
<![CDATA[
 
     Public Overridable Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         result = m_Signature.Parameters.ResolveParameters(Info, True) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1865" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1866" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1867" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="90" endline="98">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Lock.ResolveExpression(INfo) AndAlso result
         result = CodeBlock.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1868" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="54" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Type IsNot Nothing Then
             result = m_Type.ResolveTypeReferences AndAlso result
             EventType = m_Type.ResolvedType
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1869" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="73" endline="87">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
 
         Classification = New ValueClassification(Me, Me.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1870" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="80" endline="98">
<![CDATA[
 
     ''' <summary>
     ''' Resolves either all optional parameters or all non-optional parameters.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="OptionalParameters"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function ResolveParameters(ByVal Info As ResolveInfo, ByVal OptionalParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Count - 1
             If Me(i).Modifiers.Is(ModifierMasks.Optional) = OptionalParameters Then
                 result = Me(i).ResolveCode(Info) AndAlso result
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1871" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2574" endline="2590">
<![CDATA[
 
     Shared Function GetTypeOrTypeBuilders(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference(), Optional ByVal OnlySuccessful As Boolean = False) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         If Type Is Nothing Then Return Nothing
 
         ReDim result(Type.GetUpperBound(0))
         For i As Integer = 0 To Type.GetUpperBound(0)
             Dim tmp As Mono.Cecil.TypeReference
             tmp = GetTypeOrTypeBuilder(Compiler, Type(i))
             If tmp Is Nothing AndAlso OnlySuccessful Then
                 result(i) = Type(i)
             Else
                 result(i) = tmp
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1872" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="87" endline="103">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Test.ResolveExpression(Info) AndAlso result
         If result = False Then Return False
 
         result = Helper.VerifyValueClassification(m_Test, Info) AndAlso result
         If result = False Then Return False
 
         m_CachedTest = New CachedExpression(m_Test, m_Test)
 
         result = m_Cases.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Check that there is at most one else block, and only at the end.")
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1873" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="56" endline="71">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_InterfaceBases IsNot Nothing Then
             result = m_InterfaceBases.ResolveTypeReferences AndAlso result
             For i As Integer = 0 To m_InterfaceBases.Bases.Length - 1
                 AddInterface(m_InterfaceBases.Bases(i).ResolvedType)
             Next
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1874" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="66" endline="77">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Clauses.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Each clause in the statement must be classified as a variable or a property access whose type is an array type or Object, and be followed by a list of array bounds. ")
         Compiler.Helper.AddCheck("The number of the bounds must be consistent with the type of the variable; any number of bounds is allowed for Object.")
         Compiler.Helper.AddCheck("If the Preserve keyword is specified, then the expressions must also be classifiable as a value, and the new size for each dimension except for the rightmost one must be the same as the size of the existing array. ")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1875" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="71" endline="80">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1876" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1877" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="34" endline="42">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1878" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="108" endline="118">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_UsingResources.ResolveCode(Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1880" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1881" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="79" endline="88">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_Condition, Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1882" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="984" endline="992">
<![CDATA[
 
     Function FindTypeWithFullname(ByVal Fullname As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.FullName, Fullname) Then Return tD
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1883" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="85" endline="94">
<![CDATA[
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         Helper.Assert(Me.DeclaringType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1884" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="311" endline="320">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.CustomAttributes IsNot Nothing Then
             result = Me.CustomAttributes.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1886" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="429" endline="445">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if the current token is an identifier
     ''' and advances to the next token.
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIdentifier(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIdentifier Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1887" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="446" endline="455">
<![CDATA[
 
     Function AcceptStringLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsStringLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1888" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="30" endline="41">
<![CDATA[
 
     Private Function CheckIndexedStatement(ByVal Info As ResolveInfo, ByVal InvocationExpression As InvocationOrIndexExpression) As Boolean
         Dim result As Boolean = True
 
         If InvocationExpression Is Nothing Then Return result
 
         If InvocationExpression.Classification.IsVariableClassification AndAlso CecilHelper.IsArray(InvocationExpression.Expression.ExpressionType) Then
             result = ResolveIndexedStatement(Info, InvocationExpression) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1889" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2229" endline="2237">
<![CDATA[
 
     Shared Function IsDebugging() As Boolean
         'Return False
         If Diagnostics.Debugger.IsAttached = False Then Return False
         If Reflection.Assembly.GetEntryAssembly Is Nothing Then Return False
         If Reflection.Assembly.GetEntryAssembly.FullName.Contains("rt") Then Return False
         If AppDomain.CurrentDomain.FriendlyName.Contains("rt") Then Return False
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1890" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="51" endline="59">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_AttributePositionalArgumentList IsNot Nothing Then result = m_AttributePositionalArgumentList.ResolveCode(info) AndAlso result
         If m_VariablePropertyInitializerList IsNot Nothing Then result = m_VariablePropertyInitializerList.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1892" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1415" endline="1428">
<![CDATA[
 
     Shared Function GetTypes(ByVal Arguments As Generic.List(Of Argument)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference = New Mono.Cecil.TypeReference() {}
 
         If Arguments Is Nothing Then Return result
         ReDim result(Arguments.Count - 1)
         For i As Integer = 0 To Arguments.Count - 1
             Helper.Assert(Arguments(i) IsNot Nothing)
             If Arguments(i) IsNot Nothing AndAlso Arguments(i).Expression IsNot Nothing Then
                 result(i) = Arguments(i).Expression.ExpressionType
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1893" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1733" endline="1764">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if a leave instruction is necessary to jump from one statement to the other.
     ''' If ToStatement is nothing then it is assumed a ret instruction is about to be emitted.
     ''' </summary>
     ''' <param name="FromStatement"></param>
     ''' <param name="ToStatement"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsLeaveNecessary(ByVal FromStatement As Statement, ByVal ToStatement As Statement) As Boolean
         Dim result As Boolean
 
         If ToStatement Is Nothing Then
             result = FromStatement.FindParentCodeBlock.UpmostBlock.HasUnstructuredExceptionHandling
         End If
 
         If result = False Then
             Dim parentStmt As Statement = FromStatement
             Do Until parentStmt Is ToStatement OrElse parentStmt Is Nothing
                 result = result OrElse TypeOf parentStmt Is TryStatement
                 result = result OrElse TypeOf parentStmt Is SyncLockStatement
                 result = result OrElse TypeOf parentStmt Is ForEachStatement
                 result = result OrElse TypeOf parentStmt Is UsingStatement
                 result = result OrElse TypeOf parentStmt Is CatchStatement
 
                 If result Then Exit Do
 
                 parentStmt = parentStmt.Parent.FindFirstParent(Of Statement)()
             Loop
             Do Until parentStmt Is ToStatement OrElse parentStmt Is Nothing
                 result = result OrElse TypeOf parentStmt Is TryStatement
                 result = result OrElse TypeOf parentStmt Is SyncLockStatement
                 result = result OrElse TypeOf parentStmt Is ForEachStatement
                 result = result OrElse TypeOf parentStmt Is UsingStatement
                 result = result OrElse TypeOf parentStmt Is CatchStatement
 
                 If result Then Exit Do
 
                 parentStmt = parentStmt.Parent.FindFirstParent(Of Statement)()
             Loop
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1895" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="408" endline="421">
<![CDATA[
 
     ReadOnly Property UpmostBlock() As CodeBlock
         Get
             Dim result As CodeBlock = Nothing
             Dim tmp As CodeBlock
 
             tmp = Me
             Do Until tmp Is Nothing
                 result = tmp
                 tmp = tmp.FindFirstParent(Of CodeBlock)()
             Loop
             Do Until tmp Is Nothing
                 result = tmp
                 tmp = tmp.FindFirstParent(Of CodeBlock)()
             Loop
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1898" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="83" endline="92">
<![CDATA[
     End Property
 
     ReadOnly Property RemoveDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RemoveMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RemoveMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1899" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="45" endline="51">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.AsMethodPointerClassification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1900" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="79" endline="88">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Catches.ResolveCode(Info) AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveCode(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1901" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="975" endline="983">
<![CDATA[
 
     Function FindTypeWithName(ByVal Name As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.Name, Name) Then Return tD
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1902" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="258" endline="268">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Get IsNot Nothing Then result = m_Get.GenerateCode(Info) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.GenerateCode(Info) AndAlso result
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1903" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="549" endline="562">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             result = m_Variables(i).ResolveTypeReferences AndAlso result
         Next
 
         For i As Integer = 0 To m_Statements.Count - 1
             result = m_Statements(i).ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1931" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3488" endline="3497">
<![CDATA[
 
     Shared Function IsLiteral0Expression(ByVal Compiler As Compiler, ByVal exp As Expression) As Boolean
         If exp Is Nothing Then Return False
         Dim litExp As LiteralExpression = TryCast(exp, LiteralExpression)
         If litExp Is Nothing Then Return False
         If litExp.ConstantValue Is Nothing Then Return False
         If Compiler.TypeResolution.IsIntegralType(CecilHelper.GetType(Compiler, litExp.ConstantValue)) = False Then Return False
         If CDbl(litExp.ConstantValue) = 0.0 Then Return True
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1933" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="68" endline="77">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1934" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1935" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1936" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="383" endline="390">
<![CDATA[
 
     Public Overloads Function Equals(ByVal Special As KS) As Boolean
         If m_TokenType = TokenType.Keyword OrElse m_TokenType = TokenType.Symbol Then
             Return CInt(m_TokenObject) = CInt(Special)
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1937" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="115" endline="124">
<![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1938" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="55" endline="66">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info) AndAlso result
         End If
 
         Emitter.EmitLoadVariable(Info, m_Field)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1940" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="76" endline="84">
<![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.PropertyReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1941" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="473" endline="489">
<![CDATA[
 
     ''' <summary>
     ''' Intrinsic type
     ''' </summary>
     ''' <param name="Compiler"></param>
     ''' <param name="Type"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsIntrinsicType(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Dim tC As TypeCode = GetTypeCode(Compiler, Type)
 
         If tC = TypeCode.Object Then
             Return Helper.CompareType(Type, Compiler.TypeCache.System_Object)
         Else
             Return True
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1942" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="147" endline="154">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1943" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="94" endline="123">
<![CDATA[
 
     '''' <summary>
     '''' Checks that all types are equal.
     '''' Returns nothing if types are not equal.
     '''' </summary>
     '''' <param name="Types"></param>
     '''' <returns></returns>
     '''' <remarks></remarks>
     'Private Function CheckUniqueType(ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
     '    Helper.Assert(Types.Length >= 1)
     '    For i As Integer = 1 To Types.Length - 1
     '        If Helper.CompareType(Types(0), Types(i)) = False Then Return Nothing
     '    Next
     '    Return Types(0)
     'End Function
 
     ''' <summary>
     ''' Checks that all types are equal.
     ''' Returns nothing if types are not equal.
     ''' </summary>
     ''' <param name="Types"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function CheckUniqueType(ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(Types.Length >= 1)
         For i As Integer = 1 To Types.Length - 1
             If Helper.CompareType(Types(0), Types(i)) = False Then Return Nothing
         Next
         Return Types(0)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1944" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6104" endline="6120">
<![CDATA[
 
     ''' <summary>
     ''' Parses a imports statement as specified on the commandline.
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Shared Function ParseImportsStatement(ByVal Parent As ImportsStatement, ByVal str As String) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Parent IsNot Nothing)
         Helper.Assert(Parent.Clauses IsNot Nothing)
 
         result = ParseImportsClauses(Parent.Clauses, str) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1945" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="30" endline="38">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Expression) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1949" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="323" endline="336">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         result = ResolveOverrides() AndAlso result
         result = m_Signature.ResolveCode(Info) AndAlso result
 
         If m_Code IsNot Nothing Then
             result = m_Code.ResolveCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1952" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="187" endline="204">
<![CDATA[
 
     Function CreateImplicitTypes() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitTypes " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitTypes = TryCast(Type, IHasImplicitTypes)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitTypes AndAlso result
 
             result = CreateImplicitTypes(Type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1953" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="45" endline="57">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim nullExp As New NothingConstantExpression(Me)
         result = nullExp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
         For i As Integer = 0 To m_Targets.Count - 1
             Dim exp As Expression = DirectCast(m_Targets.Item(i), Expression)
             result = exp.GenerateCode(Info.Clone(Me, nullExp)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1954" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="904" endline="913">
<![CDATA[
 
     Shared Function GetParameterTypes(ByVal Parameters As Mono.Cecil.ParameterReference()) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         Helper.Assert(Parameters IsNot Nothing)
         ReDim result(Parameters.Length - 1)
         For i As Integer = 0 To Parameters.GetUpperBound(0)
             result(i) = Parameters(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1955" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="264" endline="281">
<![CDATA[
 
     Function CreateImplicitMembers() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitMembers " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitMembers = TryCast(Type, IHasImplicitMembers)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitMembers AndAlso result
 
             result = CreateImplicitMembers(Type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1958" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="179" endline="188">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.OperatorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.OperatorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Operator) = False Then Return False
         If IsOverloadableOperator(tm.PeekToken(i + 1)) = False Then Return False
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1959" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="141" endline="151">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         result = MyBase.ResolveCode(info) AndAlso result
 
         Helper.Assert(m_ReturnType IsNot Nothing OrElse Compiler.Report.Errors > 0)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1960" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="89" endline="99">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Catches IsNot Nothing Then result = m_Catches.ResolveTypeReferences() AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1961" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="379" endline="388">
<![CDATA[
 
     Overridable Function DefineOverrides() As Boolean
         Dim result As Boolean = True
 
         If m_MethodOverrides IsNot Nothing Then
             Throw New NotImplementedException
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1963" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="145" endline="153">
<![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Sub AndAlso tm.PeekToken(i + 1).IsIdentifier
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1967" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="74" endline="82">
<![CDATA[
     End Property
 
     Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1968" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="275" endline="292">
<![CDATA[
     End Property
 
     ReadOnly Property HasMethodBody() As Boolean
         Get
             Dim result As Boolean
 
             If TypeOf Me Is ExternalSubDeclaration Then Return False
 
             result = CBool(MethodAttributes And Mono.Cecil.MethodAttributes.Abstract) = False AndAlso CBool(MethodImplAttributes And Mono.Cecil.MethodImplAttributes.Runtime) = False
 
             If result Then
                 If Me.CustomAttributes IsNot Nothing AndAlso Me.CustomAttributes.IsDefined(Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then
                     result = False
                 End If
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2006" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="67" endline="75">
<![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2007" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="634" endline="645">
<![CDATA[
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2010" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="437" endline="451">
<![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String, ByVal Ordinal As Boolean) As Boolean
         If Ordinal Then
             Return CompareNameOrdinal(Value1, Value2)
         Else
             Return CompareName(Value1, Value2)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2011" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceBases.vb" startline="44" endline="53">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Bases IsNot Nothing)
         result = Helper.ResolveTypeReferencesCollection(m_Bases)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2012" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="117" endline="135">
<![CDATA[
     End Property
 
     Protected Overridable Function ResolveExpressions(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveExpression(Info) AndAlso result
         result = m_RightExpression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return False
 
         If m_LeftExpression.Classification.IsValueClassification = False Then
             result = Helper.VerifyValueClassification(m_LeftExpression, Info) AndAlso result
         End If
 
         If m_RightExpression.Classification.IsValueClassification = False Then
             result = Helper.VerifyValueClassification(m_RightExpression, Info) AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2013" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="77" endline="85">
<![CDATA[
 
     Function Resolve(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
 
         result = Classification.AsMethodPointerClassification.Resolve(DelegateType) AndAlso result
         m_ExpressionType = DelegateType
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2014" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclarations.vb" startline="77" endline="90">
<![CDATA[
     End Property
 
     Function GetSpecificMembers(Of T)() As Generic.List(Of T)
         Dim result As New Generic.List(Of T)
 
         For i As Integer = 0 To Count - 1
             Dim obj As IMember = Me.Item(i)
             If TypeOf obj Is T Then
                 result.Add(CType(CObj(obj), T))
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2016" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2548" endline="2555">
<![CDATA[
 
     Shared Function GetPropertyOrPropertyBuilder(ByVal Compiler As Compiler, ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.PropertyReference
         If Compiler.Assembly.IsDefinedHere([Property]) Then
             Return [Property]
         Else
             Return [Property]
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2019" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="44" endline="54">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = m_NonArrayTypeName.ResolvedType
         End If
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2020" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="59" endline="75">
<![CDATA[
     End Property
 
     ReadOnly Property SpecialConstraintAttribute() As Mono.Cecil.GenericParameterAttributes
         Get
             Select Case m_Special
                 Case KS.[New]
                     Return Mono.Cecil.GenericParameterAttributes.DefaultConstructorConstraint
                 Case KS.Class
                     Return Mono.Cecil.GenericParameterAttributes.ReferenceTypeConstraint
                 Case KS.Structure
                     Return Mono.Cecil.GenericParameterAttributes.NotNullableValueTypeConstraint
                 Case KS.None
                     Return Mono.Cecil.GenericParameterAttributes.NonVariant
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2021" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1651" endline="1665">
<![CDATA[
 
     Shared Function GetUnaryOperators(ByVal Compiler As Compiler, ByVal Op As UnaryOperators, ByVal Type As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Dim opNameAlternatives As String() = Nothing
 
         Select Case Op
             Case UnaryOperators.Add
                 opNameAlternatives = New String() {"op_UnaryPlus"}
             Case UnaryOperators.Minus
                 opNameAlternatives = New String() {"op_UnaryNegation"}
             Case UnaryOperators.Not
                 opNameAlternatives = New String() {"op_OnesComplement", "op_LogicalNot"}
         End Select
 
         Return GetOperators(Compiler, opNameAlternatives, Type)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2022" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="49" endline="57">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(info) AndAlso result
         Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2023" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="276" endline="287">
<![CDATA[
 
     ''' <summary>
     ''' Checks for this grammar
     ''' VariableMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.VariableModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.VariableModifiers)
             i += 1
         End While
         Return i > 0 AndAlso tm.PeekToken(i).IsIdentifier
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2024" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1301" endline="1315">
<![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Double) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Dim tmp As EmitInfo = Info
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 If Value <= Single.MaxValue AndAlso Value >= Single.MinValue Then
                     EmitLoadValue(tmp, CSng(Value))
                     Return True
                 End If
         End Select
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2025" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="171" endline="182">
<![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         BaseType = Compiler.TypeCache.System_MulticastDelegate
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences(False) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2026" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="127" endline="145">
<![CDATA[
 
     Public Shared Function GetAttributes(ByVal m_Declaration As ConstructorDeclaration) As Mono.Cecil.MethodAttributes
         Dim flags As Mono.Cecil.MethodAttributes
         flags = Mono.Cecil.MethodAttributes.SpecialName Or Mono.Cecil.MethodAttributes.RTSpecialName
 
         'LAMESPEC
         'VBC
         If m_Declaration.Modifiers.IsAny(ModifierMasks.AccessModifiers) = False AndAlso m_Declaration.IsShared Then
             flags = flags Or Mono.Cecil.MethodAttributes.Private
         Else
             flags = flags Or m_Declaration.Modifiers.GetMethodAttributeScope
         End If
 
         If m_Declaration.IsShared Then
             flags = flags Or Mono.Cecil.MethodAttributes.Static
         End If
 
         Return flags
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2027" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="96" endline="110">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If HandlesClause IsNot Nothing Then
             result = HandlesClause.ResolveTypeReferences AndAlso result
         ElseIf ImplementsClause IsNot Nothing Then
             result = ImplementsClause.ResolveTypeReferences AndAlso result
         Else
             Helper.Stop()
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2028" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="968" endline="974">
<![CDATA[
 
     Function FindType(ByVal FullName As String) As TypeDeclaration
         For Each type As TypeDeclaration In Me.Types
             If Helper.CompareName(type.FullName, FullName) Then Return type
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2029" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="82" endline="89">
<![CDATA[
 
     Overrides Function ToString() As String
         Dim result As String = ""
         For Each atn As ArrayTypeModifier In m_ArrayTypeModifiers
             result &= atn.ToString
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2030" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="50" endline="66">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Loads the instance expression onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, m_InstanceExpression.ExpressionType)) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2031" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2032" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Function
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2033" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="47" endline="55">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterList(NewParent)
         For i As Integer = 0 To Me.Count - 1
             result.Add(Me.Item(i).Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2034" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="43" endline="52">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         If tm.PeekToken(i) <> KS.Declare Then Return False
         If tm.PeekToken(i + 1).Equals(ModifierMasks.CharSetModifiers) Then i += 1
         Return tm.PeekToken(i + 1) = KS.Function
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2035" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="34" endline="53">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsLHS Then
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateindexSet(Info) AndAlso result
             Else
                 result = EmitLateSet(Info) AndAlso result
             End If
         Else
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateIndexGet(Info) AndAlso result
             Else
                 result = EmitLateGet(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2040" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="37" endline="44">
<![CDATA[
 
     Shared Function IsUnaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2041" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2042" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="64" endline="71">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2043" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="559" endline="583">
<![CDATA[
 
     Function GenerateMyRequest() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Request"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Request As Global.System.Web.HttpRequest" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Request" & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2044" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="590" endline="614">
<![CDATA[
 
     Function GenerateMyResponse() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Response"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Response As Global.System.Web.HttpResponse" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Response    " & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2045" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="142" endline="150">
<![CDATA[
 
     Public Shared Function SelectNarrowingConversionOperator(ByVal Compiler As Compiler, ByVal Type As TypeReference, ByVal ReturnType As TypeReference, ByRef ConversionMethod As MethodReference) As Boolean
         Dim methods As Generic.List(Of MethodReference)
 
         methods = TypeResolution.GetNarrowingConversionOperators(Compiler, Type, ReturnType)
         If methods Is Nothing OrElse methods.Count <> 1 Then Return False
         ConversionMethod = methods(0)
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2046" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="112" endline="128">
<![CDATA[
 
     ''' <summary>
     ''' Loads the loop control variable onto the stack
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitLoadVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             Emitter.EmitLoadVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False)) AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2049" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="158" endline="169">
<![CDATA[
 
     Private Function IsPositiveStep() As Boolean
         Dim constant As Object
 
         constant = m_LoopStepExpression.ConstantValue
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) > 0
         Else
             Return CDbl(constant) > 0
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2050" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2206" endline="2212">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> Shared Function AddError(ByVal Context As BaseObject, Optional ByVal Message As String = Nothing) As Boolean
         If Message Is Nothing Then
             Message = "<no message written yet>"
         End If
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC99999, Context.Location, Message)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2051" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" startline="35" endline="42">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         result = LiteralExpression.IsMe(tm) OrElse ParenthesizedExpression.IsMe(tm) OrElse InstanceExpression.IsMe(tm) OrElse SimpleNameExpression.IsMe(tm) OrElse AddressOfExpression.IsMe(tm)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2052" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="285" endline="302">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2053" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="92" endline="103">
<![CDATA[
 
     Private Function GetTypeAttributes() As Mono.Cecil.TypeAttributes
         Dim result As Mono.Cecil.TypeAttributes = MyBase.TypeAttributes
 
         If Me.Modifiers.Is(ModifierMasks.MustInherit) Then
             result = result Or Mono.Cecil.TypeAttributes.Abstract
         ElseIf Me.Modifiers.Is(ModifierMasks.NotInheritable) Then
             result = result Or Mono.Cecil.TypeAttributes.Sealed
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2054" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="59" endline="67">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
         Classification = m_Expression.Classification
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2055" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="389" endline="396">
<![CDATA[
 
     Private Function IsPropertyHandlesHandler() As Boolean
         Dim propD As PropertyDeclaration
 
         propD = TryCast(Parent, PropertyDeclaration)
         If propD Is Nothing Then Return False
         Return propD.HandlesField IsNot Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2056" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="539" endline="550">
<![CDATA[
 
     ''' <summary>
     ''' This function returns the members list in the cache, or nothing
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattenedMembers(ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim cache As MemberCacheEntry = LookupFlattened(Name)
         If cache Is Nothing Then Return Nothing
         Return cache.Members
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2058" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="301" endline="308">
<![CDATA[
 
     Function IsValidCandidate(ByVal candidate As MemberCandidate) As Boolean
         If CecilHelper.IsValidType(candidate.ReturnType) = False Then Return False
         For j As Integer = 0 To candidate.DefinedParametersTypes.Length - 1
             If CecilHelper.IsValidType(candidate.DefinedParametersTypes(j)) = False Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2059" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3094" endline="3108">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Mono.Cecil.TypeReference()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         If Types IsNot Nothing Then
             For Each t As Mono.Cecil.TypeReference In Types
                 Helper.Assert(t IsNot Nothing)
                 result &= sep & t.ToString
                 sep = ", "
             Next
         End If
 
         Return "{" & result & "}"
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2063" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="212" endline="228">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Show the saved messages. Returns true if any error messages have been shown.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ShowSavedMessages() As Boolean
         Dim result As Boolean = False
 
         For Each msg As Message In m_SavedMessages
             ShowMessage(False, msg) 'Compiler.Report.WriteLine(str)
             If msg.Level >= MessageLevel.Error Then result = True
         Next
         m_SavedMessages.Clear()
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2064" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1748" endline="1758">
<![CDATA[
 
     Shared Function IsAccessibleExternal(ByVal Compiler As Compiler, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         If Compiler.Assembly.IsDefinedHere(Member) Then Return True
 
         If IsPublic(Member) Then Return True
         If IsProtectedFriend(Member) Then Return True
         If IsPrivate(Member) Then Return False
         If IsFriend(Member) Then Return False
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2084" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="112" endline="123">
<![CDATA[
 
     Overloads Function Equals(ByVal str As String) As Boolean
         If IsGlobal(str) Then
             If Me.Global = False Then
                 Return False
             Else
                 Return Helper.CompareName(RemoveGlobal(str), Me.Name)
             End If
         Else
             Return Helper.CompareName(str, Me.Name)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2085" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="72" endline="86">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.DefineLabel(Info)
 
         For i As Integer = 0 To m_Cases.Count - 1
             Dim stmt As CaseStatement = m_Cases(i)
             result = stmt.GenerateCode(Info) AndAlso result
         Next
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2086" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="26" endline="38">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_DestinationType IsNot Nothing Then
             result = m_DestinationType.ResolveTypeReferences AndAlso result
             m_ResolvedDestinationType = m_DestinationType.ResolvedType
             Helper.Assert(CecilHelper.IsByRef(m_ResolvedDestinationType) = False)
         End If
 
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2087" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="73" endline="86">
<![CDATA[
 
     Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal Destination As Mono.Cecil.ParameterDefinition) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.GenerateCode(Info) AndAlso result
         Else
             Helper.Assert(Destination IsNot Nothing)
             Helper.Assert(Destination.IsOptional)
             Emitter.EmitLoadValue(Info, Destination.Constant)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2088" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2427" endline="2439">
<![CDATA[
 
     Shared Function IntToBin(ByVal Int As ULong) As String
         If Int = 0 Then Return "0"
         IntToBin = ""
         Do Until Int = 0
             If CBool(Int And 1UL) Then
                 IntToBin = "1" & IntToBin
             Else
                 IntToBin = "0" & IntToBin
             End If
             Int >>= 1
         Loop
         Do Until Int = 0
             If CBool(Int And 1UL) Then
                 IntToBin = "1" & IntToBin
             Else
                 IntToBin = "0" & IntToBin
             End If
             Int >>= 1
         Loop
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2089" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="95" endline="108">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Signature.Parameters IsNot Nothing Then
             For i As Integer = 0 To Signature.Parameters.Count - 1
                 result = Signature.Parameters(i).GenerateCode(Info) AndAlso result
             Next
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2090" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="84" endline="94">
<![CDATA[
     End Property
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         If tm.PeekToken(i) <> KS.Declare Then Return False
         If tm.PeekToken(i + 1).Equals(ModifierMasks.CharSetModifiers) Then i += 1
         Return tm.PeekToken(i + 1) = KS.Sub AndAlso tm.PeekToken(i + 2).IsIdentifier
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2091" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="494" endline="503">
<![CDATA[
 
     Sub ExpandParamArrays()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             candidate.ExpandParamArray()
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2092" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="57" endline="69">
<![CDATA[
 
     ReadOnly Property Name() As String
         Get
             If TypeOf Me Is MeExpression Then
                 Return KS.Me.ToString
             ElseIf TypeOf Me Is MyBaseExpression Then
                 Return KS.MyBase.ToString
             ElseIf TypeOf Me Is MyClassExpression Then
                 Return KS.MyClass.ToString
             Else
                 Throw New InternalException("Invalid instance expression.")
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2094" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="1137" endline="1158">
<![CDATA[
 
     Private Function AddFile(ByVal File As String) As Boolean
         Dim result As Boolean = True
 
         Dim strFile As String
         Dim strFiles As String()
 
         strFiles = GetFullPaths(File)
 
         If strFiles Is Nothing OrElse strFiles.Length = 0 Then
             If IsPattern(File) = False Then
                 result = Compiler.Report.SaveMessage(Messages.VBNC2001, Span.CommandLineSpan, File) AndAlso result
             End If
             Return result
         End If
 
         For Each strFile In strFiles
             m_lstFileNames.Add(New CodeFile(strFile, System.IO.Path.GetDirectoryName(File), Me.Compiler))
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2095" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="145" endline="157">
<![CDATA[
     End Property
 
     Private Function IsNegativeStep() As Boolean
         Dim constant As Object
 
         constant = m_LoopStepExpression.ConstantValue
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) < 0
         Else
             Return CDbl(constant) < 0
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2105" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="35" endline="43">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         MyBase.BaseType = Compiler.TypeCache.System_ValueType
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2106" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" startline="75" endline="82">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Get
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2107" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="84" endline="100">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Target.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_Target.Classification.IsMethodGroupClassification Then
             Dim tmp As New InvocationOrIndexExpression(Me)
             tmp.Init(m_Target, New ArgumentList(tmp))
             result = tmp.ResolveExpression(Info) AndAlso result
             m_Target = tmp
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2108" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="53" endline="72">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_PropertyGroup.IsResolved = False OrElse m_PropertyGroup.ResolvedProperty Is Nothing Then
             result = m_PropertyGroup.ResolveGroup(New ArgumentList(Me)) AndAlso result
         End If
 
         If result = False Then
             Return False
         End If
 
         m_ExpressionType = m_PropertyGroup.ResolvedProperty.PropertyType
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2113" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="45" endline="59">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Expression As Expression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             result = Expression.GenerateCode(Info.Clone(Expression, True, False, Expression.ExpressionType)) AndAlso result
             If CecilHelper.IsValueType(Expression.ExpressionType) OrElse CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
                 Emitter.EmitBox(Info, Expression.ExpressionType)
             End If
         Else
             Throw New InternalException(Expression)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2115" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="325" endline="335">
<![CDATA[
 
     ReadOnly Property Identifier() As String
         Get
             If IsKeyword() Then
                 Return Enums.strSpecial(Keyword)
             ElseIf IsIdentifier() Then
                 Return DirectCast(m_TokenObject, String)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2116" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="316" endline="347">
<![CDATA[
 
     ''' <summary>
     ''' ImportsAliasClause  
     '''	Identifier  =  QualifiedIdentifier  |
     '''	Identifier  =  ConstructedTypeName
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     ''' 
     ''' This overload is used when parsing commandline imports.
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsAliasClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsAliasClause
         Dim result As New ImportsAliasClause(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_Second As ImportsNamespaceClause = Nothing
 
         Dim values() As String = str.Split("="c)
         If values.Length <> 2 Then Return Nothing
 
         m_Identifier = New Identifier(result, values(0), Span.CommandLineSpan, TypeCharacters.Characters.None)
 
         m_Second = ParseImportsNamespaceClause(result, values(1))
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
 
         result.Init(m_Identifier, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2117" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1222" endline="1244">
<![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Long) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
             Return EmitLoadValue(Info, CInt(Value))
         End If
 
         Dim tmp As EmitInfo = Info.Clone(Info.Context, CType(Nothing, Mono.Cecil.TypeReference))
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
         End Select
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2118" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="64" endline="74">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         MyBase.BaseType = Compiler.TypeCache.System_Object
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Me.FindDefaultConstructors()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2119" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="41" endline="48">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals("Custom") AndAlso tm.PeekToken(i + 1).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2120" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="39" endline="53">
<![CDATA[
         Get
             Dim result As Boolean
             Static recursive As Boolean
             Helper.Assert(recursive = False)
             recursive = True
             If ReclassifiedClassification IsNot Nothing Then
                 result = ReclassifiedClassification.IsConstant
             ElseIf m_Value IsNot Nothing AndAlso m_Value.IsConstant Then
                 result = True
             Else
                 result = False
             End If
             recursive = False
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2122" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="71" endline="79">
<![CDATA[
     End Property
 
     Function ToTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
         For i As Integer = 0 To Me.Count - 1
             result(i) = Me.Item(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2124" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="90" endline="104">
<![CDATA[
 
     Function StartsWith(ByVal str As String) As Boolean
         Helper.Assert(m_Name IsNot Nothing AndAlso m_Name <> "")
         Helper.Assert(str IsNot Nothing AndAlso str <> "")
         If str.Length <= m_Name.Length Then
             If m_Global AndAlso IsGlobal(str) Then
                 str = RemoveGlobal(str)
                 Return Helper.CompareName(str, m_Name.Substring(0, str.Length))
             Else
                 Return Helper.CompareName(str, m_Name.Substring(0, str.Length))
             End If
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2125" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2126" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="47" endline="54">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2127" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="53" endline="60">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2128" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" startline="43" endline="50">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2129" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="72" endline="79">
<![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2130" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="326" endline="337">
<![CDATA[
 
     Public Sub Trace(ByVal format As String, ByVal ParamArray args() As Object)
         If Compiler.CommandLine.Trace = False Then Return
         If args IsNot Nothing Then
             For i As Integer = 0 To args.Length - 1
                 If TypeOf args(i) Is Span Then
                     args(i) = DirectCast(args(i), Span).ToString(Compiler)
                 End If
             Next
         End If
         Console.WriteLine(format, args)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2131" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="98" endline="108">
<![CDATA[
 
     Public ReadOnly Property IsExternalDeclaration() As Boolean
         Get
             If TypeOf Me Is ExternalSubDeclaration Then Return True
             If CustomAttributes Is Nothing Then Return False
             For i As Integer = 0 To CustomAttributes.Count - 1
                 If CustomAttributes(i).ResolvedType Is Nothing Then Continue For
                 If Helper.CompareType(CustomAttributes(i).ResolvedType, Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then Return True
             Next
             Return False
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2133" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="40" endline="49">
<![CDATA[
     End Property
 
     ReadOnly Property Expression() As Expression
         Get
             If m_Group Is Nothing Then
                 If Not CanBeExpression() Then Return Nothing
                 If m_Group Is Nothing Then Return Nothing
             End If
             Return m_Group.DefaultInstanceAlias
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2134" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="211" endline="224">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedType Is Nothing Then
             Helper.Assert(m_SimpleTypeName IsNot Nothing, "SimpleTypeName Is Nothing
             result = m_SimpleTypeName.ResolveTypeReferences(True) AndAlso result
             m_ResolvedType = m_SimpleTypeName.ResolvedType
         End If
         result = m_ResolvedType IsNot Nothing AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2135" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="125" endline="134">
<![CDATA[
     End Property
 
     Public ReadOnly Property GetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Get IsNot Nothing Then
                 Return m_Get.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2136" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="79" endline="87">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Operator) = False Then Return False
         Return IsOverloadableConversionOperator(tm.PeekToken(i + 1))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2140" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="63" endline="74">
<![CDATA[
 
     ''' <summary>
     ''' Checks for the following grammar
     ''' ConstantMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Const
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2141" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="210" endline="219">
<![CDATA[
 
     Private Function EmitStoreCounterInstanceExpression(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
 
         If Data.InstanceExpression IsNot Nothing Then
             result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2142" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="396" endline="408">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Report.Trace("{0}
 
         result = MyBase.ResolveCode(Info) AndAlso result
         Compiler.VerifyConsistency(result, Location)
         result = m_Members.ResolveCode(Info) AndAlso result
         'vbnc.Helper.Assert(result = (Compiler.Report.Errors = 0))
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2143" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2064" endline="2071">
<![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2184" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="196" endline="203">
<![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2187" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="941" endline="979">
<![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As Expression()) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Length}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Length - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2188" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" startline="86" endline="102">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             ElseIf TypeOf lvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             ElseIf TypeOf rvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             Else
                 Return CBool(lvalue) AndAlso CBool(rvalue)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2191" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="204" endline="213">
<![CDATA[
 
     Function DefineOverrides() As Boolean
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then
             result = m_ImplementsClause.DefineImplements(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2192" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="57" endline="78">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.EmitBeginExceptionBlock(Info)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         For i As Integer = 0 To m_Catches.Count - 1
             Dim catchstmt As CatchStatement = m_Catches(i)
             result = catchstmt.GenerateCode(Info) AndAlso result
         Next
 
         If m_FinallyBlock IsNot Nothing Then
             Info.ILGen.BeginFinallyBlock()
             result = m_FinallyBlock.GenerateCode(Info) AndAlso result
         End If
 
         Info.ILGen.EndExceptionBlock()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2193" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="345" endline="366">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = DefineOverrides() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Me.IsPropertyHandlesHandler Then
             result = GeneratePropertyHandlers() AndAlso result
         ElseIf Me.HasMethodBody Then
             Helper.Assert(m_Code IsNot Nothing)
 
             'Create the default return variable
             If Me.HasReturnValue Then
                 m_DefaultReturnVariable = Emitter.DeclareLocal(Info, ReturnType)
             End If
 
             result = m_Code.GenerateCode(Me) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2194" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="128" endline="146">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
 
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Char, TypeCode.String
                     Return CStr(originalValue)
                 Case TypeCode.DBNull
                     Return DBNull.Value
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2196" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="75" endline="82">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Module)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2197" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="102" endline="115">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_IsVariableDeclaration Then
             result = m_VariableDeclaration.GenerateCode(Info.Clone(Me, True, False, UsingVariableType)) AndAlso result
             UsingVariable = m_VariableDeclaration.LocalBuilder
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2198" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="32" endline="41">
<![CDATA[
 
     Public Overrides Function ToString() As String
         If Me.IsIdentifier Then
             Return Me.Identifier
         ElseIf Me.IsKeyword Then
             Return Me.Identifier
         Else
             Return "<Token>"
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2199" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="197" endline="213">
<![CDATA[
 
     ''' <summary>
     ''' If not the current token is a newline, then shows the specified message
     ''' and eats the newline. After this sub the current token will be the first after the newline
     ''' Returns false if first symbol isn't a newline
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindNewLineAndShowError(ByVal Message As Messages) As Boolean
         If Not AcceptNewLine() Then
             Compiler.Report.ShowMessage(Message, CurrentLocation)
             GotoNewline(True, False)
             Return False
         Else
             Return True
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2200" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="107" endline="123">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Resolved)
 
         If Info.IsRHS Then
             result = GenerateCodeAsValue(Info) AndAlso result
         ElseIf Info.IsLHS Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2205" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlesList.vb" startline="30" endline="39">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each Item As EventMemberSpecifier In Me
             result = Item.ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2207" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3492" endline="3509">
<![CDATA[
 
     Private Function ParseBooleanLiteralExpression(ByVal Parent As ParsedObject) As BooleanLiteralExpression
         Dim result As New BooleanLiteralExpression(Parent)
 
         Dim m_Value As Boolean
 
         If tm.Accept(KS.True) Then
             m_Value = True
         ElseIf tm.Accept(KS.False) Then
             m_Value = False
         Else
             Throw New InternalException(result)
         End If
 
         result.Init(m_Value)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2208" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2095" endline="2102">
<![CDATA[
 
     Shared Function ResolveStatementCollection(ByVal Collection As IEnumerable, ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As Statement In Collection
             result = obj.ResolveStatement(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2209" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2103" endline="2110">
<![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IEnumerable, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.GenerateCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2210" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="980" endline="1018">
<![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Count}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Count - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2211" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="124" endline="136">
<![CDATA[
     End Property
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal where As String)
         'Console.WriteLine("Verifying consistency
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, where & "
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2212" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="321" endline="330">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal GotoNewline As Boolean, ByVal MessageParameter As String) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation, MessageParameter)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2213" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="109" endline="120">
<![CDATA[
 
     Private Function DefineTypeHierarchy(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineTypeHierarchy AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineTypeHierarchy(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2214" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="162" endline="180">
<![CDATA[
     End Property
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         If Me.IsShared = False AndAlso Me.HasMethodBody AndAlso Me.HasExplicitCtorCall = False Then
             CreateDefaultCtorCall()
             CreateDefaultCtorCallCecil()
         ElseIf Code IsNot Nothing AndAlso Me.HasExplicitCtorCall Then
             m_BaseCtorCall = Code.FirstStatement
             If m_BaseCtorCall IsNot Nothing Then Code.RemoveStatement(m_BaseCtorCall)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2215" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2216" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BoxExpression.vb" startline="60" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim tp As TypeReference
 
         result = m_Expression.GenerateCode(Info) AndAlso result
 
         tp = m_Expression.ExpressionType
         If CecilHelper.IsByRef(tp) Then
             tp = CecilHelper.GetElementType(tp)
         End If
         Emitter.EmitBox(Info, tp)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2217" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ThrowStatement.vb" startline="40" endline="52">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Exception Is Nothing Then
             Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Rethrow)
         Else
             result = m_Exception.GenerateCode(Info.Clone(Me, True, False, m_Exception.ExpressionType)) AndAlso result
             Emitter.EmitThrow(Info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2218" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="370" endline="378">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstructorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstructorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Sub) = False Then Return False
         Return tm.PeekToken(i + 1).Equals(KS.[New])
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2219" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="244" endline="263">
<![CDATA[
 
     Private Overloads Function ResolveTypeReferences(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         For Each Member As ParsedObject In Type.Members
             Dim NestedType As TypeDeclaration = TryCast(Member, TypeDeclaration)
             If NestedType IsNot Nothing Then
                 result = ResolveTypeReferences(NestedType) AndAlso result
             Else
                 result = Member.ResolveTypeReferences() AndAlso result
             End If
             If result = False Then Return result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2221" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="280" endline="294">
<![CDATA[
 
     Shared Function VerifyValueClassification(ByRef Expression As Expression, ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         If Expression.Classification.IsValueClassification Then
             result = True
         ElseIf Expression.Classification.CanBeValueClassification Then
             Expression = Expression.ReclassifyToValueExpression
             result = Expression.ResolveExpression(Info) AndAlso result
             Helper.StopIfDebugging(result = False)
         Else
             Helper.AddError(Expression)
             result = False
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2222" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="207" endline="223">
<![CDATA[
 
     Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_TypeName Is Nothing AndAlso Location.File(Compiler).IsOptionStrictOn Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30209, Me.Location) AndAlso result
         End If
 
         If m_ConstantExpression Is Nothing Then
             Helper.AddError(Me, "No constant expression.")
             Return False
         End If
 
         result = ResolveConstantValue(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2223" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\GetTypeTypeName.vb" startline="36" endline="54">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedType IsNot Nothing Then Return True
 
         If m_TypeArity > 0 Then
             Dim qi As QualifiedIdentifier = DirectCast(m_Name, QualifiedIdentifier)
             result = qi.ResolveAsTypeName(False, m_TypeArity) AndAlso result
 
             If result Then m_ResolvedType = qi.ResolvedType
         Else
             result = m_Name.ResolveTypeReferences AndAlso result
             If result Then m_ResolvedType = DirectCast(m_Name, TypeName).ResolvedType
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2224" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="563" endline="586">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             result = m_Variables(i).ResolveCode(Info) AndAlso result
         Next
 
         'We may add statements as we go.
         Dim counter As Integer = 0
         Dim count As Integer = m_Statements.Count
         While counter < m_Statements.Count
             Dim obj As Statement = m_Statements(counter)
             result = obj.ResolveStatement(Info) AndAlso result
             If count <> m_Statements.Count Then
             	'A statement has been added somewhere.
             	'Find the correct index of the current statement.
                 counter = m_Statements.IndexOf(obj)
             End If
             counter += 1
         End While
         While counter < m_Statements.Count
             Dim obj As Statement = m_Statements(counter)
             result = obj.ResolveStatement(Info) AndAlso result
             If count <> m_Statements.Count Then
             	'A statement has been added somewhere.
             	'Find the correct index of the current statement.
                 counter = m_Statements.IndexOf(obj)
             End If
             counter += 1
         End While
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2226" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="103" endline="115">
<![CDATA[
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2227" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="175" endline="186">
<![CDATA[
     End Property
 
     ReadOnly Property FieldInfo() As Mono.Cecil.FieldReference
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return m_FieldInfo
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2228" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="407" endline="430">
<![CDATA[
 
     Private Function CheckCurrentFunctionForTypeParameters(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         Dim signature As SubSignature = Nothing
         Dim method As MethodBaseDeclaration = FromWhere.FindFirstParent(Of MethodBaseDeclaration)()
 
         If method IsNot Nothing Then
             signature = method.Signature
         Else
             Dim del As DelegateDeclaration = FromWhere.FindFirstParent(Of DelegateDeclaration)()
             If del IsNot Nothing Then
                 signature = del.Signature
             End If
         End If
 
         If signature IsNot Nothing AndAlso signature.TypeParameters IsNot Nothing Then
             Dim item As TypeParameter = signature.TypeParameters.Parameters.Item(R)
             If item IsNot Nothing Then
                 m_FoundObjects.Add(item)
                 Return True
             End If
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2229" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="311" endline="330">
<![CDATA[
 
     Private Shared Function ResolveMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each n As IBaseObject In Type.Members.GetSpecificMembers(Of IBaseObject)()
             Dim nType As TypeDeclaration = TryCast(n, TypeDeclaration)
             Dim nMember As INonTypeMember = TryCast(n, INonTypeMember)
 
             If nType IsNot Nothing Then
                 result = ResolveMembers(nType) AndAlso result
             ElseIf nMember IsNot Nothing Then
                 'Resolve all non-type members.
                 result = nMember.ResolveMember(ResolveInfo.Default(Type.Compiler)) AndAlso result
             Else
                 Helper.Stop() '?
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2230" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="80" endline="99">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_WithExpression.ResolveExpression(Info) AndAlso result
 
         If result Then
             If CecilHelper.IsValueType(m_WithExpression.ExpressionType) AndAlso m_WithExpression.Classification.IsVariableClassification Then
                 m_WithVariableExpression = m_WithExpression
             Else
                 m_WithVariableExpression = New CompilerGeneratedExpression(Me, New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateVariableCode), m_WithExpression.ExpressionType)
                 result = m_WithVariableExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2231" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="51" endline="61">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
 
         Emitter.EmitLoadIndirect(Info, m_Expression.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2232" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="145" endline="156">
<![CDATA[
 
     Friend Function Emit(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.GenerateCode(Nothing) AndAlso result
         result = Type.Members.GenerateCode(Nothing) AndAlso result
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = Emit(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2233" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="48" endline="63">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             If Me.Classification.IsValueClassification Then
                 result = m_Expression.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2234" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="162" endline="174">
<![CDATA[
 
     ReadOnly Property GenericParameterAttributes() As Mono.Cecil.GenericParameterAttributes
         Get
             Dim result As Mono.Cecil.GenericParameterAttributes
 
             If m_TypeParameterConstraints IsNot Nothing Then
                 For i As Integer = 0 To m_TypeParameterConstraints.Constraints.Count - 1
                     result = result Or m_TypeParameterConstraints.Constraints(i).SpecialConstraintAttribute
                 Next
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2236" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="153" endline="162">
<![CDATA[
     End Property
 
     ReadOnly Property LocalBuilder() As Mono.Cecil.Cil.VariableDefinition
         Get
             If m_LocalVariable IsNot Nothing Then
                 Return m_LocalVariable.LocalBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2237" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MustOverridePropertyDeclaration.vb" startline="32" endline="39">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2238" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="73" endline="90">
<![CDATA[
 
     Public NotOverridable Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveStatement(Info) AndAlso result
 
         If result = False Then Return result
 
         result = CheckIndexedStatement(Info, TryCast(LSide, InvocationOrIndexExpression)) AndAlso result
 
         m_CompoundExpression = ResolveStatement(LSide, RSide)
 
         result = m_CompoundExpression.ResolveExpression(Info) AndAlso result
 
         m_CompoundExpression = Helper.CreateTypeConversion(Me, m_CompoundExpression, LSide.ExpressionType, result)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2239" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="92" endline="111">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Store the stack value into the loop control variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitStoreVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Info.RHSExpression IsNot Nothing)
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             result = Info.RHSExpression.Classification.GenerateCode(Info.Clone(Me, True, False, m_Declaration.LocalBuilder.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info) AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2240" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3552" endline="3575">
<![CDATA[
 
     Shared Function GetVisibility(ByVal Compiler As Compiler, ByVal CallerType As Mono.Cecil.TypeReference, ByVal CalledType As Mono.Cecil.TypeReference) As MemberVisibility
         Helper.Assert(CallerType IsNot Nothing)
         Helper.Assert(CalledType IsNot Nothing)
         Helper.Assert(Compiler.Assembly.IsDefinedHere(CallerType))
 
         If Helper.CompareType(CallerType, CalledType) Then Return MemberVisibility.All
 
         If Compiler.Assembly.IsDefinedHere(CalledType) Then
             If Helper.IsNested(CalledType, CallerType) Then
                 Return MemberVisibility.All
             ElseIf Helper.IsSubclassOf(CalledType, CallerType) Then
                 Return MemberVisibility.PublicProtectedFriend
             Else
                 Return MemberVisibility.PublicFriend
             End If
         Else
             If Helper.IsSubclassOf(CalledType, CallerType) Then
                 Return MemberVisibility.PublicProtected
             Else
                 Return MemberVisibility.Public
             End If
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2243" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="256" endline="266">
<![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             If Me.IsResolved Then
                 Return m_ExpressionType
             ElseIf m_ExpressionType IsNot Nothing Then
                 Return m_ExpressionType
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2244" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="49" endline="61">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Expressions.Length - 1
             result = m_Expressions(i).ResolveExpression(Info) AndAlso result
             If result Then
                 m_Expressions(i) = Helper.CreateTypeConversion(Me, m_Expressions(i), Compiler.TypeCache.System_Int32, result)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2245" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="47" endline="61">
<![CDATA[
 
     Shared Function DeclareLocal(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference, Optional ByVal Name As String = "") As Mono.Cecil.Cil.VariableDefinition
         Dim result As Mono.Cecil.Cil.VariableDefinition
         Helper.Assert(Info IsNot Nothing)
         Helper.Assert(Info.ILGen IsNot Nothing)
 
         Type = Helper.GetTypeOrTypeReference(Info.Compiler, Type)
         result = Info.ILGen.DeclareLocal(Type)
 
         If Name <> String.Empty AndAlso Info.Compiler.EmittingDebugInfo Then
             result.Name = Name
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2246" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1245" endline="1274">
<![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As ULong) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Dim tmp As EmitInfo = Info
 
         'If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
         '    Helper.NotImplemented() 'Return EmitLoadValue(Info, CInt(Value))
         'ElseIf Value <= Long.MaxValue AndAlso Value >= Long.MinValue Then
         '    Return EmitLoadValue(Info, CLng(Value))
         'End If
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
             Case TypeCode.Int64, TypeCode.UInt64
                 EmitLoadI8Value(Info, Value)
                 Return True
         End Select
         Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2247" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="148" endline="158">
<![CDATA[
 
     ReadOnly Property VariableType() As Mono.Cecil.TypeReference
         Get
             If m_Expression IsNot Nothing Then
                 Return m_Expression.ExpressionType
             ElseIf m_TypeName IsNot Nothing Then
                 Return m_TypeName.ResolvedType
             Else
                 Return m_Declaration.VariableType
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2248" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="103" endline="121">
<![CDATA[
     End Property
 
     Function GetMethodAttributeScope() As Mono.Cecil.MethodAttributes
         If Me.Is(ModifierMasks.Public) Then
             Return Mono.Cecil.MethodAttributes.Public
         ElseIf Me.Is(ModifierMasks.Friend) Then
             If Me.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.MethodAttributes.FamORAssem
             Else
                 Return Mono.Cecil.MethodAttributes.Assembly
             End If
         ElseIf Me.Is(ModifierMasks.Protected) Then
             Return Mono.Cecil.MethodAttributes.Family
         ElseIf Me.Is(ModifierMasks.Private) Then
             Return Mono.Cecil.MethodAttributes.Private
         Else
             Return Mono.Cecil.MethodAttributes.Public
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2249" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="474" endline="493">
<![CDATA[
 
     Sub InferTypeArguments()
         If m_TypeArguments IsNot Nothing AndAlso m_TypeArguments.Count > 0 Then
             Log("Type arguments specified, not inferring them")
             Return
         End If
 
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.InferTypeArguments = False Then
                 Log("TYPE INFERENCE FAILED
                 m_Candidates(i) = Nothing
             Else
                 Log("TYPE INFERENCE PASSED
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2271" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="91" endline="101">
<![CDATA[
 
     Friend NotOverridable Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         'result = m_CompoundExpression.GenerateCode(Info.Clone(True, False, LSide.ExpressionType)) AndAlso result
 
         Dim lInfo As EmitInfo = Info.Clone(Me, m_CompoundExpression)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2272" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="53" endline="70">
<![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject)
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2276" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="667" endline="687">
<![CDATA[
 
     Private Function CheckImportsAlias(ByVal R As String, ByVal [Imports] As ImportsClauses, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* If the source file has one or more import aliases, and R matches the name of one of them, then 
         '* the unqualified name refers to that import alias.
         '---------------------------------------------------------------------------------------------------------
         ' (...)
         '---------------------------------------------------------------------------------------------------------
         '* If the compilation environment defines one or more import aliases, and R matches the name of one of 
         '* them, then the unqualified name refers to that import alias.
         '---------------------------------------------------------------------------------------------------------
         For Each import As ImportsClause In [Imports]
             If import.IsAliasClause Then
                 If Helper.CompareName(import.AsAliasClause.Name, R) Then
                     m_FoundObjects.Add(import)
                     Return True
                 End If
             End If
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2277" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="424" endline="446">
<![CDATA[
 
     Function RuleNot(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Not) Then
             NextToken()
             RuleNot = RuleRelational(LSide)
 
             Dim op1 As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 LSide = 0
             Else
                 LSide = Not op1
             End If
         Else
             If RuleRelational(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2280" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="136" endline="158">
<![CDATA[
 
     Function RuleUnaryNegation(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Minus) Then
             NextToken()
             RuleUnaryNegation = RuleExponent(LSide)
 
             Dim op1 As Double
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 LSide = 0
             Else
                 LSide = -op1
             End If
         Else
             If RuleExponent(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2281" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="32" endline="41">
<![CDATA[
     End Property
 
     Overridable ReadOnly Property AsString() As String
         Get
             If m_Expression Is Nothing Then
                 Return "Nothing"
             Else
                 Return m_Expression.AsString
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2282" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="214" endline="225">
<![CDATA[
     End Property
 
     ReadOnly Property AsSpecial() As KS
         Get
             If IsKeyword() Then
                 Return Keyword
             ElseIf IsSymbol() Then
                 Return Symbol
             Else
                 Return KS.None
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2283" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="202" endline="209">
<![CDATA[
 
     Public Function ResolveAndGetConstantValue(ByRef value As Object) As Boolean Implements IFieldMember.ResolveAndGetConstantValue
         If m_ResolvedMember = False Then
             If ResolveMember(ResolveInfo.Default(Compiler)) = False Then Return False
         End If
         value = ConstantValue
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2284" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" startline="40" endline="50">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeModifiers
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeModifiers(NewParent)
         Dim mods(m_ArrayTypeModifiers.GetUpperBound(0)) As ArrayTypeModifier
         For i As Integer = 0 To mods.GetUpperBound(0)
             mods(i) = m_ArrayTypeModifiers(i).Clone(result)
         Next
         result.Init(mods)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2285" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="162" endline="181">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If Me.IsArrayTypeName Then
             result = Me.AsArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = Me.AsArrayTypeName.ResolvedType
         ElseIf Me.IsNonArrayTypeName Then
             result = Me.AsNonArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = Me.AsNonArrayTypeName.ResolvedType
         ElseIf m_ResolvedType Is Nothing Then
             Throw New InternalException(Me)
         End If
 
         If result = False Then Return result
 
         Helper.Assert(m_ResolvedType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2288" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="364" endline="373">
<![CDATA[
 
     ''' <summary>
     ''' Finds all the non-nested types in the compiling code and loads them into the lists.
     ''' </summary>
     ''' <remarks></remarks>
     Public Sub LoadCompiledTypes()
         For Each t As TypeDeclaration In Compiler.theAss.Types
             LoadType(t.CecilType)
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2289" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="491" endline="507">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If Expression.IsConstant Then
                 If m_ResolvedDestinationType IsNot Nothing AndAlso Helper.CompareType(m_ResolvedDestinationType, Compiler.TypeCache.System_String) AndAlso Helper.CompareType(Expression.ExpressionType, Compiler.TypeCache.System_Char) Then
                     Return True
                 ElseIf Helper.CompareType(Compiler.TypeCache.Nothing, Expression.ExpressionType) Then
                     Return True
                 Else
                     Return False
                 End If
             Else
                 Return False
             End If
             Return False 'TODO
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2290" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="49" endline="71">
<![CDATA[
 
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.ResolveExpression(info) AndAlso result
             If result AndAlso m_Expression.Classification.IsValueClassification = False Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If result = False Then Return result
 
         If m_Expression IsNot Nothing Then
             Dim method As IMethod
             method = Me.FindFirstParent(Of IMethod)()
             m_Expression = Helper.CreateTypeConversion(Me, m_Expression, method.Signature.ReturnType, result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2293" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="303" endline="320">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal GotoNewline As Boolean, ByVal MessageParameters() As String) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation, MessageParameters)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2298" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Enum)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2299" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="219" endline="226">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For i As Integer = 0 To m_TypeDeclarations.Length - 1
             m_TypeDeclarations(i).Initialize(Me)
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2300" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="478" endline="499">
<![CDATA[
 
     Private Function ResolveReclassifyToValueThenIndex() As Boolean
         Dim result As Boolean = True
         Dim tmpExp As Expression
         Dim oldExp As Expression
 
         tmpExp = m_Expression.ReclassifyToValueExpression
         result = tmpExp.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
 
         If result = False Then
             Helper.AddError(Me)
             Return False
         End If
 
         oldExp = m_Expression
         m_Expression = tmpExp
         result = ResolveIndexInvocation(Me, m_Expression.ExpressionType) AndAlso result
 
         Helper.StopIfDebugging(result = False)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2301" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="898" endline="920">
<![CDATA[
 
     Function FindMainClass(ByRef Result As TypeDeclaration) As Boolean
         'Dim mainClasses As ArrayList
         Dim mainClass As TypeDeclaration
 
         If CommandLine.Main = "" Then
             Result = Nothing
             Return True
         End If
 
         mainClass = theAss.FindType(CommandLine.Main)
 
         If mainClass Is Nothing Then
             Report.ShowMessage(Messages.VBNC90013, Span.CommandLineSpan, CommandLine.Main, "0")
             Result = Nothing
             Return False
         End If
 
         'Result = DirectCast(mainClasses(0), TypeDescriptor)
         Result = mainClass
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2317" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2111" endline="2119">
<![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IList, ByVal Info As EmitInfo, ByVal Types As Mono.Cecil.TypeReference()) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Collection.Count = Types.Length)
         For i As Integer = 0 To Collection.Count - 1
             result = DirectCast(Collection(i), IBaseObject).GenerateCode(Info.Clone(Info.Context, Info.IsRHS, Info.IsExplicitConversion, Types(i))) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2318" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="73" endline="91">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Classification = New ValueClassification(Me)
 
         If m_Expression.Classification.IsValueClassification Then
         ElseIf m_Expression.Classification.CanBeValueClassification Then
             m_Expression = m_Expression.ReclassifyToValueExpression()
             result = m_Expression.ResolveExpression(Info) AndAlso result
         Else
             result = Helper.AddError(Me) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2319" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="175" endline="196">
<![CDATA[
 
     ReadOnly Property HasSecurityCustomAttribute() As Boolean
         Get
             Dim checkedAll As Boolean = True
 
             If CustomAttributes Is Nothing Then Return False
 
             If m_HasSecurityCustomAttribute.HasValue Then Return m_HasSecurityCustomAttribute.Value
 
             For i As Integer = 0 To CustomAttributes.Count - 1
                 If CustomAttributes(i).ResolvedType Is Nothing Then
                     checkedAll = False
                 ElseIf Helper.IsSubclassOf(Compiler.TypeCache.System_Security_Permissions_SecurityAttribute, CustomAttributes(i).ResolvedType) Then
                     m_HasSecurityCustomAttribute = True
                     Return True
                 End If
             Next
 
             If checkedAll Then m_HasSecurityCustomAttribute = False
 
             Return False
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2320" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="47" endline="57">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For Each exp As Expression In m_Initializers
             result = exp.ResolveExpression(Info) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2324" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" startline="48" endline="56">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_Destination = Me.FindFirstParent(Of CodeBlock).FindLabel(m_GotoWhere)
         result = m_Destination IsNot Nothing AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2325" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceFunctionDeclaration.vb" startline="36" endline="43">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Function)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2326" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="142" endline="164">
<![CDATA[
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2327" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="232" endline="244">
<![CDATA[
     End Property
 
     Function ToTypes() As Mono.Cecil.TypeReference()
         Dim result(m_Arguments.Count - 1) As Mono.Cecil.TypeReference
         For i As Integer = 0 To m_Arguments.Count - 1
             If m_Arguments(i).Expression Is Nothing Then
                 result(i) = New MissingType(Compiler)
             Else
                 result(i) = m_Arguments(i).Expression.ExpressionType
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2328" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitIntDiv(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__IntDivideObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2329" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceEventMemberDeclaration.vb" startline="31" endline="38">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2330" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="132" endline="140">
<![CDATA[
 
     Shared Function RemoveGlobal(ByVal ns As String) As String
         If IsGlobal(ns) Then
             Return ns.Substring(7)
         Else
             Helper.Assert(ns.StartsWith("Global.", Helper.StringComparison) = False)
             Return ns
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2331" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="208" endline="226">
<![CDATA[
     End Property
 
     ReadOnly Property CanBeValueClassification() As Boolean
         Get
             Select Case m_Classification
                 Case Classifications.Value, Classifications.Variable, _
                 Classifications.LateBoundAccess, Classifications.MethodGroup, _
                 Classifications.MethodPointer, Classifications.PropertyAccess, Classifications.PropertyGroup
                     Return True
                 Case Classifications.Type
                     Dim tc As TypeClassification = AsTypeClassification
                     Return tc.CanBeExpression AndAlso tc.Expression.Classification.CanBeValueClassification
                 Case Classifications.Void, Classifications.Namespace, Classifications.EventAccess
                     Return False
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2332" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" startline="83" endline="99">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             ElseIf TypeOf lvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             ElseIf TypeOf rvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             Else
                 Return CBool(lvalue) OrElse CBool(rvalue)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2333" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="125" endline="142">
<![CDATA[
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2334" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="38" endline="60">
<![CDATA[
     End Property
 
     Private Function IsExcluded() As Boolean
         Dim exp As InvocationOrIndexExpression
         Dim method As Mono.Cecil.MethodReference
         Dim classification As MethodGroupClassification
    
         If Not m_Target.Classification.IsVoidClassification Then Return False
 
         exp = TryCast(m_Target, InvocationOrIndexExpression)
 
         If exp Is Nothing Then Return False
         If exp.Expression Is Nothing Then Return False
 
         classification = TryCast(exp.Expression.Classification, MethodGroupClassification)
         If classification Is Nothing Then Return False
 
         method = classification.ResolvedMethodInfo
 
         If method Is Nothing Then Return False
 
         Return Compiler.Scanner.IsConditionallyExcluded(method, Me.Location)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2335" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfacePropertyMemberDeclaration.vb" startline="33" endline="40">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2336" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="541" endline="548">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Class)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2337" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="183" endline="190">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Delegate)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2338" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="52" endline="61">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property AsString() As String
         Get
             If m_TypeArgumentList Is Nothing OrElse m_TypeArgumentList.Count = 0 Then
                 Return m_Identifier.Identifier
             Else
                 Return m_Identifier.Identifier & "(Of <type arguments>)"
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2339" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="97" endline="108">
<![CDATA[
 
     Private Function DefineType(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineType AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineType(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2340" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="459" endline="473">
<![CDATA[
 
     Sub RemoveInaccessible()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsAccessible = False Then
                 Log("NOT ACCESSIBLE
                 m_Candidates(i) = Nothing
             Else
                 Log("ACCESSIBLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2341" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="504" endline="518">
<![CDATA[
 
     Sub RemoveInapplicable()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.DefineApplicability = False Then
                 Log("NOT APPLICABLE
                 m_Candidates(i) = Nothing
             Else
                 Log("APPLICABLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2342" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="39" endline="62">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitAnd(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AndObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2343" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3322" endline="3333">
<![CDATA[
 
     Private Function ParseNot(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As UnaryNotExpression
 
         If tm.CurrentToken = KS.Not Then
             result = ParseUnaryNotExpression(Info)
         Else
             Return ParseComparison(Info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2344" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="54" endline="65">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             If ReclassifiedClassification IsNot Nothing Then
                 Return ReclassifiedClassification.ConstantValue
             ElseIf m_Value IsNot Nothing Then
                 Return m_Value.ConstantValue
             Else
                 Return MyBase.ConstantValue
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2345" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="30" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Expression.GenerateCode(Info.Clone(Me, ExpressionType)) AndAlso result
 
         If CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
             Emitter.EmitBox(Info, Expression.ExpressionType)
         End If
 
         Emitter.EmitIsInst(Info, Expression.ExpressionType, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2346" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="137" endline="147">
<![CDATA[
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal Location As Span)
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, Location.AsString(Compiler) & " No errors, but compilation failed? ")
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2347" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="199" endline="233">
<![CDATA[
 
 #Region "Resolution region"
     ''' <summary>
     ''' Has this expression been resolved?
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Resolved As Boolean
 
     ''' <summary>
     ''' Is this expression beeing resolved (in Resolve / DoResolve)
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Resolving As Boolean
 
     Function ResolveExpression(ByVal ResolveInfo As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(ResolveInfo IsNot Nothing)
 
         StartResolve()
 
         Try
             result = ResolveExpressionInternal(ResolveInfo) AndAlso result
         Catch ex As Exception
             Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Internal compiler error close to this location")
             Throw
         End Try
 #If EXTENDEDDEBUG Then
         Helper.Assert(result = False OrElse m_Classification IsNot Nothing, "Classification is nothing! (type of expression = " & Me.GetType.ToString & ")")
         Helper.Assert(ResolveInfo.CanFail OrElse result = (Compiler.Report.Errors = 0))
 #End If
 
         EndResolve(result)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2348" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2985" endline="2992">
<![CDATA[
 
     Public Function ParseExpression(ByVal Parent As ParsedObject) As Expression
         Dim result As Expression = Nothing
 
         result = ParseOr_OrElse_Xor(New ExpressionParseInfo(Parent))
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2349" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2350" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2351" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="489" endline="506">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special1 As KS, ByVal Special2 As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special1) AndAlso PeekToken.Equals(Special2) Then
             NextToken()
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2352" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="141" endline="150">
<![CDATA[
     End Property
 
     Public ReadOnly Property SetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Set IsNot Nothing Then
                 Return m_Set.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2353" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularPropertyDeclaration.vb" startline="35" endline="42">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2354" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" startline="73" endline="95">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim selectparent As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         EndLabel = Emitter.DefineLabel(Info)
         m_StartCode = Emitter.DefineLabel(Info)
 
         If m_IsElse = False Then
             For i As Integer = 0 To m_Clauses.Count - 1
                 Dim clause As CaseClause = m_Clauses.Item(i)
                 result = clause.GenerateCode(Info) AndAlso result
             Next
             Emitter.EmitBranch(Info, EndLabel)
         End If
         Emitter.MarkLabel(Info, m_StartCode)
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, selectparent.EndLabel)
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2359" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="326" endline="334">
<![CDATA[
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2360" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="63" endline="72">
<![CDATA[
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         If Me.IsArraySizeInitializationModifier Then
             Return Me.AsArraySizeInitializationModifier.CreateArrayType(OriginalType)
         ElseIf Me.IsArrayTypeModifiers Then
             Return Me.AsArrayTypeModifiers.CreateArrayType(OriginalType)
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2361" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="482" endline="499">
<![CDATA[
 
     ''' <summary>
     '''  Attributes 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         While AttributeBlock.IsMe(tm)
             If ParseAttributeBlock(Parent, Attributes) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End While
         While AttributeBlock.IsMe(tm)
             If ParseAttributeBlock(Parent, Attributes) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End While
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2362" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="517" endline="535">
<![CDATA[
     ''' <summary>
     ''' AttributeBlock  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeBlock(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         tm.AcceptIfNotInternalError(KS.LT)
 
         If ParseAttributeList(Parent, Attributes) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result = tm.AcceptIfNotError(KS.GT) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2363" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="456" endline="477">
<![CDATA[
 
     Private Function ResolvePropertyGroupInvocation() As Boolean
         Dim result As Boolean = True
         Dim propGroup As PropertyGroupClassification = m_Expression.Classification.AsPropertyGroup
         Dim tmpResult As Boolean
 
         tmpResult = propGroup.ResolveGroup(m_ArgumentList)
 
         If tmpResult = False Then
             tmpResult = ResolveReclassifyToValueThenIndex()
 
             Helper.StopIfDebugging(tmpResult = False)
 
             Return tmpResult
         Else
             result = m_ArgumentList.ReplaceAndVerifyArguments(propGroup.FinalArguments, propGroup.ResolvedProperty) AndAlso result
         End If
 
         Classification = New PropertyAccessClassification(propGroup)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2364" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="71" endline="88">
<![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2365" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="229" endline="257">
<![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         If m_Get IsNot Nothing Then
             result = m_Get.DefineMember() AndAlso result
         End If
 
         If m_Set IsNot Nothing Then
             result = m_Set.DefineMember AndAlso result
         End If
 
         Dim name As String
         Dim attributes As Mono.Cecil.PropertyAttributes
         Dim returnType As Mono.Cecil.TypeReference
         Dim parameterTypes() As Mono.Cecil.TypeReference
 
         name = Me.Name
         attributes = 0 'Mono.Cecil.PropertyAttributes.None
         returnType = Me.Signature.ReturnType
         parameterTypes = Me.Signature.Parameters.ToTypeArray
 
         Helper.SetTypeOrTypeBuilder(Compiler, parameterTypes)
         returnType = Helper.GetTypeOrTypeBuilder(Compiler, returnType)
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2367" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="187" endline="201">
<![CDATA[
     End Property
 
     Public Function VerifyParameterNamesDoesntMatchFunctionName() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Parameters.Count - 1
             Dim p As Parameter = Parameters(i)
 
             If Helper.CompareName(p.Name, Name) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30530, Me.Location)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2368" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="90" endline="98">
<![CDATA[
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2369" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3194" endline="3206">
<![CDATA[
 
     Private Function ParseIntDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMultDiv(Info)
 
         While tm.Accept(KS.IntDivision)
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.IntDivision)
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2370" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3207" endline="3219">
<![CDATA[
 
     Private Function ParseMod(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIntDiv(Info)
 
         While tm.Accept(KS.Mod)
             rSide = ParseIntDiv(Info)
             lSide = New ModExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Mod)
             rSide = ParseIntDiv(Info)
             lSide = New ModExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2371" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5023" endline="5031">
<![CDATA[
 
     Private Function ParseResumeStatement(ByVal Parent As ParsedObject) As ResumeStatement
         Dim m_IsResumeNext As Boolean
 
         tm.AcceptIfNotInternalError(KS.Resume)
         m_IsResumeNext = tm.Accept(KS.Next)
 
         Return New ResumeStatement(Parent, m_IsResumeNext)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2372" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3145" endline="3157">
<![CDATA[
 
     Private Function ParseExponent(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIdentifier(Info)
 
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2373" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="54" endline="65">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_ExpressionType = m_PropertyAccess.Type
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2381" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="72" endline="79">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Interface)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2382" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2159" endline="2168">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     <Diagnostics.Conditional("DEBUG")> _
     Shared Sub Assert(ByVal Condition As Boolean, ByVal Message As String)
         If Condition = False Then
             Diagnostics.Debug.WriteLine(Message)
             If SharedCompiler IsNot Nothing Then SharedCompiler.Report.WriteLine(Report.ReportLevels.Debug, Message)
         End If
         Assert(Condition)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2383" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ConstantExpression.vb" startline="38" endline="45">
<![CDATA[
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         If m_Value IsNot Nothing Then
             Classification = New ValueClassification(Me, m_ExpressionType, m_Value)
         Else
             Classification = New ValueClassification(Me, m_ExpressionType, DBNull.Value)
         End If
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2384" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="536" endline="554">
<![CDATA[
 
     ''' <summary>
     ''' AttributeList  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeList(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         Do
             Dim Attribute As Attribute
             Attribute = ParseAttribute(Parent)
             If Attribute Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Attributes.Add(Attribute)
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2385" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="170" endline="186">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Skips tokens until a newline is found.
     ''' Returns if CodeEnd of EndOfFile found.
     ''' </summary>
     ''' <param name="EatNewLine">Eat the newline character?</param>
     ''' <param name="ReportError">Report the error "End of line expected."? (Always shown if this paramter is true.</param>
     ''' <remarks></remarks>
     Sub GotoNewline(ByVal EatNewLine As Boolean, Optional ByVal ReportError As Boolean = False)
         If ReportError Then Compiler.Report.ShowMessage(Messages.VBNC90018, CurrentLocation)
 
         Do Until CurrentToken.IsEndOfLine
             NextToken()
         Loop
         Do Until CurrentToken.IsEndOfLine
             NextToken()
         Loop
         If EatNewLine AndAlso CurrentToken.IsEndOfFile = False Then NextToken()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2386" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="44" endline="51">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Structure)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2387" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="140" endline="147">
<![CDATA[
 
     ReadOnly Property InstanceExpression() As Expression
         Get
             If m_InstanceExpression Is Nothing AndAlso m_Classification IsNot Nothing Then
                 m_InstanceExpression = m_Classification.InstanceExpression
             End If
             Return m_InstanceExpression
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2388" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceSubDeclaration.vb" startline="31" endline="38">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Sub)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2389" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Nameables.vb" startline="58" endline="73">
<![CDATA[
 
     ''' <summary>
     ''' Adds a new object to this collection.
     ''' </summary>
     ''' <param name="Base"></param>
     ''' <remarks></remarks>
     Shadows Sub Add(ByVal Base As T)
         'This is a workaround for #463303
         Dim B As INameable = DirectCast(Base, INameable)
 
 #If DEBUG Then
         If B.Name = "" Then Throw New InternalException(Base)
 #End If
         MyBase.Add(Base)
         m_Index.Add(Base)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2390" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="639" endline="655">
<![CDATA[
 
     ''' <summary>
     ''' Parses lists of type List 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseList(Of T As BaseObject)(ByVal List As BaseList(Of T), ByVal ParseMethod As ParseDelegate_Parent(Of T), ByVal Parent As ParsedObject) As Boolean
         Helper.Assert(List IsNot Nothing, "List was nothing, tm.CurrentToken=" & tm.CurrentLocation.ToString(Compiler))
         Do
             Dim newObject As T
             newObject = ParseMethod(Parent)
             If newObject Is Nothing Then
                 Return False
             End If
             List.Add(newObject)
         Loop While tm.Accept(KS.Comma)
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2392" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3243" endline="3255">
<![CDATA[
 
     Private Function ParseConcat(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParsePlusMinus(Info)
 
         While tm.Accept(KS.Concat)
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Concat)
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2393" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2074" endline="2088">
<![CDATA[
 
     Private Function ParseCIntExpression(ByVal Parent As ParsedObject) As CIntExpression
         Dim result As New CIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2394" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2089" endline="2103">
<![CDATA[
 
     Private Function ParseCLngExpression(ByVal Parent As ParsedObject) As CLngExpression
         Dim result As New CLngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CLng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2395" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2104" endline="2118">
<![CDATA[
 
     Private Function ParseCObjExpression(ByVal Parent As ParsedObject) As CObjExpression
         Dim result As New CObjExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CObj)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2396" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2119" endline="2133">
<![CDATA[
 
     Private Function ParseCSByteExpression(ByVal Parent As ParsedObject) As CSByteExpression
         Dim result As New CSByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2397" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2149" endline="2163">
<![CDATA[
 
     Private Function ParseCSngExpression(ByVal Parent As ParsedObject) As CSngExpression
         Dim result As New CSngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2398" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2164" endline="2178">
<![CDATA[
 
     Private Function ParseCStrExpression(ByVal Parent As ParsedObject) As CStrExpression
         Dim result As New CStrExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CStr)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2399" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2179" endline="2193">
<![CDATA[
 
     Private Function ParseCUIntExpression(ByVal Parent As ParsedObject) As CUIntExpression
         Dim result As New CUIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2400" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4081" endline="4093">
<![CDATA[
 
     Private Function ParseConstantDeclarations(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal Modifiers As Modifiers) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Do
             Dim newCD As ConstantDeclaration = Nothing
             newCD = ParseConstantDeclaration(Parent, New ParseAttributableInfo(Parent.Compiler, Attributes), Modifiers)
             If newCD Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Add(newCD)
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2401" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="341" endline="364">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' Accepts only newline, not endofcode, nor endoffile. 
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <param name="EOFIsError">Specifies whether to return false if the current token is EOF or not.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptNewLine(Optional ByVal GotoNewline As Boolean = False, Optional ByVal EOFIsError As Boolean = True, Optional ByVal ReportError As Boolean = False) As Boolean
         If CurrentToken.IsEndOfLine Then
             If CurrentToken.IsEndOfLineOnly Then
                 NextToken()
                 Return True
             ElseIf EOFIsError = False Then
                 Return True
             Else
                 Return False
             End If
         Else
             If GotoNewline Then Me.GotoNewline(True, ReportError)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2402" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="39" endline="62">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitOr(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__OrObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2403" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitXOr(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__XorObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2404" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="59" endline="79">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConcatenateObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2405" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3172" endline="3193">
<![CDATA[
 
     Private Function ParseMultDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseUnaryPlusMinus(Info)
 
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2406" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="529" endline="540">
<![CDATA[
     End Property
 
     Overridable ReadOnly Property IsOneLiner() As Boolean
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Return False
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2407" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="223" endline="241">
<![CDATA[
 
     ''' <summary>
     ''' Skips tokens until it finds any of the specified tokens.
     ''' If StopOnNewLine = True then stops also when a NewLine is found 
     ''' (the newline token is not eaten).
     ''' </summary>
     ''' <param name="StopOnNewline"></param>
     ''' <param name="Specials"></param>
     ''' <remarks></remarks>
     Sub GotoAny(ByVal StopOnNewline As Boolean, ByVal ParamArray Specials() As KS)
         Do Until (CurrentToken.Equals(Specials))
             If StopOnNewline AndAlso CurrentToken.IsEndOfLine Then
                 Return
             ElseIf CurrentToken.IsEndOfFile Then
                 Return
             End If
             NextToken()
         Loop
         Do Until (CurrentToken.Equals(Specials))
             If StopOnNewline AndAlso CurrentToken.IsEndOfLine Then
                 Return
             ElseIf CurrentToken.IsEndOfFile Then
                 Return
             End If
             NextToken()
         Loop
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2413" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="54" endline="62">
<![CDATA[
 
     Public Property ConstantValue() As Object
         Get
             If m_ResolvedMember = False Then
                 'Helper.StopIfDebugging()
                 ResolveMember(ResolveInfo.Default(Compiler))
             End If
             Return m_FieldBuilderCecil.Constant
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2414" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="168" endline="177">
<![CDATA[
 
     Function IdentiferOrKeywordIdentifier() As String
         If IsKeyword() Then
             Return Identifier
         ElseIf IsIdentifier() Then
             Return Identifier
         Else
             Throw New InternalException()
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2415" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4778" endline="4794">
<![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseTypeVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As Generic.List(Of TypeVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseTypeVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2416" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="55" endline="69">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression.IsResolved = False Then
             result = m_Expression.ResolveExpression(Info)
         Else
             result = True
         End If
 
         Classification = New ValueClassification(Me, Me.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2417" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3158" endline="3171">
<![CDATA[
 
     Private Function ParseUnaryPlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As UnaryExpression
 
         If tm.CurrentToken = KS.Add Then
             result = ParseUnaryPlusExpression(Info)
         ElseIf tm.CurrentToken = KS.Minus Then
             result = ParseUnaryMinusExpression(Info)
         Else
             Return ParseExponent(Info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2418" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="142" endline="155">
<![CDATA[
     End Property
 
     Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim constant As Object = Nothing 'm_ResolvedProperty.GetConstantValue
         If constant IsNot Nothing Then
             Emitter.EmitLoadValue(Info, constant)
         Else
             Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, m_Parameters, CecilHelper.GetGetMethod(m_ResolvedProperty))
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2419" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="65" endline="76">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lInfo As EmitInfo = Info.Clone(Me, RSide)
 
         Helper.Assert(LSide.Classification.IsVariableClassification OrElse LSide.Classification.IsPropertyAccessClassification)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2420" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2421" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="338" endline="356">
<![CDATA[
 
     Public Shared Function EmitLateIndexGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexGet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
         '2 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2422" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="30" endline="52">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Decimal
             Case TypeCode.Single, TypeCode.Double
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__PlusObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2423" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="74" endline="86">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim casestmt As CaseStatement = Me.FindFirstParent(Of CaseStatement)()
         Dim selectstmt As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         result = m_ComparisonExpression.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
 
         Emitter.EmitBranchIfTrue(Info, casestmt.StartCode)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2424" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="30" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Local Is Nothing Then
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
             m_Local = Emitter.DeclareLocal(Info, m_Expression.ExpressionType)
             Emitter.EmitStoreVariable(Info, m_Local)
         End If
 
         Emitter.EmitLoadVariable(Info, m_Local)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2425" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ExponentExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Math__Pow_Double_Double)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ExponentObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2426" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="792" endline="809">
<![CDATA[
 
     Private Function ResolveAliasImports(ByVal imps As ImportsClauses, ByVal Name As String) As Boolean
         Dim import As ImportsClause = imps.Item(Name)
         Dim nsimport As ImportsNamespaceClause
         If import IsNot Nothing Then
             nsimport = import.AsAliasClause.NamespaceClause
             If nsimport.IsNamespaceImport Then
                 Classification = New NamespaceClassification(Me, nsimport.NamespaceImported)
                 Return True
             ElseIf nsimport.IsTypeImport Then
                 Classification = New TypeClassification(Me, nsimport.TypeImported)
                 Return True
             Else
                 Throw New InternalException(Me)
             End If
         End If
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2427" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="86" endline="105">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If Classification IsNot Nothing Then Return True
 
         result = m_Expression.ResolveExpression(New ResolveInfo(Info.Compiler, True)) AndAlso result
 
         If m_Expression.Classification.IsMethodGroupClassification Then
             Dim mpClassification As MethodPointerClassification
             mpClassification = New MethodPointerClassification(Me, m_Expression.Classification.AsMethodGroupClassification)
             Classification = mpClassification
 
             m_ExpressionType = Info.Compiler.TypeCache.DelegateUnresolvedType
         Else
             Helper.AddError(Me, Me.Location.ToString(Compiler))
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2428" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="134" endline="148">
<![CDATA[
 
     ''' <summary>
     ''' Reclassifies the method group to a value, at the same time the method
     ''' group might be resolved using an empty argument list.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function ReclassifyToValue() As ValueClassification
         Dim result As ValueClassification
         If m_Resolved = False Then
             Me.ResolveGroup(New ArgumentList(Me.Parent))
         End If
         result = New ValueClassification(Me)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2429" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="110" endline="125">
<![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If m_Expression.IsConstant = False Then
                 Return False
             Else
                 Dim value As Object
                 value = m_Expression.ConstantValue
                 Dim result As Object = Nothing
                 If Compiler.TypeResolution.CheckNumericRange(value, result, ExpressionType) Then
                     Return True
                 Else
                     Return False
                 End If
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2430" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="87" endline="105">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.ResolveExpression(Info) AndAlso result
 
             If result AndAlso m_Expression.Classification.IsMethodGroupClassification Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             ElseIf result AndAlso m_Expression.Classification.IsPropertyGroupClassification Then
                 m_Expression = m_Expression.ReclassifyToPropertyAccessExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2431" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3735" endline="3771">
<![CDATA[
 
     ''' <summary>
     ''' Tries to parse a sub signature. Returns false if not successful.
     ''' SubSignature  
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="m_Identifier">Output parameter, must be nothing on entry.</param>
     ''' <param name="m_TypeParameters">Output parameter, must be nothing on entry.</param>
     ''' <param name="m_ParameterList">Input/Output parameter, must not be nothing on entry.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseSubSignature(ByVal Parent As ParsedObject, ByRef m_Identifier As Identifier, ByRef m_TypeParameters As TypeParameters, ByVal m_ParameterList As ParameterList) As Boolean
         Dim result As Boolean = True
 
         'Helper.Assert(m_Identifier Is Nothing)
         Helper.Assert(m_TypeParameters Is Nothing)
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         m_Identifier = ParseIdentifier(Parent)
         result = m_Identifier IsNot Nothing AndAlso result
 
         If vbnc.TypeParameters.IsMe(tm) Then
             m_TypeParameters = ParseTypeParameters(Parent)
         End If
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 result = tm.AcceptIfNotError(KS.RParenthesis) AndAlso result
             End If
         End If
 
         'Helper.Assert(m_Identifier IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2432" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6257" endline="6280">
<![CDATA[
 
     Private Function FindTypeInParent(ByVal Parent As ParsedObject, ByVal CompleteName As String) As TypeDeclaration
         Dim assemblyParent As AssemblyDeclaration = TryCast(Parent, AssemblyDeclaration)
         Dim typeParent As TypeDeclaration = TryCast(Parent, TypeDeclaration)
         Dim partialType As TypeDeclaration = Nothing
         Dim partialTypes As Generic.List(Of INameable)
 
         If assemblyParent IsNot Nothing Then
             partialType = assemblyParent.FindTypeWithFullname(CompleteName)
         ElseIf typeParent IsNot Nothing Then
             partialTypes = typeParent.Members.Index.Item(CompleteName)
             If partialTypes IsNot Nothing Then
                 If partialTypes.Count = 1 Then
                     partialType = TryCast(partialTypes(0), TypeDeclaration)
                     If partialType Is Nothing Then
                         Helper.AddError(Compiler, tm.CurrentLocation, "Already a member with the name " & CompleteName)
                     End If
                 ElseIf partialTypes.Count > 1 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Already a member with the name " & CompleteName)
                 End If
             End If
         End If
         Return partialType
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2433" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3498" endline="3506">
<![CDATA[
 
     Shared Function IsFirstLessGeneric(ByVal Context As BaseObject) As Boolean
         'A member M is determined to be less generic than a member N using the following steps
         '-	If M has fewer method type parameters than N, then M is less generic than N.
         '-	Otherwise, if for each pair of matching parameters Mj and Nj, Mj and Nj are equally generic with respect to type parameters on the method, or Mj is less generic with respect to type parameters on the method, and at least one Mj is less generic than Nj, then M is less generic than N.
         '-	Otherwise, if for each pair of matching parameters Mj and Nj, Mj and Nj are equally generic with respect to type parameters on the type, or Mj is less generic with respect to type parameters on the type, and at least one Mj is less generic than Nj, then M is less generic than N.
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2434" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="388" endline="405">
<![CDATA[
 
     Public Shared Function EmitLateIndexSet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexSet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
 
         '2 - The arguments
         '3 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexSet_Object_Array_Array)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2435" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1189" endline="1210">
<![CDATA[
 
     ''' <summary>
     ''' ArrayTypeModifier  
     ''' RankList  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayTypeModifier(ByVal Parent As ParsedObject) As ArrayTypeModifier
         Dim result As New ArrayTypeModifier(Parent)
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         Dim m_Ranks As Integer
         Do
             m_Ranks += 1
         Loop While tm.Accept(KS.Comma)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Ranks)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2436" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="256" endline="269">
<![CDATA[
 
     Function Compile(ByVal CommandLine As String()) As Integer
         'Try
         If m_CommandLine.Parse(CommandLine) = False Then
             If m_CommandLine.NoLogo = False Then
                 ShowLogo()
             End If
             If Report.ShowSavedMessages() = False Then
                 ShowHelp()
             End If
             Return 1
         End If
         Return Compile()
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2437" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3220" endline="3242">
<![CDATA[
 
     Private Function ParsePlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMod(Info)
 
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2438" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="134" endline="152">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, _
                   TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Return CBool(originalValue) 'No range checking needed.
                 Case TypeCode.DBNull
                     Return CBool(Nothing)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2439" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="463" endline="480">
<![CDATA[
 
     Function ReportReclassifyToValueErrorMessage() As Boolean
 
         Select Case m_Classification.Classification
             Case ExpressionClassification.Classifications.EventAccess
                 Compiler.Report.ShowMessage(Messages.VBNC32022, Me.Location)
             Case ExpressionClassification.Classifications.Type
                 Compiler.Report.ShowMessage(Messages.VBNC30108, Me.Location)
             Case ExpressionClassification.Classifications.Namespace
                 Compiler.Report.ShowMessage(Messages.VBNC30112, Me.Location)
             Case ExpressionClassification.Classifications.Void
                 Compiler.Report.ShowMessage(Messages.VBNC30491, Me.Location)
             Case Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End Select
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2440" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2518" endline="2546">
<![CDATA[
 
     ''' <summary>
     ''' DelegateCreationExpression 
     ''' ObjectCreationExpression   
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateOrObjectCreationExpression(ByVal Parent As ParsedObject) As DelegateOrObjectCreationExpression
         Dim result As New DelegateOrObjectCreationExpression(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName = Nothing
         Dim m_ArgumentList As ArgumentList = Nothing
 
         tm.AcceptIfNotInternalError(KS.[New])
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.CurrentToken <> KS.RParenthesis Then
                 m_ArgumentList = ParseArgumentList(result)
                 If m_ArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If m_ArgumentList Is Nothing Then m_ArgumentList = New ArgumentList(result)
 
         result.Init(m_NonArrayTypeName, m_ArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2441" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="106" endline="114">
<![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             If MyBase.IsResolved Then
                 Return m_ExpressionType
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2442" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="743" endline="749">
<![CDATA[
     End Property
 
     ReadOnly Property ParamArrayExpression() As ArrayCreationExpression
         Get
             If m_IsParamArray = False Then Return Nothing
             Return DirectCast(m_ExactArguments(m_ExactArguments.Count - 1).Expression, ArrayCreationExpression)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2443" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4795" endline="4811">
<![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseLocalVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2444" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="75" endline="87">
<![CDATA[
 
     ReadOnly Property ConstantValue() As Object
         Get
             If m_Resolved = False Then
                 Dim result As Boolean
                 result = ResolveConstantValue(ResolveInfo.Default(Compiler))
                 If result = False Then
                     Helper.AddError(Me, "")
                     Return Nothing
                 End If
             End If
             Return m_ConstantValue
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2445" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="163" endline="174">
<![CDATA[
     End Property
 
     ReadOnly Property FieldDefinition() As Mono.Cecil.FieldDefinition
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return CecilHelper.FindDefinition(m_FieldInfo)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2446" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="45" endline="53">
<![CDATA[
     End Property
 
     ReadOnly Property Parameters() As ArgumentList
         Get
             If m_Parameters Is Nothing AndAlso m_Classification IsNot Nothing Then
                 m_Parameters = m_Classification.Parameters
             End If
             Return m_Parameters
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2447" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3334" endline="3355">
<![CDATA[
 
     Private Function ParseAnd_AndAlso(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseNot(Info)
 
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2448" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3256" endline="3277">
<![CDATA[
 
     Private Function ParseBitshift(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseConcat(Info)
 
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2449" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3356" endline="3379">
<![CDATA[
 
     Private Function ParseOr_OrElse_Xor(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseAnd_AndAlso(Info)
 
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2451" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\StopStatement.vb" startline="30" endline="38">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ' Helper.NotImplemented()
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Diagnostics_Debugger__Break)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2452" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="136" endline="153">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The namespace or type that is imported.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Name() As String
         Get
             If IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             ElseIf IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2453" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2014" endline="2028">
<![CDATA[
 
     Private Function ParseCCharExpression(ByVal Parent As ParsedObject) As CCharExpression
         Dim result As New CCharExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CChar)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2454" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2029" endline="2043">
<![CDATA[
 
     Private Function ParseCDateExpression(ByVal Parent As ParsedObject) As CDateExpression
         Dim result As New CDateExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDate)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2455" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1985" endline="1998">
<![CDATA[
 
     Private Function ParseCByteExpression(ByVal Parent As ParsedObject) As CByteExpression
         Dim result As New CByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2456" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1999" endline="2013">
<![CDATA[
 
     Private Function ParseCBoolExpression(ByVal Parent As ParsedObject) As CBoolExpression
         Dim result As New CBoolExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CBool)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2457" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2059" endline="2073">
<![CDATA[
 
     Private Function ParseCDecExpression(ByVal Parent As ParsedObject) As CDecExpression
         Dim result As New CDecExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDec)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2458" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2209" endline="2223">
<![CDATA[
 
     Private Function ParseCUShortExpression(ByVal Parent As ParsedObject) As CUShortExpression
         Dim result As New CUShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2459" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="79" endline="95">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New MemberAccessExpression(NewParent)
 
         Dim m_First As Expression = Nothing
         Dim m_Second As IdentifierOrKeyword = Nothing
         '  Dim m_TypeArguments As TypeParameters
 
         If Me.m_First IsNot Nothing Then m_First = Me.m_First.Clone(result)
         If Me.m_Second IsNot Nothing Then m_Second = Me.m_Second.Clone(result)
         '  If Me.m_TypeArguments IsNot Nothing Then m_TypeArguments = Me.m_TypeArguments.Clone(result)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2460" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="207" endline="218">
<![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsString
                 sep = ", "
             Next
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2461" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="219" endline="231">
<![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsTypeString
                 sep = ", "
             Next
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2462" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="587" endline="600">
<![CDATA[
 
     Function FindVariable(ByVal Name As String) As IAttributableNamedDeclaration
         Dim found As Generic.List(Of INameable)
         found = m_Variables.Index.Item(Name)
         If found Is Nothing Then
             Return Nothing
         ElseIf found.Count = 1 Then
             Return DirectCast(found(0), IAttributableNamedDeclaration)
         ElseIf found.Count > 1 Then
             Throw New InternalException(Me)
         Else
             Return Nothing
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2464" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="155" endline="164">
<![CDATA[
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2465" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="45" endline="60">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim falseLabel As Label = Emitter.DefineLabel(Info)
 
         result = m_Condition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, falseLabel)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, ParentAsIfStatement.EndLabel)
 
         Emitter.MarkLabel(Info, falseLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2466" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2224" endline="2253">
<![CDATA[
 
     ''' <summary>
     ''' VariableIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifier(ByVal Parent As ParsedObject) As VariableIdentifier
         Dim result As New VariableIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier
 
         If tm.CurrentToken.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ArrayNameModifier = Nothing
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2467" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="66" endline="79">
<![CDATA[
     End Property
 
     Function PeekToken(Optional ByVal Jump As Integer = 1) As Token
         Helper.Assert(Jump >= -1)
         If Jump = -1 Then Return m_Previous
         If Jump = 0 Then Return CurrentToken()
         If m_TokenList.Count = 0 Then
             m_TokenList.Add(CurrentToken)
         End If
         For i As Integer = m_TokenList.Count To m_CurrentIndex + Jump
             m_TokenList.Add(m_Reader.Next())
         Next
         Return m_TokenList(m_CurrentIndex + Jump)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2468" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="68" endline="81">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveTypeReferences AndAlso result
         'Not necessary.'result = m_ArrayTypeModifiers.ResolveCode AndAlso result
 
         Dim tp As Mono.Cecil.TypeReference = m_TypeName.ResolvedType
         tp = m_ArrayTypeModifiers.CreateArrayType(tp)
         m_ResolvedType = tp
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2469" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="227" endline="247">
<![CDATA[
     End Property
 
     ReadOnly Property CanBePropertyAccessClassification() As Boolean
         Get
             Select Case m_Classification
                 Case Classifications.PropertyGroup
                     Return True
                 Case Classifications.LateBoundAccess
                     Return True
                 Case Classifications.Type
                     Dim tc As TypeClassification = AsTypeClassification
                     Return tc.CanBeExpression AndAlso tc.Expression.Classification.CanBePropertyAccessClassification
                 Case Classifications.Value, Classifications.Variable, Classifications.EventAccess, _
 Classifications.LateBoundAccess, Classifications.MethodGroup, _
 Classifications.MethodPointer, Classifications.PropertyAccess, Classifications.Void, Classifications.Namespace
                     Return False
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2470" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="472" endline="488">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2472" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="63" endline="75">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeName(NewParent)
         If Me.IsNonArrayTypeName Then
             result.Init(Me.AsNonArrayTypeName.clone)
         ElseIf Me.IsArrayTypeName Then
             result.Init(Me.AsArrayTypeName.clone)
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2473" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2134" endline="2148">
<![CDATA[
 
     Private Function ParseCShortExpression(ByVal Parent As ParsedObject) As CShortExpression
         Dim result As New CShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2474" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="42" endline="50">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2475" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5130" endline="5149">
<![CDATA[
 
     ''' <summary>
     ''' ExitStatement  
     ''' ExitKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExitStatement(ByVal Parent As ParsedObject) As ExitStatement
         Dim m_ExitWhat As KS
 
         tm.AcceptIfNotInternalError(KS.Exit)
         If tm.CurrentToken.Equals(KS.Sub, KS.Function, KS.Property, KS.Do, KS.For, KS.Try, KS.While, KS.Select) Then
             m_ExitWhat = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30240, tm.CurrentLocation)
             Return Nothing
         End If
 
         Return New ExitStatement(Parent, m_ExitWhat)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2476" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="170" endline="187">
<![CDATA[
 
     Protected Shared Function GenerateCodeForExpression(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo, ByRef expTypeCode As TypeCode, ByRef expType As TypeReference) As Boolean
         Dim result As Boolean = True
         Dim Expression As Expression = Conversion.Expression
 
         expType = Expression.ExpressionType
 
         result = Expression.Classification.GenerateCode(Info.Clone(Expression, expType)) AndAlso result
 
         If Conversion.ConversionMethod IsNot Nothing Then
             Emitter.EmitCall(Info, Conversion.ConversionMethod)
             expType = Conversion.ConversionMethod.ReturnType
         End If
 
         expTypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2477" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="151" endline="169">
<![CDATA[
 
     Protected Shared Function ValidateForNullable(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression, ByRef expTypeCode As TypeCode, ByRef expType As TypeReference) As Boolean
         Dim result As Boolean = True
         Dim ConversionMethod As MethodReference = Nothing
 
         expType = Conversion.Expression.ExpressionType
 
         If CecilHelper.IsNullable(expType) Then
             If SelectNarrowingConversionOperator(Info.Compiler, expType, Conversion.ExpressionType, ConversionMethod) = False Then
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Conversion.Expression.Location)
             End If
             expType = CecilHelper.GetNulledType(expType)
             Conversion.ConversionMethod = ConversionMethod
         End If
 
         expTypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2478" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="102" endline="111">
<![CDATA[
 
     Private Function GenerateCodeForPreserve(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_ArrayType)) AndAlso result
         Emitter.EmitCastClass(Info, m_Expression.ExpressionType, Compiler.TypeCache.System_Array)
         result = GenerateCodeForNewArray(Info) AndAlso result
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Utils__CopyArray_Array_Array)
         Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Array, m_ArrayType)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2479" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="519" endline="533">
<![CDATA[
 
     Sub RemoveNarrowingExceptObject()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowingExceptObject Then
                 Log("NARROWING (EXCEPT OBJECT)    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING (EXCEPT OBJECT)
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2480" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="124" endline="135">
<![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsBuiltInTypeName Then
                 Return AsBuiltInTypeName.Name
             ElseIf IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2481" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2044" endline="2058">
<![CDATA[
 
     Private Function ParseCDblExpression(ByVal Parent As ParsedObject) As CDblExpression
         Dim result As New CDblExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDbl)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2482" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2194" endline="2208">
<![CDATA[
 
     Private Function ParseCULngExpression(ByVal Parent As ParsedObject) As CULngExpression
         Dim result As New CULngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CULng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2483" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="76" endline="82">
<![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             If TypeOf m_TypeName Is NonArrayTypeName Then Return AsNonArrayTypeName.Name
             If TypeOf m_TypeName Is ArrayTypeName Then Return AsArrayTypeName.Name
             Return DirectCast(m_TypeName, INameable).Name
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2484" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5110" endline="5129">
<![CDATA[
 
 
     ''' <summary>
     ''' GotoStatement  
     ''' LabelName 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseGotoStatement(ByVal Parent As ParsedObject) As GotoStatement
         Dim m_GotoWhere As Token
 
         tm.AcceptIfNotInternalError(KS.GoTo)
         If tm.CurrentToken.IsIdentifier OrElse tm.CurrentToken.IsIntegerLiteral Then
             m_GotoWhere = tm.CurrentToken
             tm.NextToken()
         Else
             Return Nothing
         End If
 
         Return New GotoStatement(Parent, m_GotoWhere)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2485" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6083" endline="6103">
<![CDATA[
 
     ''' <summary>
     ''' ImportsStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsStatement(ByVal Parent As ParsedObject) As ImportsStatement
         Dim result As New ImportsStatement(Parent)
 
         Dim m_Clauses As ImportsClauses
 
         tm.AcceptIfNotInternalError(KS.Imports)
 
         m_Clauses = ParseImportsClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2486" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2322" endline="2344">
<![CDATA[
 
     ''' <summary>
     ''' ParenthesizedExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParenthesizedExpression(ByVal Parent As ParsedObject) As ParenthesizedExpression
         Dim result As New ParenthesizedExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_Expression = ParseExpression(result)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2487" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="814" endline="839">
<![CDATA[
 
     ''' <summary>
     ''' ArrayElementInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayElementInitializer(ByVal Parent As ParsedObject) As ArrayElementInitializer
         Dim result As New ArrayElementInitializer(Parent)
 
         Dim m_VariableInitializerList As VariableInitializerList
 
         m_VariableInitializerList = New VariableInitializerList(result)
 
         tm.AcceptIfNotInternalError(KS.LBrace)
         If tm.Accept(KS.RBrace) = False Then
 
             If ParseList(Of VariableInitializer)(m_VariableInitializerList, New ParseDelegate_Parent(Of VariableInitializer)(AddressOf ParseVariableInitializer), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_VariableInitializerList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2488" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="435" endline="455">
<![CDATA[
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2489" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="58" endline="74">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_WithExpression Is m_WithVariableExpression = False Then
             m_WithVariable = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, m_WithExpression.ExpressionType), "WithVariable" & Me.ObjectID.ToString)
             result = m_WithExpression.GenerateCode(Info.Clone(Me, True, False, m_WithVariable.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_WithVariable)
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         Emitter.FreeLocal(m_WithVariable)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2490" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="94" endline="110">
<![CDATA[
 
     Public Shared Sub EmitArrayCreation(ByVal Parent As ParsedObject, ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal asim As ArraySizeInitializationModifier)
         Dim Ranks As Integer = asim.BoundList.Expressions.Length
         For i As Integer = 0 To Ranks - 1
             Dim litexp As New ConstantExpression(Parent, 1, Parent.Compiler.TypeCache.System_Int32)
             Dim exp As Expression
 
             exp = New BinaryAddExpression(Parent, asim.BoundList.Expressions(i), litexp)
             exp = New CIntExpression(Parent, exp)
 
             If exp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) = False Then Throw New InternalException(Parent)
             If exp.GenerateCode(Info.Clone(Parent, True)) = False Then Throw New InternalException(Parent)
 
             'Emitter.EmitConversion(exp.ExpressionType, Parent.Compiler.TypeCache.System_Int32, Info)
         Next
         EmitArrayConstructor(Info, ArrayType, Ranks)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2491" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="61" endline="83">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Target.Classification.IsLateBoundClassification Then
             result = m_Target.GenerateCode(Info) AndAlso result
 
             Return result
         End If
 
         Helper.Assert(m_Target.Classification.IsValueClassification OrElse m_Target.Classification.IsVoidClassification)
 
         If IsExcluded() Then Return result
 
         result = m_Target.GenerateCode(Info.Clone(Me, True)) AndAlso result
         If m_Target.Classification.IsValueClassification Then
             If Helper.CompareType(m_Target.Classification.AsValueClassification.Type, Compiler.TypeCache.System_Void) = False Then
                 Emitter.EmitPop(Info, m_Target.ExpressionType)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2492" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2056" endline="2063">
<![CDATA[
 
     Shared Function DefineCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.Define AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2493" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClause.vb" startline="68" endline="77">
<![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             If Me.IsAliasClause Then
                 Return Me.AsAliasClause.Name
             Else
                 Return ""
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2511" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4762" endline="4777">
<![CDATA[
 
     ''' <summary>
     ''' LocalDeclarationStatement  
     ''' </summary>
     Private Function ParseLocalDeclarationStatement(ByVal Parent As CodeBlock) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.LocalModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_Modifiers, New ParseAttributableInfo(Compiler, Nothing))
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2512" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5205" endline="5222">
<![CDATA[
 
     Private Function ParseReturnStatement(ByVal Parent As ParsedObject) As ReturnStatement
         Dim result As New ReturnStatement(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Return)
         If Not tm.CurrentToken.IsEndOfStatement Then
             m_Expression = ParseExpression(result)
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression = Nothing
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2513" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1899" endline="1932">
<![CDATA[
 
     ''' <summary>
     ''' MemberAccessExpression 
     ''' MemberAccessBase 
     ''' 
     ''' TODO
     ''' LAMESPEC
     ''' MemberAccessExpression 
     ''' </summary>
     ''' <param name="FirstExpression"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseMemberAccessExpression(ByVal Parent As ParsedObject, ByVal FirstExpression As Expression) As MemberAccessExpression
         Dim result As New MemberAccessExpression(Parent)
 
         Dim m_First As Expression
         Dim m_Second As IdentifierOrKeywordWithTypeArguments
 
         m_First = FirstExpression 'Might be nothing.
         If m_First IsNot Nothing Then m_First.Parent = result
         'According to the language specification, the dot is optional,
         'but that doesn't seem to be correct... so let's make it 
         'required
         tm.AcceptIfNotInternalError(KS.Dot)
         'Specifically, this is not a MemberAccessExpression without the
         'dot, so it is an internal error.
 
         m_Second = ParseIdentifierOrKeywordWithTypeArguments(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2514" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2646" endline="2672">
<![CDATA[
     ''' <summary>
     ''' A single identifier followed by an optional type argument list.
     ''' 
     ''' SimpleNameExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleNameExpression(ByVal Parent As ParsedObject) As SimpleNameExpression
         Dim result As New SimpleNameExpression(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeArgumentList As TypeArgumentList
 
         m_Identifier = ParseIdentifier(result)
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             m_TypeArgumentList = ParseTypeArgumentList(result)
             If m_TypeArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             'If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented()
         Else
             m_TypeArgumentList = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2515" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="82" endline="123">
<![CDATA[
 
     Friend Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal IsAddHandler As Boolean) As Boolean
         Dim result As Boolean = True
 
         Dim handler As Mono.Cecil.MethodReference
 
         '1 - Load the instance expression of the event (m_Event)
         '    (first argument to the add/remove method - the this pointer)
         '2 - Create the delegate to call when the event is fired.
         '    (second argument to the add/remove method).
         '2.1 - Load the instance expression of the eventhandler (m_EventHandler)
         '      (first argument to the delegate constructor).
         '2.2 - Load the method pointer of the eventhandler (m_EventHandler)
         '      (second argument to the delegate constructor).
         '2.2.1 - Load the instance expression of the eventhandler (m_EventHandler)
         '        (the argument of the load method pointer instruction)
         '2.2.2 - Call the method pointer creation instruction.
         '2.3 - Call the delegate's constructor.
         '3 - Call the add/remove method
 
         Helper.Assert(m_Event.Classification.IsEventAccessClassification)
         Helper.Assert(m_EventHandler.Classification.IsValueClassification)
 
         Dim evt As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(m_Event.Classification.AsEventAccess.EventInfo)
 
         If IsAddHandler Then
             handler = evt.AddMethod
         Else
             handler = evt.RemoveMethod
         End If
 
         If Helper.IsShared(handler) = False Then
             result = m_Event.Classification.AsEventAccess.GenerateCode(Info) AndAlso result
         End If
         result = m_EventHandler.Classification.GenerateCode(Info.Clone(Me, True, False, m_EventHandler.ExpressionType)) AndAlso result
 
         Helper.Assert(handler IsNot Nothing)
 
         Emitter.EmitCallOrCallVirt(Info, handler)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2516" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="972" endline="997">
<![CDATA[
 
     ''' <summary>
     ''' BoundList
     ''' UpperBoundList
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseBoundList(ByVal Parent As ParsedObject) As BoundList
         Dim result As New BoundList(Parent)
 
         Dim newExp As Expression = Nothing
         Dim tmp As New Generic.List(Of Expression)
 
         Do
             If tm.CurrentToken.IsIntegerLiteral AndAlso tm.CurrentToken.IntegralLiteral = 0 AndAlso tm.PeekToken.Equals(KS.To) Then tm.NextToken(2)
             newExp = ParseExpression(result)
             If newExp Is Nothing Then
                 If m_ShowErrors = False Then Return Nothing
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             tmp.Add(newExp)
         Loop While tm.Accept(KS.Comma)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2517" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="500" endline="516">
<![CDATA[
     ''' <summary>
     '''  Parses attributes (if any). Always returns something.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject) As Attributes
         Dim result As New Attributes(Parent)
 
         If Attributes.IsMe(tm) Then
             While AttributeBlock.IsMe(tm)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
             While AttributeBlock.IsMe(tm)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2518" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="840" endline="862">
<![CDATA[
 
     ''' <summary>
     ''' VariableInitializer  
     ''' RegularInitializer 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableInitializer(ByVal Parent As ParsedObject) As VariableInitializer
         Dim result As New VariableInitializer(Parent)
 
         If ArrayElementInitializer.CanBeMe(tm) Then
             Dim newAEI As ArrayElementInitializer
             newAEI = ParseArrayElementInitializer(Parent)
             If newAEI Is Nothing Then Return Nothing
             result.Init(newAEI)
         Else
             Dim newExp As Expression
             newExp = ParseExpression(Parent)
             If newExp Is Nothing Then Return Nothing
             result.Init(newExp)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2519" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="947" endline="971">
<![CDATA[
 
     ''' <summary>
     ''' TypeImplementsClause  
     ''' Implements  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeImplementsClauses(ByVal Parent As ParsedObject) As TypeImplementsClauses
         Dim result As New TypeImplementsClauses(Parent)
 
         Dim m_Clauses As New Generic.List(Of NonArrayTypeName)
 
         Do While tm.Accept(KS.Implements)
             Do
                 Dim newI As NonArrayTypeName
                 newI = ParseNonArrayTypeName(result)
                 If newI Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Clauses.Add(newI)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While tm.Accept(KS.Implements)
             Do
                 Dim newI As NonArrayTypeName
                 newI = ParseNonArrayTypeName(result)
                 If newI Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Clauses.Add(newI)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         result.Init(m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2520" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1959" endline="1984">
<![CDATA[
 
     ''' <summary>
     ''' DictionaryAccessExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDictionaryAccessExpression(ByVal Parent As ParsedObject, ByVal FirstPart As Expression) As DictionaryAccessExpression
         Dim result As New DictionaryAccessExpression(Parent)
 
         Dim m_FirstPart As Expression
         Dim m_SecondPart As IdentifierOrKeyword
 
         m_FirstPart = FirstPart
         If m_FirstPart IsNot Nothing Then m_FirstPart.Parent = result
         tm.AcceptIfNotInternalError(KS.Exclamation)
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_SecondPart = ParseIdentifierOrKeyword(result)
             If m_SecondPart Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_FirstPart, m_SecondPart)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2521" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1826" endline="1837">
<![CDATA[
 
     Shared Sub EmitStoreVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitStoreVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitStoreField(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitStoreVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2522" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="97" endline="117">
<![CDATA[
 
     ''' <summary>
     ''' Get the parent code block. Might be nothing!
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindParentCodeBlock() As CodeBlock
         If TypeOf Parent Is CodeBlock Then
             Return DirectCast(Parent, CodeBlock)
         Else
             If TypeOf Parent Is Expression Then
                 Return DirectCast(Parent, Expression).FindParentCodeBlock
             ElseIf TypeOf Parent Is BlockStatement Then
                 Return DirectCast(Parent, BlockStatement).CodeBlock
             ElseIf TypeOf Parent Is Statement Then
                 Return DirectCast(Parent, Statement).FindParentCodeBlock
             Else
                 Return Nothing
             End If
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2523" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="414" endline="427">
<![CDATA[
 
     Overloads Function Equals(ByVal obj As Token) As Boolean
         If Me.IsIdentifier AndAlso obj.IsIdentifier Then
             Return Me.Equals(obj.Identifier)
         ElseIf Me.IsLiteral AndAlso obj.IsLiteral Then
             Return Me.LiteralValue.Equals(obj.LiteralValue)
         ElseIf Me.IsKeyword AndAlso obj.IsKeyword Then
             Return Me.Keyword = obj.Keyword
         ElseIf Me.IsSymbol AndAlso obj.IsSymbol Then
             Return Me.Symbol = obj.Symbol
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2524" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="199" endline="212">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2525" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="213" endline="222">
<![CDATA[
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2526" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="54" endline="70">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             Helper.Assert(Me.Classification.IsValueClassification)
             If Me.Classification.CanBeValueClassification Then
                 result = Me.Classification.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2527" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4945" endline="4966">
<![CDATA[
 
     Private Function ParseInterfacePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfacePropertyMemberDeclaration
         Dim result As New InterfacePropertyMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfacePropertyModifier)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2528" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4185" endline="4212">
<![CDATA[
 
     ''' <summary>
     ''' EnumMemberDeclaration  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal EnumIndex As Integer) As EnumMemberDeclaration
         Dim result As New EnumMemberDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ConstantExpression As Expression
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Equals) Then
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(EnumIndex, m_Identifier, m_ConstantExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2529" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="32" endline="48">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim isSub As Boolean
 
         isSub = Info.Method.Signature.ReturnType Is Nothing OrElse Helper.CompareType(Info.Method.Signature.ReturnType, Compiler.TypeCache.System_Void)
         If isSub Then
             Helper.Assert(m_Expression Is Nothing)
         Else
             Helper.Assert(m_Expression IsNot Nothing)
             result = m_Expression.GenerateCode(Info.Clone(Me, True, , Info.Method.Signature.ReturnType)) AndAlso result
         End If
 
         Emitter.EmitRetOrLeave(Info, Me, Not isSub)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2530" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5332" endline="5359">
<![CDATA[
     ''' <summary>
     ''' WhileStatement  
     '''	   "While" BooleanExpression  StatementTerminator
     '''	         [  Block  ]
     '''	   "End" "While" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWhileStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WhileStatement
         Dim result As New WhileStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.While)
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.While) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Condition, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2531" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5504" endline="5533">
<![CDATA[
 
     ''' <summary>
     '''SyncLockStatement  
     '''	"SyncLock" Expression  StatementTerminator
     '''	   [  Block  ]
     '''	"End" "SyncLock" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSyncLockStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SyncLockStatement
         Dim result As New SyncLockStatement(Parent)
 
         Dim m_Lock As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.SyncLock)
 
         m_Lock = ParseExpression(result)
         If m_Lock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.SyncLock) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Lock, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2532" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="64" endline="72">
<![CDATA[
     End Property
 
     Public ReadOnly Property EventField() As Mono.Cecil.FieldDefinition
         Get
             Helper.Assert(m_Variable IsNot Nothing)
             Helper.Assert(m_Variable.IsFieldVariable)
             Helper.Assert(m_Variable.FieldBuilder IsNot Nothing)
             Return m_Variable.FieldBuilder
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2533" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="89" endline="106">
<![CDATA[
 
     Function DefineHandlesOrImplements() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then
             Dim hclause As HandlesClause = m_HandlesOrImplements.HandlesClause
             Dim iclause As MemberImplementsClause = m_HandlesOrImplements.ImplementsClause
             If hclause IsNot Nothing Then
                 'Helper.NotImplemented()
             ElseIf iclause IsNot Nothing Then
                 result = iclause.DefineImplements(Me.CecilBuilder)
             Else
                 Throw New InternalException(Me)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2534" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="1490" endline="1501">
<![CDATA[
 
     Sub SelectOutputArguments()
         If IsParamArrayCandidate Then
             Dim ace As ArrayCreationExpression
             ace = ParamArrayExpression ' TryCast(OutputArguments.Item(OutputArguments.Count - 1).Expression, ArrayCreationExpression)
             If ace IsNot Nothing AndAlso ace.IsResolved = False AndAlso Helper.IsParamArrayParameter(Compiler, InputParameters(InputParameters.Count - 1)) Then
                 If ace.ResolveExpression(ResolveInfo.Default(Compiler)) = False Then
                     Helper.ErrorRecoveryNotImplemented(Parent.Location)
                 End If
             End If
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2535" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryExpression.vb" startline="53" endline="61">
<![CDATA[
 
 #If DEBUG Then
     Protected MustOverride Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
 #End If
     MustOverride ReadOnly Property Keyword() As KS
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(Enums.UnaryOperators)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2536" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="107" endline="116">
<![CDATA[
     End Property
 
     ReadOnly Property OperandTypeCode() As TypeCode
         Get
             Dim result As TypeCode
 
             result = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, LeftType, RightType)
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2537" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2968" endline="2976">
<![CDATA[
 
     <Obsolete()> Private Function ParseExpression() As Expression
         Dim result As Expression = Nothing
 
         Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         '        result = ParseOr_OrElse_Xor(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2538" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="165" endline="174">
<![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If m_LocalBuilder IsNot Nothing Then
             Emitter.EmitStoreVariable(Info, m_LocalBuilder)
         ElseIf FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2539" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="51" endline="61">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As Mono.Cecil.ParameterReference())
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         m_ParameterList = New ParameterList(Me)
         For i As Integer = 0 To Parameters.GetUpperBound(0)
             m_ParameterList.Add(Parameters(i).Name, Parameters(i).ParameterType)
         Next
         'Helper.Assert(m_Identifier IsNot Nothing)
         Helper.Assert(m_ParameterList IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2540" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="82" endline="91">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         Helper.Assert(TypeOf Parent Is ClassDeclaration = False)
 
         If m_Identifier IsNot Nothing Then m_Identifier.Initialize(Me)
         If m_TypeParameters IsNot Nothing Then m_TypeParameters.Initialize(Me)
         If m_ParameterList IsNot Nothing Then m_ParameterList.Initialize(Me)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2541" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="31" endline="48">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         If result AndAlso CecilHelper.IsGenericParameter(m_LeftExpression.ExpressionType) Then
             m_LeftExpression = New BoxExpression(Me, m_LeftExpression, m_LeftExpression.ExpressionType)
             m_DesiredNothingType = Compiler.TypeCache.System_Object
         End If
         If result AndAlso CecilHelper.IsGenericParameter(m_RightExpression.ExpressionType) Then
             m_RightExpression = New BoxExpression(Me, m_RightExpression, m_RightExpression.ExpressionType)
             m_DesiredNothingType = Compiler.TypeCache.System_Object
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2542" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="192" endline="209">
<![CDATA[
 
     Private Function EmitLoadCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariable(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2543" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="348" endline="359">
<![CDATA[
 
     Function DereferenceByRef() As Expression
         Dim result As Expression
 
         If CecilHelper.IsByRef(ExpressionType) Then
             result = New DeRefExpression(Me, Me)
         Else
             result = Me
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2544" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1562" endline="1573">
<![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitLoadVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2545" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="534" endline="548">
<![CDATA[
 
     Sub RemoveNarrowing()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowing Then
                 Log("NARROWING    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2546" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" startline="40" endline="47">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitBranchOrLeave(Info, m_Destination.GetLabel(Info), Me, m_Destination)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2547" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim tp As TypeDeclaration
         tp = Me.FindFirstParent(Of TypeDeclaration)()
         m_ExpressionType = tp.CecilType
 
         '        Classification = New ValueClassification(Me, m_ExpressionType)
         'SPECBUG
         Classification = New VariableClassification(Me, Me, m_ExpressionType)
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2548" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="172" endline="184">
<![CDATA[
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2549" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="220" endline="234">
<![CDATA[
 
     Private Function EmitStoreCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 Emitter.EmitStoreField(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitStoreVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2550" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2993" endline="3012">
<![CDATA[
     ''' <summary>
     ''' GetTypeExpression 
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseGetTypeExpression(ByVal Parent As ParsedObject) As GetTypeExpression
         Dim result As New GetTypeExpression(Parent)
 
         tm.AcceptIfNotInternalError(KS.GetType)
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Dim m_TypeName As GetTypeTypeName
         m_TypeName = ParseGetTypeTypeName(result)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2551" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4213" endline="4239">
<![CDATA[
 
     ''' <summary>
     ''' Operand  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOperand(ByVal Parent As ParsedObject) As Operand
         Dim result As New Operand(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName
 
         tm.Accept(KS.ByVal)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2552" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="202" endline="225">
<![CDATA[
 
     ''' <summary>
     ''' OptionExplicitStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionExplicitStatement(ByVal Parent As BaseObject) As OptionExplicitStatement
         Dim result As New OptionExplicitStatement(Parent)
 
         Dim m_Off As Boolean
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Explicit")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30640, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2553" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClauses.vb" startline="71" endline="97">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if a clause with the same imported namespace or alias exists.
     ''' </summary>
     ''' <param name="Clause"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Exists(ByVal Clause As ImportsClause) As Boolean
         For Each cl As ImportsClause In Me
             If cl.IsNamespaceClause Then
                 If Clause.IsNamespaceClause Then
                     If Helper.CompareName(cl.AsNamespaceClause.Name, Clause.AsNamespaceClause.Name) Then
                         Return True
                     End If
                 End If
             ElseIf cl.IsAliasClause Then
                 If Clause.IsAliasClause Then
                     If Helper.CompareName(cl.AsAliasClause.Name, Clause.AsAliasClause.Name) Then
                         Return True
                     End If
                 End If
             Else
                 Throw New InternalException(Me)
             End If
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2554" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="286" endline="325">
<![CDATA[
 
     ''' <summary>
     ''' Shows the specified message. Can optionally save it (not show it)
     ''' to show it later with ShowSavedMessages()
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Private Function ShowMessage(ByVal SaveIt As Boolean, ByVal Message As Message) As Boolean
         Dim isOnlyWarning As Boolean = False
 
         isOnlyWarning = Message.Level <= MessageLevel.Warning
 
         If SaveIt Then
             m_SavedMessages.Add(Message)
         Else
             m_Messages.Add(Message)
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Always, Message.ToString())
             m_MessageCount(Message.Level) += 1
             If m_MessageCount(MessageLevel.Error) > MAXERRORS Then
                 Throw New TooManyErrorsException()
             End If
         End If
 
 #If TRACEMESSAGES Then
         Console.WriteLine(Environment.StackTrace)
 #End If
 
 #If STOPONERROR Then
         If Helper.IsDebugging AndAlso Message.Level = MessageLevel.Error Then
             Helper.Stop()
         ElseIf Helper.IsBootstrapping Then
             Throw New InternalException(Message.ToString)
         End If
 #ElseIf STOPONWARNING Then
         If Debugger.IsAttached AndAlso Message.Level = MessageLevel.Warning Then
             Helper.Stop()
         End If
 #End If
 
         Return isOnlyWarning
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2555" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="30" endline="53">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case Me.OperandTypeCode
 
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Boolean)
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitNot(Info, OperandType)
             Case TypeCode.Object
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__NotObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2559" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="805" endline="818">
<![CDATA[
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2560" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstraintList.vb" startline="30" endline="38">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstraintList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstraintList(NewParent)
         For Each item As Constraint In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2561" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="34" endline="50">
<![CDATA[
     Private Function AddAttribute() As Boolean
         Dim result As Boolean = True
         Dim newAttrib As Attribute
 
         If m_DefinedStandardModuleAttribute Then Return True
 
         If Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute Is Nothing Then Return True
 
         newAttrib = New Attribute(Me, Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute)
         result = newAttrib.ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
 
         If MyBase.CustomAttributes Is Nothing Then MyBase.CustomAttributes = New Attributes(Me)
         MyBase.CustomAttributes.Add(newAttrib)
         m_DefinedStandardModuleAttribute = True
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2562" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="37" endline="56">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal [Operator] As Token, ByVal Operand As Operand, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Block As CodeBlock)
         Dim mySignature As New FunctionSignature(Me)
         Dim parameters As New ParameterList(Me)
 
         parameters.Add(New Parameter(parameters, Operand.Name, Operand.TypeName))
 
         If Modifiers.Is(ModifierMasks.Widening) Then
             mySignature.Init("op_Implicit", Nothing, parameters, ReturnTypeAttributes, TypeName, Me.Location)
         ElseIf Modifiers.Is(ModifierMasks.Narrowing) Then
             mySignature.Init("op_Explicit", Nothing, parameters, ReturnTypeAttributes, TypeName, Me.Location)
         Else
             Helper.AddError(Me)
         End If
 
         m_Operator = [Operator]
         m_Operand = Operand
 
         MyBase.Init(Modifiers, mySignature, Block)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2563" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2290" endline="2321">
<![CDATA[
 
     ''' <summary>
     ''' InvocationExpression
     ''' IndexExpression
     ''' Note that for the index expression the parenthesis are not optional.
     ''' This is reflected by the fact that m_ArgumentList is not nothing if 
     ''' parenthesis are provided.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInvocationOrIndexExpression(ByVal Parent As ParsedObject, ByVal First As Expression) As InvocationOrIndexExpression
         Dim result As New InvocationOrIndexExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_ArgumentList As ArgumentList
 
         m_Expression = First
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_ArgumentList = ParseArgumentList(result)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_ArgumentList = New ArgumentList(result)
             End If
         Else
             m_ArgumentList = Nothing
         End If
 
         result.Init(m_Expression, m_ArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2564" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6331" endline="6358">
<![CDATA[
 
     ''' <summary>
     ''' Parses enum members.
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseEnumMembers(ByVal Parent As EnumDeclaration) As Boolean
         Dim newConst As EnumMemberDeclaration
         Dim constAttributes As Attributes
 
         Do Until tm.CurrentToken.Equals(KS.End, KS.Enum)
             constAttributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, constAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             newConst = ParseEnumMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, constAttributes), Parent.Members.Count)
             If newConst Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Return False
             End If
             Parent.Members.Add(newConst)
         Loop
         Do Until tm.CurrentToken.Equals(KS.End, KS.Enum)
             constAttributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, constAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             newConst = ParseEnumMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, constAttributes), Parent.Members.Count)
             If newConst Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Return False
             End If
             Parent.Members.Add(newConst)
         Loop
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2565" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="922" endline="946">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceBase   
     ''' InterfaceBases  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceBases(ByVal Parent As ParsedObject) As InterfaceBases
         Dim result As New InterfaceBases(Parent)
         Dim tmp As New Generic.List(Of NonArrayTypeName)
 
         Do While tm.Accept(KS.Inherits)
             Do
                 Dim newBase As NonArrayTypeName
                 newBase = ParseNonArrayTypeName(result)
                 tmp.Add(newBase)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While tm.Accept(KS.Inherits)
             Do
                 Dim newBase As NonArrayTypeName
                 newBase = ParseNonArrayTypeName(result)
                 tmp.Add(newBase)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         If tmp.Count <= 0 Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2566" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4967" endline="4993">
<![CDATA[
 
 
     ''' <summary>
     ''' LabelDeclarationStatement  
     ''' LabelName  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLabelDeclarationStatement(ByVal Parent As ParsedObject) As LabelDeclarationStatement
         Dim m_Label As Token
 
         If tm.CurrentToken.IsIdentifier OrElse tm.CurrentToken.IsIntegerLiteral Then
             m_Label = tm.CurrentToken
             tm.NextToken()
         Else
             Throw New InternalException(Parent)
         End If
 
         If tm.CurrentToken.Equals(KS.Colon) = False Then
             Throw New InternalException(Parent)
         End If
 
         If tm.PeekToken.IsEndOfLineOnly Then
             tm.NextToken()
         End If
 
         Return New LabelDeclarationStatement(Parent, m_Label)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2568" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="394" endline="409">
<![CDATA[
 
     ''' <summary>
     ''' Returns all the types within the specified namespace.
     ''' Never returns nothing and never throws an exception.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetTypesByNamespace(ByVal [Namespace] As String) As TypeDictionary
         If [Namespace] Is Nothing Then [Namespace] = ""
         If m_CecilTypesByNamespace.ContainsKey([Namespace]) Then
             Return m_CecilTypesByNamespace([Namespace])
         Else
             Return New TypeDictionary()
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2569" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="96" endline="107">
<![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             ElseIf Me.IsSimpleTypeName Then
                 Return AsSimpleTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2570" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="191" endline="200">
<![CDATA[
 
     Overrides Function ToString() As String
         If IsConstructedTypeName Then
             Return AsConstructedTypeName.Name
         ElseIf IsSimpleTypeName Then
             Return AsSimpleTypeName.Name
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2571" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\Statement.vb" startline="24" endline="32">
<![CDATA[
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2572" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="46" endline="55">
<![CDATA[
 
     Sub Init(ByVal Elements As Expression())
         m_VariableInitializerList = New VariableInitializerList(Me)
         For Each e As Expression In Elements
             Dim vi As VariableInitializer
             vi = New VariableInitializer(Me)
             vi.Init(e)
             m_VariableInitializerList.Add(vi)
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2573" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5032" endline="5059">
<![CDATA[
 
     ''' <summary>
     ''' RedimStatement  
     ''' RedimClauses  
     '''	   RedimClause  |
     '''	   RedimClauses  ","  RedimClause
     ''' RedimClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseReDimStatement(ByVal Parent As ParsedObject) As ReDimStatement
         Dim result As New ReDimStatement(Parent)
 
         Dim m_IsPreserve As Boolean
         Dim m_Clauses As RedimClauses
 
         tm.AcceptIfNotInternalError(KS.ReDim)
         If tm.CurrentToken.Equals("Preserve") Then
             m_IsPreserve = True
             tm.NextToken()
         End If
 
         m_Clauses = ParseRedimClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsPreserve, m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2574" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4529" endline="4554">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceFunctionDeclaration  
     '''	[  Attributes  ]  [  InterfaceProcedureModifier+  ] "Function" FunctionSignature  StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceFunctionDeclaration
         Dim result As New InterfaceFunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Signature = ParseFunctionSignature(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2575" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5534" endline="5550">
<![CDATA[
 
     Private Function ParseDoStatementCondition(ByVal Parent As ParsedObject, ByRef IsWhile As Boolean) As Expression
         Dim result As Expression = Nothing
 
         If tm.Accept(KS.While) Then
             IsWhile = True
             result = ParseExpression(Parent)
         ElseIf tm.Accept(KS.Until) Then
             IsWhile = False
             result = ParseExpression(Parent)
         Else
             Throw New InternalException(result)
         End If
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2576" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6040" endline="6072">
<![CDATA[
 
     ''' <summary>
     ''' AddHandlerStatement  
     ''' RemoveHandlerStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddOrRemoveHandlerStatement(ByVal Parent As ParsedObject) As AddOrRemoveHandlerStatement
         Dim result As New AddOrRemoveHandlerStatement(Parent)
 
         Dim m_Event As Expression
         Dim m_EventHandler As Expression
         Dim m_IsAddHandler As Boolean
 
         If tm.Accept(KS.AddHandler) Then
             m_IsAddHandler = True
         ElseIf tm.Accept(KS.RemoveHandler) Then
             m_IsAddHandler = False
         Else
             Throw New InternalException(result)
         End If
 
         m_Event = ParseExpression(result)
         If m_Event Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_EventHandler = ParseExpression(result)
         If m_EventHandler Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Event, m_EventHandler, m_IsAddHandler)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2577" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="890" endline="921">
<![CDATA[
 
     ''' <summary>
     ''' ArraySizeInitializationModifier  
     ''' LAMESPEC this might be correct? REMOVED, CURRENTLY USING ^ SPEC!
     ''' ArraySizeInitializationModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArraySizeInitializationModifer(ByVal Parent As ParsedObject) As ArraySizeInitializationModifier
         Dim result As New ArraySizeInitializationModifier(Parent)
 
         Dim m_BoundList As BoundList = Nothing
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers = Nothing
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_BoundList = ParseBoundList(result)
         If m_BoundList Is Nothing Then
             If m_ShowErrors = False Then Return Nothing
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayTypeModifiers.CanBeMe(tm) Then
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(result)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_BoundList, m_ArrayTypeModifiers)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2578" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3879" endline="3905">
<![CDATA[
 
     ''' <summary>
     ''' TypeParameterConstraints  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameterConstraints(ByVal Parent As ParsedObject) As TypeParameterConstraints
         Dim result As New TypeParameterConstraints(Parent)
 
         tm.AcceptIfNotInternalError(KS.As)
 
         Dim m_ConstraintList As New ConstraintList(result)
 
         If tm.Accept(KS.LBrace) Then
             If ParseList(Of Constraint)(m_ConstraintList, New ParseDelegate_Parent(Of Constraint)(AddressOf ParseConstraint), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Dim tmpConstraint As Constraint = Nothing
             tmpConstraint = ParseConstraint(result)
             m_ConstraintList = New ConstraintList(result, tmpConstraint)
         End If
 
         result.Init(m_ConstraintList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2579" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1211" endline="1243">
<![CDATA[
 
     ''' <summary>
     ''' SimpleTypeName 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleTypeName(ByVal Parent As ParsedObject) As SimpleTypeName
         Dim result As New SimpleTypeName(Parent)
 
         If BuiltInTypeName.IsBuiltInTypeName(tm) Then
             Dim m_BuiltInTypeName As BuiltInTypeName
             m_BuiltInTypeName = ParseBuiltinTypeName(result)
             If m_BuiltInTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_BuiltInTypeName)
         Else
             Dim m_QualifiedIdentifier As QualifiedIdentifier
 
             If QualifiedIdentifier.CanBeQualifiedIdentifier(tm) = False Then
                 If tm.CurrentToken.IsKeyword Then
                     Compiler.Report.ShowMessage(Messages.VBNC30180, tm.CurrentLocation)
                     tm.NextToken()
                 End If
                 Return Nothing
             End If
 
             m_QualifiedIdentifier = ParseQualifiedIdentifier(result)
             If m_QualifiedIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_QualifiedIdentifier)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2580" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Enums\TypeCharacters.vb" startline="61" endline="79">
<![CDATA[
 
     Shared Function TypeCharacterToType(ByVal Compiler As Compiler, ByVal TypeCharacter As TypeCharacters.Characters) As Mono.Cecil.TypeReference
         Select Case GetDataType(TypeCharacter)
             Case KS.Integer
                 Return Compiler.TypeCache.System_Int32
             Case KS.Long
                 Return Compiler.TypeCache.System_Int64
             Case KS.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case KS.Single
                 Return Compiler.TypeCache.System_Single
             Case KS.Double
                 Return Compiler.TypeCache.System_Double
             Case KS.String
                 Return Compiler.TypeCache.System_String
             Case Else
                 Throw New InternalException("Unknown typecharacter
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2581" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3439" endline="3471">
<![CDATA[
 
     ''' <summary>
     ''' "TypeOf" Expression "Is" TypeName
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeOfExpression(ByVal Parent As ParsedObject) As TypeOfExpression
         Dim result As New TypeOfExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_Is As Boolean
         Dim m_Type As TypeName
 
         tm.AcceptIfNotInternalError(KS.TypeOf)
 
         m_Expression = ParseExpression(New ExpressionParseInfo(result, False, True))
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Is) Then
             m_Is = True
         ElseIf tm.Accept(KS.IsNot) Then
             m_Is = False
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Type = ParseTypeName(result)
         If m_Type Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression, m_Is, m_Type)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2582" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="85" endline="91">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New LiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2583" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="59" endline="66">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal DelegateType As Mono.Cecil.TypeReference, ByVal AddressOfExpression As AddressOfExpression)
         MyBase.New(Parent)
 
         m_IsDelegateCreationExpression = True
         m_ResolvedType = DelegateType
         m_ArgumentList = New ArgumentList(Me, AddressOfExpression)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2584" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="541" endline="548">
<![CDATA[
     End Property
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_Variables IsNot Nothing Then m_Variables.Initialize(Me)
         If m_Statements IsNot Nothing Then m_Statements.Initialize(Me)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2585" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="91" endline="109">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         block.HasUnstructuredExceptionHandling = True
         If m_IsResumeNext Then block.HasResume = True
         If block.HasStructuredExceptionHandling Then
             Helper.AddError(Me, "No structured exception handling in the same method.")
         End If
 
         If Token.IsSomething(m_Label) Then
             block = Me.FindFirstParent(Of CodeBlock)()
             m_ResolvedLabel = block.FindLabel(m_Label)
             Compiler.Helper.AddCheck("Label must exist.")
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2586" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="312" endline="325">
<![CDATA[
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2587" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4503" endline="4528">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceSubDeclaration  
     ''' [  Attributes  ]  [  InterfaceProcedureModifier+  ]  "Sub" SubSignature  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceSubDeclaration
         Dim result As New InterfaceSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As SubSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Signature = ParseSubSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2588" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5360" endline="5389">
<![CDATA[
 
     ''' <summary>
     ''' WithStatement  
     '''	   "With" Expression  StatementTerminator
     '''	        [  Block  ]
     '''	   "End" "With" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWithStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WithStatement
         Dim result As New WithStatement(Parent)
 
         Dim m_WithExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.With)
 
         m_WithExpression = ParseExpression(result)
         If m_WithExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_Code = ParseCodeBlock(result, IsOneLiner)
 
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.With) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_WithExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2589" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="270" endline="280">
<![CDATA[
 
     ''' <summary>
     ''' If the current token is not the specified keyword / symbol, then a
     ''' InternalException is thrown. (In which case it doesn't return,
     ''' so this is not a function).
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <remarks></remarks>
     Sub AcceptIfNotInternalError(ByVal Special As KS)
         If Not Accept(Special) Then Throw New InternalException("Location
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2590" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="245" endline="265">
<![CDATA[
 
     ''' <summary>
     ''' A list of the types of the arguments.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetTypes() As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
 
         Helper.Assert(Me.HasNamedArguments = False)
 
         For Each arg As PositionalArgument In m_Arguments
             If arg.Expression IsNot Nothing Then
                 result.Add(arg.Expression.ExpressionType)
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2591" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4994" endline="5016">
<![CDATA[
 
     ''' <summary>
     ''' ThrowStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseThrowStatement(ByVal Parent As ParsedObject) As ThrowStatement
         Dim result As New ThrowStatement(Parent)
 
         Dim m_Exception As Expression
 
         tm.AcceptIfNotInternalError(KS.Throw)
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_Exception = ParseExpression(result)
             If m_Exception Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Exception = Nothing
         End If
 
         result.Init(m_Exception)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2592" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="121" endline="148">
<![CDATA[
     ''' <summary>
     ''' OptionCompareStatement  
     ''' CompareOption  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionCompareStatement(ByVal Parent As BaseObject) As OptionCompareStatement
         Dim result As New OptionCompareStatement(Parent)
 
         Dim m_IsBinary As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Compare")
 
         If tm.Accept("Text") Then
             m_IsBinary = False
         ElseIf tm.Accept("Binary") Then
             m_IsBinary = True
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30207, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsBinary)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2593" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="283" endline="303">
<![CDATA[
 
     ReadOnly Property CodeStream() As IO.StreamReader
         Get
             Dim Stream As System.IO.Stream
             Dim StreamReader As System.IO.StreamReader
 
             Try
                 If m_Code IsNot Nothing Then
                     Stream = New System.IO.MemoryStream(Compiler.CommandLine.Encoding.GetBytes(m_Code))
                 Else
                     Stream = New System.IO.FileStream(FileName, IO.FileMode.Open, IO.FileAccess.Read, IO.FileShare.Read)
                 End If
 
                 StreamReader = New System.IO.StreamReader(Stream, Compiler.CommandLine.Encoding, True)
 
                 Return StreamReader
             Catch e As Exception
                 Compiler.Report.ShowMessage(Messages.VBNC31007, Span.CommandLineSpan, FileName)
                 Return Nothing
             End Try
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2594" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="722" endline="739">
<![CDATA[
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2595" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="149" endline="174">
<![CDATA[
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionInferStatement(ByVal Parent As BaseObject) As OptionInferStatement
         Dim result As New OptionInferStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Infer")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2596" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="175" endline="201">
<![CDATA[
 
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionStrictStatement(ByVal Parent As BaseObject) As OptionStrictStatement
         Dim result As New OptionStrictStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Strict")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2597" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="398" endline="429">
<![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim qi As QualifiedIdentifier
 
         qi = ParseQualifiedIdentifier(result)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result IsNot Nothing AndAlso tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             Dim ctn As ConstructedTypeName = Nothing
             tm.RestoreToPoint(iCurrent)
             ctn = ParseConstructedTypeName(result)
             If ctn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(ctn)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(qi)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2598" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="174" endline="191">
<![CDATA[
 
     Private Function EmitLoadAddressCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariableLocation(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariableLocation(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2599" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5803" endline="5839">
<![CDATA[
 
     ''' <summary>
     ''' SelectStatement  
     '''	   "Select" [ "Case" ]  Expression  StatementTerminator
     '''	        [  CaseStatement+  ]
     '''	        [  CaseElseStatement  ]
     '''	   "End" "Select" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSelectStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SelectStatement
         Dim result As New SelectStatement(Parent)
 
         Dim m_Test As Expression
         Dim m_Cases As BaseObjects(Of CaseStatement)
 
         tm.AcceptIfNotInternalError(KS.Select)
 
         tm.Accept(KS.Case) '"Case" is not required
 
         m_Test = ParseExpression(result)
         If m_Test Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Cases = New BaseObjects(Of CaseStatement)(result)
         While tm.CurrentToken = KS.Case
             Dim newCase As CaseStatement
             newCase = ParseCaseStatement(result, IsOneLiner)
             m_Cases.Add(newCase)
         End While
         While tm.CurrentToken = KS.Case
             Dim newCase As CaseStatement
             newCase = ParseCaseStatement(result, IsOneLiner)
             m_Cases.Add(newCase)
         End While
 
         If tm.Accept(KS.End, KS.Select) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Test, m_Cases)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2600" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="384" endline="410">
<![CDATA[
 
     Private Sub FlattenWith(ByVal Name As String, ByVal MemberCache As MemberCache, ByVal Visibility As MemberVisibility)
         Dim cache_entries As MemberCacheEntries = Nothing
 
         'Console.WriteLine("{0} FlattenWith
 
         cache_entries = m_FlattenedCacheInsensitive(Visibility)
         If cache_entries Is Nothing Then
             cache_entries = New MemberCacheEntries()
             m_FlattenedCacheInsensitive(Visibility) = cache_entries
         End If
 
         AddToFlattenedCache(cache_entries, Name, MemberCache, m_CacheInsensitive(Visibility), Visibility)
 
         Dim cache2 As MemberCacheEntries
         cache2 = MemberCache.m_FlattenedCacheInsensitive(Visibility)
 
         If Name Is Nothing Then
             For Each cache As MemberCacheEntry In cache2.Values
                 AddToCache(cache, Visibility, cache_entries)
             Next
         Else
             Dim entry As MemberCacheEntry = Nothing
             If Not cache2.TryGetValue(Name, entry) Then Return
             AddToCache(cache2(Name), Visibility, cache_entries)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2601" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2602" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="177" endline="184">
<![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2603" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="44" endline="54">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.Classification IsNot Nothing Then
             Me.Classification = New ValueClassification(Me, m_Field.FieldType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2604" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="36" endline="46">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
         Emitter.EmitConversion(m_ErrNumber.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2605" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="126" endline="144">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, _
                 TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Return CDbl(originalValue) 'No range checking needed.
                 Case TypeCode.DBNull
                     Return CDbl(0)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Double
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2606" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="37" endline="43">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As BoundList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New BoundList(NewParent)
         result.Init(Helper.CloneExpressionArray(m_Expressions, result))
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2607" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="249" endline="256">
<![CDATA[
     End Property
 
     Public ReadOnly Property GetParameters() As Mono.Cecil.ParameterDefinition() Implements IMethod.GetParameters
         Get
             Helper.Assert(m_Signature IsNot Nothing)
             Helper.Assert(m_Signature.Parameters IsNot Nothing)
             Return m_Signature.Parameters.AsParameterInfo
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2608" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="696" endline="720">
<![CDATA[
 
     ''' <summary>
     ''' AttributeArgumentExpression  
     '''   ConstantExpression  |
     '''   GetTypeExpression  |
     '''   ArrayCreationExpression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeArgumentExpression(ByVal Parent As ParsedObject) As AttributeArgumentExpression
         Dim result As New AttributeArgumentExpression(Parent)
 
         Dim m_Expression As Expression
 
         If tm.CurrentToken = KS.GetType Then
             m_Expression = ParseGetTypeExpression(result)
         ElseIf tm.CurrentToken = KS.[New] Then
             m_Expression = ParseArrayCreationExpression(result)
         Else
             m_Expression = ParseExpression(result)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2609" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="56" endline="68">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(EventParent.EventType IsNot Nothing)
         If Signature.Parameters.Count = 0 Then
             Signature.Parameters.Add(New Parameter(Signature.Parameters, "obj", EventParent.EventType))
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2610" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5159" endline="5182">
<![CDATA[
 
     ''' <summary>
     '''ContinueStatement  
     '''ContinueKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseContinueStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ContinueStatement
         Dim result As New ContinueStatement(Parent)
 
         Dim m_ContinueWhat As KS
 
         tm.AcceptIfNotInternalError(KS.Continue)
         If tm.CurrentToken.Equals(KS.Do, KS.For, KS.While) Then
             m_ContinueWhat = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30781, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_ContinueWhat)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2611" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="294" endline="315">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClause(ByVal Parent As ParsedObject) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(tm) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2612" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2418" endline="2441">
<![CDATA[
 
     Private Function ParseArrayInitializerExpression(ByVal Parent As ParsedObject) As ArrayInitializerExpression
         Dim result As New ArrayInitializerExpression(Parent)
 
         Dim m_Initializers As New Expressions()
 
         tm.AcceptIfNotInternalError(KS.LBrace)
 
         If tm.CurrentToken <> KS.RBrace Then
             Do
                 Dim newExp As Expression
                 newExp = ParseExpression(result)
                 If newExp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
                 m_Initializers.Add(newExp)
             Loop While tm.Accept(KS.Comma)
         End If
 
         If tm.Accept(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Initializers)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2613" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2547" endline="2593">
<![CDATA[
 
     ''' <summary>
     ''' ArgumentList  
     '''                     PositionalArgumentList  |
     '''	                    NamedArgumentList
     ''' 
     ''' PositionalArgumentList  
     ''' 
     ''' NamedArgumentList  
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArgumentList(ByVal Parent As ParsedObject) As ArgumentList
         Dim result As New ArgumentList(Parent)
 
         Dim m_Arguments As New BaseObjects(Of Argument)(result)
 
         'First parse positional arguments
         Do
             'Check for named argument.
             If NamedArgument.CanBeMe(tm) Then Exit Do
 
             Dim exp As Expression
             exp = Nothing
 
             If tm.CurrentToken.Equals(KS.Comma) = False Then
                 exp = ParseExpression(result)
             End If
 
             Dim newPA As PositionalArgument
             newPA = New PositionalArgument(result, m_Arguments.Count, exp)
             m_Arguments.Add(newPA)
         Loop While tm.Accept(KS.Comma)
 
         'Then parse named arguments
         If NamedArgument.CanBeMe(tm) Then
             Do
                 Dim newArgument As NamedArgument
                 newArgument = ParseNamedArgument(result)
                 m_Arguments.Add(newArgument)
             Loop While tm.Accept(KS.Comma)
         End If
 
         result.Init(m_Arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2614" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" startline="53" endline="72">
<![CDATA[
 
     ''' <summary>
     ''' Might return nothing
     ''' </summary>
     ''' <param name="AttributeType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindAttributes(ByVal AttributeType As Mono.Cecil.TypeReference) As Generic.List(Of Attribute)
         Dim result As Generic.List(Of Attribute) = Nothing
 
         If AttributeType Is Nothing Then Return Nothing
 
         For Each att As Attribute In Me
             If Helper.CompareType(att.AttributeType, AttributeType) Then
                 If result Is Nothing Then result = New Generic.List(Of Attribute)
                 result.Add(att)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2615" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="37" endline="43">
<![CDATA[
         Get
             If TypeOf m_Value.LiteralValue Is String Then
                 Return """" & m_Value.LiteralValue.ToString & """"
             Else
                 Return m_Value.LiteralValue.ToString()
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2616" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="130" endline="141">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The type of the expression.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Return Nothing
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2617" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="124" endline="133">
<![CDATA[
 
     Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Resolved)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, New ArgumentList(Parent, m_Parameters), ResolvedMethod)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2618" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2619" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="52" endline="58">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_Signature IsNot Nothing Then m_Signature.Initialize(Me)
         If m_Code IsNot Nothing Then m_Code.Initialize(Me)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2620" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5183" endline="5204">
<![CDATA[
 
     ''' <summary>
     ''' EraseStatement  
     ''' EraseExpressions  
     '''	  Expression  |
     '''	  EraseExpressions  ,  Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEraseStatement(ByVal Parent As ParsedObject) As EraseStatement
         Dim result As New EraseStatement(Parent)
 
         Dim m_Targets As ExpressionList
 
         tm.AcceptIfNotInternalError(KS.Erase)
 
         m_Targets = ParseExpressionList(Parent)
         If m_Targets Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Targets)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2621" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4729" endline="4761">
<![CDATA[
 
     ''' <summary>
     ''' ConstantDeclarator  
     ''' TODO
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstantDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal Modifiers As Modifiers) As ConstantDeclaration
         Dim result As New ConstantDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName = Nothing
         Dim m_ConstantExpression As Expression = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.AcceptIfNotError(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ConstantExpression = ParseExpression(result)
         If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(Modifiers, m_Identifier, m_TypeName, m_ConstantExpression)
 
         'Don't parse a StatementTerminator as the VB spec says.
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2622" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="157" endline="168">
<![CDATA[
     End Property
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             If m_Property Is Nothing Then
                 Helper.Assert(m_Classification IsNot Nothing)
                 Helper.Assert(m_Classification.IsResolved)
                 m_Property = m_Classification.ResolvedProperty
             End If
             Helper.Assert(m_Property IsNot Nothing)
             Return m_Property.PropertyType
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2623" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="113" endline="121">
<![CDATA[
     End Property
 
     Property TypeParameterConstraints() As TypeParameterConstraints
         Get
             If m_TypeParameterConstraints Is Nothing Then
                 m_TypeParameterConstraints = New TypeParameterConstraints(Me)
             End If
             Return m_TypeParameterConstraints
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2624" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="27" endline="34">
<![CDATA[
         Get
             Dim result As String = ""
             If m_PropertyGroup.InstanceExpression IsNot Nothing Then
                 result = m_PropertyGroup.InstanceExpression.AsString & "."
             End If
             result &= m_PropertyGroup.Group(0).Name
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2625" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="73" endline="81">
<![CDATA[
 
     Shared Operator &(ByVal ns As [Namespace], ByVal str As String) As [Namespace]
         If ns Is Nothing Then Throw New InternalException("")
         If TypeOf ns Is GlobalNamespace Then
             Return New [Namespace](ns.Parent, str, True)
         Else
             Return New [Namespace](ns.Parent, ns, str)
         End If
     End Operator
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2626" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="427" endline="435">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal variable As Mono.Cecil.FieldReference, ByVal InstanceExpression As Expression)
         MyBase.New(Classifications.Variable, Parent)
         m_FieldInfo = variable
         m_InstanceExpression = InstanceExpression
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
         Helper.Assert((Helper.IsShared(variable) AndAlso m_InstanceExpression Is Nothing) OrElse (Helper.IsShared(variable) = False AndAlso m_InstanceExpression IsNot Nothing))
         Helper.Assert(variable IsNot Nothing AndAlso variable.FieldType IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2627" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="76" endline="93">
<![CDATA[
 
     Sub Init(ByVal ArrayType As Mono.Cecil.TypeReference, ByVal ArrayBounds() As Expression, ByVal InitializerElements As Expression())
         m_ExpressionType = ArrayType
 
         If ArrayBounds IsNot Nothing Then
             m_ArrayNameModifier = New ArrayNameModifier(Me)
             Dim newSizes As New ArraySizeInitializationModifier(Me)
             Dim bounds As New BoundList(newSizes)
             bounds.Init(ArrayBounds)
             newSizes.Init(bounds, Nothing)
             m_ArrayNameModifier.Init(newSizes)
         End If
 
         If InitializerElements IsNot Nothing Then
             m_ArrayElementInitializer = New ArrayElementInitializer(Me)
             m_ArrayElementInitializer.Init(InitializerElements)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2628" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1583" endline="1617">
<![CDATA[
 
     Public Sub NextUnconditionally()
 
         If Token.IsSomething(m_Peeked) Then
             m_Current = m_Peeked
             m_Peeked = Nothing
             Return
         End If
 
         If Token.IsSomething(m_Current) AndAlso m_Current.IsEndOfFile Then
             NextFile()
         End If
 
         If m_CodeFile Is Nothing Then
             m_Current = Token.CreateEndOfCodeToken
             Return
         End If
 
         m_CurrentTypeCharacter = TypeCharacters.Characters.None
         m_Current = GetNextToken()
 
         'Console.WriteLine("Scanned token
 
         'If m_Current.IsEndOfFile() Then
         '    If Token.IsSomething(m_Current) AndAlso Not m_Current.IsEndOfLineOnly Then
         '        m_Peeked = m_Current
         '        m_Current = Token.CreateEndOfLineToken(Me.GetCurrentLocation)
         '    End If
         '    'NextFile()
         'End If
 
         m_CurrentTokenType = m_Current.m_TokenType
         m_CurrentData = m_Current.m_TokenObject
 
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2629" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="95" endline="109">
<![CDATA[
     End Property
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         If DefaultSharedConstructor Is Nothing AndAlso (Me.HasSharedConstantFields OrElse Me.HasSharedFieldsWithInitializers) Then
             DefaultSharedConstructor = New ConstructorDeclaration(Me)
             DefaultSharedConstructor.Init(New Modifiers(ModifierMasks.Shared), New SubSignature(DefaultSharedConstructor, ConstructorDeclaration.SharedConstructorName, New ParameterList(DefaultSharedConstructor)), New CodeBlock(DefaultSharedConstructor))
             result = DefaultSharedConstructor.ResolveTypeReferences AndAlso result
             Members.Add(DefaultSharedConstructor)
             BeforeFieldInit = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2630" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3824" endline="3845">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeParameters  
     ''' CHANGED
     ''' </summary>
     ''' <remarks></remarks>
     ''' 
     Private Function ParseTypeParameters(ByVal Parent As ParsedObject) As TypeParameters
         Dim result As New TypeParameters()
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptIfNotError(KS.Of) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseList(Of TypeParameter)(result.Parameters, New ParseDelegate_Parent(Of TypeParameter)(AddressOf ParseTypeParameter), result.Parameters) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2631" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1346" endline="1356">
<![CDATA[
 
     Private Function ParseModifiers(ByVal ValidModifiers As ModifierMasks) As Modifiers
         Dim result As New Modifiers()
 
         While tm.CurrentToken.Equals(ValidModifiers)
             result.AddModifier(tm.CurrentToken.Keyword)
             tm.NextToken()
         End While
         While tm.CurrentToken.Equals(ValidModifiers)
             result.AddModifier(tm.CurrentToken.Keyword)
             tm.NextToken()
         End While
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2632" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="72" endline="87">
<![CDATA[
 
     ''' <summary>
     ''' The returned object will always be a function signature.
     ''' </summary>
     ''' <param name="NewParent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SubSignature
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New FunctionSignature(NewParent)
         MyBase.CloneTo(result)
         If m_ReturnTypeAttributes IsNot Nothing Then result.m_ReturnTypeAttributes = m_ReturnTypeAttributes.clone(result)
         result.m_ReturnType = m_ReturnType
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2633" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="58" endline="72">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As NonArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New NonArrayTypeName(NewParent)
         result.IsNullable = IsNullable
         If Me.IsConstructedTypeName Then
             result.Init(Me.AsConstructedTypeName.Clone)
         ElseIf Me.IsSimpleTypeName Then
             result.Init(Me.AsSimpleTypeName.Clone)
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2634" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="272" endline="293">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(str) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(Parent, str)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(Parent, str)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2635" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="44" endline="52">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributePositionalArgumentList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributePositionalArgumentList(NewParent)
         For Each item As AttributeArgumentExpression In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2636" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3906" endline="3930">
<![CDATA[
 
     ''' <summary>
     ''' Constraint  
     ''' LAMESPEC? Using the following
     ''' Constraint  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstraint(ByVal Parent As ParsedObject) As Constraint
         Dim result As New Constraint(Parent)
 
         Dim m_Special As KS
         Dim m_TypeName As TypeName = Nothing
 
         If tm.CurrentToken.Equals(KS.[New], KS.Class, KS.Structure) Then
             m_Special = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_TypeName, m_Special)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2637" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="863" endline="889">
<![CDATA[
 
     ''' <summary>
     ''' ArrayNameModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayNameModifier(ByVal Parent As ParsedObject) As ArrayNameModifier
         Dim result As New ArrayNameModifier(Parent)
 
         If ArrayTypeModifiers.CanBeMe(tm) Then
             Dim newATM As ArrayTypeModifiers
             newATM = ParseArrayTypeModifiers(result)
             If newATM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(newATM)
         ElseIf ArraySizeInitializationModifier.CanBeMe(tm) Then
             Dim newASIM As ArraySizeInitializationModifier
             newASIM = ParseArraySizeInitializationModifer(result)
             If newASIM Is Nothing Then
                 If m_ShowErrors = False Then Return Nothing
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             result.Init(newASIM)
         Else
             Throw New InternalException(result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2638" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4705" endline="4728">
<![CDATA[
 
     ''' <summary>
     ''' LibraryClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLibraryClause(ByVal Parent As ParsedObject) As LibraryClause
         Dim result As New LibraryClause(Parent)
 
         Dim m_StringLiteral As Token
 
         tm.AcceptIfNotInternalError(KS.Lib)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             m_StringLiteral = Nothing
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2639" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3975" endline="3997">
<![CDATA[
 
     ''' <summary>
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameterIdentifier(ByVal Parent As Parameter) As ParameterIdentifier
         Dim result As New ParameterIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2640" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1709" endline="1738">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceEventMemberDeclaration  
     '''	[  Attributes  ]  [  InterfaceEventModifiers+  ]  "Event"  Identifier  ParametersOrType  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceEventMemberDeclaration
         Dim result As New InterfaceEventMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
 
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceEventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2641" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="62" endline="72">
<![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         Me.ParameterType = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         m_TypeName = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2642" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2958" endline="2967">
<![CDATA[
 
     Private Function ParseExpressionList(ByVal Parent As ParsedObject) As ExpressionList
         Dim result As New ExpressionList(Parent)
 
         If ParseList(Of Expression)(result, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2643" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1169" endline="1188">
<![CDATA[
 
     ''' <summary>
     ''' ArrayTypeModifiers  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayTypeModifiers(ByVal Parent As ParsedObject) As ArrayTypeModifiers
         Dim result As New ArrayTypeModifiers(Parent)
 
         Dim tmp As New Generic.List(Of ArrayTypeModifier)
         Do
             Dim newATM As ArrayTypeModifier
             newATM = ParseArrayTypeModifier(result)
             If newATM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             tmp.Add(newATM)
         Loop While ArrayTypeModifier.CanBeMe(tm)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2644" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="207" endline="222">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2645" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4059" endline="4080">
<![CDATA[
 
     ''' <summary>
     ''' ConstantMemberDeclaration  
     ''' </summary>
     ''' <remarks>
     ''' </remarks>
     Private Function ParseConstantMemberDeclarations(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConstantModifiers)
 
         tm.AcceptIfNotInternalError(KS.Const)
         m_Modifiers.AddModifiers(ModifierMasks.Const)
 
         result = ParseConstantDeclarations(Parent, Info.Attributes, m_Modifiers)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2646" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" startline="30" endline="38">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Attributes
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New Attributes(NewParent)
         For Each item As Attribute In Me
             result.Add(item.Clone(NewParent))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2647" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="89" endline="104">
<![CDATA[
 
     Shared Function CreateDefaultConstructor(ByVal Parent As TypeDeclaration) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
         Dim modifiers As Modifiers
 
         If Parent.Modifiers.Is(ModifierMasks.MustInherit) Then
             modifiers.AddModifier(KS.Protected)
         End If
         result.Init(modifiers, New SubSignature(result, ConstructorName, New ParameterList(result)), New CodeBlock(result))
 
         If result.ResolveTypeReferences() = False Then
             Helper.ErrorRecoveryNotImplemented(Parent.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2648" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="45" endline="57">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SimpleTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SimpleTypeName(NewParent)
         If Me.IsBuiltInTypeName Then
             result.Init(Me.AsBuiltInTypeName.Clone(result))
         ElseIf Me.IsQualifiedIdentifier Then
             result.Init(Me.AsQualifiedIdentifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2649" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="95" endline="110">
<![CDATA[
     End Property
 
     Sub Init(ByVal InitialGroup As Generic.List(Of Mono.Cecil.MemberReference), ByVal Arguments As ArgumentList, ByVal TypeArguments As TypeArgumentList)
         m_Candidates = New Generic.List(Of MemberCandidate)(InitialGroup.Count)
         For i As Integer = 0 To InitialGroup.Count - 1
             Dim member As Mono.Cecil.MemberReference = InitialGroup(i)
             m_Candidates.Add(New MemberCandidate(Me, member))
         Next
 
         m_InitialCandidates = m_Candidates.ToArray()
 
         m_Arguments = Arguments
         m_TypeArguments = TypeArguments
         m_Caller = Parent.FindTypeParent()
         m_Name = InitialGroup(0).Name
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2650" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="60" endline="80">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Local IsNot Nothing)
 
         If Info.IsRHS Then
             If CecilHelper.IsByRef(Info.DesiredType) Then
                 Emitter.EmitLoadVariableLocation(Info, m_Local)
             Else
                 Emitter.EmitLoadVariable(Info, m_Local)
             End If
         Else
             If Info.RHSExpression IsNot Nothing Then
                 result = Info.RHSExpression.GenerateCode(Info.Clone(Me, True, , m_Local.VariableType)) AndAlso result
             End If
             Emitter.EmitStoreVariable(Info, m_Local)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2651" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="350" endline="376">
<![CDATA[
 
     Protected Function GetVBType(ByVal Name As String) As Mono.Cecil.TypeDefinition
         Dim result As Mono.Cecil.TypeDefinition = Nothing
 
         If String.IsNullOrEmpty(Compiler.CommandLine.VBRuntime) AndAlso vbruntime Is Nothing Then
             Dim tps As Generic.List(Of Mono.Cecil.TypeReference)
             tps = Compiler.TypeManager.GetType(Name, True)
 
             If tps.Count = 1 Then
                 result = CecilHelper.FindDefinition(tps(0))
 #If DEBUG Then
             ElseIf tps.Count > 1 Then
                 Compiler.Report.WriteLine("Found " & tps.Count & " types with the name " & Name)
 #End If
             End If
         Else
             result = [GetType](vbruntime, Name)
         End If
 
 #If DEBUG Then
         If result Is Nothing Then
             Compiler.Report.WriteLine("Could not load VB Type
         End If
 #End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2652" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="721" endline="767">
<![CDATA[
 
 
 
     ''' <summary>
     ''' Type | QualifiedIdentifier ( Of [TypeArityList] )
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseGetTypeTypeName(ByVal Parent As GetTypeExpression) As GetTypeTypeName
         'TypeName |
         'QualifiedIdentifier (Of [TypeArityList])
         'TypeArityList 
         ' , |
         ' TypeParameterList ,
         Dim result As New GetTypeTypeName(Parent)
 
         'First try to parse as typename, if no 
         'success try as qualifiedidentifier.
         Dim m_TypeName As TypeName
         Dim iCurPos As RestorablePoint = tm.GetRestorablePoint
 
         m_TypeName = ParseTypeName(result)
         If m_TypeName Is Nothing Then
             tm.RestoreToPoint(iCurPos)
 
             Dim qn As QualifiedIdentifier
 
             qn = ParseQualifiedIdentifier(result)
             If qn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             tm.AcceptIfNotInternalError(KS.LParenthesis)
             tm.AcceptIfNotError(KS.Of)
 
             Dim typeArity As Integer = 1
             Do While tm.Accept(KS.Comma)
                 typeArity += 1
             Loop
             Do While tm.Accept(KS.Comma)
                 typeArity += 1
             Loop
 
             tm.AcceptIfNotError(KS.RParenthesis)
 
             result.Init(qn, typeArity)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(m_TypeName)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2653" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="60" endline="67">
<![CDATA[
 
     ReadOnly Property PositionalArgumentList() As AttributePositionalArgumentList
         Get
             If m_AttributePositionalArgumentList Is Nothing Then
                 m_AttributePositionalArgumentList = New AttributePositionalArgumentList(Me)
             End If
             Return m_AttributePositionalArgumentList
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2654" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5223" endline="5230">
<![CDATA[
 
     Private Function ParseRedimClauses(ByVal Parent As ReDimStatement) As RedimClauses
         Dim result As New RedimClauses(Parent)
         If ParseList(Of RedimClause)(result, New ParseDelegate_Parent(Of RedimClause)(AddressOf ParseRedimClause), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2655" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5270" endline="5288">
<![CDATA[
 
     ''' <summary>
     ''' ErrorStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseErrorStatement(ByVal Parent As ParsedObject) As ErrorStatement
         Dim result As New ErrorStatement(Parent)
 
         Dim m_ErrNumber As Expression
 
         tm.AcceptIfNotInternalError(KS.Error)
 
         m_ErrNumber = ParseExpression(result)
         If m_ErrNumber Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_ErrNumber)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2656" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BoxExpression.vb" startline="33" endline="49">
<![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression, ByVal DestinationType As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         m_DestinationType = DestinationType
         m_Expression = Expression
 
         Helper.Assert(m_DestinationType IsNot Nothing)
         Helper.Assert(m_Expression IsNot Nothing)
         Helper.Assert(m_Expression.IsResolved)
         Helper.Assert(TypeOf Expression Is BoxExpression = False)
 
         Classification = New ValueClassification(Me, m_DestinationType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Compiler)) = False Then
             Helper.ErrorRecoveryNotImplemented(Me.Location)
         End If
 
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2657" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="469" endline="479">
<![CDATA[
     End Property
 
     ReadOnly Property HasInstanceConstructors() As Boolean
         Get
             Dim ctors As Generic.List(Of ConstructorDeclaration)
             ctors = Me.Members.GetSpecificMembers(Of ConstructorDeclaration)()
             For Each item As ConstructorDeclaration In ctors
                 If item.IsShared = False Then Return True
             Next
             Return False
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2658" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2345" endline="2359">
<![CDATA[
 
 
     Private Function ParseUnaryMinusExpression(ByVal Info As ExpressionParseInfo) As UnaryMinusExpression
         Dim result As New UnaryMinusExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Minus)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2659" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2404" endline="2417">
<![CDATA[
 
     Private Function ParseUnaryPlusExpression(ByVal Info As ExpressionParseInfo) As UnaryPlusExpression
         Dim result As New UnaryPlusExpression(Info.Parent)
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Add)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2660" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4832" endline="4853">
<![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As New Generic.List(Of TypeVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of TypeVariableDeclaration)
             'Console.WriteLine("ParseTypeVariableDeclarators...")
             tmp = ParseTypeVariableDeclarator(Parent, Modifiers, Info)
             'Console.WriteLine("Got something
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2661" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="150" endline="168">
<![CDATA[
 
     ''' <summary>
     ''' Searches the namespaces of the current compiling assembly / referenced assemblies to check
     ''' if the name is a namespace.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsNamespace(ByVal Name As String, ByVal onlyExact As Boolean) As Boolean
         Name = vbnc.Namespace.RemoveGlobal(Name)
         If ContainsKey(Name) Then
             Return True
         ElseIf onlyExact = False Then
             For Each strNS As [Namespace] In Me
                 If strNS.StartsWith(Name) Then Return True
             Next
         End If
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2662" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2488" endline="2517">
<![CDATA[
 
     ''' <summary>
     ''' NewExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseNewExpression(ByVal Parent As ParsedObject) As NewExpression
         Dim result As New NewExpression(Parent)
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim bShowingErrors As Boolean
 
         Dim ace As ArrayCreationExpression
 
         bShowingErrors = Me.ShowErrors
         Me.m_ShowErrors = False
         ace = ParseArrayCreationExpression(result)
         Me.m_ShowErrors = bShowingErrors
 
         If ace IsNot Nothing Then
             tm.IgnoreRestoredPoint()
             result.Init(ace)
         Else
             tm.RestoreToPoint(iCurrent)
             Dim doce As DelegateOrObjectCreationExpression
             doce = ParseDelegateOrObjectCreationExpression(result)
             If doce Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(doce)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2663" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="231" endline="262">
<![CDATA[
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2664" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="376" endline="397">
<![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' This overload is used when parsing commandline imports.
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim qi As QualifiedIdentifier = Nothing
         qi = ParseQualifiedIdentifier(result, str)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
 
         result.Init(qi)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2665" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3510" endline="3525">
<![CDATA[
 
     ''' <summary>
     ''' VariableIdentifiers  
     '''	            VariableIdentifier  |
     '''	            VariableIdentifiers  ,  VariableIdentifier
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifiers(ByVal Parent As ParsedObject) As VariableIdentifiers
         Dim result As New VariableIdentifiers(Parent)
 
         If ParseList(Of VariableIdentifier)(result, New ParseDelegate_Parent(Of VariableIdentifier)(AddressOf ParseVariableIdentifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2666" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="39" endline="45">
<![CDATA[
         Get
             If m_First IsNot Nothing Then
                 Return m_First.AsString & "." & m_Second.Identifier
             Else
                 Return "." & m_Second.Identifier
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2667" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="109" endline="117">
<![CDATA[
 
     Private Function EmitStringToCharArray(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Expression.GenerateCode(Info.Clone(Info.Context, Compiler.TypeCache.System_String)) AndAlso result
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToCharArrayRankOne_String)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2668" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3846" endline="3878">
<![CDATA[
 
     ''' <summary>
     ''' TypeParameter  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameter(ByVal Parent As ParsedObject) As TypeParameter
         Dim result As New TypeParameter(Parent)
         Dim m_Identifier As Identifier
         Dim m_TypeParameterConstraints As TypeParameterConstraints
         Dim parentList As TypeParameterList
 
         Helper.Assert(TypeOf Parent Is TypeParameterList)
 
         parentList = DirectCast(Parent, TypeParameterList)
         result.GenericParameterPosition = parentList.Count + 1
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             result.Identifier = m_Identifier
         End If
 
         If TypeParameterConstraints.CanBeMe(tm) Then
             m_TypeParameterConstraints = ParseTypeParameterConstraints(result)
             If m_TypeParameterConstraints Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.TypeParameterConstraints = m_TypeParameterConstraints
         Else
             m_TypeParameterConstraints = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2669" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2594" endline="2618">
<![CDATA[
 
     Private Function ParseNamedArgument(ByVal Parent As ParsedObject) As NamedArgument
         Dim result As New NamedArgument(Parent)
         Dim Name As String
         Dim Expression As Expression = Nothing
 
         If tm.CurrentToken.IsIdentifier Then
             Name = tm.CurrentToken.Identifier
         ElseIf tm.CurrentToken.IsKeyword Then
             Name = tm.CurrentToken.Identifier
         Else
             Throw New InternalException(result)
         End If
         tm.NextToken()
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
 
         Expression = ParseExpression(result)
         If Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.Init(Name, Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2670" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="193" endline="211">
<![CDATA[
 
     Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If Signature IsNot Nothing AndAlso Signature.Parameters IsNot Nothing Then
             For i As Integer = 0 To Signature.Parameters.Count - 1
                 Signature.Parameters(i).UpdateDefinition()
             Next
         End If
         CecilBuilder.Name = Name
 
         MethodAttributes = Helper.GetAttributes(Me)
         MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL
 
         If DeclaringType IsNot Nothing AndAlso DeclaringType.CecilType IsNot Nothing AndAlso m_Added = False Then
             m_Added = True
             DeclaringType.CecilType.Methods.Add(CecilBuilder)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2671" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="116" endline="124">
<![CDATA[
 
     Function GetRestorablePoint() As RestorablePoint
         m_RestorePoints += 1
         If m_TokenList.Count = 0 Then
             m_TokenList.Add(CurrentToken)
         End If
         'Console.WriteLine(" Creating restore point
         Return New RestorablePoint(m_CurrentIndex)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2672" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3998" endline="4013">
<![CDATA[
 
     Private Function ParseImplementsClause(ByVal Parent As ParsedObject) As MemberImplementsClause
         Dim result As New MemberImplementsClause(Parent)
 
         Dim m_ImplementsList As New MemberImplementsList(Parent)
 
         tm.AcceptIfNotInternalError(KS.Implements)
 
         If ParseList(Of InterfaceMemberSpecifier)(m_ImplementsList, New ParseDelegate_Parent(Of InterfaceMemberSpecifier)(AddressOf ParseInterfaceMemberSpecifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_ImplementsList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2673" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EndStatement.vb" startline="34" endline="41">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__EndApp)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2674" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="750" endline="759">
<![CDATA[
     End Property
 
     ReadOnly Property IsAccessible() As Boolean
         Get
             If Resolver.Caller Is Nothing Then
                 Return Helper.IsAccessibleExternal(Compiler, m_Member)
             Else
                 Return Helper.IsAccessible(Compiler, Resolver.Caller.CecilType, m_Member)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2675" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="62" endline="74">
<![CDATA[
     End Property
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SimpleNameExpression(NewParent)
         If m_TypeArgumentList Is Nothing Then
             result.Init(m_Identifier, Nothing)
         Else
             result.Init(m_Identifier, m_TypeArgumentList.Clone(result))
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2676" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4812" endline="4831">
<![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLocalVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As New Generic.List(Of LocalVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of LocalVariableDeclaration)
             tmp = ParseLocalVariableDeclarator(Parent, Modifiers, Info)
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2677" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4682" endline="4704">
<![CDATA[
 
     ''' <summary>
     ''' AliasClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAliasClause(ByVal Parent As ParsedObject) As AliasClause
         Dim result As New AliasClause(Parent)
 
         Dim m_StringLiteral As Token = Nothing
 
         tm.AcceptIfNotInternalError(KS.Alias)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2678" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4418" endline="4441">
<![CDATA[
 
     ''' <summary>
     ''' HandlesOrImplements  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseHandlesOrImplements(ByVal Parent As ParsedObject) As HandlesOrImplements
         Dim result As New HandlesOrImplements(Parent)
 
         If vbnc.HandlesClause.IsMe(tm) Then
             Dim m_Clause As HandlesClause
             m_Clause = ParseHandlesClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         ElseIf vbnc.MemberImplementsClause.IsMe(tm) Then
             Dim m_Clause As MemberImplementsClause
             m_Clause = ParseImplementsClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Throw New InternalException(result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2679" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="62" endline="78">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
 
         Emitter.MarkLabel(Info, m_NextIteration)
         result = m_Condition.GenerateCode(Info.Clone(Me, True, , Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, EndLabel)
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, m_NextIteration)
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2680" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlerDeclaration.vb" startline="32" endline="58">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal HandlerType As KS, ByVal EventName As Identifier, ByVal Parameters As ParameterList, ByVal Code As CodeBlock)
 
         m_HandlerType = HandlerType
 
         Dim prefix As String
         Dim name As String
         Select Case m_HandlerType
             Case KS.AddHandler
                 prefix = "add_"
             Case KS.RemoveHandler
                 prefix = "remove_"
             Case KS.RaiseEvent
                 prefix = "raise_"
             Case Else
                 Throw New InternalException(Me)
         End Select
         name = prefix & EventName.Name
 
         Dim mySignature As SubSignature
 
         mySignature = New SubSignature(Me)
         mySignature.Init(New Identifier(mySignature, name, EventName.Location, EventName.TypeCharacter), Nothing, Parameters)
 
         MyBase.Init(Modifiers, mySignature, Code)
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2681" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1772" endline="1808">
<![CDATA[
 
     ''' <summary>
     ''' RegularEventMemberDeclaration  
     ''' 	[  Attributes  ]  [  EventModifiers+  ]  "Event"  Identifier  ParametersOrType  [  ImplementsClause  ] StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRegularEventDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As RegularEventDeclaration
         Dim result As New RegularEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
         Dim m_ImplementsClause As MemberImplementsClause
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ImplementsClause = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, m_ImplementsClause)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2682" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="261" endline="269">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessageNoLocation(ByVal Message As Messages, ByVal ParamArray Parameters() As String) As Boolean
         Dim Location As Span = Nothing
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2683" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializerList.vb" startline="30" endline="36">
<![CDATA[
     Overloads Sub Add(ByVal Name As String, ByVal Value As Object)
         Dim var As New VariablePropertyInitializer(Me)
         Dim exp As New AttributeArgumentExpression(var)
         exp.Init(New ConstantExpression(var, Value, CecilHelper.GetType(Compiler, Value)))
         var.Init(Name, exp)
         Add(var)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2684" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1335" endline="1345">
<![CDATA[
 
     Private Function ParseBuiltinTypeName(ByVal Parent As ParsedObject) As BuiltInTypeName
         Dim m_Typename As KS
 
         If vbnc.BuiltInTypeName.IsBuiltInTypeName(tm) = False Then Throw New InternalException(Parent)
 
         m_Typename = tm.CurrentToken.Keyword
         tm.NextToken()
 
         Return New BuiltInTypeName(Parent, m_Typename)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2685" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1322" endline="1334">
<![CDATA[
 
     Private Function ParseIdentifier(ByVal Parent As ParsedObject) As Identifier
         Dim result As Identifier
 
         If tm.CurrentToken.IsIdentifier Then
             result = New Identifier(Parent, tm.CurrentToken.Identifier, tm.CurrentLocation, tm.CurrentTypeCharacter)
             tm.NextToken()
         Else
             result = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2686" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4442" endline="4463">
<![CDATA[
 
     ''' <summary>
     ''' HandlesClause  
     ''' LAMESPEC
     ''' HandlesClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseHandlesClause(ByVal Parent As ParsedObject) As HandlesClause
         Dim result As New HandlesClause(Parent)
 
         Dim m_List As New EventHandlesList(result)
 
         tm.AcceptIfNotInternalError(KS.Handles)
 
         If ParseList(Of EventMemberSpecifier)(m_List, New ParseDelegate_Parent(Of EventMemberSpecifier)(AddressOf ParseEventMemberSpecifier), result) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_List)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2687" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="50" endline="62">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayNameModifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayNameModifier(NewParent)
         If Me.IsArrayTypeModifiers Then
             result.Init(Me.AsArrayTypeModifiers.Clone(result))
         ElseIf Me.IsArraySizeInitializationModifier Then
             result.Init(Me.AsArraySizeInitializationModifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2688" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1933" endline="1958">
<![CDATA[
 
     Private Function ParseIdentifierOrKeywordWithTypeArguments(ByVal Parent As ParsedObject) As IdentifierOrKeywordWithTypeArguments
         Dim result As New IdentifierOrKeywordWithTypeArguments(Parent)
 
         Dim m_TypeArguments As TypeArgumentList
         Dim m_Token As Token
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_Token = tm.CurrentToken
             tm.NextToken()
         Else
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Return Nothing
         End If
 
         If tm.CurrentToken.Equals(KS.LParenthesis) AndAlso tm.PeekToken.Equals(KS.Of) Then
             m_TypeArguments = ParseTypeArgumentList(result)
             If m_TypeArguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeArguments = Nothing
         End If
 
         result.Init(m_Token, m_TypeArguments)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2689" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4094" endline="4127">
<![CDATA[
 
     ''' <summary>
     ''' MustOverridePropertyMemberDeclaration  
     '''	[  Attributes  ]  [  MustOverridePropertyModifier+  ]  "Property" FunctionSignature  [  ImplementsClause  ]
     '''		StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseMustOverridePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As MustOverridePropertyDeclaration
         Dim result As New MustOverridePropertyDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverridePropertyModifiers)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, , , m_ImplementsClause)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2690" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\Identifier.vb" startline="73" endline="81">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Identifier
         Dim result As Identifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         result = New Identifier(NewParent)
         result.Init(m_Name, Location, m_TypeCharacter)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2691" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3472" endline="3491">
<![CDATA[
 
     ''' <summary>
     ''' LiteralExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLiteralExpression(ByVal Parent As ParsedObject) As LiteralExpression
         Dim result As LiteralExpression
 
         Dim m_Value As Token
         m_Value = tm.CurrentToken
         If m_Value.IsLiteral = False Then
             result = Nothing
         Else
             result = New LiteralExpression(Parent)
             result.Init(m_Value)
             tm.NextToken()
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2692" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="71" endline="79">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameter
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameter(NewParent)
         result.m_Identifier = m_Identifier
         If m_TypeParameterConstraints IsNot Nothing Then result.m_TypeParameterConstraints = m_TypeParameterConstraints.Clone(result)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2693" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3331" endline="3349">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As String
         Dim methodReference As MethodReference
         Dim propertyReference As PropertyReference
         Dim typeReference As TypeReference
 
         methodReference = TryCast(Member, MethodReference)
         If methodReference IsNot Nothing Then Return ToString(Context, methodReference)
 
         propertyReference = TryCast(Member, PropertyReference)
         If propertyReference IsNot Nothing Then Return Member.Name & "(" & Helper.ToString(Context, Helper.GetParameters(Context, Member)) & ")"
 
         typeReference = TryCast(Member, TypeReference)
         If typeReference IsNot Nothing Then Return ToString(Context, DirectCast(Member, TypeReference))
 
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
 
         Return String.Empty
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2694" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="83" endline="110">
<![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Dim result As Mono.Cecil.TypeReference
             Select Case Classification.Classification
                 Case ExpressionClassification.Classifications.Value
                     result = Classification.AsValueClassification.Type
                 Case ExpressionClassification.Classifications.Variable
                     result = Classification.AsVariableClassification.Type
                 Case ExpressionClassification.Classifications.Type
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                     result = Nothing
                 Case ExpressionClassification.Classifications.Namespace
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                     result = Nothing
                 Case ExpressionClassification.Classifications.PropertyGroup
                     result = Classification.AsPropertyGroup.Type
                 Case ExpressionClassification.Classifications.PropertyAccess
                     result = Classification.AsPropertyAccess.Type
                 Case ExpressionClassification.Classifications.MethodGroup
                     result = Classification.AsMethodGroupClassification.Type
                 Case Else
                     Throw New InternalException(Me)
             End Select
             Helper.Assert(result IsNot Nothing)
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2695" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5150" endline="5158">
<![CDATA[
 
     ''' <summary>
     ''' EndStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEndStatement(ByVal Parent As ParsedObject) As EndStatement
         tm.AcceptIfNotInternalError(KS.End)
         Return New EndStatement(Parent)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2696" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="34" endline="40">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_CustomAttributes IsNot Nothing Then m_CustomAttributes.Initialize(Me)
         Helper.Assert(m_Name IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2697" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="656" endline="681">
<![CDATA[
 
     Private Delegate Function ParseDelegate_Parent(Of T)(ByVal Parent As ParsedObject) As T
 
     ''' <summary>
     ''' VariablePropertyInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariablePropertyInitializer(ByVal Parent As ParsedObject) As VariablePropertyInitializer
         Dim result As New VariablePropertyInitializer(Parent)
 
         Dim m_IdentifierOrKeyword As IdentifierOrKeyword
         Dim m_AttributeArgumentExpression As AttributeArgumentExpression
 
         m_IdentifierOrKeyword = ParseIdentifierOrKeyword(result)
         If m_IdentifierOrKeyword Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
 
         m_AttributeArgumentExpression = ParseAttributeArgumentExpression(result)
         If m_AttributeArgumentExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IdentifierOrKeyword, m_AttributeArgumentExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2698" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="335" endline="354">
<![CDATA[
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2699" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="867" endline="878">
<![CDATA[
 
     Shared Sub EmitCallOrCallVirt(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Helper.Assert(Method IsNot Nothing)
         Dim mD As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(Method)
         If mD Is Nothing AndAlso TypeOf Method.DeclaringType Is Mono.Cecil.ArrayType AndAlso (Method.Name = "Get" OrElse Method.Name = "Set") Then
             EmitCall(Info, Method)
         ElseIf mD.IsStatic OrElse CecilHelper.IsValueType(Method.DeclaringType) Then
             EmitCall(Info, Method)
         Else
             EmitCallVirt(Info, Method)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2700" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="54" endline="72">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
         If CecilHelper.IsGenericParameter(m_Expression.ExpressionType) Then
             Emitter.EmitBox(Info, m_Expression.ExpressionType)
         End If
         Emitter.EmitIsInst(Info, m_Expression.ExpressionType, m_Type.ResolvedType)
 
         Emitter.EmitLoadNull(Info.Clone(Me, True, False, Compiler.TypeCache.System_Object))
         If m_Is Then
             Emitter.EmitNotEquals(Info, m_Type.ResolvedType)
         Else
             Emitter.EmitEquals(Info, m_Type.ResolvedType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2701" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ResumeStatement.vb" startline="32" endline="69">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim ResumeOK As Label = Emitter.DefineLabel(Info)
 
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         Dim lastblock As CodeBlock = block
         Do Until lastblock Is Nothing
             block = lastblock
             lastblock = block.FindFirstParent(Of CodeBlock)()
         Loop
         Do Until lastblock Is Nothing
             block = lastblock
             lastblock = block.FindFirstParent(Of CodeBlock)()
         Loop
 
         'Clear the error.
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
 
         'Test if the code is in an exception handler
         Emitter.EmitLoadVariable(Info, block.VB_ResumeTarget)
         Emitter.EmitBranchIfTrue(Info, ResumeOK)
 
         'If code is not in an exception handler raise an error
         Emitter.EmitLoadI4Value(Info, -2146828268)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Emitter.MarkLabel(Info, ResumeOK)
         'Load the instruction switch index
         Emitter.EmitLoadVariable(Info, block.VB_CurrentInstruction)
         'Increment the instruction pointer if it is a Resume Next statement
         If m_IsResumeNext Then
             Emitter.EmitLoadI4Value(Info, 1)
             Emitter.EmitAdd(Info, Compiler.TypeCache.System_Int32)
         End If
         'If everything is ok, jump to the instruction switch (adding one to the instruction if necessary)
         Emitter.EmitLeave(Info, block.UnstructuredResumeHandler)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2702" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="39" endline="47">
<![CDATA[
     End Property
 
     Private Function GetTypeAttributes() As Mono.Cecil.TypeAttributes
         Dim result As Mono.Cecil.TypeAttributes
 
         result = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2703" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="54" endline="60">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameterConstraints
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameterConstraints(NewParent)
         result.Init(m_ConstraintList.clone(result))
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2704" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="226" endline="239">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClauses  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClauses(ByVal Parent As ImportsStatement) As ImportsClauses
         Dim result As New ImportsClauses(Parent)
 
         If ParseList(Of ImportsClause)(result, New ParseDelegate_Parent(Of ImportsClause)(AddressOf ParseImportsClause), result) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2705" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="51" endline="61">
<![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         Me.ParameterType = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2706" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="348" endline="375">
<![CDATA[
 
     ''' <summary>
     ''' ImportsAliasClause  
     '''	Identifier  =  QualifiedIdentifier  |
     '''	Identifier  =  ConstructedTypeName
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsAliasClause(ByVal Parent As ParsedObject) As ImportsAliasClause
         Dim result As New ImportsAliasClause(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_Second As ImportsNamespaceClause = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Equals)
 
         m_Second = ParseImportsNamespaceClause(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Identifier, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2707" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" startline="42" endline="59">
<![CDATA[
     End Property
 
     Overridable ReadOnly Property AsTypeString() As String
         Get
             If m_Expression Is Nothing Then
                 Return "Nothing"
             Else
                 If m_Expression.ExpressionType Is Nothing Then
                     Return "(Nothing)"
                 Else
                     If m_Expression.ExpressionType.FullName = "" Then
                         Return m_Expression.ExpressionType.Name
                     Else
                         Return m_Expression.ExpressionType.FullName
                     End If
                 End If
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2708" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="373" endline="393">
<![CDATA[
 
     Shared Sub EmitValueTypeToObjectConversion(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         'Dim FromType As Type = Info.Stack.Peek
         Dim FromTP, ToTP As TypeCode
 
         FromTP = Helper.GetTypeCode(Info.Compiler, FromType)
         ToTP = Helper.GetTypeCode(Info.Compiler, ToType)
 
         Helper.Assert(ToTP = TypeCode.Object)
 
         If CecilHelper.IsByRef(ToType) AndAlso Helper.CompareType(CecilHelper.GetElementType(ToType), FromType) Then
             Dim localvar As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, FromType)
             Emitter.EmitStoreVariable(Info, localvar)
             Emitter.EmitLoadVariableLocation(Info, localvar)
         ElseIf Helper.IsEnum(Info.Compiler, CecilHelper.FindDefinition(FromType).BaseType) AndAlso Helper.CompareType(ToType, Info.Compiler.TypeCache.System_Enum) Then
 
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2709" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="42" endline="72">
<![CDATA[
 
     Private Function ResolveIndexedStatement(ByVal Info As ResolveInfo, ByVal InvocationExpression As InvocationOrIndexExpression) As Boolean
         Dim result As Boolean = True
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
 
         For i As Integer = 0 To InvocationExpression.ArgumentList.Count - 1
             Dim arg As Argument = InvocationExpression.ArgumentList(i)
             Dim exp As Expression = arg.Expression
             Dim newExp As VariableExpression
             Dim varDecl As LocalVariableDeclaration
             Dim stmt As AssignmentStatement
 
             varDecl = New LocalVariableDeclaration(arg)
             varDecl.Init(Nothing, "VB$tmp", exp.ExpressionType)
             block.AddVariable(varDecl)
 
             newExp = New VariableExpression(arg, varDecl)
 
             stmt = New AssignmentStatement(Me.Parent)
             stmt.Init(newExp, exp)
             block.AddStatementBefore(stmt, Me)
 
             arg.Expression = newExp
         Next
 
         If InvocationExpression.Classification.IsVariableClassification Then
             result = CheckIndexedStatement(Info, TryCast(InvocationExpression.Classification.AsVariableClassification.ArrayVariable, InvocationOrIndexExpression)) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2710" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="196" endline="202">
<![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2711" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="44" endline="54">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim tpparent As IType = Me.FindFirstParent(Of IType)()
         m_ExpressionType = tpparent.BaseType
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2712" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="47" endline="57">
<![CDATA[
 
     Shadows Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As IdentifierOrKeywordWithTypeArguments
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New IdentifierOrKeywordWithTypeArguments(NewParent)
         If m_TypeArguments IsNot Nothing Then
             result.Init(Me.Identifier, Me.Keyword, m_TypeArguments.Clone(result))
         Else
             result.Init(Me.Identifier, Me.Keyword, Nothing)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2713" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="309" endline="316">
<![CDATA[
 
     Sub RemoveInvalid()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim m As MemberCandidate = m_Candidates(i)
             If m Is Nothing Then Continue For
             If IsValidCandidate(m) = False Then m_Candidates(i) = Nothing
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2714" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="45" endline="65">
<![CDATA[
 
     Overloads Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As FunctionSignature, Optional ByVal GetMethod As PropertyGetDeclaration = Nothing, Optional ByVal SetMethod As PropertySetDeclaration = Nothing, Optional ByVal MemberImplementsClause As MemberImplementsClause = Nothing)
         MyBase.Init(Modifiers, Signature.Name)
 
         m_Signature = Signature
 
         If Modifiers.Is(ModifierMasks.ReadOnly) = False AndAlso SetMethod Is Nothing Then
             SetMethod = New PropertySetDeclaration(Me)
             SetMethod.Init(Modifiers, Nothing, Nothing, Nothing)
         End If
         If Modifiers.Is(ModifierMasks.WriteOnly) = False AndAlso GetMethod Is Nothing Then
             GetMethod = New PropertyGetDeclaration(Me)
             GetMethod.Init(Modifiers, Nothing, Nothing)
         End If
 
         m_Get = GetMethod
         m_Set = SetMethod
         m_MemberImplementsClause = MemberImplementsClause
 
         Helper.Assert(m_Signature IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2720" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="146" endline="153">
<![CDATA[
 
     Overridable Function CreateTypeConversion() As Boolean
         Dim result As Boolean = True
 
         m_RSide = Helper.CreateTypeConversion(Me, m_RSide, m_LSide.ExpressionType, result)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2721" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2391" endline="2403">
<![CDATA[
 
     Private Function ParseUnaryNotExpression(ByVal Info As ExpressionParseInfo) As UnaryNotExpression
         Dim result As New UnaryNotExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Not)
 
         m_Expression = ParseComparison(Info)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2722" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3380" endline="3397">
<![CDATA[
 
     ''' <summary>
     ''' AddressOfExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddressOfExpression(ByVal Parent As ParsedObject) As AddressOfExpression
         Dim result As New AddressOfExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.AddressOf)
 
         m_Expression = ParseExpression(result)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2723" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5880" endline="5891">
<![CDATA[
 
     Private Function ParseCallStatement(ByVal Parent As ParsedObject) As CallStatement
         Dim result As New CallStatement(Parent)
 
         Dim m_Target As Expression
         tm.AcceptIfNotInternalError(KS.Call)
         m_Target = ParseExpression(result)
 
         result.Init(m_Target)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2724" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="82" endline="89">
<![CDATA[
 
     Shared Operator &(ByVal str As String, ByVal ns As [Namespace]) As [Namespace]
         If ns.Global Then
             Throw New InternalException("")
         Else
             Return New [Namespace](ns.Parent, str & "." & ns.ToString, False)
         End If
     End Operator
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2725" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="453" endline="459">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal ParamArray Methods As Mono.Cecil.MemberReference())
         Me.New(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(New Generic.List(Of Mono.Cecil.MemberReference)(Methods))
         Helper.Assert(Methods.Length > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2726" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="63" endline="69">
<![CDATA[
     Sub New(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference)
     Private m_CacheInsensitive(MemberVisibility.All) As MemberCacheEntries
     Private m_FlattenedCacheInsensitive(MemberVisibility.All) As MemberCacheEntries
     Private m_ShadowedInterfaceMembers As Generic.List(Of Mono.Cecil.MemberReference)
     Private m_Type As Mono.Cecil.TypeReference
     Private m_Types As List(Of Mono.Cecil.TypeReference)
     Private m_Members As List(Of Mono.Collections.Generic.Collection(Of MemberReference))
     Private m_Bases As List(Of MemberCache)
     Private m_LoadedNames(MemberVisibility.All) As System.Collections.Generic.Dictionary(Of String, String)
     Private m_LoadedAll(MemberVisibility.All) As Boolean
 
     Sub New(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference)
         m_Compiler = Compiler
         m_Type = Type
 
         Compiler.TypeManager.MemberCache.Add(Type, Me)
         ClearAll()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2727" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="489" endline="502">
<![CDATA[
 
     Private Function CreateLabelForCurrentInstruction(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         If UpmostBlock.HasResume Then
             Dim index As Integer
             Dim lbl As Label = Emitter.DefineLabel(Info)
             UpmostBlock.UnstructuredExceptionLabels.Add(lbl)
             index = UpmostBlock.UnstructuredExceptionLabels.IndexOf(lbl)
             Emitter.MarkLabel(Info, lbl)
             Emitter.EmitLoadI4Value(Info, index)
             Emitter.EmitStoreVariable(Info, UpmostBlock.VB_CurrentInstruction)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2728" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1109" endline="1128">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeArgumentList 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeArgumentList(ByVal Parent As ParsedObject) As TypeArgumentList
         Dim result As New TypeArgumentList(Parent)
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
         tm.AcceptIfNotInternalError(KS.Of)
 
         If ParseList(Of TypeName)(result, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
             Return Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2729" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Index.vb" startline="44" endline="61">
<![CDATA[
 
     Shadows Sub Add(ByVal Base As INameable)
         Dim idxList As IndexList
         'Does name exist already?
         Dim name As String = Base.Name
 
         If name Is Nothing Then Throw New InternalException("Got nothing for base type = " & CObj(Base).GetType().FullName)
 
         If m_lstCollections.ContainsKey(name) Then
             idxList = DirectCast(m_lstCollections.Item(name), IndexList)
         Else 'If not, create a new indexlist
             idxList = New IndexList()
             idxList.Name = name
             m_lstCollections.Add(idxList.Name, idxList)
         End If
         'Add the value
         idxList.Values.Add(Base)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2730" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="32" endline="45">
<![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.new(Parent)
 
         Dim refType As ByReferenceType = TryCast(Expression.ExpressionType, ByReferenceType)
 
         If refType Is Nothing Then Throw New InternalException
 
         m_Expression = Expression
         m_ExpressionType = refType.ElementType
 
         Classification = New VariableClassification(Me, Expression, m_ExpressionType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then Helper.ErrorRecoveryNotImplemented(Me.Location)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2731" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="64" endline="75">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As SubSignature, ByVal Block As CodeBlock)
 
         'If vbnc.Modifiers.IsNothing(Modifiers) = False AndAlso Modifiers.Is(ModifierMasks.Shared) Then
         If Modifiers.Is(ModifierMasks.Shared) OrElse FindTypeParent.IsModule Then
             Signature.Init(New Identifier(Signature, SharedConstructorName, Signature.Location, TypeCharacters.Characters.None), Signature.TypeParameters, Signature.Parameters)
         Else
             Signature.Init(New Identifier(Signature, ConstructorName, Signature.Location, TypeCharacters.Characters.None), Signature.TypeParameters, Signature.Parameters)
         End If
 
         MyBase.Init(Modifiers, Signature, Block)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2732" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GlobalExpression.vb" startline="36" endline="42">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
 
         Classification = New NamespaceClassification(Me, New GlobalNamespace(Me))
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2733" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="83" endline="89">
<![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
         AddAttribute()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2734" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1326" endline="1339">
<![CDATA[
 
     ''' <summary>
     ''' Loads the boolean value onto the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Overloads Shared Sub EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Boolean)
         If Value Then
             EmitLoadI4Value(Info, 1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2735" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="231" endline="247">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property FullName() As String
         Get
             If m_FullName Is Nothing Then
                 If Me.IsNestedType Then
                     m_FullName = DeclaringType.FullName & "+" & Me.Name
                 Else
                     If m_Namespace <> "" Then
                         m_FullName = m_Namespace & "." & Me.Name
                     Else
                         m_FullName = Me.Name
                     End If
                 End If
             End If
             Return m_FullName
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2736" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="51" endline="67">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As QualifiedIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New QualifiedIdentifier(NewParent, Me.Location)
 
         If Me.IsFirstGlobal Then
             result.Init(Me.FirstAsGlobal.Clone(result), m_Second)
         ElseIf Me.IsFirstIdentifier Then
             result.Init(Me.FirstAsIdentifier.Clone(result), m_Second)
         ElseIf Me.IsFirstQualifiedIdentifier Then
             result.Init(Me.FirstAsQualifiedIdentifier.Clone(result), m_Second)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2740" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="941" endline="968">
<![CDATA[
 
     ''' <summary>
     ''' Returns the directory where the system assemblies are installed
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function GetSystemDir() As String
         Dim assemblies() As Reflection.Assembly
         Dim result As String
 
         If Not String.IsNullOrEmpty(CommandLine.SDKPath) Then
             If CommandLine.Verbose Then Report.WriteLine(string.Format ("Using alternate system path
             Return CommandLine.SDKPath
         End If
 
         assemblies = AppDomain.CurrentDomain.GetAssemblies
 
         For Each a As Reflection.Assembly In assemblies
             Dim codebase As String = a.Location
             If codebase.EndsWith("corlib.dll") Then
                 result = codebase.Substring(0, codebase.LastIndexOf(System.IO.Path.DirectorySeparatorChar))
                 If CommandLine.Verbose Then Report.WriteLine(String.Format("Using system path
                 Return result
             End If
         Next
         Throw New InternalException("Cannot compute the system directory.")
         Return ""
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2741" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="46" endline="54">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal Signature As SubSignature)
         MyBase.Init(Modifiers, Signature, Nothing)
         Modifiers = Modifiers.AddModifier(KS.Shared)
         m_CharsetModifier = CharsetModifier
         m_Identifier = Identifier
         m_LibraryClause = LibraryClause
         m_AliasClause = AliasClause
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2742" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="89" endline="98">
<![CDATA[
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2743" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1129" endline="1168">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeName 
     ''' 
     ''' ArrayTypeName          
     ''' ArrayTypeModifiers     
     ''' ArrayTypeModifier      
     ''' RankList               
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeName(ByVal Parent As ParsedObject) As TypeName
         Dim result As New TypeName(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers
         Dim m_ArrayTypeName As ArrayTypeName
 
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If m_NonArrayTypeName Is Nothing Then Return Nothing
 
         If ArrayTypeName.CanBeArrayTypeModifier(tm) Then
             m_ArrayTypeName = New ArrayTypeName(Parent)
 
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(m_ArrayTypeName)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             m_NonArrayTypeName.Parent = m_ArrayTypeName
 
             m_ArrayTypeName.Init(m_NonArrayTypeName, m_ArrayTypeModifiers)
 
             result.Init(m_ArrayTypeName)
         Else
             result.Init(m_NonArrayTypeName)
         End If
 
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2744" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3772" endline="3791">
<![CDATA[
 
     ''' <summary>
     ''' SubSignature  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSubSignature(ByVal Parent As ParsedObject) As SubSignature
         Dim result As New SubSignature(Parent)
 
         Dim m_Identifier As Identifier = Nothing
         Dim m_TypeParameters As TypeParameters = Nothing
         Dim m_ParameterList As New ParameterList(result)
 
         If ParseSubSignature(result, m_Identifier, m_TypeParameters, m_ParameterList) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_TypeParameters, m_ParameterList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2745" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="320" endline="344">
<![CDATA[
 
     ''' <summary>
     ''' Load the type into the various lists.
     ''' </summary>
     ''' <param name="Type"></param>
     ''' <remarks></remarks>
     Private Sub LoadType(ByVal Type As Mono.Cecil.TypeDefinition)
         'Add the type to the list of all types.
         Me.Types.Add(Type)
 
         'Add the namespace to the list of all namespaces.
         Me.Namespaces.AddAllNamespaces(Compiler, Type.Namespace, True)
 
         'Add the type to the list of types by namespace.
         m_CecilTypesByNamespace.AddType(Type)
 
         'If it is a module add it to the list of all modules and to the list of modules by namespace.
         If Helper.IsModule(Compiler, Type) Then
             m_CecilModuleTypes.Add(Type)
             m_CecilModulesByNamespace.AddType(Type)
         Else
             Helper.Assert(Type.Annotations(Compiler) Is Nothing OrElse Not TypeOf Type.Annotations(Compiler) Is ModuleDeclaration)
         End If
 
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2746" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3882" endline="3900">
<![CDATA[
 
 
     Shared Function ShowClassificationError(ByVal Compiler As Compiler, ByVal Location As Span, ByVal ActualClassification As ExpressionClassification, ByVal Expected As String) As Boolean
         Select Case ActualClassification.Classification
             Case ExpressionClassification.Classifications.Type
                 Dim tp As Mono.Cecil.TypeReference = ActualClassification.AsTypeClassification.Type
                 Return Compiler.Report.ShowMessage(Messages.VBNC30691, Location, tp.Name, tp.Namespace)
             Case ExpressionClassification.Classifications.Value
                 Dim vC As ValueClassification = ActualClassification.AsValueClassification
                 If vC.IsConstant Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30074, Location)
                 Else
                     Helper.AddError(Compiler, Location, "Expected " & Expected & " got " & ActualClassification.Classification.ToString())
                 End If
             Case Else
                 Helper.AddError(Compiler, Location, "Expected " & Expected & " got " & ActualClassification.Classification.ToString())
         End Select
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2747" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="54" endline="62">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeName(NewParent)
 
         result.Init(m_TypeName.Clone(result), m_ArrayTypeModifiers.Clone(result))
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2748" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1765" endline="1779">
<![CDATA[
 
     Shared Sub EmitRetOrLeave(ByVal Info As EmitInfo, ByVal CurrentStatement As Statement, ByVal HasReturnValue As Boolean)
         Dim emitLeave As Boolean
 
         emitLeave = IsLeaveNecessary(CurrentStatement, Nothing)
 
         If emitLeave Then
             If HasReturnValue Then
                 Emitter.EmitStoreVariable(Info, Info.Method.DefaultReturnVariable)
             End If
             Emitter.EmitLeave(Info, CurrentStatement.FindParentCodeBlock.UpmostBlock.EndOfMethodLabel)
         Else
             Emitter.EmitRet(Info)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2749" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1884" endline="1898">
<![CDATA[
 
     Private Function ParseBuiltInTypeExpression(ByVal Parent As ParsedObject) As BuiltInTypeExpression
         Dim result As New BuiltInTypeExpression(Parent)
 
         Dim m_Type As BuiltInDataTypes
 
         Helper.Assert(tm.CurrentToken.Equals(Enums.BuiltInTypeTypeNames))
 
         m_Type = CType(tm.CurrentToken.Keyword, BuiltInDataTypes)
         tm.NextToken()
 
         result.Init(m_Type)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2750" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2637" endline="2645">
<![CDATA[
 
     Private Function ParseMeExpression(ByVal Parent As ParsedObject) As MeExpression
         Dim result As MeExpression
 
         tm.AcceptIfNotInternalError(KS.Me)
         result = New MeExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2751" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="216" endline="222">
<![CDATA[
 
     Sub New(ByVal Classification As PropertyGroupClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2752" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="223" endline="229">
<![CDATA[
 
     Sub New(ByVal Classification As MethodGroupClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2753" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="237" endline="243">
<![CDATA[
 
     Sub New(ByVal Classification As LateBoundAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2754" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="32" endline="38">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New BooleanLiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2755" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="413" endline="420">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal variable As VariableDeclaration, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.New(Classifications.Variable, Parent)
         m_Variable = variable
         m_LocalVariable = TryCast(m_Variable, LocalVariableDeclaration)
         m_TypeVariable = TryCast(m_Variable, TypeVariableDeclaration)
         m_InstanceExpression = InstanceExpression
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2758" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="47" endline="62">
<![CDATA[
 
     ''' <summary>
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal [Namespace] As String) As TypeDictionary
         Get
             If MyBase.ContainsKey([Namespace]) Then
                 Return MyBase.Item([Namespace])
             Else
                 Return TypeDictionary.EmptyDictionary
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2759" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="252" endline="258">
<![CDATA[
 
     Sub AddInitializer(ByVal Expression As Expression)
         Dim init As New VariableInitializer(Me)
         init.Init(Expression)
         m_VariableInitializerList.Add(init)
         If SetElements() = False Then Throw New InternalException(Me)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2760" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="61" endline="71">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As ExpressionClassification)
         MyBase.new()
         If Obj IsNot Nothing Then
             m_Message = "There has been an internal error in the compiler caused by the line
         Else
             m_Message = "There has been an internal error in the compiler."
         End If
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2761" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="175" endline="186">
<![CDATA[
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2763" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2078" endline="2086">
<![CDATA[
 
     Shared Function ResolveTypeReferencesCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             result = obj.ResolveTypeReferences AndAlso result
             'vbnc.Helper.Assert(result = (obj.Compiler.Report.Errors = 0))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2764" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="152" endline="159">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal EnumVariable As EnumMemberDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(EnumVariable IsNot Nothing)
         m_EnumVariable = EnumVariable
         m_Type = m_EnumVariable.FindFirstParent(Of EnumDeclaration).EnumConstantType
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2765" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="97" endline="118">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="IncludePath"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function ToString(ByVal IncludePath As Boolean, ByVal Compiler As Compiler) As String
         If m_Line < 0 Then
             Return "(in the commandline)"
         End If
 
         If Not File(Compiler) Is Nothing Then
             If IncludePath Then
                 Return String.Format("{0} ({1},{2})", File(Compiler).FileName, Line.ToString, Column.ToString)
             Else
                 Return String.Format("{0} ({1},{2})", File(Compiler).FileNameToReport, Line.ToString, Column.ToString)
             End If
         Else
             Return String.Format("({0},{1})", Line.ToString, Column.ToString)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2766" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="355" endline="365">
<![CDATA[
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2774" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="507" endline="519">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     Function Accept(ByVal Identifier As String, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Identifier) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2775" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="26" endline="33">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New PropertyAccessClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2776" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="409" endline="419">
<![CDATA[
 
     Function ReclassifyMethodPointerToValueExpression(ByVal DelegateType As Mono.Cecil.TypeReference) As Expression
         Dim result As Expression = Nothing
 
         Helper.Assert(Classification.IsMethodPointerClassification)
         Helper.Assert(TypeOf Me Is AddressOfExpression)
 
         result = New DelegateOrObjectCreationExpression(Me, DelegateType, DirectCast(Me, AddressOfExpression))
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2777" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="39" endline="45">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributeArgumentExpression
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributeArgumentExpression(NewParent)
         result.Init(m_Expression.Clone(result))
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2778" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableIdentifier.vb" startline="46" endline="52">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
 
         If Identifier.Identifier Is Nothing Then Throw New InternalException("No identifier
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2779" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="47" endline="53">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal TokenReader As Scanner)
     Private m_ShowErrors As Boolean = True
 
     Private ReadOnly Property ShowErrors() As Boolean
         Get
             Return m_ShowErrors
         End Get
     End Property
 
     Public ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         tm = m_Compiler.tm
         Helper.Assert(tm IsNot Nothing)
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal TokenReader As Scanner)
         m_Compiler = Compiler
         tm = New tm(Compiler, TokenReader)
         tm.NextToken()
         Helper.Assert(tm IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2780" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="324" endline="347">
<![CDATA[
 
     Function GetObjectReference() As Expression
         Dim result As Expression
         If TypeOf Me Is GetRefExpression Then
             Return Me
         ElseIf TypeOf Me Is InstanceExpression Then
             Return Me
         ElseIf CecilHelper.IsValueType(ExpressionType) Then
             If TypeOf Me Is DeRefExpression Then
                 Dim derefExp As DeRefExpression = DirectCast(Me, DeRefExpression)
                 result = derefExp.Expression
             ElseIf Helper.CompareType(CecilHelper.FindDefinition(Me.ExpressionType).BaseType, Compiler.TypeCache.System_Enum) Then
                 result = New BoxExpression(Me, Me, CecilHelper.MakeByRefType(Me.ExpressionType))
                 'ElseIf Me.ExpressionType.IsValueType AndAlso Helper.IsNullableType(Compiler, Me.ExpressionType) = False Then
                 '    result = New BoxExpression(Me, Me, Me.ExpressionType)
             Else
                 result = New GetRefExpression(Me, Me)
             End If
         Else
             result = Me
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2781" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="1208" endline="1245">
<![CDATA[
 
     ''' <summary>
     ''' Shows an error if the filename(s) cannot be found.
     ''' If it returns an empty array something went wrong 
     ''' (the error message has already been shown).
     ''' </summary>
     ''' <param name="FileName">Can be a complete filename or a pattern.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetFullPaths(ByVal FileName As String) As String()
         Dim strPath As String = System.IO.Path.GetDirectoryName(FileName)
         Dim strFileName As String
 
         If strPath <> "" Then
             strFileName = FileName.Substring(strPath.Length + 1)
         Else
             strFileName = FileName
         End If
 
         Dim tmpPath As String
         If strPath = "" Then
             strPath = IO.Path.GetDirectoryName(IO.Path.GetFullPath(FileName))
         End If
         tmpPath = IO.Path.GetFullPath(strPath)
 
         If IO.Directory.Exists(tmpPath) = False Then Return Nothing
 
         If IsPattern(FileName) Then
             Return IO.Directory.GetFiles(tmpPath, strFileName)
         Else
             Dim file As String = IO.Path.Combine(tmpPath, strFileName)
             If IO.File.Exists(file) Then
                 Return New String() {file}
             Else
                 Return Nothing
             End If
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2785" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="40" endline="47">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Constraint
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New Constraint(NewParent)
         If m_TypeName IsNot Nothing Then result.m_TypeName = m_TypeName.Clone(result)
         result.m_Special = m_Special
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2786" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2628" endline="2636">
<![CDATA[
 
     Private Function ParseMyBaseExpression(ByVal Parent As ParsedObject) As MyBaseExpression
         Dim result As MyBaseExpression
 
         tm.AcceptIfNotInternalError(KS.MyBase)
         result = New MyBaseExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2787" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="682" endline="695">
<![CDATA[
 
     Private Function ParseIdentifierOrKeyword(ByVal Parent As ParsedObject) As IdentifierOrKeyword
         Dim result As IdentifierOrKeyword
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             result = New IdentifierOrKeyword(Parent, tm.CurrentToken)
             tm.NextToken()
         Else
             Helper.AddError(Compiler, tm.CurrentLocation)
             result = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2788" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="130" endline="144">
<![CDATA[
     End Property
 
     Friend Function DefineLocalVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.IsStaticVariable Then Return result
 
         Helper.Assert(IsLocalVariable)
 
         If m_LocalBuilder Is Nothing Then
             m_LocalBuilder = Emitter.DeclareLocal(Info, VariableTypeOrTypeBuilder, Me.Name)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2789" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="27" endline="35">
<![CDATA[
         Get
             Dim result As String = ""
             If m_PropertyAccess.InstanceExpression IsNot Nothing Then
                 result = m_PropertyAccess.InstanceExpression.AsString & "."
             End If
             result &= m_PropertyAccess.ResolvedProperty.Name
             result &= "(" & m_PropertyAccess.Parameters.AsString & ")"
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2790" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1559" endline="1582">
<![CDATA[
 
     Private Sub NextFile()
         m_TotalLineCount += m_CurrentLine
         'm_TotalCharCount += m_Code.Length
 
         m_CurrentLine = 1
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
         m_CurrentChar = Nothing
         m_PreviousChar = Nothing
         m_EndOfFile = False
         m_PeekedChars.Clear()
 
         If m_Files.Count > 0 Then
             m_CodeFile = m_Files.Dequeue()
             m_CodeFileIndex = CUShort(Compiler.CommandLine.Files.IndexOf(m_CodeFile))
             m_Reader = m_CodeFile.CodeStream
             NextChar()
         Else
             m_CodeFile = Nothing
             'm_Code = Nothing
             m_Reader = Nothing
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2791" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1501" endline="1529">
<![CDATA[
 
     ''' <summary>
     ''' Parses a type declaration. Returns nothing if no type declaration was found.
     ''' Parses only one typedeclaration.
     ''' Type declaration = Class, Module, Structure, Enum, Delegate, Interface declaration.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseTypeDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As TypeDeclaration
         Dim result As TypeDeclaration
         If ClassDeclaration.IsMe(tm) Then
             result = ParseClassDeclaration(Parent, Attributes, [Namespace])
         ElseIf EnumDeclaration.IsMe(tm) Then
             result = ParseEnumDeclaration(Parent, Attributes, [Namespace])
         ElseIf StructureDeclaration.IsMe(tm) Then
             result = ParseStructureDeclaration(Parent, Attributes, [Namespace])
         ElseIf InterfaceDeclaration.IsMe(tm) Then
             result = ParseInterfaceDeclaration(Parent, Attributes, [Namespace])
         ElseIf DelegateDeclaration.IsMe(tm) Then
             result = ParseDelegateDeclaration(Parent, Attributes, [Namespace])
         ElseIf ModuleDeclaration.IsMe(tm) Then
             result = ParseModuleDeclaration(Parent, Attributes, [Namespace])
         Else
             result = Nothing
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2792" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="113" endline="124">
<![CDATA[
 
     Sub CloneTo(ByVal ClonedSignature As SubSignature)
         ClonedSignature.m_Identifier = m_Identifier
         If m_TypeParameters IsNot Nothing Then
             ClonedSignature.m_TypeParameters = m_TypeParameters.Clone()
             ClonedSignature.m_TypeParameters.Initialize(ClonedSignature)
         End If
         If m_ParameterList IsNot Nothing Then
             ClonedSignature.m_ParameterList = m_ParameterList.Clone(ClonedSignature)
             ClonedSignature.m_ParameterList.Initialize(ClonedSignature)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2793" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="229" endline="252">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2794" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="357" endline="387">
<![CDATA[
 
     Public Shared Function EmitLateSet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateSet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
 
         '2 - Type ??? - haven't found an example where this isn't nothing yet
         Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateSet_Object_Type_String_Array_Array_Array)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2795" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="425" endline="434">
<![CDATA[
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2796" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="414" endline="424">
<![CDATA[
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2797" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="67" endline="94">
<![CDATA[
     End Property
 
     Overloads Function [GetType](ByVal ThrowIfNoType As Boolean) As Mono.Cecil.TypeReference
         Select Case m_Classification
             Case Classifications.Value
                 Return AsValueClassification.Type
             Case Classifications.Variable
                 Return AsVariableClassification.Type
             Case Classifications.MethodGroup
                 Return AsMethodGroupClassification.Type
             Case Classifications.MethodPointer
                 Return AsMethodPointerClassification.Type
             Case Classifications.PropertyAccess
                 Return AsPropertyAccess.Type
             Case Classifications.PropertyGroup
                 Return AsPropertyGroup.Type
             Case Classifications.Void
                 Return Compiler.TypeCache.System_Void
             Case Classifications.LateBoundAccess
                 Return AsLateBoundAccess.Type
             Case Else
                 If ThrowIfNoType Then
                     Throw New InternalException("No type was found")
                 Else
                     Return Nothing
                 End If
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2798" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2309" endline="2361">
<![CDATA[
 
     ''' <summary>
     ''' Get the type attribute from the scope
     ''' </summary>
     ''' <param name="Modifiers"></param>
     ''' <param name="isNested"></param>
     ''' <returns></returns>
     ''' <remarks>
     ''' Scope
     ''' Private = private
     ''' Protected = family
     ''' Protected Friend = famorassem
     ''' Friend = assembly
     ''' Public = public
     ''' </remarks>
     Shared Function getTypeAttributeScopeFromScope(ByVal Modifiers As Modifiers, ByVal isNested As Boolean) As Mono.Cecil.TypeAttributes
         If Not isNested Then
             'If vbnc.Modifiers.IsNothing(Modifiers) = False Then
             If Modifiers.Is(ModifierMasks.Public) Then
                 Return Mono.Cecil.TypeAttributes.Public
             Else
                 Return Mono.Cecil.TypeAttributes.NotPublic
             End If
             'Else
             '  Return TypeAttributes.NotPublic
             'End If
         Else
             'If vbnc.Modifiers.IsNothing(Modifiers) = False Then
             If Modifiers.Is(ModifierMasks.Public) Then
                 Return Mono.Cecil.TypeAttributes.NestedPublic
             ElseIf Modifiers.Is(ModifierMasks.Friend) Then
                 If Modifiers.Is(ModifierMasks.Protected) Then
                     Return Mono.Cecil.TypeAttributes.NestedFamORAssem
                     '0Return Reflection.TypeAttributes.NotPublic
                     'Return Reflection.TypeAttributes.VisibilityMask
                 Else
                     Return Mono.Cecil.TypeAttributes.NestedAssembly
                     'Return Reflection.TypeAttributes.NotPublic
                 End If
             ElseIf Modifiers.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.TypeAttributes.NestedFamily
                 'Return Reflection.TypeAttributes.NotPublic
             ElseIf Modifiers.Is(ModifierMasks.Private) Then
                 Return Mono.Cecil.TypeAttributes.NestedPrivate
             Else
                 'Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Default scope set to public...")
                 Return Mono.Cecil.TypeAttributes.NestedPublic
             End If
             ' Else
             'Return Reflection.TypeAttributes.NestedPublic
             'End If
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2799" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="320" endline="345">
<![CDATA[
 
     Function RuleStringConcat(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleAdditionSubtractionStringConcat(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Concat)
             NextToken()
             RuleAdditionSubtractionStringConcat(RSide)
 
             Dim op1, op2 As String
             Dim bErr As Boolean
 
             op1 = LSide.ToString
             op2 = RSide.ToString
 
             If bErr Then
                 LSide = ""
             Else
                 LSide = op1 & op2
             End If
         End While
         While CurrentToken.Equals(KS.Concat)
             NextToken()
             RuleAdditionSubtractionStringConcat(RSide)
 
             Dim op1, op2 As String
             Dim bErr As Boolean
 
             op1 = LSide.ToString
             op2 = RSide.ToString
 
             If bErr Then
                 LSide = ""
             Else
                 LSide = op1 & op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2800" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="47" endline="55">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameterList(NewParent)
         For Each item As TypeParameter In Me
             result.Add(item.clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2801" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="50" endline="72">
<![CDATA[
     End Property
 
     Function CreateAliasExpression(ByVal SharedExpression As Expression, ByRef result As Expression) As Boolean
         Dim sne As SimpleNameExpression = TryCast(SharedExpression, SimpleNameExpression)
         Dim mae As MemberAccessExpression
         Dim maeIE As MemberAccessExpression
 
         If TypeOf SharedExpression.Parent Is Is_IsNotExpression Then
             Dim fieldLoad As New LoadFieldExpression(SharedExpression, DirectCast(m_Type.Annotations(Compiler), TypeDeclaration).MyGroupField.FieldBuilder, m_Group.DefaultInstanceAlias)
             result = fieldLoad
         Else
             If sne IsNot Nothing Then
                 maeIE = New MemberAccessExpression(SharedExpression.Parent)
                 maeIE.Init(Expression, New IdentifierOrKeyword(SharedExpression.Parent, Token.CreateIdentifierToken(sne.Location, sne.Identifier.Identifier)))
             Else
                 mae = TryCast(SharedExpression, MemberAccessExpression)
                 maeIE = New MemberAccessExpression(SharedExpression.Parent)
                 maeIE.Init(Expression, mae.SecondExpression)
             End If
             result = maeIE
         End If
         Return result.ResolveExpression(ResolveInfo.Default(SharedExpression.Compiler))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2802" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="87" endline="93">
<![CDATA[
 
     Shared Function EmitBeginExceptionBlock(ByVal Info As EmitInfo) As Label
         Helper.Assert(Info.InExceptionFilter = False)
         Dim result As Label
         result = Info.ILGen.BeginExceptionBlock
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2803" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="209" endline="215">
<![CDATA[
 
     Sub New(ByVal Classification As VariableClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2804" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="230" endline="236">
<![CDATA[
 
     Sub New(ByVal Classification As MethodPointerClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2805" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="244" endline="250">
<![CDATA[
 
     Sub New(ByVal Classification As PropertyAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2806" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArgumentList.vb" startline="43" endline="52">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeArgumentList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeArgumentList(NewParent)
         For Each item As TypeName In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2807" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="154" endline="170">
<![CDATA[
     End Property
 
     Private m_FakeGenerator As EmitLog
     ''' <summary>
     ''' The ILGenerator used to emit the code.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ILGen() As EmitLog
         Get
             If m_FakeGenerator Is Nothing Then
                 m_FakeGenerator = New EmitLog(Compiler)
                 m_FakeGenerator.CilBody = CilBody
             End If
             Return m_FakeGenerator
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2808" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="278" endline="285">
<![CDATA[
 
     ''' <summary>
     ''' Saves the message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function SaveMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(True, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2809" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="40" endline="46">
<![CDATA[
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
     Private m_ShowErrors As Boolean = True
 
     Private ReadOnly Property ShowErrors() As Boolean
         Get
             Return m_ShowErrors
         End Get
     End Property
 
     Public ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         tm = m_Compiler.tm
         Helper.Assert(tm IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2810" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="160" endline="166">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Variable As VariableDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Variable IsNot Nothing)
         m_Classification = New VariableClassification(Me.Parent, Variable)
         m_Type = DirectCast(m_Classification, VariableClassification).Type
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2811" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="460" endline="466">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2812" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="443" endline="452">
<![CDATA[
 
     Private Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression)
         MyBase.new(Classifications.MethodGroup, Parent)
         m_InstanceExpression = InstanceExpression
         m_CallingType = Parent.FindFirstParent(Of TypeDeclaration)()
         m_Parameters = Parameters
         m_TypeArguments = TypeArguments
         'Helper.Assert(m_CallingType IsNot Nothing)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2813" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="137" endline="148">
<![CDATA[
 
     Private Function ConvertArgument(ByVal constant As Object, ByVal Type As Mono.Cecil.TypeReference) As Object
         If Helper.IsEnum(Compiler, Type) = False Then Return constant
 
         Dim enumCecilAssembly As Mono.Cecil.AssemblyNameReference = CecilHelper.GetAssemblyRef(Type)
         Dim enumAssembly As Assembly = System.Reflection.Assembly.Load(enumCecilAssembly.FullName)
         Dim enumType As Type = enumAssembly.GetType(Type.FullName)
 
         If enumType.IsEnum = False Then Return constant
 
         Return System.Enum.ToObject(enumType, constant)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2814" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="480" endline="490">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the flattened cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattened(ByVal Name As String, ByVal From As Mono.Cecil.TypeReference) As MemberCacheEntry
         Return LookupFlattened(Name, Helper.GetVisibility(Compiler, From, m_Type))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2815" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="95" endline="101">
<![CDATA[
     End Property
 
     ReadOnly Property AsNonArrayTypeName() As NonArrayTypeName
         Get
             Helper.Assert(IsNotArray)
             Return DirectCast(m_TypeName, NonArrayTypeName)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2816" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="107" endline="115">
<![CDATA[
 End Class
 
 Public Class ValueOnStackExpression
     Inherits CompilerGeneratedExpression
 
     Sub New(ByVal Parent As ParsedObject, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.New(Parent, Nothing, ExpressionType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2817" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="272" endline="279">
<![CDATA[
 
     Shared Sub EmitMultOrMultOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitMultOvf(Info, OperandType)
         Else
             EmitMult(Info, OperandType)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2818" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="364" endline="373">
<![CDATA[
 
     Private Function ResolveLateBoundArrayInvocation(ByVal Context As ParsedObject) As Boolean
         Dim result As Boolean = True
 
         Classification = New LateBoundAccessClassification(Me, Expression, Nothing, Nothing)
 
         m_IsLateBoundArray = True
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2819" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="154" endline="161">
<![CDATA[
 
     Shared Sub EmitSubOrSubOvfOrSubOvfUn(ByVal Info As EmitInfo, ByVal SubType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitSubOvf(Info, SubType)
         Else
             EmitSub(Info, SubType)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2820" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="102" endline="108">
<![CDATA[
     End Property
 
     ReadOnly Property AsArrayTypeName() As ArrayTypeName
         Get
             Helper.Assert(IsArray)
             Return DirectCast(m_TypeName, ArrayTypeName)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2821" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1150" endline="1157">
<![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As Boolean)
         If I Then
             EmitLoadI4Value(Info, -1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2822" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="414" endline="428">
<![CDATA[
 
     <Obsolete()> _
     Function AcceptIdentifier(ByRef result As Token) As Boolean
         Dim tmp As Token = CurrentToken()
         If CurrentToken.IsIdentifier Then
             result = CurrentToken()
             If tmp.IsIdentifier = False Then Throw New InternalException("Not an identifier?????")
             If CurrentToken.IsIdentifier = False Then Throw New InternalException("Not an identifier???")
             If result.IsIdentifier = False Then Throw New InternalException("Not an identifier?")
             NextToken()
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2826" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="38" endline="54">
<![CDATA[
 
     ''' <summary>
     ''' Loops up the namespace of the specified namespace.
     ''' Returns nothing if nothing is found.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Overloads ReadOnly Property Item(ByVal Name As String) As [Namespace]
         Get
             If ContainsKey(Name) Then
                 Return m_Hashed(Name)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2827" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="249" endline="256">
<![CDATA[
 
     Shared Sub EmitAddOrAddOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitAddOvf(Info, OperandType)
         Else
             EmitAdd(Info, OperandType)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2828" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetRefExpression.vb" startline="34" endline="51">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Automatically resolved.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Expression"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.new(Parent)
         m_Expression = Expression
         m_ExpressionType = Parent.Compiler.TypeManager.MakeByRefType(Parent, Expression.ExpressionType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Throw New InternalException(Me)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2829" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="40" endline="48">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadToken(Info, m_TypeName.ResolvedType)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2830" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="96" endline="103">
<![CDATA[
     End Property
 
     Public Sub AddCustomAttribute(ByVal Attribute As Attribute)
         If m_CustomAttributes Is Nothing Then
             m_CustomAttributes = New Attributes(Me)
         End If
         m_CustomAttributes.Add(Attribute)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2831" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="74" endline="80">
<![CDATA[
 
     Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String)
         m_Modifiers = Modifiers
         m_Name = Name
 
         If m_Name Is Nothing Then Throw New InternalException(Me.Location.ToString(Compiler))
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2832" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="166" endline="181">
<![CDATA[
 
     ''' <summary>
     ''' A label to just before the last ret instruction of the method.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property EndOfMethodLabel() As Label
         Get
             If m_EndOfMethodLabel.HasValue Then
                 Return m_EndOfMethodLabel.Value
             Else
                 Helper.Assert(Me IsNot UpmostBlock)
                 Return Me.UpmostBlock.EndOfMethodLabel
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2833" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="53" endline="59">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             Dim value As Object = Expression.ConstantValue
             Return value
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2834" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="49" endline="56">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArraySizeInitializationModifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArraySizeInitializationModifier(NewParent)
         result.m_BoundList = m_BoundList.Clone(result)
         If m_ArrayTypeModifiers IsNot Nothing Then result.m_ArrayTypeModifiers = m_ArrayTypeModifiers.Clone(result)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2835" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="45" endline="51">
<![CDATA[
 
     Sub New(ByVal Parent As TypeDeclaration, ByVal Name As String, ByVal MethodAttributes As Mono.Cecil.MethodAttributes, ByVal ParameterTypes As Mono.Cecil.TypeReference())
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), New SubSignature(Me, Name, ParameterTypes))
         MyBase.MethodAttributes = MethodAttributes
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2836" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="167" endline="174">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Variable As Mono.Cecil.FieldReference, ByVal InstanceExpression As Expression)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Variable IsNot Nothing)
         m_Classification = New VariableClassification(Me.Parent, Variable, InstanceExpression)
         m_Type = DirectCast(m_Classification, VariableClassification).Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2837" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="124" endline="136">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Attribute
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New Attribute(NewParent)
         result.m_IsAssembly = m_IsAssembly
         result.m_IsModule = m_IsModule
         If m_SimpleTypeName IsNot Nothing Then result.m_SimpleTypeName = m_SimpleTypeName.Clone(result)
         If m_AttributeArguments IsNot Nothing Then result.m_AttributeArguments = m_AttributeArguments.Clone(result)
         result.m_ResolvedType = m_ResolvedType
         result.m_ResolvedTypeConstructor = m_ResolvedTypeConstructor
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2838" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="58" endline="64">
<![CDATA[
 
     Friend Sub ChangeQualifiedIdentifier(ByVal qi As QualifiedIdentifier)
         Helper.Assert(IsQualifiedIdentifier)
         'Helper.Assert(AsQualifiedIdentifier.Second IsNot Nothing)
         Helper.Assert(AsQualifiedIdentifier.First Is qi)
         m_TypeName = qi
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2839" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="79" endline="88">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_MethodGroup.Resolved)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_MethodGroup.InstanceExpression, m_MethodGroup.FinalArguments, Helper.GetMethodOrMethodReference(Compiler, m_MethodGroup.ResolvedMethod))
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2840" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2619" endline="2627">
<![CDATA[
 
     Private Function ParseMyClassExpression(ByVal Parent As ParsedObject) As MyClassExpression
         Dim result As MyClassExpression
 
         tm.AcceptIfNotInternalError(KS.MyClass)
         result = New MyClassExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2841" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="278" endline="286">
<![CDATA[
     End Property
 
     ReadOnly Property IsNestedType() As Boolean Implements IType.IsNestedType
         Get
             Dim result As Boolean
             result = DeclaringType IsNot Nothing
             Helper.Assert(result = (Me.FindFirstParent(Of IType)() IsNot Nothing))
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2842" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="68" endline="76">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializer
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializer(NewParent)
         If m_IdentifierOrKeyword IsNot Nothing Then result.m_IdentifierOrKeyword = m_IdentifierOrKeyword.Clone(result)
         If m_AttributeArgumentExpression IsNot Nothing Then result.m_AttributeArgumentExpression = m_AttributeArgumentExpression.Clone(result)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2843" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="242" endline="256">
<![CDATA[
     End Property
 
     Function FindLabel(ByVal Name As Token) As LabelDeclarationStatement
         Dim cb As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         If cb IsNot Nothing Then
             Return cb.FindLabel(Name)
         Else
             For Each l As LabelDeclarationStatement In m_Labels
                 If l.Label.Equals(Name) Then
                     Return l
                 End If
             Next
         End If
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2844" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="85" endline="91">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As TypeName)
         MyBase.Init(Modifiers, Name)
         m_TypeName = VariableType
 
         Helper.Assert(m_TypeName IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2845" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LabelDeclarationStatement.vb" startline="64" endline="70">
<![CDATA[
 
     Function GetLabel(ByVal Info As EmitInfo) As Label
         If m_LabelBuilder.HasValue = False Then
             m_LabelBuilder = Emitter.DefineLabel(Info)
         End If
         Return m_LabelBuilder.Value
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2846" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="42" endline="50">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributeArguments
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributeArguments(NewParent)
         If m_AttributePositionalArgumentList IsNot Nothing Then result.m_AttributePositionalArgumentList = m_AttributePositionalArgumentList.clone(result)
         If m_VariablePropertyInitializerList IsNot Nothing Then result.m_VariablePropertyInitializerList = m_VariablePropertyInitializerList.clone(result)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2847" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="46" endline="53">
<![CDATA[
 
     Shadows Sub Init(ByVal EnumIndex As Integer, ByVal Identifier As Identifier, ByVal ConstantExpression As Expression)
         MyBase.Init(Nothing, Identifier.Identifier)
         m_EnumIndex = EnumIndex
         m_Identifier = Identifier
         m_ConstantExpression = ConstantExpression
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2848" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="61" endline="67">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstructedTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstructedTypeName(NewParent)
         result.Init(m_QualifiedIdentifier.Clone(result), m_TypeArgumentList.Clone(result))
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2849" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="179" endline="190">
<![CDATA[
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2850" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="285" endline="295">
<![CDATA[
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2851" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="125" endline="131">
<![CDATA[
 
     Sub RestoreToPoint(ByVal Point As RestorablePoint)
         m_CurrentIndex = Point.Index
         Current = m_TokenList(m_CurrentIndex)
         'Console.WriteLine(" Restored to
         IgnoreRestoredPoint()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2852" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="96" endline="108">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             If IsConstant = False Then Throw New InternalException(Me)
 
             Dim rvalue, lvalue As String
 
             lvalue = CStr(m_LeftExpression.ConstantValue)
             rvalue = CStr(m_RightExpression.ConstantValue)
 
             Return lvalue & rvalue
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2853" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="55" endline="62">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal TypeName As TypeName, ByVal ConstantExpression As Expression)
         MyBase.Init(Modifiers, Identifier.Name)
         m_Identifier = Identifier
         m_TypeName = TypeName
         m_ConstantExpression = ConstantExpression
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2854" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6073" endline="6082">
<![CDATA[
 
     Private Function ParseImportsStatements(ByVal Parent As ParsedObject) As Generic.List(Of ImportsStatement)
         Dim result As New Generic.List(Of ImportsStatement)
         While ImportsStatement.IsMe(tm)
             Dim newI As ImportsStatement
             newI = ParseImportsStatement(Parent)
             result.Add(newI)
         End While
         While ImportsStatement.IsMe(tm)
             Dim newI As ImportsStatement
             newI = ParseImportsStatement(Parent)
             result.Add(newI)
         End While
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2855" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="67" endline="78">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), Identifier.Name)
 
         m_VariableIdentifier = New VariableIdentifier(Me, Identifier)
         m_IsNew = IsNew
         m_TypeName = New TypeName(Me, TypeName)
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2856" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" startline="782" endline="795">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new commandline parser!
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
     Private m_lstResponseFiles As New Specialized.StringCollection
 
     ''' <summary>
     ''' All files specified
     ''' </summary>s
     ''' <remarks></remarks>
     Private m_lstFileNames As CodeFiles
 
     ''' <summary>
     ''' A list of all the arguments parsed.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_lstAllArgs As New Specialized.StringCollection
 
     ''' <summary>
     ''' The compiler used.
     ''' </summary>
     Private m_Compiler As Compiler
 
     ''' <summary>
     ''' The compiler used.
     ''' </summary>
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
 #Region "Properties"
 
     ' - OUTPUT FILE -
 
     ''' <summary>
     ''' /out
     ''' </summary>
     Private m_strOut As String
 
     ''' <summary>
     ''' /target
     ''' /target
     ''' /target
     ''' /target
     ''' </summary>
     Private m_strTarget As Targets
 
     ''' <summary>
     ''' /doc[+|-]               Generates XML documentation file.
     ''' /doc
     ''' </summary>
     ''' <remarks></remarks>
     Private m_strDoc As String
 
     ' - INPUT FILES -
 
     ''' <summary>
     ''' /addmodule
     ''' </summary>
     Private m_lstModules As New Specialized.StringCollection
 
     ''' <summary>
     ''' /recurse
     ''' </summary>
     Private m_lstRecurse As New Specialized.StringCollection
 
     ''' <summary>
     ''' /reference
     ''' </summary>
     Private m_lstReferences As New Specialized.StringCollection
 
     ' - RESOURCES -
 
     ''' <summary>
     ''' /linkresource
     ''' </summary>	
     Private m_lstLinkResources As Resources
 
     ''' <summary>
     ''' /resource
     ''' </summary>
     Private m_lstResources As Resources
 
     ''' <summary>
     ''' /win32icon
     ''' </summary>
     Private m_strWin32Icon As String
 
     ''' <summary>
     ''' /win32resource
     ''' </summary>
     Private m_strWin32Resource As String
 
     ' - CODE GENERATION -
 
     ''' <summary>
     ''' /optimize[+|-]          Enable optimizations.
     ''' </summary>
     Private m_bOptimize As Boolean
 
     ''' <summary>
     ''' /removeintchecks[+|-]   Remove integer checks. Default off.
     ''' </summary>
     Private m_bRemoveIntChecks As Boolean
 
     ''' <summary>
     ''' /debug[+|-]             Emit debugging information.
     '''/debug
     '''/debug
     ''' According to #81054 vbc doesn't emit debug info unless /debug is specified.
     ''' </summary>
     Private m_eDebugInfo As DebugTypes = DebugTypes.None
 
     ' - ERRORS AND WARNINGS -
 
     ''' <summary>
     ''' /nowarn                 Disable warnings.
     ''' </summary>
     Private m_bNoWarn As Boolean
 
     ''' <summary>
     ''' /warnaserror[+|-]       Treat warnings as errors.
     ''' </summary>
     Private m_bWarnAsError As Boolean
 
     ' - LANGUAGE -
 
     ''' <summary>
     ''' /define
     ''' </summary>
     Private m_lstDefine As New Defines
 
     ''' <summary>
     ''' /imports
     ''' </summary>
     Private m_lstImports As ImportsStatement
 
     ''' <summary>
     ''' /optionexplicit[+|-]    Require explicit declaration of variables.
     ''' </summary>
     Private m_eOptionExplicit As OptionExplicitTypes = OptionExplicitTypes.On
 
     ''' <summary>
     ''' /optionstrict[+|-]      Enforce strict language semantics.
     ''' </summary>
     Private m_eOptionStrict As OptionStrictTypes = OptionStrictTypes.Off
 
     ''' <summary>
     ''' /optioninfer[+|-]       Allow type inference of variables.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_eOptionInfer As OptionInferTypes = OptionInferTypes.Off
 
     ''' <summary>
     ''' /rootnamespace
     ''' </summary>
     Private m_strRootNamespace As String
 
     ''' <summary>
     '''/optioncompare
     '''/optioncompare
     ''' </summary>
     Private m_eOptionCompare As OptionCompareTypes = OptionCompareTypes.Binary
 
     ' - MISCELLANEOUS -
 
     ''' <summary>
     ''' /help                   Display this usage message. (Short form
     ''' </summary>
     Private m_bHelp As Boolean
 
     ''' <summary>
     ''' /nologo                 Do not display compiler copyright banner.
     ''' </summary>
     Private m_bNoLogo As Boolean
 
     ''' <summary>
     ''' /quiet                  Quiet output mode. 
     ''' </summary>
     Private m_bQuiet As Boolean
 
     ''' <summary>
     ''' /verbose                Display verbose messages.
     ''' </summary>
     Private m_bVerbose As Boolean
 
     ''' <summary>
     ''' /noconfig               Disable the automatic inclusion of the vbnc.rsp response file.
     ''' </summary>
     Private m_bNoConfig As Boolean
 
     ''' <summary>
     ''' /trace                  Output trace messages (vbnc extension)
     ''' </summary>
     ''' <remarks></remarks>
     Private m_bTrace As Boolean
 
     ' - ADVANCED -
 
     ''' <summary>
     ''' /baseaddress
     ''' </summary>
     Private m_strBaseAddress As String
 
     ''' <summary>
     ''' /bugreport
     ''' </summary>
     Private m_strBugReport As String
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     Private m_Encoding As System.Text.Encoding
 
     ''' <summary>
     ''' /delaysign[+|-]         Delay-sign the assembly using only the public portion of the strong name key.
     ''' </summary>
     Private m_bDelaySign As Boolean
 
     ''' <summary>
     ''' /keycontainer
     ''' </summary>
     Private m_strKeyContainer As String
 
     ''' <summary>
     ''' /keyfile
     ''' </summary>
     Private m_strKeyFile As String
 
     ''' <summary>
     ''' /libpath
     ''' </summary>
     Private m_lstLibPath As New Specialized.StringCollection
 
     ''' <summary>
     ''' /main
     ''' </summary>
     Private m_strMain As String
 
     ''' <summary>
     ''' /netcf                  Target the .NET Compact Framework.
     ''' </summary>
     Private m_bNetCF As Boolean
 
     ''' <summary>
     ''' /sdkpath
     ''' </summary>
     Private m_strSDKPath As String
 
     ''' <summary>
     ''' /utf8output[+|-]        Emit compiler output in UTF8 character encoding.
     ''' </summary>
     Private m_bUTF8Output As Boolean
 
     Private m_VBRuntime As String = "Microsoft.VisualBasic.dll"
 
     ''' <summary>
     ''' /vbversion
     ''' </summary>
     ''' <remarks></remarks>
     Private m_VBVersion As VBVersions = VBVersions.V8
     ' - OUTPUT FILE -
 
 
     ReadOnly Property VBVersion() As VBVersions
         Get
             Return m_VBVersion
         End Get
     End Property
 
     ''' <summary>
     ''' /out
     ''' </summary>
     ReadOnly Property Out() As String
         Get
             Return m_strOut
         End Get
     End Property
 
     ''' <summary>
     ''' /target
     ''' /target
     ''' /target
     ''' /target
     ''' </summary>
     ReadOnly Property Target() As Targets
         Get
             Return m_strTarget
         End Get
     End Property
 
     ' - INPUT FILES - 
 
     ''' <summary>
     ''' /addmodule
     ''' </summary>
     ReadOnly Property Modules() As Specialized.StringCollection
         Get
             Return m_lstModules
         End Get
     End Property
 
     ''' <summary>
     ''' /recurse
     ''' </summary>
     ReadOnly Property Recurse() As Specialized.StringCollection
         Get
             Return m_lstRecurse
         End Get
     End Property
 
     ''' <summary>
     ''' /reference
     ''' </summary>
     ReadOnly Property References() As Specialized.StringCollection
         Get
             Return m_lstReferences
         End Get
     End Property
 
     ' - RESOURCES -
 
     ''' <summary>
     ''' /linkresource
     ''' </summary>	
     ReadOnly Property LinkResources() As Resources
         Get
             Return m_lstLinkResources
         End Get
     End Property
 
     ''' <summary>
     ''' /resource
     ''' </summary>
     ReadOnly Property Resources() As Resources
         Get
             Return m_lstResources
         End Get
     End Property
 
     ''' <summary>
     ''' /win32icon
     ''' </summary>
     ReadOnly Property Win32Icon() As String
         Get
             Return m_strWin32Icon
         End Get
     End Property
 
     ''' <summary>
     ''' /win32resource
     ''' </summary>
     ReadOnly Property Win32Resource() As String
         Get
             Return m_strWin32Resource
         End Get
     End Property
 
     ' - CODE GENERATION -
 
     ''' <summary>
     ''' /optimize[+|-]          Enable optimizations.
     ''' </summary>
     ReadOnly Property Optimize() As Boolean
         Get
             Return m_bOptimize
         End Get
     End Property
 
     ''' <summary>
     ''' /removeintchecks[+|-]   Remove integer checks. Default off.
     ''' </summary>
     ReadOnly Property RemoveIntChecks() As Boolean
         Get
             Return m_bRemoveIntChecks
         End Get
     End Property
 
     ''' <summary>
     '''/debug
     '''/debug
     ''' </summary>
     ReadOnly Property DebugInfo() As DebugTypes
         Get
             Return m_eDebugInfo
         End Get
     End Property
 
     ' - ERRORS AND WARNINGS -
 
     ''' <summary>
     ''' /nowarn                 Disable warnings.
     ''' </summary>
     ReadOnly Property NoWarn() As Boolean
         Get
             Return m_bNoLogo
         End Get
     End Property
 
     ''' <summary>
     ''' /warnaserror[+|-]       Treat warnings as errors.
     ''' </summary>
     ReadOnly Property WarnAsError() As Boolean
         Get
             Return m_bWarnAsError
         End Get
     End Property
 
     ' - LANGUAGE -
 
     ''' <summary>
     ''' /define
     ''' </summary>
     ReadOnly Property Define() As Defines
         Get
             Return m_lstDefine
         End Get
     End Property
 
     ''' <summary>
     ''' /imports
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsStatement
         Get
             Return m_lstImports
         End Get
     End Property
 
     ''' <summary>
     ''' /optionexplicit[+|-]    Require explicit declaration of variables.
     ''' </summary>
     ReadOnly Property OptionExplicit() As OptionExplicitTypes
         Get
             Return m_eOptionExplicit
         End Get
     End Property
 
     ''' <summary>
     ''' /optionstrict[+|-]      Enforce strict language semantics.
     ''' </summary>
     ReadOnly Property OptionStrict() As OptionStrictTypes
         Get
             Return m_eOptionStrict
         End Get
     End Property
 
     ''' <summary>
     ''' /rootnamespace
     ''' </summary>
     ReadOnly Property RootNamespace() As String
         Get
             Return m_strRootNamespace
         End Get
     End Property
 
     ''' <summary>
     '''/optioncompare
     '''/optioncompare
     ''' </summary>
     ReadOnly Property OptionCompare() As OptionCompareTypes
         Get
             Return m_eOptionCompare
         End Get
     End Property
 
     ''' <summary>
     ''' /optioninfer[+|-]       Allow type inference of variables.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property OptionInfer As OptionInferTypes
         Get
             Return m_eOptionInfer
         End Get
     End Property
 
     ' - MISCELLANEOUS -
 
     ''' <summary>
     ''' /help                   Display this usage message. (Short form
     ''' </summary>
     ReadOnly Property Help() As Boolean
         Get
             Return m_bHelp
         End Get
     End Property
 
     ''' <summary>
     ''' /nologo                 Do not display compiler copyright banner.
     ''' </summary>
     ReadOnly Property NoLogo() As Boolean
         Get
             Return m_bNoLogo
         End Get
     End Property
 
     ''' <summary>
     ''' /quiet                  Quiet output mode. 
     ''' </summary>
     ReadOnly Property Quiet() As Boolean
         Get
             Return m_bQuiet
         End Get
     End Property
 
     ''' <summary>
     ''' /verbose                Display verbose messages.
     ''' </summary>
     ReadOnly Property Verbose() As Boolean
         Get
             Return m_bVerbose
         End Get
     End Property
 
     ''' <summary>
     ''' /noconfig               Disable the automatic inclusion of the vbnc.rsp response file.
     ''' </summary>
     ReadOnly Property NoConfig() As Boolean
         Get
             Return m_bNoConfig
         End Get
     End Property
 
     ''' <summary>
     ''' /trace                  Output trace messages (vbnc extension)
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Trace As Boolean
         Get
             Return m_bTrace
         End Get
     End Property
 
     ReadOnly Property VBRuntime() As String
         Get
             Return m_VBRuntime
         End Get
     End Property
 
     ' - ADVANCED -
 
     ''' <summary>
     ''' /baseaddress
     ''' </summary>
     ReadOnly Property BaseAddress() As String
         Get
             Return m_strBaseAddress
         End Get
     End Property
 
     ''' <summary>
     ''' /bugreport
     ''' </summary>
     ReadOnly Property BugReport() As String
         Get
             Return m_strBugReport
         End Get
     End Property
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     ReadOnly Property Encoding() As System.Text.Encoding
         Get
             If m_Encoding Is Nothing Then m_Encoding = System.Text.Encoding.Default
             Return m_Encoding
         End Get
     End Property
 
     ''' <summary>
     ''' /delaysign[+|-]         Delay-sign the assembly using only the public portion of the strong name key.
     ''' </summary>
     ReadOnly Property DelaySign() As Boolean
         Get
             Return m_bDelaySign
         End Get
     End Property
 
     ''' <summary>
     ''' /keycontainer
     ''' </summary>
     ReadOnly Property KeyContainer() As String
         Get
             Return m_strKeyContainer
         End Get
     End Property
 
     ''' <summary>
     ''' /keyfile
     ''' </summary>
     ReadOnly Property KeyFile() As String
         Get
             Return m_strKeyFile
         End Get
     End Property
 
     ''' <summary>
     ''' /libpath
     ''' </summary>
     ReadOnly Property LibPath() As Specialized.StringCollection
         Get
             Return m_lstLibPath
         End Get
     End Property
 
     ''' <summary>
     ''' /main
     ''' </summary>
     ReadOnly Property Main() As String
         Get
             Return m_strMain
         End Get
     End Property
 
     ''' <summary>
     ''' /netcf                  Target the .NET Compact Framework.
     ''' </summary>
     ReadOnly Property NetCF() As Boolean
         Get
             Return m_bNetCF
         End Get
     End Property
 
     ''' <summary>
     ''' /sdkpath
     ''' </summary>
     ReadOnly Property SDKPath() As String
         Get
             Return m_strSDKPath
         End Get
     End Property
 
     ''' <summary>
     ''' /utf8output[+|-]        Emit compiler output in UTF8 character encoding.
     ''' </summary>
     ReadOnly Property UTF8Output() As Boolean
         Get
             Return m_bUTF8Output
         End Get
     End Property
 
     ''' <summary>
     ''' A list of all the response files specified on the command line.
     ''' </summary>
     ReadOnly Property ResponseFiles() As Specialized.StringCollection
         Get
             Return m_lstResponseFiles
         End Get
     End Property
 
 #End Region
 
     ReadOnly Property AllArgumentsAsArray() As String()
         Get
             Dim result(m_lstAllArgs.Count - 1) As String
             m_lstAllArgs.CopyTo(result, 0)
             Return result
         End Get
     End Property
 
     ''' <summary>
     ''' This property returns the files the commandline parser found on the commandline,
     ''' this includes expanded wildcards.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Files() As CodeFiles
         Get
             Return m_lstFileNames
         End Get
     End Property
 
     ''' <summary>
     ''' Create a new commandline parser!
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         m_lstImports = New ImportsStatement(Compiler)
         m_lstImports.Init(New ImportsClauses(m_lstImports))
         m_lstFileNames = New CodeFiles(m_Compiler)
         m_lstResources = New Resources(m_Compiler, False)
         m_lstLinkResources = New Resources(m_Compiler, True)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2857" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="283" endline="290">
<![CDATA[
 
     Protected Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent)
         m_LeftExpression = LExp
         m_LeftExpression.Parent = Me
         m_RightExpression = RExp
         m_RightExpression.Parent = Me
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2858" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="259" endline="269">
<![CDATA[
 
     ''' <summary>
     ''' Eats the current tokens if if coincides, if not shows a 
     ''' message "Expected
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special1 As KS, ByVal Special2 As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         Return AcceptIfNotError(Special1, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special1)) AndAlso AcceptIfNotError(Special2, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special2))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2859" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1071" endline="1082">
<![CDATA[
     ''' <summary>
     ''' Creates a new array and the new array reference is loaded at the top of the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <param name="Elements"></param>
     ''' <remarks></remarks>
     Shared Sub CreateArray(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference, ByVal Elements As Integer)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         EmitLoadValue(Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32), Elements)
         EmitNewArr(Info, ElementType)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2860" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="117" endline="135">
<![CDATA[
     End Property
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             If m_ResolvedProperty IsNot Nothing Then
                 Return m_ResolvedProperty.PropertyType
             ElseIf m_Members IsNot Nothing Then
                 If m_Members.Count = 1 Then
                     m_ResolvedProperty = m_Members(0)
                     Return m_Members(0).PropertyType
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                 End If
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
             Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Return Nothing
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2861" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="58" endline="65">
<![CDATA[
 
     Shadows Sub Init(ByVal Variable As Identifier, ByVal TypeName As NonArrayTypeName, ByVal [When] As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_Variable = Variable
         m_TypeName = TypeName
         m_When = [When]
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2862" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="37" endline="45">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal Identifier As Identifier, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal ParameterList As ParameterList)
         MyBase.Init(Modifiers, New SubSignature(Me, Identifier.Name, ParameterList), Nothing)
         Modifiers = Modifiers.AddModifier(KS.Shared)
         m_CharsetModifier = CharsetModifier
         m_Identifier = Identifier
         m_LibraryClause = LibraryClause
         m_AliasClause = AliasClause
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2863" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="44" endline="52">
<![CDATA[
 
     ReadOnly Property Constants() As Generic.List(Of EnumMemberDeclaration)
         Get
             If m_Constants Is Nothing Then
                 m_Constants = Members.GetSpecificMembers(Of EnumMemberDeclaration)()
                 Helper.Assert(m_Constants.Count = Members.Count)
             End If
             Return m_Constants
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2864" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="49" endline="58">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal ImplementsClause As MemberImplementsClause)
         MyBase.Init(Modifiers, Identifier.Name)
 
         m_Identifier = Identifier
         m_ImplementsClause = ImplementsClause
 
         Helper.Assert(m_Identifier IsNot Nothing)
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2865" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="76" endline="88">
<![CDATA[
 
     Shared Function CreateTypeConstructor(ByVal Parent As TypeDeclaration) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
 
         result.Init(New Modifiers(ModifierMasks.Shared), New SubSignature(result, SharedConstructorName, New ParameterList(result)), New CodeBlock(result))
 
         result.UpdateDefinition()
         If result.ResolveTypeReferences() = False Then
             Helper.ErrorRecoveryNotImplemented(Parent.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2866" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="294" endline="312">
<![CDATA[
 
     Private Function EmitConstantInitialization(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim parent As TypeDeclaration
 
         Parent = Me.DeclaringType
 
         For Each variable As ConstantDeclaration In Parent.Members.GetSpecificMembers(Of ConstantDeclaration)()
             If Helper.CompareType(variable.FieldType, Compiler.TypeCache.System_DateTime) Then
                 Emitter.EmitLoadDateValue(Info, DirectCast(variable.ConstantValue, Date))
                 Emitter.EmitStoreField(Info, variable.FieldBuilder)
             ElseIf Helper.CompareType(variable.FieldType, Compiler.TypeCache.System_Decimal) Then
                 Emitter.EmitLoadDecimalValue(Info, DirectCast(variable.ConstantValue, Decimal))
                 Emitter.EmitStoreField(Info, variable.FieldBuilder)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2867" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="114" endline="126">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier)
         MyBase.New(Parent)
     Private m_Members As New MemberDeclarations(Me)
     Private m_Namespace As String
     Private m_Name As Identifier
 
     Private m_DefaultInstanceConstructor As ConstructorDeclaration
     Private m_DefaultSharedConstructor As ConstructorDeclaration
     Private m_StaticVariables As Generic.List(Of LocalVariableDeclaration)
     Private m_BeforeFieldInit As Boolean
     Private m_Serializable As Boolean
     Private m_AddedCompareTextAttribute As Boolean
 
     'Information collected during define phase.
     Private m_CecilType As Mono.Cecil.TypeDefinition
 
     Private m_FullName As String
 
     Private m_AddHandlers As New Generic.List(Of AddOrRemoveHandlerStatement)
     Private m_MyGroupField As TypeVariableDeclaration
 
     Property MyGroupField() As TypeVariableDeclaration
         Get
             Return m_MyGroupField
         End Get
         Set(ByVal value As TypeVariableDeclaration)
             m_MyGroupField = value
         End Set
     End Property
 
     Property Serializable() As Boolean
         Get
             Return m_Serializable
         End Get
         Set(ByVal value As Boolean)
             If m_CecilType IsNot Nothing Then m_CecilType.IsSerializable = value
             m_Serializable = value
         End Set
     End Property
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For Each member As MemberDeclaration In m_Members
             member.Initialize(Me)
         Next
     End Sub
 
     ReadOnly Property DescriptiveType() As String
         Get
             If TypeOf Me Is ClassDeclaration Then
                 Return "class"
             ElseIf TypeOf Me Is ModuleDeclaration Then
                 Return "module"
             ElseIf TypeOf Me Is EnumDeclaration Then
                 Return "enum"
             ElseIf TypeOf Me Is StructureDeclaration Then
                 Return "structure"
             ElseIf TypeOf Me Is DelegateDeclaration Then
                 Return "delegate"
             ElseIf TypeOf Me Is InterfaceDeclaration Then
                 Return "interface"
             Else
                 Return "type"
             End If
         End Get
     End Property
 
     ReadOnly Property AddHandlers() As Generic.List(Of AddOrRemoveHandlerStatement)
         Get
             Return m_AddHandlers
         End Get
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier)
         MyBase.New(Parent)
 
         m_Namespace = [Namespace]
         m_Name = Name
         MyBase.Name = Name.Name
 
         Helper.Assert(m_Namespace IsNot Nothing)
         Helper.Assert(m_Name IsNot Nothing)
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2868" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="180" endline="209">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The complete name for this qualified identifier.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Name() As String
         Get
             If m_Name Is Nothing Then
                 m_Name = String.Empty
                 If m_First IsNot Nothing Then
                     Dim id As Identifier = TryCast(m_First, Identifier)
                     Dim qid As QualifiedIdentifier = TryCast(m_First, QualifiedIdentifier)
                     If id IsNot Nothing Then
                         m_Name = id.Name
                     ElseIf qid IsNot Nothing Then
                         m_Name = qid.Name
                     Else
                         m_Name = m_First.ToString
                     End If
                 Else
                     Throw New InternalException(Me)
                 End If
                 If Token.IsSomething(m_Second) Then
                     m_Name = m_Name & "." & m_Second.ToString
                 End If
             End If
             Return m_Name
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2869" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BuiltInTypeExpression.vb" startline="41" endline="47">
<![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
 
             'Return New TypeDescriptor(TypeResolution.BuiltInTypeToType(m_Type))
             Return Compiler.TypeResolution.BuiltInTypeToType(m_Type)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2870" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="51" endline="61">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifier(ByVal Modifier As KS) As Modifiers
         m_ModifierMask = m_ModifierMask Or KSToMask(Modifier)
         Return Me
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2871" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="97" endline="105">
<![CDATA[
     End Property
 
     ReadOnly Property AttributeArguments() As AttributeArguments
         Get
             If m_AttributeArguments Is Nothing Then
                 m_AttributeArguments = New AttributeArguments(Me)
             End If
             Return m_AttributeArguments
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2872" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="62" endline="71">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As ParameterList)
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = Parameters
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2873" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="68" endline="76">
<![CDATA[
     End Property
 
     ReadOnly Property VariablePropertyInitializerList() As VariablePropertyInitializerList
         Get
             If m_VariablePropertyInitializerList Is Nothing Then
                 m_VariablePropertyInitializerList = New VariablePropertyInitializerList(Me)
             End If
             Return m_VariablePropertyInitializerList
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2875" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1354" endline="1362">
<![CDATA[
 
     Shared Sub EmitLoadValueConstantOrValueAddress(ByVal Info As EmitInfo, ByVal Value As Object)
         Helper.Assert(Info.DesiredType IsNot Nothing, "EmitInfo.DesiredType must be set!")
         If CecilHelper.IsByRef(Info.DesiredType) Then
             EmitLoadValueAddress(Info, Value)
         Else
             EmitLoadValue(Info, Value)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2876" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="44" endline="50">
<![CDATA[
 
     Sub Init(ByVal LSide As Expression, ByVal RSide As Expression)
         m_LSide = LSide
         m_RSide = RSide
         m_LSide.Parent = Me
         m_RSide.Parent = Me
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2877" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="51" endline="57">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
         If Arguments IsNot Nothing Then
             m_Arguments.AddRange(Arguments)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2878" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="496" endline="502">
<![CDATA[
 
     Function IsSignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_SByte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int64)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2879" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="84" endline="96">
<![CDATA[
     End Property
 
     Sub Init(ByVal Attributes As Attributes, ByVal Modifiers As Modifiers, ByVal ParameterIdentifier As ParameterIdentifier, ByVal TypeName As TypeName, ByVal ConstantExpression As Expression)
         m_CustomAttributes = Attributes
         m_Modifiers = Modifiers
         m_ParameterIdentifier = ParameterIdentifier
         m_TypeName = TypeName
         m_ConstantExpression = ConstantExpression
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
 
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2880" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="95" endline="106">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.IsRHS)
 
         Emitter.EmitLoadVariable(Info, m_Local)
         Emitter.EmitLoadI4Value(Info, m_Index)
         Emitter.EmitLoadElement(Info, m_Local.VariableType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2881" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="503" endline="509">
<![CDATA[
 
     Function IsUnsignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_Byte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt64)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2882" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="52" endline="60">
<![CDATA[
 
     Sub Init(ByVal First As Expression, ByVal Second As IdentifierOrKeyword)
         m_First = First
         m_Second = Second
 
         m_Expression = New MemberAccessExpression(Me)
         m_Expression.Init(m_First, m_Second)
 
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2883" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1494" endline="1504">
<![CDATA[
 
     ''' <summary>
     ''' Load a constant date value on the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadDateValue(ByVal Info As EmitInfo, ByVal DateValue As Date)
         Dim emitLong As EmitInfo = Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Int64)
         EmitLoadI8Value(emitLong, DateValue.Ticks)
         Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_DateTime__ctor_Int64))
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2884" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="97" endline="108">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParameterList = Nothing) As Parameter
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParameterList)
         Dim result As New Parameter(NewParent)
         result.m_CustomAttributes = m_CustomAttributes
         result.m_Modifiers = m_Modifiers
         result.m_ParameterIdentifier = m_ParameterIdentifier.Clone(result)
         If m_TypeName IsNot Nothing Then result.m_TypeName = m_TypeName.Clone(result)
         If m_ConstantExpression IsNot Nothing Then result.m_ConstantExpression = m_ConstantExpression.Clone(result)
         result.UpdateDefinition()
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2885" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="162" endline="171">
<![CDATA[
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2886" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="43" endline="68">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         Dim expType As Mono.Cecil.TypeReference = Expression.ExpressionType
         Dim expTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Select Case expTypeCode
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2887" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="296" endline="302">
<![CDATA[
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2888" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="394" endline="406">
<![CDATA[
 
     ''' <summary>
     ''' A variable declaration which refers to the implicitly declared local variable
     ''' for methods with return values (functions and get properties)
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="method"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal method As IMethod)
         MyBase.New(Classifications.Variable, Parent)
         Helper.Assert(TypeOf method Is FunctionDeclaration OrElse TypeOf method Is PropertyGetDeclaration)
         m_Method = method
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2889" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClauses.vb" startline="27" endline="39">
<![CDATA[
     Function GetNamespaces(ByVal FromWhere As BaseObject, ByVal Name As String) As Generic.List(Of [Namespace])
         Dim result As New Generic.List(Of [Namespace])
         For Each imp As ImportsClause In Me
             If imp.IsNamespaceClause AndAlso imp.AsNamespaceClause.IsNamespaceImport Then
                 Dim ns As [Namespace]
                 ns = FromWhere.Compiler.TypeManager.Namespaces.Item(imp.AsNamespaceClause.NamespaceImported, Name)
                 If ns IsNot Nothing Then
                     result.Add(ns)
                 End If
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2890" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="282" endline="295">
<![CDATA[
 
     Private Function CreateImplicitMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = CreateImplicitMembers(NestedType) AndAlso result
         Next
 
         For Each Member As IHasImplicitMembers In Type.Members.GetSpecificMembers(Of IHasImplicitMembers)()
             result = Member.CreateImplicitMembers() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2891" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="130" endline="139">
<![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal LoopStartExpression As Expression, ByVal LoopEndExpression As Expression, ByVal LoopStepExpression As Expression, ByVal NextExpressionList As ExpressionList, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_LoopStartExpression = LoopStartExpression
         m_LoopEndExpression = LoopEndExpression
         m_LoopStepExpression = LoopStepExpression
         m_NextExpressionList = NextExpressionList
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2892" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="436" endline="449">
<![CDATA[
 
     ''' <summary>
     ''' Creates a variable classification for an array access.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Arguments"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal ArrayVariableExpression As Expression, ByVal Arguments As ArgumentList)
         MyBase.New(Classifications.Variable, Parent)
         m_ArrayVariable = ArrayVariableExpression
         m_Arguments = Arguments
         Helper.Assert(ArrayVariable IsNot Nothing)
         Helper.Assert(Arguments IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2893" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="61" endline="72">
<![CDATA[
 
     ''' <summary>
     ''' Returns nothing if it is not a handles clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property HandlesClause() As HandlesClause
         Get
             Helper.Assert(m_Clause IsNot Nothing)
             Return TryCast(m_Clause, HandlesClause)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2894" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="73" endline="85">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if it is not an implements clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ImplementsClause() As MemberImplementsClause
         Get
             helper.Assert(m_clause IsNot Nothing)
             Return TryCast(m_Clause, MemberImplementsClause)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2895" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="89" endline="95">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return m_LeftExpression.IsConstant AndAlso (Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_String) OrElse Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_Char)) _
               AndAlso m_RightExpression.IsConstant AndAlso (Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_String) OrElse Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_Char))
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2896" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="624" endline="630">
<![CDATA[
     End Property
 
     ReadOnly Property ResolvedMember() As Mono.Cecil.MemberReference
         Get
             If m_ResolvedCandidate Is Nothing Then Return Nothing
             Return m_ResolvedCandidate.Member
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2897" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="62" endline="71">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As Parameter = Nothing) As ParameterIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterIdentifier(NewParent)
         result.m_Identifier = m_Identifier
         If m_ArrayNameModifier IsNot Nothing Then
             result.m_ArrayNameModifier = m_ArrayNameModifier.clone(result)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2898" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="78" endline="85">
<![CDATA[
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2899" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="268" endline="284">
<![CDATA[
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2900" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="80" endline="88">
<![CDATA[
     End Property
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         For Each member As MemberDeclaration In m_Members
             member.Initialize(Me)
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2901" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="31" endline="37">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal CodeGenerator As GenerateCodeDelegate, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         m_Delegate = CodeGenerator
         m_ExpressionType = ExpressionType
         MyBase.Classification = New ValueClassification(Me)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2903" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2135" endline="2150">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' If there is only one shared compiler, that one is returned, otherwise nothing is returned.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared ReadOnly Property SharedCompiler() As Compiler
         Get
             If m_SharedCompilers.Count = 1 Then
                 Return m_SharedCompilers(0)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2904" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="357" endline="371">
<![CDATA[
 
     Public Overridable Function DefineTypeHierarchy() As Boolean Implements IDefinableType.DefineTypeHierarchy
         Dim result As Boolean = True
 
         If BaseType Is Nothing Then
             If Me.IsInterface = False Then
                 m_CecilType.BaseType = Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void)
             End If
         End If
         If DeclaringType IsNot Nothing Then
             m_CecilType.DeclaringType = DeclaringType.CecilType
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2905" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="127" endline="134">
<![CDATA[
 
     Shared Sub EmitBranchOrLeave(ByVal Info As EmitInfo, ByVal Label As Label, ByVal FromStatement As Statement, ByVal ToStatement As Statement)
         If IsLeaveNecessary(FromStatement, ToStatement) Then
             EmitLeave(Info, Label)
         Else
             EmitBranch(Info, Label)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2906" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="58" endline="64">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As Mono.Cecil.TypeReference)
         MyBase.Init(Modifiers, Name, VariableType)
         UpdateDefinition()
 
         Helper.Assert(FieldType IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2907" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="467" endline="473">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2913" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NamespaceExpression.vb" startline="33" endline="39">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal ns As [Namespace])
         MyBase.New(Parent)
         If ns Is Nothing Then Throw New InternalException(Me)
         m_NS = ns
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2914" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="111" endline="129">
<![CDATA[
     End Property
 
     Sub FindStaticVariables(ByVal list As Generic.List(Of LocalVariableDeclaration))
         If m_StaticVariables IsNot Nothing Then
             list.AddRange(m_StaticVariables)
             Return
         End If
 
         For Each var As LocalVariableDeclaration In m_Variables
             If var.Modifiers.Is(ModifierMasks.Static) Then
                 list.Add(var)
             End If
         Next
         For Each stmt As BlockStatement In BlockStatements
             stmt.CodeBlock.FindStaticVariables(list)
         Next
 
         m_StaticVariables = list
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2915" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="118" endline="127">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             If Me.IsConstant Then 'Necessary, since the property loads the constant value if it is a constant.
                 Return m_ConstantValue
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2916" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="65" endline="72">
<![CDATA[
         Get
             If m_CilBody Is Nothing Then
                 Helper.Assert(m_Method IsNot Nothing)
                 Helper.Assert(m_Method.CecilBuilder IsNot Nothing)
                 m_CilBody = m_Method.CecilBuilder.Body
             End If
             Return m_CilBody
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2917" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="33" endline="39">
<![CDATA[
 
     Function GetTypes(ByVal [Namespace] As String) As TypeDictionary
         If Me.ContainsKey([Namespace]) = False Then
             Return Me.AddNamespace([Namespace])
         End If
         Return MyBase.Item([Namespace])
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2918" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="72" endline="81">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As Mono.Cecil.TypeReference())
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = New ParameterList(Me, Parameters)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2919" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="73" endline="81">
<![CDATA[
 
     Shadows Sub Init(ByVal Condition As Expression, ByVal FalseCode As CodeBlock, ByVal TrueCode As CodeBlock, ByVal OneLiner As Boolean, ByVal ElseIfs As BaseObjects(Of ElseIfStatement))
         MyBase.Init(TrueCode)
 
         m_Condition = Condition
         m_FalseCode = FalseCode
         m_ElseIfs = ElseIfs
         m_OneLiner = OneLiner
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2920" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="90" endline="107">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lst As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
         lst = Compiler.TypeManager.GetCache(m_ResolvedType).LookupFlattenedMembers(m_2.Name)
         'If lst.Count = 0 AndAlso m_ResolvedType.IsInterface Then
         '    lst.AddRange(Compiler.TypeManager.GetCache(m_ResolvedType).LookupMembersFlattened(m_2.Name))
         'End If
         m_ResolvedMember = MethodGroupClassification.ResolveInterfaceGroup(lst, Me.FindFirstParent(Of IMember))
         If m_ResolvedMember Is Nothing Then
             Helper.AddError(Me, "Implemented method has not the same signature as the interface method")
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2921" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" startline="30" endline="38">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal Field As Mono.Cecil.FieldReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.New(Parent)
 
         m_Field = Field
         m_InstanceExpression = InstanceExpression
         Me.Classification = New ValueClassification(Me, m_Field.FieldType)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2925" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializerList.vb" startline="45" endline="53">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializerList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializerList(NewParent)
         For Each item As VariablePropertyInitializer In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2926" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="253" endline="260">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2927" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="270" endline="277">
<![CDATA[
 
     ''' <summary>
     ''' Shows the multiline message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message() As Messages, ByVal Location As Span, ByVal ParamArray Parameters()() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2928" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="62" endline="70">
<![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             If m_ArgumentsTypesAsString Is Nothing Then
                 m_ArgumentsTypesAsString = "(" & m_Arguments.ArgumentsTypesAsString & ")"
             End If
             Return m_ArgumentsTypesAsString
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2929" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="165" endline="174">
<![CDATA[
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2930" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="699" endline="721">
<![CDATA[
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2931" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="40" endline="46">
<![CDATA[
 
     Function AddNamespace(ByVal [Namespace] As String) As TypeDictionary
         Dim result As New TypeDictionary()
         Helper.Assert(MyBase.ContainsKey([Namespace]) = False)
         MyBase.Add([Namespace], result)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2932" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="175" endline="182">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Constant As ConstantDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Constant IsNot Nothing)
         m_Constant = Constant
         m_Type = Constant.FieldType
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2933" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="480" endline="487">
<![CDATA[
     End Property
 
     ReadOnly Property HasSharedConstantFields() As Boolean
         Get
             Dim ctors As Generic.List(Of ConstantDeclaration)
             ctors = Me.Members.GetSpecificMembers(Of ConstantDeclaration)()
             Return ctors.Count > 0
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2934" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="313" endline="324">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2935" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="79" endline="88">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As BaseObject, ByVal strMsg As String)
         MyBase.new()
         m_Message = "There has been an internal error in the compiler
         If Obj IsNot Nothing Then
             m_Message &= " caused by the line
         End If
 StopOnInternalException()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2936" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespace.vb" startline="45" endline="57">
<![CDATA[
 
     Sub New(ByVal Parent As BaseObject, ByVal Previous As [Namespace], ByVal Name As String)
         MyBase.New(Parent)
         If Previous Is Nothing Then Throw New ArgumentNullException("Namespace")
 
         If TypeOf Previous Is GlobalNamespace Then
             m_Name = Name
             m_Global = True
         Else
             m_Name = Previous.Name & "." & Name
             m_Global = Previous.Global
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2937" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="36" endline="53">
<![CDATA[
 
     ''' <summary>
     ''' Might very well be nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ClassConstraint() As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Nothing
         For Each constraint As Constraint In m_ConstraintList
             If constraint.Special = KS.None Then
                 If CecilHelper.IsClass(constraint.TypeName.ResolvedType) Then
                     Helper.Assert(result Is Nothing)
                     result = constraint.TypeName.ResolvedType
                 End If
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2938" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="305" endline="311">
<![CDATA[
 
     Sub Init()
         InitOptimizations()
         InitAssemblies()
         InitInternal()
         InitVBNCTypes()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2939" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="86" endline="96">
<![CDATA[
 
     Sub Init(ByVal Attributes As Attributes)
         If m_Attributes Is Nothing Then
             m_Attributes = Attributes
         Else
             m_Attributes.AddRange(Attributes)
         End If
         m_TypeDeclarations = m_Members.GetSpecificMembers(Of TypeDeclaration).ToArray
 
         Helper.Assert(m_Members.Count = m_TypeDeclarations.Length)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2940" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="39" endline="46">
<![CDATA[
 
     ReadOnly Property Identifier() As String
         Get
             If m_Identifier IsNot Nothing Then
                 Return m_Identifier
             End If
             Return m_IdentifierOrKeyword.Identifier
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2941" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1549" endline="1558">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     Private m_Peeked As Token
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentTokenType As TokenType
     Private m_CurrentData As Object
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)()
         Dim cf As New CodeFile("<Internal>", "", Compiler, Code)
         m_Files.Enqueue(cf)
         Compiler.CommandLine.Files.Add(cf)
         NextFile()
         LoadProjectConstants()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2942" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="233" endline="251">
<![CDATA[
 
     Private Function GetRegularInitializer(ByVal indices As Generic.List(Of Integer)) As Expression
         Dim ai As ArrayElementInitializer = Me
         Dim result As Expression
 
         Dim index As Integer
         For i As Integer = 0 To indices.Count - 2
             index = indices(i)
             Helper.Assert(ai.m_VariableInitializerList.List.ToArray.Length > index)
             Helper.Assert(ai.m_VariableInitializerList.List.ToArray()(index).IsArrayElementInitializer)
             ai = ai.m_VariableInitializerList.List.ToArray()(index).AsArrayElementInitializer
         Next
         index = indices(indices.Count - 1)
         Helper.Assert(ai.m_VariableInitializerList.List.ToArray.Length > index)
         Helper.Assert(ai.m_VariableInitializerList.List.ToArray()(index).IsRegularInitializer)
         result = ai.m_VariableInitializerList.List.ToArray()(index).AsRegularInitializer
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2943" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="50" endline="65">
<![CDATA[
 
     Sub Init(ByVal [Event] As Expression, ByVal EventHandler As MethodDeclaration, ByVal IsAddHandler As Boolean, ByVal InstanceExpression As Expression)
         Dim result As Boolean = True
         m_Event = [Event]
         m_IsAddHandler = IsAddHandler
 
         Dim o As Object = CType(CecilHelper.FindDefinition(m_Event.Classification.AsEventAccess.EventType), Mono.Cecil.TypeDefinition).Methods(0).Parameters
 
         Dim eventInfo As Mono.Cecil.EventReference = m_Event.Classification.AsEventAccess.EventInfo
         Dim objCreation As New DelegateOrObjectCreationExpression(Me)
         Dim methodPointer As New AddressOfExpression(Me)
         methodPointer.Init(EventHandler, InstanceExpression)
         objCreation.Init(eventInfo.EventType, New ArgumentList(objCreation, methodPointer))
         result = objCreation.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
         m_EventHandler = objCreation
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2944" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" startline="50" endline="60">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As IBaseObject)
         MyBase.new()
         If Obj IsNot Nothing Then
             m_Message = "There has been an internal error in the compiler caused by the line
         Else
             m_Message = "There has been an internal error in the compiler."
         End If
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2945" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="56" endline="66">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2946" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="121" endline="128">
<![CDATA[
         Set(ByVal value As Object)
             If TypeConverter.ConvertTo(Me, value, ParameterType, value) = False Then
                 Throw New NotImplementedException
             End If
             If value Is DBNull.Value Then value = Nothing
             m_ParameterBuilderCecil.Constant = value
             UpdateDefinition()
         End Set
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2948" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="214" endline="234">
<![CDATA[
 
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_AddMethod.CecilBuilder IsNot Nothing)
         Helper.Assert(m_RemoveMethod.CecilBuilder IsNot Nothing)
 
         'm_Builder.SetAddOnMethod(m_AddMethod.MethodBuilder)
         'm_Builder.SetRemoveOnMethod(m_RemoveMethod.MethodBuilder)
         'If m_RaiseMethod IsNot Nothing Then m_Builder.SetRaiseMethod(m_RaiseMethod.MethodBuilder)
 
         result = DefineOverrides() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         m_CecilBuilder.AddMethod = m_AddMethod.CecilBuilder
         m_CecilBuilder.RemoveMethod = m_RemoveMethod.CecilBuilder
         If m_RaiseMethod IsNot Nothing Then m_CecilBuilder.InvokeMethod = m_RaiseMethod.CecilBuilder
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2949" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1340" endline="1353">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadValueAddress(ByVal Info As EmitInfo, ByVal Value As Object)
         Helper.Assert(CecilHelper.IsByRef(Info.DesiredType))
         EmitLoadValue(Info.Clone(Info.Context, CecilHelper.GetElementType(Info.DesiredType)), Value)
         Dim local As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Info.Compiler, CecilHelper.GetElementType(Info.DesiredType)))
         EmitStoreVariable(Info, local)
         EmitLoadVariableLocation(Info, local)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2952" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="45" endline="55">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2953" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1542" endline="1548">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     Private m_Peeked As Token
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentTokenType As TokenType
     Private m_CurrentData As Object
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2954" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="92" endline="101">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList)
         m_Identifier = Identifier
         m_TypeParameters = TypeParameters
         If ParameterList Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = ParameterList
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2955" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="157" endline="168">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The default implementation throws an internal exception.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Overridable ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(m_Classification IsNot Nothing)
             Return m_Classification.ConstantValue
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2956" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3109" endline="3121">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Type()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         For Each t As Type In Types
             Helper.Assert(t IsNot Nothing)
             result &= sep & t.ToString
             sep = ", "
         Next
 
         Return "{" & result & "}"
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2958" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="26" endline="33">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2959" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="242" endline="254">
<![CDATA[
 
     ''' <summary>
     ''' Create a new EmitInfo copying the values from the specified info.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Private Sub New(ByVal Info As EmitInfo)
         Me.m_DesiredType = Info.m_DesiredType
         Me.m_IsExplicitConversion = Info.m_IsExplicitConversion
         Me.m_IsRHS = Info.m_IsRHS
         Me.m_Method = Info.m_Method
         Me.m_RHSExpression = Info.m_RHSExpression
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2960" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="80" endline="87">
<![CDATA[
 
     Function GetCache(ByVal Type As Mono.Cecil.TypeReference) As MemberCache
         If MemberCache.ContainsKey(Type) Then
             Return MemberCache(Type)
         Else
             Return New MemberCache(Compiler, Type)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2961" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1218" endline="1227">
<![CDATA[
 
     Public Shared Function GetField(ByVal collection As ICollection, ByVal reference As FieldReference) As FieldDefinition
         For Each field As FieldDefinition In collection
             If Not Helper.CompareNameOrdinal(field.Name, reference.Name) Then
                 Continue For
             End If
             Return field
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2962" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1283" endline="1292">
<![CDATA[
 
     Public Shared Function GetEvent(ByVal collection As ICollection, ByVal reference As EventReference) As EventDefinition
         For Each meth As EventDefinition In collection
             If Helper.CompareNameOrdinal(meth.Name, reference.Name) = False Then
                 Continue For
             End If
             Return meth
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2964" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="111" endline="129">
<![CDATA[
 
 
     ''' <summary>
     ''' Creates an array of the specified type and number of elements (and ranks)
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="arraytype"></param>
     ''' <param name="Elements"></param>
     ''' <remarks></remarks>
     Public Shared Sub EmitArrayCreation(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal Elements As Generic.List(Of Integer))
         If Elements.Count = 0 Then
             Emitter.EmitLoadI4Value(Info, 0)
         Else
             For i As Integer = 0 To Elements.Count - 1
                 Emitter.EmitLoadI4Value(Info, Elements(i))
             Next
         End If
         EmitArrayConstructor(Info, ArrayType, Elements.Count)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2967" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="84" endline="90">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal EventInfo As Mono.Cecil.EventReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.new(Classifications.EventAccess, Parent)
         m_EventInfo = EventInfo
         m_InstanceExpression = InstanceExpression
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2968" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="147" endline="153">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As AddressOfExpression, ByVal MethodGroup As MethodGroupClassification)
         MyBase.new(Classifications.MethodPointer, Parent)
         Helper.Assert(MethodGroup IsNot Nothing)
         m_MethodGroup = MethodGroup
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2969" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="81" endline="90">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal ArgumentList As ArgumentList, ByVal VariableInitializer As VariableInitializer, ByVal IsVariableDeclaration As Boolean, ByVal VariableDeclaration As LocalVariableDeclaration)
         m_Identifier = Identifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_ArgumentList = ArgumentList
         m_VariableInitializer = VariableInitializer
         m_IsVariableDeclaration = IsVariableDeclaration
         m_VariableDeclaration = VariableDeclaration
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2970" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MeExpression.vb" startline="36" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Emitter.EmitLoadMe(Info, Me.FindFirstParent(Of IType).CecilType)
         If CecilHelper.IsValueType(Info.DesiredType) AndAlso CecilHelper.IsByRef(Info.DesiredType) = False Then
             Emitter.EmitLoadObject(Info, Info.DesiredType)
         End If
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2971" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" startline="83" endline="94">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new define with the specified values.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Symbol As String, ByVal Value As String)
         Me.m_Symbol = Symbol
         Me.m_Value = Value
         Me.m_Compiler = Compiler
 
         Parse()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2972" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Infos\ResolveInfo.vb" startline="39" endline="45">
<![CDATA[
 
     Sub New(ByVal Compiler As Compiler, Optional ByVal SkipFunctionReturnVariable As Boolean = False, Optional ByVal CanFail As Boolean = False, Optional ByVal CanBeImplicitSimpleName As Boolean = True)
     Private m_Bits As New Collections.BitArray(32)
     Private Const c_SkipFunctionReturnVariable As Integer = 0
     Private Const c_CanFail As Integer = 1
     Private Const c_CanBeLateCall As Integer = 2
     Private Const c_CanBeImplicitSimpleName As Integer = 3
     Private Const c_EventResolution As Integer = 4
 
     Public Compiler As Compiler
 
     Private Shared DefaultInfo As ResolveInfo
 
     Shared Function [Default](ByVal Compiler As Compiler) As ResolveInfo
         If DefaultInfo Is Nothing OrElse Compiler Is DefaultInfo.Compiler = False Then
             DefaultInfo = New ResolveInfo(Compiler)
         End If
 
         Return DefaultInfo
     End Function
 
     Sub New(ByVal Compiler As Compiler, Optional ByVal SkipFunctionReturnVariable As Boolean = False, Optional ByVal CanFail As Boolean = False, Optional ByVal CanBeImplicitSimpleName As Boolean = True)
         Me.SkipFunctionReturnVariable = SkipFunctionReturnVariable
         Me.CanFail = CanFail
         Me.CanBeImplicitSimpleName = CanBeImplicitSimpleName
         Me.Compiler = Compiler
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2973" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2151" endline="2158">
<![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         If m_SharedCompilers.Contains(Compiler) = False Then
             m_SharedCompilers.Add(Compiler)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2974" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="81" endline="94">
<![CDATA[
 End Class
 
 Public Class LoadElementExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     Private m_Index As Integer
 
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition, ByVal Index As Integer)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
         m_Index = Index
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2975" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="123" endline="129">
<![CDATA[
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
     Private m_FoundObjects As New Generic.List(Of Object)
 
     Private Name As ParsedObject
     Private FromWhere As BaseObject
     Private m_IsImportsResolution As Boolean
     Private m_Qualifier As TypeNameResolutionInfo
     Private m_TypeArgumentCount As Integer
     Private m_IsAttributeTypeName As Boolean
 
 
     Property IsAttributeTypeName() As Boolean
         Get
             Return m_IsAttributeTypeName
         End Get
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2976" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="169" endline="176">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Property] As Mono.Cecil.PropertyReference, ByVal InstanceExpression As Expression, ByVal Parameters As ArgumentList)
         MyBase.New(Classifications.PropertyAccess, Parent)
         m_Property = [Property]
         m_InstanceExpression = InstanceExpression
         m_Parameters = Parameters
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2977" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\Is_IsNotExpression.vb" startline="96" endline="102">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression, ByVal Keyword As KS)
         MyBase.New(Parent, LExp, RExp)
         m_Keyword = Keyword
         Helper.Assert(m_Keyword = KS.Is OrElse m_Keyword = KS.IsNot)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2978" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="894" endline="910">
<![CDATA[
 
     ''' <summary>
     ''' Emits a constrained callvirt instructions. 
     ''' Throws an exception if the method is a shared method.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Shared Sub EmitConstrainedCallVirt(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference, ByVal ConstrainedType As Mono.Cecil.TypeReference)
         Dim OriginalMethod As Mono.Cecil.MethodReference = Method
 
         Helper.Assert(Method IsNot Nothing)
         Helper.Assert(ConstrainedType IsNot Nothing)
 
         EmitConstrained(Info, ConstrainedType)
         EmitCallVirt(Info, Method)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2979" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="365" endline="372">
<![CDATA[
 
     Shared Sub EmitIsInst(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         Dim toOriginal As Mono.Cecil.TypeReference = ToType
 
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Info.ILGen.Emit(OpCodes.Isinst, ToType)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2980" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="56" endline="63">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2981" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="349" endline="356">
<![CDATA[
 
     Overridable Function DefineType() As Boolean Implements IDefinableType.DefineType
         Dim result As Boolean = True
 
         Helper.Assert(BaseType IsNot Nothing OrElse Me.CecilType.IsInterface)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2987" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="63" endline="81">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the specified child of the namespace.
     ''' Returns nothing if nothing is found.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Child"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Overloads ReadOnly Property Item(ByVal Parent As [Namespace], ByVal Child As String) As [Namespace]
         Get
             Dim name As String = Parent.Name & "." & Child
             If ContainsKey(name) Then
                 Return Item(name)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2988" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="117" endline="123">
<![CDATA[
 
     Sub Init(ByVal IsAssembly As Boolean, ByVal IsModule As Boolean, ByVal SimpleTypeName As SimpleTypeName, ByVal AttributeArguments As AttributeArguments)
         m_IsAssembly = IsAssembly
         m_IsModule = IsModule
         m_SimpleTypeName = SimpleTypeName
         m_AttributeArguments = AttributeArguments
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2989" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="35" endline="42">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal Identifier As Identifier, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName)
 
         Dim mySignature As New FunctionSignature(Me)
         mySignature.Init(Identifier, Nothing, ParameterList, ReturnTypeAttributes, TypeName, Me.Location)
 
         MyBase.Init(Modifiers, CharsetModifier, LibraryClause, AliasClause, mySignature)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2990" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="68" endline="91">
<![CDATA[
     End Property
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = OriginalType
 
         If m_ArrayTypeModifiers IsNot Nothing Then
             result = m_ArrayTypeModifiers.CreateArrayType(result)
         End If
 
         If m_BoundList.Expressions.GetUpperBound(0) = 0 Then
             result = CecilHelper.MakeArrayType(result)
         Else
             Dim arr As ArrayType
             arr = CecilHelper.MakeArrayType(result, m_BoundList.Expressions.GetUpperBound(0) + 1)
             result = arr
             If arr.Rank > 1 Then
                 For d As Integer = 0 To arr.Rank - 1
                     arr.Dimensions(d) = New ArrayDimension(New Nullable(Of Integer)(0), Nothing)
                 Next
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2993" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="190" endline="196">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Value As Expression)
         Me.New(DirectCast(Parent, ParsedObject))
         m_Type = Value.ExpressionType
         m_Value = Value
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2994" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="491" endline="499">
<![CDATA[
 
     Public Function LookupFlattened(ByVal Name As String, ByVal Visibility As MemberVisibility) As MemberCacheEntry
         Dim result As MemberCacheEntry = Nothing
 
         Load(Name, Visibility)
 
         m_FlattenedCacheInsensitive(Visibility).TryGetValue(Name, result)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2997" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="183" endline="189">
<![CDATA[
 
     Sub New(ByVal ParentAndValue As Expression)
         Me.New(DirectCast(ParentAndValue, ParsedObject))
         m_Type = ParentAndValue.ExpressionType
         m_Value = ParentAndValue
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3000" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="60" endline="67">
<![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal InExpression As Expression, ByVal NextExpression As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_InExpression = InExpression
         m_NextExpression = NextExpression
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3001" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\NamedBaseList.vb" startline="38" endline="55">
<![CDATA[
 
     ''' <summary>
     ''' Finds the list item with the specified name.
     ''' Returns nothing if nothing found.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal Name As String) As T
         Get
             For Each tp As T In Me
                 Dim t As INameable = CType(CObj(tp), INameable)
                 If Helper.CompareName(t.Name, Name) Then
                     Return tp
                 End If
             Next
             Return Nothing
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3004" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="64" endline="71">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3006" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" startline="62" endline="71">
<![CDATA[
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifiers(ByVal Modifier As ModifierMasks) As Modifiers
         m_ModifierMask = m_ModifierMask Or Modifier
         Return Me
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3008" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" startline="84" endline="98">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="InstanceExpression">May be Nothing</param>
     ''' <param name="TypeArguments">May be Nothing</param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Name As String)
         MyBase.New(Classifications.LateBoundAccess, Parent)
         m_InstanceExpression = InstanceExpression
         m_Name = Name
         m_TypeArguments = TypeArguments
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3009" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="885" endline="893">
<![CDATA[
 
 
     Shared Sub EmitConstrained(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference)
         Dim OriginalType As Mono.Cecil.TypeReference = Type
 
         Type = Helper.GetTypeOrTypeBuilder(Info.Compiler, Type)
 
         Info.ILGen.Emit(OpCodes.Constrained, Type)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3010" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resources.vb" startline="41" endline="49">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' A new resource list.
     ''' </summary>	
     Sub New(ByVal Compiler As Compiler, ByVal LinkedResources As Boolean)
         m_Compiler = Compiler
         m_IsLinkedResources = LinkedResources
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3015" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="37" endline="43">
<![CDATA[
 
     Sub Init(ByVal Target As Expression, ByVal Start As Expression, ByVal Length As Expression, ByVal Source As Expression)
         m_Target = Target
         m_Start = Start
         m_Length = Length
         m_Source = Source
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3017" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="48" endline="55">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As Mono.Cecil.TypeReference, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_ReturnType = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3018" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="76" endline="82">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier, ByVal TypeName As TypeName, ByVal Expression As Expression)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
         m_TypeName = TypeName
         m_Expression = Expression
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3035" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3033" endline="3053">
<![CDATA[
 
     Shared Function Compare(ByVal g1 As Mono.Cecil.IGenericParameterProvider, ByVal g2 As Mono.Cecil.IGenericParameterProvider) As Boolean
         Helper.Assert(g1 IsNot Nothing AndAlso g2 IsNot Nothing)
         Dim m1 As Mono.Cecil.MethodReference = TryCast(g1, Mono.Cecil.MethodReference)
         Dim m2 As Mono.Cecil.MethodReference = TryCast(g2, Mono.Cecil.MethodReference)
 
         If m1 IsNot Nothing AndAlso m2 IsNot Nothing Then
             Return m1 Is m2
         ElseIf m1 IsNot Nothing Xor m2 IsNot Nothing Then
             Return False
         End If
 
         Dim t1 As Mono.Cecil.TypeReference = TryCast(g1, Mono.Cecil.TypeReference)
         Dim t2 As Mono.Cecil.TypeReference = TryCast(g2, Mono.Cecil.TypeReference)
 
         If t1 IsNot Nothing AndAlso t2 IsNot Nothing Then
             Return Helper.CompareType(t1, t2)
         End If
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3791" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="770" endline="802">
<![CDATA[
 
 		public void Error_UnexpectedKind (ResolveContext ec, ResolveFlags flags, Location loc)
 		{
 			string [] valid = new string [4];
 			int count = 0;
 
 			if ((flags & ResolveFlags.VariableOrValue) != 0) {
 				valid [count++] = "variable";
 				valid [count++] = "value";
 			}
 
 			if ((flags & ResolveFlags.Type) != 0)
 				valid [count++] = "type";
 
 			if ((flags & ResolveFlags.MethodGroup) != 0)
 				valid [count++] = "method group";
 
 			if (count == 0)
 				valid [count++] = "unknown";
 
 			StringBuilder sb = new StringBuilder (valid [0]);
 			for (int i = 1; i < count - 1; i++) {
 				sb.Append ("', `");
 				sb.Append (valid [i]);
 			}
 			for (int i = 1; i < count - 1; i++) {
 				sb.Append ("', `");
 				sb.Append (valid [i]);
 			}
 			if (count > 1) {
 				sb.Append ("' or `");
 				sb.Append (valid [count - 1]);
 			}
 
 			ec.Report.Error (119, loc, 
 				"Expression denotes a `{0}', where a `{1}' was expected", ExprClassName, sb.ToString ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3807" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="324" endline="351">
<![CDATA[
 
 		internal bool MatchParameterTypes(Type[] types)
 		{
 			if (types == parameterTypes)
 			{
 				return true;
 			}
 			if (types == null)
 			{
 				return parameterTypes.Length == 0;
 			}
 			if (parameterTypes == null)
 			{
 				return types.Length == 0;
 			}
 			if (types.Length == parameterTypes.Length)
 			{
 				for (int i = 0; i < types.Length; i++)
 				{
 					if (!Util.TypeEquals(types[i], parameterTypes[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < types.Length; i++)
 				{
 					if (!Util.TypeEquals(types[i], parameterTypes[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3861" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="192" endline="236">
<![CDATA[
 
 		public static MethodAttributes MethodAttr (Modifiers mod_flags)
 		{
 			MethodAttributes ma = MethodAttributes.HideBySig;
 
 			switch (mod_flags & Modifiers.AccessibilityMask) {
 			case Modifiers.PUBLIC
 				ma |= MethodAttributes.Public;
 				break;
 			case Modifiers.PRIVATE
 				ma |= MethodAttributes.Private;
 				break;
 			case Modifiers.PROTECTED | Modifiers.INTERNAL
 				ma |= MethodAttributes.FamORAssem;
 				break;
 			case Modifiers.PROTECTED
 				ma |= MethodAttributes.Family;
 				break;
 			case Modifiers.INTERNAL
 				ma |= MethodAttributes.Assembly;
 				break;
 			default
 				throw new NotImplementedException (mod_flags.ToString ());
 			}
 
 			if ((mod_flags & Modifiers.STATIC) != 0)
 				ma |= MethodAttributes.Static;
 			if ((mod_flags & Modifiers.ABSTRACT) != 0) {
 				ma |= MethodAttributes.Abstract | MethodAttributes.Virtual;
 			}
 			if ((mod_flags & Modifiers.SEALED) != 0)
 				ma |= MethodAttributes.Final;
 
 			if ((mod_flags & Modifiers.VIRTUAL) != 0)
 				ma |= MethodAttributes.Virtual;
 
 			if ((mod_flags & Modifiers.OVERRIDE) != 0) {
 				ma |= MethodAttributes.Virtual;
 			} else {
 				if ((ma & MethodAttributes.Virtual) != 0)
 					ma |= MethodAttributes.NewSlot;
 			}
 			
 			return ma;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3923" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2220" endline="2261">
<![CDATA[
 
 		bool pp_primary (ref string s)
 		{
 			s = s.Trim ();
 			int len = s.Length;
 
 			if (len > 0){
 				char c = s [0];
 				
 				if (c == '('){
 					s = s.Substring (1);
 					bool val = pp_expr (ref s, false);
 					if (s.Length > 0 && s [0] == ')'){
 						s = s.Substring (1);
 						return val;
 					}
 					Error_InvalidDirective ();
 					return false;
 				}
 				
 				if (is_identifier_start_character (c)){
 					int j = 1;
 
 					while (j < len){
 						c = s [j];
 						
 						if (is_identifier_part_character (c)){
 							j++;
 							continue;
 						}
 						bool v = eval_val (s.Substring (0, j));
 						s = s.Substring (j);
 						return v;
 					while (j < len){
 						c = s [j];
 						
 						if (is_identifier_part_character (c)){
 							j++;
 							continue;
 						}
 						bool v = eval_val (s.Substring (0, j));
 						s = s.Substring (j);
 						return v;
 					}
 					bool vv = eval_val (s);
 					s = "";
 					return vv;
 				}
 			}
 			Error_InvalidDirective ();
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3927" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="460" endline="487">
<![CDATA[
 
 		private static void WriteGenericSignature(ModuleBuilder module, ByteBuffer bb, Type type)
 		{
 			Type[] typeArguments = type.GetGenericArguments();
 			Type[][] requiredCustomModifiers = type.__GetGenericArgumentsRequiredCustomModifiers();
 			Type[][] optionalCustomModifiers = type.__GetGenericArgumentsOptionalCustomModifiers();
 			if (!type.IsGenericTypeDefinition)
 			{
 				type = type.GetGenericTypeDefinition();
 			}
 			bb.Write(ELEMENT_TYPE_GENERICINST);
 			if (type.IsValueType)
 			{
 				bb.Write(ELEMENT_TYPE_VALUETYPE);
 			}
 			else
 			{
 				bb.Write(ELEMENT_TYPE_CLASS);
 			}
 			bb.WriteTypeDefOrRefEncoded(module.GetTypeToken(type).Token);
 			bb.WriteCompressedInt(typeArguments.Length);
 			for (int i = 0; i < typeArguments.Length; i++)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
 				WriteType(module, bb, typeArguments[i]);
 			}
 			for (int i = 0; i < typeArguments.Length; i++)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
 				WriteType(module, bb, typeArguments[i]);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3937" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="218" endline="299">
<![CDATA[
 
 		// note that this is the fusion specific parser, it is not the same as System.Reflection.AssemblyName
 		private static bool ParseAssemblyName(string fullName, out ParsedAssemblyName parsedName)
 		{
 			parsedName = new ParsedAssemblyName();
 			StringBuilder sb = new StringBuilder();
 			int pos = 0;
 			while (pos < fullName.Length)
 			{
 				char ch = fullName[pos++];
 				if (ch == '\\')
 				{
 					if (pos == fullName.Length)
 					{
 						return false;
 					}
 					ch = fullName[pos++];
 				}
 				else if (ch == ',')
 				{
 					break;
 				}
 				sb.Append(ch);
 			}
 			while (pos < fullName.Length)
 			{
 				char ch = fullName[pos++];
 				if (ch == '\\')
 				{
 					if (pos == fullName.Length)
 					{
 						return false;
 					}
 					ch = fullName[pos++];
 				}
 				else if (ch == ',')
 				{
 					break;
 				}
 				sb.Append(ch);
 			}
 			parsedName.Name = sb.ToString().Trim();
 			if (pos < fullName.Length)
 			{
 				string[] parts = fullName.Substring(pos).Split(',');
 				for (int i = 0; i < parts.Length; i++)
 				{
 					string[] kv = parts[i].Split('=');
 					if (kv.Length != 2)
 					{
 						return false;
 					}
 					switch (kv[0].Trim().ToLowerInvariant())
 					{
 						case "version"
 							if (parsedName.Version != null)
 							{
 								return false;
 							}
 							if (!ParseVersion(kv[1].Trim(), out parsedName.Version))
 							{
 								return false;
 							}
 							break;
 						case "culture"
 							if (parsedName.Culture != null)
 							{
 								return false;
 							}
 							if (!ParseCulture(kv[1].Trim(), out parsedName.Culture))
 							{
 								return false;
 							}
 							break;
 						case "publickeytoken"
 							if (parsedName.PublicKeyToken != null)
 							{
 								return false;
 							}
 							if (!ParsePublicKeyToken(kv[1].Trim(), out parsedName.PublicKeyToken))
 							{
 								return false;
 							}
 							break;
 						case "publickey"
 							if (parsedName.PublicKeyToken != null)
 							{
 								return false;
 							}
 							if (!ParsePublicKey(kv[1].Trim(), out parsedName.PublicKeyToken))
 							{
 								return false;
 							}
 							break;
 					}
 				}
 				for (int i = 0; i < parts.Length; i++)
 				{
 					string[] kv = parts[i].Split('=');
 					if (kv.Length != 2)
 					{
 						return false;
 					}
 					switch (kv[0].Trim().ToLowerInvariant())
 					{
 						case "version"
 							if (parsedName.Version != null)
 							{
 								return false;
 							}
 							if (!ParseVersion(kv[1].Trim(), out parsedName.Version))
 							{
 								return false;
 							}
 							break;
 						case "culture"
 							if (parsedName.Culture != null)
 							{
 								return false;
 							}
 							if (!ParseCulture(kv[1].Trim(), out parsedName.Culture))
 							{
 								return false;
 							}
 							break;
 						case "publickeytoken"
 							if (parsedName.PublicKeyToken != null)
 							{
 								return false;
 							}
 							if (!ParsePublicKeyToken(kv[1].Trim(), out parsedName.PublicKeyToken))
 							{
 								return false;
 							}
 							break;
 						case "publickey"
 							if (parsedName.PublicKeyToken != null)
 							{
 								return false;
 							}
 							if (!ParsePublicKey(kv[1].Trim(), out parsedName.PublicKeyToken))
 							{
 								return false;
 							}
 							break;
 					}
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3938" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1131" endline="1237">
<![CDATA[
 					
 		//
 		// Tonizes `?' using custom disambiguous rules to return one
 		// of following tokens
 		//
 		// Tricky expression look like
 		//
 		// Foo ? a = x ? b 
 		//
 		int TokenizePossibleNullableType ()
 		{
 			if (parsing_block == 0 || parsing_type > 0)
 				return Token.INTERR_NULLABLE;
 
 			int d = peek_char ();
 			if (d == '?') {
 				get_char ();
 				return Token.OP_COALESCING;
 			}
 
 			switch (current_token) {
 			case Token.CLOSE_PARENS
 			case Token.TRUE
 			case Token.FALSE
 			case Token.NULL
 			case Token.LITERAL
 				return Token.INTERR;
 			}
 
 			if (d != ' ') {
 				if (d == ',' || d == ';' || d == '>')
 					return Token.INTERR_NULLABLE;
 				if (d == '*' || (d >= '0' && d <= '9'))
 					return Token.INTERR;
 			}
 
 			PushPosition ();
 			current_token = Token.NONE;
 			int next_token;
 			switch (xtoken ()) {
 			case Token.LITERAL
 			case Token.TRUE
 			case Token.FALSE
 			case Token.NULL
 			case Token.THIS
 			case Token.NEW
 				next_token = Token.INTERR;
 				break;
 				
 			case Token.SEMICOLON
 			case Token.COMMA
 			case Token.CLOSE_PARENS
 			case Token.OPEN_BRACKET
 			case Token.OP_GENERICS_GT
 				next_token = Token.INTERR_NULLABLE;
 				break;
 				
 			default
 				next_token = -1;
 				break;
 			}
 
 			if (next_token == -1) {
 				switch (xtoken ()) {
 				case Token.COMMA
 				case Token.SEMICOLON
 				case Token.OPEN_BRACE
 				case Token.CLOSE_PARENS
 				case Token.IN
 					next_token = Token.INTERR_NULLABLE;
 					break;
 					
 				case Token.COLON
 					next_token = Token.INTERR;
 					break;							
 					
 				default
 					int ntoken;
 					int interrs = 1;
 					int colons = 0;
 					//
 					// All shorcuts failed, do it hard way
 					//
 					while ((ntoken = xtoken ()) != Token.EOF) {
 						if (ntoken == Token.SEMICOLON)
 							break;
 						
 						if (ntoken == Token.COLON) {
 							if (++colons == interrs)
 								break;
 							continue;
 						}
 						
 						if (ntoken == Token.INTERR) {
 							++interrs;
 							continue;
 						}
 					}
 					while ((ntoken = xtoken ()) != Token.EOF) {
 						if (ntoken == Token.SEMICOLON)
 							break;
 						
 						if (ntoken == Token.COLON) {
 							if (++colons == interrs)
 								break;
 							continue;
 						}
 						
 						if (ntoken == Token.INTERR) {
 							++interrs;
 							continue;
 						}
 					}
 					
 					next_token = colons != interrs ? Token.INTERR_NULLABLE 
 					break;
 				}
 			}
 			
 			PopPosition ();
 			return next_token;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3951" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2091" endline="2165">
<![CDATA[
 		}
 
 		#endregion
 
 		/// <summary>
 		///   Returns a stringified representation of the Operator
 		/// </summary>
 		string OperName (Operator oper)
 		{
 			string s;
 			switch (oper){
 			case Operator.Multiply
 				s = "*";
 				break;
 			case Operator.Division
 				s = "/";
 				break;
 			case Operator.Modulus
 				s = "%";
 				break;
 			case Operator.Addition
 				s = "+";
 				break;
 			case Operator.Subtraction
 				s = "-";
 				break;
 			case Operator.LeftShift
 				s = "<<";
 				break;
 			case Operator.RightShift
 				s = ">>";
 				break;
 			case Operator.LessThan
 				s = "<";
 				break;
 			case Operator.GreaterThan
 				s = ">";
 				break;
 			case Operator.LessThanOrEqual
 				s = "<=";
 				break;
 			case Operator.GreaterThanOrEqual
 				s = ">=";
 				break;
 			case Operator.Equality
 				s = "==";
 				break;
 			case Operator.Inequality
 				s = "!=";
 				break;
 			case Operator.BitwiseAnd
 				s = "&";
 				break;
 			case Operator.BitwiseOr
 				s = "|";
 				break;
 			case Operator.ExclusiveOr
 				s = "^";
 				break;
 			case Operator.LogicalOr
 				s = "||";
 				break;
 			case Operator.LogicalAnd
 				s = "&&";
 				break;
 			default
 				s = oper.ToString ();
 				break;
 			}
 
 			if (IsCompound)
 				return s + "=";
 
 			return s;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3970" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="170" endline="227">
<![CDATA[
 
 		internal int ReadHasCustomAttribute()
 		{
 			int codedIndex;
 			if (bigHasCustomAttribute)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 31)
 			{
 				case 0
 					return (MethodDefTable.Index << 24) + (codedIndex >> 5);
 				case 1
 					return (FieldTable.Index << 24) + (codedIndex >> 5);
 				case 2
 					return (TypeRefTable.Index << 24) + (codedIndex >> 5);
 				case 3
 					return (TypeDefTable.Index << 24) + (codedIndex >> 5);
 				case 4
 					return (ParamTable.Index << 24) + (codedIndex >> 5);
 				case 5
 					return (InterfaceImplTable.Index << 24) + (codedIndex >> 5);
 				case 6
 					return (MemberRefTable.Index << 24) + (codedIndex >> 5);
 				case 7
 					return (ModuleTable.Index << 24) + (codedIndex >> 5);
 				case 8
 					throw new BadImageFormatException();
 				case 9
 					return (PropertyTable.Index << 24) + (codedIndex >> 5);
 				case 10
 					return (EventTable.Index << 24) + (codedIndex >> 5);
 				case 11
 					return (StandAloneSigTable.Index << 24) + (codedIndex >> 5);
 				case 12
 					return (ModuleRefTable.Index << 24) + (codedIndex >> 5);
 				case 13
 					return (TypeSpecTable.Index << 24) + (codedIndex >> 5);
 				case 14
 					return (AssemblyTable.Index << 24) + (codedIndex >> 5);
 				case 15
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 5);
 				case 16
 					return (FileTable.Index << 24) + (codedIndex >> 5);
 				case 17
 					return (ExportedTypeTable.Index << 24) + (codedIndex >> 5);
 				case 18
 					return (ManifestResourceTable.Index << 24) + (codedIndex >> 5);
 				case 19
 					return (GenericParamTable.Index << 24) + (codedIndex >> 5);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3982" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="551" endline="633">
<![CDATA[
 
 #if NET_2_0
 	string FormatGenericParams (Type [] args)
 	{
 		StringBuilder sb = new StringBuilder ();
 		if (args.Length == 0)
 			return "";
 		
 		sb.Append ("<");
 		for (int i = 0; i < args.Length; i++) {
 			if (i > 0)
 				sb.Append (",");
 			sb.Append (FormatType (args [i]));
 		}
 		sb.Append (">");
 		return sb.ToString ();
 	}
 #endif
 
 	// TODO
 	// out a way to do this while not making things confusing.
 	string FormatType (Type t)
 	{
 		if (t == null)
 			return "";
 
 		string type = GetFullName (t);
 		if (type == null)
 			return t.ToString ();
 		
 		if (!type.StartsWith ("System.")) {
 			if (t.Namespace == this.t.Namespace)
 				return t.Name;
 			return type;
 		}
 		
 		if (t.HasElementType) {
 			Type et = t.GetElementType ();
 			if (t.IsArray)
 				return FormatType (et) + " []";
 			if (t.IsPointer)
 				return FormatType (et) + " *";
 			if (t.IsByRef)
 				return "ref " + FormatType (et);
 		}
 	
 		switch (type) {
 		case "System.Byte"
 		case "System.SByte"
 		case "System.Int16"
 		case "System.Int32"
 		case "System.Int64"
 			
 		case "System.UInt16"
 		case "System.UInt32"
 		case "System.UInt64"
 			
 		case "System.Single"
 		case "System.Double"
 		case "System.Decimal"
 		case "System.Boolean"
 		case "System.Char"
 		case "System.String"
 			
 		case "System.Object"
 		case "System.Void"
 		}
 	
 		if (type.LastIndexOf(".") == 6)
 			return type.Substring(7);
 
 		//
 		// If the namespace of the type is the namespace of what
 		// we are printing (or is a member of one if its children
 		// don't print it. This basically means that in C# we would
 		// automatically get the namespace imported by virtue of the
 		// namespace {} block.
 		//	
 		if (this.t.Namespace.StartsWith (t.Namespace + ".") || t.Namespace == this.t.Namespace)
 			return type.Substring (t.Namespace.Length + 1);
 	
 		return type;
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3989" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="913" endline="948">
<![CDATA[
 
 		static string FriendlyStackTrace (StackTrace t)
 		{		
 			StringBuilder sb = new StringBuilder ();
 			
 			bool foundUserCode = false;
 			
 			for (int i = 0; i < t.FrameCount; i++) {
 				StackFrame f = t.GetFrame (i);
 				var mb = f.GetMethod ();
 				
 				if (!foundUserCode && mb.ReflectedType == typeof (Report))
 					continue;
 				
 				foundUserCode = true;
 				
 				sb.Append ("\tin ");
 				
 				if (f.GetFileLineNumber () > 0)
 					sb.AppendFormat ("(at {0}
 				
 				sb.AppendFormat ("{0}.{1} (", mb.ReflectedType.Name, mb.Name);
 				
 				bool first = true;
 				foreach (var pi in mb.GetParameters ()) {
 					if (!first)
 						sb.Append (", ");
 					first = false;
 
 					sb.Append (pi.ParameterType.FullName);
 				}
 				foreach (var pi in mb.GetParameters ()) {
 					if (!first)
 						sb.Append (", ");
 					first = false;
 
 					sb.Append (pi.ParameterType.FullName);
 				}
 				sb.Append (")\n");
 			}
 			for (int i = 0; i < t.FrameCount; i++) {
 				StackFrame f = t.GetFrame (i);
 				var mb = f.GetMethod ();
 				
 				if (!foundUserCode && mb.ReflectedType == typeof (Report))
 					continue;
 				
 				foundUserCode = true;
 				
 				sb.Append ("\tin ");
 				
 				if (f.GetFileLineNumber () > 0)
 					sb.AppendFormat ("(at {0}
 				
 				sb.AppendFormat ("{0}.{1} (", mb.ReflectedType.Name, mb.Name);
 				
 				bool first = true;
 				foreach (var pi in mb.GetParameters ()) {
 					if (!first)
 						sb.Append (", ");
 					first = false;
 
 					sb.Append (pi.ParameterType.FullName);
 				}
 				sb.Append (")\n");
 			}
 	
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3993" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="257" endline="302">
<![CDATA[
 
 		static string [] LoadArgs (string file)
 		{
 			StreamReader f;
 			var args = new List<string> ();
 			string line;
 			try {
 				f = new StreamReader (file);
 			} catch {
 				return null;
 			}
 
 			StringBuilder sb = new StringBuilder ();
 			
 			while ((line = f.ReadLine ()) != null){
 				int t = line.Length;
 
 				for (int i = 0; i < t; i++){
 					char c = line [i];
 					
 					if (c == '"' || c == '\''){
 						char end = c;
 						
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 					} else if (c == ' '){
 						if (sb.Length > 0){
 							args.Add (sb.ToString ());
 							sb.Length = 0;
 						}
 					} else
 						sb.Append (c);
 				}
 				for (int i = 0; i < t; i++){
 					char c = line [i];
 					
 					if (c == '"' || c == '\''){
 						char end = c;
 						
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 					} else if (c == ' '){
 						if (sb.Length > 0){
 							args.Add (sb.ToString ());
 							sb.Length = 0;
 						}
 					} else
 						sb.Append (c);
 				}
 				if (sb.Length > 0){
 					args.Add (sb.ToString ());
 					sb.Length = 0;
 				}
 			}
 			while ((line = f.ReadLine ()) != null){
 				int t = line.Length;
 
 				for (int i = 0; i < t; i++){
 					char c = line [i];
 					
 					if (c == '"' || c == '\''){
 						char end = c;
 						
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 					} else if (c == ' '){
 						if (sb.Length > 0){
 							args.Add (sb.ToString ());
 							sb.Length = 0;
 						}
 					} else
 						sb.Append (c);
 				}
 				if (sb.Length > 0){
 					args.Add (sb.ToString ());
 					sb.Length = 0;
 				}
 			}
 
 			return args.ToArray ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3994" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="291" endline="311">
<![CDATA[
 
 		private static int ReadCompressedInt(byte[] buffer, ref int offset)
 		{
 			byte b1 = buffer[offset++];
 			if (b1 <= 0x7F)
 			{
 				return b1;
 			}
 			else if ((b1 & 0xC0) == 0x80)
 			{
 				byte b2 = buffer[offset++];
 				return ((b1 & 0x3F) << 8) | b2;
 			}
 			else
 			{
 				byte b2 = buffer[offset++];
 				byte b3 = buffer[offset++];
 				byte b4 = buffer[offset++];
 				return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3998" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="68" endline="147">
<![CDATA[
 
 		private sealed class UnboundGenericMethodContext 
 		{
 			private readonly IGenericContext original;
 
 			internal UnboundGenericMethodContext(IGenericContext original)
 			{
 				this.original = original;
 			}
 
 			public Type GetGenericTypeArgument(int index)
 			{
 				return original.GetGenericTypeArgument(index);
 			}
 
 			public Type GetGenericMethodArgument(int index)
 			{
 				return UnboundGenericMethodParameter.Make(index);
 			}
 		}
 
 		internal static MethodSignature ReadSig(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			CallingConventions callingConvention;
 			int genericParamCount;
 			Type returnType;
 			Type[] parameterTypes;
 			byte flags = br.ReadByte();
 			switch (flags & 7)
 			{
 				case DEFAULT
 					callingConvention = CallingConventions.Standard;
 					break;
 				case VARARG
 					callingConvention = CallingConventions.VarArgs;
 					break;
 				default
 					throw new BadImageFormatException();
 			}
 			if ((flags & HASTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.HasThis;
 			}
 			if ((flags & EXPLICITTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.ExplicitThis;
 			}
 			genericParamCount = 0;
 			if ((flags & GENERIC) != 0)
 			{
 				genericParamCount = br.ReadCompressedInt();
 				context = new UnboundGenericMethodContext(context);
 			}
 			int paramCount = br.ReadCompressedInt();
 			Type[][][] modifiers = null;
 			Type[] optionalCustomModifiers;
 			Type[] requiredCustomModifiers;
 			ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
 			returnType = ReadRetType(module, br, context);
 			parameterTypes = new Type[paramCount];
 			PackedCustomModifiers.SetModifiers(ref modifiers, 0, 0, optionalCustomModifiers, paramCount + 1);
 			PackedCustomModifiers.SetModifiers(ref modifiers, 0, 1, requiredCustomModifiers, paramCount + 1);
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if ((callingConvention & CallingConventions.VarArgs) != 0 && br.PeekByte() == SENTINEL)
 				{
 					Array.Resize(ref parameterTypes, i);
 					if (modifiers != null)
 					{
 						Array.Resize(ref modifiers, i + 1);
 					}
 					break;
 				}
 				ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
 				PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 0, optionalCustomModifiers, paramCount + 1);
 				PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 1, requiredCustomModifiers, paramCount + 1);
 				parameterTypes[i] = ReadParam(module, br, context);
 			}
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if ((callingConvention & CallingConventions.VarArgs) != 0 && br.PeekByte() == SENTINEL)
 				{
 					Array.Resize(ref parameterTypes, i);
 					if (modifiers != null)
 					{
 						Array.Resize(ref modifiers, i + 1);
 					}
 					break;
 				}
 				ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
 				PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 0, optionalCustomModifiers, paramCount + 1);
 				PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 1, requiredCustomModifiers, paramCount + 1);
 				parameterTypes[i] = ReadParam(module, br, context);
 			}
 			return new MethodSignature(returnType, parameterTypes, modifiers, callingConvention, genericParamCount);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3999" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="779" endline="809">
<![CDATA[
 
 		public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
 		{
 			List<PropertyInfo> list = new List<PropertyInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4002" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="479" endline="509">
<![CDATA[
 
 		public EventInfo[] GetEvents(BindingFlags bindingAttr)
 		{
 			List<EventInfo> list = new List<EventInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4004" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="794" endline="831">
<![CDATA[
 
 #if !SMCS_SOURCE
 		public static string GetPackageFlags (string packages, bool fatal, Report report)
 		{
 			ProcessStartInfo pi = new ProcessStartInfo ();
 			pi.FileName = "pkg-config";
 			pi.RedirectStandardOutput = true;
 			pi.UseShellExecute = false;
 			pi.Arguments = "--libs " + packages;
 			Process p = null;
 			try {
 				p = Process.Start (pi);
 			} catch (Exception e) {
 				report.Error (-27, "Couldn't run pkg-config
 				if (fatal)
 					Environment.Exit (1);
 				p.Close ();
 				return null;
 			}
 			
 			if (p.StandardOutput == null){
 				report.Warning (-27, 1, "Specified package did not return any information");
 				p.Close ();
 				return null;
 			}
 			string pkgout = p.StandardOutput.ReadToEnd ();
 			p.WaitForExit ();
 			if (p.ExitCode != 0) {
 				report.Error (-27, "Error running pkg-config. Check the above output.");
 				if (fatal)
 					Environment.Exit (1);
 				p.Close ();
 				return null;
 			}
 			p.Close ();
 
 			return pkgout;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4007" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1924" endline="1957">
<![CDATA[
 
 		byte read_hex (out bool error)
 		{
 			int total;
 			int c = get_char ();
 
 			if ((c >= '0') && (c <= '9'))
 				total = (int) c - (int) '0';
 			else if ((c >= 'A') && (c <= 'F'))
 				total = (int) c - (int) 'A' + 10;
 			else if ((c >= 'a') && (c <= 'f'))
 				total = (int) c - (int) 'a' + 10;
 			else {
 				error = true;
 				return 0;
 			}
 
 			total *= 16;
 			c = get_char ();
 
 			if ((c >= '0') && (c <= '9'))
 				total += (int) c - (int) '0';
 			else if ((c >= 'A') && (c <= 'F'))
 				total += (int) c - (int) 'A' + 10;
 			else if ((c >= 'a') && (c <= 'f'))
 				total += (int) c - (int) 'a' + 10;
 			else {
 				error = true;
 				return 0;
 			}
 
 			error = false;
 			return (byte) total;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4011" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2283" endline="2309">
<![CDATA[
 		
 		bool pp_eq (ref string s)
 		{
 			bool va = pp_unary (ref s);
 
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				if (s [0] == '='){
 					if (len > 2 && s [1] == '='){
 						s = s.Substring (2);
 						return va == pp_unary (ref s);
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				} else if (s [0] == '!' && len > 1 && s [1] == '='){
 					s = s.Substring (2);
 
 					return va != pp_unary (ref s);
 
 				} 
 			}
 
 			return va;
 				
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4015" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="538" endline="593">
<![CDATA[
 
 		/// <summary>
 		///   Get a string containing a list of valid targets for the attribute 'attr'
 		/// </summary>
 		public string GetValidTargets ()
 		{
 			StringBuilder sb = new StringBuilder ();
 			AttributeTargets targets = Type.GetAttributeUsage (context.Module.PredefinedAttributes.AttributeUsage).ValidOn;
 
 			if ((targets & AttributeTargets.Assembly) != 0)
 				sb.Append ("assembly, ");
 
 			if ((targets & AttributeTargets.Module) != 0)
 				sb.Append ("module, ");
 
 			if ((targets & AttributeTargets.Class) != 0)
 				sb.Append ("class, ");
 
 			if ((targets & AttributeTargets.Struct) != 0)
 				sb.Append ("struct, ");
 
 			if ((targets & AttributeTargets.Enum) != 0)
 				sb.Append ("enum, ");
 
 			if ((targets & AttributeTargets.Constructor) != 0)
 				sb.Append ("constructor, ");
 
 			if ((targets & AttributeTargets.Method) != 0)
 				sb.Append ("method, ");
 
 			if ((targets & AttributeTargets.Property) != 0)
 				sb.Append ("property, indexer, ");
 
 			if ((targets & AttributeTargets.Field) != 0)
 				sb.Append ("field, ");
 
 			if ((targets & AttributeTargets.Event) != 0)
 				sb.Append ("event, ");
 
 			if ((targets & AttributeTargets.Interface) != 0)
 				sb.Append ("interface, ");
 
 			if ((targets & AttributeTargets.Parameter) != 0)
 				sb.Append ("parameter, ");
 
 			if ((targets & AttributeTargets.Delegate) != 0)
 				sb.Append ("delegate, ");
 
 			if ((targets & AttributeTargets.ReturnValue) != 0)
 				sb.Append ("return, ");
 
 			if ((targets & AttributeTargets.GenericParameter) != 0)
 				sb.Append ("type parameter, ");
 
 			return sb.Remove (sb.Length - 2, 2).ToString ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4017" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2186" endline="2232">
<![CDATA[
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (oper) {
 			case Operator.Addition
 				return IsCompound ? "AddAssign" 
 			case Operator.BitwiseAnd
 				return IsCompound ? "AndAssign" 
 			case Operator.BitwiseOr
 				return IsCompound ? "OrAssign" 
 			case Operator.Division
 				return IsCompound ? "DivideAssign" 
 			case Operator.ExclusiveOr
 				return IsCompound ? "ExclusiveOrAssign" 
 			case Operator.Equality
 				return "Equal";
 			case Operator.GreaterThan
 				return "GreaterThan";
 			case Operator.GreaterThanOrEqual
 				return "GreaterThanOrEqual";
 			case Operator.Inequality
 				return "NotEqual";
 			case Operator.LeftShift
 				return IsCompound ? "LeftShiftAssign" 
 			case Operator.LessThan
 				return "LessThan";
 			case Operator.LessThanOrEqual
 				return "LessThanOrEqual";
 			case Operator.LogicalAnd
 				return "And";
 			case Operator.LogicalOr
 				return "Or";
 			case Operator.Modulus
 				return IsCompound ? "ModuloAssign" 
 			case Operator.Multiply
 				return IsCompound ? "MultiplyAssign" 
 			case Operator.RightShift
 				return IsCompound ? "RightShiftAssign" 
 			case Operator.Subtraction
 				return IsCompound ? "SubtractAssign" 
 			default
 				throw new NotImplementedException ("Unknown expression type operator " + oper.ToString ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4018" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="174" endline="270">
<![CDATA[
 
 		private static int WriteMarshallingDescriptor(ModuleBuilder module, CustomAttributeBuilder attribute)
 		{
 			UnmanagedType unmanagedType;
 			object val = attribute.GetConstructorArgument(0);
 			if (val is short)
 			{
 				unmanagedType = (UnmanagedType)(short)val;
 			}
 			else if (val is int)
 			{
 				unmanagedType = (UnmanagedType)(int)val;
 			}
 			else
 			{
 				unmanagedType = (UnmanagedType)val;
 			}
 
 			ByteBuffer bb = new ByteBuffer(5);
 			bb.WriteCompressedInt((int)unmanagedType);
 
 			if (unmanagedType == UnmanagedType.LPArray)
 			{
 				UnmanagedType arraySubType = attribute.GetFieldValue<UnmanagedType>("ArraySubType") ?? NATIVE_TYPE_MAX;
 				bb.WriteCompressedInt((int)arraySubType);
 				int? sizeParamIndex = attribute.GetFieldValue<short>("SizeParamIndex");
 				int? sizeConst = attribute.GetFieldValue<int>("SizeConst");
 				if (sizeParamIndex != null)
 				{
 					bb.WriteCompressedInt(sizeParamIndex.Value);
 					if (sizeConst != null)
 					{
 						bb.WriteCompressedInt(sizeConst.Value);
 						bb.WriteCompressedInt(1); // flag that says that SizeParamIndex was specified
 					}
 				}
 				else if (sizeConst != null)
 				{
 					bb.WriteCompressedInt(0); // SizeParamIndex
 					bb.WriteCompressedInt(sizeConst.Value);
 					bb.WriteCompressedInt(0); // flag that says that SizeParamIndex was not specified
 				}
 			}
 			else if (unmanagedType == UnmanagedType.SafeArray)
 			{
 				VarEnum? safeArraySubType = attribute.GetFieldValue<VarEnum>("SafeArraySubType");
 				if (safeArraySubType != null)
 				{
 					bb.WriteCompressedInt((int)safeArraySubType);
 					Type safeArrayUserDefinedSubType = (Type)attribute.GetFieldValue("SafeArrayUserDefinedSubType");
 					if (safeArrayUserDefinedSubType != null)
 					{
 						WriteType(module, bb, safeArrayUserDefinedSubType);
 					}
 				}
 			}
 			else if (unmanagedType == UnmanagedType.ByValArray)
 			{
 				bb.WriteCompressedInt(attribute.GetFieldValue<int>("SizeConst") ?? 1);
 				UnmanagedType? arraySubType = attribute.GetFieldValue<UnmanagedType>("ArraySubType");
 				if (arraySubType != null)
 				{
 					bb.WriteCompressedInt((int)arraySubType);
 				}
 			}
 			else if (unmanagedType == UnmanagedType.ByValTStr)
 			{
 				bb.WriteCompressedInt(attribute.GetFieldValue<int>("SizeConst").Value);
 			}
 			else if (unmanagedType == UnmanagedType.Interface
 				|| unmanagedType == UnmanagedType.IDispatch
 				|| unmanagedType == UnmanagedType.IUnknown)
 			{
 				int? iidParameterIndex = attribute.GetFieldValue<int>("IidParameterIndex");
 				if (iidParameterIndex != null)
 				{
 					bb.WriteCompressedInt(iidParameterIndex.Value);
 				}
 			}
 			else if (unmanagedType == UnmanagedType.CustomMarshaler)
 			{
 				bb.WriteCompressedInt(0);
 				bb.WriteCompressedInt(0);
 				string marshalType = (string)attribute.GetFieldValue("MarshalType");
 				if (marshalType != null)
 				{
 					WriteString(bb, marshalType);
 				}
 				else
 				{
 					WriteType(module, bb, (Type)attribute.GetFieldValue("MarshalTypeRef"));
 				}
 				WriteString(bb, (string)attribute.GetFieldValue("MarshalCookie") ?? "");
 			}
 
 			return module.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4020" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1750" endline="1779">
<![CDATA[
 
 		int TokenizePreprocessorIdentifier (out int c)
 		{
 			// skip over white space
 			do {
 				c = get_char ();
 			} while (c == '\r' || c == ' ' || c == '\t');
 
 
 			int pos = 0;
 			while (c != -1 && c >= 'a' && c <= 'z') {
 				id_builder[pos++] = (char) c;
 				c = get_char ();
 				if (c == '\\') {
 					int peek = peek_char ();
 					if (peek == 'U' || peek == 'u') {
 						int surrogate;
 						c = EscapeUnicode (c, out surrogate);
 						if (surrogate != 0) {
 							if (is_identifier_part_character ((char) c)) {
 								id_builder[pos++] = (char) c;
 							}
 							c = surrogate;
 						}
 					}
 				}
 			}
 			while (c != -1 && c >= 'a' && c <= 'z') {
 				id_builder[pos++] = (char) c;
 				c = get_char ();
 				if (c == '\\') {
 					int peek = peek_char ();
 					if (peek == 'U' || peek == 'u') {
 						int surrogate;
 						c = EscapeUnicode (c, out surrogate);
 						if (surrogate != 0) {
 							if (is_identifier_part_character ((char) c)) {
 								id_builder[pos++] = (char) c;
 							}
 							c = surrogate;
 						}
 					}
 				}
 			}
 
 			return pos;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4023" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="940" endline="972">
<![CDATA[
 
 		protected void ImportTypes (MetaType[] types, Namespace targetNamespace, bool hasExtensionTypes)
 		{
 			Namespace ns = targetNamespace;
 			string prev_namespace = null;
 			foreach (var t in types) {
 				if (t == null)
 					continue;
 
 				// Be careful not to trigger full parent type loading
 				if (t.MemberType == MemberTypes.NestedType)
 					continue;
 
 				if (t.Name[0] == '<')
 					continue;
 
 				var it = CreateType (t, null, new DynamicTypeReader (t), true);
 				if (it == null)
 					continue;
 
 				if (prev_namespace != t.Namespace) {
 					ns = t.Namespace == null ? targetNamespace 
 					prev_namespace = t.Namespace;
 				}
 
 				ns.AddType (it);
 
 				if (it.IsStatic && hasExtensionTypes &&
 					HasAttribute (CustomAttributeData.GetCustomAttributes (t), "ExtensionAttribute", CompilerServicesNamespace)) {
 					it.SetExtensionMethodContainer ();
 				}
 			}
 			foreach (var t in types) {
 				if (t == null)
 					continue;
 
 				// Be careful not to trigger full parent type loading
 				if (t.MemberType == MemberTypes.NestedType)
 					continue;
 
 				if (t.Name[0] == '<')
 					continue;
 
 				var it = CreateType (t, null, new DynamicTypeReader (t), true);
 				if (it == null)
 					continue;
 
 				if (prev_namespace != t.Namespace) {
 					ns = t.Namespace == null ? targetNamespace 
 					prev_namespace = t.Namespace;
 				}
 
 				ns.AddType (it);
 
 				if (it.IsStatic && hasExtensionTypes &&
 					HasAttribute (CustomAttributeData.GetCustomAttributes (t), "ExtensionAttribute", CompilerServicesNamespace)) {
 					it.SetExtensionMethodContainer ();
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4089" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="569" endline="589">
<![CDATA[
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3139" endline="3158">
<![CDATA[
 
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.FieldAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.FieldAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.FieldAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.FieldAttributes.Public
                 Return "Public"
             Case Mono.Cecil.FieldAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4090" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="569" endline="589">
<![CDATA[
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3159" endline="3177">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.MethodAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.MethodAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.MethodAttributes.Public
                 Return "Public"
             Case Mono.Cecil.MethodAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4091" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="569" endline="589">
<![CDATA[
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3523" endline="3540">
<![CDATA[
 
     Shared Function GetMethodAccessibilityString(ByVal Attributes As Mono.Cecil.MethodAttributes) As String
         Attributes = Attributes And Mono.Cecil.MethodAttributes.MemberAccessMask
         Select Case Attributes
             Case Mono.Cecil.MethodAttributes.Public
                 Return "Public"
             Case Mono.Cecil.MethodAttributes.Private
                 Return "Private"
             Case Mono.Cecil.MethodAttributes.FamANDAssem, Mono.Cecil.MethodAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return "Friend"
             Case Else
                 Return "Public"
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4092" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="569" endline="589">
<![CDATA[
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3178" endline="3196">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.TypeAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.TypeAttributes.NestedFamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Return "Protected"
             Case Mono.Cecil.TypeAttributes.NestedAssembly, Mono.Cecil.TypeAttributes.NotPublic
                 Return "Friend"
             Case Mono.Cecil.TypeAttributes.NestedPublic, Mono.Cecil.TypeAttributes.Public
                 Return "Public"
             Case Mono.Cecil.TypeAttributes.NestedPrivate
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4093" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="569" endline="589">
<![CDATA[
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="89" endline="107">
<![CDATA[
 
     ReadOnly Property DescriptiveType() As String
         Get
             If TypeOf Me Is ClassDeclaration Then
                 Return "class"
             ElseIf TypeOf Me Is ModuleDeclaration Then
                 Return "module"
             ElseIf TypeOf Me Is EnumDeclaration Then
                 Return "enum"
             ElseIf TypeOf Me Is StructureDeclaration Then
                 Return "structure"
             ElseIf TypeOf Me Is DelegateDeclaration Then
                 Return "delegate"
             ElseIf TypeOf Me Is InterfaceDeclaration Then
                 Return "interface"
             Else
                 Return "type"
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4094" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="262" endline="277">
<![CDATA[
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
     Private m_ConditionalConstants As New Generic.List(Of ConditionalConstants)
     Private m_ConditionalConstantsLines As New Generic.List(Of UInteger)
 
     Private m_Code As String
 
     Public ReadOnly Property SymbolDocument() As Mono.Cecil.Cil.Document
         Get
             If m_SymbolDocument Is Nothing Then
                 m_SymbolDocument = New Mono.Cecil.Cil.Document(System.IO.Path.Combine(m_RelativePath.Replace("<"c, "["c).Replace(">"c, "]"c), m_FileName.Replace("<"c, "["c).Replace(">"c, "]"c)))
                 m_SymbolDocument.Language = Cil.DocumentLanguage.Basic
                 m_SymbolDocument.LanguageVendor = Cil.DocumentLanguageVendor.Microsoft
                 m_SymbolDocument.Type = Cil.DocumentType.Text
             End If
             Return m_SymbolDocument
         End Get
     End Property
 
     Sub AddConditionalConstants(ByVal Line As UInteger, ByVal Constants As ConditionalConstants)
         m_ConditionalConstants.Add(Constants.Clone)
         m_ConditionalConstantsLines.Add(Line)
     End Sub
 
     Function GetConditionalConstants(ByVal Line As UInteger) As ConditionalConstants
         If m_ConditionalConstantsLines.Count = 0 Then Return Nothing
 
         'If the first #const is after the line, no constants in this file at the line
         If m_ConditionalConstantsLines(0) > Line Then Return Nothing
 
         For i As Integer = 0 To m_ConditionalConstantsLines.Count - 1
             'If the current #const is after the line, the previous one corresponds to the line
             If m_ConditionalConstantsLines(i) > Line Then
                 Return m_ConditionalConstants(i - 1)
             End If
         Next
 
         'If no constants are after the line, the last is the one.
         Return m_ConditionalConstants(m_ConditionalConstants.Count - 1)
     End Function
 
     Private Shared ReadOnly Property UTF8Throw() As System.Text.Encoding
         Get
             ' Use no preamble to let StreamReader use a non-throwing decoder
             ' when UTF-8 byte order mark found.
             If m_UTF8Throw Is Nothing Then m_UTF8Throw = New System.Text.UTF8Encoding(False, True)
             Return m_UTF8Throw
         End Get
     End Property
 
     Property RelativePath() As String
         Get
             Return m_RelativePath
         End Get
         Set(ByVal value As String)
             m_RelativePath = value
         End Set
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_Imports.ResolveCode(Info)
     End Function
 
     ReadOnly Property OptionExplicit() As OptionExplicitStatement
         Get
             Return m_OptionExplicit
         End Get
     End Property
 
     ReadOnly Property OptionStrict() As OptionStrictStatement
         Get
             Return m_OptionStrict
         End Get
     End Property
 
     ReadOnly Property OptionCompare() As OptionCompareStatement
         Get
             Return m_OptionCompare
         End Get
     End Property
 
     ReadOnly Property OptionInfer As OptionInferStatement
         Get
             Return m_OptionInfer
         End Get
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareText() As Boolean
         Get
             Return Not IsOptionCompareBinary
         End Get
     End Property
 
     ''' <summary>
     ''' The imports clauses this file has.
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsClauses
         Get
             Return m_Imports
         End Get
     End Property
 
     ''' <summary>
     ''' Compare one CodeFile to another based on filename.
     ''' </summary>
     ''' <param name="value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Overrides Function Equals(ByVal value As Object) As Boolean
         Dim file As CodeFile = TryCast(value, CodeFile)
         If file IsNot Nothing Then
             If file Is Me Then
                 Return True
             Else
                 Return Microsoft.VisualBasic.Strings.StrComp(m_FileName, file.FileName, Microsoft.VisualBasic.CompareMethod.Text) = 0
             End If
         Else
             Return False
         End If
     End Function
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
         'Try to get the absolute path for all files.
         If FileName Is Nothing OrElse FileName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars()) >= 0 Then
             m_FileName = FileName
         Else
             m_FileName = IO.Path.GetFullPath(FileName)
         End If
         m_RelativePath = RelativePath
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="730" endline="747">
<![CDATA[
 
 		internal SourceFileEntry (MonoSymbolFile file, MyBinaryReader reader)
 		{
 			this.file = file;
 
 			Index = reader.ReadInt32 ();
 			DataOffset = reader.ReadInt32 ();
 
 			int old_pos = (int) reader.BaseStream.Position;
 			reader.BaseStream.Position = DataOffset;
 
 			file_name = reader.ReadString ();
 			guid = reader.ReadBytes (16);
 			hash = reader.ReadBytes (16);
 			auto_generated = reader.ReadByte () == 1;
 
 			reader.BaseStream.Position = old_pos;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4095" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="262" endline="277">
<![CDATA[
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
     Private m_ConditionalConstants As New Generic.List(Of ConditionalConstants)
     Private m_ConditionalConstantsLines As New Generic.List(Of UInteger)
 
     Private m_Code As String
 
     Public ReadOnly Property SymbolDocument() As Mono.Cecil.Cil.Document
         Get
             If m_SymbolDocument Is Nothing Then
                 m_SymbolDocument = New Mono.Cecil.Cil.Document(System.IO.Path.Combine(m_RelativePath.Replace("<"c, "["c).Replace(">"c, "]"c), m_FileName.Replace("<"c, "["c).Replace(">"c, "]"c)))
                 m_SymbolDocument.Language = Cil.DocumentLanguage.Basic
                 m_SymbolDocument.LanguageVendor = Cil.DocumentLanguageVendor.Microsoft
                 m_SymbolDocument.Type = Cil.DocumentType.Text
             End If
             Return m_SymbolDocument
         End Get
     End Property
 
     Sub AddConditionalConstants(ByVal Line As UInteger, ByVal Constants As ConditionalConstants)
         m_ConditionalConstants.Add(Constants.Clone)
         m_ConditionalConstantsLines.Add(Line)
     End Sub
 
     Function GetConditionalConstants(ByVal Line As UInteger) As ConditionalConstants
         If m_ConditionalConstantsLines.Count = 0 Then Return Nothing
 
         'If the first #const is after the line, no constants in this file at the line
         If m_ConditionalConstantsLines(0) > Line Then Return Nothing
 
         For i As Integer = 0 To m_ConditionalConstantsLines.Count - 1
             'If the current #const is after the line, the previous one corresponds to the line
             If m_ConditionalConstantsLines(i) > Line Then
                 Return m_ConditionalConstants(i - 1)
             End If
         Next
 
         'If no constants are after the line, the last is the one.
         Return m_ConditionalConstants(m_ConditionalConstants.Count - 1)
     End Function
 
     Private Shared ReadOnly Property UTF8Throw() As System.Text.Encoding
         Get
             ' Use no preamble to let StreamReader use a non-throwing decoder
             ' when UTF-8 byte order mark found.
             If m_UTF8Throw Is Nothing Then m_UTF8Throw = New System.Text.UTF8Encoding(False, True)
             Return m_UTF8Throw
         End Get
     End Property
 
     Property RelativePath() As String
         Get
             Return m_RelativePath
         End Get
         Set(ByVal value As String)
             m_RelativePath = value
         End Set
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_Imports.ResolveCode(Info)
     End Function
 
     ReadOnly Property OptionExplicit() As OptionExplicitStatement
         Get
             Return m_OptionExplicit
         End Get
     End Property
 
     ReadOnly Property OptionStrict() As OptionStrictStatement
         Get
             Return m_OptionStrict
         End Get
     End Property
 
     ReadOnly Property OptionCompare() As OptionCompareStatement
         Get
             Return m_OptionCompare
         End Get
     End Property
 
     ReadOnly Property OptionInfer As OptionInferStatement
         Get
             Return m_OptionInfer
         End Get
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareText() As Boolean
         Get
             Return Not IsOptionCompareBinary
         End Get
     End Property
 
     ''' <summary>
     ''' The imports clauses this file has.
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsClauses
         Get
             Return m_Imports
         End Get
     End Property
 
     ''' <summary>
     ''' Compare one CodeFile to another based on filename.
     ''' </summary>
     ''' <param name="value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Overrides Function Equals(ByVal value As Object) As Boolean
         Dim file As CodeFile = TryCast(value, CodeFile)
         If file IsNot Nothing Then
             If file Is Me Then
                 Return True
             Else
                 Return Microsoft.VisualBasic.Strings.StrComp(m_FileName, file.FileName, Microsoft.VisualBasic.CompareMethod.Text) = 0
             End If
         Else
             Return False
         End If
     End Function
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
         'Try to get the absolute path for all files.
         If FileName Is Nothing OrElse FileName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars()) >= 0 Then
             m_FileName = FileName
         Else
             m_FileName = IO.Path.GetFullPath(FileName)
         End If
         m_RelativePath = RelativePath
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="367" endline="395">
<![CDATA[
 	
 	void OutlineMethod (MethodInfo mi)
 	{
 		if (MethodIsExplicitIfaceImpl (mi)) {
 			o.Write (FormatType (mi.ReturnType));
 			o.Write (" ");
 			// MSFT has no way to get the method that we are overriding
 			// from the interface. this would allow us to pretty print
 			// the type name (and be more correct if there compiler
 			// were to do some strange naming thing).
 		} else {
 			o.Write (GetMethodVisibility (mi));
 			o.Write (GetMethodModifiers  (mi));
 			o.Write (FormatType (mi.ReturnType));
 			o.Write (" ");
 		}
 
 		o.Write (mi.Name);
 #if NET_2_0
 		o.Write (FormatGenericParams (mi.GetGenericArguments ()));
 #endif
 		o.Write (" (");
 		OutlineParams (mi.GetParameters ());
 		o.Write (")");
 #if NET_2_0
 		WriteGenericConstraints (mi.GetGenericArguments ());
 #endif
 		o.Write (";");
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4096" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="262" endline="277">
<![CDATA[
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
     Private m_ConditionalConstants As New Generic.List(Of ConditionalConstants)
     Private m_ConditionalConstantsLines As New Generic.List(Of UInteger)
 
     Private m_Code As String
 
     Public ReadOnly Property SymbolDocument() As Mono.Cecil.Cil.Document
         Get
             If m_SymbolDocument Is Nothing Then
                 m_SymbolDocument = New Mono.Cecil.Cil.Document(System.IO.Path.Combine(m_RelativePath.Replace("<"c, "["c).Replace(">"c, "]"c), m_FileName.Replace("<"c, "["c).Replace(">"c, "]"c)))
                 m_SymbolDocument.Language = Cil.DocumentLanguage.Basic
                 m_SymbolDocument.LanguageVendor = Cil.DocumentLanguageVendor.Microsoft
                 m_SymbolDocument.Type = Cil.DocumentType.Text
             End If
             Return m_SymbolDocument
         End Get
     End Property
 
     Sub AddConditionalConstants(ByVal Line As UInteger, ByVal Constants As ConditionalConstants)
         m_ConditionalConstants.Add(Constants.Clone)
         m_ConditionalConstantsLines.Add(Line)
     End Sub
 
     Function GetConditionalConstants(ByVal Line As UInteger) As ConditionalConstants
         If m_ConditionalConstantsLines.Count = 0 Then Return Nothing
 
         'If the first #const is after the line, no constants in this file at the line
         If m_ConditionalConstantsLines(0) > Line Then Return Nothing
 
         For i As Integer = 0 To m_ConditionalConstantsLines.Count - 1
             'If the current #const is after the line, the previous one corresponds to the line
             If m_ConditionalConstantsLines(i) > Line Then
                 Return m_ConditionalConstants(i - 1)
             End If
         Next
 
         'If no constants are after the line, the last is the one.
         Return m_ConditionalConstants(m_ConditionalConstants.Count - 1)
     End Function
 
     Private Shared ReadOnly Property UTF8Throw() As System.Text.Encoding
         Get
             ' Use no preamble to let StreamReader use a non-throwing decoder
             ' when UTF-8 byte order mark found.
             If m_UTF8Throw Is Nothing Then m_UTF8Throw = New System.Text.UTF8Encoding(False, True)
             Return m_UTF8Throw
         End Get
     End Property
 
     Property RelativePath() As String
         Get
             Return m_RelativePath
         End Get
         Set(ByVal value As String)
             m_RelativePath = value
         End Set
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_Imports.ResolveCode(Info)
     End Function
 
     ReadOnly Property OptionExplicit() As OptionExplicitStatement
         Get
             Return m_OptionExplicit
         End Get
     End Property
 
     ReadOnly Property OptionStrict() As OptionStrictStatement
         Get
             Return m_OptionStrict
         End Get
     End Property
 
     ReadOnly Property OptionCompare() As OptionCompareStatement
         Get
             Return m_OptionCompare
         End Get
     End Property
 
     ReadOnly Property OptionInfer As OptionInferStatement
         Get
             Return m_OptionInfer
         End Get
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareText() As Boolean
         Get
             Return Not IsOptionCompareBinary
         End Get
     End Property
 
     ''' <summary>
     ''' The imports clauses this file has.
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsClauses
         Get
             Return m_Imports
         End Get
     End Property
 
     ''' <summary>
     ''' Compare one CodeFile to another based on filename.
     ''' </summary>
     ''' <param name="value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Overrides Function Equals(ByVal value As Object) As Boolean
         Dim file As CodeFile = TryCast(value, CodeFile)
         If file IsNot Nothing Then
             If file Is Me Then
                 Return True
             Else
                 Return Microsoft.VisualBasic.Strings.StrComp(m_FileName, file.FileName, Microsoft.VisualBasic.CompareMethod.Text) = 0
             End If
         Else
             Return False
         End If
     End Function
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
         'Try to get the absolute path for all files.
         If FileName Is Nothing OrElse FileName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars()) >= 0 Then
             m_FileName = FileName
         Else
             m_FileName = IO.Path.GetFullPath(FileName)
         End If
         m_RelativePath = RelativePath
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="396" endline="413">
<![CDATA[
 	
 	void OutlineOperator (MethodInfo mi)
 	{
 		o.Write (GetMethodVisibility (mi));
 		o.Write (GetMethodModifiers  (mi));
 		if (mi.Name == "op_Explicit" || mi.Name == "op_Implicit") {
 			o.Write (mi.Name.Substring (3).ToLower ());
 			o.Write (" operator ");
 			o.Write (FormatType (mi.ReturnType));
 		} else {
 			o.Write (FormatType (mi.ReturnType));
 			o.Write (" operator ");
 			o.Write (OperatorFromName (mi.Name));
 		}
 		o.Write (" (");
 		OutlineParams (mi.GetParameters ());
 		o.Write (");");
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4098" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="798" endline="807">
<![CDATA[
 
     Shared Function FilterByName(ByVal collection As Generic.List(Of Type), ByVal Name As String) As Generic.List(Of Type)
         Dim result As New Generic.List(Of Type)
         Dim tmpname As String = ""
         For Each obj As Type In collection
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="399" endline="425">
<![CDATA[
 		}
 
 		internal T? GetFieldValue<T>(string name) where T 
 		{
 			object val = GetFieldValue(name);
 			if (val is T)
 			{
 				return (T)val;
 			}
 			else if (val != null)
 			{
 				if (typeof(T).IsEnum)
 				{
 					Debug.Assert(Enum.GetUnderlyingType(typeof(T)) == val.GetType());
 					return (T)Enum.ToObject(typeof(T), val);
 				}
 				else
 				{
 					Debug.Assert(Enum.GetUnderlyingType(val.GetType()) == typeof(T));
 					return (T)Convert.ChangeType(val, typeof(T));
 				}
 			}
 			else
 			{
 				return null;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4174" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="304" endline="324">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' This function is only used for error reporting, no need to do things fast.
     ''' </summary>
     ''' <param name="LineNumber"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DoesLineEndWithLineContinuation(ByVal LineNumber As UInteger) As Boolean
         Dim lines() As String
         Using stream As IO.StreamReader = CodeStream
             lines = stream.ReadToEnd().Split(New String() {VB.vbCrLf, VB.vbCr, VB.vbLf}, StringSplitOptions.None)
         End Using
         If lines.Length < LineNumber Then Return False
 
         Dim line As String = lines(CInt(LineNumber - 1UI))
         Do While line.Length > 0 AndAlso Scanner.IsWhiteSpace(line(line.Length - 1))
             line = line.Substring(0, line.Length - 1)
         Loop
         Do While line.Length > 0 AndAlso Scanner.IsWhiteSpace(line(line.Length - 1))
             line = line.Substring(0, line.Length - 1)
         Loop
         Return line.EndsWith(" _")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="78" endline="117">
<![CDATA[
 
 		// MemberCore
 		private static readonly string line_head =
 			Environment.NewLine + "            ";
 
 		private static XmlNode GetDocCommentNode (MemberCore mc,
 			string name, Report Report)
 		{
 			// FIXME
 			// to use XmlDocument. But anyways the nodes
 			// are not kept in memory.
 			XmlDocument doc = RootContext.Documentation.XmlDocumentation;
 			try {
 				XmlElement el = doc.CreateElement ("member");
 				el.SetAttribute ("name", name);
 				string normalized = mc.DocComment;
 				el.InnerXml = normalized;
 				// csc keeps lines as written in the sources
 				// and inserts formatting indentation (which 
 				// is different from XmlTextWriter.Formatting
 				// one), but when a start tag contains an 
 				// endline, it joins the next line. We don't
 				// have to follow such a hacky behavior.
 				string [] split =
 					normalized.Split ('\n');
 				int j = 0;
 				for (int i = 0; i < split.Length; i++) {
 					string s = split [i].TrimEnd ();
 					if (s.Length > 0)
 						split [j++] = s;
 				}
 				for (int i = 0; i < split.Length; i++) {
 					string s = split [i].TrimEnd ();
 					if (s.Length > 0)
 						split [j++] = s;
 				}
 				el.InnerXml = line_head + String.Join (
 					line_head, split, 0, j);
 				return el;
 			} catch (Exception ex) {
 				Report.Warning (1570, 1, mc.Location, "XML comment on `{0}' has non-well-formed XML ({1})", name, ex.Message);
 				XmlComment com = doc.CreateComment (String.Format ("FIXME
 				return com;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4189" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="88" endline="114">
<![CDATA[
 	       
 		void tokenize_file (CompilationUnit file, CompilerContext ctx)
 		{
 			Stream input;
 
 			try {
 				input = File.OpenRead (file.Name);
 			} catch {
 				Report.Error (2001, "Source file `" + file.Name + "' could not be found");
 				return;
 			}
 
 			using (input){
 				SeekableStreamReader reader = new SeekableStreamReader (input, RootContext.Encoding);
 				Tokenizer lexer = new Tokenizer (reader, file, ctx);
 				int token, tokens = 0, errors = 0;
 
 				while ((token = lexer.token ()) != Token.EOF){
 					tokens++;
 					if (token == Token.ERROR)
 						errors++;
 				}
 				while ((token = lexer.token ()) != Token.EOF){
 					tokens++;
 					if (token == Token.ERROR)
 						errors++;
 				}
 				Console.WriteLine ("Tokenized
 			}
 			
 			return;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Main.vb" startline="27" endline="96">
<![CDATA[
     Shared Function Main(ByVal CmdArgs() As String) As Integer
         Dim start As Date = Date.Now
         Try
             Dim result As Integer = -2
             Dim Compiler As Compiler
 
 #If DEBUG Then
             Try
                 System.Console.SetWindowSize(150, 50)
                 System.Console.ForegroundColor = ConsoleColor.Green
                 System.Console.WriteLine(VB.vbNewLine & New String(" "c, 50) & "DEBUG RUN" & VB.vbNewLine)
                 System.Console.ResetColor()
                 System.Console.SetBufferSize(150, 3000)
             Catch
                 'Ignore all exceptions.
             End Try
 #End If
 
             Compiler = New Compiler()
 
 #If DEBUG Then
             Dim debugwriter As New IO.StringWriter()
             Compiler.Report.Listeners.Add(New System.Diagnostics.TextWriterTraceListener(debugwriter))
 #End If
 
             result = Compiler.Compile(CmdArgs)
 
 #If DEBUG Then
             Global.System.Diagnostics.Debug.WriteLine("")
             Global.System.Diagnostics.Debug.WriteLine( _
             "***************************************** Console output
             Global.System.Diagnostics.Debug.WriteLine(debugwriter.ToString)
             Global.System.Diagnostics.Debug.WriteLine( _
             "*************************************************************************************************** ")
 #End If
 
             Console.WriteLine("Compilation took " & (Date.Now.Subtract(start)).ToString())
             System.Diagnostics.Debug.WriteLine("Compilation took " & (Date.Now.Subtract(start)).ToString())
 #If DEBUG Then
             'Console.WriteLine("With " & GC.CollectionCount(0) & " 0 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(1) & " 1 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(2) & " 2 gen collections")
             'System.Diagnostics.Debug.WriteLine("With " & GC.CollectionCount(0) & " 0 gen collections")
             'System.Diagnostics.Debug.WriteLine("With " & GC.CollectionCount(1) & " 1 gen collections")
             'System.Diagnostics.Debug.WriteLine("With " & GC.CollectionCount(2) & " 2 gen collections")
             '#End If
 #End If
             Return result
         Catch ex As TooManyErrorsException
             Return 1 'An appropiate message has already been shown to the user
         Catch ex As vbncException
             Console.WriteLine(ex.Message & VB.vbNewLine & ex.StackTrace)
             Console.WriteLine("Failed compilation took " & (Date.Now.Subtract(start)).ToString())
             System.Diagnostics.Debug.WriteLine("Failed compilation took " & (Date.Now.Subtract(start)).ToString())
             'Console.WriteLine("With " & GC.CollectionCount(0) & " 0 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(1) & " 1 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(2) & " 2 gen collections")
             Return 1 'The exception has already been shown to the user.
         Catch ex As Exception
             Console.WriteLine(ex.Message & VB.vbNewLine & ex.StackTrace)
             Console.WriteLine("Failed compilation took " & (Date.Now.Subtract(start)).ToString())
             System.Diagnostics.Debug.WriteLine("Failed compilation took " & (Date.Now.Subtract(start)).ToString())
             'Console.WriteLine("With " & GC.CollectionCount(0) & " 0 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(1) & " 1 gen collections")
             'Console.WriteLine("With " & GC.CollectionCount(2) & " 2 gen collections")
             Return 1
         End Try
         Helper.Assert(False, "End of program reached!")
         Return 1
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4200" nfragments="2" Csharpe_files="1" vb_files="1" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2376" endline="2422">
<![CDATA[
 
     'TODO
     Shared Function HexToInt(ByVal str As String) As ULong
         Dim i, n As Integer
         Dim l As Integer = str.Length
         HexToInt = 0
         For i = l To 1 Step -1
             Select Case str.Chars(i - 1)
                 Case "0"c
                     n = 0
                 Case "1"c
                     n = 1
                 Case "2"c
                     n = 2
                 Case "3"c
                     n = 3
                 Case "4"c
                     n = 4
                 Case "5"c
                     n = 5
                 Case "6"c
                     n = 6
                 Case "7"c
                     n = 7
                 Case "8"c
                     n = 8
                 Case "9"c
                     n = 9
                 Case "a"c, "A"c
                     n = 10
                 Case "b"c, "B"c
                     n = 11
                 Case "c"c, "C"c
                     n = 12
                 Case "d"c, "D"c
                     n = 13
                 Case "e"c, "E"c
                     n = 14
                 Case "f"c, "F"c
                     n = 15
                 Case Else
                     Throw New ArgumentOutOfRangeException("str", str, "Invalid hex number
             End Select
 
             HexToInt += CULng(n * (16 ^ (l - i)))
         Next
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="508" endline="618">
<![CDATA[
 
 		enum InputKind {
 			EOF,
 			StatementOrExpression,
 			CompilationUnit,
 			Error
 		}
 
 		//
 		// Deambiguates the input string to determine if we
 		// want to process a statement or if we want to
 		// process a compilation unit.
 		//
 		// This is done using a top-down predictive parser,
 		// since the yacc/jay parser can not deambiguage this
 		// without more than one lookahead token.   There are very
 		// few ambiguities.
 		//
 		static InputKind ToplevelOrStatement (SeekableStreamReader seekable)
 		{
 			Tokenizer tokenizer = new Tokenizer (seekable, (CompilationUnit) Location.SourceFiles [0], ctx);
 			
 			int t = tokenizer.token ();
 			switch (t){
 			case Token.EOF
 				return InputKind.EOF;
 				
 			// These are toplevels
 			case Token.EXTERN
 			case Token.OPEN_BRACKET
 			case Token.ABSTRACT
 			case Token.CLASS
 			case Token.ENUM
 			case Token.INTERFACE
 			case Token.INTERNAL
 			case Token.NAMESPACE
 			case Token.PRIVATE
 			case Token.PROTECTED
 			case Token.PUBLIC
 			case Token.SEALED
 			case Token.STATIC
 			case Token.STRUCT
 				return InputKind.CompilationUnit;
 				
 			// Definitely expression
 			case Token.FIXED
 			case Token.BOOL
 			case Token.BYTE
 			case Token.CHAR
 			case Token.DECIMAL
 			case Token.DOUBLE
 			case Token.FLOAT
 			case Token.INT
 			case Token.LONG
 			case Token.NEW
 			case Token.OBJECT
 			case Token.SBYTE
 			case Token.SHORT
 			case Token.STRING
 			case Token.UINT
 			case Token.ULONG
 				return InputKind.StatementOrExpression;
 
 			// These need deambiguation help
 			case Token.USING
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 
 				if (t == Token.IDENTIFIER)
 					return InputKind.CompilationUnit;
 				return InputKind.StatementOrExpression;
 
 
 			// Distinguish between
 			//    delegate opt_anonymous_method_signature block
 			//    delegate type 
 			case Token.DELEGATE
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 				if (t == Token.OPEN_PARENS || t == Token.OPEN_BRACE)
 					return InputKind.StatementOrExpression;
 				return InputKind.CompilationUnit;
 
 			// Distinguih between
 			//    unsafe block
 			//    unsafe as modifier of a type declaration
 			case Token.UNSAFE
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 				if (t == Token.OPEN_PARENS)
 					return InputKind.StatementOrExpression;
 				return InputKind.CompilationUnit;
 				
 		        // These are errors
 			// from the grammar, ERROR and then everything else
 
 			case Token.READONLY
 			case Token.OVERRIDE
 			case Token.ERROR
 				return InputKind.Error;
 
 			// This catches everything else allowed by
 			// expressions.  We could add one-by-one use cases
 			// if needed.
 			default
 				return InputKind.StatementOrExpression;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
</clones>
