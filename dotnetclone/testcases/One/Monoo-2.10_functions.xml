<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="48" endline="51">
static private int ToInt32LE (byte [] bytes, int offset) {
    return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="53" endline="56">
static private uint ToUInt32LE (byte [] bytes, int offset) {
    return (uint) ((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="58" endline="66">
static private byte [] GetBytesLE (int val) {
    return new byte [] {(byte) (val & 0xff), (byte) ((val > > 8) & 0xff), (byte) ((val > > 16) & 0xff), (byte) ((val > > 24) & 0xff)};
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="68" endline="78">
static private byte [] Trim (byte [] array) {
    for (int i = 0; i < array.Length; i ++) {
        if (array [i] != 0x00) {
            byte [] result = new byte [array.Length - i];
            Buffer.BlockCopy (array, i, result, 0, result.Length);
            return result;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="83" endline="86">
static public RSA FromCapiPrivateKeyBlob (byte [] blob) {
    return FromCapiPrivateKeyBlob (blob, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="88" endline="195">
static public RSA FromCapiPrivateKeyBlob (byte [] blob, int offset) {
    if (blob == null)
        throw new ArgumentNullException ("blob");

    if (offset >= blob.Length)
        throw new ArgumentException ("blob is too small.");

    RSAParameters rsap = new RSAParameters ();
    try {
        if ((blob [offset] != 0x07) || (blob [offset + 1] != 0x02) || (blob [offset + 2] != 0x00) || (blob [offset + 3] != 0x00) || (ToUInt32LE (blob, offset + 8) != 0x32415352))
            throw new CryptographicException ("Invalid blob header");

        int bitLen = ToInt32LE (blob, offset + 12);
        byte [] exp = new byte [4];
        Buffer.BlockCopy (blob, offset + 16, exp, 0, 4);
        Array.Reverse (exp);
        rsap.Exponent = Trim (exp);
        int pos = offset + 20;
        int byteLen = (bitLen > > 3);
        rsap.Modulus = new byte [byteLen];
        Buffer.BlockCopy (blob, pos, rsap.Modulus, 0, byteLen);
        Array.Reverse (rsap.Modulus);
        pos += byteLen;
        int byteHalfLen = (byteLen > > 1);
        rsap.P = new byte [byteHalfLen];
        Buffer.BlockCopy (blob, pos, rsap.P, 0, byteHalfLen);
        Array.Reverse (rsap.P);
        pos += byteHalfLen;
        rsap.Q = new byte [byteHalfLen];
        Buffer.BlockCopy (blob, pos, rsap.Q, 0, byteHalfLen);
        Array.Reverse (rsap.Q);
        pos += byteHalfLen;
        rsap.DP = new byte [byteHalfLen];
        Buffer.BlockCopy (blob, pos, rsap.DP, 0, byteHalfLen);
        Array.Reverse (rsap.DP);
        pos += byteHalfLen;
        rsap.DQ = new byte [byteHalfLen];
        Buffer.BlockCopy (blob, pos, rsap.DQ, 0, byteHalfLen);
        Array.Reverse (rsap.DQ);
        pos += byteHalfLen;
        rsap.InverseQ = new byte [byteHalfLen];
        Buffer.BlockCopy (blob, pos, rsap.InverseQ, 0, byteHalfLen);
        Array.Reverse (rsap.InverseQ);
        pos += byteHalfLen;
        rsap.D = new byte [byteLen];
        if (pos + byteLen + offset <= blob.Length) {
            Buffer.BlockCopy (blob, pos, rsap.D, 0, byteLen);
            Array.Reverse (rsap.D);
        }
    }
    catch (Exception e) {
        throw new CryptographicException ("Invalid blob.", e);
    }
    RSA rsa = null;
    try {
        rsa = RSA.Create ();
        rsa.ImportParameters (rsap);
    }
    catch (CryptographicException ce) {
        try {
            CspParameters csp = new CspParameters ();
            csp.Flags = CspProviderFlags.UseMachineKeyStore;
            rsa = new RSACryptoServiceProvider (csp);
            rsa.ImportParameters (rsap);
        }
        catch {
            throw ce;
        }
    }
    return rsa;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="197" endline="200">
static public DSA FromCapiPrivateKeyBlobDSA (byte [] blob) {
    return FromCapiPrivateKeyBlobDSA (blob, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="202" endline="280">
static public DSA FromCapiPrivateKeyBlobDSA (byte [] blob, int offset) {
    if (blob == null)
        throw new ArgumentNullException ("blob");

    if (offset >= blob.Length)
        throw new ArgumentException ("blob is too small.");

    DSAParameters dsap = new DSAParameters ();
    try {
        if ((blob [offset] != 0x07) || (blob [offset + 1] != 0x02) || (blob [offset + 2] != 0x00) || (blob [offset + 3] != 0x00) || (ToUInt32LE (blob, offset + 8) != 0x32535344))
            throw new CryptographicException ("Invalid blob header");

        int bitlen = ToInt32LE (blob, offset + 12);
        int bytelen = bitlen > > 3;
        int pos = offset + 16;
        dsap.P = new byte [bytelen];
        Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
        Array.Reverse (dsap.P);
        pos += bytelen;
        dsap.Q = new byte [20];
        Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
        Array.Reverse (dsap.Q);
        pos += 20;
        dsap.G = new byte [bytelen];
        Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
        Array.Reverse (dsap.G);
        pos += bytelen;
        dsap.X = new byte [20];
        Buffer.BlockCopy (blob, pos, dsap.X, 0, 20);
        Array.Reverse (dsap.X);
        pos += 20;
        dsap.Counter = ToInt32LE (blob, pos);
        pos += 4;
        dsap.Seed = new byte [20];
        Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
        Array.Reverse (dsap.Seed);
        pos += 20;
    }
    catch (Exception e) {
        throw new CryptographicException ("Invalid blob.", e);
    }
    DSA dsa = null;
    try {
        dsa = (DSA) DSA.Create ();
        dsa.ImportParameters (dsap);
    }
    catch (CryptographicException ce) {
        try {
            CspParameters csp = new CspParameters ();
            csp.Flags = CspProviderFlags.UseMachineKeyStore;
            dsa = new DSACryptoServiceProvider (csp);
            dsa.ImportParameters (dsap);
        }
        catch {
            throw ce;
        }
    }
    return dsa;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="282" endline="352">
static public byte [] ToCapiPrivateKeyBlob (RSA rsa) {
    RSAParameters p = rsa.ExportParameters (true);
    int keyLength = p.Modulus.Length;
    byte [] blob = new byte [20 + (keyLength << 2) + (keyLength > > 1)];
    blob [0] = 0x07;
    blob [1] = 0x02;
    blob [5] = 0x24;
    blob [8] = 0x52;
    blob [9] = 0x53;
    blob [10] = 0x41;
    blob [11] = 0x32;
    byte [] bitlen = GetBytesLE (keyLength << 3);
    blob [12] = bitlen [0];
    blob [13] = bitlen [1];
    blob [14] = bitlen [2];
    blob [15] = bitlen [3];
    int pos = 16;
    int n = p.Exponent.Length;
    while (n > 0)
        blob [pos ++] = p.Exponent [-- n];

    pos = 20;
    byte [] part = p.Modulus;
    int len = part.Length;
    Array.Reverse (part, 0, len);
    Buffer.BlockCopy (part, 0, blob, pos, len);
    pos += len;
    part = p.P;
    len = part.Length;
    Array.Reverse (part, 0, len);
    Buffer.BlockCopy (part, 0, blob, pos, len);
    pos += len;
    part = p.Q;
    len = part.Length;
    Array.Reverse (part, 0, len);
    Buffer.BlockCopy (part, 0, blob, pos, len);
    pos += len;
    part = p.DP;
    len = part.Length;
    Array.Reverse (part, 0, len);
    Buffer.BlockCopy (part, 0, blob, pos, len);
    pos += len;
    part = p.DQ;
    len = part.Length;
    Array.Reverse (part, 0, len);
    Buffer.BlockCopy (part, 0, blob, pos, len);
    pos += len;
    part = p.InverseQ;
    len = part.Length;
    Array.Reverse (part, 0, len);
    Buffer.BlockCopy (part, 0, blob, pos, len);
    pos += len;
    part = p.D;
    len = part.Length;
    Array.Reverse (part, 0, len);
    Buffer.BlockCopy (part, 0, blob, pos, len);
    return blob;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="354" endline="406">
static public byte [] ToCapiPrivateKeyBlob (DSA dsa) {
    DSAParameters p = dsa.ExportParameters (true);
    int keyLength = p.P.Length;
    byte [] blob = new byte [16 + keyLength + 20 + keyLength + 20 + 4 + 20];
    blob [0] = 0x07;
    blob [1] = 0x02;
    blob [5] = 0x22;
    blob [8] = 0x44;
    blob [9] = 0x53;
    blob [10] = 0x53;
    blob [11] = 0x32;
    byte [] bitlen = GetBytesLE (keyLength << 3);
    blob [12] = bitlen [0];
    blob [13] = bitlen [1];
    blob [14] = bitlen [2];
    blob [15] = bitlen [3];
    int pos = 16;
    byte [] part = p.P;
    Array.Reverse (part);
    Buffer.BlockCopy (part, 0, blob, pos, keyLength);
    pos += keyLength;
    part = p.Q;
    Array.Reverse (part);
    Buffer.BlockCopy (part, 0, blob, pos, 20);
    pos += 20;
    part = p.G;
    Array.Reverse (part);
    Buffer.BlockCopy (part, 0, blob, pos, keyLength);
    pos += keyLength;
    part = p.X;
    Array.Reverse (part);
    Buffer.BlockCopy (part, 0, blob, pos, 20);
    pos += 20;
    Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
    pos += 4;
    part = p.Seed;
    Array.Reverse (part);
    Buffer.BlockCopy (part, 0, blob, pos, 20);
    return blob;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="408" endline="411">
static public RSA FromCapiPublicKeyBlob (byte [] blob) {
    return FromCapiPublicKeyBlob (blob, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="413" endline="471">
static public RSA FromCapiPublicKeyBlob (byte [] blob, int offset) {
    if (blob == null)
        throw new ArgumentNullException ("blob");

    if (offset >= blob.Length)
        throw new ArgumentException ("blob is too small.");

    try {
        if ((blob [offset] != 0x06) || (blob [offset + 1] != 0x02) || (blob [offset + 2] != 0x00) || (blob [offset + 3] != 0x00) || (ToUInt32LE (blob, offset + 8) != 0x31415352))
            throw new CryptographicException ("Invalid blob header");

        int bitLen = ToInt32LE (blob, offset + 12);
        RSAParameters rsap = new RSAParameters ();
        rsap.Exponent = new byte [3];
        rsap.Exponent [0] = blob [offset + 18];
        rsap.Exponent [1] = blob [offset + 17];
        rsap.Exponent [2] = blob [offset + 16];
        int pos = offset + 20;
        int byteLen = (bitLen > > 3);
        rsap.Modulus = new byte [byteLen];
        Buffer.BlockCopy (blob, pos, rsap.Modulus, 0, byteLen);
        Array.Reverse (rsap.Modulus);
        RSA rsa = null;
        try {
            rsa = RSA.Create ();
            rsa.ImportParameters (rsap);
        }
        catch (CryptographicException) {
            CspParameters csp = new CspParameters ();
            csp.Flags = CspProviderFlags.UseMachineKeyStore;
            rsa = new RSACryptoServiceProvider (csp);
            rsa.ImportParameters (rsap);
        }
        return rsa;
    }
    catch (Exception e) {
        throw new CryptographicException ("Invalid blob.", e);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="473" endline="476">
static public DSA FromCapiPublicKeyBlobDSA (byte [] blob) {
    return FromCapiPublicKeyBlobDSA (blob, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="478" endline="533">
static public DSA FromCapiPublicKeyBlobDSA (byte [] blob, int offset) {
    if (blob == null)
        throw new ArgumentNullException ("blob");

    if (offset >= blob.Length)
        throw new ArgumentException ("blob is too small.");

    try {
        if ((blob [offset] != 0x06) || (blob [offset + 1] != 0x02) || (blob [offset + 2] != 0x00) || (blob [offset + 3] != 0x00) || (ToUInt32LE (blob, offset + 8) != 0x31535344))
            throw new CryptographicException ("Invalid blob header");

        int bitlen = ToInt32LE (blob, offset + 12);
        DSAParameters dsap = new DSAParameters ();
        int bytelen = bitlen > > 3;
        int pos = offset + 16;
        dsap.P = new byte [bytelen];
        Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
        Array.Reverse (dsap.P);
        pos += bytelen;
        dsap.Q = new byte [20];
        Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
        Array.Reverse (dsap.Q);
        pos += 20;
        dsap.G = new byte [bytelen];
        Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
        Array.Reverse (dsap.G);
        pos += bytelen;
        dsap.Y = new byte [bytelen];
        Buffer.BlockCopy (blob, pos, dsap.Y, 0, bytelen);
        Array.Reverse (dsap.Y);
        pos += bytelen;
        dsap.Counter = ToInt32LE (blob, pos);
        pos += 4;
        dsap.Seed = new byte [20];
        Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
        Array.Reverse (dsap.Seed);
        pos += 20;
        DSA dsa = (DSA) DSA.Create ();
        dsa.ImportParameters (dsap);
        return dsa;
    }
    catch (Exception e) {
        throw new CryptographicException ("Invalid blob.", e);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="535" endline="569">
static public byte [] ToCapiPublicKeyBlob (RSA rsa) {
    RSAParameters p = rsa.ExportParameters (false);
    int keyLength = p.Modulus.Length;
    byte [] blob = new byte [20 + keyLength];
    blob [0] = 0x06;
    blob [1] = 0x02;
    blob [5] = 0x24;
    blob [8] = 0x52;
    blob [9] = 0x53;
    blob [10] = 0x41;
    blob [11] = 0x31;
    byte [] bitlen = GetBytesLE (keyLength << 3);
    blob [12] = bitlen [0];
    blob [13] = bitlen [1];
    blob [14] = bitlen [2];
    blob [15] = bitlen [3];
    int pos = 16;
    int n = p.Exponent.Length;
    while (n > 0)
        blob [pos ++] = p.Exponent [-- n];

    pos = 20;
    byte [] part = p.Modulus;
    int len = part.Length;
    Array.Reverse (part, 0, len);
    Buffer.BlockCopy (part, 0, blob, pos, len);
    pos += len;
    return blob;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="571" endline="625">
static public byte [] ToCapiPublicKeyBlob (DSA dsa) {
    DSAParameters p = dsa.ExportParameters (false);
    int keyLength = p.P.Length;
    byte [] blob = new byte [16 + keyLength + 20 + keyLength + keyLength + 4 + 20];
    blob [0] = 0x06;
    blob [1] = 0x02;
    blob [5] = 0x22;
    blob [8] = 0x44;
    blob [9] = 0x53;
    blob [10] = 0x53;
    blob [11] = 0x31;
    byte [] bitlen = GetBytesLE (keyLength << 3);
    blob [12] = bitlen [0];
    blob [13] = bitlen [1];
    blob [14] = bitlen [2];
    blob [15] = bitlen [3];
    int pos = 16;
    byte [] part;
    part = p.P;
    Array.Reverse (part);
    Buffer.BlockCopy (part, 0, blob, pos, keyLength);
    pos += keyLength;
    part = p.Q;
    Array.Reverse (part);
    Buffer.BlockCopy (part, 0, blob, pos, 20);
    pos += 20;
    part = p.G;
    Array.Reverse (part);
    Buffer.BlockCopy (part, 0, blob, pos, keyLength);
    pos += keyLength;
    part = p.Y;
    Array.Reverse (part);
    Buffer.BlockCopy (part, 0, blob, pos, keyLength);
    pos += keyLength;
    Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
    pos += 4;
    part = p.Seed;
    Array.Reverse (part);
    Buffer.BlockCopy (part, 0, blob, pos, 20);
    return blob;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="629" endline="632">
static public RSA FromCapiKeyBlob (byte [] blob) {
    return FromCapiKeyBlob (blob, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="634" endline="655">
static public RSA FromCapiKeyBlob (byte [] blob, int offset) {
    if (blob == null)
        throw new ArgumentNullException ("blob");

    if (offset >= blob.Length)
        throw new ArgumentException ("blob is too small.");

    switch (blob [offset]) {
        case 0x00 :
            if (blob [offset + 12] == 0x06) {
                return FromCapiPublicKeyBlob (blob, offset + 12);
            }
            break;
        case 0x06 :
            return FromCapiPublicKeyBlob (blob, offset);
        case 0x07 :
            return FromCapiPrivateKeyBlob (blob, offset);
    }
    throw new CryptographicException ("Unknown blob format.");
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="657" endline="660">
static public DSA FromCapiKeyBlobDSA (byte [] blob) {
    return FromCapiKeyBlobDSA (blob, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="662" endline="676">
static public DSA FromCapiKeyBlobDSA (byte [] blob, int offset) {
    if (blob == null)
        throw new ArgumentNullException ("blob");

    if (offset >= blob.Length)
        throw new ArgumentException ("blob is too small.");

    switch (blob [offset]) {
        case 0x06 :
            return FromCapiPublicKeyBlobDSA (blob, offset);
        case 0x07 :
            return FromCapiPrivateKeyBlobDSA (blob, offset);
    }
    throw new CryptographicException ("Unknown blob format.");
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="678" endline="690">
static public byte [] ToCapiKeyBlob (AsymmetricAlgorithm keypair, bool includePrivateKey) {
    if (keypair == null)
        throw new ArgumentNullException ("keypair");

    if (keypair is RSA)
        return ToCapiKeyBlob ((RSA) keypair, includePrivateKey);
    else if (keypair is DSA)
        return ToCapiKeyBlob ((DSA) keypair, includePrivateKey);
    else
        return null;

}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="692" endline="701">
static public byte [] ToCapiKeyBlob (RSA rsa, bool includePrivateKey) {
    if (rsa == null)
        throw new ArgumentNullException ("rsa");

    if (includePrivateKey)
        return ToCapiPrivateKeyBlob (rsa);
    else
        return ToCapiPublicKeyBlob (rsa);

}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="703" endline="712">
static public byte [] ToCapiKeyBlob (DSA dsa, bool includePrivateKey) {
    if (dsa == null)
        throw new ArgumentNullException ("dsa");

    if (includePrivateKey)
        return ToCapiPrivateKeyBlob (dsa);
    else
        return ToCapiPublicKeyBlob (dsa);

}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="714" endline="724">
static public string ToHex (byte [] input) {
    if (input == null)
        return null;

    StringBuilder sb = new StringBuilder (input.Length * 2);
    foreach (byte b in input) {
        sb.Append (b.ToString ("X2", CultureInfo.InvariantCulture));
    }
    return sb.ToString ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="726" endline="735">
static private byte FromHexChar (char c) {
    if ((c >= 'a') && (c <= 'f'))
        return (byte) (c - 'a' + 10);

    if ((c >= 'A') && (c <= 'F'))
        return (byte) (c - 'A' + 10);

    if ((c >= '0') && (c <= '9'))
        return (byte) (c - '0');

    throw new ArgumentException ("invalid hex char");
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/corlib/Mono.Security.Cryptography/CryptoConvert.cs.ifdefed" startline="737" endline="752">
static public byte [] FromHex (string hex) {
    if (hex == null)
        return null;

    if ((hex.Length & 0x1) == 0x1)
        throw new ArgumentException ("Length must be a multiple of 2");

    byte [] result = new byte [hex.Length > > 1];
    int n = 0;
    int i = 0;
    while (n < result.Length) {
        result [n] = (byte) (FromHexChar (hex [i ++]) << 4);
        result [n ++] += FromHexChar (hex [i ++]);
    }
    return result;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="55" endline="58">
public Module [] GetModules () {
    return GetModules (true);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="60" endline="63">
public Module [] GetLoadedModules () {
    return GetLoadedModules (true);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="65" endline="68">
public AssemblyName GetName (bool copiedName) {
    return GetName ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="75" endline="86">
public Type [] GetExportedTypes () {
    List < Type > list = new List < Type > ();
    foreach (Type type in GetTypes ()) {
        if (type.IsVisible) {
            list.Add (type);
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="88" endline="91">
public Type GetType (string typeName) {
    return GetType (typeName, false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="93" endline="112">
public Type GetType (string typeName, bool throwOnError) {
    TypeNameParser parser = TypeNameParser.Parse (typeName, throwOnError);
    if (parser.Error) {
        return null;
    }
    if (parser.AssemblyName != null) {
        if (throwOnError) {
            throw new ArgumentException ("Type names passed to Assembly.GetType() must not specify an assembly.");
        } else {
            return null;
        }
    }
    return parser.Expand (GetTypeImpl (parser.FirstNamePart), this, throwOnError, typeName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="114" endline="117">
public virtual Module LoadModule (string moduleName, byte [] rawModule) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="119" endline="122">
public Module LoadModule (string moduleName, byte [] rawModule, byte [] rawSymbolStore) {
    return LoadModule (moduleName, rawModule);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="124" endline="127">
public bool IsDefined (Type attributeType, bool inherit) {
    return CustomAttributeData.__GetCustomAttributes (this, attributeType, inherit).Count != 0;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="129" endline="132">
public IList < CustomAttributeData > __GetCustomAttributes (Type attributeType, bool inherit) {
    return CustomAttributeData.__GetCustomAttributes (this, attributeType, inherit);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="134" endline="137">
public static string CreateQualifiedName (string assemblyName, string typeName) {
    return assemblyName == null ? typeName : typeName + ", " + assemblyName;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Assembly.cs.ifdefed" startline="139" endline="142">
public static Assembly GetAssembly (Type type) {
    return type.Assembly;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/AssemblyName.cs.ifdefed" startline="53" endline="61">
public override string ToString () {
    string str = name.ToString ();
    if (culture != null) {
        str = str.Replace ("Culture=neutral", "Culture=" + culture);
    }
    return str;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/AssemblyName.cs.ifdefed" startline="124" endline="127">
public byte [] GetPublicKey () {
    return name.GetPublicKey ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/AssemblyName.cs.ifdefed" startline="129" endline="132">
public void SetPublicKey (byte [] publicKey) {
    name.SetPublicKey (publicKey);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/AssemblyName.cs.ifdefed" startline="134" endline="137">
public byte [] GetPublicKeyToken () {
    return name.GetPublicKeyToken ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/AssemblyName.cs.ifdefed" startline="139" endline="142">
public void SetPublicKeyToken (byte [] publicKeyToken) {
    name.SetPublicKeyToken (publicKeyToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/AssemblyName.cs.ifdefed" startline="163" endline="167">
public override bool Equals (object obj) {
    AssemblyName other = obj as AssemblyName;
    return other != null && other.FullName == this.FullName;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/AssemblyName.cs.ifdefed" startline="169" endline="172">
public override int GetHashCode () {
    return FullName.GetHashCode ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/AssemblyName.cs.ifdefed" startline="174" endline="177">
public object Clone () {
    return new AssemblyName ((System.Reflection.AssemblyName) name.Clone (), culture);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/AssemblyName.cs.ifdefed" startline="179" endline="182">
public static bool ReferenceMatchesDefinition (AssemblyName reference, AssemblyName definition) {
    return System.Reflection.AssemblyName.ReferenceMatchesDefinition (reference.name, definition.name);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/AssemblyName.cs.ifdefed" startline="184" endline="207">
public static AssemblyName GetAssemblyName (string path) {
    try {
        path = Path.GetFullPath (path);
        using (FileStream fs = new FileStream (path, FileMode.Open, FileAccess.Read, FileShare.Read))
        {
            ModuleReader module = new ModuleReader (null, null, fs, path);
            if (module.Assembly == null) {
                throw new BadImageFormatException ("Module does not contain a manifest");
            }
            return module.Assembly.GetName ();
        }}
    catch (IOException x) {
        throw new FileNotFoundException (x.Message, x);
    }
    catch (UnauthorizedAccessException x) {
        throw new FileNotFoundException (x.Message, x);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="36" endline="39">
internal override MethodBase BindTypeParameters (Type type) {
    return new ConstructorInfoImpl ((MethodInfo) GetMethodInfo ().BindTypeParameters (type));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="51" endline="59">
public sealed override ParameterInfo [] GetParameters () {
    ParameterInfo [] parameters = GetMethodInfo ().GetParameters ();
    for (int i = 0; i < parameters.Length; i ++) {
        parameters [i] = new ParameterInfoWrapper (this, parameters [i]);
    }
    return parameters;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="97" endline="100">
public override Type [] GetOptionalCustomModifiers () {
    return forward.GetOptionalCustomModifiers ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="102" endline="105">
public override Type [] GetRequiredCustomModifiers () {
    return forward.GetRequiredCustomModifiers ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="122" endline="125">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    return forward.GetCustomAttributesData (attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="138" endline="142">
public override bool Equals (object obj) {
    ConstructorInfoImpl other = obj as ConstructorInfoImpl;
    return other != null && other.method.Equals (method);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="144" endline="147">
public override int GetHashCode () {
    return method.GetHashCode ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="149" endline="152">
public override MethodBody GetMethodBody () {
    return method.GetMethodBody ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="164" endline="167">
public override MethodImplAttributes GetMethodImplementationFlags () {
    return method.GetMethodImplementationFlags ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="184" endline="187">
public override string ToString () {
    return method.ToString ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="199" endline="202">
internal override MethodInfo GetMethodInfo () {
    return method;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="204" endline="207">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    return method.GetCustomAttributesData (attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="209" endline="212">
internal override MethodInfo GetMethodOnTypeDefinition () {
    return method.GetMethodOnTypeDefinition ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/ConstructorInfo.cs.ifdefed" startline="219" endline="222">
internal override int ImportTo (Emit.ModuleBuilder module) {
    return method.ImportTo (module);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="89" endline="113">
public override string ToString () {
    StringBuilder sb = new StringBuilder ();
    sb.Append ('[');
    sb.Append (Constructor.DeclaringType.FullName);
    sb.Append ('(');
    string sep = "";
    foreach (CustomAttributeTypedArgument arg in ConstructorArguments) {
        sb.Append (sep);
        sep = ", ";
        AppendValue (sb, arg);
    }
    foreach (CustomAttributeNamedArgument named in NamedArguments) {
        sb.Append (sep);
        sep = ", ";
        sb.Append (named.MemberInfo.Name);
        sb.Append (" = ");
        AppendValue (sb, named.TypedValue);
    }
    sb.Append (')');
    sb.Append (']');
    return sb.ToString ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="115" endline="131">
private static void AppendValue (StringBuilder sb, CustomAttributeTypedArgument arg) {
    if (arg.ArgumentType == arg.ArgumentType.Module.universe.System_String) {
        sb.Append ('"').Append (arg.Value).Append ('"');
    } else {
        if (arg.ArgumentType.IsEnum) {
            sb.Append ('(');
            sb.Append (arg.ArgumentType.FullName);
            sb.Append (')');
        }
        sb.Append (arg.Value);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="133" endline="173">
internal static void ReadDeclarativeSecurity (Assembly asm, List < CustomAttributeData > list, int action, ByteReader br) {
    Universe u = asm.universe;
    if (br.PeekByte () == '.') {
        br.ReadByte ();
        int count = br.ReadCompressedInt ();
        for (int j = 0; j < count; j ++) {
            Type type = ReadType (asm, br);
            ConstructorInfo constructor;
            if (type == u.System_Security_Permissions_HostProtectionAttribute && action == (int) System.Security.Permissions.SecurityAction.LinkDemand) {
                constructor = type.GetConstructor (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null);
            } else {
                constructor = type.GetConstructor (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type [] {u.System_Security_Permissions_SecurityAction}, null);
            }
            ByteReader slice = br.Slice (br.ReadCompressedInt ());
            list.Add (new CustomAttributeData (constructor, action, ReadNamedArguments (asm, slice, slice.ReadCompressedInt (), type)));
        }
    } else {
        char [] buf = new char [br.Length / 2];
        for (int i = 0; i < buf.Length; i ++) {
            buf [i] = br.ReadChar ();
        }
        string xml = new String (buf);
        ConstructorInfo constructor = u.System_Security_Permissions_PermissionSetAttribute.GetConstructor (new Type [] {u.System_Security_Permissions_SecurityAction});
        List < CustomAttributeNamedArgument > args = new List < CustomAttributeNamedArgument > ();
        args.Add (new CustomAttributeNamedArgument (u.System_Security_Permissions_PermissionSetAttribute.GetProperty ("XML"), new CustomAttributeTypedArgument (u.System_String, xml)));
        list.Add (new CustomAttributeData (constructor, action, args));
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="185" endline="227">
private static Type ReadFieldOrPropType (Assembly asm, ByteReader br) {
    Universe u = asm.universe;
    switch (br.ReadByte ()) {
        case Signature.ELEMENT_TYPE_BOOLEAN :
            return u.System_Boolean;
        case Signature.ELEMENT_TYPE_CHAR :
            return u.System_Char;
        case Signature.ELEMENT_TYPE_I1 :
            return u.System_SByte;
        case Signature.ELEMENT_TYPE_U1 :
            return u.System_Byte;
        case Signature.ELEMENT_TYPE_I2 :
            return u.System_Int16;
        case Signature.ELEMENT_TYPE_U2 :
            return u.System_UInt16;
        case Signature.ELEMENT_TYPE_I4 :
            return u.System_Int32;
        case Signature.ELEMENT_TYPE_U4 :
            return u.System_UInt32;
        case Signature.ELEMENT_TYPE_I8 :
            return u.System_Int64;
        case Signature.ELEMENT_TYPE_U8 :
            return u.System_UInt64;
        case Signature.ELEMENT_TYPE_R4 :
            return u.System_Single;
        case Signature.ELEMENT_TYPE_R8 :
            return u.System_Double;
        case Signature.ELEMENT_TYPE_STRING :
            return u.System_String;
        case Signature.ELEMENT_TYPE_SZARRAY :
            return ReadFieldOrPropType (asm, br).MakeArrayType ();
        case 0x55 :
            return ReadType (asm, br);
        case 0x50 :
            return u.System_Type;
        case 0x51 :
            return u.System_Object;
        default :
            throw new InvalidOperationException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="229" endline="295">
private static CustomAttributeTypedArgument ReadFixedArg (Assembly asm, ByteReader br, Type type) {
    Universe u = asm.universe;
    if (type == u.System_String) {
        return new CustomAttributeTypedArgument (type, br.ReadString ());
    } else if (type == u.System_Type) {
        return new CustomAttributeTypedArgument (type, ReadType (asm, br));
    } else if (type == u.System_Object) {
        return ReadFixedArg (asm, br, ReadFieldOrPropType (asm, br));
    } else if (type.IsArray) {
        int length = br.ReadInt32 ();
        if (length == - 1) {
            return new CustomAttributeTypedArgument (type, null);
        }
        Type elementType = type.GetElementType ();
        CustomAttributeTypedArgument [] array = new CustomAttributeTypedArgument [length];
        for (int i = 0; i < length; i ++) {
            array [i] = ReadFixedArg (asm, br, elementType);
        }
        return new CustomAttributeTypedArgument (type, array);
    } else if (type.IsEnum) {
        return new CustomAttributeTypedArgument (type, ReadFixedArg (asm, br, type.GetEnumUnderlyingTypeImpl ()).Value);
    } else {
        switch (Type.GetTypeCode (type)) {
            case TypeCode.Boolean :
                return new CustomAttributeTypedArgument (type, br.ReadByte () != 0);
            case TypeCode.Char :
                return new CustomAttributeTypedArgument (type, br.ReadChar ());
            case TypeCode.Single :
                return new CustomAttributeTypedArgument (type, br.ReadSingle ());
            case TypeCode.Double :
                return new CustomAttributeTypedArgument (type, br.ReadDouble ());
            case TypeCode.SByte :
                return new CustomAttributeTypedArgument (type, br.ReadSByte ());
            case TypeCode.Int16 :
                return new CustomAttributeTypedArgument (type, br.ReadInt16 ());
            case TypeCode.Int32 :
                return new CustomAttributeTypedArgument (type, br.ReadInt32 ());
            case TypeCode.Int64 :
                return new CustomAttributeTypedArgument (type, br.ReadInt64 ());
            case TypeCode.Byte :
                return new CustomAttributeTypedArgument (type, br.ReadByte ());
            case TypeCode.UInt16 :
                return new CustomAttributeTypedArgument (type, br.ReadUInt16 ());
            case TypeCode.UInt32 :
                return new CustomAttributeTypedArgument (type, br.ReadUInt32 ());
            case TypeCode.UInt64 :
                return new CustomAttributeTypedArgument (type, br.ReadUInt64 ());
            default :
                throw new InvalidOperationException ();
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="297" endline="310">
private static Type ReadType (Assembly asm, ByteReader br) {
    string typeName = br.ReadString ();
    if (typeName == null) {
        return null;
    }
    if (typeName.Length > 0 && typeName [typeName.Length - 1] == 0) {
        typeName = typeName.Substring (0, typeName.Length - 1);
    }
    return asm.universe.GetType (asm, typeName, true);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="312" endline="322">
private static IList < CustomAttributeTypedArgument > ReadConstructorArguments (Assembly asm, ByteReader br, ConstructorInfo constructor) {
    MethodSignature sig = constructor.MethodSignature;
    int count = sig.GetParameterCount ();
    List < CustomAttributeTypedArgument > list = new List < CustomAttributeTypedArgument > (count);
    for (int i = 0; i < count; i ++) {
        list.Add (ReadFixedArg (asm, br, sig.GetParameterType (i)));
    }
    return list.AsReadOnly ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="324" endline="352">
private static IList < CustomAttributeNamedArgument > ReadNamedArguments (Assembly asm, ByteReader br, int named, Type type) {
    List < CustomAttributeNamedArgument > list = new List < CustomAttributeNamedArgument > (named);
    for (int i = 0; i < named; i ++) {
        byte fieldOrProperty = br.ReadByte ();
        Type fieldOrPropertyType = ReadFieldOrPropType (asm, br);
        string name = br.ReadString ();
        CustomAttributeTypedArgument value = ReadFixedArg (asm, br, fieldOrPropertyType);
        MemberInfo member;
        switch (fieldOrProperty) {
            case 0x53 :
                member = GetField (type, name);
                break;
            case 0x54 :
                member = GetProperty (type, name);
                break;
            default :
                throw new BadImageFormatException ();
        }
        if (member == null) {
            throw new BadImageFormatException ();
        }
        list.Add (new CustomAttributeNamedArgument (member, value));
    }
    return list.AsReadOnly ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="354" endline="367">
private static FieldInfo GetField (Type type, string name) {
    for (; type != null; type = type.BaseType) {
        foreach (FieldInfo field in type.__GetDeclaredFields ()) {
            if (field.IsPublic && ! field.IsStatic && field.Name == name) {
                return field;
            }
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="369" endline="382">
private static PropertyInfo GetProperty (Type type, string name) {
    for (; type != null; type = type.BaseType) {
        foreach (PropertyInfo property in type.__GetDeclaredProperties ()) {
            if (property.IsPublic && ! property.IsStatic && property.Name == name) {
                return property;
            }
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="384" endline="409">
public void __ReadTypeName (out string ns, out string name) {
    if (lazyConstructor == null) {
        ModuleReader mod = module as ModuleReader;
        if (mod != null) {
            int methodToken = mod.CustomAttribute.records [index].Type;
            if ((methodToken > > 24) == MemberRefTable.Index) {
                int methodIndex = (methodToken & 0xFFFFFF) - 1;
                int typeToken = mod.MemberRef.records [methodIndex].Class;
                if ((typeToken > > 24) == TypeRefTable.Index) {
                    int typeIndex = (typeToken & 0xFFFFFF) - 1;
                    int typeNameSpace = mod.TypeRef.records [typeIndex].TypeNameSpace;
                    ns = typeNameSpace == 0 ? null : mod.GetString (typeNameSpace);
                    name = mod.GetString (mod.TypeRef.records [typeIndex].TypeName);
                    return;
                }
            }
        }
    }
    ns = Constructor.DeclaringType.Namespace;
    name = Constructor.DeclaringType.Name;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="447" endline="465">
private void LazyParseArguments () {
    ByteReader br = module.GetBlob (module.CustomAttribute.records [index].Value);
    if (br.Length == 0) {
        lazyConstructorArguments = Empty < CustomAttributeTypedArgument >.Array;
        lazyNamedArguments = Empty < CustomAttributeNamedArgument >.Array;
    } else {
        if (br.ReadUInt16 () != 1) {
            throw new BadImageFormatException ();
        }
        lazyConstructorArguments = ReadConstructorArguments (module.Assembly, br, Constructor);
        lazyNamedArguments = ReadNamedArguments (module.Assembly, br, br.ReadUInt16 (), Constructor.DeclaringType);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="467" endline="492">
public CustomAttributeBuilder __ToBuilder () {
    object [] args = new object [ConstructorArguments.Count];
    for (int i = 0; i < args.Length; i ++) {
        args [i] = ConstructorArguments [i].Value;
    }
    List < PropertyInfo > namedProperties = new List < PropertyInfo > ();
    List < object > propertyValues = new List < object > ();
    List < FieldInfo > namedFields = new List < FieldInfo > ();
    List < object > fieldValues = new List < object > ();
    foreach (CustomAttributeNamedArgument named in NamedArguments) {
        if (named.MemberInfo is PropertyInfo) {
            namedProperties.Add ((PropertyInfo) named.MemberInfo);
            propertyValues.Add (named.TypedValue.Value);
        } else {
            namedFields.Add ((FieldInfo) named.MemberInfo);
            fieldValues.Add (named.TypedValue.Value);
        }
    }
    return new CustomAttributeBuilder (Constructor, args, namedProperties.ToArray (), propertyValues.ToArray (), namedFields.ToArray (), fieldValues.ToArray ());
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="494" endline="497">
public static IList < CustomAttributeData > GetCustomAttributes (MemberInfo member) {
    return member.GetCustomAttributesData (null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="499" endline="502">
public static IList < CustomAttributeData > GetCustomAttributes (Assembly assembly) {
    return assembly.GetCustomAttributesData (null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="504" endline="507">
public static IList < CustomAttributeData > GetCustomAttributes (Module module) {
    return module.GetCustomAttributesData (null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="509" endline="512">
public static IList < CustomAttributeData > GetCustomAttributes (ParameterInfo parameter) {
    return parameter.GetCustomAttributesData (null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="514" endline="517">
public static IList < CustomAttributeData > __GetCustomAttributes (Assembly assembly, Type attributeType, bool inherit) {
    return assembly.GetCustomAttributesData (attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="519" endline="522">
public static IList < CustomAttributeData > __GetCustomAttributes (Module module, Type attributeType, bool inherit) {
    return module.GetCustomAttributesData (attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="524" endline="527">
public static IList < CustomAttributeData > __GetCustomAttributes (ParameterInfo parameter, Type attributeType, bool inherit) {
    return parameter.GetCustomAttributesData (attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="529" endline="564">
public static IList < CustomAttributeData > __GetCustomAttributes (MemberInfo member, Type attributeType, bool inherit) {
    if (! inherit || ! IsInheritableAttribute (attributeType)) {
        return member.GetCustomAttributesData (attributeType);
    }
    List < CustomAttributeData > list = new List < CustomAttributeData > ();
    for (;;) {
        list.AddRange (member.GetCustomAttributesData (attributeType));
        Type type = member as Type;
        if (type != null) {
            type = type.BaseType;
            if (type == null) {
                return list;
            }
            member = type;
            continue;
        }
        MethodInfo method = member as MethodInfo;
        if (method != null) {
            MemberInfo prev = member;
            method = method.GetBaseDefinition ();
            if (method == null || method == prev) {
                return list;
            }
            member = method;
            continue;
        }
        return list;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="566" endline="569">
public static IList < CustomAttributeData > __GetDeclarativeSecurity (Assembly assembly) {
    return assembly.ManifestModule.GetDeclarativeSecurity (0x20000001);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="571" endline="581">
public static IList < CustomAttributeData > __GetDeclarativeSecurity (Type type) {
    if ((type.Attributes & TypeAttributes.HasSecurity) != 0) {
        return type.Module.GetDeclarativeSecurity (type.MetadataToken);
    } else {
        return EmptyList;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="583" endline="593">
public static IList < CustomAttributeData > __GetDeclarativeSecurity (MethodBase method) {
    if ((method.Attributes & MethodAttributes.HasSecurity) != 0) {
        return method.Module.GetDeclarativeSecurity (method.MetadataToken);
    } else {
        return EmptyList;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/CustomAttributeData.cs.ifdefed" startline="595" endline="610">
private static bool IsInheritableAttribute (Type attribute) {
    Type attributeUsageAttribute = attribute.Module.universe.System_AttributeUsageAttribute;
    IList < CustomAttributeData > attr = attribute.GetCustomAttributesData (attributeUsageAttribute);
    if (attr.Count != 0) {
        foreach (CustomAttributeNamedArgument named in attr [0].NamedArguments) {
            if (named.MemberInfo.Name == "Inherited") {
                return (bool) named.TypedValue.Value;
            }
        }
    }
    return true;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="117" endline="133">
private void SetVersionHelper (Version version) {
    if (version == null) {
        majorVersion = 0;
        minorVersion = 0;
        buildVersion = 0;
        revisionVersion = 0;
    } else {
        majorVersion = (ushort) version.Major;
        minorVersion = (ushort) version.Minor;
        buildVersion = version.Build == - 1 ? (ushort) 0 : (ushort) version.Build;
        revisionVersion = version.Revision == - 1 ? (ushort) 0 : (ushort) version.Revision;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="135" endline="140">
public void __SetAssemblyVersion (Version version) {
    AssemblyName oldName = GetName ();
    SetVersionHelper (version);
    universe.RenameAssembly (this, oldName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="142" endline="147">
public void __SetAssemblyCulture (string cultureName) {
    AssemblyName oldName = GetName ();
    this.culture = cultureName;
    universe.RenameAssembly (this, oldName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="149" endline="158">
public void __SetAssemblyKeyPair (StrongNameKeyPair keyPair) {
    AssemblyName oldName = GetName ();
    this.keyPair = keyPair;
    if (keyPair != null) {
        this.publicKey = keyPair.PublicKey;
    }
    universe.RenameAssembly (this, oldName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="161" endline="166">
public void __SetAssemblyPublicKey (byte [] publicKey) {
    AssemblyName oldName = GetName ();
    this.publicKey = publicKey == null ? null : (byte []) publicKey.Clone ();
    universe.RenameAssembly (this, oldName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="168" endline="171">
public void __SetAssemblyAlgorithmId (AssemblyHashAlgorithm hashAlgorithm) {
    this.hashAlgorithm = hashAlgorithm;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="173" endline="176">
public void __SetAssemblyFlags (AssemblyNameFlags flags) {
    this.flags = flags;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="178" endline="189">
public override AssemblyName GetName () {
    AssemblyName n = new AssemblyName ();
    n.Name = name;
    n.Version = new Version (majorVersion, minorVersion, buildVersion, revisionVersion);
    n.Culture = culture;
    n.HashAlgorithm = hashAlgorithm;
    n.Flags = flags;
    n.SetPublicKey (publicKey != null ? (byte []) publicKey.Clone () : Empty < byte >.Array);
    n.KeyPair = keyPair;
    return n;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="201" endline="204">
public ModuleBuilder DefineDynamicModule (string name, string fileName) {
    return DefineDynamicModule (name, fileName, false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="206" endline="211">
public ModuleBuilder DefineDynamicModule (string name, string fileName, bool emitSymbolInfo) {
    ModuleBuilder module = new ModuleBuilder (this, name, fileName, emitSymbolInfo);
    modules.Add (module);
    return module;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="213" endline="223">
public ModuleBuilder GetDynamicModule (string name) {
    foreach (ModuleBuilder module in modules) {
        if (module.Name == name) {
            return module;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="225" endline="228">
public void SetCustomAttribute (ConstructorInfo con, byte [] binaryAttribute) {
    SetCustomAttribute (new CustomAttributeBuilder (con, binaryAttribute));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="230" endline="233">
public void SetCustomAttribute (CustomAttributeBuilder customBuilder) {
    customAttributes.Add (customBuilder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="235" endline="238">
public void __AddDeclarativeSecurity (CustomAttributeBuilder customBuilder) {
    declarativeSecurity.Add (customBuilder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="240" endline="243">
public void __AddTypeForwarder (Type type) {
    typeForwarders.Add (type);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="245" endline="248">
public void SetEntryPoint (MethodInfo entryMethod) {
    SetEntryPoint (entryMethod, PEFileKinds.ConsoleApplication);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="250" endline="254">
public void SetEntryPoint (MethodInfo entryMethod, PEFileKinds fileKind) {
    this.entryPoint = entryMethod;
    this.fileKind = fileKind;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="256" endline="259">
public void Save (string assemblyFileName) {
    Save (assemblyFileName, PortableExecutableKinds.ILOnly, ImageFileMachine.I386);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="261" endline="402">
public void Save (string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine) {
    ModuleBuilder manifestModule = null;
    foreach (ModuleBuilder moduleBuilder in modules) {
        moduleBuilder.PopulatePropertyAndEventTables ();
        if (manifestModule == null && string.Compare (moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0) {
            manifestModule = moduleBuilder;
        }
    }
    if (manifestModule == null) {
        manifestModule = DefineDynamicModule ("RefEmit_OnDiskManifestModule", assemblyFileName, false);
    }
    AssemblyTable.Record assemblyRecord = new AssemblyTable.Record ();
    assemblyRecord.HashAlgId = (int) hashAlgorithm;
    assemblyRecord.Name = manifestModule.Strings.Add (name);
    assemblyRecord.MajorVersion = majorVersion;
    assemblyRecord.MinorVersion = minorVersion;
    assemblyRecord.BuildNumber = buildVersion;
    assemblyRecord.RevisionNumber = revisionVersion;
    if (publicKey != null) {
        assemblyRecord.PublicKey = manifestModule.Blobs.Add (ByteBuffer.Wrap (publicKey));
        assemblyRecord.Flags = (int) (flags | AssemblyNameFlags.PublicKey);
    } else {
        assemblyRecord.Flags = (int) (flags & ~ AssemblyNameFlags.PublicKey);
    }
    if (culture != null) {
        assemblyRecord.Culture = manifestModule.Strings.Add (culture);
    }
    int token = 0x20000000 + manifestModule.AssemblyTable.AddRecord (assemblyRecord);
    System.Security.Permissions.SecurityAction requestMinimum = System.Security.Permissions.SecurityAction.RequestMinimum;
    System.Security.Permissions.SecurityAction requestOptional = System.Security.Permissions.SecurityAction.RequestOptional;
    System.Security.Permissions.SecurityAction requestRefuse = System.Security.Permissions.SecurityAction.RequestRefuse;
    if (requiredPermissions != null) {
        manifestModule.AddDeclarativeSecurity (token, requestMinimum, requiredPermissions);
    }
    if (optionalPermissions != null) {
        manifestModule.AddDeclarativeSecurity (token, requestOptional, optionalPermissions);
    }
    if (refusedPermissions != null) {
        manifestModule.AddDeclarativeSecurity (token, requestRefuse, refusedPermissions);
    }
    if (versionInfo != null) {
        versionInfo.SetName (GetName ());
        versionInfo.SetFileName (assemblyFileName);
        foreach (CustomAttributeBuilder cab in customAttributes) {
            if (! cab.HasBlob) {
                versionInfo.SetAttribute (cab);
            }
        }
        ByteBuffer versionInfoData = new ByteBuffer (512);
        versionInfo.Write (versionInfoData);
        if (unmanagedResources == null) {
            unmanagedResources = new ResourceSection ();
        }
        unmanagedResources.AddVersionInfo (versionInfoData);
    }
    foreach (CustomAttributeBuilder cab in customAttributes) {
        manifestModule.SetCustomAttribute (0x20000001, cab);
    }
    manifestModule.AddDeclarativeSecurity (0x20000001, declarativeSecurity);
    foreach (Type type in typeForwarders) {
        manifestModule.AddTypeForwarder (type);
    }
    foreach (ResourceFile resfile in resourceFiles) {
        int fileToken = AddFile (manifestModule, resfile.FileName, 1);
        ManifestResourceTable.Record rec = new ManifestResourceTable.Record ();
        rec.Offset = 0;
        rec.Flags = (int) resfile.Attributes;
        rec.Name = manifestModule.Strings.Add (resfile.Name);
        rec.Implementation = fileToken;
        manifestModule.ManifestResource.AddRecord (rec);
    }
    int entryPointToken = 0;
    foreach (ModuleBuilder moduleBuilder in modules) {
        moduleBuilder.FillAssemblyRefTable ();
        if (moduleBuilder != manifestModule) {
            int fileToken;
            if (entryPoint != null && entryPoint.Module == moduleBuilder) {
                ModuleWriter.WriteModule (null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
                entryPointToken = fileToken = AddFile (manifestModule, moduleBuilder.fileName, 0);
            } else {
                ModuleWriter.WriteModule (null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
                fileToken = AddFile (manifestModule, moduleBuilder.fileName, 0);
            }
            moduleBuilder.ExportTypes (fileToken, manifestModule);
        }
    }
    foreach (Module module in addedModules) {
        int fileToken = AddFile (manifestModule, module.FullyQualifiedName, 0);
        module.ExportTypes (fileToken, manifestModule);
    }
    if (entryPointToken == 0 && entryPoint != null) {
        entryPointToken = entryPoint.MetadataToken;
    }
    ModuleWriter.WriteModule (keyPair, publicKey, manifestModule, fileKind, portableExecutableKind, imageFileMachine, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="404" endline="425">
private int AddFile (ModuleBuilder manifestModule, string fileName, int flags) {
    SHA1Managed hash = new SHA1Managed ();
    string fullPath = fileName;
    if (dir != null) {
        fullPath = Path.Combine (dir, fileName);
    }
    using (FileStream fs = new FileStream (fullPath, FileMode.Open, FileAccess.Read))
    {
        using (CryptoStream cs = new CryptoStream (Stream.Null, hash, CryptoStreamMode.Write))
        {
            byte [] buf = new byte [8192];
            ModuleWriter.HashChunk (fs, cs, buf, (int) fs.Length);
        }} FileTable.Record file = new FileTable.Record ();
    file.Flags = flags;
    file.Name = manifestModule.Strings.Add (Path.GetFileName (fileName));
    file.HashValue = manifestModule.Blobs.Add (ByteBuffer.Wrap (hash.Hash));
    return 0x26000000 + manifestModule.File.AddRecord (file);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="427" endline="430">
public void AddResourceFile (string name, string fileName) {
    AddResourceFile (name, fileName, ResourceAttributes.Public);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="432" endline="439">
public void AddResourceFile (string name, string fileName, ResourceAttributes attribs) {
    ResourceFile resfile = new ResourceFile ();
    resfile.Name = name;
    resfile.FileName = fileName;
    resfile.Attributes = attribs;
    resourceFiles.Add (resfile);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="441" endline="444">
public void DefineVersionInfoResource () {
    versionInfo = new VersionInfo ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="446" endline="454">
public void DefineVersionInfoResource (string product, string productVersion, string company, string copyright, string trademark) {
    versionInfo = new VersionInfo ();
    versionInfo.product = product;
    versionInfo.informationalVersion = productVersion;
    versionInfo.company = company;
    versionInfo.copyright = copyright;
    versionInfo.trademark = trademark;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="456" endline="460">
public void __DefineIconResource (byte [] iconFile) {
    unmanagedResources = new ResourceSection ();
    unmanagedResources.AddIcon (iconFile);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="462" endline="469">
public void __DefineUnmanagedResource (byte [] resource) {
    unmanagedResources = new ResourceSection ();
    unmanagedResources.ExtractResources (resource);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="471" endline="476">
public void DefineUnmanagedResource (string resourceFileName) {
    __DefineUnmanagedResource (File.ReadAllBytes (resourceFileName));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="478" endline="490">
public override Type [] GetTypes () {
    List < Type > list = new List < Type > ();
    foreach (ModuleBuilder module in modules) {
        module.GetTypesImpl (list);
    }
    foreach (Module module in addedModules) {
        module.GetTypesImpl (list);
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="492" endline="511">
internal override Type GetTypeImpl (string typeName) {
    foreach (ModuleBuilder mb in modules) {
        Type type = mb.GetTypeImpl (typeName);
        if (type != null) {
            return type;
        }
    }
    foreach (Module module in addedModules) {
        Type type = module.GetTypeImpl (typeName);
        if (type != null) {
            return type;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="518" endline="522">
public void __SetImageRuntimeVersion (string imageRuntimeVersion, int mdStreamVersion) {
    this.imageRuntimeVersion = imageRuntimeVersion;
    this.mdStreamVersion = mdStreamVersion;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="541" endline="544">
public override AssemblyName [] GetReferencedAssemblies () {
    return Empty < AssemblyName >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="546" endline="549">
public override Module [] GetLoadedModules (bool getResourceModules) {
    return GetModules (getResourceModules);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="551" endline="569">
public override Module [] GetModules (bool getResourceModules) {
    List < Module > list = new List < Module > ();
    foreach (ModuleBuilder module in modules) {
        if (getResourceModules || ! module.IsResource ()) {
            list.Add (module);
        }
    }
    foreach (Module module in addedModules) {
        if (getResourceModules || ! module.IsResource ()) {
            list.Add (module);
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="571" endline="588">
public override Module GetModule (string name) {
    foreach (ModuleBuilder module in modules) {
        if (module.Name.Equals (name, StringComparison.InvariantCultureIgnoreCase)) {
            return module;
        }
    }
    foreach (Module module in addedModules) {
        if (module.Name.Equals (name, StringComparison.InvariantCultureIgnoreCase)) {
            return module;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="590" endline="595">
public Module __AddModule (RawModule module) {
    Module mod = module.ToModule (this);
    addedModules.Add (mod);
    return mod;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="597" endline="600">
public override ManifestResourceInfo GetManifestResourceInfo (string resourceName) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="602" endline="605">
public override string [] GetManifestResourceNames () {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="607" endline="610">
public override Stream GetManifestResourceStream (string resourceName) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="612" endline="623">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    List < CustomAttributeData > list = new List < CustomAttributeData > ();
    foreach (CustomAttributeBuilder cab in customAttributes) {
        if (attributeType == null || attributeType.IsAssignableFrom (cab.Constructor.DeclaringType)) {
            list.Add (cab.ToData (this));
        }
    }
    return list;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="647" endline="650">
internal override Type GetTypeImpl (string typeName) {
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="652" endline="654">
internal override void GetTypesImpl (List < Type > list) {
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="671" endline="674">
public override Type ResolveType (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new ArgumentException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="676" endline="679">
public override MethodBase ResolveMethod (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new ArgumentException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="681" endline="684">
public override FieldInfo ResolveField (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new ArgumentException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="686" endline="689">
public override MemberInfo ResolveMember (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new ArgumentException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="691" endline="694">
public override string ResolveString (int metadataToken) {
    throw new ArgumentException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="696" endline="699">
public override Type [] __ResolveOptionalParameterTypes (int metadataToken) {
    throw new ArgumentException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="706" endline="709">
public override AssemblyName [] __GetReferencedAssemblies () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="711" endline="714">
internal override Type GetModuleType () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/AssemblyBuilder.cs.ifdefed" startline="716" endline="719">
internal override IKVM.Reflection.Reader.ByteReader GetBlob (int blobIndex) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="86" endline="96">
internal void WriteCustomAttributeBlob () {
    WriteUInt16 (1);
    ParameterInfo [] pi = cab.con.GetParameters ();
    for (int i = 0; i < pi.Length; i ++) {
        WriteFixedArg (pi [i].ParameterType, cab.constructorArgs [i]);
    }
    WriteNamedArguments (false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="98" endline="132">
internal void WriteNamedArguments (bool forDeclSecurity) {
    int named = 0;
    if (cab.namedFields != null) {
        named += cab.namedFields.Length;
    }
    if (cab.namedProperties != null) {
        named += cab.namedProperties.Length;
    }
    if (forDeclSecurity) {
        WritePackedLen (named);
    } else {
        WriteUInt16 ((ushort) named);
    }
    if (cab.namedFields != null) {
        for (int i = 0; i < cab.namedFields.Length; i ++) {
            WriteNamedArg (0x53, cab.namedFields [i].FieldType, cab.namedFields [i].Name, cab.fieldValues [i]);
        }
    }
    if (cab.namedProperties != null) {
        for (int i = 0; i < cab.namedProperties.Length; i ++) {
            WriteNamedArg (0x54, cab.namedProperties [i].PropertyType, cab.namedProperties [i].Name, cab.propertyValues [i]);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="134" endline="140">
private void WriteNamedArg (byte fieldOrProperty, Type type, string name, object value) {
    WriteByte (fieldOrProperty);
    WriteFieldOrPropType (type);
    WriteString (name);
    WriteFixedArg (type, value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="142" endline="145">
private void WriteByte (byte value) {
    bb.Write (value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="147" endline="150">
private void WriteUInt16 (ushort value) {
    bb.Write (value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="152" endline="155">
private void WriteInt32 (int value) {
    bb.Write (value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="157" endline="251">
private void WriteFixedArg (Type type, object value) {
    Universe u = moduleBuilder.universe;
    if (type == u.System_String) {
        WriteString ((string) value);
    } else if (type == u.System_Type) {
        WriteTypeName ((Type) value);
    } else if (type == u.System_Object) {
        if (value == null) {
            type = u.System_String;
        } else if (value is Type) {
            type = u.System_Type;
        } else {
            type = u.Import (value.GetType ());
        }
        WriteFieldOrPropType (type);
        WriteFixedArg (type, value);
    } else if (type.IsArray) {
        if (value == null) {
            WriteInt32 (- 1);
        } else {
            Array array = (Array) value;
            Type elemType = type.GetElementType ();
            WriteInt32 (array.Length);
            foreach (object val in array) {
                WriteFixedArg (elemType, val);
            }
        }
    } else if (type.IsEnum) {
        WriteFixedArg (type.GetEnumUnderlyingTypeImpl (), value);
    } else {
        switch (Type.GetTypeCode (type)) {
            case TypeCode.Boolean :
                WriteByte ((bool) value ? (byte) 1 : (byte) 0);
                break;
            case TypeCode.Char :
                WriteUInt16 ((char) value);
                break;
            case TypeCode.SByte :
                WriteByte ((byte) (sbyte) value);
                break;
            case TypeCode.Byte :
                WriteByte ((byte) value);
                break;
            case TypeCode.Int16 :
                WriteUInt16 ((ushort) (short) value);
                break;
            case TypeCode.UInt16 :
                WriteUInt16 ((ushort) value);
                break;
            case TypeCode.Int32 :
                WriteInt32 ((int) value);
                break;
            case TypeCode.UInt32 :
                WriteInt32 ((int) (uint) value);
                break;
            case TypeCode.Int64 :
                WriteInt64 ((long) value);
                break;
            case TypeCode.UInt64 :
                WriteInt64 ((long) (ulong) value);
                break;
            case TypeCode.Single :
                WriteSingle ((float) value);
                break;
            case TypeCode.Double :
                WriteDouble ((double) value);
                break;
            default :
                throw new ArgumentException ();
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="253" endline="256">
private void WriteInt64 (long value) {
    bb.Write (value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="258" endline="261">
private void WriteSingle (float value) {
    bb.Write (value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="263" endline="266">
private void WriteDouble (double value) {
    bb.Write (value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="268" endline="283">
private void WriteTypeName (Type type) {
    string name = null;
    if (type != null) {
        if (type.Assembly == moduleBuilder.Assembly) {
            name = type.FullName;
        } else {
            name = type.AssemblyQualifiedName;
        }
    }
    WriteString (name);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="285" endline="288">
private void WriteString (string val) {
    bb.Write (val);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="290" endline="293">
private void WritePackedLen (int len) {
    bb.WriteCompressedInt (len);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="295" endline="363">
private void WriteFieldOrPropType (Type type) {
    Universe u = type.Module.universe;
    if (type == u.System_Type) {
        WriteByte (0x50);
    } else if (type == u.System_Object) {
        WriteByte (0x51);
    } else if (type.IsArray) {
        WriteByte (0x1D);
        WriteFieldOrPropType (type.GetElementType ());
    } else if (type.IsEnum) {
        WriteByte (0x55);
        WriteTypeName (type);
    } else {
        switch (Type.GetTypeCode (type)) {
            case TypeCode.Boolean :
                WriteByte (0x02);
                break;
            case TypeCode.Char :
                WriteByte (0x03);
                break;
            case TypeCode.SByte :
                WriteByte (0x04);
                break;
            case TypeCode.Byte :
                WriteByte (0x05);
                break;
            case TypeCode.Int16 :
                WriteByte (0x06);
                break;
            case TypeCode.UInt16 :
                WriteByte (0x07);
                break;
            case TypeCode.Int32 :
                WriteByte (0x08);
                break;
            case TypeCode.UInt32 :
                WriteByte (0x09);
                break;
            case TypeCode.Int64 :
                WriteByte (0x0A);
                break;
            case TypeCode.UInt64 :
                WriteByte (0x0B);
                break;
            case TypeCode.Single :
                WriteByte (0x0C);
                break;
            case TypeCode.Double :
                WriteByte (0x0D);
                break;
            case TypeCode.String :
                WriteByte (0x0E);
                break;
            default :
                throw new ArgumentException ();
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="376" endline="389">
internal int WriteBlob (ModuleBuilder moduleBuilder) {
    ByteBuffer bb = new ByteBuffer (100);
    if (blob != null) {
        bb.Write (blob);
    } else {
        BlobWriter bw = new BlobWriter (moduleBuilder, this, bb);
        bw.WriteCustomAttributeBlob ();
    }
    return moduleBuilder.Blobs.Add (bb);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="391" endline="394">
internal object GetConstructorArgument (int pos) {
    return constructorArgs [pos];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="401" endline="425">
internal T ? GetFieldValue < T > (string name) where T : struct {
    object val = GetFieldValue (name);
    if (val is T) {
        return (T) val;
    } else if (val != null) {
        if (typeof (T).IsEnum) {
            Debug.Assert (Enum.GetUnderlyingType (typeof (T)) == val.GetType ());
            return (T) Enum.ToObject (typeof (T), val);
        } else {
            Debug.Assert (Enum.GetUnderlyingType (val.GetType ()) == typeof (T));
            return (T) Convert.ChangeType (val, typeof (T));
        }
    } else {
        return null;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="427" endline="440">
internal object GetFieldValue (string name) {
    if (namedFields != null) {
        for (int i = 0; i < namedFields.Length; i ++) {
            if (namedFields [i].Name == name) {
                return fieldValues [i];
            }
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="442" endline="446">
internal void WriteNamedArgumentsForDeclSecurity (ModuleBuilder moduleBuilder, ByteBuffer bb) {
    BlobWriter bw = new BlobWriter (moduleBuilder, this, bb);
    bw.WriteNamedArguments (true);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="448" endline="473">
internal CustomAttributeData ToData (Assembly asm) {
    if (blob != null) {
        return new CustomAttributeData (asm, con, new IKVM.Reflection.Reader.ByteReader (blob, 0, blob.Length));
    } else {
        List < CustomAttributeNamedArgument > namedArgs = new List < CustomAttributeNamedArgument > ();
        if (namedProperties != null) {
            for (int i = 0; i < namedProperties.Length; i ++) {
                namedArgs.Add (new CustomAttributeNamedArgument (namedProperties [i], new CustomAttributeTypedArgument (namedProperties [i].PropertyType, propertyValues [i])));
            }
        }
        if (namedFields != null) {
            for (int i = 0; i < namedFields.Length; i ++) {
                namedArgs.Add (new CustomAttributeNamedArgument (namedFields [i], new CustomAttributeTypedArgument (namedFields [i].FieldType, fieldValues [i])));
            }
        }
        return new CustomAttributeData (con, constructorArgs, namedArgs);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/CustomAttributeBuilder.cs.ifdefed" startline="480" endline="490">
internal CustomAttributeBuilder DecodeBlob (Assembly asm) {
    if (blob == null) {
        return this;
    } else {
        return ToData (asm).__ToBuilder ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EnumBuilder.cs.ifdefed" startline="61" endline="66">
public FieldBuilder DefineLiteral (string literalName, object literalValue) {
    FieldBuilder fb = typeBuilder.DefineField (literalName, typeBuilder, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
    fb.SetConstant (literalValue);
    return fb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EnumBuilder.cs.ifdefed" startline="68" endline="71">
public Type CreateType () {
    return typeBuilder.CreateType ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EnumBuilder.cs.ifdefed" startline="83" endline="86">
public void SetCustomAttribute (ConstructorInfo con, byte [] binaryAttribute) {
    typeBuilder.SetCustomAttribute (con, binaryAttribute);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EnumBuilder.cs.ifdefed" startline="88" endline="91">
public void SetCustomAttribute (CustomAttributeBuilder customBuilder) {
    typeBuilder.SetCustomAttribute (customBuilder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EnumBuilder.cs.ifdefed" startline="93" endline="96">
public override Type GetEnumUnderlyingType () {
    return fieldBuilder.FieldType;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="52" endline="55">
public void SetAddOnMethod (MethodBuilder mdBuilder) {
    addOnMethod = mdBuilder;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="57" endline="60">
public void SetRemoveOnMethod (MethodBuilder mdBuilder) {
    removeOnMethod = mdBuilder;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="62" endline="65">
public void SetRaiseMethod (MethodBuilder mdBuilder) {
    fireMethod = mdBuilder;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="67" endline="74">
public void AddOtherMethod (MethodBuilder mdBuilder) {
    if (otherMethods == null) {
        otherMethods = new List < MethodBuilder > ();
    }
    otherMethods.Add (mdBuilder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="76" endline="79">
public void SetCustomAttribute (ConstructorInfo con, byte [] binaryAttribute) {
    SetCustomAttribute (new CustomAttributeBuilder (con, binaryAttribute));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="81" endline="96">
public void SetCustomAttribute (CustomAttributeBuilder customBuilder) {
    Universe u = typeBuilder.ModuleBuilder.universe;
    if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute) {
        attributes |= EventAttributes.SpecialName;
    } else {
        if (lazyPseudoToken == 0) {
            lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken ();
        }
        typeBuilder.ModuleBuilder.SetCustomAttribute (lazyPseudoToken, customBuilder);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="103" endline="106">
public override MethodInfo GetAddMethod (bool nonPublic) {
    return nonPublic || (addOnMethod != null && addOnMethod.IsPublic) ? addOnMethod : null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="108" endline="111">
public override MethodInfo GetRemoveMethod (bool nonPublic) {
    return nonPublic || (removeOnMethod != null && removeOnMethod.IsPublic) ? removeOnMethod : null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="113" endline="116">
public override MethodInfo GetRaiseMethod (bool nonPublic) {
    return nonPublic || (fireMethod != null && fireMethod.IsPublic) ? fireMethod : null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="118" endline="132">
public override MethodInfo [] GetOtherMethods (bool nonPublic) {
    List < MethodInfo > list = new List < MethodInfo > ();
    if (otherMethods != null) {
        foreach (MethodInfo method in otherMethods) {
            if (nonPublic || method.IsPublic) {
                list.Add (method);
            }
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="149" endline="156">
public EventToken GetEventToken () {
    if (lazyPseudoToken == 0) {
        lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken ();
    }
    return new EventToken (lazyPseudoToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="163" endline="195">
internal void Bake () {
    EventTable.Record rec = new EventTable.Record ();
    rec.EventFlags = (short) attributes;
    rec.Name = typeBuilder.ModuleBuilder.Strings.Add (name);
    rec.EventType = eventtype;
    int token = 0x14000000 | typeBuilder.ModuleBuilder.Event.AddRecord (rec);
    if (lazyPseudoToken != 0) {
        typeBuilder.ModuleBuilder.RegisterTokenFixup (lazyPseudoToken, token);
    }
    if (addOnMethod != null) {
        AddMethodSemantics (MethodSemanticsTable.AddOn, addOnMethod.MetadataToken, token);
    }
    if (removeOnMethod != null) {
        AddMethodSemantics (MethodSemanticsTable.RemoveOn, removeOnMethod.MetadataToken, token);
    }
    if (fireMethod != null) {
        AddMethodSemantics (MethodSemanticsTable.Fire, fireMethod.MetadataToken, token);
    }
    if (otherMethods != null) {
        foreach (MethodBuilder method in otherMethods) {
            AddMethodSemantics (MethodSemanticsTable.Other, method.MetadataToken, token);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/EventBuilder.cs.ifdefed" startline="197" endline="204">
private void AddMethodSemantics (short semantics, int methodToken, int propertyToken) {
    MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record ();
    rec.Semantics = semantics;
    rec.Method = methodToken;
    rec.Association = propertyToken;
    typeBuilder.ModuleBuilder.MethodSemantics.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="55" endline="59">
public void SetConstant (object defaultValue) {
    attribs |= FieldAttributes.HasDefault;
    typeBuilder.ModuleBuilder.AddConstant (pseudoToken, defaultValue);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="61" endline="64">
public override object GetRawConstantValue () {
    return typeBuilder.Module.Constant.GetRawConstantValue (typeBuilder.Module, this.MetadataToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="66" endline="74">
public void __SetDataAndRVA (byte [] data) {
    attribs |= FieldAttributes.HasFieldRVA;
    FieldRVATable.Record rec = new FieldRVATable.Record ();
    rec.RVA = typeBuilder.ModuleBuilder.initializedData.Position;
    rec.Field = pseudoToken;
    typeBuilder.ModuleBuilder.FieldRVA.AddRecord (rec);
    typeBuilder.ModuleBuilder.initializedData.Write (data);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="76" endline="79">
public override void __GetDataFromRVA (byte [] data, int offset, int length) {
    throw new NotImplementedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="81" endline="84">
public void SetCustomAttribute (ConstructorInfo con, byte [] binaryAttribute) {
    SetCustomAttribute (new CustomAttributeBuilder (con, binaryAttribute));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="86" endline="111">
public void SetCustomAttribute (CustomAttributeBuilder customBuilder) {
    Universe u = this.Module.universe;
    if (customBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_FieldOffsetAttribute) {
        customBuilder = customBuilder.DecodeBlob (this.Module.Assembly);
        SetOffset ((int) customBuilder.GetConstructorArgument (0));
    } else if (customBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_MarshalAsAttribute) {
        MarshalSpec.SetMarshalAsAttribute (typeBuilder.ModuleBuilder, pseudoToken, customBuilder);
        attribs |= FieldAttributes.HasFieldMarshal;
    } else if (customBuilder.Constructor.DeclaringType == u.System_NonSerializedAttribute) {
        attribs |= FieldAttributes.NotSerialized;
    } else if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute) {
        attribs |= FieldAttributes.SpecialName;
    } else {
        typeBuilder.ModuleBuilder.SetCustomAttribute (pseudoToken, customBuilder);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="113" endline="119">
public void SetOffset (int iOffset) {
    FieldLayoutTable.Record rec = new FieldLayoutTable.Record ();
    rec.Offset = iOffset;
    rec.Field = pseudoToken;
    typeBuilder.ModuleBuilder.FieldLayout.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="146" endline="149">
public FieldToken GetToken () {
    return new FieldToken (pseudoToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="151" endline="156">
internal void WriteFieldRecords (MetadataWriter mw) {
    mw.Write ((short) attribs);
    mw.WriteStringIndex (nameIndex);
    mw.WriteBlobIndex (signature);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="158" endline="161">
internal void FixupToken (int token) {
    typeBuilder.ModuleBuilder.RegisterTokenFixup (this.pseudoToken, token);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/FieldBuilder.cs.ifdefed" startline="168" endline="182">
internal override int ImportTo (ModuleBuilder other) {
    if (typeBuilder.IsGenericTypeDefinition) {
        return other.ImportMember (TypeBuilder.GetField (typeBuilder, this));
    } else if (other == typeBuilder.ModuleBuilder) {
        return pseudoToken;
    } else {
        return other.ImportMethodOrField (typeBuilder, name, fieldSig);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="73" endline="76">
public ILGenerator GetILGenerator () {
    return GetILGenerator (16);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="78" endline="85">
public ILGenerator GetILGenerator (int streamSize) {
    if (ilgen == null) {
        ilgen = new ILGenerator (typeBuilder.ModuleBuilder, streamSize);
    }
    return ilgen;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="87" endline="90">
public void SetCustomAttribute (ConstructorInfo con, byte [] binaryAttribute) {
    SetCustomAttribute (new CustomAttributeBuilder (con, binaryAttribute));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="92" endline="105">
private void SetDllImportPseudoCustomAttribute (CustomAttributeBuilder customBuilder) {
    CallingConvention ? callingConvention = customBuilder.GetFieldValue < CallingConvention > ("CallingConvention");
    CharSet ? charSet = customBuilder.GetFieldValue < CharSet > ("CharSet");
    SetDllImportPseudoCustomAttribute ((string) customBuilder.GetConstructorArgument (0), (string) customBuilder.GetFieldValue ("EntryPoint"), callingConvention, charSet, (bool ?) customBuilder.GetFieldValue ("BestFitMapping"), (bool ?) customBuilder.GetFieldValue ("ThrowOnUnmappableChar"), (bool ?) customBuilder.GetFieldValue ("SetLastError"), (bool ?) customBuilder.GetFieldValue ("PreserveSig"), (bool ?) customBuilder.GetFieldValue ("ExactSpelling"));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="107" endline="199">
internal void SetDllImportPseudoCustomAttribute (string dllName, string entryName, CallingConvention ? nativeCallConv, CharSet ? nativeCharSet, bool ? bestFitMapping, bool ? throwOnUnmappableChar, bool ? setLastError, bool ? preserveSig, bool ? exactSpelling) {
    const short NoMangle = 0x0001;
    const short CharSetMask = 0x0006;
    const short CharSetNotSpec = 0x0000;
    const short CharSetAnsi = 0x0002;
    const short CharSetUnicode = 0x0004;
    const short CharSetAuto = 0x0006;
    const short SupportsLastError = 0x0040;
    const short CallConvMask = 0x0700;
    const short CallConvWinapi = 0x0100;
    const short CallConvCdecl = 0x0200;
    const short CallConvStdcall = 0x0300;
    const short CallConvThiscall = 0x0400;
    const short CallConvFastcall = 0x0500;
    const short BestFitOn = 0x0010;
    const short BestFitOff = 0x0020;
    const short CharMapErrorOn = 0x1000;
    const short CharMapErrorOff = 0x2000;
    int name = this.nameIndex;
    short flags = CharSetNotSpec | CallConvWinapi;
    if (bestFitMapping.HasValue) {
        flags |= bestFitMapping.Value ? BestFitOn : BestFitOff;
    }
    if (throwOnUnmappableChar.HasValue) {
        flags |= throwOnUnmappableChar.Value ? CharMapErrorOn : CharMapErrorOff;
    }
    if (nativeCallConv.HasValue) {
        flags &= ~ CallConvMask;
        switch (nativeCallConv.Value) {
            case System.Runtime.InteropServices.CallingConvention.Cdecl :
                flags |= CallConvCdecl;
                break;
            case System.Runtime.InteropServices.CallingConvention.FastCall :
                flags |= CallConvFastcall;
                break;
            case System.Runtime.InteropServices.CallingConvention.StdCall :
                flags |= CallConvStdcall;
                break;
            case System.Runtime.InteropServices.CallingConvention.ThisCall :
                flags |= CallConvThiscall;
                break;
            case System.Runtime.InteropServices.CallingConvention.Winapi :
                flags |= CallConvWinapi;
                break;
        }
    }
    if (nativeCharSet.HasValue) {
        flags &= ~ CharSetMask;
        switch (nativeCharSet.Value) {
            case CharSet.Ansi : case CharSet.None :
                flags |= CharSetAnsi;
                break;
            case CharSet.Auto :
                flags |= CharSetAuto;
                break;
            case CharSet.Unicode :
                flags |= CharSetUnicode;
                break;
        }
    }
    if (entryName != null) {
        name = this.ModuleBuilder.Strings.Add (entryName);
    }
    if (exactSpelling.HasValue && exactSpelling.Value) {
        flags |= NoMangle;
    }
    if (! preserveSig.HasValue || preserveSig.Value) {
        implFlags |= MethodImplAttributes.PreserveSig;
    }
    if (setLastError.HasValue && setLastError.Value) {
        flags |= SupportsLastError;
    }
    ImplMapTable.Record rec = new ImplMapTable.Record ();
    rec.MappingFlags = flags;
    rec.MemberForwarded = pseudoToken;
    rec.ImportName = name;
    rec.ImportScope = this.ModuleBuilder.ModuleRef.FindOrAddRecord (dllName == null ? 0 : this.ModuleBuilder.Strings.Add (dllName));
    this.ModuleBuilder.ImplMap.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="201" endline="235">
private void SetMethodImplAttribute (CustomAttributeBuilder customBuilder) {
    MethodImplOptions opt;
    switch (customBuilder.Constructor.ParameterCount) {
        case 0 :
            opt = 0;
            break;
        case 1 :
            {
                object val = customBuilder.GetConstructorArgument (0);
                if (val is short) {
                    opt = (MethodImplOptions) (short) val;
                } else if (val is int) {
                    opt = (MethodImplOptions) (int) val;
                } else {
                    opt = (MethodImplOptions) val;
                }
                break;
            } default :
            throw new NotSupportedException ();
    }
    MethodCodeType ? type = customBuilder.GetFieldValue < MethodCodeType > ("MethodCodeType");
    implFlags = (MethodImplAttributes) opt;
    if (type.HasValue) {
        implFlags |= (MethodImplAttributes) type;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="237" endline="266">
public void SetCustomAttribute (CustomAttributeBuilder customBuilder) {
    Universe u = this.ModuleBuilder.universe;
    Type type = customBuilder.Constructor.DeclaringType;
    if (type == u.System_Runtime_InteropServices_DllImportAttribute) {
        attributes |= MethodAttributes.PinvokeImpl;
        SetDllImportPseudoCustomAttribute (customBuilder.DecodeBlob (this.Module.Assembly));
    } else if (type == u.System_Runtime_CompilerServices_MethodImplAttribute) {
        SetMethodImplAttribute (customBuilder.DecodeBlob (this.Module.Assembly));
    } else if (type == u.System_Runtime_InteropServices_PreserveSigAttribute) {
        implFlags |= MethodImplAttributes.PreserveSig;
    } else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute) {
        attributes |= MethodAttributes.SpecialName;
    } else {
        if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute) {
            attributes |= MethodAttributes.HasSecurity;
        }
        this.ModuleBuilder.SetCustomAttribute (pseudoToken, customBuilder);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="268" endline="276">
public void __AddDeclarativeSecurity (CustomAttributeBuilder customBuilder) {
    attributes |= MethodAttributes.HasSecurity;
    if (declarativeSecurity == null) {
        declarativeSecurity = new List < CustomAttributeBuilder > ();
    }
    declarativeSecurity.Add (customBuilder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="278" endline="282">
public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction securityAction, System.Security.PermissionSet permissionSet) {
    this.ModuleBuilder.AddDeclarativeSecurity (pseudoToken, securityAction, permissionSet);
    this.attributes |= MethodAttributes.HasSecurity;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="284" endline="287">
public void SetImplementationFlags (MethodImplAttributes attributes) {
    implFlags = attributes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="289" endline="315">
public ParameterBuilder DefineParameter (int position, ParameterAttributes attributes, string strParamName) {
    int sequence = position --;
    if (parameters == null) {
        parameters = new List < ParameterBuilder > ();
    }
    this.ModuleBuilder.Param.AddVirtualRecord ();
    ParameterBuilder pb = new ParameterBuilder (this.ModuleBuilder, sequence, attributes, strParamName);
    if (parameters.Count == 0 || position > parameters [parameters.Count - 1].Position) {
        parameters.Add (pb);
    } else {
        for (int i = 0; i < parameters.Count; i ++) {
            if (parameters [i].Position > position) {
                parameters.Insert (i, pb);
                break;
            }
        }
    }
    return pb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="317" endline="320">
public void SetParameters (params Type [] parameterTypes) {
    this.parameterTypes = Util.Copy (parameterTypes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="322" endline="325">
public void SetReturnType (Type returnType) {
    this.returnType = returnType ?? this.Module.universe.System_Void;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="327" endline="333">
public void SetSignature (Type returnType, Type [] returnTypeRequiredCustomModifiers, Type [] returnTypeOptionalCustomModifiers, Type [] parameterTypes, Type [] [] parameterTypeRequiredCustomModifiers, Type [] [] parameterTypeOptionalCustomModifiers) {
    this.returnType = returnType ?? this.Module.universe.System_Void;
    this.parameterTypes = Util.Copy (parameterTypes);
    this.modifiers = PackedCustomModifiers.CreateFromExternal (returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers, parameterTypeRequiredCustomModifiers, this.parameterTypes.Length);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="335" endline="343">
public GenericTypeParameterBuilder [] DefineGenericParameters (params string [] names) {
    gtpb = new GenericTypeParameterBuilder [names.Length];
    for (int i = 0; i < names.Length; i ++) {
        gtpb [i] = new GenericTypeParameterBuilder (names [i], null, this, i);
    }
    return (GenericTypeParameterBuilder []) gtpb.Clone ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="345" endline="348">
public override MethodInfo MakeGenericMethod (params Type [] typeArguments) {
    return new GenericMethodInstance (typeBuilder, this, typeArguments);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="350" endline="357">
public override MethodInfo GetGenericMethodDefinition () {
    if (gtpb == null) {
        throw new InvalidOperationException ();
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="359" endline="362">
public override Type [] GetGenericArguments () {
    return Util.Copy (gtpb);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="364" endline="367">
internal override Type GetGenericMethodArgument (int index) {
    return gtpb [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="369" endline="372">
internal override int GetGenericMethodArgumentCount () {
    return gtpb == null ? 0 : gtpb.Length;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="389" endline="392">
public void __SetAttributes (MethodAttributes attributes) {
    this.attributes = attributes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="394" endline="397">
public override MethodImplAttributes GetMethodImplementationFlags () {
    return implFlags;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="473" endline="480">
private Type [] GetCustomModifiers (int optOrReq) {
    if (method.modifiers == null || method.modifiers [parameter + 1] == null) {
        return Type.EmptyTypes;
    }
    return Util.Copy (method.modifiers [parameter + 1] [optOrReq]);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="482" endline="485">
public override Type [] GetOptionalCustomModifiers () {
    return GetCustomModifiers (0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="487" endline="490">
public override Type [] GetRequiredCustomModifiers () {
    return GetCustomModifiers (1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="512" endline="520">
public override ParameterInfo [] GetParameters () {
    ParameterInfo [] parameters = new ParameterInfo [parameterTypes.Length];
    for (int i = 0; i < parameters.Length; i ++) {
        parameters [i] = new ParameterInfoImpl (this, i);
    }
    return parameters;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="562" endline="565">
public Module GetModule () {
    return typeBuilder.Module;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="567" endline="570">
public MethodToken GetToken () {
    return new MethodToken (pseudoToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="572" endline="575">
public override MethodBody GetMethodBody () {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="583" endline="609">
internal void Bake () {
    this.signature = this.ModuleBuilder.GetSignatureBlobIndex (this.MethodSignature);
    if (ilgen != null) {
        if (this.ModuleBuilder.symbolWriter != null) {
            this.ModuleBuilder.symbolWriter.OpenMethod (new SymbolToken (- pseudoToken | 0x06000000));
        }
        rva = ilgen.WriteBody (initLocals);
        if (this.ModuleBuilder.symbolWriter != null) {
            this.ModuleBuilder.symbolWriter.CloseMethod ();
        }
        ilgen = null;
    } else {
        rva = - 1;
    }
    if (declarativeSecurity != null) {
        this.ModuleBuilder.AddDeclarativeSecurity (pseudoToken, declarativeSecurity);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="616" endline="635">
internal void WriteMethodDefRecord (int baseRVA, MetadataWriter mw, ref int paramList) {
    if (rva != - 1) {
        mw.Write (rva + baseRVA);
    } else {
        mw.Write (0);
    }
    mw.Write ((short) implFlags);
    mw.Write ((short) attributes);
    mw.WriteStringIndex (nameIndex);
    mw.WriteBlobIndex (signature);
    mw.WriteParam (paramList);
    if (parameters != null) {
        paramList += parameters.Count;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="637" endline="646">
internal void WriteParamRecords (MetadataWriter mw) {
    if (parameters != null) {
        foreach (ParameterBuilder pb in parameters) {
            pb.WriteParamRecord (mw);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="648" endline="658">
internal void FixupToken (int token, ref int parameterToken) {
    typeBuilder.ModuleBuilder.RegisterTokenFixup (this.pseudoToken, token);
    if (parameters != null) {
        foreach (ParameterBuilder pb in parameters) {
            pb.FixupToken (parameterToken ++);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="672" endline="686">
internal override int ImportTo (ModuleBuilder other) {
    if (typeBuilder.IsGenericTypeDefinition) {
        return other.ImportMember (TypeBuilder.GetMethod (typeBuilder, this));
    } else if (other == typeBuilder.ModuleBuilder) {
        return pseudoToken;
    } else {
        return other.ImportMethodOrField (typeBuilder, name, this.MethodSignature);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/MethodBuilder.cs.ifdefed" startline="688" endline="691">
internal void CheckBaked () {
    typeBuilder.CheckBaked ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="82" endline="87">
public bool Equals (MemberRefKey other) {
    return other.type.Equals (type) && other.name == name && other.signature.Equals (signature);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="89" endline="93">
public override bool Equals (object obj) {
    MemberRefKey ? other = obj as MemberRefKey ?;
    return other != null && Equals (other);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="95" endline="98">
public override int GetHashCode () {
    return type.GetHashCode () + name.GetHashCode () + signature.GetHashCode ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="116" endline="125">
internal void PopulatePropertyAndEventTables () {
    foreach (TypeBuilder type in types) {
        type.PopulatePropertyAndEventTables ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="127" endline="135">
internal void WriteTypeDefTable (MetadataWriter mw) {
    int fieldList = 1;
    int methodList = 1;
    foreach (TypeBuilder type in types) {
        type.WriteTypeDefRecord (mw, ref fieldList, ref methodList);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="137" endline="144">
internal void WriteMethodDefTable (int baseRVA, MetadataWriter mw) {
    int paramList = 1;
    foreach (TypeBuilder type in types) {
        type.WriteMethodDefRecords (baseRVA, mw, ref paramList);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="146" endline="152">
internal void WriteParamTable (MetadataWriter mw) {
    foreach (TypeBuilder type in types) {
        type.WriteParamRecords (mw);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="154" endline="160">
internal void WriteFieldTable (MetadataWriter mw) {
    foreach (TypeBuilder type in types) {
        type.WriteFieldRecords (mw);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="162" endline="165">
internal int AllocPseudoToken () {
    return nextPseudoToken --;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="167" endline="170">
public TypeBuilder DefineType (string name) {
    return DefineType (name, TypeAttributes.Class);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="172" endline="175">
public TypeBuilder DefineType (string name, TypeAttributes attr) {
    return DefineType (name, attr, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="177" endline="180">
public TypeBuilder DefineType (string name, TypeAttributes attr, Type parent) {
    return DefineType (name, attr, parent, PackingSize.Unspecified, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="182" endline="185">
public TypeBuilder DefineType (string name, TypeAttributes attr, Type parent, int typesize) {
    return DefineType (name, attr, parent, PackingSize.Unspecified, typesize);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="187" endline="190">
public TypeBuilder DefineType (string name, TypeAttributes attr, Type parent, PackingSize packsize) {
    return DefineType (name, attr, parent, packsize, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="192" endline="200">
public TypeBuilder DefineType (string name, TypeAttributes attr, Type parent, Type [] interfaces) {
    TypeBuilder tb = DefineType (name, attr, parent);
    foreach (Type iface in interfaces) {
        tb.AddInterfaceImplementation (iface);
    }
    return tb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="202" endline="211">
public TypeBuilder DefineType (string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize) {
    if (parent == null && (attr & TypeAttributes.Interface) == 0) {
        parent = universe.System_Object;
    }
    TypeBuilder typeBuilder = new TypeBuilder (this, name, parent, attr);
    PostDefineType (typeBuilder, packingSize, typesize);
    return typeBuilder;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="213" endline="218">
public EnumBuilder DefineEnum (string name, TypeAttributes visibility, Type underlyingType) {
    TypeBuilder tb = DefineType (name, (visibility & TypeAttributes.VisibilityMask) | TypeAttributes.Sealed, universe.System_Enum);
    FieldBuilder fb = tb.DefineField ("value__", underlyingType, FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
    return new EnumBuilder (tb, fb);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="220" endline="236">
internal TypeBuilder DefineNestedTypeHelper (TypeBuilder enclosingType, string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize) {
    if (parent == null && (attr & TypeAttributes.Interface) == 0) {
        parent = universe.System_Object;
    }
    TypeBuilder typeBuilder = new TypeBuilder (enclosingType, name, parent, attr);
    PostDefineType (typeBuilder, packingSize, typesize);
    if (enclosingType != null) {
        NestedClassTable.Record rec = new NestedClassTable.Record ();
        rec.NestedClass = typeBuilder.MetadataToken;
        rec.EnclosingClass = enclosingType.MetadataToken;
        this.NestedClass.AddRecord (rec);
    }
    return typeBuilder;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="238" endline="250">
private void PostDefineType (TypeBuilder typeBuilder, PackingSize packingSize, int typesize) {
    types.Add (typeBuilder);
    fullNameToType.Add (typeBuilder.FullName, typeBuilder);
    if (packingSize != PackingSize.Unspecified || typesize != 0) {
        ClassLayoutTable.Record rec = new ClassLayoutTable.Record ();
        rec.PackingSize = (short) packingSize;
        rec.ClassSize = typesize;
        rec.Parent = typeBuilder.MetadataToken;
        this.ClassLayout.AddRecord (rec);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="252" endline="255">
public FieldBuilder __DefineField (string name, Type type, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers, FieldAttributes attributes) {
    return moduleType.DefineField (name, type, requiredCustomModifiers, optionalCustomModifiers, attributes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="257" endline="260">
public ConstructorBuilder __DefineModuleInitializer (MethodAttributes visibility) {
    return moduleType.DefineConstructor (visibility | MethodAttributes.Static | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName, CallingConventions.Standard, Type.EmptyTypes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="262" endline="265">
public FieldBuilder DefineUninitializedData (string name, int size, FieldAttributes attributes) {
    return moduleType.DefineUninitializedData (name, size, attributes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="267" endline="270">
public FieldBuilder DefineInitializedData (string name, byte [] data, FieldAttributes attributes) {
    return moduleType.DefineInitializedData (name, data, attributes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="272" endline="275">
public MethodBuilder DefineGlobalMethod (string name, MethodAttributes attributes, Type returnType, Type [] parameterTypes) {
    return moduleType.DefineMethod (name, attributes, returnType, parameterTypes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="277" endline="280">
public MethodBuilder DefineGlobalMethod (string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] parameterTypes) {
    return moduleType.DefineMethod (name, attributes, callingConvention, returnType, parameterTypes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="282" endline="285">
public MethodBuilder DefineGlobalMethod (string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] requiredReturnTypeCustomModifiers, Type [] optionalReturnTypeCustomModifiers, Type [] parameterTypes, Type [] [] requiredParameterTypeCustomModifiers, Type [] [] optionalParameterTypeCustomModifiers) {
    return moduleType.DefineMethod (name, attributes, callingConvention, returnType, requiredReturnTypeCustomModifiers, optionalReturnTypeCustomModifiers, parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="287" endline="290">
public MethodBuilder DefinePInvokeMethod (string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet) {
    return moduleType.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="292" endline="295">
public MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet) {
    return moduleType.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="297" endline="300">
public void CreateGlobalFunctions () {
    moduleType.CreateType ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="302" endline="311">
internal void AddTypeForwarder (Type type) {
    ExportType (type);
    foreach (Type nested in type.GetNestedTypes (BindingFlags.Public | BindingFlags.NonPublic)) {
        AddTypeForwarder (nested);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="313" endline="332">
private int ExportType (Type type) {
    ExportedTypeTable.Record rec = new ExportedTypeTable.Record ();
    rec.TypeDefId = type.MetadataToken;
    rec.TypeName = this.Strings.Add (TypeNameParser.Unescape (type.Name));
    if (type.IsNested) {
        rec.Flags = 0;
        rec.TypeNamespace = 0;
        rec.Implementation = ExportType (type.DeclaringType);
    } else {
        rec.Flags = 0x00200000;
        string ns = type.Namespace;
        rec.TypeNamespace = ns == null ? 0 : this.Strings.Add (TypeNameParser.Unescape (ns));
        rec.Implementation = ImportAssemblyRef (type.Assembly);
    }
    return 0x27000000 | this.ExportedType.FindOrAddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="334" endline="337">
public void SetCustomAttribute (ConstructorInfo con, byte [] binaryAttribute) {
    SetCustomAttribute (new CustomAttributeBuilder (con, binaryAttribute));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="339" endline="342">
public void SetCustomAttribute (CustomAttributeBuilder customBuilder) {
    SetCustomAttribute (0x00000001, customBuilder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="344" endline="352">
internal void SetCustomAttribute (int token, CustomAttributeBuilder customBuilder) {
    Debug.Assert (! customBuilder.IsPseudoCustomAttribute);
    CustomAttributeTable.Record rec = new CustomAttributeTable.Record ();
    rec.Parent = token;
    rec.Type = this.GetConstructorToken (customBuilder.Constructor).Token;
    rec.Value = customBuilder.WriteBlob (this);
    this.CustomAttribute.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="354" endline="362">
internal void AddDeclarativeSecurity (int token, System.Security.Permissions.SecurityAction securityAction, System.Security.PermissionSet permissionSet) {
    DeclSecurityTable.Record rec = new DeclSecurityTable.Record ();
    rec.Action = (short) securityAction;
    rec.Parent = token;
    rec.PermissionSet = this.Blobs.Add (ByteBuffer.Wrap (System.Text.Encoding.Unicode.GetBytes (permissionSet.ToXml ().ToString ())));
    this.DeclSecurity.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="364" endline="395">
internal void AddDeclarativeSecurity (int token, List < CustomAttributeBuilder > declarativeSecurity) {
    Dictionary < int, List < CustomAttributeBuilder > > ordered = new Dictionary < int, List < CustomAttributeBuilder > > ();
    foreach (CustomAttributeBuilder cab in declarativeSecurity) {
        int action;
        if (cab.ConstructorArgumentCount == 0) {
            action = (int) System.Security.Permissions.SecurityAction.LinkDemand;
        } else {
            action = (int) cab.GetConstructorArgument (0);
        }
        List < CustomAttributeBuilder > list;
        if (! ordered.TryGetValue (action, out list)) {
            list = new List < CustomAttributeBuilder > ();
            ordered.Add (action, list);
        }
        list.Add (cab);
    }
    foreach (KeyValuePair < int, List < CustomAttributeBuilder > > kv in ordered) {
        DeclSecurityTable.Record rec = new DeclSecurityTable.Record ();
        rec.Action = (short) kv.Key;
        rec.Parent = token;
        rec.PermissionSet = WriteDeclSecurityBlob (kv.Value);
        this.DeclSecurity.AddRecord (rec);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="397" endline="412">
private int WriteDeclSecurityBlob (List < CustomAttributeBuilder > list) {
    ByteBuffer namedArgs = new ByteBuffer (100);
    ByteBuffer bb = new ByteBuffer (list.Count * 100);
    bb.Write ((byte) '.');
    bb.WriteCompressedInt (list.Count);
    foreach (CustomAttributeBuilder cab in list) {
        bb.Write (cab.Constructor.DeclaringType.AssemblyQualifiedName);
        namedArgs.Clear ();
        cab.WriteNamedArgumentsForDeclSecurity (this, namedArgs);
        bb.WriteCompressedInt (namedArgs.Length);
        bb.Write (namedArgs);
    }
    return this.Blobs.Add (bb);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="414" endline="428">
public void DefineManifestResource (string name, Stream stream, ResourceAttributes attribute) {
    ManifestResourceTable.Record rec = new ManifestResourceTable.Record ();
    rec.Offset = manifestResources.Position;
    rec.Flags = (int) attribute;
    rec.Name = this.Strings.Add (name);
    rec.Implementation = 0;
    this.ManifestResource.AddRecord (rec);
    manifestResources.Write (0);
    manifestResources.Write (stream);
    int savePosition = manifestResources.Position;
    manifestResources.Position = rec.Offset;
    manifestResources.Write (savePosition - (manifestResources.Position + 4));
    manifestResources.Position = savePosition;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="435" endline="440">
internal override Type GetTypeImpl (string typeName) {
    TypeBuilder type;
    fullNameToType.TryGetValue (typeName, out type);
    return type;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="442" endline="451">
internal override void GetTypesImpl (List < Type > list) {
    foreach (Type type in types) {
        if (type != moduleType) {
            list.Add (type);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="453" endline="456">
public ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType) {
    return symbolWriter.DefineDocument (url, language, languageVendor, documentType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="458" endline="461">
public TypeToken GetTypeToken (string name) {
    return new TypeToken (GetType (name, true, false).MetadataToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="463" endline="473">
public TypeToken GetTypeToken (Type type) {
    if (type.Module == this) {
        return new TypeToken (type.GetModuleBuilderToken ());
    } else {
        return new TypeToken (ImportType (type));
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="475" endline="497">
internal int GetTypeTokenForMemberRef (Type type) {
    if (type.IsGenericTypeDefinition) {
        int token;
        if (! memberRefTypeTokens.TryGetValue (type, out token)) {
            ByteBuffer spec = new ByteBuffer (5);
            Signature.WriteTypeSpec (this, spec, type);
            token = 0x1B000000 | this.TypeSpec.AddRecord (this.Blobs.Add (spec));
            memberRefTypeTokens.Add (type, token);
        }
        return token;
    } else if (type.IsModulePseudoType) {
        return 0x1A000000 | this.ModuleRef.FindOrAddRecord (this.Strings.Add (type.Module.ScopeName));
    } else {
        return GetTypeToken (type).Token;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="499" endline="503">
private static bool IsFromGenericTypeDefinition (MemberInfo member) {
    Type decl = member.DeclaringType;
    return decl != null && decl.IsGenericTypeDefinition;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="505" endline="519">
public FieldToken GetFieldToken (FieldInfo field) {
    FieldBuilder fb = field as FieldBuilder;
    if (fb != null && fb.Module == this && ! IsFromGenericTypeDefinition (fb)) {
        return new FieldToken (fb.MetadataToken);
    } else {
        return new FieldToken (ImportMember (field));
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="521" endline="532">
public MethodToken GetMethodToken (MethodInfo method) {
    MethodBuilder mb = method as MethodBuilder;
    if (mb != null && mb.ModuleBuilder == this) {
        return new MethodToken (mb.MetadataToken);
    } else {
        return new MethodToken (ImportMember (method));
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="536" endline="550">
internal MethodToken GetMethodTokenForIL (MethodInfo method) {
    if (method.IsGenericMethodDefinition) {
        method = method.MakeGenericMethod (method.GetGenericArguments ());
    }
    if (IsFromGenericTypeDefinition (method)) {
        return new MethodToken (ImportMember (method));
    } else {
        return GetMethodToken (method);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="552" endline="562">
public MethodToken GetConstructorToken (ConstructorInfo constructor) {
    if (constructor.Module == this && constructor.GetMethodInfo () is MethodBuilder) {
        return new MethodToken (constructor.MetadataToken);
    } else {
        return new MethodToken (ImportMember (constructor));
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="564" endline="573">
internal int ImportMember (MethodBase member) {
    int token;
    if (! importedMembers.TryGetValue (member, out token)) {
        token = member.ImportTo (this);
        importedMembers.Add (member, token);
    }
    return token;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="575" endline="584">
internal int ImportMember (FieldInfo member) {
    int token;
    if (! importedMembers.TryGetValue (member, out token)) {
        token = member.ImportTo (this);
        importedMembers.Add (member, token);
    }
    return token;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="586" endline="601">
internal int ImportMethodOrField (Type declaringType, string name, Signature sig) {
    int token;
    if (! importedMemberRefs.TryGetValue (new MemberRefKey (declaringType, name, sig), out token)) {
        MemberRefTable.Record rec = new MemberRefTable.Record ();
        rec.Class = GetTypeTokenForMemberRef (declaringType);
        rec.Name = this.Strings.Add (name);
        ByteBuffer bb = new ByteBuffer (16);
        sig.WriteSig (this, bb);
        rec.Signature = this.Blobs.Add (bb);
        token = 0x0A000000 | this.MemberRef.AddRecord (rec);
        importedMemberRefs.Add (new MemberRefKey (declaringType, name, sig), token);
    }
    return token;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="603" endline="635">
internal int ImportType (Type type) {
    int token;
    if (! typeTokens.TryGetValue (type, out token)) {
        if (type.HasElementType || (type.IsGenericType && ! type.IsGenericTypeDefinition)) {
            ByteBuffer spec = new ByteBuffer (5);
            Signature.WriteTypeSpec (this, spec, type);
            token = 0x1B000000 | this.TypeSpec.AddRecord (this.Blobs.Add (spec));
        } else {
            TypeRefTable.Record rec = new TypeRefTable.Record ();
            if (type.IsNested) {
                rec.ResolutionScope = GetTypeToken (type.DeclaringType).Token;
                rec.TypeName = this.Strings.Add (TypeNameParser.Unescape (type.Name));
                rec.TypeNameSpace = 0;
            } else {
                rec.ResolutionScope = ImportAssemblyRef (type.Assembly);
                rec.TypeName = this.Strings.Add (TypeNameParser.Unescape (type.Name));
                string ns = type.Namespace;
                rec.TypeNameSpace = ns == null ? 0 : this.Strings.Add (TypeNameParser.Unescape (ns));
            }
            token = 0x01000000 | this.TypeRef.AddRecord (rec);
        }
        typeTokens.Add (type, token);
    }
    return token;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="637" endline="650">
private int ImportAssemblyRef (Assembly asm) {
    int token;
    if (! referencedAssemblies.TryGetValue (asm, out token)) {
        token = 0x23800001 + referencedAssemblies.Count;
        referencedAssemblies.Add (asm, token);
    }
    return token;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="652" endline="677">
internal void FillAssemblyRefTable () {
    int [] realtokens = new int [referencedAssemblies.Count];
    foreach (KeyValuePair < Assembly, int > kv in referencedAssemblies) {
        realtokens [(kv.Value & 0x7FFFFF) - 1] = FindOrAddAssemblyRef (kv.Key.GetName ());
    }
    for (int i = 0; i < this.TypeRef.records.Length; i ++) {
        int resolutionScope = this.TypeRef.records [i].ResolutionScope;
        if ((resolutionScope > > 24) == AssemblyRefTable.Index) {
            this.TypeRef.records [i].ResolutionScope = realtokens [(resolutionScope & 0x7FFFFF) - 1];
        }
    }
    for (int i = 0; i < this.ExportedType.records.Length; i ++) {
        int implementation = this.ExportedType.records [i].Implementation;
        if ((implementation > > 24) == AssemblyRefTable.Index) {
            this.ExportedType.records [i].Implementation = realtokens [(implementation & 0x7FFFFF) - 1];
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="679" endline="714">
private int FindOrAddAssemblyRef (AssemblyName name) {
    AssemblyRefTable.Record rec = new AssemblyRefTable.Record ();
    Version ver = name.Version;
    rec.MajorVersion = (ushort) ver.Major;
    rec.MinorVersion = (ushort) ver.Minor;
    rec.BuildNumber = (ushort) ver.Build;
    rec.RevisionNumber = (ushort) ver.Revision;
    rec.Flags = (int) (name.Flags & AssemblyNameFlags.Retargetable);
    byte [] publicKeyOrToken = null;
    if (usePublicKeyAssemblyReference) {
        publicKeyOrToken = name.GetPublicKey ();
    }
    if (publicKeyOrToken == null || publicKeyOrToken.Length == 0) {
        publicKeyOrToken = name.GetPublicKeyToken ();
    } else {
        const int PublicKey = 0x0001;
        rec.Flags |= PublicKey;
    }
    rec.PublicKeyOrToken = this.Blobs.Add (ByteBuffer.Wrap (publicKeyOrToken));
    rec.Name = this.Strings.Add (name.Name);
    if (name.CultureInfo != null) {
        rec.Culture = this.Strings.Add (name.CultureInfo.Name);
    } else {
        rec.Culture = 0;
    }
    rec.HashValue = 0;
    return 0x23000000 | this.AssemblyRef.FindOrAddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="716" endline="727">
internal void WriteSymbolTokenMap () {
    for (int i = 0; i < resolvedTokens.Count; i ++) {
        int newToken = resolvedTokens [i];
        int oldToken = (i + 1) | (newToken & ~ 0xFFFFFF);
        SymbolSupport.RemapToken (symbolWriter, oldToken, newToken);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="729" endline="737">
internal void RegisterTokenFixup (int pseudoToken, int realToken) {
    int index = - (pseudoToken + 1);
    while (resolvedTokens.Count <= index) {
        resolvedTokens.Add (0);
    }
    resolvedTokens [index] = realToken;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="739" endline="742">
internal bool IsPseudoToken (int token) {
    return token < 0;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="744" endline="748">
internal int ResolvePseudoToken (int pseudoToken) {
    int index = - (pseudoToken + 1);
    return resolvedTokens [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="750" endline="765">
internal void FixupMethodBodyTokens () {
    int methodToken = 0x06000001;
    int fieldToken = 0x04000001;
    int parameterToken = 0x08000001;
    foreach (TypeBuilder type in types) {
        type.ResolveMethodAndFieldTokens (ref methodToken, ref fieldToken, ref parameterToken);
    }
    foreach (int offset in tokenFixupOffsets) {
        methodBodies.Position = offset;
        int pseudoToken = methodBodies.GetInt32AtCurrentPosition ();
        methodBodies.Write (ResolvePseudoToken (pseudoToken));
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="767" endline="796">
private int GetHeaderLength () {
    return 4 + 2 + 2 + 4 + 4 + StringToPaddedUTF8Length (asm.ImageRuntimeVersion) + 2 + 2 + 4 + 4 + 4 + 4 + 4 + 12 + 4 + 4 + 4 + 4 + 4 + 8 + (Blobs.IsEmpty ? 0 : (4 + 4 + 8));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="806" endline="864">
internal void WriteMetadata (MetadataWriter mw) {
    mw.Write (0x424A5342);
    mw.Write ((ushort) 1);
    mw.Write ((ushort) 1);
    mw.Write (0);
    byte [] version = StringToPaddedUTF8 (asm.ImageRuntimeVersion);
    mw.Write (version.Length);
    mw.Write (version);
    mw.Write ((ushort) 0);
    if (Blobs.IsEmpty) {
        mw.Write ((ushort) 4);
    } else {
        mw.Write ((ushort) 5);
    }
    int offset = GetHeaderLength ();
    mw.Write (offset);
    mw.Write (Tables.Length);
    mw.Write (StringToPaddedUTF8 ("#~"));
    offset += Tables.Length;
    mw.Write (offset);
    mw.Write (Strings.Length);
    mw.Write (StringToPaddedUTF8 ("#Strings"));
    offset += Strings.Length;
    mw.Write (offset);
    mw.Write (UserStrings.Length);
    mw.Write (StringToPaddedUTF8 ("#US"));
    offset += UserStrings.Length;
    mw.Write (offset);
    mw.Write (Guids.Length);
    mw.Write (StringToPaddedUTF8 ("#GUID"));
    offset += Guids.Length;
    if (! Blobs.IsEmpty) {
        mw.Write (offset);
        mw.Write (Blobs.Length);
        mw.Write (StringToPaddedUTF8 ("#Blob"));
    }
    Tables.Write (mw);
    Strings.Write (mw);
    UserStrings.Write (mw);
    Guids.Write (mw);
    if (! Blobs.IsEmpty) {
        Blobs.Write (mw);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="866" endline="869">
private static int StringToPaddedUTF8Length (string str) {
    return (System.Text.Encoding.UTF8.GetByteCount (str) + 4) & ~ 3;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="871" endline="876">
private static byte [] StringToPaddedUTF8 (string str) {
    byte [] buf = new byte [(System.Text.Encoding.UTF8.GetByteCount (str) + 4) & ~ 3];
    System.Text.Encoding.UTF8.GetBytes (str, 0, str.Length, buf, 0);
    return buf;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="878" endline="881">
internal override void ExportTypes (int fileToken, ModuleBuilder manifestModule) {
    manifestModule.ExportTypes (types.ToArray (), fileToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="883" endline="908">
internal void ExportTypes (Type [] types, int fileToken) {
    Dictionary < Type, int > declaringTypes = new Dictionary < Type, int > ();
    foreach (Type type in types) {
        if (! type.IsModulePseudoType && IsVisible (type)) {
            ExportedTypeTable.Record rec = new ExportedTypeTable.Record ();
            rec.Flags = (int) type.Attributes;
            rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
            rec.TypeName = this.Strings.Add (TypeNameParser.Unescape (type.Name));
            string ns = type.Namespace;
            rec.TypeNamespace = ns == null ? 0 : this.Strings.Add (TypeNameParser.Unescape (ns));
            if (type.IsNested) {
                rec.Implementation = declaringTypes [type.DeclaringType];
            } else {
                rec.Implementation = fileToken;
            }
            int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord (rec);
            declaringTypes.Add (type, exportTypeToken);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="910" endline="914">
private static bool IsVisible (Type type) {
    return type.IsPublic || ((type.IsNestedFamily || type.IsNestedFamORAssem || type.IsNestedPublic) && IsVisible (type.DeclaringType));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="916" endline="1005">
internal void AddConstant (int parentToken, object defaultValue) {
    ConstantTable.Record rec = new ConstantTable.Record ();
    rec.Parent = parentToken;
    ByteBuffer val = new ByteBuffer (16);
    if (defaultValue == null) {
        rec.Type = Signature.ELEMENT_TYPE_CLASS;
        val.Write ((int) 0);
    } else if (defaultValue is bool) {
        rec.Type = Signature.ELEMENT_TYPE_BOOLEAN;
        val.Write ((bool) defaultValue ? (byte) 1 : (byte) 0);
    } else if (defaultValue is char) {
        rec.Type = Signature.ELEMENT_TYPE_CHAR;
        val.Write ((char) defaultValue);
    } else if (defaultValue is sbyte) {
        rec.Type = Signature.ELEMENT_TYPE_I1;
        val.Write ((sbyte) defaultValue);
    } else if (defaultValue is byte) {
        rec.Type = Signature.ELEMENT_TYPE_U1;
        val.Write ((byte) defaultValue);
    } else if (defaultValue is short) {
        rec.Type = Signature.ELEMENT_TYPE_I2;
        val.Write ((short) defaultValue);
    } else if (defaultValue is ushort) {
        rec.Type = Signature.ELEMENT_TYPE_U2;
        val.Write ((ushort) defaultValue);
    } else if (defaultValue is int) {
        rec.Type = Signature.ELEMENT_TYPE_I4;
        val.Write ((int) defaultValue);
    } else if (defaultValue is uint) {
        rec.Type = Signature.ELEMENT_TYPE_U4;
        val.Write ((uint) defaultValue);
    } else if (defaultValue is long) {
        rec.Type = Signature.ELEMENT_TYPE_I8;
        val.Write ((long) defaultValue);
    } else if (defaultValue is ulong) {
        rec.Type = Signature.ELEMENT_TYPE_U8;
        val.Write ((ulong) defaultValue);
    } else if (defaultValue is float) {
        rec.Type = Signature.ELEMENT_TYPE_R4;
        val.Write ((float) defaultValue);
    } else if (defaultValue is double) {
        rec.Type = Signature.ELEMENT_TYPE_R8;
        val.Write ((double) defaultValue);
    } else if (defaultValue is string) {
        rec.Type = Signature.ELEMENT_TYPE_STRING;
        foreach (char c in (string) defaultValue) {
            val.Write (c);
        }
    } else if (defaultValue is DateTime) {
        rec.Type = Signature.ELEMENT_TYPE_I8;
        val.Write (((DateTime) defaultValue).Ticks);
    } else {
        throw new ArgumentException ();
    }
    rec.Value = this.Blobs.Add (val);
    this.Constant.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1012" endline="1019">
public override Type ResolveType (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    if (genericTypeArguments != null || genericMethodArguments != null) {
        throw new NotImplementedException ();
    }
    return types [(metadataToken & 0xFFFFFF) - 1];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1021" endline="1052">
public override MethodBase ResolveMethod (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    if (genericTypeArguments != null || genericMethodArguments != null) {
        throw new NotImplementedException ();
    }
    if ((metadataToken > > 24) == MemberRefTable.Index) {
        foreach (KeyValuePair < MemberInfo, int > kv in importedMembers) {
            if (kv.Value == metadataToken) {
                return (MethodBase) kv.Key;
            }
        }
    }
    if ((metadataToken & 0xFF000000) == 0x06000000) {
        metadataToken = - (metadataToken & 0x00FFFFFF);
    }
    foreach (Type type in types) {
        MethodBase method = ((TypeBuilder) type).LookupMethod (metadataToken);
        if (method != null) {
            return method;
        }
    }
    return ((TypeBuilder) moduleType).LookupMethod (metadataToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1054" endline="1057">
public override FieldInfo ResolveField (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new NotImplementedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1059" endline="1062">
public override MemberInfo ResolveMember (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new NotImplementedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1064" endline="1067">
public override string ResolveString (int metadataToken) {
    throw new NotImplementedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1084" endline="1087">
public override Type [] __ResolveOptionalParameterTypes (int metadataToken) {
    throw new NotImplementedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1094" endline="1097">
public ISymbolWriter GetSymWriter () {
    return symbolWriter;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1099" endline="1105">
public void DefineUnmanagedResource (string resourceFileName) {
    unmanagedResources = new ResourceSection ();
    unmanagedResources.ExtractResources (System.IO.File.ReadAllBytes (resourceFileName));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1107" endline="1110">
public bool IsTransient () {
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1112" endline="1123">
public void SetUserEntryPoint (MethodInfo entryPoint) {
    int token = entryPoint.MetadataToken;
    if (token < 0) {
        token = - token | 0x06000000;
    }
    if (symbolWriter != null) {
        symbolWriter.SetUserEntryPoint (new SymbolToken (token));
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1125" endline="1128">
public StringToken GetStringConstant (string str) {
    return new StringToken (this.UserStrings.Add (str) | (0x70 << 24));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1130" endline="1133">
public SignatureToken GetSignatureToken (SignatureHelper sigHelper) {
    return new SignatureToken (this.StandAloneSig.FindOrAddRecord (this.Blobs.Add (sigHelper.GetSignature (this))) | (StandAloneSigTable.Index << 24));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1135" endline="1138">
public SignatureToken GetSignatureToken (byte [] sigBytes, int sigLength) {
    return new SignatureToken (this.StandAloneSig.FindOrAddRecord (this.Blobs.Add (ByteBuffer.Wrap (sigBytes, sigLength))) | (StandAloneSigTable.Index << 24));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1140" endline="1143">
public MethodInfo GetArrayMethod (Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type [] parameterTypes) {
    return new ArrayMethod (this, arrayClass, methodName, callingConvention, returnType, parameterTypes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1145" endline="1148">
public MethodToken GetArrayMethodToken (Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type [] parameterTypes) {
    return GetMethodToken (GetArrayMethod (arrayClass, methodName, callingConvention, returnType, parameterTypes));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1150" endline="1153">
internal override Type GetModuleType () {
    return moduleType;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1155" endline="1158">
internal override IKVM.Reflection.Reader.ByteReader GetBlob (int blobIndex) {
    return Blobs.GetBlob (blobIndex);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1160" endline="1165">
internal int GetSignatureBlobIndex (Signature sig) {
    ByteBuffer bb = new ByteBuffer (16);
    sig.WriteSig (this, bb);
    return this.Blobs.Add (bb);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1179" endline="1186">
private int AddTypeRefByName (int resolutionScope, string ns, string name) {
    TypeRefTable.Record rec = new TypeRefTable.Record ();
    rec.ResolutionScope = resolutionScope;
    rec.TypeName = this.Strings.Add (name);
    rec.TypeNameSpace = ns == null ? 0 : this.Strings.Add (ns);
    return 0x01000000 | this.TypeRef.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1188" endline="1229">
public void __Save (PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine) {
    PopulatePropertyAndEventTables ();
    IList < CustomAttributeData > attributes = asm.GetCustomAttributesData (null);
    if (attributes.Count > 0) {
        int mscorlib = ImportAssemblyRef (universe.Mscorlib);
        int [] placeholderTokens = new int [4];
        string [] placeholderTypeNames = new string [] {"AssemblyAttributesGoHere", "AssemblyAttributesGoHereM", "AssemblyAttributesGoHereS", "AssemblyAttributesGoHereSM"};
        foreach (CustomAttributeData cad in attributes) {
            int index;
            if (cad.Constructor.DeclaringType.BaseType == universe.System_Security_Permissions_CodeAccessSecurityAttribute) {
                if (cad.Constructor.DeclaringType.IsAllowMultipleCustomAttribute) {
                    index = 3;
                } else {
                    index = 2;
                }
            } else if (cad.Constructor.DeclaringType.IsAllowMultipleCustomAttribute) {
                index = 1;
            } else {
                index = 0;
            }
            if (placeholderTokens [index] == 0) {
                placeholderTokens [index] = AddTypeRefByName (mscorlib, "System.Runtime.CompilerServices", placeholderTypeNames [index]);
            }
            SetCustomAttribute (placeholderTokens [index], cad.__ToBuilder ());
        }
    }
    FillAssemblyRefTable ();
    ModuleWriter.WriteModule (null, null, this, PEFileKinds.Dll, portableExecutableKind, imageFileMachine, unmanagedResources, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1231" endline="1239">
public void __AddAssemblyReference (AssemblyName assemblyName) {
    if (referencedAssemblyNames == null) {
        referencedAssemblyNames = new List < AssemblyName > ();
    }
    FindOrAddAssemblyRef (assemblyName);
    referencedAssemblyNames.Add ((AssemblyName) assemblyName.Clone ());
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1241" endline="1263">
public override AssemblyName [] __GetReferencedAssemblies () {
    List < AssemblyName > list = new List < AssemblyName > ();
    if (referencedAssemblyNames != null) {
        foreach (AssemblyName name in referencedAssemblyNames) {
            if (! list.Contains (name)) {
                list.Add (name);
            }
        }
    }
    foreach (Assembly asm in referencedAssemblies.Keys) {
        AssemblyName name = asm.GetName ();
        if (! list.Contains (name)) {
            list.Add (name);
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1286" endline="1289">
public override MethodBody GetMethodBody () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1291" endline="1294">
public override MethodImplAttributes GetMethodImplementationFlags () {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1296" endline="1299">
public override ParameterInfo [] GetParameters () {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ModuleBuilder.cs.ifdefed" startline="1301" endline="1304">
internal override int ImportTo (ModuleBuilder module) {
    return module.ImportMethodOrField (arrayClass, methodName, MethodSignature);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/OpCodes.cs.ifdefed" startline="257" endline="715">
internal static string GetName (int value) {
    switch (value) {
        case 0 :
            return "nop";
        case 1 :
            return "break";
        case 2 :
            return "ldarg.0";
        case 3 :
            return "ldarg.1";
        case 4 :
            return "ldarg.2";
        case 5 :
            return "ldarg.3";
        case 6 :
            return "ldloc.0";
        case 7 :
            return "ldloc.1";
        case 8 :
            return "ldloc.2";
        case 9 :
            return "ldloc.3";
        case 10 :
            return "stloc.0";
        case 11 :
            return "stloc.1";
        case 12 :
            return "stloc.2";
        case 13 :
            return "stloc.3";
        case 14 :
            return "ldarg.s";
        case 15 :
            return "ldarga.s";
        case 16 :
            return "starg.s";
        case 17 :
            return "ldloc.s";
        case 18 :
            return "ldloca.s";
        case 19 :
            return "stloc.s";
        case 20 :
            return "ldnull";
        case 21 :
            return "ldc.i4.m1";
        case 22 :
            return "ldc.i4.0";
        case 23 :
            return "ldc.i4.1";
        case 24 :
            return "ldc.i4.2";
        case 25 :
            return "ldc.i4.3";
        case 26 :
            return "ldc.i4.4";
        case 27 :
            return "ldc.i4.5";
        case 28 :
            return "ldc.i4.6";
        case 29 :
            return "ldc.i4.7";
        case 30 :
            return "ldc.i4.8";
        case 31 :
            return "ldc.i4.s";
        case 32 :
            return "ldc.i4";
        case 33 :
            return "ldc.i8";
        case 34 :
            return "ldc.r4";
        case 35 :
            return "ldc.r8";
        case 37 :
            return "dup";
        case 38 :
            return "pop";
        case 39 :
            return "jmp";
        case 40 :
            return "call";
        case 41 :
            return "calli";
        case 42 :
            return "ret";
        case 43 :
            return "br.s";
        case 44 :
            return "brfalse.s";
        case 45 :
            return "brtrue.s";
        case 46 :
            return "beq.s";
        case 47 :
            return "bge.s";
        case 48 :
            return "bgt.s";
        case 49 :
            return "ble.s";
        case 50 :
            return "blt.s";
        case 51 :
            return "bne.un.s";
        case 52 :
            return "bge.un.s";
        case 53 :
            return "bgt.un.s";
        case 54 :
            return "ble.un.s";
        case 55 :
            return "blt.un.s";
        case 56 :
            return "br";
        case 57 :
            return "brfalse";
        case 58 :
            return "brtrue";
        case 59 :
            return "beq";
        case 60 :
            return "bge";
        case 61 :
            return "bgt";
        case 62 :
            return "ble";
        case 63 :
            return "blt";
        case 64 :
            return "bne.un";
        case 65 :
            return "bge.un";
        case 66 :
            return "bgt.un";
        case 67 :
            return "ble.un";
        case 68 :
            return "blt.un";
        case 69 :
            return "switch";
        case 70 :
            return "ldind.i1";
        case 71 :
            return "ldind.u1";
        case 72 :
            return "ldind.i2";
        case 73 :
            return "ldind.u2";
        case 74 :
            return "ldind.i4";
        case 75 :
            return "ldind.u4";
        case 76 :
            return "ldind.i8";
        case 77 :
            return "ldind.i";
        case 78 :
            return "ldind.r4";
        case 79 :
            return "ldind.r8";
        case 80 :
            return "ldind.ref";
        case 81 :
            return "stind.ref";
        case 82 :
            return "stind.i1";
        case 83 :
            return "stind.i2";
        case 84 :
            return "stind.i4";
        case 85 :
            return "stind.i8";
        case 86 :
            return "stind.r4";
        case 87 :
            return "stind.r8";
        case 88 :
            return "add";
        case 89 :
            return "sub";
        case 90 :
            return "mul";
        case 91 :
            return "div";
        case 92 :
            return "div.un";
        case 93 :
            return "rem";
        case 94 :
            return "rem.un";
        case 95 :
            return "and";
        case 96 :
            return "or";
        case 97 :
            return "xor";
        case 98 :
            return "shl";
        case 99 :
            return "shr";
        case 100 :
            return "shr.un";
        case 101 :
            return "neg";
        case 102 :
            return "not";
        case 103 :
            return "conv.i1";
        case 104 :
            return "conv.i2";
        case 105 :
            return "conv.i4";
        case 106 :
            return "conv.i8";
        case 107 :
            return "conv.r4";
        case 108 :
            return "conv.r8";
        case 109 :
            return "conv.u4";
        case 110 :
            return "conv.u8";
        case 111 :
            return "callvirt";
        case 112 :
            return "cpobj";
        case 113 :
            return "ldobj";
        case 114 :
            return "ldstr";
        case 115 :
            return "newobj";
        case 116 :
            return "castclass";
        case 117 :
            return "isinst";
        case 118 :
            return "conv.r.un";
        case 121 :
            return "unbox";
        case 122 :
            return "throw";
        case 123 :
            return "ldfld";
        case 124 :
            return "ldflda";
        case 125 :
            return "stfld";
        case 126 :
            return "ldsfld";
        case 127 :
            return "ldsflda";
        case 128 :
            return "stsfld";
        case 129 :
            return "stobj";
        case 130 :
            return "conv.ovf.i1.un";
        case 131 :
            return "conv.ovf.i2.un";
        case 132 :
            return "conv.ovf.i4.un";
        case 133 :
            return "conv.ovf.i8.un";
        case 134 :
            return "conv.ovf.u1.un";
        case 135 :
            return "conv.ovf.u2.un";
        case 136 :
            return "conv.ovf.u4.un";
        case 137 :
            return "conv.ovf.u8.un";
        case 138 :
            return "conv.ovf.i.un";
        case 139 :
            return "conv.ovf.u.un";
        case 140 :
            return "box";
        case 141 :
            return "newarr";
        case 142 :
            return "ldlen";
        case 143 :
            return "ldelema";
        case 144 :
            return "ldelem.i1";
        case 145 :
            return "ldelem.u1";
        case 146 :
            return "ldelem.i2";
        case 147 :
            return "ldelem.u2";
        case 148 :
            return "ldelem.i4";
        case 149 :
            return "ldelem.u4";
        case 150 :
            return "ldelem.i8";
        case 151 :
            return "ldelem.i";
        case 152 :
            return "ldelem.r4";
        case 153 :
            return "ldelem.r8";
        case 154 :
            return "ldelem.ref";
        case 155 :
            return "stelem.i";
        case 156 :
            return "stelem.i1";
        case 157 :
            return "stelem.i2";
        case 158 :
            return "stelem.i4";
        case 159 :
            return "stelem.i8";
        case 160 :
            return "stelem.r4";
        case 161 :
            return "stelem.r8";
        case 162 :
            return "stelem.ref";
        case 163 :
            return "ldelem";
        case 164 :
            return "stelem";
        case 165 :
            return "unbox.any";
        case 179 :
            return "conv.ovf.i1";
        case 180 :
            return "conv.ovf.u1";
        case 181 :
            return "conv.ovf.i2";
        case 182 :
            return "conv.ovf.u2";
        case 183 :
            return "conv.ovf.i4";
        case 184 :
            return "conv.ovf.u4";
        case 185 :
            return "conv.ovf.i8";
        case 186 :
            return "conv.ovf.u8";
        case 194 :
            return "refanyval";
        case 195 :
            return "ckfinite";
        case 198 :
            return "mkrefany";
        case 208 :
            return "ldtoken";
        case 209 :
            return "conv.u2";
        case 210 :
            return "conv.u1";
        case 211 :
            return "conv.i";
        case 212 :
            return "conv.ovf.i";
        case 213 :
            return "conv.ovf.u";
        case 214 :
            return "add.ovf";
        case 215 :
            return "add.ovf.un";
        case 216 :
            return "mul.ovf";
        case 217 :
            return "mul.ovf.un";
        case 218 :
            return "sub.ovf";
        case 219 :
            return "sub.ovf.un";
        case 220 :
            return "endfinally";
        case 221 :
            return "leave";
        case 222 :
            return "leave.s";
        case 223 :
            return "stind.i";
        case 224 :
            return "conv.u";
        case 248 :
            return "prefix7";
        case 249 :
            return "prefix6";
        case 250 :
            return "prefix5";
        case 251 :
            return "prefix4";
        case 252 :
            return "prefix3";
        case 253 :
            return "prefix2";
        case 254 :
            return "prefix1";
        case 255 :
            return "prefixref";
        case - 512 :
            return "arglist";
        case - 511 :
            return "ceq";
        case - 510 :
            return "cgt";
        case - 509 :
            return "cgt.un";
        case - 508 :
            return "clt";
        case - 507 :
            return "clt.un";
        case - 506 :
            return "ldftn";
        case - 505 :
            return "ldvirtftn";
        case - 503 :
            return "ldarg";
        case - 502 :
            return "ldarga";
        case - 501 :
            return "starg";
        case - 500 :
            return "ldloc";
        case - 499 :
            return "ldloca";
        case - 498 :
            return "stloc";
        case - 497 :
            return "localloc";
        case - 495 :
            return "endfilter";
        case - 494 :
            return "unaligned.";
        case - 493 :
            return "volatile.";
        case - 492 :
            return "tail.";
        case - 491 :
            return "initobj";
        case - 490 :
            return "constrained.";
        case - 489 :
            return "cpblk";
        case - 488 :
            return "initblk";
        case - 486 :
            return "rethrow";
        case - 484 :
            return "sizeof";
        case - 483 :
            return "refanytype";
        case - 482 :
            return "readonly.";
    }
    throw new ArgumentOutOfRangeException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/OpCodes.cs.ifdefed" startline="717" endline="747">
public static bool TakesSingleByteArgument (OpCode inst) {
    switch (inst.Value) {
        case 14 : case 15 : case 16 : case 17 : case 18 : case 19 : case 31 : case 43 : case 44 : case 45 : case 46 : case 47 : case 48 : case 49 : case 50 : case 51 : case 52 : case 53 : case 54 : case 55 : case 222 : case - 494 :
            return true;
        default :
            return false;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ParameterBuilder.cs.ifdefed" startline="91" endline="94">
public void SetCustomAttribute (ConstructorInfo con, byte [] binaryAttribute) {
    SetCustomAttribute (new CustomAttributeBuilder (con, binaryAttribute));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ParameterBuilder.cs.ifdefed" startline="96" endline="120">
public void SetCustomAttribute (CustomAttributeBuilder customAttributeBuilder) {
    Universe u = moduleBuilder.universe;
    if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_InAttribute) {
        flags |= (short) ParameterAttributes.In;
    } else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_OutAttribute) {
        flags |= (short) ParameterAttributes.Out;
    } else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_OptionalAttribute) {
        flags |= (short) ParameterAttributes.Optional;
    } else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_MarshalAsAttribute) {
        MarshalSpec.SetMarshalAsAttribute (moduleBuilder, PseudoToken, customAttributeBuilder);
        flags |= (short) ParameterAttributes.HasFieldMarshal;
    } else {
        moduleBuilder.SetCustomAttribute (PseudoToken, customAttributeBuilder);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ParameterBuilder.cs.ifdefed" startline="122" endline="126">
public void SetConstant (object defaultValue) {
    flags |= (short) ParameterAttributes.HasDefault;
    moduleBuilder.AddConstant (PseudoToken, defaultValue);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ParameterBuilder.cs.ifdefed" startline="128" endline="133">
internal void WriteParamRecord (MetadataWriter mw) {
    mw.Write (flags);
    mw.Write (sequence);
    mw.WriteStringIndex (nameIndex);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/ParameterBuilder.cs.ifdefed" startline="135" endline="141">
internal void FixupToken (int parameterToken) {
    if (lazyPseudoToken != 0) {
        moduleBuilder.RegisterTokenFixup (lazyPseudoToken, parameterToken);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="58" endline="64">
private void PatchCallingConvention (MethodBuilder mdBuilder) {
    if (patchCallingConvention && ! mdBuilder.IsStatic) {
        sig.HasThis = true;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="66" endline="70">
public void SetGetMethod (MethodBuilder mdBuilder) {
    PatchCallingConvention (mdBuilder);
    getter = mdBuilder;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="72" endline="76">
public void SetSetMethod (MethodBuilder mdBuilder) {
    PatchCallingConvention (mdBuilder);
    setter = mdBuilder;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="78" endline="86">
public void AddOtherMethod (MethodBuilder mdBuilder) {
    PatchCallingConvention (mdBuilder);
    if (otherMethods == null) {
        otherMethods = new List < MethodBuilder > ();
    }
    otherMethods.Add (mdBuilder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="88" endline="91">
public void SetCustomAttribute (ConstructorInfo con, byte [] binaryAttribute) {
    SetCustomAttribute (new CustomAttributeBuilder (con, binaryAttribute));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="93" endline="108">
public void SetCustomAttribute (CustomAttributeBuilder customBuilder) {
    Universe u = typeBuilder.ModuleBuilder.universe;
    if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute) {
        attributes |= PropertyAttributes.SpecialName;
    } else {
        if (lazyPseudoToken == 0) {
            lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken ();
        }
        typeBuilder.ModuleBuilder.SetCustomAttribute (lazyPseudoToken, customBuilder);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="110" endline="117">
public override object GetRawConstantValue () {
    if (lazyPseudoToken != 0) {
        return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue (typeBuilder.ModuleBuilder, lazyPseudoToken);
    }
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="134" endline="137">
public override MethodInfo GetGetMethod (bool nonPublic) {
    return nonPublic || (getter != null && getter.IsPublic) ? getter : null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="139" endline="142">
public override MethodInfo GetSetMethod (bool nonPublic) {
    return nonPublic || (setter != null && setter.IsPublic) ? setter : null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="144" endline="157">
public override MethodInfo [] GetAccessors (bool nonPublic) {
    List < MethodInfo > list = new List < MethodInfo > ();
    AddAccessor (list, nonPublic, getter);
    AddAccessor (list, nonPublic, setter);
    if (otherMethods != null) {
        foreach (MethodInfo method in otherMethods) {
            AddAccessor (list, nonPublic, method);
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="159" endline="165">
private static void AddAccessor (List < MethodInfo > list, bool nonPublic, MethodInfo method) {
    if (method != null && (nonPublic || method.IsPublic)) {
        list.Add (method);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="182" endline="190">
public void SetConstant (object defaultValue) {
    if (lazyPseudoToken == 0) {
        lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken ();
    }
    attributes |= PropertyAttributes.HasDefault;
    typeBuilder.ModuleBuilder.AddConstant (lazyPseudoToken, defaultValue);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="192" endline="220">
internal void Bake () {
    PropertyTable.Record rec = new PropertyTable.Record ();
    rec.Flags = (short) attributes;
    rec.Name = typeBuilder.ModuleBuilder.Strings.Add (name);
    rec.Type = typeBuilder.ModuleBuilder.GetSignatureBlobIndex (sig);
    int token = 0x17000000 | typeBuilder.ModuleBuilder.Property.AddRecord (rec);
    if (lazyPseudoToken != 0) {
        typeBuilder.ModuleBuilder.RegisterTokenFixup (lazyPseudoToken, token);
    }
    if (getter != null) {
        AddMethodSemantics (MethodSemanticsTable.Getter, getter.MetadataToken, token);
    }
    if (setter != null) {
        AddMethodSemantics (MethodSemanticsTable.Setter, setter.MetadataToken, token);
    }
    if (otherMethods != null) {
        foreach (MethodBuilder method in otherMethods) {
            AddMethodSemantics (MethodSemanticsTable.Other, method.MetadataToken, token);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/PropertyBuilder.cs.ifdefed" startline="222" endline="229">
private void AddMethodSemantics (short semantics, int methodToken, int propertyToken) {
    MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record ();
    rec.Semantics = semantics;
    rec.Method = methodToken;
    rec.Association = propertyToken;
    typeBuilder.ModuleBuilder.MethodSemantics.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="70" endline="73">
public static SignatureHelper GetFieldSigHelper (Module mod) {
    return new SignatureHelper (mod as ModuleBuilder, Signature.FIELD);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="75" endline="78">
public static SignatureHelper GetLocalVarSigHelper () {
    return new SignatureHelper (null, Signature.LOCAL_SIG);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="80" endline="83">
public static SignatureHelper GetLocalVarSigHelper (Module mod) {
    return new SignatureHelper (mod as ModuleBuilder, Signature.LOCAL_SIG);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="85" endline="96">
public static SignatureHelper GetPropertySigHelper (Module mod, Type returnType, Type [] parameterTypes) {
    SignatureHelper sig = new SignatureHelper (mod as ModuleBuilder, Signature.PROPERTY);
    sig.returnType = returnType;
    sig.returnTypeOptionalCustomModifiers = Type.EmptyTypes;
    sig.returnTypeRequiredCustomModifiers = Type.EmptyTypes;
    foreach (Type type in parameterTypes) {
        sig.AddArgument (type);
    }
    return sig;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="98" endline="101">
public static SignatureHelper GetPropertySigHelper (Module mod, Type returnType, Type [] requiredReturnTypeCustomModifiers, Type [] optionalReturnTypeCustomModifiers, Type [] parameterTypes, Type [] [] requiredParameterTypeCustomModifiers, Type [] [] optionalParameterTypeCustomModifiers) {
    return GetPropertySigHelper (mod, CallingConventions.Standard, returnType, requiredReturnTypeCustomModifiers, optionalReturnTypeCustomModifiers, parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="103" endline="112">
public static SignatureHelper GetPropertySigHelper (Module mod, CallingConventions callingConvention, Type returnType, Type [] requiredReturnTypeCustomModifiers, Type [] optionalReturnTypeCustomModifiers, Type [] parameterTypes, Type [] [] requiredParameterTypeCustomModifiers, Type [] [] optionalParameterTypeCustomModifiers) {
    SignatureHelper sig = new SignatureHelper (mod as ModuleBuilder, Signature.PROPERTY);
    sig.callingConvention = callingConvention;
    sig.returnType = returnType;
    sig.returnTypeOptionalCustomModifiers = requiredReturnTypeCustomModifiers;
    sig.returnTypeRequiredCustomModifiers = optionalReturnTypeCustomModifiers;
    sig.AddArguments (parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers);
    return sig;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="114" endline="117">
public static SignatureHelper GetMethodSigHelper (CallingConvention unmanagedCallingConvention, Type returnType) {
    return GetMethodSigHelper (null, unmanagedCallingConvention, returnType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="119" endline="122">
public static SignatureHelper GetMethodSigHelper (CallingConventions callingConvention, Type returnType) {
    return GetMethodSigHelper (null, callingConvention, returnType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="124" endline="131">
public static SignatureHelper GetMethodSigHelper (Module mod, CallingConvention unmanagedCallConv, Type returnType) {
    SignatureHelper sig = new SignatureHelper (mod as ModuleBuilder, 0);
    sig.returnType = returnType;
    sig.unmanaged = true;
    sig.unmanagedCallConv = unmanagedCallConv;
    return sig;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="133" endline="139">
public static SignatureHelper GetMethodSigHelper (Module mod, CallingConventions callingConvention, Type returnType) {
    SignatureHelper sig = new SignatureHelper (mod as ModuleBuilder, 0);
    sig.returnType = returnType;
    sig.callingConvention = callingConvention;
    return sig;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="141" endline="151">
public static SignatureHelper GetMethodSigHelper (Module mod, Type returnType, Type [] parameterTypes) {
    SignatureHelper sig = new SignatureHelper (mod as ModuleBuilder, 0);
    sig.returnType = returnType;
    sig.callingConvention = CallingConventions.Standard;
    foreach (Type type in parameterTypes) {
        sig.AddArgument (type);
    }
    return sig;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="153" endline="160">
public byte [] GetSignature () {
    if (module == null) {
        throw new NotSupportedException ();
    }
    return GetSignature (module).ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="162" endline="190">
internal ByteBuffer GetSignature (ModuleBuilder module) {
    ByteBuffer bb = new ByteBuffer (16);
    switch (type) {
        case 0 :
            if (unmanaged) {
                Signature.WriteStandAloneMethodSig (module, bb, unmanagedCallConv, returnType, args.ToArray ());
            } else {
                Signature.WriteStandAloneMethodSig (module, bb, callingConvention, returnType, args.ToArray (), optionalArgs.ToArray ());
            }
            break;
        case Signature.FIELD :
            FieldSignature.Create (args [0], optionalCustomModifiers [0], requiredCustomModifiers [0]).WriteSig (module, bb);
            break;
        case Signature.PROPERTY :
            Signature.WritePropertySig (module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray (), requiredCustomModifiers.ToArray (), optionalCustomModifiers.ToArray ());
            break;
        case Signature.LOCAL_SIG :
            Signature.WriteLocalVarSig (module, bb, locals);
            break;
        default :
            throw new InvalidOperationException ();
    }
    return bb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="192" endline="196">
public void AddSentinel () {
    optional = true;
    callingConvention |= CallingConventions.VarArgs;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="198" endline="201">
public void AddArgument (Type clsArgument) {
    AddArgument (clsArgument, false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="203" endline="206">
public void AddArgument (Type argument, bool pinned) {
    AddArgument (argument, pinned, Type.EmptyTypes, Type.EmptyTypes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="208" endline="211">
public void AddArgument (Type argument, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    AddArgument (argument, false, requiredCustomModifiers, optionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="213" endline="229">
private void AddArgument (Type argument, bool pinned, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    if (type == Signature.LOCAL_SIG) {
        locals.Add (new LocalBuilder (argument, 0, pinned));
    } else if (optional) {
        this.optionalArgs.Add (argument);
    } else {
        this.args.Add (argument);
        this.requiredCustomModifiers.Add (requiredCustomModifiers);
        this.optionalCustomModifiers.Add (optionalCustomModifiers);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/SignatureHelper.cs.ifdefed" startline="231" endline="237">
public void AddArguments (Type [] arguments, Type [] [] requiredCustomModifiers, Type [] [] optionalCustomModifiers) {
    for (int i = 0; i < arguments.Length; i ++) {
        AddArgument (arguments [i], false, requiredCustomModifiers [i], optionalCustomModifiers [i]);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="74" endline="77">
public override Type [] __GetDeclaredInterfaces () {
    throw new NotImplementedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="104" endline="107">
public override string ToString () {
    return this.Name;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="139" endline="142">
public override Type [] GetGenericParameterConstraints () {
    throw new NotImplementedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="160" endline="166">
private void AddConstraint (Type type) {
    GenericParamConstraintTable.Record rec = new GenericParamConstraintTable.Record ();
    rec.Owner = paramPseudoIndex;
    rec.Constraint = this.ModuleBuilder.GetTypeTokenForMemberRef (type);
    this.ModuleBuilder.GenericParamConstraint.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="168" endline="172">
public void SetBaseTypeConstraint (Type baseTypeConstraint) {
    this.baseType = baseTypeConstraint;
    AddConstraint (baseTypeConstraint);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="174" endline="180">
public void SetInterfaceConstraints (params Type [] interfaceConstraints) {
    foreach (Type type in interfaceConstraints) {
        AddConstraint (type);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="182" endline="187">
public void SetGenericParameterAttributes (GenericParameterAttributes genericParameterAttributes) {
    this.attr = genericParameterAttributes;
    this.ModuleBuilder.GenericParam.PatchAttribute (paramPseudoIndex, genericParameterAttributes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="189" endline="192">
public void SetCustomAttribute (CustomAttributeBuilder customBuilder) {
    this.ModuleBuilder.SetCustomAttribute ((GenericParamTable.Index << 24) | paramPseudoIndex, customBuilder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="194" endline="197">
public void SetCustomAttribute (ConstructorInfo con, byte [] binaryAttribute) {
    SetCustomAttribute (new CustomAttributeBuilder (con, binaryAttribute));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="199" endline="208">
internal override int GetModuleBuilderToken () {
    if (typeToken == 0) {
        ByteBuffer spec = new ByteBuffer (5);
        Signature.WriteTypeSpec (this.ModuleBuilder, spec, this);
        typeToken = 0x1B000000 | this.ModuleBuilder.TypeSpec.AddRecord (this.ModuleBuilder.Blobs.Add (spec));
    }
    return typeToken;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="210" endline="220">
internal override Type BindTypeParameters (IGenericBinder binder) {
    if (type != null) {
        return binder.BindTypeParameter (this);
    } else {
        return binder.BindMethodParameter (this);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="270" endline="278">
public ConstructorBuilder DefineDefaultConstructor (MethodAttributes attributes) {
    ConstructorBuilder cb = DefineConstructor (attributes, CallingConventions.Standard, Type.EmptyTypes);
    ILGenerator ilgen = cb.GetILGenerator ();
    ilgen.Emit (OpCodes.Ldarg_0);
    ilgen.Emit (OpCodes.Call, baseType.GetConstructor (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null));
    ilgen.Emit (OpCodes.Ret);
    return cb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="280" endline="283">
public ConstructorBuilder DefineConstructor (MethodAttributes attribs, CallingConventions callConv, Type [] parameterTypes) {
    return DefineConstructor (attribs, callConv, parameterTypes, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="285" endline="291">
public ConstructorBuilder DefineConstructor (MethodAttributes attribs, CallingConventions callingConvention, Type [] parameterTypes, Type [] [] requiredCustomModifiers, Type [] [] optionalCustomModifiers) {
    attribs |= MethodAttributes.RTSpecialName | MethodAttributes.SpecialName;
    string name = (attribs & MethodAttributes.Static) == 0 ? ConstructorInfo.ConstructorName : ConstructorInfo.TypeConstructorName;
    MethodBuilder mb = DefineMethod (name, attribs, callingConvention, null, null, null, parameterTypes, requiredCustomModifiers, optionalCustomModifiers);
    return new ConstructorBuilder (mb);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="293" endline="297">
public ConstructorBuilder DefineTypeInitializer () {
    MethodBuilder mb = DefineMethod (ConstructorInfo.TypeConstructorName, MethodAttributes.Private | MethodAttributes.Static | MethodAttributes.RTSpecialName | MethodAttributes.SpecialName, null, Type.EmptyTypes);
    return new ConstructorBuilder (mb);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="299" endline="305">
private MethodBuilder CreateMethodBuilder (string name, MethodAttributes attributes, CallingConventions callingConvention) {
    this.ModuleBuilder.MethodDef.AddVirtualRecord ();
    MethodBuilder mb = new MethodBuilder (this, name, attributes, callingConvention);
    methods.Add (mb);
    return mb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="307" endline="310">
public MethodBuilder DefineMethod (string name, MethodAttributes attribs) {
    return DefineMethod (name, attribs, CallingConventions.Standard);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="312" endline="315">
public MethodBuilder DefineMethod (string name, MethodAttributes attribs, CallingConventions callingConvention) {
    return CreateMethodBuilder (name, attribs, callingConvention);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="317" endline="320">
public MethodBuilder DefineMethod (string name, MethodAttributes attribs, Type returnType, Type [] parameterTypes) {
    return DefineMethod (name, attribs, CallingConventions.Standard, returnType, null, null, parameterTypes, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="322" endline="325">
public MethodBuilder DefineMethod (string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] parameterTypes) {
    return DefineMethod (name, attributes, callingConvention, returnType, null, null, parameterTypes, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="327" endline="332">
public MethodBuilder DefineMethod (string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] returnTypeRequiredCustomModifiers, Type [] returnTypeOptionalCustomModifiers, Type [] parameterTypes, Type [] [] parameterTypeRequiredCustomModifiers, Type [] [] parameterTypeOptionalCustomModifiers) {
    MethodBuilder mb = CreateMethodBuilder (name, attributes, callingConvention);
    mb.SetSignature (returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
    return mb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="334" endline="337">
public MethodBuilder DefinePInvokeMethod (string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet) {
    return DefinePInvokeMethod (name, dllName, null, attributes, callingConvention, returnType, null, null, parameterTypes, null, null, nativeCallConv, nativeCharSet);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="339" endline="342">
public MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet) {
    return DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, null, null, parameterTypes, null, null, nativeCallConv, nativeCharSet);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="344" endline="354">
public MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] returnTypeRequiredCustomModifiers, Type [] returnTypeOptionalCustomModifiers, Type [] parameterTypes, Type [] [] parameterTypeRequiredCustomModifiers, Type [] [] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet) {
    MethodBuilder mb = DefineMethod (name, attributes | MethodAttributes.PinvokeImpl, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
    mb.SetDllImportPseudoCustomAttribute (dllName, entryName, nativeCallConv, nativeCharSet, null, null, null, null, null);
    return mb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="356" endline="363">
public void DefineMethodOverride (MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration) {
    MethodImplTable.Record rec = new MethodImplTable.Record ();
    rec.Class = token;
    rec.MethodBody = this.ModuleBuilder.GetMethodToken (methodInfoBody).Token;
    rec.MethodDeclaration = this.ModuleBuilder.GetMethodToken (methodInfoDeclaration).Token;
    this.ModuleBuilder.MethodImpl.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="365" endline="368">
public FieldBuilder DefineField (string name, Type fieldType, FieldAttributes attribs) {
    return DefineField (name, fieldType, null, null, attribs);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="370" endline="375">
public FieldBuilder DefineField (string fieldName, Type type, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers, FieldAttributes attributes) {
    FieldBuilder fb = new FieldBuilder (this, fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes);
    fields.Add (fb);
    return fb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="377" endline="380">
public PropertyBuilder DefineProperty (string name, PropertyAttributes attributes, Type returnType, Type [] parameterTypes) {
    return DefineProperty (name, attributes, returnType, null, null, parameterTypes, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="382" endline="387">
public PropertyBuilder DefineProperty (string name, PropertyAttributes attributes, Type returnType, Type [] returnTypeRequiredCustomModifiers, Type [] returnTypeOptionalCustomModifiers, Type [] parameterTypes, Type [] [] parameterTypeRequiredCustomModifiers, Type [] [] parameterTypeOptionalCustomModifiers) {
    return DefinePropertyImpl (name, attributes, CallingConventions.Standard, true, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="389" endline="395">
public PropertyBuilder DefineProperty (string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] returnTypeRequiredCustomModifiers, Type [] returnTypeOptionalCustomModifiers, Type [] parameterTypes, Type [] [] parameterTypeRequiredCustomModifiers, Type [] [] parameterTypeOptionalCustomModifiers) {
    return DefinePropertyImpl (name, attributes, callingConvention, false, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="397" endline="410">
private PropertyBuilder DefinePropertyImpl (string name, PropertyAttributes attributes, CallingConventions callingConvention, bool patchCallingConvention, Type returnType, Type [] returnTypeRequiredCustomModifiers, Type [] returnTypeOptionalCustomModifiers, Type [] parameterTypes, Type [] [] parameterTypeRequiredCustomModifiers, Type [] [] parameterTypeOptionalCustomModifiers) {
    if (properties == null) {
        properties = new List < PropertyBuilder > ();
    }
    PropertySignature sig = PropertySignature.Create (callingConvention, returnType, returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers, parameterTypes, parameterTypeOptionalCustomModifiers, parameterTypeRequiredCustomModifiers);
    PropertyBuilder pb = new PropertyBuilder (this, name, attributes, sig, patchCallingConvention);
    properties.Add (pb);
    return pb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="412" endline="421">
public EventBuilder DefineEvent (string name, EventAttributes attributes, Type eventtype) {
    if (events == null) {
        events = new List < EventBuilder > ();
    }
    EventBuilder eb = new EventBuilder (this, name, attributes, eventtype);
    events.Add (eb);
    return eb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="423" endline="426">
public TypeBuilder DefineNestedType (string name) {
    return DefineNestedType (name, TypeAttributes.Class | TypeAttributes.NestedPrivate);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="428" endline="431">
public TypeBuilder DefineNestedType (string name, TypeAttributes attribs) {
    return DefineNestedType (name, attribs, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="433" endline="441">
public TypeBuilder DefineNestedType (string name, TypeAttributes attr, Type parent, Type [] interfaces) {
    TypeBuilder tb = DefineNestedType (name, attr, parent);
    foreach (Type iface in interfaces) {
        tb.AddInterfaceImplementation (iface);
    }
    return tb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="443" endline="447">
public TypeBuilder DefineNestedType (string name, TypeAttributes attr, Type parent) {
    this.typeFlags |= TypeFlags.HasNestedTypes;
    return this.ModuleBuilder.DefineNestedTypeHelper (this, name, attr, parent, PackingSize.Unspecified, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="449" endline="453">
public TypeBuilder DefineNestedType (string name, TypeAttributes attr, Type parent, int typeSize) {
    this.typeFlags |= TypeFlags.HasNestedTypes;
    return this.ModuleBuilder.DefineNestedTypeHelper (this, name, attr, parent, PackingSize.Unspecified, typeSize);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="455" endline="459">
public TypeBuilder DefineNestedType (string name, TypeAttributes attr, Type parent, PackingSize packSize) {
    this.typeFlags |= TypeFlags.HasNestedTypes;
    return this.ModuleBuilder.DefineNestedTypeHelper (this, name, attr, parent, packSize, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="461" endline="464">
public void SetParent (Type parent) {
    baseType = parent;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="466" endline="473">
public void AddInterfaceImplementation (Type interfaceType) {
    if (interfaces == null) {
        interfaces = new List < Type > ();
    }
    interfaces.Add (interfaceType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="505" endline="555">
private void SetStructLayoutPseudoCustomAttribute (CustomAttributeBuilder customBuilder) {
    object val = customBuilder.GetConstructorArgument (0);
    LayoutKind layout;
    if (val is short) {
        layout = (LayoutKind) (short) val;
    } else {
        layout = (LayoutKind) val;
    }
    int ? pack = (int ?) customBuilder.GetFieldValue ("Pack");
    int ? size = (int ?) customBuilder.GetFieldValue ("Size");
    if (pack.HasValue || size.HasValue) {
        ClassLayoutTable.Record rec = new ClassLayoutTable.Record ();
        rec.PackingSize = (short) (pack ?? 0);
        rec.ClassSize = size ?? 0;
        rec.Parent = token;
        this.ModuleBuilder.ClassLayout.AddOrReplaceRecord (rec);
    }
    attribs &= ~ TypeAttributes.LayoutMask;
    switch (layout) {
        case LayoutKind.Auto :
            attribs |= TypeAttributes.AutoLayout;
            break;
        case LayoutKind.Explicit :
            attribs |= TypeAttributes.ExplicitLayout;
            break;
        case LayoutKind.Sequential :
            attribs |= TypeAttributes.SequentialLayout;
            break;
    }
    CharSet ? charSet = customBuilder.GetFieldValue < CharSet > ("CharSet");
    attribs &= ~ TypeAttributes.StringFormatMask;
    switch (charSet ?? CharSet.None) {
        case CharSet.None : case CharSet.Ansi :
            attribs |= TypeAttributes.AnsiClass;
            break;
        case CharSet.Auto :
            attribs |= TypeAttributes.AutoClass;
            break;
        case CharSet.Unicode :
            attribs |= TypeAttributes.UnicodeClass;
            break;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="557" endline="560">
public void SetCustomAttribute (ConstructorInfo con, byte [] binaryAttribute) {
    SetCustomAttribute (new CustomAttributeBuilder (con, binaryAttribute));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="562" endline="590">
public void SetCustomAttribute (CustomAttributeBuilder customBuilder) {
    Universe u = this.ModuleBuilder.universe;
    Type type = customBuilder.Constructor.DeclaringType;
    if (type == u.System_Runtime_InteropServices_StructLayoutAttribute) {
        SetStructLayoutPseudoCustomAttribute (customBuilder.DecodeBlob (this.Assembly));
    } else if (type == u.System_SerializableAttribute) {
        attribs |= TypeAttributes.Serializable;
    } else if (type == u.System_Runtime_InteropServices_ComImportAttribute) {
        attribs |= TypeAttributes.Import;
    } else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute) {
        attribs |= TypeAttributes.SpecialName;
    } else {
        if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute) {
            attribs |= TypeAttributes.HasSecurity;
        }
        this.ModuleBuilder.SetCustomAttribute (token, customBuilder);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="592" endline="600">
public void __AddDeclarativeSecurity (CustomAttributeBuilder customBuilder) {
    attribs |= TypeAttributes.HasSecurity;
    if (declarativeSecurity == null) {
        declarativeSecurity = new List < CustomAttributeBuilder > ();
    }
    declarativeSecurity.Add (customBuilder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="602" endline="606">
public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction securityAction, System.Security.PermissionSet permissionSet) {
    this.ModuleBuilder.AddDeclarativeSecurity (token, securityAction, permissionSet);
    this.attribs |= TypeAttributes.HasSecurity;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="608" endline="617">
public GenericTypeParameterBuilder [] DefineGenericParameters (params string [] names) {
    typeFlags |= TypeFlags.IsGenericTypeDefinition;
    gtpb = new GenericTypeParameterBuilder [names.Length];
    for (int i = 0; i < names.Length; i ++) {
        gtpb [i] = new GenericTypeParameterBuilder (names [i], this, null, i);
    }
    return (GenericTypeParameterBuilder []) gtpb.Clone ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="619" endline="622">
public override Type [] GetGenericArguments () {
    return Util.Copy (gtpb);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="624" endline="627">
public override Type [] [] __GetGenericArgumentsOptionalCustomModifiers () {
    return gtpb == null ? Empty < Type [] >.Array : Util.Copy (new Type [gtpb.Length] []);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="629" endline="632">
public override Type [] [] __GetGenericArgumentsRequiredCustomModifiers () {
    return gtpb == null ? Empty < Type [] >.Array : Util.Copy (new Type [gtpb.Length] []);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="634" endline="637">
internal override Type GetGenericTypeArgument (int index) {
    return gtpb [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="644" endline="647">
public override Type GetGenericTypeDefinition () {
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="649" endline="680">
public Type CreateType () {
    if ((typeFlags & TypeFlags.Baked) != 0) {
        throw new NotImplementedException ();
    }
    typeFlags |= TypeFlags.Baked;
    foreach (MethodBuilder mb in methods) {
        mb.Bake ();
    }
    if (declarativeSecurity != null) {
        this.ModuleBuilder.AddDeclarativeSecurity (token, declarativeSecurity);
    }
    if (baseType != null) {
        extends = this.ModuleBuilder.GetTypeToken (baseType).Token;
    }
    if (interfaces != null) {
        foreach (Type interfaceType in interfaces) {
            InterfaceImplTable.Record rec = new InterfaceImplTable.Record ();
            rec.Class = token;
            rec.Interface = this.ModuleBuilder.GetTypeToken (interfaceType).Token;
            this.ModuleBuilder.InterfaceImpl.AddRecord (rec);
        }
    }
    return new BakedType (this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="682" endline="706">
internal void PopulatePropertyAndEventTables () {
    if (properties != null) {
        PropertyMapTable.Record rec = new PropertyMapTable.Record ();
        rec.Parent = token;
        rec.PropertyList = this.ModuleBuilder.Property.RowCount + 1;
        this.ModuleBuilder.PropertyMap.AddRecord (rec);
        foreach (PropertyBuilder pb in properties) {
            pb.Bake ();
        }
    }
    if (events != null) {
        EventMapTable.Record rec = new EventMapTable.Record ();
        rec.Parent = token;
        rec.EventList = this.ModuleBuilder.Event.RowCount + 1;
        this.ModuleBuilder.EventMap.AddRecord (rec);
        foreach (EventBuilder eb in events) {
            eb.Bake ();
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="752" endline="757">
internal string GetBakedNamespace () {
    return base.Namespace;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="764" endline="767">
public void __SetAttributes (TypeAttributes attributes) {
    this.attribs = attributes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="769" endline="772">
public override Type [] __GetDeclaredInterfaces () {
    return Util.ToArray (interfaces, Type.EmptyTypes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="774" endline="790">
public override MethodBase [] __GetDeclaredMethods () {
    MethodBase [] methods = new MethodBase [this.methods.Count];
    for (int i = 0; i < methods.Length; i ++) {
        MethodBuilder mb = this.methods [i];
        if (mb.IsConstructor) {
            methods [i] = new ConstructorInfoImpl (mb);
        } else {
            methods [i] = mb;
        }
    }
    return methods;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="846" endline="849">
public FieldBuilder DefineUninitializedData (string name, int size, FieldAttributes attributes) {
    return DefineInitializedData (name, new byte [size], attributes);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="851" endline="863">
public FieldBuilder DefineInitializedData (string name, byte [] data, FieldAttributes attributes) {
    Type fieldType = this.ModuleBuilder.GetType ("$ArrayType$" + data.Length);
    if (fieldType == null) {
        TypeBuilder tb = this.ModuleBuilder.DefineType ("$ArrayType$" + data.Length, TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.ExplicitLayout, this.Module.universe.System_ValueType, PackingSize.Size1, data.Length);
        tb.CreateType ();
        fieldType = tb;
    }
    FieldBuilder fb = DefineField (name, fieldType, attributes | FieldAttributes.Static);
    fb.__SetDataAndRVA (data);
    return fb;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="865" endline="868">
public static MethodInfo GetMethod (Type type, MethodInfo method) {
    return new GenericMethodInstance (type, method, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="870" endline="873">
public static ConstructorInfo GetConstructor (Type type, ConstructorInfo constructor) {
    return new ConstructorInfoImpl (GetMethod (type, constructor.GetMethodInfo ()));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="875" endline="878">
public static FieldInfo GetField (Type type, FieldInfo field) {
    return new GenericFieldInstance (type, field);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="890" endline="900">
internal void WriteTypeDefRecord (MetadataWriter mw, ref int fieldList, ref int methodList) {
    mw.Write ((int) attribs);
    mw.WriteStringIndex (typeName);
    mw.WriteStringIndex (typeNameSpace);
    mw.WriteTypeDefOrRef (extends);
    mw.WriteField (fieldList);
    mw.WriteMethodDef (methodList);
    methodList += methods.Count;
    fieldList += fields.Count;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="902" endline="908">
internal void WriteMethodDefRecords (int baseRVA, MetadataWriter mw, ref int paramList) {
    foreach (MethodBuilder mb in methods) {
        mb.WriteMethodDefRecord (baseRVA, mw, ref paramList);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="910" endline="920">
internal void ResolveMethodAndFieldTokens (ref int methodToken, ref int fieldToken, ref int parameterToken) {
    foreach (MethodBuilder method in methods) {
        method.FixupToken (methodToken ++, ref parameterToken);
    }
    foreach (FieldBuilder field in fields) {
        field.FixupToken (fieldToken ++);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="922" endline="928">
internal void WriteParamRecords (MetadataWriter mw) {
    foreach (MethodBuilder mb in methods) {
        mb.WriteParamRecords (mw);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="930" endline="936">
internal void WriteFieldRecords (MetadataWriter mw) {
    foreach (FieldBuilder fb in fields) {
        fb.WriteFieldRecords (mw);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="948" endline="951">
internal override int GetModuleBuilderToken () {
    return token;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="959" endline="969">
internal MethodBase LookupMethod (int token) {
    foreach (MethodBuilder method in methods) {
        if (method.MetadataToken == token) {
            return method;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="971" endline="974">
public bool IsCreated () {
    return (typeFlags & TypeFlags.Baked) != 0;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="976" endline="982">
internal override void CheckBaked () {
    if ((typeFlags & TypeFlags.Baked) == 0) {
        throw new NotSupportedException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="984" endline="1000">
public override Type [] __GetDeclaredTypes () {
    if (this.HasNestedTypes) {
        List < Type > types = new List < Type > ();
        List < int > classes = this.ModuleBuilder.NestedClass.GetNestedClasses (token);
        foreach (int nestedClass in classes) {
            types.Add (this.ModuleBuilder.ResolveType (nestedClass));
        }
        return types.ToArray ();
    } else {
        return Type.EmptyTypes;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1002" endline="1005">
public override FieldInfo [] __GetDeclaredFields () {
    return Util.ToArray (fields, Empty < FieldInfo >.Array);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1007" endline="1010">
public override EventInfo [] __GetDeclaredEvents () {
    return Util.ToArray (events, Empty < EventInfo >.Array);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1012" endline="1015">
public override PropertyInfo [] __GetDeclaredProperties () {
    return Util.ToArray (properties, Empty < PropertyInfo >.Array);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1062" endline="1065">
public override Type [] __GetDeclaredInterfaces () {
    return typeBuilder.__GetDeclaredInterfaces ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1067" endline="1070">
public override MethodBase [] __GetDeclaredMethods () {
    return typeBuilder.__GetDeclaredMethods ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1072" endline="1075">
public override __MethodImplMap __GetMethodImplMap () {
    return typeBuilder.__GetMethodImplMap ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1077" endline="1080">
public override FieldInfo [] __GetDeclaredFields () {
    return typeBuilder.__GetDeclaredFields ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1082" endline="1085">
public override EventInfo [] __GetDeclaredEvents () {
    return typeBuilder.__GetDeclaredEvents ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1087" endline="1090">
public override PropertyInfo [] __GetDeclaredProperties () {
    return typeBuilder.__GetDeclaredProperties ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1092" endline="1095">
public override Type [] __GetDeclaredTypes () {
    return typeBuilder.__GetDeclaredTypes ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1113" endline="1116">
public override Type [] GetGenericArguments () {
    return typeBuilder.GetGenericArguments ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1118" endline="1121">
internal override Type GetGenericTypeArgument (int index) {
    return typeBuilder.GetGenericTypeArgument (index);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1123" endline="1126">
public override Type [] [] __GetGenericArgumentsOptionalCustomModifiers () {
    return typeBuilder.__GetGenericArgumentsOptionalCustomModifiers ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1128" endline="1131">
public override Type [] [] __GetGenericArgumentsRequiredCustomModifiers () {
    return typeBuilder.__GetGenericArgumentsRequiredCustomModifiers ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Emit/TypeBuilder.cs.ifdefed" startline="1158" endline="1161">
internal override int GetModuleBuilderToken () {
    return typeBuilder.GetModuleBuilderToken ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/EventInfo.cs.ifdefed" startline="48" endline="51">
public MethodInfo GetAddMethod () {
    return GetAddMethod (false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/EventInfo.cs.ifdefed" startline="53" endline="56">
public MethodInfo GetRaiseMethod () {
    return GetRaiseMethod (false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/EventInfo.cs.ifdefed" startline="58" endline="61">
public MethodInfo GetRemoveMethod () {
    return GetRemoveMethod (false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/EventInfo.cs.ifdefed" startline="63" endline="66">
public MethodInfo [] GetOtherMethods () {
    return GetOtherMethods (false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/EventInfo.cs.ifdefed" startline="68" endline="71">
internal virtual EventInfo BindTypeParameters (Type type) {
    return new GenericEventInfo (this.DeclaringType.BindTypeParameters (type), this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldInfo.cs.ifdefed" startline="45" endline="48">
public Type [] GetOptionalCustomModifiers () {
    return this.FieldSignature.GetOptionalCustomModifiers ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldInfo.cs.ifdefed" startline="50" endline="53">
public Type [] GetRequiredCustomModifiers () {
    return this.FieldSignature.GetRequiredCustomModifiers ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldInfo.cs.ifdefed" startline="117" endline="120">
internal virtual FieldInfo BindTypeParameters (Type type) {
    return new GenericFieldInstance (this.DeclaringType.BindTypeParameters (type), this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldSignature.cs.ifdefed" startline="40" endline="43">
internal static FieldSignature Create (Type fieldType, Type [] optionalCustomModifiers, Type [] requiredCustomModifiers) {
    return new FieldSignature (fieldType, Util.Copy (optionalCustomModifiers), Util.Copy (requiredCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldSignature.cs.ifdefed" startline="52" endline="59">
public override bool Equals (object obj) {
    FieldSignature other = obj as FieldSignature;
    return other != null && other.fieldType.Equals (fieldType) && Util.ArrayEquals (other.optionalCustomModifiers, optionalCustomModifiers) && Util.ArrayEquals (other.requiredCustomModifiers, requiredCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldSignature.cs.ifdefed" startline="61" endline="64">
public override int GetHashCode () {
    return fieldType.GetHashCode () ^ Util.GetHashCode (optionalCustomModifiers) ^ Util.GetHashCode (requiredCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldSignature.cs.ifdefed" startline="71" endline="74">
internal Type [] GetOptionalCustomModifiers () {
    return Util.Copy (optionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldSignature.cs.ifdefed" startline="76" endline="79">
internal Type [] GetRequiredCustomModifiers () {
    return Util.Copy (requiredCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldSignature.cs.ifdefed" startline="81" endline="87">
internal FieldSignature ExpandTypeParameters (Type declaringType) {
    return new FieldSignature (fieldType.BindTypeParameters (declaringType), BindTypeParameters (declaringType, optionalCustomModifiers), BindTypeParameters (declaringType, requiredCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldSignature.cs.ifdefed" startline="89" endline="101">
internal static FieldSignature ReadSig (ModuleReader module, ByteReader br, IGenericContext context) {
    if (br.ReadByte () != FIELD) {
        throw new BadImageFormatException ();
    }
    Type fieldType;
    Type [] optionalCustomModifiers;
    Type [] requiredCustomModifiers;
    ReadCustomModifiers (module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
    fieldType = ReadType (module, br, context);
    return new FieldSignature (fieldType, optionalCustomModifiers, requiredCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/FieldSignature.cs.ifdefed" startline="103" endline="109">
internal override void WriteSig (ModuleBuilder module, ByteBuffer bb) {
    bb.Write (FIELD);
    WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers);
    WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers);
    WriteType (module, bb, fieldType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="44" endline="56">
internal static bool CompareAssemblyIdentity (string assemblyIdentity1, bool unified1, string assemblyIdentity2, bool unified2, out AssemblyComparisonResult result) {
    if (UseNativeFusion) {
        bool equivalent;
        Marshal.ThrowExceptionForHR (CompareAssemblyIdentity (assemblyIdentity1, unified1, assemblyIdentity2, unified2, out equivalent, out result));
        return equivalent;
    } else {
        return CompareAssemblyIdentityPure (assemblyIdentity1, unified1, assemblyIdentity2, unified2, out result);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="62" endline="161">
internal static bool CompareAssemblyIdentityPure (string assemblyIdentity1, bool unified1, string assemblyIdentity2, bool unified2, out AssemblyComparisonResult result) {
    ParsedAssemblyName name1;
    ParsedAssemblyName name2;
    if (! ParseAssemblyName (assemblyIdentity1, out name1) || ! ParseAssemblyName (assemblyIdentity2, out name2)) {
        result = AssemblyComparisonResult.NonEquivalent;
        throw new ArgumentException ();
    }
    bool partial = IsPartial (name1);
    if ((partial && unified1) || IsPartial (name2)) {
        result = AssemblyComparisonResult.NonEquivalent;
        throw new ArgumentException ();
    }
    if (! name1.Name.Equals (name2.Name, StringComparison.InvariantCultureIgnoreCase)) {
        result = AssemblyComparisonResult.NonEquivalent;
        return false;
    }
    if (name1.Name.Equals ("mscorlib", StringComparison.InvariantCultureIgnoreCase)) {
        result = AssemblyComparisonResult.EquivalentFullMatch;
        return true;
    }
    if (partial && name1.Culture == null) {
    } else if (! name1.Culture.Equals (name2.Culture, StringComparison.InvariantCultureIgnoreCase)) {
        result = AssemblyComparisonResult.NonEquivalent;
        return false;
    }
    if (IsStrongNamed (name2)) {
        if (partial && name1.PublicKeyToken == null) {
        } else if (name1.PublicKeyToken != name2.PublicKeyToken) {
            result = AssemblyComparisonResult.NonEquivalent;
            return false;
        }
        if (partial && name1.Version == null) {
            result = AssemblyComparisonResult.EquivalentPartialMatch;
            return true;
        } else if (IsFrameworkAssembly (name2)) {
            result = partial ? AssemblyComparisonResult.EquivalentPartialFXUnified : AssemblyComparisonResult.EquivalentFXUnified;
            return true;
        } else if (name1.Version < name2.Version) {
            if (unified2) {
                result = partial ? AssemblyComparisonResult.EquivalentPartialUnified : AssemblyComparisonResult.EquivalentUnified;
                return true;
            } else {
                result = partial ? AssemblyComparisonResult.NonEquivalentPartialVersion : AssemblyComparisonResult.NonEquivalentVersion;
                return false;
            }
        } else if (name1.Version > name2.Version) {
            if (unified1) {
                result = partial ? AssemblyComparisonResult.EquivalentPartialUnified : AssemblyComparisonResult.EquivalentUnified;
                return true;
            } else {
                result = partial ? AssemblyComparisonResult.NonEquivalentPartialVersion : AssemblyComparisonResult.NonEquivalentVersion;
                return false;
            }
        } else {
            result = partial ? AssemblyComparisonResult.EquivalentPartialMatch : AssemblyComparisonResult.EquivalentFullMatch;
            return true;
        }
    } else if (IsStrongNamed (name1)) {
        result = AssemblyComparisonResult.NonEquivalent;
        return false;
    } else {
        result = partial ? AssemblyComparisonResult.EquivalentPartialWeakNamed : AssemblyComparisonResult.EquivalentWeakNamed;
        return true;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="163" endline="217">
static bool IsFrameworkAssembly (ParsedAssemblyName name) {
    switch (name.Name) {
        case "System" : case "System.Core" : case "System.Data" : case "System.Data.DataSetExtensions" : case "System.Data.Linq" : case "System.Data.OracleClient" : case "System.Data.Services" : case "System.Data.Services.Client" : case "System.IdentityModel" : case "System.IdentityModel.Selectors" : case "System.Runtime.Remoting" : case "System.Runtime.Serialization" : case "System.ServiceModel" : case "System.Transactions" : case "System.Windows.Forms" : case "System.Xml" : case "System.Xml.Linq" :
            return name.PublicKeyToken == "b77a5c561934e089";
        case "System.Configuration" : case "System.Configuration.Install" : case "System.Design" : case "System.DirectoryServices" : case "System.Drawing" : case "System.Drawing.Design" : case "System.EnterpriseServices" : case "System.Management" : case "System.Messaging" : case "System.Runtime.Serialization.Formatters.Soap" : case "System.Security" : case "System.ServiceProcess" : case "System.Web" : case "System.Web.Mobile" : case "System.Web.Services" :
            return name.PublicKeyToken == "b03f5f7f11d50a3a";
        case "System.ComponentModel.DataAnnotations" : case "System.ServiceModel.Web" : case "System.Web.Abstractions" : case "System.Web.Extensions" : case "System.Web.Extensions.Design" : case "System.Web.DynamicData" : case "System.Web.Routing" :
            return name.PublicKeyToken == "31bf3856ad364e35";
    }
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="220" endline="299">
private static bool ParseAssemblyName (string fullName, out ParsedAssemblyName parsedName) {
    parsedName = new ParsedAssemblyName ();
    StringBuilder sb = new StringBuilder ();
    int pos = 0;
    while (pos < fullName.Length) {
        char ch = fullName [pos ++];
        if (ch == '\\') {
            if (pos == fullName.Length) {
                return false;
            }
            ch = fullName [pos ++];
        } else if (ch == ',') {
            break;
        }
        sb.Append (ch);
    }
    parsedName.Name = sb.ToString ().Trim ();
    if (pos < fullName.Length) {
        string [] parts = fullName.Substring (pos).Split (',');
        for (int i = 0; i < parts.Length; i ++) {
            string [] kv = parts [i].Split ('=');
            if (kv.Length != 2) {
                return false;
            }
            switch (kv [0].Trim ().ToLowerInvariant ()) {
                case "version" :
                    if (parsedName.Version != null) {
                        return false;
                    }
                    if (! ParseVersion (kv [1].Trim (), out parsedName.Version)) {
                        return false;
                    }
                    break;
                case "culture" :
                    if (parsedName.Culture != null) {
                        return false;
                    }
                    if (! ParseCulture (kv [1].Trim (), out parsedName.Culture)) {
                        return false;
                    }
                    break;
                case "publickeytoken" :
                    if (parsedName.PublicKeyToken != null) {
                        return false;
                    }
                    if (! ParsePublicKeyToken (kv [1].Trim (), out parsedName.PublicKeyToken)) {
                        return false;
                    }
                    break;
                case "publickey" :
                    if (parsedName.PublicKeyToken != null) {
                        return false;
                    }
                    if (! ParsePublicKey (kv [1].Trim (), out parsedName.PublicKeyToken)) {
                        return false;
                    }
                    break;
            }
        }
    }
    return true;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="301" endline="318">
private static bool ParseVersion (string str, out Version version) {
    string [] parts = str.Split ('.');
    if (parts.Length == 4) {
        ushort major, minor, build, revision;
        if (ushort.TryParse (parts [0], System.Globalization.NumberStyles.Integer, null, out major) && ushort.TryParse (parts [1], System.Globalization.NumberStyles.Integer, null, out minor) && ushort.TryParse (parts [2], System.Globalization.NumberStyles.Integer, null, out build) && ushort.TryParse (parts [3], System.Globalization.NumberStyles.Integer, null, out revision)) {
            version = new Version (major, minor, build, revision);
            return true;
        }
    }
    version = null;
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="320" endline="329">
private static bool ParseCulture (string str, out string culture) {
    if (str == null) {
        culture = null;
        return false;
    }
    culture = str;
    return true;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="331" endline="340">
private static bool ParsePublicKeyToken (string str, out string publicKeyToken) {
    if (str == null) {
        publicKeyToken = null;
        return false;
    }
    publicKeyToken = str.ToLowerInvariant ();
    return true;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="342" endline="358">
private static bool ParsePublicKey (string str, out string publicKeyToken) {
    if (str == null) {
        publicKeyToken = null;
        return false;
    }
    byte [] token = new AssemblyName ("Foo, PublicKey=" + str).GetPublicKeyToken ();
    StringBuilder sb = new StringBuilder (token.Length * 2);
    for (int i = 0; i < token.Length; i ++) {
        sb.AppendFormat ("{0:x2}", token [i]);
    }
    publicKeyToken = sb.ToString ();
    return true;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="360" endline="363">
private static bool IsPartial (ParsedAssemblyName name) {
    return name.Version == null || name.Culture == null || name.PublicKeyToken == null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="365" endline="368">
private static bool IsStrongNamed (ParsedAssemblyName name) {
    return name.PublicKeyToken != null && name.PublicKeyToken != "null";
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Fusion.cs.ifdefed" startline="370" endline="384">
private static bool IsEqual (byte [] b1, byte [] b2) {
    if (b1.Length != b2.Length) {
        return false;
    }
    for (int i = 0; i < b1.Length; i ++) {
        if (b1 [i] != b2 [i]) {
            return false;
        }
    }
    return true;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="47" endline="54">
public override bool Equals (object obj) {
    GenericMethodInstance other = obj as GenericMethodInstance;
    return other != null && other.method.Equals (method) && other.declaringType.Equals (declaringType) && Util.ArrayEquals (other.methodArgs, methodArgs);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="56" endline="59">
public override int GetHashCode () {
    return declaringType.GetHashCode () * 33 ^ method.GetHashCode () ^ Util.GetHashCode (methodArgs);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="71" endline="79">
public override ParameterInfo [] GetParameters () {
    ParameterInfo [] parameters = method.GetParameters ();
    for (int i = 0; i < parameters.Length; i ++) {
        parameters [i] = new GenericParameterInfoImpl (this, parameters [i]);
    }
    return parameters;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="96" endline="99">
public override MethodImplAttributes GetMethodImplementationFlags () {
    return method.GetMethodImplementationFlags ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="121" endline="129">
public override MethodBody GetMethodBody () {
    IKVM.Reflection.Reader.MethodDefImpl md = method as IKVM.Reflection.Reader.MethodDefImpl;
    if (md != null) {
        return md.GetMethodBody (this);
    }
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="131" endline="134">
public override MethodInfo MakeGenericMethod (params Type [] typeArguments) {
    return new GenericMethodInstance (declaringType, method, typeArguments);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="168" endline="186">
public override MethodInfo GetGenericMethodDefinition () {
    if (this.IsGenericMethod) {
        if (this.IsGenericMethodDefinition) {
            return this;
        } else if (declaringType.IsGenericType && ! declaringType.IsGenericTypeDefinition) {
            return new GenericMethodInstance (declaringType, method, null);
        } else {
            return method;
        }
    }
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="188" endline="198">
public override Type [] GetGenericArguments () {
    if (methodArgs == null) {
        return method.GetGenericArguments ();
    } else {
        return (Type []) methodArgs.Clone ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="200" endline="210">
internal override Type GetGenericMethodArgument (int index) {
    if (methodArgs == null) {
        return method.GetGenericMethodArgument (index);
    } else {
        return methodArgs [index];
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="212" endline="215">
internal override int GetGenericMethodArgumentCount () {
    return method.GetGenericMethodArgumentCount ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="217" endline="220">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    return method.GetCustomAttributesData (attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="222" endline="225">
internal override MethodInfo GetMethodOnTypeDefinition () {
    return method.GetMethodOnTypeDefinition ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="227" endline="250">
internal override int ImportTo (Emit.ModuleBuilder module) {
    if (methodArgs == null) {
        return module.ImportMethodOrField (declaringType, method.Name, method.MethodSignature);
    } else {
        Writer.ByteBuffer spec = new Writer.ByteBuffer (10);
        Signature.WriteMethodSpec (module, spec, methodArgs);
        Metadata.MethodSpecTable.Record rec = new Metadata.MethodSpecTable.Record ();
        Emit.MethodBuilder mb = method as Emit.MethodBuilder;
        if (mb != null && mb.ModuleBuilder == module && ! declaringType.IsGenericType) {
            rec.Method = mb.MetadataToken;
        } else {
            rec.Method = module.ImportMember (GetGenericMethodDefinition ());
        }
        rec.Instantiation = module.Blobs.Add (spec);
        return 0x2B000000 | module.MethodSpec.FindOrAddRecord (rec);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="257" endline="261">
internal override MethodBase BindTypeParameters (Type type) {
    System.Diagnostics.Debug.Assert (methodArgs == null);
    return new GenericMethodInstance (declaringType.BindTypeParameters (type), method, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="275" endline="279">
public override bool Equals (object obj) {
    GenericFieldInstance other = obj as GenericFieldInstance;
    return other != null && other.declaringType.Equals (declaringType) && other.field.Equals (field);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="281" endline="284">
public override int GetHashCode () {
    return declaringType.GetHashCode () * 3 ^ field.GetHashCode ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="311" endline="314">
public override object GetRawConstantValue () {
    return field.GetRawConstantValue ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="316" endline="319">
public override void __GetDataFromRVA (byte [] data, int offset, int length) {
    field.__GetDataFromRVA (data, offset, length);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="321" endline="324">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    return field.GetCustomAttributesData (attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="331" endline="334">
internal override int ImportTo (Emit.ModuleBuilder module) {
    return module.ImportMethodOrField (declaringType, field.Name, field.FieldSignature);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="336" endline="339">
internal override FieldInfo BindTypeParameters (Type type) {
    return new GenericFieldInstance (declaringType.BindTypeParameters (type), field);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="378" endline="383">
public override Type [] GetOptionalCustomModifiers () {
    Type [] modifiers = parameterInfo.GetOptionalCustomModifiers ();
    Type.InplaceBindTypeParameters (method, modifiers);
    return modifiers;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="385" endline="390">
public override Type [] GetRequiredCustomModifiers () {
    Type [] modifiers = parameterInfo.GetRequiredCustomModifiers ();
    Type.InplaceBindTypeParameters (method, modifiers);
    return modifiers;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="419" endline="423">
public override bool Equals (object obj) {
    GenericPropertyInfo other = obj as GenericPropertyInfo;
    return other != null && other.typeInstance == typeInstance && other.property == property;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="425" endline="428">
public override int GetHashCode () {
    return typeInstance.GetHashCode () * 537 + property.GetHashCode ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="445" endline="452">
private MethodInfo Wrap (MethodInfo method) {
    if (method == null) {
        return null;
    }
    return new GenericMethodInstance (typeInstance, method, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="454" endline="457">
public override MethodInfo GetGetMethod (bool nonPublic) {
    return Wrap (property.GetGetMethod (nonPublic));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="459" endline="462">
public override MethodInfo GetSetMethod (bool nonPublic) {
    return Wrap (property.GetSetMethod (nonPublic));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="464" endline="472">
public override MethodInfo [] GetAccessors (bool nonPublic) {
    MethodInfo [] accessors = property.GetAccessors (nonPublic);
    for (int i = 0; i < accessors.Length; i ++) {
        accessors [i] = Wrap (accessors [i]);
    }
    return accessors;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="474" endline="477">
public override object GetRawConstantValue () {
    return property.GetRawConstantValue ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="514" endline="517">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    return property.GetCustomAttributesData (attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="519" endline="522">
internal override PropertyInfo BindTypeParameters (Type type) {
    return new GenericPropertyInfo (typeInstance.BindTypeParameters (type), property);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="536" endline="540">
public override bool Equals (object obj) {
    GenericEventInfo other = obj as GenericEventInfo;
    return other != null && other.typeInstance == typeInstance && other.eventInfo == eventInfo;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="542" endline="545">
public override int GetHashCode () {
    return typeInstance.GetHashCode () * 777 + eventInfo.GetHashCode ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="552" endline="559">
private MethodInfo Wrap (MethodInfo method) {
    if (method == null) {
        return null;
    }
    return new GenericMethodInstance (typeInstance, method, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="561" endline="564">
public override MethodInfo GetAddMethod (bool nonPublic) {
    return Wrap (eventInfo.GetAddMethod (nonPublic));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="566" endline="569">
public override MethodInfo GetRaiseMethod (bool nonPublic) {
    return Wrap (eventInfo.GetRaiseMethod (nonPublic));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="571" endline="574">
public override MethodInfo GetRemoveMethod (bool nonPublic) {
    return Wrap (eventInfo.GetRemoveMethod (nonPublic));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="576" endline="584">
public override MethodInfo [] GetOtherMethods (bool nonPublic) {
    MethodInfo [] others = eventInfo.GetOtherMethods (nonPublic);
    for (int i = 0; i < others.Length; i ++) {
        others [i] = Wrap (others [i]);
    }
    return others;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="611" endline="614">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    return eventInfo.GetCustomAttributesData (attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/GenericWrappers.cs.ifdefed" startline="616" endline="619">
internal override EventInfo BindTypeParameters (Type type) {
    return new GenericEventInfo (typeInstance.BindTypeParameters (type), eventInfo);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Impl/CryptoHack.cs.ifdefed" startline="34" endline="54">
internal static RSA CreateRSA (StrongNameKeyPair keyPair) {
    SerializationInfo ser = new SerializationInfo (typeof (StrongNameKeyPair), new FormatterConverter ());
    ((ISerializable) keyPair.keyPair).GetObjectData (ser, new StreamingContext ());
    byte [] key = (byte []) ser.GetValue ("_keyPairArray", typeof (byte []));
    string keycontainer = ser.GetString ("_keyPairContainer");
    if (keycontainer != null) {
        CspParameters parm = new CspParameters ();
        parm.Flags = CspProviderFlags.UseMachineKeyStore;
        parm.KeyContainerName = keycontainer;
        parm.KeyNumber = 2;
        return new RSACryptoServiceProvider (parm);
    } else {
        return Mono.Security.Cryptography.CryptoConvert.FromCapiKeyBlob (key);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MarshalSpec.cs.ifdefed" startline="39" endline="164">
internal static CustomAttributeData GetMarshalAsAttribute (Module module, int token) {
    for (int i = 0; i < module.FieldMarshal.records.Length; i ++) {
        if (module.FieldMarshal.records [i].Parent == token) {
            ByteReader blob = module.GetBlob (module.FieldMarshal.records [i].NativeType);
            UnmanagedType unmanagedType = (UnmanagedType) blob.ReadCompressedInt ();
            UnmanagedType ? arraySubType = null;
            short ? sizeParamIndex = null;
            int ? sizeConst = null;
            VarEnum ? safeArraySubType = null;
            Type safeArrayUserDefinedSubType = null;
            int ? iidParameterIndex = null;
            string marshalType = null;
            string marshalCookie = null;
            Type marshalTypeRef = null;
            if (unmanagedType == UnmanagedType.LPArray) {
                arraySubType = (UnmanagedType) blob.ReadCompressedInt ();
                if (arraySubType == NATIVE_TYPE_MAX) {
                    arraySubType = null;
                }
                if (blob.Length != 0) {
                    sizeParamIndex = (short) blob.ReadCompressedInt ();
                    if (blob.Length != 0) {
                        sizeConst = blob.ReadCompressedInt ();
                        if (blob.Length != 0 && blob.ReadCompressedInt () == 0) {
                            sizeParamIndex = null;
                        }
                    }
                }
            } else if (unmanagedType == UnmanagedType.SafeArray) {
                if (blob.Length != 0) {
                    safeArraySubType = (VarEnum) blob.ReadCompressedInt ();
                    if (blob.Length != 0) {
                        safeArrayUserDefinedSubType = ReadType (module, blob);
                    }
                }
            } else if (unmanagedType == UnmanagedType.ByValArray) {
                sizeConst = blob.ReadCompressedInt ();
                if (blob.Length != 0) {
                    arraySubType = (UnmanagedType) blob.ReadCompressedInt ();
                }
            } else if (unmanagedType == UnmanagedType.ByValTStr) {
                sizeConst = blob.ReadCompressedInt ();
            } else if (unmanagedType == UnmanagedType.Interface || unmanagedType == UnmanagedType.IDispatch || unmanagedType == UnmanagedType.IUnknown) {
                if (blob.Length != 0) {
                    iidParameterIndex = blob.ReadCompressedInt ();
                }
            } else if (unmanagedType == UnmanagedType.CustomMarshaler) {
                blob.ReadCompressedInt ();
                blob.ReadCompressedInt ();
                marshalType = ReadString (blob);
                marshalCookie = ReadString (blob);
                marshalTypeRef = module.Assembly.GetType (marshalType) ?? module.universe.GetType (marshalType);
            }
            Type typeofMarshalAs = module.universe.System_Runtime_InteropServices_MarshalAsAttribute;
            Type typeofUnmanagedType = module.universe.System_Runtime_InteropServices_UnmanagedType;
            Type typeofVarEnum = module.universe.System_Runtime_InteropServices_VarEnum;
            Type typeofType = module.universe.System_Type;
            List < CustomAttributeNamedArgument > named = new List < CustomAttributeNamedArgument > ();
            if (arraySubType != null) {
                named.Add (new CustomAttributeNamedArgument (typeofMarshalAs.GetField ("ArraySubType"), new CustomAttributeTypedArgument (typeofUnmanagedType, arraySubType.Value)));
            }
            if (sizeParamIndex != null) {
                named.Add (new CustomAttributeNamedArgument (typeofMarshalAs.GetField ("SizeParamIndex"), new CustomAttributeTypedArgument (module.universe.System_Int16, sizeParamIndex.Value)));
            }
            if (sizeConst != null) {
                named.Add (new CustomAttributeNamedArgument (typeofMarshalAs.GetField ("SizeConst"), new CustomAttributeTypedArgument (module.universe.System_Int32, sizeConst.Value)));
            }
            if (safeArraySubType != null) {
                named.Add (new CustomAttributeNamedArgument (typeofMarshalAs.GetField ("SafeArraySubType"), new CustomAttributeTypedArgument (typeofVarEnum, safeArraySubType.Value)));
            }
            if (safeArrayUserDefinedSubType != null) {
                named.Add (new CustomAttributeNamedArgument (typeofMarshalAs.GetField ("SafeArrayUserDefinedSubType"), new CustomAttributeTypedArgument (typeofType, safeArrayUserDefinedSubType)));
            }
            if (iidParameterIndex != null) {
                named.Add (new CustomAttributeNamedArgument (typeofMarshalAs.GetField ("IidParameterIndex"), new CustomAttributeTypedArgument (module.universe.System_Int32, iidParameterIndex.Value)));
            }
            if (marshalType != null) {
                named.Add (new CustomAttributeNamedArgument (typeofMarshalAs.GetField ("MarshalType"), new CustomAttributeTypedArgument (module.universe.System_String, marshalType)));
            }
            if (marshalTypeRef != null) {
                named.Add (new CustomAttributeNamedArgument (typeofMarshalAs.GetField ("MarshalTypeRef"), new CustomAttributeTypedArgument (module.universe.System_Type, marshalTypeRef)));
            }
            if (marshalCookie != null) {
                named.Add (new CustomAttributeNamedArgument (typeofMarshalAs.GetField ("MarshalCookie"), new CustomAttributeTypedArgument (module.universe.System_String, marshalCookie)));
            }
            ConstructorInfo constructor = typeofMarshalAs.GetConstructor (new Type [] {typeofUnmanagedType});
            return new CustomAttributeData (constructor, new object [] {unmanagedType}, named);
        }
    }
    throw new BadImageFormatException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MarshalSpec.cs.ifdefed" startline="166" endline="173">
internal static void SetMarshalAsAttribute (ModuleBuilder module, int token, CustomAttributeBuilder attribute) {
    attribute = attribute.DecodeBlob (module.Assembly);
    FieldMarshalTable.Record rec = new FieldMarshalTable.Record ();
    rec.Parent = token;
    rec.NativeType = WriteMarshallingDescriptor (module, attribute);
    module.FieldMarshal.AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MarshalSpec.cs.ifdefed" startline="175" endline="270">
private static int WriteMarshallingDescriptor (ModuleBuilder module, CustomAttributeBuilder attribute) {
    UnmanagedType unmanagedType;
    object val = attribute.GetConstructorArgument (0);
    if (val is short) {
        unmanagedType = (UnmanagedType) (short) val;
    } else if (val is int) {
        unmanagedType = (UnmanagedType) (int) val;
    } else {
        unmanagedType = (UnmanagedType) val;
    }
    ByteBuffer bb = new ByteBuffer (5);
    bb.WriteCompressedInt ((int) unmanagedType);
    if (unmanagedType == UnmanagedType.LPArray) {
        UnmanagedType arraySubType = attribute.GetFieldValue < UnmanagedType > ("ArraySubType") ?? NATIVE_TYPE_MAX;
        bb.WriteCompressedInt ((int) arraySubType);
        int ? sizeParamIndex = attribute.GetFieldValue < short > ("SizeParamIndex");
        int ? sizeConst = attribute.GetFieldValue < int > ("SizeConst");
        if (sizeParamIndex != null) {
            bb.WriteCompressedInt (sizeParamIndex.Value);
            if (sizeConst != null) {
                bb.WriteCompressedInt (sizeConst.Value);
                bb.WriteCompressedInt (1);
            }
        } else if (sizeConst != null) {
            bb.WriteCompressedInt (0);
            bb.WriteCompressedInt (sizeConst.Value);
            bb.WriteCompressedInt (0);
        }
    } else if (unmanagedType == UnmanagedType.SafeArray) {
        VarEnum ? safeArraySubType = attribute.GetFieldValue < VarEnum > ("SafeArraySubType");
        if (safeArraySubType != null) {
            bb.WriteCompressedInt ((int) safeArraySubType);
            Type safeArrayUserDefinedSubType = (Type) attribute.GetFieldValue ("SafeArrayUserDefinedSubType");
            if (safeArrayUserDefinedSubType != null) {
                WriteType (module, bb, safeArrayUserDefinedSubType);
            }
        }
    } else if (unmanagedType == UnmanagedType.ByValArray) {
        bb.WriteCompressedInt (attribute.GetFieldValue < int > ("SizeConst") ?? 1);
        UnmanagedType ? arraySubType = attribute.GetFieldValue < UnmanagedType > ("ArraySubType");
        if (arraySubType != null) {
            bb.WriteCompressedInt ((int) arraySubType);
        }
    } else if (unmanagedType == UnmanagedType.ByValTStr) {
        bb.WriteCompressedInt (attribute.GetFieldValue < int > ("SizeConst").Value);
    } else if (unmanagedType == UnmanagedType.Interface || unmanagedType == UnmanagedType.IDispatch || unmanagedType == UnmanagedType.IUnknown) {
        int ? iidParameterIndex = attribute.GetFieldValue < int > ("IidParameterIndex");
        if (iidParameterIndex != null) {
            bb.WriteCompressedInt (iidParameterIndex.Value);
        }
    } else if (unmanagedType == UnmanagedType.CustomMarshaler) {
        bb.WriteCompressedInt (0);
        bb.WriteCompressedInt (0);
        string marshalType = (string) attribute.GetFieldValue ("MarshalType");
        if (marshalType != null) {
            WriteString (bb, marshalType);
        } else {
            WriteType (module, bb, (Type) attribute.GetFieldValue ("MarshalTypeRef"));
        }
        WriteString (bb, (string) attribute.GetFieldValue ("MarshalCookie") ?? "");
    }
    return module.Blobs.Add (bb);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MarshalSpec.cs.ifdefed" startline="272" endline="280">
private static Type ReadType (Module module, ByteReader br) {
    string str = ReadString (br);
    if (str == "") {
        return null;
    }
    return module.Assembly.GetType (str) ?? module.universe.GetType (str, true);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MarshalSpec.cs.ifdefed" startline="282" endline="285">
private static void WriteType (Module module, ByteBuffer bb, Type type) {
    WriteString (bb, type.Assembly == module.Assembly ? type.FullName : type.AssemblyQualifiedName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MarshalSpec.cs.ifdefed" startline="287" endline="290">
private static string ReadString (ByteReader br) {
    return Encoding.UTF8.GetString (br.ReadBytes (br.ReadCompressedInt ()));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MarshalSpec.cs.ifdefed" startline="292" endline="297">
private static void WriteString (ByteBuffer bb, string str) {
    byte [] buf = Encoding.UTF8.GetBytes (str);
    bb.WriteCompressedInt (buf.Length);
    bb.Write (buf);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/CliHeader.cs.ifdefed" startline="52" endline="70">
internal void Read (BinaryReader br) {
    Cb = br.ReadUInt32 ();
    MajorRuntimeVersion = br.ReadUInt16 ();
    MinorRuntimeVersion = br.ReadUInt16 ();
    MetaDataRVA = br.ReadUInt32 ();
    MetaDataSize = br.ReadUInt32 ();
    Flags = br.ReadUInt32 ();
    EntryPointToken = br.ReadUInt32 ();
    ResourcesRVA = br.ReadUInt32 ();
    ResourcesSize = br.ReadUInt32 ();
    StrongNameSignatureRVA = br.ReadUInt32 ();
    StrongNameSignatureSize = br.ReadUInt32 ();
    CodeManagerTable = br.ReadUInt32 ();
    VTableFixupsRVA = br.ReadUInt32 ();
    VTableFixupsSize = br.ReadUInt32 ();
    ExportAddressTableJumps = br.ReadUInt32 ();
    ManagedNativeHeader = br.ReadUInt32 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/CliHeader.cs.ifdefed" startline="72" endline="90">
internal void Write (IKVM.Reflection.Writer.MetadataWriter mw) {
    mw.Write (Cb);
    mw.Write (MajorRuntimeVersion);
    mw.Write (MinorRuntimeVersion);
    mw.Write (MetaDataRVA);
    mw.Write (MetaDataSize);
    mw.Write (Flags);
    mw.Write (EntryPointToken);
    mw.Write (ResourcesRVA);
    mw.Write (ResourcesSize);
    mw.Write (StrongNameSignatureRVA);
    mw.Write (StrongNameSignatureSize);
    mw.Write (CodeManagerTable);
    mw.Write (VTableFixupsRVA);
    mw.Write (VTableFixupsSize);
    mw.Write (ExportAddressTableJumps);
    mw.Write (ManagedNativeHeader);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/MetadataRW.cs.ifdefed" startline="88" endline="99">
private static bool IsBig (int bitsUsed, params Table [] tables) {
    int limit = 1 << (16 - bitsUsed);
    foreach (Table table in tables) {
        if (table.RowCount >= limit) {
            return true;
        }
    }
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="45" endline="48">
internal int GetLength (MetadataWriter md) {
    return RowCount * GetRowSize (new RowSizeCalc (md));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="62" endline="66">
internal RowSizeCalc AddFixed (int size) {
    this.size += size;
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="68" endline="79">
internal RowSizeCalc WriteStringIndex () {
    if (mw.bigStrings) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="81" endline="92">
internal RowSizeCalc WriteGuidIndex () {
    if (mw.bigGuids) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="94" endline="105">
internal RowSizeCalc WriteBlobIndex () {
    if (mw.bigBlobs) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="107" endline="118">
internal RowSizeCalc WriteTypeDefOrRef () {
    if (mw.bigTypeDefOrRef) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="120" endline="131">
internal RowSizeCalc WriteField () {
    if (mw.bigField) {
        size += 4;
    } else {
        size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="133" endline="144">
internal RowSizeCalc WriteMethodDef () {
    if (mw.bigMethodDef) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="146" endline="157">
internal RowSizeCalc WriteParam () {
    if (mw.bigParam) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="159" endline="170">
internal RowSizeCalc WriteResolutionScope () {
    if (mw.bigResolutionScope) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="172" endline="183">
internal RowSizeCalc WriteMemberRefParent () {
    if (mw.bigMemberRefParent) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="185" endline="196">
internal RowSizeCalc WriteHasCustomAttribute () {
    if (mw.bigHasCustomAttribute) {
        size += 4;
    } else {
        size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="198" endline="209">
internal RowSizeCalc WriteCustomAttributeType () {
    if (mw.bigCustomAttributeType) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="211" endline="222">
internal RowSizeCalc WriteHasConstant () {
    if (mw.bigHasConstant) {
        size += 4;
    } else {
        size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="224" endline="235">
internal RowSizeCalc WriteTypeDef () {
    if (mw.bigTypeDef) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="237" endline="248">
internal RowSizeCalc WriteMethodDefOrRef () {
    if (mw.bigMethodDefOrRef) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="250" endline="261">
internal RowSizeCalc WriteEvent () {
    if (mw.bigEvent) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="263" endline="274">
internal RowSizeCalc WriteProperty () {
    if (mw.bigProperty) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="276" endline="287">
internal RowSizeCalc WriteHasSemantics () {
    if (mw.bigHasSemantics) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="289" endline="300">
internal RowSizeCalc WriteImplementation () {
    if (mw.bigImplementation) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="302" endline="313">
internal RowSizeCalc WriteTypeOrMethodDef () {
    if (mw.bigTypeOrMethodDef) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="315" endline="326">
internal RowSizeCalc WriteGenericParam () {
    if (mw.bigGenericParam) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="328" endline="339">
internal RowSizeCalc WriteHasDeclSecurity () {
    if (mw.bigHasDeclSecurity) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="341" endline="352">
internal RowSizeCalc WriteMemberForwarded () {
    if (mw.bigMemberForwarded) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="354" endline="365">
internal RowSizeCalc WriteModuleRef () {
    if (mw.bigModuleRef) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="367" endline="378">
internal RowSizeCalc WriteHasFieldMarshal () {
    if (mw.bigHasFieldMarshal) {
        this.size += 4;
    } else {
        this.size += 2;
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="398" endline="401">
protected override int GetRowSize (RowSizeCalc rsc) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="403" endline="413">
internal int AddRecord (T newRecord) {
    if (rowCount == records.Length) {
        T [] newarr = new T [records.Length * 2];
        Array.Copy (records, newarr, records.Length);
        records = newarr;
    }
    records [rowCount ++] = newRecord;
    return rowCount;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="415" endline="418">
internal int AddVirtualRecord () {
    return ++ rowCount;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="420" endline="423">
internal override void Write (MetadataWriter mw) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="439" endline="449">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Generation = mr.ReadInt16 ();
        records [i].Name = mr.ReadStringIndex ();
        records [i].Mvid = mr.ReadGuidIndex ();
        records [i].EncId = mr.ReadGuidIndex ();
        records [i].EncBaseId = mr.ReadGuidIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="451" endline="461">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].Generation);
        mw.WriteStringIndex (records [i].Name);
        mw.WriteGuidIndex (records [i].Mvid);
        mw.WriteGuidIndex (records [i].EncId);
        mw.WriteGuidIndex (records [i].EncBaseId);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="463" endline="472">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (2).WriteStringIndex ().WriteGuidIndex ().WriteGuidIndex ().WriteGuidIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="474" endline="483">
internal void Add (short generation, int name, int mvid, int encid, int encbaseid) {
    Record record = new Record ();
    record.Generation = generation;
    record.Name = name;
    record.Mvid = mvid;
    record.EncId = encid;
    record.EncBaseId = encbaseid;
    AddRecord (record);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="497" endline="505">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].ResolutionScope = mr.ReadResolutionScope ();
        records [i].TypeName = mr.ReadStringIndex ();
        records [i].TypeNameSpace = mr.ReadStringIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="507" endline="515">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteResolutionScope (records [i].ResolutionScope);
        mw.WriteStringIndex (records [i].TypeName);
        mw.WriteStringIndex (records [i].TypeNameSpace);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="517" endline="524">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteResolutionScope ().WriteStringIndex ().WriteStringIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="541" endline="552">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Flags = mr.ReadInt32 ();
        records [i].TypeName = mr.ReadStringIndex ();
        records [i].TypeNamespace = mr.ReadStringIndex ();
        records [i].Extends = mr.ReadTypeDefOrRef ();
        records [i].FieldList = mr.ReadField ();
        records [i].MethodList = mr.ReadMethodDef ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="554" endline="557">
internal override void Write (MetadataWriter mw) {
    mw.ModuleBuilder.WriteTypeDefTable (mw);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="559" endline="562">
internal int AllocToken () {
    return 0x02000000 + AddVirtualRecord ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="564" endline="574">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (4).WriteStringIndex ().WriteStringIndex ().WriteTypeDefOrRef ().WriteField ().WriteMethodDef ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="588" endline="596">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Flags = mr.ReadInt16 ();
        records [i].Name = mr.ReadStringIndex ();
        records [i].Signature = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="598" endline="601">
internal override void Write (MetadataWriter mw) {
    mw.ModuleBuilder.WriteFieldTable (mw);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="603" endline="610">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (2).WriteStringIndex ().WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="628" endline="639">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].RVA = mr.ReadInt32 ();
        records [i].ImplFlags = mr.ReadInt16 ();
        records [i].Flags = mr.ReadInt16 ();
        records [i].Name = mr.ReadStringIndex ();
        records [i].Signature = mr.ReadBlobIndex ();
        records [i].ParamList = mr.ReadParam ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="641" endline="644">
internal override void Write (MetadataWriter mw) {
    mw.ModuleBuilder.WriteMethodDefTable (baseRVA, mw);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="646" endline="654">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (8).WriteStringIndex ().WriteBlobIndex ().WriteParam ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="656" endline="659">
internal void Fixup (TextSection code) {
    baseRVA = (int) code.MethodBodiesRVA;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="673" endline="681">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Flags = mr.ReadInt16 ();
        records [i].Sequence = mr.ReadInt16 ();
        records [i].Name = mr.ReadStringIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="683" endline="686">
internal override void Write (MetadataWriter mw) {
    mw.ModuleBuilder.WriteParamTable (mw);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="688" endline="694">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (4).WriteStringIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="707" endline="714">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Class = mr.ReadTypeDef ();
        records [i].Interface = mr.ReadTypeDefOrRef ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="716" endline="723">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteTypeDef (records [i].Class);
        mw.WriteEncodedTypeDefOrRef (records [i].Interface);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="725" endline="731">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteTypeDef ().WriteTypeDefOrRef ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="733" endline="757">
internal void Fixup () {
    for (int i = 0; i < rowCount; i ++) {
        int token = records [i].Interface;
        switch (token > > 24) {
            case 0 :
                break;
            case TypeDefTable.Index :
                token = (token & 0xFFFFFF) << 2 | 0;
                break;
            case TypeRefTable.Index :
                token = (token & 0xFFFFFF) << 2 | 1;
                break;
            case TypeSpecTable.Index :
                token = (token & 0xFFFFFF) << 2 | 2;
                break;
            default :
                throw new InvalidOperationException ();
        }
        records [i].Interface = token;
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="759" endline="766">
int IComparer < Record >.Compare (Record x, Record y) {
    if (x.Class == y.Class) {
        return x.Interface == y.Interface ? 0 : (x.Interface > y.Interface ? 1 : - 1);
    }
    return x.Class > y.Class ? 1 : - 1;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="780" endline="788">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Class = mr.ReadMemberRefParent ();
        records [i].Name = mr.ReadStringIndex ();
        records [i].Signature = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="790" endline="798">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteMemberRefParent (records [i].Class);
        mw.WriteStringIndex (records [i].Name);
        mw.WriteBlobIndex (records [i].Signature);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="800" endline="807">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteMemberRefParent ().WriteStringIndex ().WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="809" endline="821">
internal int FindOrAddRecord (Record record) {
    for (int i = 0; i < rowCount; i ++) {
        if (records [i].Class == record.Class && records [i].Name == record.Name && records [i].Signature == record.Signature) {
            return i + 1;
        }
    }
    return AddRecord (record);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="823" endline="832">
internal void Fixup (ModuleBuilder moduleBuilder) {
    for (int i = 0; i < rowCount; i ++) {
        if (moduleBuilder.IsPseudoToken (records [i].Class)) {
            records [i].Class = moduleBuilder.ResolvePseudoToken (records [i].Class);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="846" endline="854">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Type = mr.ReadInt16 ();
        records [i].Parent = mr.ReadHasConstant ();
        records [i].Value = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="856" endline="864">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].Type);
        mw.WriteHasConstant (records [i].Parent);
        mw.WriteBlobIndex (records [i].Value);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="866" endline="873">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (2).WriteHasConstant ().WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="875" endline="901">
internal void Fixup (ModuleBuilder moduleBuilder) {
    for (int i = 0; i < rowCount; i ++) {
        int token = records [i].Parent;
        if (moduleBuilder.IsPseudoToken (token)) {
            token = moduleBuilder.ResolvePseudoToken (token);
        }
        switch (token > > 24) {
            case FieldTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 2 | 0;
                break;
            case ParamTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 2 | 1;
                break;
            case PropertyTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 2 | 2;
                break;
            default :
                throw new InvalidOperationException ();
        }
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="903" endline="906">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.Parent == y.Parent ? 0 : (x.Parent > y.Parent ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="908" endline="964">
internal object GetRawConstantValue (Module module, int parent) {
    for (int i = 0; i < module.Constant.records.Length; i ++) {
        if (module.Constant.records [i].Parent == parent) {
            ByteReader br = module.GetBlob (module.Constant.records [i].Value);
            switch (module.Constant.records [i].Type) {
                case Signature.ELEMENT_TYPE_BOOLEAN :
                    return br.ReadByte () != 0;
                case Signature.ELEMENT_TYPE_I1 :
                    return br.ReadSByte ();
                case Signature.ELEMENT_TYPE_I2 :
                    return br.ReadInt16 ();
                case Signature.ELEMENT_TYPE_I4 :
                    return br.ReadInt32 ();
                case Signature.ELEMENT_TYPE_I8 :
                    return br.ReadInt64 ();
                case Signature.ELEMENT_TYPE_U1 :
                    return br.ReadByte ();
                case Signature.ELEMENT_TYPE_U2 :
                    return br.ReadUInt16 ();
                case Signature.ELEMENT_TYPE_U4 :
                    return br.ReadUInt32 ();
                case Signature.ELEMENT_TYPE_U8 :
                    return br.ReadUInt64 ();
                case Signature.ELEMENT_TYPE_R4 :
                    return br.ReadSingle ();
                case Signature.ELEMENT_TYPE_R8 :
                    return br.ReadDouble ();
                case Signature.ELEMENT_TYPE_CHAR :
                    return br.ReadChar ();
                case Signature.ELEMENT_TYPE_STRING :
                    {
                        char [] chars = new char [br.Length / 2];
                        for (int j = 0; j < chars.Length; j ++) {
                            chars [j] = br.ReadChar ();
                        }
                        return new String (chars);
                    } case Signature.ELEMENT_TYPE_CLASS :
                    if (br.ReadInt32 () != 0) {
                        throw new BadImageFormatException ();
                    }
                    return null;
                default :
                    throw new BadImageFormatException ();
            }
        }
    }
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="978" endline="986">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Parent = mr.ReadHasCustomAttribute ();
        records [i].Type = mr.ReadCustomAttributeType ();
        records [i].Value = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="988" endline="996">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteHasCustomAttribute (records [i].Parent);
        mw.WriteCustomAttributeType (records [i].Type);
        mw.WriteBlobIndex (records [i].Value);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="998" endline="1005">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteHasCustomAttribute ().WriteCustomAttributeType ().WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1007" endline="1087">
internal void Fixup (ModuleBuilder moduleBuilder) {
    int [] genericParamFixup = moduleBuilder.GenericParam.GetIndexFixup ();
    for (int i = 0; i < rowCount; i ++) {
        if (moduleBuilder.IsPseudoToken (records [i].Type)) {
            records [i].Type = moduleBuilder.ResolvePseudoToken (records [i].Type);
        }
        int token = records [i].Parent;
        if (moduleBuilder.IsPseudoToken (token)) {
            token = moduleBuilder.ResolvePseudoToken (token);
        }
        switch (token > > 24) {
            case MethodDefTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 0;
                break;
            case FieldTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 1;
                break;
            case TypeRefTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 2;
                break;
            case TypeDefTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 3;
                break;
            case ParamTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 4;
                break;
            case InterfaceImplTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 5;
                break;
            case MemberRefTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 6;
                break;
            case ModuleTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 7;
                break;
            case PropertyTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 9;
                break;
            case EventTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 10;
                break;
            case StandAloneSigTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 11;
                break;
            case ModuleRefTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 12;
                break;
            case TypeSpecTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 13;
                break;
            case AssemblyTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 14;
                break;
            case AssemblyRefTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 15;
                break;
            case FileTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 16;
                break;
            case ExportedTypeTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 17;
                break;
            case ManifestResourceTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 5 | 18;
                break;
            case GenericParamTable.Index :
                records [i].Parent = (genericParamFixup [(token & 0xFFFFFF) - 1] + 1) << 5 | 19;
                break;
            default :
                throw new InvalidOperationException ();
        }
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1089" endline="1092">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.Parent == y.Parent ? 0 : (x.Parent > y.Parent ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1105" endline="1112">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Parent = mr.ReadHasFieldMarshal ();
        records [i].NativeType = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1114" endline="1121">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteHasFieldMarshal (records [i].Parent);
        mw.WriteBlobIndex (records [i].NativeType);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1123" endline="1129">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteHasFieldMarshal ().WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1131" endline="1150">
internal void Fixup (ModuleBuilder moduleBuilder) {
    for (int i = 0; i < rowCount; i ++) {
        int token = moduleBuilder.ResolvePseudoToken (records [i].Parent);
        switch (token > > 24) {
            case FieldTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 1 | 0;
                break;
            case ParamTable.Index :
                records [i].Parent = (token & 0xFFFFFF) << 1 | 1;
                break;
            default :
                throw new InvalidOperationException ();
        }
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1152" endline="1155">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.Parent == y.Parent ? 0 : (x.Parent > y.Parent ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1169" endline="1177">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Action = mr.ReadInt16 ();
        records [i].Parent = mr.ReadHasDeclSecurity ();
        records [i].PermissionSet = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1179" endline="1187">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].Action);
        mw.WriteHasDeclSecurity (records [i].Parent);
        mw.WriteBlobIndex (records [i].PermissionSet);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1189" endline="1196">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (2).WriteHasDeclSecurity ().WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1198" endline="1225">
internal void Fixup (ModuleBuilder moduleBuilder) {
    for (int i = 0; i < rowCount; i ++) {
        int token = records [i].Parent;
        if (moduleBuilder.IsPseudoToken (token)) {
            token = moduleBuilder.ResolvePseudoToken (token);
        }
        switch (token > > 24) {
            case TypeDefTable.Index :
                token = (token & 0xFFFFFF) << 2 | 0;
                break;
            case MethodDefTable.Index :
                token = (token & 0xFFFFFF) << 2 | 1;
                break;
            case AssemblyTable.Index :
                token = (token & 0xFFFFFF) << 2 | 2;
                break;
            default :
                throw new InvalidOperationException ();
        }
        records [i].Parent = token;
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1227" endline="1230">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.Parent == y.Parent ? 0 : (x.Parent > y.Parent ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1244" endline="1255">
internal void AddOrReplaceRecord (Record rec) {
    for (int i = 0; i < records.Length; i ++) {
        if (records [i].Parent == rec.Parent) {
            records [i] = rec;
            return;
        }
    }
    AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1257" endline="1265">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].PackingSize = mr.ReadInt16 ();
        records [i].ClassSize = mr.ReadInt32 ();
        records [i].Parent = mr.ReadTypeDef ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1267" endline="1276">
internal override void Write (MetadataWriter mw) {
    Array.Sort (records, 0, rowCount, this);
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].PackingSize);
        mw.Write (records [i].ClassSize);
        mw.WriteTypeDef (records [i].Parent);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1278" endline="1284">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (6).WriteTypeDef ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1286" endline="1289">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.Parent == y.Parent ? 0 : (x.Parent > y.Parent ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1291" endline="1302">
internal void GetLayout (int token, ref int pack, ref int size) {
    for (int i = 0; i < rowCount; i ++) {
        if (records [i].Parent == token) {
            pack = records [i].PackingSize;
            size = records [i].ClassSize;
            break;
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1315" endline="1322">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Offset = mr.ReadInt32 ();
        records [i].Field = mr.ReadField ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1324" endline="1331">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].Offset);
        mw.WriteField (records [i].Field);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1333" endline="1339">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (4).WriteField ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1341" endline="1348">
internal void Fixup (ModuleBuilder moduleBuilder) {
    for (int i = 0; i < rowCount; i ++) {
        records [i].Field = moduleBuilder.ResolvePseudoToken (records [i].Field);
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1350" endline="1353">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.Field == y.Field ? 0 : (x.Field > y.Field ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1360" endline="1366">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i] = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1368" endline="1374">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteBlobIndex (records [i]);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1376" endline="1379">
protected override int GetRowSize (Table.RowSizeCalc rsc) {
    return rsc.WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1381" endline="1391">
internal int FindOrAddRecord (int blob) {
    for (int i = 0; i < rowCount; i ++) {
        if (records [i] == blob) {
            return i + 1;
        }
    }
    return AddRecord (blob);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1404" endline="1411">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Parent = mr.ReadTypeDef ();
        records [i].EventList = mr.ReadEvent ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1413" endline="1420">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteTypeDef (records [i].Parent);
        mw.WriteEvent (records [i].EventList);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1422" endline="1428">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteTypeDef ().WriteEvent ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1442" endline="1450">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].EventFlags = mr.ReadInt16 ();
        records [i].Name = mr.ReadStringIndex ();
        records [i].EventType = mr.ReadTypeDefOrRef ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1452" endline="1460">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].EventFlags);
        mw.WriteStringIndex (records [i].Name);
        mw.WriteTypeDefOrRef (records [i].EventType);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1462" endline="1469">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (2).WriteStringIndex ().WriteTypeDefOrRef ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1482" endline="1489">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Parent = mr.ReadTypeDef ();
        records [i].PropertyList = mr.ReadProperty ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1491" endline="1498">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteTypeDef (records [i].Parent);
        mw.WriteProperty (records [i].PropertyList);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1500" endline="1506">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteTypeDef ().WriteProperty ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1520" endline="1528">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Flags = mr.ReadInt16 ();
        records [i].Name = mr.ReadStringIndex ();
        records [i].Type = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1530" endline="1538">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].Flags);
        mw.WriteStringIndex (records [i].Name);
        mw.WriteBlobIndex (records [i].Type);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1540" endline="1547">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (2).WriteStringIndex ().WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1569" endline="1577">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Semantics = mr.ReadInt16 ();
        records [i].Method = mr.ReadMethodDef ();
        records [i].Association = mr.ReadHasSemantics ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1579" endline="1587">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].Semantics);
        mw.WriteMethodDef (records [i].Method);
        mw.WriteHasSemantics (records [i].Association);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1589" endline="1596">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (2).WriteMethodDef ().WriteHasSemantics ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1598" endline="1622">
internal void Fixup (ModuleBuilder moduleBuilder) {
    for (int i = 0; i < rowCount; i ++) {
        if (moduleBuilder.IsPseudoToken (records [i].Method)) {
            records [i].Method = moduleBuilder.ResolvePseudoToken (records [i].Method);
        }
        int token = records [i].Association;
        switch (token > > 24) {
            case EventTable.Index :
                token = (token & 0xFFFFFF) << 1 | 0;
                break;
            case PropertyTable.Index :
                token = (token & 0xFFFFFF) << 1 | 1;
                break;
            default :
                throw new InvalidOperationException ();
        }
        records [i].Association = token;
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1624" endline="1627">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.Association == y.Association ? 0 : (x.Association > y.Association ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1629" endline="1633">
internal MethodInfo GetMethod (Module module, int token, bool nonPublic, short semantics) {
    int i = 0;
    return GetNextMethod (module, token, nonPublic, semantics, ref i);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1635" endline="1644">
internal MethodInfo [] GetMethods (Module module, int token, bool nonPublic, short semantics) {
    List < MethodInfo > methods = new List < MethodInfo > ();
    MethodInfo method;
    for (int i = 0; (method = GetNextMethod (module, token, nonPublic, semantics, ref i)) != null;) {
        methods.Add (method);
    }
    return methods.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1646" endline="1665">
private MethodInfo GetNextMethod (Module module, int token, bool nonPublic, short semantics, ref int i) {
    for (; i < records.Length; i ++) {
        if (records [i].Association == token) {
            if ((records [i].Semantics & semantics) != 0) {
                MethodInfo method = (MethodInfo) module.ResolveMethod ((MethodDefTable.Index << 24) + records [i].Method);
                if (nonPublic || method.IsPublic) {
                    i ++;
                    return method;
                }
            }
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1667" endline="1683">
internal void ComputeFlags (Module module, int token, out bool isPublic, out bool isStatic) {
    isPublic = false;
    isStatic = false;
    MethodInfo method;
    for (int i = 0; (method = GetNextMethod (module, token, true, - 1, ref i)) != null;) {
        if (method.IsPublic) {
            isPublic = true;
        }
        if (method.IsStatic) {
            isStatic = true;
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1697" endline="1705">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Class = mr.ReadTypeDef ();
        records [i].MethodBody = mr.ReadMethodDefOrRef ();
        records [i].MethodDeclaration = mr.ReadMethodDefOrRef ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1707" endline="1715">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteTypeDef (records [i].Class);
        mw.WriteMethodDefOrRef (records [i].MethodBody);
        mw.WriteMethodDefOrRef (records [i].MethodDeclaration);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1717" endline="1724">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteTypeDef ().WriteMethodDefOrRef ().WriteMethodDefOrRef ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1726" endline="1740">
internal void Fixup (ModuleBuilder moduleBuilder) {
    for (int i = 0; i < rowCount; i ++) {
        if (moduleBuilder.IsPseudoToken (records [i].MethodBody)) {
            records [i].MethodBody = moduleBuilder.ResolvePseudoToken (records [i].MethodBody);
        }
        if (moduleBuilder.IsPseudoToken (records [i].MethodDeclaration)) {
            records [i].MethodDeclaration = moduleBuilder.ResolvePseudoToken (records [i].MethodDeclaration);
        }
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1742" endline="1745">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.Class == y.Class ? 0 : (x.Class > y.Class ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1752" endline="1758">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i] = mr.ReadStringIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1760" endline="1766">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteStringIndex (records [i]);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1768" endline="1773">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteStringIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1775" endline="1785">
internal int FindOrAddRecord (int str) {
    for (int i = 0; i < rowCount; i ++) {
        if (records [i] == str) {
            return i + 1;
        }
    }
    return AddRecord (str);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1792" endline="1798">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i] = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1800" endline="1806">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteBlobIndex (records [i]);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1808" endline="1811">
protected override int GetRowSize (Table.RowSizeCalc rsc) {
    return rsc.WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1826" endline="1835">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].MappingFlags = mr.ReadInt16 ();
        records [i].MemberForwarded = mr.ReadMemberForwarded ();
        records [i].ImportName = mr.ReadStringIndex ();
        records [i].ImportScope = mr.ReadModuleRef ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1837" endline="1846">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].MappingFlags);
        mw.WriteMemberForwarded (records [i].MemberForwarded);
        mw.WriteStringIndex (records [i].ImportName);
        mw.WriteModuleRef (records [i].ImportScope);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1848" endline="1856">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (2).WriteMemberForwarded ().WriteStringIndex ().WriteModuleRef ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1858" endline="1868">
internal void Fixup (ModuleBuilder moduleBuilder) {
    for (int i = 0; i < rowCount; i ++) {
        if (moduleBuilder.IsPseudoToken (records [i].MemberForwarded)) {
            records [i].MemberForwarded = moduleBuilder.ResolvePseudoToken (records [i].MemberForwarded);
        }
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1870" endline="1873">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.MemberForwarded == y.MemberForwarded ? 0 : (x.MemberForwarded > y.MemberForwarded ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1886" endline="1893">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].RVA = mr.ReadInt32 ();
        records [i].Field = mr.ReadField ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1895" endline="1902">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].RVA);
        mw.WriteField (records [i].Field);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1904" endline="1910">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (4).WriteField ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1912" endline="1923">
internal void Fixup (ModuleBuilder moduleBuilder, int sdataRVA) {
    for (int i = 0; i < rowCount; i ++) {
        records [i].RVA += sdataRVA;
        if (moduleBuilder.IsPseudoToken (records [i].Field)) {
            records [i].Field = moduleBuilder.ResolvePseudoToken (records [i].Field);
        }
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1925" endline="1928">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.Field == y.Field ? 0 : (x.Field > y.Field ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1948" endline="1962">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].HashAlgId = mr.ReadInt32 ();
        records [i].MajorVersion = mr.ReadUInt16 ();
        records [i].MinorVersion = mr.ReadUInt16 ();
        records [i].BuildNumber = mr.ReadUInt16 ();
        records [i].RevisionNumber = mr.ReadUInt16 ();
        records [i].Flags = mr.ReadInt32 ();
        records [i].PublicKey = mr.ReadBlobIndex ();
        records [i].Name = mr.ReadStringIndex ();
        records [i].Culture = mr.ReadStringIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1964" endline="1978">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].HashAlgId);
        mw.Write (records [i].MajorVersion);
        mw.Write (records [i].MinorVersion);
        mw.Write (records [i].BuildNumber);
        mw.Write (records [i].RevisionNumber);
        mw.Write (records [i].Flags);
        mw.WriteBlobIndex (records [i].PublicKey);
        mw.WriteStringIndex (records [i].Name);
        mw.WriteStringIndex (records [i].Culture);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="1980" endline="1988">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (16).WriteBlobIndex ().WriteStringIndex ().WriteStringIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2008" endline="2027">
internal int FindOrAddRecord (Record rec) {
    for (int i = 0; i < rowCount; i ++) {
        if (records [i].Name == rec.Name && records [i].MajorVersion == rec.MajorVersion && records [i].MinorVersion == rec.MinorVersion && records [i].BuildNumber == rec.BuildNumber && records [i].RevisionNumber == rec.RevisionNumber && records [i].Flags == rec.Flags && records [i].PublicKeyOrToken == rec.PublicKeyOrToken && records [i].Culture == rec.Culture && records [i].HashValue == rec.HashValue) {
            return i + 1;
        }
    }
    return AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2029" endline="2043">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].MajorVersion = mr.ReadUInt16 ();
        records [i].MinorVersion = mr.ReadUInt16 ();
        records [i].BuildNumber = mr.ReadUInt16 ();
        records [i].RevisionNumber = mr.ReadUInt16 ();
        records [i].Flags = mr.ReadInt32 ();
        records [i].PublicKeyOrToken = mr.ReadBlobIndex ();
        records [i].Name = mr.ReadStringIndex ();
        records [i].Culture = mr.ReadStringIndex ();
        records [i].HashValue = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2045" endline="2059">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].MajorVersion);
        mw.Write (records [i].MinorVersion);
        mw.Write (records [i].BuildNumber);
        mw.Write (records [i].RevisionNumber);
        mw.Write (records [i].Flags);
        mw.WriteBlobIndex (records [i].PublicKeyOrToken);
        mw.WriteStringIndex (records [i].Name);
        mw.WriteStringIndex (records [i].Culture);
        mw.WriteBlobIndex (records [i].HashValue);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2061" endline="2070">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (12).WriteBlobIndex ().WriteStringIndex ().WriteStringIndex ().WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2084" endline="2092">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Flags = mr.ReadInt32 ();
        records [i].Name = mr.ReadStringIndex ();
        records [i].HashValue = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2094" endline="2102">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].Flags);
        mw.WriteStringIndex (records [i].Name);
        mw.WriteBlobIndex (records [i].HashValue);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2104" endline="2111">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (4).WriteStringIndex ().WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2127" endline="2137">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Flags = mr.ReadInt32 ();
        records [i].TypeDefId = mr.ReadInt32 ();
        records [i].TypeName = mr.ReadStringIndex ();
        records [i].TypeNamespace = mr.ReadStringIndex ();
        records [i].Implementation = mr.ReadImplementation ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2139" endline="2149">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].Flags);
        mw.Write (records [i].TypeDefId);
        mw.WriteStringIndex (records [i].TypeName);
        mw.WriteStringIndex (records [i].TypeNamespace);
        mw.WriteImplementation (records [i].Implementation);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2151" endline="2159">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (8).WriteStringIndex ().WriteStringIndex ().WriteImplementation ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2161" endline="2173">
internal int FindOrAddRecord (Record rec) {
    for (int i = 0; i < rowCount; i ++) {
        if (records [i].Implementation == rec.Implementation && records [i].TypeName == rec.TypeName && records [i].TypeNamespace == rec.TypeNamespace) {
            return i + 1;
        }
    }
    return AddRecord (rec);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2188" endline="2197">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Offset = mr.ReadInt32 ();
        records [i].Flags = mr.ReadInt32 ();
        records [i].Name = mr.ReadStringIndex ();
        records [i].Implementation = mr.ReadImplementation ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2199" endline="2208">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].Offset);
        mw.Write (records [i].Flags);
        mw.WriteStringIndex (records [i].Name);
        mw.WriteImplementation (records [i].Implementation);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2210" endline="2217">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (8).WriteStringIndex ().WriteImplementation ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2230" endline="2237">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].NestedClass = mr.ReadTypeDef ();
        records [i].EnclosingClass = mr.ReadTypeDef ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2239" endline="2246">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteTypeDef (records [i].NestedClass);
        mw.WriteTypeDef (records [i].EnclosingClass);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2248" endline="2254">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteTypeDef ().WriteTypeDef ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2256" endline="2267">
internal List < int > GetNestedClasses (int enclosingClass) {
    List < int > nestedClasses = new List < int > ();
    for (int i = 0; i < rowCount; i ++) {
        if (records [i].EnclosingClass == enclosingClass) {
            nestedClasses.Add (records [i].NestedClass);
        }
    }
    return nestedClasses;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2284" endline="2293">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Number = mr.ReadInt16 ();
        records [i].Flags = mr.ReadInt16 ();
        records [i].Owner = mr.ReadTypeOrMethodDef ();
        records [i].Name = mr.ReadStringIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2295" endline="2304">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.Write (records [i].Number);
        mw.Write (records [i].Flags);
        mw.WriteTypeOrMethodDef (records [i].Owner);
        mw.WriteStringIndex (records [i].Name);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2306" endline="2313">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.AddFixed (4).WriteTypeOrMethodDef ().WriteStringIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2315" endline="2339">
internal void Fixup (ModuleBuilder moduleBuilder) {
    for (int i = 0; i < rowCount; i ++) {
        int token = records [i].Owner;
        if (moduleBuilder.IsPseudoToken (token)) {
            token = moduleBuilder.ResolvePseudoToken (token);
        }
        switch (token > > 24) {
            case TypeDefTable.Index :
                records [i].Owner = (token & 0xFFFFFF) << 1 | 0;
                break;
            case MethodDefTable.Index :
                records [i].Owner = (token & 0xFFFFFF) << 1 | 1;
                break;
            default :
                throw new InvalidOperationException ();
        }
        records [i].unsortedIndex = i;
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2341" endline="2348">
int IComparer < Record >.Compare (Record x, Record y) {
    if (x.Owner == y.Owner) {
        return x.Number == y.Number ? 0 : (x.Number > y.Number ? 1 : - 1);
    }
    return x.Owner > y.Owner ? 1 : - 1;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2350" endline="2353">
internal GenericParameterAttributes GetAttributes (int token) {
    return (GenericParameterAttributes) records [(token & 0xFFFFFF) - 1].Flags;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2355" endline="2358">
internal void PatchAttribute (int token, GenericParameterAttributes genericParameterAttributes) {
    records [(token & 0xFFFFFF) - 1].Flags = (short) genericParameterAttributes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2360" endline="2368">
internal int [] GetIndexFixup () {
    int [] array = new int [rowCount];
    for (int i = 0; i < rowCount; i ++) {
        array [records [i].unsortedIndex] = i;
    }
    return array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2370" endline="2381">
internal int FindFirstByOwner (int token) {
    for (int i = 0; i < records.Length; i ++) {
        if (records [i].Owner == token) {
            return i;
        }
    }
    return - 1;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2394" endline="2401">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Method = mr.ReadMethodDefOrRef ();
        records [i].Instantiation = mr.ReadBlobIndex ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2403" endline="2410">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteMethodDefOrRef (records [i].Method);
        mw.WriteBlobIndex (records [i].Instantiation);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2412" endline="2418">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteMethodDefOrRef ().WriteBlobIndex ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2420" endline="2431">
internal int FindOrAddRecord (Record record) {
    for (int i = 0; i < rowCount; i ++) {
        if (records [i].Method == record.Method && records [i].Instantiation == record.Instantiation) {
            return i + 1;
        }
    }
    return AddRecord (record);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2433" endline="2442">
internal void Fixup (ModuleBuilder moduleBuilder) {
    for (int i = 0; i < rowCount; i ++) {
        if (moduleBuilder.IsPseudoToken (records [i].Method)) {
            records [i].Method = moduleBuilder.ResolvePseudoToken (records [i].Method);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2455" endline="2462">
internal override void Read (MetadataReader mr) {
    for (int i = 0; i < records.Length; i ++) {
        records [i].Owner = mr.ReadGenericParam ();
        records [i].Constraint = mr.ReadTypeDefOrRef ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2464" endline="2471">
internal override void Write (MetadataWriter mw) {
    for (int i = 0; i < rowCount; i ++) {
        mw.WriteGenericParam (records [i].Owner);
        mw.WriteTypeDefOrRef (records [i].Constraint);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2473" endline="2479">
protected override int GetRowSize (RowSizeCalc rsc) {
    return rsc.WriteGenericParam ().WriteTypeDefOrRef ().Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2481" endline="2489">
internal void Fixup (ModuleBuilder moduleBuilder) {
    int [] fixups = moduleBuilder.GenericParam.GetIndexFixup ();
    for (int i = 0; i < rowCount; i ++) {
        records [i].Owner = fixups [records [i].Owner - 1] + 1;
    }
    Array.Sort (records, 0, rowCount, this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Metadata/Tables.cs.ifdefed" startline="2491" endline="2494">
int IComparer < Record >.Compare (Record x, Record y) {
    return x.Owner == y.Owner ? 0 : (x.Owner > y.Owner ? 1 : - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodBase.cs.ifdefed" startline="111" endline="114">
public virtual Type [] GetGenericArguments () {
    return Type.EmptyTypes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodBody.cs.ifdefed" startline="123" endline="129">
private static int ComputeExceptionCount (int size, int itemLength) {
    return size / itemLength;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodBody.cs.ifdefed" startline="146" endline="149">
public byte [] GetILAsByteArray () {
    return body;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="39" endline="42">
public virtual MethodInfo MakeGenericMethod (params Type [] typeArguments) {
    throw new NotSupportedException (this.GetType ().FullName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="44" endline="47">
public virtual MethodInfo GetGenericMethodDefinition () {
    throw new NotSupportedException (this.GetType ().FullName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="49" endline="74">
public override string ToString () {
    StringBuilder sb = new StringBuilder ();
    sb.Append (this.ReturnType.Name).Append (' ').Append (this.Name);
    string sep;
    if (this.IsGenericMethod) {
        sb.Append ('[');
        sep = "";
        foreach (Type arg in GetGenericArguments ()) {
            sb.Append (sep).Append (arg);
            sep = ", ";
        }
        sb.Append (']');
    }
    sb.Append ('(');
    sep = "";
    foreach (ParameterInfo arg in GetParameters ()) {
        sb.Append (sep).Append (arg.ParameterType);
        sep = ", ";
    }
    sb.Append (')');
    return sb.ToString ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="81" endline="96">
public MethodInfo GetBaseDefinition () {
    MethodInfo match = this;
    if (match.IsVirtual) {
        for (Type type = this.DeclaringType.BaseType; type != null && ! match.IsNewSlot; type = type.BaseType) {
            MethodInfo method = type.FindMethod (this.Name, this.MethodSignature) as MethodInfo;
            if (method != null && method.IsVirtual) {
                match = method;
            }
        }
    }
    return match;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="98" endline="101">
Type IGenericContext.GetGenericTypeArgument (int index) {
    return this.DeclaringType.GetGenericTypeArgument (index);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="103" endline="106">
Type IGenericContext.GetGenericMethodArgument (int index) {
    return GetGenericMethodArgument (index);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="108" endline="111">
internal virtual Type GetGenericMethodArgument (int index) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="113" endline="116">
internal virtual int GetGenericMethodArgumentCount () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="118" endline="121">
internal override MethodInfo GetMethodOnTypeDefinition () {
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="123" endline="126">
Type IGenericBinder.BindTypeParameter (Type type) {
    return this.DeclaringType.GetGenericTypeArgument (type.GenericParameterPosition);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="128" endline="131">
Type IGenericBinder.BindMethodParameter (Type type) {
    return GetGenericMethodArgument (type.GenericParameterPosition);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodInfo.cs.ifdefed" startline="133" endline="136">
internal override MethodBase BindTypeParameters (Type type) {
    return new GenericMethodInstance (this.DeclaringType.BindTypeParameters (type), this, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="50" endline="59">
public override bool Equals (object obj) {
    MethodSignature other = obj as MethodSignature;
    return other != null && other.callingConvention == callingConvention && other.genericParamCount == genericParamCount && other.returnType.Equals (returnType) && Util.ArrayEquals (other.parameterTypes, parameterTypes) && Util.ArrayEquals (other.modifiers, modifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="61" endline="67">
public override int GetHashCode () {
    return genericParamCount ^ 77 * (int) callingConvention ^ 3 * returnType.GetHashCode () ^ Util.GetHashCode (parameterTypes) * 5 ^ Util.GetHashCode (modifiers) * 55;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="78" endline="81">
public Type GetGenericTypeArgument (int index) {
    return original.GetGenericTypeArgument (index);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="83" endline="86">
public Type GetGenericMethodArgument (int index) {
    return UnboundGenericMethodParameter.Make (index);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="89" endline="147">
internal static MethodSignature ReadSig (ModuleReader module, ByteReader br, IGenericContext context) {
    CallingConventions callingConvention;
    int genericParamCount;
    Type returnType;
    Type [] parameterTypes;
    byte flags = br.ReadByte ();
    switch (flags & 7) {
        case DEFAULT :
            callingConvention = CallingConventions.Standard;
            break;
        case VARARG :
            callingConvention = CallingConventions.VarArgs;
            break;
        default :
            throw new BadImageFormatException ();
    }
    if ((flags & HASTHIS) != 0) {
        callingConvention |= CallingConventions.HasThis;
    }
    if ((flags & EXPLICITTHIS) != 0) {
        callingConvention |= CallingConventions.ExplicitThis;
    }
    genericParamCount = 0;
    if ((flags & GENERIC) != 0) {
        genericParamCount = br.ReadCompressedInt ();
        context = new UnboundGenericMethodContext (context);
    }
    int paramCount = br.ReadCompressedInt ();
    Type [] [] [] modifiers = null;
    Type [] optionalCustomModifiers;
    Type [] requiredCustomModifiers;
    ReadCustomModifiers (module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
    returnType = ReadRetType (module, br, context);
    parameterTypes = new Type [paramCount];
    PackedCustomModifiers.SetModifiers (ref modifiers, 0, 0, optionalCustomModifiers, paramCount + 1);
    PackedCustomModifiers.SetModifiers (ref modifiers, 0, 1, requiredCustomModifiers, paramCount + 1);
    for (int i = 0; i < parameterTypes.Length; i ++) {
        if ((callingConvention & CallingConventions.VarArgs) != 0 && br.PeekByte () == SENTINEL) {
            Array.Resize (ref parameterTypes, i);
            if (modifiers != null) {
                Array.Resize (ref modifiers, i + 1);
            }
            break;
        }
        ReadCustomModifiers (module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
        PackedCustomModifiers.SetModifiers (ref modifiers, i + 1, 0, optionalCustomModifiers, paramCount + 1);
        PackedCustomModifiers.SetModifiers (ref modifiers, i + 1, 1, requiredCustomModifiers, paramCount + 1);
        parameterTypes [i] = ReadParam (module, br, context);
    }
    return new MethodSignature (returnType, parameterTypes, modifiers, callingConvention, genericParamCount);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="149" endline="213">
internal static __StandAloneMethodSig ReadStandAloneMethodSig (ModuleReader module, ByteReader br, IGenericContext context) {
    CallingConventions callingConvention = 0;
    System.Runtime.InteropServices.CallingConvention unmanagedCallingConvention = 0;
    bool unmanaged;
    byte flags = br.ReadByte ();
    switch (flags & 7) {
        case DEFAULT :
            callingConvention = CallingConventions.Standard;
            unmanaged = false;
            break;
        case 0x01 :
            unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
            unmanaged = true;
            break;
        case 0x02 :
            unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
            unmanaged = true;
            break;
        case 0x03 :
            unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
            unmanaged = true;
            break;
        case 0x04 :
            unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
            unmanaged = true;
            break;
        case VARARG :
            callingConvention = CallingConventions.VarArgs;
            unmanaged = false;
            break;
        default :
            throw new BadImageFormatException ();
    }
    if ((flags & HASTHIS) != 0) {
        callingConvention |= CallingConventions.HasThis;
    }
    if ((flags & EXPLICITTHIS) != 0) {
        callingConvention |= CallingConventions.ExplicitThis;
    }
    if ((flags & GENERIC) != 0) {
        throw new BadImageFormatException ();
    }
    int paramCount = br.ReadCompressedInt ();
    SkipCustomModifiers (br);
    Type returnType = ReadRetType (module, br, context);
    List < Type > parameterTypes = new List < Type > ();
    List < Type > optionalParameterTypes = new List < Type > ();
    List < Type > curr = parameterTypes;
    for (int i = 0; i < paramCount; i ++) {
        if (br.PeekByte () == SENTINEL) {
            br.ReadByte ();
            curr = optionalParameterTypes;
        }
        SkipCustomModifiers (br);
        curr.Add (ReadParam (module, br, context));
    }
    return new __StandAloneMethodSig (unmanaged, unmanagedCallingConvention, callingConvention, returnType, parameterTypes.ToArray (), optionalParameterTypes.ToArray ());
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="215" endline="218">
internal int GetParameterCount () {
    return parameterTypes.Length;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="220" endline="223">
internal Type GetParameterType (int index) {
    return parameterTypes [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="225" endline="228">
internal Type GetReturnType (IGenericBinder binder) {
    return returnType.BindTypeParameters (binder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="230" endline="233">
internal Type [] GetReturnTypeOptionalCustomModifiers (IGenericBinder binder) {
    return BindTypeParameters (binder, modifiers, 0, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="235" endline="238">
internal Type [] GetReturnTypeRequiredCustomModifiers (IGenericBinder binder) {
    return BindTypeParameters (binder, modifiers, 0, 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="240" endline="243">
internal Type GetParameterType (IGenericBinder binder, int index) {
    return parameterTypes [index].BindTypeParameters (binder);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="245" endline="248">
internal Type [] GetParameterOptionalCustomModifiers (IGenericBinder binder, int index) {
    return BindTypeParameters (binder, modifiers, index + 1, 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="250" endline="253">
internal Type [] GetParameterRequiredCustomModifiers (IGenericBinder binder, int index) {
    return BindTypeParameters (binder, modifiers, index + 1, 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="271" endline="274">
public Type BindTypeParameter (Type type) {
    return declaringType.GetGenericTypeArgument (type.GenericParameterPosition);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="276" endline="283">
public Type BindMethodParameter (Type type) {
    if (methodArgs == null) {
        return type;
    }
    return methodArgs [type.GenericParameterPosition];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="286" endline="293">
internal MethodSignature Bind (Type type, Type [] methodArgs) {
    Binder binder = new Binder (type, methodArgs);
    return new MethodSignature (returnType.BindTypeParameters (binder), BindTypeParameters (binder, parameterTypes), BindTypeParameters (binder, modifiers), callingConvention, genericParamCount);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="303" endline="306">
public Type BindTypeParameter (Type type) {
    return type;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="308" endline="311">
public Type BindMethodParameter (Type type) {
    return UnboundGenericMethodParameter.Make (type.GenericParameterPosition);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="314" endline="323">
internal static MethodSignature MakeFromBuilder (Type returnType, Type [] parameterTypes, Type [] [] [] modifiers, CallingConventions callingConvention, int genericParamCount) {
    if (genericParamCount > 0) {
        returnType = returnType.BindTypeParameters (Unbinder.Instance);
        parameterTypes = BindTypeParameters (Unbinder.Instance, parameterTypes);
        modifiers = BindTypeParameters (Unbinder.Instance, modifiers);
    }
    return new MethodSignature (returnType, parameterTypes, modifiers, callingConvention, genericParamCount);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="325" endline="351">
internal bool MatchParameterTypes (Type [] types) {
    if (types == parameterTypes) {
        return true;
    }
    if (types == null) {
        return parameterTypes.Length == 0;
    }
    if (parameterTypes == null) {
        return types.Length == 0;
    }
    if (types.Length == parameterTypes.Length) {
        for (int i = 0; i < types.Length; i ++) {
            if (! Util.TypeEquals (types [i], parameterTypes [i])) {
                return false;
            }
        }
        return true;
    }
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="353" endline="356">
internal override void WriteSig (ModuleBuilder module, ByteBuffer bb) {
    WriteSigImpl (module, bb, parameterTypes.Length);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="358" endline="369">
internal void WriteMethodRefSig (ModuleBuilder module, ByteBuffer bb, Type [] optionalParameterTypes) {
    WriteSigImpl (module, bb, parameterTypes.Length + optionalParameterTypes.Length);
    if (optionalParameterTypes.Length > 0) {
        bb.Write (SENTINEL);
        foreach (Type type in optionalParameterTypes) {
            WriteType (module, bb, type);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="371" endline="418">
private void WriteSigImpl (ModuleBuilder module, ByteBuffer bb, int parameterCount) {
    byte first;
    if ((callingConvention & CallingConventions.Any) == CallingConventions.VarArgs) {
        Debug.Assert (genericParamCount == 0);
        first = VARARG;
    } else if (genericParamCount > 0) {
        first = GENERIC;
    } else {
        first = DEFAULT;
    }
    if ((callingConvention & CallingConventions.HasThis) != 0) {
        first |= HASTHIS;
    }
    if ((callingConvention & CallingConventions.ExplicitThis) != 0) {
        first |= EXPLICITTHIS;
    }
    bb.Write (first);
    if (genericParamCount > 0) {
        bb.WriteCompressedInt (genericParamCount);
    }
    bb.WriteCompressedInt (parameterCount);
    if (modifiers != null && modifiers [0] != null) {
        WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers [0] [0]);
        WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers [0] [1]);
    }
    WriteType (module, bb, returnType);
    for (int i = 0; i < parameterTypes.Length; i ++) {
        if (modifiers != null && modifiers [i + 1] != null) {
            WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers [i + 1] [0]);
            WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers [i + 1] [1]);
        }
        WriteType (module, bb, parameterTypes [i]);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="432" endline="446">
internal static void SetModifiers (ref Type [] [] [] modifiers, int index, int optOrReq, Type [] add, int count) {
    if (add != null) {
        if (modifiers == null) {
            modifiers = new Type [count] [] [];
        }
        if (modifiers [index] == null) {
            modifiers [index] = new Type [2] [];
        }
        modifiers [index] [optOrReq] = add;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="449" endline="460">
internal static Type [] [] [] CreateFromExternal (Type [] returnOptional, Type [] returnRequired, Type [] [] parameterOptional, Type [] [] parameterRequired, int parameterCount) {
    Type [] [] [] modifiers = null;
    SetModifiers (ref modifiers, 0, 0, NormalizeAndCopy (returnOptional), parameterCount + 1);
    SetModifiers (ref modifiers, 0, 1, NormalizeAndCopy (returnRequired), parameterCount + 1);
    for (int i = 0; i < parameterCount; i ++) {
        SetModifiers (ref modifiers, i + 1, 0, NormalizeAndCopy (parameterOptional, i), parameterCount + 1);
        SetModifiers (ref modifiers, i + 1, 1, NormalizeAndCopy (parameterRequired, i), parameterCount + 1);
    }
    return modifiers;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="462" endline="481">
private static Type [] NormalizeAndCopy (Type [] array) {
    if (array == null || array.Length == 0) {
        return null;
    }
    Type [] copy = null;
    for (int i = 0; i < array.Length; i ++) {
        if (array [i] != null) {
            if (copy == null) {
                copy = new Type [array.Length];
            }
            copy [i] = array [i];
        }
    }
    return copy;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/MethodSignature.cs.ifdefed" startline="483" endline="490">
private static Type [] NormalizeAndCopy (Type [] [] array, int index) {
    if (array == null || array.Length == 0) {
        return null;
    }
    return NormalizeAndCopy (array [index]);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="53" endline="59">
private void CheckManifestModule () {
    if (! IsManifestModule) {
        throw new BadImageFormatException ("Module does not contain a manifest");
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="61" endline="65">
public AssemblyName GetAssemblyName () {
    CheckManifestModule ();
    return module.Assembly.GetName ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="67" endline="70">
public AssemblyName [] GetReferencedAssemblies () {
    return module.__GetReferencedAssemblies ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="72" endline="78">
public void Dispose () {
    if (! imported) {
        module.stream.Dispose ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="80" endline="88">
internal Assembly ToAssembly () {
    if (imported) {
        throw new InvalidOperationException ();
    }
    imported = true;
    return module.Assembly;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="90" endline="99">
internal Module ToModule (Assembly assembly) {
    if (module.Assembly != null) {
        throw new InvalidOperationException ();
    }
    imported = true;
    module.SetAssembly (assembly);
    return module;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="145" endline="183">
internal Table [] GetTables () {
    Table [] tables = new Table [64];
    tables [ModuleTable.Index] = ModuleTable;
    tables [TypeRefTable.Index] = TypeRef;
    tables [TypeDefTable.Index] = TypeDef;
    tables [FieldTable.Index] = Field;
    tables [MemberRefTable.Index] = MemberRef;
    tables [ConstantTable.Index] = Constant;
    tables [CustomAttributeTable.Index] = CustomAttribute;
    tables [FieldMarshalTable.Index] = FieldMarshal;
    tables [DeclSecurityTable.Index] = DeclSecurity;
    tables [ClassLayoutTable.Index] = ClassLayout;
    tables [FieldLayoutTable.Index] = FieldLayout;
    tables [ParamTable.Index] = Param;
    tables [InterfaceImplTable.Index] = InterfaceImpl;
    tables [StandAloneSigTable.Index] = StandAloneSig;
    tables [EventMapTable.Index] = EventMap;
    tables [EventTable.Index] = Event;
    tables [PropertyMapTable.Index] = PropertyMap;
    tables [PropertyTable.Index] = Property;
    tables [MethodSemanticsTable.Index] = MethodSemantics;
    tables [MethodImplTable.Index] = MethodImpl;
    tables [ModuleRefTable.Index] = ModuleRef;
    tables [TypeSpecTable.Index] = TypeSpec;
    tables [ImplMapTable.Index] = ImplMap;
    tables [FieldRVATable.Index] = FieldRVA;
    tables [AssemblyTable.Index] = AssemblyTable;
    tables [AssemblyRefTable.Index] = AssemblyRef;
    tables [MethodDefTable.Index] = MethodDef;
    tables [NestedClassTable.Index] = NestedClass;
    tables [FileTable.Index] = File;
    tables [ExportedTypeTable.Index] = ExportedType;
    tables [ManifestResourceTable.Index] = ManifestResource;
    tables [GenericParamTable.Index] = GenericParam;
    tables [MethodSpecTable.Index] = MethodSpec;
    tables [GenericParamConstraintTable.Index] = GenericParamConstraint;
    return tables;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="185" endline="188">
public virtual void __GetDataDirectoryEntry (int index, out int rva, out int length) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="190" endline="193">
public virtual long __RelativeVirtualAddressToFileOffset (int rva) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="195" endline="198">
public virtual void GetPEKind (out PortableExecutableKinds peKind, out ImageFileMachine machine) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="205" endline="208">
public FieldInfo GetField (string name) {
    return IsResource () ? null : GetModuleType ().GetField (name);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="210" endline="213">
public FieldInfo GetField (string name, BindingFlags bindingFlags) {
    return IsResource () ? null : GetModuleType ().GetField (name, bindingFlags);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="215" endline="218">
public FieldInfo [] GetFields () {
    return IsResource () ? Empty < FieldInfo >.Array : GetModuleType ().GetFields ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="220" endline="223">
public FieldInfo [] GetFields (BindingFlags bindingFlags) {
    return IsResource () ? Empty < FieldInfo >.Array : GetModuleType ().GetFields (bindingFlags);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="225" endline="228">
public MethodInfo GetMethod (string name) {
    return IsResource () ? null : GetModuleType ().GetMethod (name);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="230" endline="233">
public MethodInfo GetMethod (string name, Type [] types) {
    return IsResource () ? null : GetModuleType ().GetMethod (name, types);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="235" endline="238">
public MethodInfo GetMethod (string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type [] types, ParameterModifier [] modifiers) {
    return IsResource () ? null : GetModuleType ().GetMethod (name, bindingAttr, binder, callConv, types, modifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="240" endline="243">
public MethodInfo [] GetMethods () {
    return IsResource () ? Empty < MethodInfo >.Array : GetModuleType ().GetMethods ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="245" endline="248">
public MethodInfo [] GetMethods (BindingFlags bindingFlags) {
    return IsResource () ? Empty < MethodInfo >.Array : GetModuleType ().GetMethods (bindingFlags);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="255" endline="264">
public byte [] ResolveSignature (int metadataToken) {
    ModuleReader rdr = this as ModuleReader;
    if (rdr != null) {
        ByteReader br = rdr.ResolveSignature (metadataToken);
        return br.ReadBytes (br.Length);
    }
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="266" endline="269">
public virtual __StandAloneMethodSig __ResolveStandAloneMethodSig (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="293" endline="296">
public Type GetType (string className) {
    return GetType (className, false, false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="298" endline="301">
public Type GetType (string className, bool ignoreCase) {
    return GetType (className, false, ignoreCase);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="303" endline="326">
public Type GetType (string className, bool throwOnError, bool ignoreCase) {
    if (ignoreCase) {
        throw new NotImplementedException ();
    }
    TypeNameParser parser = TypeNameParser.Parse (className, throwOnError);
    if (parser.Error) {
        return null;
    }
    if (parser.AssemblyName != null) {
        if (throwOnError) {
            throw new ArgumentException ("Type names passed to Module.GetType() must not specify an assembly.");
        } else {
            return null;
        }
    }
    return parser.Expand (GetTypeImpl (parser.FirstNamePart), this.Assembly, throwOnError, className);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="328" endline="333">
public Type [] GetTypes () {
    List < Type > list = new List < Type > ();
    GetTypesImpl (list);
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="335" endline="346">
public Type [] FindTypes (TypeFilter filter, object filterCriteria) {
    List < Type > list = new List < Type > ();
    foreach (Type type in GetTypes ()) {
        if (filter (type, filterCriteria)) {
            list.Add (type);
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="348" endline="351">
public virtual bool IsResource () {
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="353" endline="356">
public Type ResolveType (int metadataToken) {
    return ResolveType (metadataToken, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="358" endline="361">
public MethodBase ResolveMethod (int metadataToken) {
    return ResolveMethod (metadataToken, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="363" endline="366">
public FieldInfo ResolveField (int metadataToken) {
    return ResolveField (metadataToken, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="368" endline="371">
public MemberInfo ResolveMember (int metadataToken) {
    return ResolveMember (metadataToken, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="373" endline="376">
public bool IsDefined (Type attributeType, bool inherit) {
    return CustomAttributeData.__GetCustomAttributes (this, attributeType, inherit).Count != 0;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="378" endline="381">
public IList < CustomAttributeData > __GetCustomAttributes (Type attributeType, bool inherit) {
    return CustomAttributeData.__GetCustomAttributes (this, attributeType, inherit);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="383" endline="386">
public virtual IList < CustomAttributeData > __GetPlaceholderAssemblyCustomAttributes (bool multiple, bool security) {
    return Empty < CustomAttributeData >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="390" endline="399">
internal Type CanonicalizeType (Type type) {
    Type canon;
    if (! universe.canonicalizedTypes.TryGetValue (type, out canon)) {
        canon = type;
        universe.canonicalizedTypes.Add (canon, canon);
    }
    return canon;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="405" endline="408">
internal IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    return GetCustomAttributes (0x00000001, attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="410" endline="433">
internal List < CustomAttributeData > GetCustomAttributes (int metadataToken, Type attributeType) {
    List < CustomAttributeData > list = new List < CustomAttributeData > ();
    for (int i = 0; i < CustomAttribute.records.Length; i ++) {
        if (CustomAttribute.records [i].Parent == metadataToken) {
            if (attributeType == null) {
                list.Add (new CustomAttributeData (this, i));
            } else {
                ConstructorInfo constructor = (ConstructorInfo) ResolveMethod (CustomAttribute.records [i].Type);
                if (attributeType.IsAssignableFrom (constructor.DeclaringType)) {
                    list.Add (new CustomAttributeData (this.Assembly, constructor, GetBlob (CustomAttribute.records [i].Value)));
                }
            }
        }
    }
    return list;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="435" endline="449">
internal IList < CustomAttributeData > GetDeclarativeSecurity (int metadataToken) {
    List < CustomAttributeData > list = new List < CustomAttributeData > ();
    for (int i = 0; i < DeclSecurity.records.Length; i ++) {
        if (DeclSecurity.records [i].Parent == metadataToken) {
            int action = DeclSecurity.records [i].Action;
            int permissionSet = DeclSecurity.records [i].PermissionSet;
            CustomAttributeData.ReadDeclarativeSecurity (this.Assembly, list, action, GetBlob (permissionSet));
        }
    }
    return list;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="451" endline="453">
internal virtual void Dispose () {
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Module.cs.ifdefed" startline="455" endline="457">
internal virtual void ExportTypes (int fileToken, IKVM.Reflection.Emit.ModuleBuilder manifestModule) {
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertyInfo.cs.ifdefed" startline="82" endline="85">
public override Type [] GetOptionalCustomModifiers () {
    return property.PropertySignature.GetOptionalCustomModifiers (parameter);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertyInfo.cs.ifdefed" startline="87" endline="90">
public override Type [] GetRequiredCustomModifiers () {
    return property.PropertySignature.GetRequiredCustomModifiers (parameter);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertyInfo.cs.ifdefed" startline="108" endline="116">
public ParameterInfo [] GetIndexParameters () {
    ParameterInfo [] parameters = new ParameterInfo [this.PropertySignature.ParameterCount];
    for (int i = 0; i < parameters.Length; i ++) {
        parameters [i] = new ParameterInfoImpl (this, i);
    }
    return parameters;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertyInfo.cs.ifdefed" startline="123" endline="126">
public Type [] GetRequiredCustomModifiers () {
    return this.PropertySignature.GetRequiredCustomModifiers ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertyInfo.cs.ifdefed" startline="128" endline="131">
public Type [] GetOptionalCustomModifiers () {
    return this.PropertySignature.GetOptionalCustomModifiers ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertyInfo.cs.ifdefed" startline="138" endline="141">
public MethodInfo GetGetMethod () {
    return GetGetMethod (false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertyInfo.cs.ifdefed" startline="143" endline="146">
public MethodInfo GetSetMethod () {
    return GetSetMethod (false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertyInfo.cs.ifdefed" startline="148" endline="151">
public MethodInfo [] GetAccessors () {
    return GetAccessors (false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertyInfo.cs.ifdefed" startline="153" endline="156">
internal virtual PropertyInfo BindTypeParameters (Type type) {
    return new GenericPropertyInfo (this.DeclaringType.BindTypeParameters (type), this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="44" endline="47">
internal static PropertySignature Create (CallingConventions callingConvention, Type propertyType, Type [] optionalCustomModifiers, Type [] requiredCustomModifiers, Type [] parameterTypes, Type [] [] parameterTypeOptionalCustomModifiers, Type [] [] parameterTypeRequiredCustomModifiers) {
    return new PropertySignature (callingConvention, propertyType, Util.Copy (optionalCustomModifiers), Util.Copy (requiredCustomModifiers), Util.Copy (parameterTypes), Util.Copy (parameterTypeOptionalCustomModifiers), Util.Copy (parameterTypeRequiredCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="60" endline="67">
public override bool Equals (object obj) {
    PropertySignature other = obj as PropertySignature;
    return other != null && other.propertyType.Equals (propertyType) && Util.ArrayEquals (other.optionalCustomModifiers, optionalCustomModifiers) && Util.ArrayEquals (other.requiredCustomModifiers, requiredCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="69" endline="72">
public override int GetHashCode () {
    return propertyType.GetHashCode () ^ Util.GetHashCode (optionalCustomModifiers) ^ Util.GetHashCode (requiredCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="99" endline="102">
internal Type [] GetOptionalCustomModifiers () {
    return Util.Copy (optionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="104" endline="107">
internal Type [] GetRequiredCustomModifiers () {
    return Util.Copy (requiredCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="109" endline="119">
internal PropertySignature ExpandTypeParameters (Type declaringType) {
    return new PropertySignature (callingConvention, propertyType.BindTypeParameters (declaringType), BindTypeParameters (declaringType, optionalCustomModifiers), BindTypeParameters (declaringType, requiredCustomModifiers), BindTypeParameters (declaringType, parameterTypes), BindTypeParameters (declaringType, parameterOptionalCustomModifiers), BindTypeParameters (declaringType, parameterRequiredCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="121" endline="156">
internal override void WriteSig (ModuleBuilder module, ByteBuffer bb) {
    byte flags = PROPERTY;
    if ((callingConvention & CallingConventions.HasThis) != 0) {
        flags |= HASTHIS;
    }
    if ((callingConvention & CallingConventions.ExplicitThis) != 0) {
        flags |= EXPLICITTHIS;
    }
    if ((callingConvention & CallingConventions.VarArgs) != 0) {
        flags |= VARARG;
    }
    bb.Write (flags);
    bb.WriteCompressedInt (parameterTypes == null ? 0 : parameterTypes.Length);
    WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers);
    WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers);
    WriteType (module, bb, propertyType);
    if (parameterTypes != null) {
        for (int i = 0; i < parameterTypes.Length; i ++) {
            if (parameterRequiredCustomModifiers != null) {
                WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers [i]);
            }
            if (parameterOptionalCustomModifiers != null) {
                WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers [i]);
            }
            WriteType (module, bb, parameterTypes [i]);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="158" endline="161">
internal Type GetParameter (int parameter) {
    return parameterTypes [parameter];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="163" endline="166">
internal Type [] GetOptionalCustomModifiers (int parameter) {
    return parameterOptionalCustomModifiers == null ? Type.EmptyTypes : parameterOptionalCustomModifiers [parameter];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="168" endline="171">
internal Type [] GetRequiredCustomModifiers (int parameter) {
    return parameterRequiredCustomModifiers == null ? Type.EmptyTypes : parameterRequiredCustomModifiers [parameter];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/PropertySignature.cs.ifdefed" startline="173" endline="216">
internal static PropertySignature ReadSig (ModuleReader module, ByteReader br, IGenericContext context) {
    byte flags = br.ReadByte ();
    if ((flags & PROPERTY) == 0) {
        throw new BadImageFormatException ();
    }
    CallingConventions callingConvention = CallingConventions.Standard;
    if ((flags & HASTHIS) != 0) {
        callingConvention |= CallingConventions.HasThis;
    }
    if ((flags & EXPLICITTHIS) != 0) {
        callingConvention |= CallingConventions.ExplicitThis;
    }
    Type returnType;
    Type [] returnTypeRequiredCustomModifiers;
    Type [] returnTypeOptionalCustomModifiers;
    Type [] parameterTypes;
    Type [] [] parameterRequiredCustomModifiers;
    Type [] [] parameterOptionalCustomModifiers;
    int paramCount = br.ReadCompressedInt ();
    ReadCustomModifiers (module, br, context, out returnTypeRequiredCustomModifiers, out returnTypeOptionalCustomModifiers);
    returnType = ReadRetType (module, br, context);
    parameterTypes = new Type [paramCount];
    parameterRequiredCustomModifiers = null;
    parameterOptionalCustomModifiers = null;
    for (int i = 0; i < parameterTypes.Length; i ++) {
        if (IsCustomModifier (br.PeekByte ())) {
            if (parameterOptionalCustomModifiers == null) {
                parameterOptionalCustomModifiers = new Type [parameterTypes.Length] [];
                parameterRequiredCustomModifiers = new Type [parameterTypes.Length] [];
            }
            ReadCustomModifiers (module, br, context, out parameterRequiredCustomModifiers [i], out parameterOptionalCustomModifiers [i]);
        }
        parameterTypes [i] = ReadParam (module, br, context);
    }
    return new PropertySignature (callingConvention, returnType, returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers, parameterTypes, parameterOptionalCustomModifiers, parameterRequiredCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="57" endline="60">
public override AssemblyName GetName () {
    return GetNameImpl (ref manifestModule.AssemblyTable.records [0]);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="62" endline="87">
private AssemblyName GetNameImpl (ref AssemblyTable.Record rec) {
    AssemblyName name = new AssemblyName ();
    name.Name = manifestModule.GetString (rec.Name);
    name.Version = new Version (rec.MajorVersion, rec.MinorVersion, rec.BuildNumber, rec.RevisionNumber);
    if (rec.PublicKey != 0) {
        name.SetPublicKey (manifestModule.GetBlobCopy (rec.PublicKey));
    } else {
        name.SetPublicKey (Empty < byte >.Array);
    }
    if (rec.Culture != 0) {
        name.CultureInfo = new System.Globalization.CultureInfo (manifestModule.GetString (rec.Culture));
    } else {
        name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
    }
    name.HashAlgorithm = (AssemblyHashAlgorithm) rec.HashAlgId;
    name.CodeBase = this.CodeBase;
    name.Flags = (AssemblyNameFlags) rec.Flags;
    return name;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="89" endline="102">
public override Type [] GetTypes () {
    if (externalModules.Length == 0) {
        return manifestModule.GetTypes ();
    }
    List < Type > list = new List < Type > ();
    foreach (Module module in GetModules (false)) {
        list.AddRange (module.GetTypes ());
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="104" endline="115">
internal override Type GetTypeImpl (string typeName) {
    Type type = manifestModule.GetType (typeName);
    for (int i = 0; type == null && i < externalModules.Length; i ++) {
        if ((manifestModule.File.records [i].Flags & ContainsNoMetaData) == 0) {
            type = GetModule (i).GetType (typeName);
        }
    }
    return type;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="127" endline="139">
public override Module [] GetLoadedModules (bool getResourceModules) {
    List < Module > list = new List < Module > ();
    list.Add (manifestModule);
    foreach (Module m in externalModules) {
        if (m != null) {
            list.Add (m);
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="141" endline="160">
public override Module [] GetModules (bool getResourceModules) {
    if (externalModules.Length == 0) {
        return new Module [] {manifestModule};
    } else {
        List < Module > list = new List < Module > ();
        list.Add (manifestModule);
        for (int i = 0; i < manifestModule.File.records.Length; i ++) {
            if (getResourceModules || (manifestModule.File.records [i].Flags & ContainsNoMetaData) == 0) {
                list.Add (GetModule (i));
            }
        }
        return list.ToArray ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="162" endline="174">
public override Module GetModule (string name) {
    if (name.Equals (manifestModule.ScopeName, StringComparison.InvariantCultureIgnoreCase)) {
        return manifestModule;
    }
    int index = GetModuleIndex (name);
    if (index != - 1) {
        return GetModule (index);
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="176" endline="186">
private int GetModuleIndex (string name) {
    for (int i = 0; i < manifestModule.File.records.Length; i ++) {
        if (name.Equals (manifestModule.GetString (manifestModule.File.records [i].Name), StringComparison.InvariantCultureIgnoreCase)) {
            return i;
        }
    }
    return - 1;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="188" endline="197">
private Module GetModule (int index) {
    if (externalModules [index] != null) {
        return externalModules [index];
    }
    string location = Path.Combine (Path.GetDirectoryName (this.location), manifestModule.GetString (manifestModule.File.records [index].Name));
    return LoadModule (index, File.ReadAllBytes (location), location);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="199" endline="209">
private Module LoadModule (int index, byte [] rawModule, string location) {
    if ((manifestModule.File.records [index].Flags & ContainsNoMetaData) != 0) {
        return externalModules [index] = new ResourceModule (this, manifestModule.GetString (manifestModule.File.records [index].Name), location);
    } else {
        return externalModules [index] = new ModuleReader (this, manifestModule.universe, new MemoryStream (rawModule), location);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="211" endline="223">
public override Module LoadModule (string moduleName, byte [] rawModule) {
    int index = GetModuleIndex (moduleName);
    if (index == - 1) {
        throw new ArgumentException ();
    }
    if (externalModules [index] != null) {
        return externalModules [index];
    }
    return LoadModule (index, rawModule, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="230" endline="233">
public override string [] GetManifestResourceNames () {
    return manifestModule.GetManifestResourceNames ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="235" endline="238">
public override ManifestResourceInfo GetManifestResourceInfo (string resourceName) {
    return manifestModule.GetManifestResourceInfo (resourceName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="240" endline="243">
public override Stream GetManifestResourceStream (string resourceName) {
    return manifestModule.GetManifestResourceStream (resourceName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="245" endline="248">
public override AssemblyName [] GetReferencedAssemblies () {
    return manifestModule.__GetReferencedAssemblies ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/AssemblyReader.cs.ifdefed" startline="250" endline="253">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    return manifestModule.GetCustomAttributes (0x20000001, attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="43" endline="49">
internal static ByteReader FromBlob (byte [] blobHeap, int blob) {
    ByteReader br = new ByteReader (blobHeap, blob, 4);
    int length = br.ReadCompressedInt ();
    br.end = br.pos + length;
    return br;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="56" endline="61">
internal byte PeekByte () {
    if (pos == end)
        throw new BadImageFormatException ();

    return buffer [pos];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="63" endline="68">
internal byte ReadByte () {
    if (pos == end)
        throw new BadImageFormatException ();

    return buffer [pos ++];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="70" endline="80">
internal byte [] ReadBytes (int count) {
    if (count < 0)
        throw new BadImageFormatException ();

    if (end - pos < count)
        throw new BadImageFormatException ();

    byte [] buf = new byte [count];
    Buffer.BlockCopy (buffer, pos, buf, 0, count);
    pos += count;
    return buf;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="82" endline="101">
internal int ReadCompressedInt () {
    byte b1 = ReadByte ();
    if (b1 <= 0x7F) {
        return b1;
    } else if ((b1 & 0xC0) == 0x80) {
        byte b2 = ReadByte ();
        return ((b1 & 0x3F) << 8) | b2;
    } else {
        byte b2 = ReadByte ();
        byte b3 = ReadByte ();
        byte b4 = ReadByte ();
        return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="103" endline="114">
internal string ReadString () {
    if (PeekByte () == 0xFF) {
        pos ++;
        return null;
    }
    int length = ReadCompressedInt ();
    string str = Encoding.UTF8.GetString (buffer, pos, length);
    pos += length;
    return str;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="116" endline="119">
internal char ReadChar () {
    return (char) ReadInt16 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="121" endline="124">
internal sbyte ReadSByte () {
    return (sbyte) ReadByte ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="126" endline="133">
internal short ReadInt16 () {
    if (end - pos < 2)
        throw new BadImageFormatException ();

    byte b1 = buffer [pos ++];
    byte b2 = buffer [pos ++];
    return (short) (b1 | (b2 << 8));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="135" endline="138">
internal ushort ReadUInt16 () {
    return (ushort) ReadInt16 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="140" endline="149">
internal int ReadInt32 () {
    if (end - pos < 4)
        throw new BadImageFormatException ();

    byte b1 = buffer [pos ++];
    byte b2 = buffer [pos ++];
    byte b3 = buffer [pos ++];
    byte b4 = buffer [pos ++];
    return (int) (b1 | (b2 << 8) | (b3 << 16) | (b4 << 24));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="151" endline="154">
internal uint ReadUInt32 () {
    return (uint) ReadInt32 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="156" endline="161">
internal long ReadInt64 () {
    ulong lo = ReadUInt32 ();
    ulong hi = ReadUInt32 ();
    return (long) (lo | (hi << 32));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="163" endline="166">
internal ulong ReadUInt64 () {
    return (ulong) ReadInt64 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="168" endline="171">
internal float ReadSingle () {
    return SingleConverter.Int32BitsToSingle (ReadInt32 ());
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="173" endline="176">
internal double ReadDouble () {
    return BitConverter.Int64BitsToDouble (ReadInt64 ());
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="178" endline="185">
internal ByteReader Slice (int length) {
    if (end - pos < length)
        throw new BadImageFormatException ();

    ByteReader br = new ByteReader (buffer, pos, length);
    pos += length;
    return br;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ByteReader.cs.ifdefed" startline="188" endline="192">
internal void Align (int alignment) {
    alignment --;
    pos = (pos + alignment) & ~ alignment;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/EventInfoImpl.cs.ifdefed" startline="47" endline="51">
public override bool Equals (object obj) {
    EventInfoImpl other = obj as EventInfoImpl;
    return other != null && other.declaringType == declaringType && other.index == index;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/EventInfoImpl.cs.ifdefed" startline="53" endline="56">
public override int GetHashCode () {
    return declaringType.GetHashCode () * 123 + index;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/EventInfoImpl.cs.ifdefed" startline="63" endline="66">
public override MethodInfo GetAddMethod (bool nonPublic) {
    return module.MethodSemantics.GetMethod (module, this.MetadataToken, nonPublic, MethodSemanticsTable.AddOn);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/EventInfoImpl.cs.ifdefed" startline="68" endline="71">
public override MethodInfo GetRaiseMethod (bool nonPublic) {
    return module.MethodSemantics.GetMethod (module, this.MetadataToken, nonPublic, MethodSemanticsTable.Fire);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/EventInfoImpl.cs.ifdefed" startline="73" endline="76">
public override MethodInfo GetRemoveMethod (bool nonPublic) {
    return module.MethodSemantics.GetMethod (module, this.MetadataToken, nonPublic, MethodSemanticsTable.RemoveOn);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/EventInfoImpl.cs.ifdefed" startline="78" endline="81">
public override MethodInfo [] GetOtherMethods (bool nonPublic) {
    return module.MethodSemantics.GetMethods (module, this.MetadataToken, nonPublic, MethodSemanticsTable.Other);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/EventInfoImpl.cs.ifdefed" startline="132" endline="136">
private void ComputeFlags () {
    module.MethodSemantics.ComputeFlags (module, this.MetadataToken, out isPublic, out isStatic);
    flagsCached = true;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Field.cs.ifdefed" startline="61" endline="64">
public override string ToString () {
    return this.FieldType.Name + " " + this.Name;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Field.cs.ifdefed" startline="76" endline="79">
public override object GetRawConstantValue () {
    return module.Constant.GetRawConstantValue (module, this.MetadataToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Field.cs.ifdefed" startline="81" endline="112">
public override void __GetDataFromRVA (byte [] data, int offset, int length) {
    int rid = index + 1;
    for (int i = 0; i < module.FieldRVA.records.Length; i ++) {
        if (module.FieldRVA.records [i].Field == rid) {
            int rva = module.FieldRVA.records [i].RVA;
            if (rva == 0) {
                Array.Clear (data, offset, length);
                return;
            }
            module.SeekRVA (rva);
            while (length > 0) {
                int read = module.stream.Read (data, offset, length);
                if (read == 0) {
                    break;
                }
                offset += read;
                length -= read;
            }
            return;
        }
    }
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Field.cs.ifdefed" startline="114" endline="140">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    List < CustomAttributeData > list = module.GetCustomAttributes (this.MetadataToken, attributeType);
    if ((this.Attributes & FieldAttributes.HasFieldMarshal) != 0 && (attributeType == null || attributeType.IsAssignableFrom (module.universe.System_Runtime_InteropServices_MarshalAsAttribute))) {
        list.Add (MarshalSpec.GetMarshalAsAttribute (module, this.MetadataToken));
    }
    if (declaringType.IsExplicitLayout && (attributeType == null || attributeType.IsAssignableFrom (module.universe.System_Runtime_InteropServices_FieldOffsetAttribute))) {
        int rid = index + 1;
        for (int i = 0; i < module.FieldLayout.records.Length; i ++) {
            if (module.FieldLayout.records [i].Field == rid) {
                ConstructorInfo constructor = module.universe.System_Runtime_InteropServices_FieldOffsetAttribute.GetConstructor (new Type [] {module.universe.System_Int32});
                list.Add (new CustomAttributeData (constructor, new object [] {module.FieldLayout.records [i].Offset}, null));
                break;
            }
        }
    }
    return list;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Field.cs.ifdefed" startline="147" endline="150">
internal override int ImportTo (Emit.ModuleBuilder module) {
    return module.ImportMethodOrField (declaringType, this.Name, this.FieldSignature);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="58" endline="69">
public override Type [] __GetDeclaredInterfaces () {
    List < Type > list = new List < Type > ();
    foreach (Type type in GetGenericParameterConstraints ()) {
        if (type.IsInterface) {
            list.Add (type);
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="86" endline="89">
public sealed override string ToString () {
    return this.Name;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="109" endline="112">
public override bool Equals (object obj) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="114" endline="117">
public override int GetHashCode () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="119" endline="122">
public override string ToString () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="134" endline="137">
internal override Type GetTypeImpl (string typeName) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="139" endline="142">
internal override void GetTypesImpl (List < Type > list) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="159" endline="162">
public override Type ResolveType (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="164" endline="167">
public override MethodBase ResolveMethod (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="169" endline="172">
public override FieldInfo ResolveField (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="174" endline="177">
public override MemberInfo ResolveMember (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="179" endline="182">
public override string ResolveString (int metadataToken) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="184" endline="187">
public override Type [] __ResolveOptionalParameterTypes (int metadataToken) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="194" endline="197">
public override AssemblyName [] __GetReferencedAssemblies () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="199" endline="202">
internal override Type GetModuleType () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="204" endline="207">
internal override ByteReader GetBlob (int blobIndex) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="210" endline="213">
internal static Type Make (int position) {
    return module.CanonicalizeType (new UnboundGenericMethodParameter (position));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="220" endline="224">
public override bool Equals (object obj) {
    UnboundGenericMethodParameter other = obj as UnboundGenericMethodParameter;
    return other != null && other.position == position;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="226" endline="229">
public override int GetHashCode () {
    return position;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="266" endline="269">
public override Type [] GetGenericParameterConstraints () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="276" endline="279">
internal override Type BindTypeParameters (IGenericBinder binder) {
    return binder.BindMethodParameter (this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="293" endline="296">
public override bool Equals (object obj) {
    return base.Equals (obj);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="298" endline="301">
public override int GetHashCode () {
    return base.GetHashCode ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="346" endline="360">
public override Type [] GetGenericParameterConstraints () {
    IGenericContext context = (this.DeclaringMethod as IGenericContext) ?? this.DeclaringType;
    List < Type > list = new List < Type > ();
    int token = this.MetadataToken;
    for (int i = 0; i < module.GenericParamConstraint.records.Length; i ++) {
        if (module.GenericParamConstraint.records [i].Owner == token) {
            list.Add (module.ResolveType (module.GenericParamConstraint.records [i].Constraint, context));
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/GenericTypeParameter.cs.ifdefed" startline="367" endline="378">
internal override Type BindTypeParameters (IGenericBinder binder) {
    int owner = module.GenericParam.records [index].Owner;
    if ((owner > > 24) == MethodDefTable.Index) {
        return binder.BindMethodParameter (this);
    } else {
        return binder.BindTypeParameter (this);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="42" endline="45">
internal short ReadInt16 () {
    return br.ReadInt16 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="47" endline="50">
internal ushort ReadUInt16 () {
    return br.ReadUInt16 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="52" endline="55">
internal int ReadInt32 () {
    return br.ReadInt32 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="57" endline="67">
internal int ReadStringIndex () {
    if (bigStrings) {
        return br.ReadInt32 ();
    } else {
        return br.ReadUInt16 ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="69" endline="79">
internal int ReadGuidIndex () {
    if (bigGuids) {
        return br.ReadInt32 ();
    } else {
        return br.ReadUInt16 ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="81" endline="91">
internal int ReadBlobIndex () {
    if (bigBlobs) {
        return br.ReadInt32 ();
    } else {
        return br.ReadUInt16 ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="93" endline="117">
internal int ReadResolutionScope () {
    int codedIndex;
    if (bigResolutionScope) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 3) {
        case 0 :
            return (ModuleTable.Index << 24) + (codedIndex > > 2);
        case 1 :
            return (ModuleRefTable.Index << 24) + (codedIndex > > 2);
        case 2 :
            return (AssemblyRefTable.Index << 24) + (codedIndex > > 2);
        case 3 :
            return (TypeRefTable.Index << 24) + (codedIndex > > 2);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="119" endline="141">
internal int ReadTypeDefOrRef () {
    int codedIndex;
    if (bigTypeDefOrRef) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 3) {
        case 0 :
            return (TypeDefTable.Index << 24) + (codedIndex > > 2);
        case 1 :
            return (TypeRefTable.Index << 24) + (codedIndex > > 2);
        case 2 :
            return (TypeSpecTable.Index << 24) + (codedIndex > > 2);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="143" endline="169">
internal int ReadMemberRefParent () {
    int codedIndex;
    if (bigMemberRefParent) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 7) {
        case 0 :
            return (TypeDefTable.Index << 24) + (codedIndex > > 3);
        case 1 :
            return (TypeRefTable.Index << 24) + (codedIndex > > 3);
        case 2 :
            return (ModuleRefTable.Index << 24) + (codedIndex > > 3);
        case 3 :
            return (MethodDefTable.Index << 24) + (codedIndex > > 3);
        case 4 :
            return (TypeSpecTable.Index << 24) + (codedIndex > > 3);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="171" endline="227">
internal int ReadHasCustomAttribute () {
    int codedIndex;
    if (bigHasCustomAttribute) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 31) {
        case 0 :
            return (MethodDefTable.Index << 24) + (codedIndex > > 5);
        case 1 :
            return (FieldTable.Index << 24) + (codedIndex > > 5);
        case 2 :
            return (TypeRefTable.Index << 24) + (codedIndex > > 5);
        case 3 :
            return (TypeDefTable.Index << 24) + (codedIndex > > 5);
        case 4 :
            return (ParamTable.Index << 24) + (codedIndex > > 5);
        case 5 :
            return (InterfaceImplTable.Index << 24) + (codedIndex > > 5);
        case 6 :
            return (MemberRefTable.Index << 24) + (codedIndex > > 5);
        case 7 :
            return (ModuleTable.Index << 24) + (codedIndex > > 5);
        case 8 :
            throw new BadImageFormatException ();
        case 9 :
            return (PropertyTable.Index << 24) + (codedIndex > > 5);
        case 10 :
            return (EventTable.Index << 24) + (codedIndex > > 5);
        case 11 :
            return (StandAloneSigTable.Index << 24) + (codedIndex > > 5);
        case 12 :
            return (ModuleRefTable.Index << 24) + (codedIndex > > 5);
        case 13 :
            return (TypeSpecTable.Index << 24) + (codedIndex > > 5);
        case 14 :
            return (AssemblyTable.Index << 24) + (codedIndex > > 5);
        case 15 :
            return (AssemblyRefTable.Index << 24) + (codedIndex > > 5);
        case 16 :
            return (FileTable.Index << 24) + (codedIndex > > 5);
        case 17 :
            return (ExportedTypeTable.Index << 24) + (codedIndex > > 5);
        case 18 :
            return (ManifestResourceTable.Index << 24) + (codedIndex > > 5);
        case 19 :
            return (GenericParamTable.Index << 24) + (codedIndex > > 5);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="229" endline="249">
internal int ReadCustomAttributeType () {
    int codedIndex;
    if (bigCustomAttributeType) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 7) {
        case 2 :
            return (MethodDefTable.Index << 24) + (codedIndex > > 3);
        case 3 :
            return (MemberRefTable.Index << 24) + (codedIndex > > 3);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="251" endline="271">
internal int ReadMethodDefOrRef () {
    int codedIndex;
    if (bigMethodDefOrRef) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 1) {
        case 0 :
            return (MethodDefTable.Index << 24) + (codedIndex > > 1);
        case 1 :
            return (MemberRefTable.Index << 24) + (codedIndex > > 1);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="273" endline="295">
internal int ReadHasConstant () {
    int codedIndex;
    if (bigHasConstant) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 3) {
        case 0 :
            return (FieldTable.Index << 24) + (codedIndex > > 2);
        case 1 :
            return (ParamTable.Index << 24) + (codedIndex > > 2);
        case 2 :
            return (PropertyTable.Index << 24) + (codedIndex > > 2);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="297" endline="317">
internal int ReadHasSemantics () {
    int codedIndex;
    if (bigHasSemantics) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 1) {
        case 0 :
            return (EventTable.Index << 24) + (codedIndex > > 1);
        case 1 :
            return (PropertyTable.Index << 24) + (codedIndex > > 1);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="319" endline="339">
internal int ReadHasFieldMarshal () {
    int codedIndex;
    if (bigHasFieldMarshal) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 1) {
        case 0 :
            return (FieldTable.Index << 24) + (codedIndex > > 1);
        case 1 :
            return (ParamTable.Index << 24) + (codedIndex > > 1);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="341" endline="363">
internal int ReadHasDeclSecurity () {
    int codedIndex;
    if (bigHasDeclSecurity) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 3) {
        case 0 :
            return (TypeDefTable.Index << 24) + (codedIndex > > 2);
        case 1 :
            return (MethodDefTable.Index << 24) + (codedIndex > > 2);
        case 2 :
            return (AssemblyTable.Index << 24) + (codedIndex > > 2);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="365" endline="385">
internal int ReadTypeOrMethodDef () {
    int codedIndex;
    if (bigTypeOrMethodDef) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 1) {
        case 0 :
            return (TypeDefTable.Index << 24) + (codedIndex > > 1);
        case 1 :
            return (MethodDefTable.Index << 24) + (codedIndex > > 1);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="387" endline="407">
internal int ReadMemberForwarded () {
    int codedIndex;
    if (bigMemberForwarded) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 1) {
        case 0 :
            return (FieldTable.Index << 24) + (codedIndex > > 1);
        case 1 :
            return (MethodDefTable.Index << 24) + (codedIndex > > 1);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="409" endline="431">
internal int ReadImplementation () {
    int codedIndex;
    if (bigImplementation) {
        codedIndex = br.ReadInt32 ();
    } else {
        codedIndex = br.ReadUInt16 ();
    }
    switch (codedIndex & 3) {
        case 0 :
            return (FileTable.Index << 24) + (codedIndex > > 2);
        case 1 :
            return (AssemblyRefTable.Index << 24) + (codedIndex > > 2);
        case 2 :
            return (ExportedTypeTable.Index << 24) + (codedIndex > > 2);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="433" endline="445">
private int ReadToken (int table, bool big) {
    int rid;
    if (big) {
        rid = br.ReadInt32 ();
    } else {
        rid = br.ReadUInt16 ();
    }
    return rid | (table << 24);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="447" endline="457">
internal int ReadField () {
    if (bigField) {
        return br.ReadInt32 ();
    } else {
        return br.ReadUInt16 ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="459" endline="469">
internal int ReadMethodDef () {
    if (bigMethodDef) {
        return br.ReadInt32 ();
    } else {
        return br.ReadUInt16 ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="471" endline="481">
internal int ReadParam () {
    if (bigParam) {
        return br.ReadInt32 ();
    } else {
        return br.ReadUInt16 ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="483" endline="493">
internal int ReadProperty () {
    if (bigProperty) {
        return br.ReadInt32 ();
    } else {
        return br.ReadUInt16 ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="495" endline="505">
internal int ReadEvent () {
    if (bigEvent) {
        return br.ReadInt32 ();
    } else {
        return br.ReadUInt16 ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="507" endline="510">
internal int ReadTypeDef () {
    return ReadToken (TypeDefTable.Index, bigTypeDef);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="512" endline="515">
internal int ReadGenericParam () {
    return ReadToken (GenericParamTable.Index, bigGenericParam);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/MetadataReader.cs.ifdefed" startline="517" endline="520">
internal int ReadModuleRef () {
    return ReadToken (ModuleRefTable.Index, bigModuleRef);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="48" endline="51">
public override MethodBody GetMethodBody () {
    return GetMethodBody (this);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="53" endline="62">
internal MethodBody GetMethodBody (IGenericContext context) {
    if ((GetMethodImplementationFlags () & MethodImplAttributes.CodeTypeMask) != MethodImplAttributes.IL) {
        return null;
    }
    int rva = module.MethodDef.records [index].RVA;
    return rva == 0 ? null : new MethodBody (module, rva, context);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="74" endline="77">
public override MethodImplAttributes GetMethodImplementationFlags () {
    return (MethodImplAttributes) module.MethodDef.records [index].ImplFlags;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="79" endline="83">
public override ParameterInfo [] GetParameters () {
    PopulateParameters ();
    return (ParameterInfo []) parameters.Clone ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="85" endline="117">
private void PopulateParameters () {
    if (parameters == null) {
        MethodSignature methodSignature = this.MethodSignature;
        parameters = new ParameterInfo [methodSignature.GetParameterCount ()];
        int parameter = module.MethodDef.records [index].ParamList - 1;
        int end = module.MethodDef.records.Length > index + 1 ? module.MethodDef.records [index + 1].ParamList - 1 : module.Param.records.Length;
        for (; parameter < end; parameter ++) {
            int seq = module.Param.records [parameter].Sequence - 1;
            if (seq == - 1) {
                returnParameter = new ParameterInfoImpl (this, seq, parameter);
            } else {
                parameters [seq] = new ParameterInfoImpl (this, seq, parameter);
            }
        }
        for (int i = 0; i < parameters.Length; i ++) {
            if (parameters [i] == null) {
                parameters [i] = new ParameterInfoImpl (this, i, - 1);
            }
        }
        if (returnParameter == null) {
            returnParameter = new ParameterInfoImpl (this, - 1, - 1);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="170" endline="174">
public override Type [] GetGenericArguments () {
    PopulateGenericArguments ();
    return Util.Copy (typeArgs);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="176" endline="197">
private void PopulateGenericArguments () {
    if (typeArgs == null) {
        int token = this.MetadataToken;
        int first = module.GenericParam.FindFirstByOwner (token);
        if (first == - 1) {
            typeArgs = Type.EmptyTypes;
        } else {
            List < Type > list = new List < Type > ();
            int len = module.GenericParam.records.Length;
            for (int i = first; i < len && module.GenericParam.records [i].Owner == token; i ++) {
                list.Add (new GenericTypeParameter (module, i));
            }
            typeArgs = list.ToArray ();
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="199" endline="203">
internal override Type GetGenericMethodArgument (int index) {
    PopulateGenericArguments ();
    return typeArgs [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="205" endline="209">
internal override int GetGenericMethodArgumentCount () {
    PopulateGenericArguments ();
    return typeArgs.Length;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="211" endline="218">
public override MethodInfo GetGenericMethodDefinition () {
    if (this.IsGenericMethodDefinition) {
        return this;
    }
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="220" endline="223">
public override MethodInfo MakeGenericMethod (params Type [] typeArguments) {
    return new GenericMethodInstance (declaringType, this, typeArguments);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="230" endline="239">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    List < CustomAttributeData > list = module.GetCustomAttributes (this.MetadataToken, attributeType);
    if ((this.Attributes & MethodAttributes.PinvokeImpl) != 0 && (attributeType == null || attributeType.IsAssignableFrom (module.universe.System_Runtime_InteropServices_DllImportAttribute))) {
        CreateDllImportPseudoCustomAttribute (list);
    }
    return list;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="241" endline="332">
private void CreateDllImportPseudoCustomAttribute (List < CustomAttributeData > attribs) {
    int token = this.MetadataToken;
    for (int i = 0; i < module.ImplMap.records.Length; i ++) {
        if (module.ImplMap.records [i].MemberForwarded == token) {
            const short NoMangle = 0x0001;
            const short CharSetMask = 0x0006;
            const short CharSetNotSpec = 0x0000;
            const short CharSetAnsi = 0x0002;
            const short CharSetUnicode = 0x0004;
            const short CharSetAuto = 0x0006;
            const short SupportsLastError = 0x0040;
            const short CallConvMask = 0x0700;
            const short CallConvWinapi = 0x0100;
            const short CallConvCdecl = 0x0200;
            const short CallConvStdcall = 0x0300;
            const short CallConvThiscall = 0x0400;
            const short CallConvFastcall = 0x0500;
            const short BestFitOn = 0x0010;
            const short BestFitOff = 0x0020;
            const short CharMapErrorOn = 0x1000;
            const short CharMapErrorOff = 0x2000;
            Type type = module.universe.System_Runtime_InteropServices_DllImportAttribute;
            ConstructorInfo constructor = type.GetConstructor (new Type [] {module.universe.System_String});
            List < CustomAttributeNamedArgument > list = new List < CustomAttributeNamedArgument > ();
            int flags = module.ImplMap.records [i].MappingFlags;
            string entryPoint = module.GetString (module.ImplMap.records [i].ImportName);
            string dllName = module.GetString (module.ModuleRef.records [(module.ImplMap.records [i].ImportScope & 0xFFFFFF) - 1]);
            System.Runtime.InteropServices.CharSet ? charSet;
            switch (flags & CharSetMask) {
                case CharSetAnsi :
                    charSet = System.Runtime.InteropServices.CharSet.Ansi;
                    break;
                case CharSetUnicode :
                    charSet = System.Runtime.InteropServices.CharSet.Unicode;
                    break;
                case CharSetAuto :
                    charSet = System.Runtime.InteropServices.CharSet.Auto;
                    break;
                case CharSetNotSpec : default :
                    charSet = null;
                    break;
            }
            System.Runtime.InteropServices.CallingConvention callingConvention;
            switch (flags & CallConvMask) {
                case CallConvCdecl :
                    callingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
                    break;
                case CallConvFastcall :
                    callingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
                    break;
                case CallConvStdcall :
                    callingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
                    break;
                case CallConvThiscall :
                    callingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
                    break;
                case CallConvWinapi : default :
                    callingConvention = System.Runtime.InteropServices.CallingConvention.Winapi;
                    break;
            }
            list.Add (MakeNamedArgument (type, "EntryPoint", entryPoint));
            list.Add (MakeNamedArgument (type, "ExactSpelling", flags, NoMangle));
            list.Add (MakeNamedArgument (type, "SetLastError", flags, SupportsLastError));
            list.Add (MakeNamedArgument (type, "PreserveSig", (int) GetMethodImplementationFlags (), (int) MethodImplAttributes.PreserveSig));
            list.Add (MakeNamedArgument (type, "CallingConvention", (int) callingConvention));
            if (charSet.HasValue) {
                list.Add (MakeNamedArgument (type, "CharSet", (int) charSet.Value));
            }
            if ((flags & (BestFitOn | BestFitOff)) != 0) {
                list.Add (MakeNamedArgument (type, "BestFitMapping", flags, BestFitOn));
            }
            if ((flags & (CharMapErrorOn | CharMapErrorOff)) != 0) {
                list.Add (MakeNamedArgument (type, "ThrowOnUnmappableChar", flags, CharMapErrorOn));
            }
            attribs.Add (new CustomAttributeData (constructor, new object [] {dllName}, list));
            return;
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="334" endline="337">
private static CustomAttributeNamedArgument MakeNamedArgument (Type type, string field, string value) {
    return new CustomAttributeNamedArgument (type.GetField (field), new CustomAttributeTypedArgument (type.Module.universe.System_String, value));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="339" endline="342">
private static CustomAttributeNamedArgument MakeNamedArgument (Type type, string field, int value) {
    return new CustomAttributeNamedArgument (type.GetField (field), new CustomAttributeTypedArgument (type.Module.universe.System_Int32, value));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="344" endline="347">
private static CustomAttributeNamedArgument MakeNamedArgument (Type type, string field, int flags, int flagMask) {
    return new CustomAttributeNamedArgument (type.GetField (field), new CustomAttributeTypedArgument (type.Module.universe.System_Boolean, (flags & flagMask) != 0));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="354" endline="357">
internal override int ImportTo (Emit.ModuleBuilder module) {
    return module.ImportMethodOrField (declaringType, this.Name, this.MethodSignature);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="440" endline="443">
public override Type [] GetRequiredCustomModifiers () {
    return Util.Copy (position == - 1 ? method.MethodSignature.GetReturnTypeRequiredCustomModifiers (method) : method.MethodSignature.GetParameterRequiredCustomModifiers (method, position));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="445" endline="448">
public override Type [] GetOptionalCustomModifiers () {
    return Util.Copy (position == - 1 ? method.MethodSignature.GetReturnTypeOptionalCustomModifiers (method) : method.MethodSignature.GetParameterOptionalCustomModifiers (method, position));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/Method.cs.ifdefed" startline="474" endline="483">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    IList < CustomAttributeData > list = base.GetCustomAttributesData (attributeType);
    if ((this.Attributes & ParameterAttributes.HasFieldMarshal) != 0 && (attributeType == null || attributeType.IsAssignableFrom (this.Module.universe.System_Runtime_InteropServices_MarshalAsAttribute))) {
        list.Add (MarshalSpec.GetMarshalAsAttribute (this.Module, this.MetadataToken));
    }
    return list;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="38" endline="52">
internal void Read (BinaryReader br) {
    Offset = br.ReadUInt32 ();
    Size = br.ReadUInt32 ();
    byte [] buf = new byte [32];
    byte b;
    int len = 0;
    while ((b = br.ReadByte ()) != 0) {
        buf [len ++] = b;
    }
    Name = Encoding.UTF8.GetString (buf, 0, len);
    int padding = - 1 + ((len + 4) & ~ 3) - len;
    br.BaseStream.Seek (padding, SeekOrigin.Current);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="90" endline="98">
internal Type GetType (ModuleReader module, string typeName) {
    if (type == null) {
        Assembly asm = module.ResolveAssemblyRef (assemblyRef);
        type = asm.GetType (typeName, true);
    }
    return type;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="114" endline="145">
private void Read () {
    BinaryReader br = new BinaryReader (stream);
    peFile.Read (br);
    stream.Seek (peFile.RvaToFileOffset (peFile.GetComDescriptorVirtualAddress ()), SeekOrigin.Begin);
    cliHeader.Read (br);
    stream.Seek (peFile.RvaToFileOffset (cliHeader.MetaDataRVA), SeekOrigin.Begin);
    foreach (StreamHeader sh in ReadStreamHeaders (br, out imageRuntimeVersion)) {
        switch (sh.Name) {
            case "#Strings" :
                stringHeap = ReadHeap (stream, sh);
                break;
            case "#Blob" :
                blobHeap = ReadHeap (stream, sh);
                break;
            case "#US" :
                userStringHeap = ReadHeap (stream, sh);
                break;
            case "#GUID" :
                guidHeap = ReadHeap (stream, sh);
                break;
            case "#~" :
                stream.Seek (peFile.RvaToFileOffset (cliHeader.MetaDataRVA + sh.Offset), SeekOrigin.Begin);
                ReadTables (br);
                break;
            default :
                throw new BadImageFormatException ("Unsupported stream: " + sh.Name);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="147" endline="150">
internal void SetAssembly (Assembly assembly) {
    this.assembly = assembly;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="152" endline="174">
private static StreamHeader [] ReadStreamHeaders (BinaryReader br, out string Version) {
    uint Signature = br.ReadUInt32 ();
    if (Signature != 0x424A5342) {
        throw new BadImageFormatException ("Invalid metadata signature");
    }
    ushort MajorVersion = br.ReadUInt16 ();
    ushort MinorVersion = br.ReadUInt16 ();
    uint Reserved = br.ReadUInt32 ();
    uint Length = br.ReadUInt32 ();
    byte [] buf = br.ReadBytes ((int) Length);
    Version = Encoding.UTF8.GetString (buf).TrimEnd ('\u0000');
    ushort Flags = br.ReadUInt16 ();
    ushort Streams = br.ReadUInt16 ();
    StreamHeader [] streamHeaders = new StreamHeader [Streams];
    for (int i = 0; i < streamHeaders.Length; i ++) {
        streamHeaders [i] = new StreamHeader ();
        streamHeaders [i].Read (br);
    }
    return streamHeaders;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="176" endline="206">
private void ReadTables (BinaryReader br) {
    Table [] tables = GetTables ();
    uint Reserved0 = br.ReadUInt32 ();
    byte MajorVersion = br.ReadByte ();
    byte MinorVersion = br.ReadByte ();
    metadataStreamVersion = MajorVersion << 16 | MinorVersion;
    byte HeapSizes = br.ReadByte ();
    byte Reserved7 = br.ReadByte ();
    ulong Valid = br.ReadUInt64 ();
    ulong Sorted = br.ReadUInt64 ();
    for (int i = 0; i < 64; i ++) {
        if ((Valid & (1UL << i)) != 0) {
            tables [i].RowCount = br.ReadInt32 ();
        } else if (tables [i] != null) {
            tables [i].RowCount = 0;
        }
    }
    MetadataReader mr = new MetadataReader (this, br, HeapSizes);
    for (int i = 0; i < 64; i ++) {
        if ((Valid & (1UL << i)) != 0) {
            tables [i].Read (mr);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="208" endline="222">
private byte [] ReadHeap (Stream stream, StreamHeader sh) {
    byte [] buf = new byte [sh.Size];
    stream.Seek (peFile.RvaToFileOffset (cliHeader.MetaDataRVA + sh.Offset), SeekOrigin.Begin);
    for (int pos = 0; pos < buf.Length;) {
        int read = stream.Read (buf, pos, buf.Length - pos);
        if (read == 0) {
            throw new BadImageFormatException ();
        }
        pos += read;
    }
    return buf;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="224" endline="227">
internal void SeekRVA (int rva) {
    stream.Seek (peFile.RvaToFileOffset ((uint) rva), SeekOrigin.Begin);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="229" endline="239">
internal override void GetTypesImpl (List < Type > list) {
    PopulateTypeDef ();
    foreach (TypeDefImpl type in typeDefs) {
        if (type != moduleType) {
            list.Add (type);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="241" endline="270">
private void PopulateTypeDef () {
    if (typeDefs == null) {
        typeDefs = new TypeDefImpl [TypeDef.records.Length];
        for (int i = 0; i < typeDefs.Length; i ++) {
            TypeDefImpl type = new TypeDefImpl (this, i);
            typeDefs [i] = type;
            if (type.IsModulePseudoType) {
                moduleType = type;
            } else {
                types.Add (type.FullName, type);
            }
        }
        for (int i = 0; i < ExportedType.records.Length; i ++) {
            int implementation = ExportedType.records [i].Implementation;
            if (implementation > > 24 == AssemblyRefTable.Index) {
                string typeName = GetTypeName (ExportedType.records [i].TypeNamespace, ExportedType.records [i].TypeName);
                forwardedTypes.Add (typeName, new LazyForwardedType ((implementation & 0xFFFFFF) - 1));
            }
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="272" endline="290">
internal string GetString (int index) {
    if (index == 0) {
        return null;
    }
    string str;
    if (! strings.TryGetValue (index, out str)) {
        int len = 0;
        while (stringHeap [index + len] != 0) {
            len ++;
        }
        str = Encoding.UTF8.GetString (stringHeap, index, len);
        strings.Add (index, str);
    }
    return str;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="292" endline="311">
private static int ReadCompressedInt (byte [] buffer, ref int offset) {
    byte b1 = buffer [offset ++];
    if (b1 <= 0x7F) {
        return b1;
    } else if ((b1 & 0xC0) == 0x80) {
        byte b2 = buffer [offset ++];
        return ((b1 & 0x3F) << 8) | b2;
    } else {
        byte b2 = buffer [offset ++];
        byte b3 = buffer [offset ++];
        byte b4 = buffer [offset ++];
        return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="313" endline="319">
internal byte [] GetBlobCopy (int blobIndex) {
    int len = ReadCompressedInt (blobHeap, ref blobIndex);
    byte [] buf = new byte [len];
    Buffer.BlockCopy (blobHeap, blobIndex, buf, 0, len);
    return buf;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="321" endline="324">
internal override ByteReader GetBlob (int blobIndex) {
    return ByteReader.FromBlob (blobHeap, blobIndex);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="326" endline="341">
public override string ResolveString (int metadataToken) {
    string str;
    if (! strings.TryGetValue (metadataToken, out str)) {
        if ((metadataToken > > 24) != 0x70) {
            throw new ArgumentOutOfRangeException ();
        }
        int index = metadataToken & 0xFFFFFF;
        int len = ReadCompressedInt (userStringHeap, ref index) & ~ 1;
        str = Encoding.Unicode.GetString (userStringHeap, index, len);
        strings.Add (metadataToken, str);
    }
    return str;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="343" endline="427">
internal Type ResolveType (int metadataToken, IGenericContext context) {
    switch (metadataToken > > 24) {
        case TypeDefTable.Index :
            PopulateTypeDef ();
            return typeDefs [(metadataToken & 0xFFFFFF) - 1];
        case TypeRefTable.Index :
            {
                if (typeRefs == null) {
                    typeRefs = new Type [TypeRef.records.Length];
                }
                int index = (metadataToken & 0xFFFFFF) - 1;
                if (typeRefs [index] == null) {
                    int scope = TypeRef.records [index].ResolutionScope;
                    switch (scope > > 24) {
                        case AssemblyRefTable.Index :
                            {
                                Assembly assembly = ResolveAssemblyRef ((scope & 0xFFFFFF) - 1);
                                string typeName = GetTypeName (TypeRef.records [index].TypeNameSpace, TypeRef.records [index].TypeName);
                                Type type = assembly.GetType (typeName);
                                if (type == null) {
                                    throw new TypeLoadException (String.Format ("Type '{0}' not found in assembly '{1}'", typeName, assembly.FullName));
                                }
                                typeRefs [index] = type;
                                break;
                            } case TypeRefTable.Index :
                            {
                                Type outer = ResolveType (scope, null);
                                typeRefs [index] = outer.GetNestedType (GetString (TypeRef.records [index].TypeName), BindingFlags.Public | BindingFlags.NonPublic);
                                break;
                            } case ModuleTable.Index :
                            if (scope != 0 && scope != 1) {
                                throw new NotImplementedException ("self reference scope?");
                            }
                            typeRefs [index] = GetType (GetTypeName (TypeRef.records [index].TypeNameSpace, TypeRef.records [index].TypeName));
                            break;
                        case ModuleRefTable.Index :
                            {
                                Module module = ResolveModuleRef (ModuleRef.records [(scope & 0xFFFFFF) - 1]);
                                string typeName = GetTypeName (TypeRef.records [index].TypeNameSpace, TypeRef.records [index].TypeName);
                                Type type = assembly.GetType (typeName);
                                if (type == null) {
                                    throw new TypeLoadException (String.Format ("Type '{0}' not found in module '{1}'", typeName, module.Name));
                                }
                                typeRefs [index] = type;
                                break;
                            } default :
                            throw new NotImplementedException ("ResolutionScope = " + scope.ToString ("X"));
                    }
                }
                return typeRefs [index];
            } case TypeSpecTable.Index :
            {
                if (typeSpecs == null) {
                    typeSpecs = new Type [TypeSpec.records.Length];
                }
                int index = (metadataToken & 0xFFFFFF) - 1;
                Type type = typeSpecs [index];
                if (type == null) {
                    TrackingGenericContext tc = context == null ? null : new TrackingGenericContext (context);
                    type = Signature.ReadTypeSpec (this, ByteReader.FromBlob (blobHeap, TypeSpec.records [index]), tc);
                    if (tc == null || ! tc.IsUsed) {
                        typeSpecs [index] = type;
                    }
                }
                return type;
            } default :
            throw new NotImplementedException (String.Format ("0x{0:X}", metadataToken));
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="429" endline="438">
private Module ResolveModuleRef (int moduleNameIndex) {
    string moduleName = GetString (moduleNameIndex);
    Module module = assembly.GetModule (moduleName);
    if (module == null) {
        throw new FileNotFoundException (moduleName);
    }
    return module;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="455" endline="459">
public Type GetGenericTypeArgument (int index) {
    used = true;
    return context.GetGenericTypeArgument (index);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="461" endline="465">
public Type GetGenericMethodArgument (int index) {
    used = true;
    return context.GetGenericMethodArgument (index);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="468" endline="478">
public override Type ResolveType (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    if ((metadataToken > > 24) == TypeSpecTable.Index) {
        return ResolveType (metadataToken, new GenericContext (genericTypeArguments, genericMethodArguments));
    } else {
        return ResolveType (metadataToken, null);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="480" endline="490">
private string GetTypeName (int typeNamespace, int typeName) {
    if (typeNamespace == 0) {
        return GetString (typeName);
    } else {
        return GetString (typeNamespace) + "." + GetString (typeName);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="492" endline="503">
private Assembly ResolveAssemblyRef (int index) {
    if (assemblyRefs == null) {
        assemblyRefs = new Assembly [AssemblyRef.RowCount];
    }
    if (assemblyRefs [index] == null) {
        assemblyRefs [index] = ResolveAssemblyRefImpl (ref AssemblyRef.records [index]);
    }
    return assemblyRefs [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="505" endline="518">
private Assembly ResolveAssemblyRefImpl (ref AssemblyRefTable.Record rec) {
    const int PublicKey = 0x0001;
    string name = String.Format ("{0}, Version={1}.{2}.{3}.{4}, Culture={5}, {6}={7}", GetString (rec.Name), rec.MajorVersion, rec.MinorVersion, rec.BuildNumber, rec.RevisionNumber, rec.Culture == 0 ? "neutral" : GetString (rec.Culture), (rec.Flags & PublicKey) == 0 ? "PublicKeyToken" : "PublicKey", PublicKeyOrTokenToString (rec.PublicKeyOrToken));
    return universe.Load (name, this.Assembly, true);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="520" endline="537">
private string PublicKeyOrTokenToString (int publicKeyOrToken) {
    if (publicKeyOrToken == 0) {
        return "null";
    }
    ByteReader br = GetBlob (publicKeyOrToken);
    if (br.Length == 0) {
        return "null";
    }
    StringBuilder sb = new StringBuilder (br.Length * 2);
    while (br.Length > 0) {
        sb.AppendFormat ("{0:x2}", br.ReadByte ());
    }
    return sb.ToString ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="564" endline="577">
internal override Type GetTypeImpl (string typeName) {
    PopulateTypeDef ();
    Type type;
    if (! types.TryGetValue (typeName, out type)) {
        LazyForwardedType fw;
        if (forwardedTypes.TryGetValue (typeName, out fw)) {
            return fw.GetType (this, typeName);
        }
    }
    return type;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="579" endline="592">
public override MemberInfo ResolveMember (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    switch (metadataToken > > 24) {
        case FieldTable.Index :
            return ResolveField (metadataToken, genericTypeArguments, genericMethodArguments);
        case MemberRefTable.Index :
            return GetMemberRef ((metadataToken & 0xFFFFFF) - 1, genericTypeArguments, genericMethodArguments);
        case MethodDefTable.Index : case MethodSpecTable.Index :
            return ResolveMethod (metadataToken, genericTypeArguments, genericMethodArguments);
    }
    throw new ArgumentOutOfRangeException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="594" endline="605">
internal FieldInfo GetFieldAt (TypeDefImpl owner, int index) {
    if (fields == null) {
        fields = new FieldInfo [Field.records.Length];
    }
    if (fields [index] == null) {
        fields [index] = new FieldDefImpl (this, owner ?? FindFieldOwner (index), index);
    }
    return fields [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="607" endline="623">
public override FieldInfo ResolveField (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    if ((metadataToken > > 24) == FieldTable.Index) {
        int index = (metadataToken & 0xFFFFFF) - 1;
        return GetFieldAt (null, index);
    } else if ((metadataToken > > 24) == MemberRefTable.Index) {
        FieldInfo field = GetMemberRef ((metadataToken & 0xFFFFFF) - 1, genericTypeArguments, genericMethodArguments) as FieldInfo;
        if (field != null) {
            return field;
        }
    }
    throw new ArgumentOutOfRangeException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="625" endline="639">
private TypeDefImpl FindFieldOwner (int fieldIndex) {
    for (int i = 0; i < TypeDef.records.Length; i ++) {
        int field = TypeDef.records [i].FieldList - 1;
        int end = TypeDef.records.Length > i + 1 ? TypeDef.records [i + 1].FieldList - 1 : Field.records.Length;
        if (field <= fieldIndex && fieldIndex < end) {
            PopulateTypeDef ();
            return typeDefs [i];
        }
    }
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="641" endline="653">
internal MethodBase GetMethodAt (TypeDefImpl owner, int index) {
    if (methods == null) {
        methods = new MethodBase [MethodDef.records.Length];
    }
    if (methods [index] == null) {
        MethodDefImpl method = new MethodDefImpl (this, owner ?? FindMethodOwner (index), index);
        methods [index] = method.IsConstructor ? new ConstructorInfoImpl (method) : (MethodBase) method;
    }
    return methods [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="666" endline="669">
public Type GetGenericTypeArgument (int index) {
    return genericTypeArguments [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="671" endline="674">
public Type GetGenericMethodArgument (int index) {
    return genericMethodArguments [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="677" endline="701">
public override MethodBase ResolveMethod (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    if ((metadataToken > > 24) == MethodDefTable.Index) {
        int index = (metadataToken & 0xFFFFFF) - 1;
        return GetMethodAt (null, index);
    } else if ((metadataToken > > 24) == MemberRefTable.Index) {
        int index = (metadataToken & 0xFFFFFF) - 1;
        MethodBase method = GetMemberRef (index, genericTypeArguments, genericMethodArguments) as MethodBase;
        if (method != null) {
            return method;
        }
    } else if ((metadataToken > > 24) == MethodSpecTable.Index) {
        int index = (metadataToken & 0xFFFFFF) - 1;
        MethodInfo method = (MethodInfo) ResolveMethod (MethodSpec.records [index].Method, genericTypeArguments, genericMethodArguments);
        ByteReader instantiation = ByteReader.FromBlob (blobHeap, MethodSpec.records [index].Instantiation);
        return method.MakeGenericMethod (Signature.ReadMethodSpec (this, instantiation, new GenericContext (genericTypeArguments, genericMethodArguments)));
    }
    throw new ArgumentOutOfRangeException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="703" endline="719">
public override Type [] __ResolveOptionalParameterTypes (int metadataToken) {
    if ((metadataToken > > 24) == MemberRefTable.Index) {
        int index = (metadataToken & 0xFFFFFF) - 1;
        int sig = MemberRef.records [index].Signature;
        return Signature.ReadOptionalParameterTypes (this, GetBlob (sig));
    } else if ((metadataToken > > 24) == MethodDefTable.Index) {
        return Type.EmptyTypes;
    }
    throw new ArgumentOutOfRangeException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="726" endline="740">
private TypeDefImpl FindMethodOwner (int methodIndex) {
    for (int i = 0; i < TypeDef.records.Length; i ++) {
        int method = TypeDef.records [i].MethodList - 1;
        int end = TypeDef.records.Length > i + 1 ? TypeDef.records [i + 1].MethodList - 1 : MethodDef.records.Length;
        if (method <= methodIndex && methodIndex < end) {
            PopulateTypeDef ();
            return typeDefs [i];
        }
    }
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="742" endline="771">
private MemberInfo GetMemberRef (int index, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    if (memberRefs == null) {
        memberRefs = new MemberInfo [MemberRef.records.Length];
    }
    if (memberRefs [index] == null) {
        int owner = MemberRef.records [index].Class;
        int sig = MemberRef.records [index].Signature;
        string name = GetString (MemberRef.records [index].Name);
        switch (owner > > 24) {
            case MethodDefTable.Index :
                return GetMethodAt (null, (owner & 0xFFFFFF) - 1);
            case ModuleRefTable.Index :
                memberRefs [index] = ResolveTypeMemberRef (ResolveModuleType (owner), name, ByteReader.FromBlob (blobHeap, sig), genericTypeArguments, genericMethodArguments);
                break;
            case TypeDefTable.Index : case TypeRefTable.Index :
                memberRefs [index] = ResolveTypeMemberRef (ResolveType (owner), name, ByteReader.FromBlob (blobHeap, sig), genericTypeArguments, genericMethodArguments);
                break;
            case TypeSpecTable.Index :
                return ResolveTypeMemberRef (ResolveType (owner, genericTypeArguments, genericMethodArguments), name, ByteReader.FromBlob (blobHeap, sig), genericTypeArguments, genericMethodArguments);
            default :
                throw new BadImageFormatException ();
        }
    }
    return memberRefs [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="773" endline="783">
private Type ResolveModuleType (int token) {
    int index = (token & 0xFFFFFF) - 1;
    string name = GetString (ModuleRef.records [index]);
    Module module = assembly.GetModule (name);
    if (module == null || module.IsResource ()) {
        throw new BadImageFormatException ();
    }
    return module.GetModuleType ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="785" endline="826">
private MemberInfo ResolveTypeMemberRef (Type type, string name, ByteReader sig, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    IGenericContext context;
    if ((genericTypeArguments == null && genericMethodArguments == null) || type.IsGenericType) {
        context = type;
    } else {
        context = new GenericContext (genericTypeArguments, genericMethodArguments);
    }
    if (sig.PeekByte () == Signature.FIELD) {
        Type org = type;
        FieldSignature fieldSig = FieldSignature.ReadSig (this, sig, context);
        do
            {
                FieldInfo field = type.FindField (name, fieldSig);
                if (field != null) {
                    return field;
                }
                type = type.BaseType;
            } while (type != null);
        throw new MissingFieldException (org.ToString (), name);
    } else {
        Type org = type;
        MethodSignature methodSig = MethodSignature.ReadSig (this, sig, context);
        do
            {
                MethodBase method = type.FindMethod (name, methodSig);
                if (method != null) {
                    return method;
                }
                type = type.BaseType;
            } while (type != null);
        throw new MissingMethodException (org.ToString (), name);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="828" endline="836">
internal new ByteReader ResolveSignature (int metadataToken) {
    if ((metadataToken > > 24) == StandAloneSigTable.Index) {
        int index = (metadataToken & 0xFFFFFF) - 1;
        return ByteReader.FromBlob (blobHeap, StandAloneSig.records [index]);
    }
    throw new ArgumentOutOfRangeException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="838" endline="841">
public override __StandAloneMethodSig __ResolveStandAloneMethodSig (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    return MethodSignature.ReadStandAloneMethodSig (this, ResolveSignature (metadataToken), new GenericContext (genericTypeArguments, genericMethodArguments));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="843" endline="850">
internal MethodInfo GetEntryPoint () {
    if (cliHeader.EntryPointToken != 0 && (cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT) == 0) {
        return (MethodInfo) ResolveMethod ((int) cliHeader.EntryPointToken);
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="852" endline="860">
internal string [] GetManifestResourceNames () {
    string [] names = new string [ManifestResource.records.Length];
    for (int i = 0; i < ManifestResource.records.Length; i ++) {
        names [i] = GetString (ManifestResource.records [i].Name);
    }
    return names;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="862" endline="872">
internal ManifestResourceInfo GetManifestResourceInfo (string resourceName) {
    for (int i = 0; i < ManifestResource.records.Length; i ++) {
        if (resourceName == GetString (ManifestResource.records [i].Name)) {
            return new ManifestResourceInfo (this, i);
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="874" endline="891">
internal Stream GetManifestResourceStream (string resourceName) {
    for (int i = 0; i < ManifestResource.records.Length; i ++) {
        if (resourceName == GetString (ManifestResource.records [i].Name)) {
            if (ManifestResource.records [i].Implementation != 0x26000000) {
                throw new NotImplementedException ();
            }
            SeekRVA ((int) cliHeader.ResourcesRVA + ManifestResource.records [i].Offset);
            BinaryReader br = new BinaryReader (stream);
            int length = br.ReadInt32 ();
            return new MemoryStream (br.ReadBytes (length));
        }
    }
    throw new FileNotFoundException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="893" endline="930">
public override AssemblyName [] __GetReferencedAssemblies () {
    List < AssemblyName > list = new List < AssemblyName > ();
    for (int i = 0; i < AssemblyRef.records.Length; i ++) {
        AssemblyName name = new AssemblyName ();
        name.Name = GetString (AssemblyRef.records [i].Name);
        name.Version = new Version (AssemblyRef.records [i].MajorVersion, AssemblyRef.records [i].MinorVersion, AssemblyRef.records [i].BuildNumber, AssemblyRef.records [i].RevisionNumber);
        if (AssemblyRef.records [i].PublicKeyOrToken != 0) {
            byte [] keyOrToken = GetBlobCopy (AssemblyRef.records [i].PublicKeyOrToken);
            const int PublicKey = 0x0001;
            if ((AssemblyRef.records [i].Flags & PublicKey) != 0) {
                name.SetPublicKey (keyOrToken);
            } else {
                name.SetPublicKeyToken (keyOrToken);
            }
        }
        if (AssemblyRef.records [i].Culture != 0) {
            name.CultureInfo = new System.Globalization.CultureInfo (GetString (AssemblyRef.records [i].Culture));
        } else {
            name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
        }
        name.Flags = (AssemblyNameFlags) AssemblyRef.records [i].Flags;
        list.Add (name);
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="932" endline="936">
internal override Type GetModuleType () {
    PopulateTypeDef ();
    return moduleType;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="948" endline="951">
public override void __GetDataDirectoryEntry (int index, out int rva, out int length) {
    peFile.GetDataDirectoryEntry (index, out rva, out length);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="953" endline="956">
public override long __RelativeVirtualAddressToFileOffset (int rva) {
    return peFile.RvaToFileOffset ((uint) rva);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="958" endline="975">
public override void GetPEKind (out PortableExecutableKinds peKind, out ImageFileMachine machine) {
    peKind = 0;
    if ((cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_ILONLY) != 0) {
        peKind |= PortableExecutableKinds.ILOnly;
    }
    if ((cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_32BITREQUIRED) != 0) {
        peKind |= PortableExecutableKinds.Required32Bit;
    }
    if (peFile.OptionalHeader.Magic == IMAGE_OPTIONAL_HEADER.IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        peKind |= PortableExecutableKinds.PE32Plus;
    }
    machine = (ImageFileMachine) peFile.FileHeader.Machine;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="982" endline="1015">
public override IList < CustomAttributeData > __GetPlaceholderAssemblyCustomAttributes (bool multiple, bool security) {
    string typeName;
    switch ((multiple ? 1 : 0) + (security ? 2 : 0)) {
        case 0 :
            typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHere";
            break;
        case 1 :
            typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereM";
            break;
        case 2 :
            typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereS";
            break;
        case 3 : default :
            typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereSM";
            break;
    }
    List < CustomAttributeData > list = new List < CustomAttributeData > ();
    for (int i = 0; i < CustomAttribute.records.Length; i ++) {
        if ((CustomAttribute.records [i].Parent > > 24) == TypeRefTable.Index) {
            int index = (CustomAttribute.records [i].Parent & 0xFFFFFF) - 1;
            if (typeName == GetTypeName (TypeRef.records [index].TypeNameSpace, TypeRef.records [index].TypeName)) {
                ConstructorInfo constructor = (ConstructorInfo) ResolveMethod (CustomAttribute.records [i].Type);
                list.Add (new CustomAttributeData (this.Assembly, constructor, GetBlob (CustomAttribute.records [i].Value)));
            }
        }
    }
    return list;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="1017" endline="1020">
internal override void Dispose () {
    stream.Close ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ModuleReader.cs.ifdefed" startline="1022" endline="1026">
internal override void ExportTypes (int fileToken, IKVM.Reflection.Emit.ModuleBuilder manifestModule) {
    PopulateTypeDef ();
    manifestModule.ExportTypes (typeDefs, fileToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PEReader.cs.ifdefed" startline="50" endline="59">
internal void Read (BinaryReader br) {
    Signature = br.ReadUInt32 ();
    if (Signature != IMAGE_NT_HEADERS.MAGIC_SIGNATURE) {
        throw new BadImageFormatException ();
    }
    FileHeader.Read (br);
    OptionalHeader.Read (br);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PEReader.cs.ifdefed" startline="81" endline="90">
internal void Read (BinaryReader br) {
    Machine = br.ReadUInt16 ();
    NumberOfSections = br.ReadUInt16 ();
    TimeDateStamp = br.ReadUInt32 ();
    PointerToSymbolTable = br.ReadUInt32 ();
    NumberOfSymbols = br.ReadUInt32 ();
    SizeOfOptionalHeader = br.ReadUInt16 ();
    Characteristics = br.ReadUInt16 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PEReader.cs.ifdefed" startline="138" endline="197">
internal void Read (BinaryReader br) {
    Magic = br.ReadUInt16 ();
    if (Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC && Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        throw new BadImageFormatException ();
    }
    MajorLinkerVersion = br.ReadByte ();
    MinorLinkerVersion = br.ReadByte ();
    SizeOfCode = br.ReadUInt32 ();
    SizeOfInitializedData = br.ReadUInt32 ();
    SizeOfUninitializedData = br.ReadUInt32 ();
    AddressOfEntryPoint = br.ReadUInt32 ();
    BaseOfCode = br.ReadUInt32 ();
    if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        BaseOfData = br.ReadUInt32 ();
        ImageBase = br.ReadUInt32 ();
    } else {
        ImageBase = br.ReadUInt64 ();
    }
    SectionAlignment = br.ReadUInt32 ();
    FileAlignment = br.ReadUInt32 ();
    MajorOperatingSystemVersion = br.ReadUInt16 ();
    MinorOperatingSystemVersion = br.ReadUInt16 ();
    MajorImageVersion = br.ReadUInt16 ();
    MinorImageVersion = br.ReadUInt16 ();
    MajorSubsystemVersion = br.ReadUInt16 ();
    MinorSubsystemVersion = br.ReadUInt16 ();
    Win32VersionValue = br.ReadUInt32 ();
    SizeOfImage = br.ReadUInt32 ();
    SizeOfHeaders = br.ReadUInt32 ();
    CheckSum = br.ReadUInt32 ();
    Subsystem = br.ReadUInt16 ();
    DllCharacteristics = br.ReadUInt16 ();
    if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        SizeOfStackReserve = br.ReadUInt32 ();
        SizeOfStackCommit = br.ReadUInt32 ();
        SizeOfHeapReserve = br.ReadUInt32 ();
        SizeOfHeapCommit = br.ReadUInt32 ();
    } else {
        SizeOfStackReserve = br.ReadUInt64 ();
        SizeOfStackCommit = br.ReadUInt64 ();
        SizeOfHeapReserve = br.ReadUInt64 ();
        SizeOfHeapCommit = br.ReadUInt64 ();
    }
    LoaderFlags = br.ReadUInt32 ();
    NumberOfRvaAndSizes = br.ReadUInt32 ();
    DataDirectory = new IMAGE_DATA_DIRECTORY [NumberOfRvaAndSizes];
    for (uint i = 0; i < NumberOfRvaAndSizes; i ++) {
        DataDirectory [i] = new IMAGE_DATA_DIRECTORY ();
        DataDirectory [i].Read (br);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PEReader.cs.ifdefed" startline="205" endline="209">
internal void Read (BinaryReader br) {
    VirtualAddress = br.ReadUInt32 ();
    Size = br.ReadUInt32 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PEReader.cs.ifdefed" startline="232" endline="255">
internal void Read (BinaryReader br) {
    char [] name = new char [8];
    int len = 8;
    for (int i = 0; i < 8; i ++) {
        byte b = br.ReadByte ();
        name [i] = (char) b;
        if (b == 0 && len == 8) {
            len = i;
        }
    }
    Name = new String (name, 0, len);
    VirtualSize = br.ReadUInt32 ();
    VirtualAddress = br.ReadUInt32 ();
    SizeOfRawData = br.ReadUInt32 ();
    PointerToRawData = br.ReadUInt32 ();
    PointerToRelocations = br.ReadUInt32 ();
    PointerToLinenumbers = br.ReadUInt32 ();
    NumberOfRelocations = br.ReadUInt16 ();
    NumberOfLinenumbers = br.ReadUInt16 ();
    Characteristics = br.ReadUInt32 ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PEReader.cs.ifdefed" startline="264" endline="283">
internal void Read (BinaryReader br) {
    msdos.signature = br.ReadUInt16 ();
    br.BaseStream.Seek (58, SeekOrigin.Current);
    msdos.peSignatureOffset = br.ReadUInt32 ();
    if (msdos.signature != MSDOS_HEADER.MAGIC_MZ) {
        throw new BadImageFormatException ();
    }
    br.BaseStream.Seek (msdos.peSignatureOffset, SeekOrigin.Begin);
    headers.Read (br);
    sections = new SectionHeader [headers.FileHeader.NumberOfSections];
    for (int i = 0; i < sections.Length; i ++) {
        sections [i] = new SectionHeader ();
        sections [i].Read (br);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PEReader.cs.ifdefed" startline="295" endline="298">
internal DWORD GetComDescriptorVirtualAddress () {
    return headers.OptionalHeader.DataDirectory [14].VirtualAddress;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PEReader.cs.ifdefed" startline="300" endline="304">
internal void GetDataDirectoryEntry (int index, out int rva, out int length) {
    rva = (int) headers.OptionalHeader.DataDirectory [index].VirtualAddress;
    length = (int) headers.OptionalHeader.DataDirectory [index].Size;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PEReader.cs.ifdefed" startline="306" endline="316">
internal long RvaToFileOffset (DWORD rva) {
    for (int i = 0; i < sections.Length; i ++) {
        if (rva >= sections [i].VirtualAddress && rva < sections [i].VirtualAddress + sections [i].VirtualSize) {
            return sections [i].PointerToRawData + rva - sections [i].VirtualAddress;
        }
    }
    throw new BadImageFormatException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PropertyInfoImpl.cs.ifdefed" startline="48" endline="52">
public override bool Equals (object obj) {
    PropertyInfoImpl other = obj as PropertyInfoImpl;
    return other != null && other.DeclaringType == declaringType && other.index == index;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PropertyInfoImpl.cs.ifdefed" startline="54" endline="57">
public override int GetHashCode () {
    return declaringType.GetHashCode () * 77 + index;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PropertyInfoImpl.cs.ifdefed" startline="76" endline="79">
public override object GetRawConstantValue () {
    return module.Constant.GetRawConstantValue (module, this.MetadataToken);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PropertyInfoImpl.cs.ifdefed" startline="91" endline="94">
public override MethodInfo GetGetMethod (bool nonPublic) {
    return module.MethodSemantics.GetMethod (module, this.MetadataToken, nonPublic, MethodSemanticsTable.Getter);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PropertyInfoImpl.cs.ifdefed" startline="96" endline="99">
public override MethodInfo GetSetMethod (bool nonPublic) {
    return module.MethodSemantics.GetMethod (module, this.MetadataToken, nonPublic, MethodSemanticsTable.Setter);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PropertyInfoImpl.cs.ifdefed" startline="101" endline="104">
public override MethodInfo [] GetAccessors (bool nonPublic) {
    return module.MethodSemantics.GetMethods (module, this.MetadataToken, nonPublic, MethodSemanticsTable.Getter | MethodSemanticsTable.Setter | MethodSemanticsTable.Other);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/PropertyInfoImpl.cs.ifdefed" startline="150" endline="154">
private void ComputeFlags () {
    module.MethodSemantics.ComputeFlags (module, this.MetadataToken, out isPublic, out isStatic);
    flagsCached = true;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="48" endline="51">
public override bool IsResource () {
    return true;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="78" endline="81">
public override Type ResolveType (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="83" endline="86">
public override MethodBase ResolveMethod (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="88" endline="91">
public override FieldInfo ResolveField (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="93" endline="96">
public override MemberInfo ResolveMember (int metadataToken, Type [] genericTypeArguments, Type [] genericMethodArguments) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="98" endline="101">
public override string ResolveString (int metadataToken) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="103" endline="106">
public override Type [] __ResolveOptionalParameterTypes (int metadataToken) {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="108" endline="111">
public override AssemblyName [] __GetReferencedAssemblies () {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="113" endline="116">
internal override Type GetTypeImpl (string typeName) {
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="118" endline="120">
internal override void GetTypesImpl (List < Type > list) {
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="122" endline="125">
internal override Type GetModuleType () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/ResourceModule.cs.ifdefed" startline="127" endline="130">
internal override ByteReader GetBlob (int blobIndex) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="66" endline="85">
public override EventInfo [] __GetDeclaredEvents () {
    int token = this.MetadataToken;
    for (int i = 0; i < module.EventMap.records.Length; i ++) {
        if (module.EventMap.records [i].Parent == token) {
            int evt = module.EventMap.records [i].EventList - 1;
            int end = module.EventMap.records.Length > i + 1 ? module.EventMap.records [i + 1].EventList - 1 : module.Event.records.Length;
            EventInfo [] events = new EventInfo [end - evt];
            for (int j = 0; evt < end; evt ++, j ++) {
                events [j] = new EventInfoImpl (module, this, evt);
            }
            return events;
        }
    }
    return Empty < EventInfo >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="87" endline="97">
public override FieldInfo [] __GetDeclaredFields () {
    int field = module.TypeDef.records [index].FieldList - 1;
    int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records [index + 1].FieldList - 1 : module.Field.records.Length;
    FieldInfo [] fields = new FieldInfo [end - field];
    for (int i = 0; field < end; i ++, field ++) {
        fields [i] = module.GetFieldAt (this, field);
    }
    return fields;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="99" endline="112">
public override Type [] __GetDeclaredInterfaces () {
    int token = this.MetadataToken;
    List < Type > list = new List < Type > ();
    for (int i = 0; i < module.InterfaceImpl.records.Length; i ++) {
        if (module.InterfaceImpl.records [i].Class == token) {
            list.Add (module.ResolveType (module.InterfaceImpl.records [i].Interface, this));
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="114" endline="124">
public override MethodBase [] __GetDeclaredMethods () {
    int method = module.TypeDef.records [index].MethodList - 1;
    int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records [index + 1].MethodList - 1 : module.MethodDef.records.Length;
    MethodBase [] methods = new MethodBase [end - method];
    for (int i = 0; method < end; method ++, i ++) {
        methods [i] = module.GetMethodAt (this, method);
    }
    return methods;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="126" endline="157">
public override __MethodImplMap __GetMethodImplMap () {
    List < MethodInfo > bodies = new List < MethodInfo > ();
    List < List < MethodInfo > > declarations = new List < List < MethodInfo > > ();
    int token = this.MetadataToken;
    for (int i = 0; i < module.MethodImpl.records.Length; i ++) {
        if (module.MethodImpl.records [i].Class == token) {
            MethodInfo body = (MethodInfo) module.ResolveMethod (module.MethodImpl.records [i].MethodBody, typeArgs, null);
            int index = bodies.IndexOf (body);
            if (index == - 1) {
                index = bodies.Count;
                bodies.Add (body);
                declarations.Add (new List < MethodInfo > ());
            }
            MethodInfo declaration = (MethodInfo) module.ResolveMethod (module.MethodImpl.records [i].MethodDeclaration, typeArgs, null);
            declarations [index].Add (declaration);
        }
    }
    __MethodImplMap map = new __MethodImplMap ();
    map.TargetType = this;
    map.MethodBodies = bodies.ToArray ();
    map.MethodDeclarations = new MethodInfo [declarations.Count] [];
    for (int i = 0; i < map.MethodDeclarations.Length; i ++) {
        map.MethodDeclarations [i] = declarations [i].ToArray ();
    }
    return map;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="159" endline="172">
public override Type [] __GetDeclaredTypes () {
    int token = this.MetadataToken;
    List < Type > list = new List < Type > ();
    for (int i = 0; i < module.NestedClass.records.Length; i ++) {
        if (module.NestedClass.records [i].EnclosingClass == token) {
            list.Add (module.ResolveType (module.NestedClass.records [i].NestedClass));
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="174" endline="193">
public override PropertyInfo [] __GetDeclaredProperties () {
    int token = this.MetadataToken;
    for (int i = 0; i < module.PropertyMap.records.Length; i ++) {
        if (module.PropertyMap.records [i].Parent == token) {
            int property = module.PropertyMap.records [i].PropertyList - 1;
            int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records [i + 1].PropertyList - 1 : module.Property.records.Length;
            PropertyInfo [] properties = new PropertyInfo [end - property];
            for (int j = 0; property < end; property ++, j ++) {
                properties [j] = new PropertyInfoImpl (module, this, property);
            }
            return properties;
        }
    }
    return Empty < PropertyInfo >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="215" endline="219">
public override Type [] GetGenericArguments () {
    PopulateGenericArguments ();
    return Util.Copy (typeArgs);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="221" endline="242">
private void PopulateGenericArguments () {
    if (typeArgs == null) {
        int token = this.MetadataToken;
        int first = module.GenericParam.FindFirstByOwner (token);
        if (first == - 1) {
            typeArgs = Type.EmptyTypes;
        } else {
            List < Type > list = new List < Type > ();
            int len = module.GenericParam.records.Length;
            for (int i = first; i < len && module.GenericParam.records [i].Owner == token; i ++) {
                list.Add (new GenericTypeParameter (module, i));
            }
            typeArgs = list.ToArray ();
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="244" endline="248">
internal override Type GetGenericTypeArgument (int index) {
    PopulateGenericArguments ();
    return typeArgs [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="250" endline="254">
public override Type [] [] __GetGenericArgumentsOptionalCustomModifiers () {
    PopulateGenericArguments ();
    return Util.Copy (new Type [typeArgs.Length] []);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="256" endline="260">
public override Type [] [] __GetGenericArgumentsRequiredCustomModifiers () {
    PopulateGenericArguments ();
    return Util.Copy (new Type [typeArgs.Length] []);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="272" endline="279">
public override Type GetGenericTypeDefinition () {
    if (IsGenericTypeDefinition) {
        return this;
    }
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Reader/TypeDefImpl.cs.ifdefed" startline="281" endline="296">
public override string ToString () {
    StringBuilder sb = new StringBuilder (this.FullName);
    string sep = "[";
    foreach (Type arg in GetGenericArguments ()) {
        sb.Append (sep);
        sb.Append (arg);
        sep = ",";
    }
    if (sep != "[") {
        sb.Append (']');
    }
    return sb.ToString ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="83" endline="119">
private static Type ReadGenericInst (ModuleReader module, ByteReader br, IGenericContext context) {
    switch (br.ReadByte ()) {
        case ELEMENT_TYPE_CLASS : case ELEMENT_TYPE_VALUETYPE :
            break;
        default :
            throw new BadImageFormatException ();
    }
    Type type = ReadTypeDefOrRefEncoded (module, br, context);
    if (! type.IsGenericTypeDefinition) {
        throw new BadImageFormatException ();
    }
    int genArgCount = br.ReadCompressedInt ();
    Type [] args = new Type [genArgCount];
    Type [] [] reqmod = null;
    Type [] [] optmod = null;
    for (int i = 0; i < genArgCount; i ++) {
        CustomModifiers mods = ReadCustomModifiers (module, br, context);
        if (mods.required != null || mods.optional != null) {
            if (reqmod == null) {
                reqmod = new Type [genArgCount] [];
                optmod = new Type [genArgCount] [];
            }
            reqmod [i] = mods.required;
            optmod [i] = mods.optional;
        }
        args [i] = ReadType (module, br, context);
    }
    return GenericTypeInstance.Make (type, args, reqmod, optmod);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="121" endline="128">
internal static Type ReadTypeSpec (ModuleReader module, ByteReader br, IGenericContext context) {
    SkipCustomModifiers (br);
    return ReadType (module, br, context);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="130" endline="136">
private static Type ReadFunctionPointer (ModuleReader module, ByteReader br, IGenericContext context) {
    MethodSignature.ReadStandAloneMethodSig (module, br, context);
    return module.universe.System_IntPtr;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="138" endline="150">
internal static Type [] ReadMethodSpec (ModuleReader module, ByteReader br, IGenericContext context) {
    if (br.ReadByte () != GENERICINST) {
        throw new BadImageFormatException ();
    }
    Type [] args = new Type [br.ReadCompressedInt ()];
    for (int i = 0; i < args.Length; i ++) {
        args [i] = ReadType (module, br, context);
    }
    return args;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="152" endline="166">
private static int ReadArrayShape (ByteReader br) {
    int rank = br.ReadCompressedInt ();
    int numSizes = br.ReadCompressedInt ();
    for (int i = 0; i < numSizes; i ++) {
        br.ReadCompressedInt ();
    }
    int numLoBounds = br.ReadCompressedInt ();
    for (int i = 0; i < numLoBounds; i ++) {
        br.ReadCompressedInt ();
    }
    return rank;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="168" endline="179">
private static Type ReadTypeOrVoid (ModuleReader module, ByteReader br, IGenericContext context) {
    if (br.PeekByte () == ELEMENT_TYPE_VOID) {
        br.ReadByte ();
        return module.universe.System_Void;
    } else {
        return ReadType (module, br, context);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="182" endline="242">
protected static Type ReadType (ModuleReader module, ByteReader br, IGenericContext context) {
    CustomModifiers mods;
    switch (br.ReadByte ()) {
        case ELEMENT_TYPE_CLASS : case ELEMENT_TYPE_VALUETYPE :
            return ReadTypeDefOrRefEncoded (module, br, context);
        case ELEMENT_TYPE_BOOLEAN :
            return module.universe.System_Boolean;
        case ELEMENT_TYPE_CHAR :
            return module.universe.System_Char;
        case ELEMENT_TYPE_I1 :
            return module.universe.System_SByte;
        case ELEMENT_TYPE_U1 :
            return module.universe.System_Byte;
        case ELEMENT_TYPE_I2 :
            return module.universe.System_Int16;
        case ELEMENT_TYPE_U2 :
            return module.universe.System_UInt16;
        case ELEMENT_TYPE_I4 :
            return module.universe.System_Int32;
        case ELEMENT_TYPE_U4 :
            return module.universe.System_UInt32;
        case ELEMENT_TYPE_I8 :
            return module.universe.System_Int64;
        case ELEMENT_TYPE_U8 :
            return module.universe.System_UInt64;
        case ELEMENT_TYPE_R4 :
            return module.universe.System_Single;
        case ELEMENT_TYPE_R8 :
            return module.universe.System_Double;
        case ELEMENT_TYPE_I :
            return module.universe.System_IntPtr;
        case ELEMENT_TYPE_U :
            return module.universe.System_UIntPtr;
        case ELEMENT_TYPE_STRING :
            return module.universe.System_String;
        case ELEMENT_TYPE_OBJECT :
            return module.universe.System_Object;
        case ELEMENT_TYPE_VAR :
            return context.GetGenericTypeArgument (br.ReadCompressedInt ());
        case ELEMENT_TYPE_MVAR :
            return context.GetGenericMethodArgument (br.ReadCompressedInt ());
        case ELEMENT_TYPE_GENERICINST :
            return ReadGenericInst (module, br, context);
        case ELEMENT_TYPE_SZARRAY :
            mods = ReadCustomModifiers (module, br, context);
            return ReadType (module, br, context).__MakeArrayType (mods.required, mods.optional);
        case ELEMENT_TYPE_ARRAY :
            mods = ReadCustomModifiers (module, br, context);
            return ReadType (module, br, context).__MakeArrayType (ReadArrayShape (br), mods.required, mods.optional);
        case ELEMENT_TYPE_PTR :
            mods = ReadCustomModifiers (module, br, context);
            return ReadTypeOrVoid (module, br, context).__MakePointerType (mods.required, mods.optional);
        case ELEMENT_TYPE_FNPTR :
            return ReadFunctionPointer (module, br, context);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="244" endline="272">
internal static void ReadLocalVarSig (ModuleReader module, ByteReader br, IGenericContext context, List < LocalVariableInfo > list) {
    if (br.Length < 2 || br.ReadByte () != LOCAL_SIG) {
        throw new BadImageFormatException ("Invalid local variable signature");
    }
    int count = br.ReadCompressedInt ();
    for (int i = 0; i < count; i ++) {
        if (br.PeekByte () == ELEMENT_TYPE_TYPEDBYREF) {
            br.ReadByte ();
            list.Add (new LocalVariableInfo (i, module.universe.System_TypedReference, false));
        } else {
            SkipCustomModifiers (br);
            bool pinned = false;
            if (br.PeekByte () == ELEMENT_TYPE_PINNED) {
                br.ReadByte ();
                pinned = true;
            }
            SkipCustomModifiers (br);
            Type type = ReadTypeOrByRef (module, br, context);
            list.Add (new LocalVariableInfo (i, type, pinned));
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="274" endline="289">
private static Type ReadTypeOrByRef (ModuleReader module, ByteReader br, IGenericContext context) {
    if (br.PeekByte () == ELEMENT_TYPE_BYREF) {
        br.ReadByte ();
        CustomModifiers mods = ReadCustomModifiers (module, br, context);
        return ReadTypeOrVoid (module, br, context).__MakeByRefType (mods.required, mods.optional);
    } else {
        return ReadType (module, br, context);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="291" endline="304">
protected static Type ReadRetType (ModuleReader module, ByteReader br, IGenericContext context) {
    switch (br.PeekByte ()) {
        case ELEMENT_TYPE_VOID :
            br.ReadByte ();
            return module.universe.System_Void;
        case ELEMENT_TYPE_TYPEDBYREF :
            br.ReadByte ();
            return module.universe.System_TypedReference;
        default :
            return ReadTypeOrByRef (module, br, context);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="306" endline="316">
protected static Type ReadParam (ModuleReader module, ByteReader br, IGenericContext context) {
    switch (br.PeekByte ()) {
        case ELEMENT_TYPE_TYPEDBYREF :
            br.ReadByte ();
            return module.universe.System_TypedReference;
        default :
            return ReadTypeOrByRef (module, br, context);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="318" endline="459">
protected static void WriteType (ModuleBuilder module, ByteBuffer bb, Type type) {
    while (type.HasElementType) {
        if (type.__IsVector) {
            bb.Write (ELEMENT_TYPE_SZARRAY);
        } else if (type.IsArray) {
            int rank = type.GetArrayRank ();
            bb.Write (ELEMENT_TYPE_ARRAY);
            WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_REQD, type.__GetRequiredCustomModifiers ());
            WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_OPT, type.__GetOptionalCustomModifiers ());
            WriteType (module, bb, type.GetElementType ());
            bb.WriteCompressedInt (rank);
            bb.WriteCompressedInt (0);
            bb.WriteCompressedInt (rank);
            for (int i = 0; i < rank; i ++) {
                bb.WriteCompressedInt (0);
            }
            return;
        } else if (type.IsByRef) {
            bb.Write (ELEMENT_TYPE_BYREF);
        } else if (type.IsPointer) {
            bb.Write (ELEMENT_TYPE_PTR);
        }
        WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_REQD, type.__GetRequiredCustomModifiers ());
        WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_OPT, type.__GetOptionalCustomModifiers ());
        type = type.GetElementType ();
    }
    Universe u = module.universe;
    if (type == u.System_Void) {
        bb.Write (ELEMENT_TYPE_VOID);
    } else if (type == u.System_Boolean) {
        bb.Write (ELEMENT_TYPE_BOOLEAN);
    } else if (type == u.System_Char) {
        bb.Write (ELEMENT_TYPE_CHAR);
    } else if (type == u.System_SByte) {
        bb.Write (ELEMENT_TYPE_I1);
    } else if (type == u.System_Byte) {
        bb.Write (ELEMENT_TYPE_U1);
    } else if (type == u.System_Int16) {
        bb.Write (ELEMENT_TYPE_I2);
    } else if (type == u.System_UInt16) {
        bb.Write (ELEMENT_TYPE_U2);
    } else if (type == u.System_Int32) {
        bb.Write (ELEMENT_TYPE_I4);
    } else if (type == u.System_UInt32) {
        bb.Write (ELEMENT_TYPE_U4);
    } else if (type == u.System_Int64) {
        bb.Write (ELEMENT_TYPE_I8);
    } else if (type == u.System_UInt64) {
        bb.Write (ELEMENT_TYPE_U8);
    } else if (type == u.System_Single) {
        bb.Write (ELEMENT_TYPE_R4);
    } else if (type == u.System_Double) {
        bb.Write (ELEMENT_TYPE_R8);
    } else if (type == u.System_String) {
        bb.Write (ELEMENT_TYPE_STRING);
    } else if (type == u.System_IntPtr) {
        bb.Write (ELEMENT_TYPE_I);
    } else if (type == u.System_UIntPtr) {
        bb.Write (ELEMENT_TYPE_U);
    } else if (type == u.System_TypedReference) {
        bb.Write (ELEMENT_TYPE_TYPEDBYREF);
    } else if (type == u.System_Object) {
        bb.Write (ELEMENT_TYPE_OBJECT);
    } else if (type.IsGenericParameter) {
        if (type is UnboundGenericMethodParameter || type.DeclaringMethod != null) {
            bb.Write (ELEMENT_TYPE_MVAR);
        } else {
            bb.Write (ELEMENT_TYPE_VAR);
        }
        bb.WriteCompressedInt (type.GenericParameterPosition);
    } else if (type.IsGenericType) {
        WriteGenericSignature (module, bb, type);
    } else {
        if (type.IsValueType) {
            bb.Write (ELEMENT_TYPE_VALUETYPE);
        } else {
            bb.Write (ELEMENT_TYPE_CLASS);
        }
        bb.WriteTypeDefOrRefEncoded (module.GetTypeToken (type).Token);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="461" endline="487">
private static void WriteGenericSignature (ModuleBuilder module, ByteBuffer bb, Type type) {
    Type [] typeArguments = type.GetGenericArguments ();
    Type [] [] requiredCustomModifiers = type.__GetGenericArgumentsRequiredCustomModifiers ();
    Type [] [] optionalCustomModifiers = type.__GetGenericArgumentsOptionalCustomModifiers ();
    if (! type.IsGenericTypeDefinition) {
        type = type.GetGenericTypeDefinition ();
    }
    bb.Write (ELEMENT_TYPE_GENERICINST);
    if (type.IsValueType) {
        bb.Write (ELEMENT_TYPE_VALUETYPE);
    } else {
        bb.Write (ELEMENT_TYPE_CLASS);
    }
    bb.WriteTypeDefOrRefEncoded (module.GetTypeToken (type).Token);
    bb.WriteCompressedInt (typeArguments.Length);
    for (int i = 0; i < typeArguments.Length; i ++) {
        WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers [i]);
        WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers [i]);
        WriteType (module, bb, typeArguments [i]);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="489" endline="499">
protected static void WriteCustomModifiers (ModuleBuilder module, ByteBuffer bb, byte mod, Type [] modifiers) {
    if (modifiers != null) {
        foreach (Type type in modifiers) {
            bb.Write (mod);
            bb.WriteTypeDefOrRefEncoded (module.GetTypeTokenForMemberRef (type));
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="501" endline="504">
protected static bool IsCustomModifier (byte b) {
    return b == ELEMENT_TYPE_CMOD_OPT || b == ELEMENT_TYPE_CMOD_REQD;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="512" endline="531">
private static CustomModifiers ReadCustomModifiers (ModuleReader module, ByteReader br, IGenericContext context) {
    CustomModifiers mods = new CustomModifiers ();
    byte b = br.PeekByte ();
    if (IsCustomModifier (b)) {
        List < Type > required = new List < Type > ();
        List < Type > optional = new List < Type > ();
        while (IsCustomModifier (b)) {
            bool req = br.ReadByte () == ELEMENT_TYPE_CMOD_REQD;
            Type type = ReadTypeDefOrRefEncoded (module, br, context);
            (req ? required : optional).Add (type);
            b = br.PeekByte ();
        }
        mods.required = required.ToArray ();
        mods.optional = optional.ToArray ();
    }
    return mods;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="533" endline="542">
protected static void SkipCustomModifiers (ByteReader br) {
    byte b = br.PeekByte ();
    while (IsCustomModifier (b)) {
        br.ReadByte ();
        br.ReadCompressedInt ();
        b = br.PeekByte ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="544" endline="558">
private static Type ReadTypeDefOrRefEncoded (ModuleReader module, ByteReader br, IGenericContext context) {
    int encoded = br.ReadCompressedInt ();
    switch (encoded & 3) {
        case 0 :
            return module.ResolveType ((TypeDefTable.Index << 24) + (encoded > > 2), null, null);
        case 1 :
            return module.ResolveType ((TypeRefTable.Index << 24) + (encoded > > 2), null, null);
        case 2 :
            return module.ResolveType ((TypeSpecTable.Index << 24) + (encoded > > 2), context);
        default :
            throw new BadImageFormatException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="560" endline="589">
protected static void ReadCustomModifiers (ModuleReader module, ByteReader br, IGenericContext context, out Type [] requiredCustomModifiers, out Type [] optionalCustomModifiers) {
    byte b = br.PeekByte ();
    if (IsCustomModifier (b)) {
        List < Type > required = new List < Type > ();
        List < Type > optional = new List < Type > ();
        while (IsCustomModifier (b)) {
            br.ReadByte ();
            Type type = ReadTypeDefOrRefEncoded (module, br, context);
            if (b == ELEMENT_TYPE_CMOD_REQD) {
                required.Add (type);
            } else {
                optional.Add (type);
            }
            b = br.PeekByte ();
        }
        requiredCustomModifiers = required.ToArray ();
        optionalCustomModifiers = optional.ToArray ();
    } else {
        requiredCustomModifiers = null;
        optionalCustomModifiers = null;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="592" endline="618">
internal static void WriteStandAloneMethodSig (ModuleBuilder module, ByteBuffer bb, CallingConvention callingConvention, Type returnType, Type [] parameterTypes) {
    switch (callingConvention) {
        case CallingConvention.Cdecl :
            bb.Write ((byte) 0x01);
            break;
        case CallingConvention.StdCall : case CallingConvention.Winapi :
            bb.Write ((byte) 0x02);
            break;
        case CallingConvention.ThisCall :
            bb.Write ((byte) 0x03);
            break;
        case CallingConvention.FastCall :
            bb.Write ((byte) 0x04);
            break;
        default :
            throw new ArgumentOutOfRangeException ("callingConvention");
    }
    bb.WriteCompressedInt (parameterTypes.Length);
    WriteType (module, bb, returnType);
    foreach (Type t in parameterTypes) {
        WriteType (module, bb, t);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="621" endline="651">
internal static void WriteStandAloneMethodSig (ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention, Type returnType, Type [] parameterTypes, Type [] optionalParameterTypes) {
    byte flags = 0;
    if ((callingConvention & CallingConventions.HasThis) != 0) {
        flags |= HASTHIS;
    }
    if ((callingConvention & CallingConventions.ExplicitThis) != 0) {
        flags |= EXPLICITTHIS;
    }
    if ((callingConvention & CallingConventions.VarArgs) != 0) {
        flags |= VARARG;
    }
    bb.Write (flags);
    bb.WriteCompressedInt (parameterTypes.Length + optionalParameterTypes.Length);
    WriteType (module, bb, returnType);
    foreach (Type t in parameterTypes) {
        WriteType (module, bb, t);
    }
    if (optionalParameterTypes.Length > 0) {
        bb.Write (SENTINEL);
        foreach (Type t in optionalParameterTypes) {
            WriteType (module, bb, t);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="653" endline="665">
internal static void WriteLocalVarSig (ModuleBuilder module, ByteBuffer bb, IList < LocalBuilder > locals) {
    bb.Write (LOCAL_SIG);
    bb.WriteCompressedInt (locals.Count);
    foreach (LocalBuilder local in locals) {
        if (local.IsPinned) {
            bb.Write (ELEMENT_TYPE_PINNED);
        }
        WriteType (module, bb, local.LocalType);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="667" endline="704">
internal static void WritePropertySig (ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention, Type returnType, Type [] returnTypeRequiredCustomModifiers, Type [] returnTypeOptionalCustomModifiers, Type [] parameterTypes, Type [] [] parameterTypeRequiredCustomModifiers, Type [] [] parameterTypeOptionalCustomModifiers) {
    byte flags = PROPERTY;
    if ((callingConvention & CallingConventions.HasThis) != 0) {
        flags |= HASTHIS;
    }
    if ((callingConvention & CallingConventions.ExplicitThis) != 0) {
        flags |= EXPLICITTHIS;
    }
    if ((callingConvention & CallingConventions.VarArgs) != 0) {
        flags |= VARARG;
    }
    bb.Write (flags);
    bb.WriteCompressedInt (parameterTypes == null ? 0 : parameterTypes.Length);
    WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_REQD, returnTypeRequiredCustomModifiers);
    WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_OPT, returnTypeOptionalCustomModifiers);
    WriteType (module, bb, returnType);
    if (parameterTypes != null) {
        for (int i = 0; i < parameterTypes.Length; i ++) {
            if (parameterTypeRequiredCustomModifiers != null) {
                WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers [i]);
            }
            if (parameterTypeOptionalCustomModifiers != null) {
                WriteCustomModifiers (module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers [i]);
            }
            WriteType (module, bb, parameterTypes [i]);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="706" endline="709">
internal static void WriteTypeSpec (ModuleBuilder module, ByteBuffer bb, Type type) {
    WriteType (module, bb, type);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="711" endline="719">
internal static void WriteMethodSpec (ModuleBuilder module, ByteBuffer bb, Type [] genArgs) {
    bb.Write (GENERICINST);
    bb.WriteCompressedInt (genArgs.Length);
    foreach (Type arg in genArgs) {
        WriteType (module, bb, arg);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="722" endline="745">
internal static Type [] ReadOptionalParameterTypes (ModuleReader module, ByteReader br) {
    br.ReadByte ();
    int paramCount = br.ReadCompressedInt ();
    SkipCustomModifiers (br);
    ReadRetType (module, br, null);
    for (int i = 0; i < paramCount; i ++) {
        if (br.PeekByte () == SENTINEL) {
            br.ReadByte ();
            Type [] types = new Type [paramCount - i];
            for (int j = 0; j < types.Length; j ++) {
                SkipCustomModifiers (br);
                types [j] = ReadType (module, br, null);
            }
            return types;
        }
        SkipCustomModifiers (br);
        ReadType (module, br, null);
    }
    return Type.EmptyTypes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="747" endline="759">
protected static Type [] BindTypeParameters (IGenericBinder binder, Type [] types) {
    if (types == null || types.Length == 0) {
        return Type.EmptyTypes;
    }
    Type [] expanded = new Type [types.Length];
    for (int i = 0; i < types.Length; i ++) {
        expanded [i] = types [i].BindTypeParameters (binder);
    }
    return expanded;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="761" endline="773">
protected static Type [] [] BindTypeParameters (IGenericBinder binder, Type [] [] types) {
    if (types == null) {
        return null;
    }
    Type [] [] expanded = new Type [types.Length] [];
    for (int i = 0; i < types.Length; i ++) {
        expanded [i] = BindTypeParameters (binder, types [i]);
    }
    return expanded;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="775" endline="787">
protected static Type [] [] [] BindTypeParameters (IGenericBinder binder, Type [] [] [] types) {
    if (types == null) {
        return null;
    }
    Type [] [] [] expanded = new Type [types.Length] [] [];
    for (int i = 0; i < types.Length; i ++) {
        expanded [i] = BindTypeParameters (binder, types [i]);
    }
    return expanded;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Signature.cs.ifdefed" startline="789" endline="796">
protected static Type [] BindTypeParameters (IGenericBinder binder, Type [] [] [] types, int index, int optOrReq) {
    if (types == null || types [index] == null) {
        return null;
    }
    return BindTypeParameters (binder, types [index] [optOrReq]);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="74" endline="77">
public virtual Type GetElementType () {
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="79" endline="81">
internal virtual void CheckBaked () {
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="83" endline="86">
public virtual Type [] __GetDeclaredTypes () {
    return Type.EmptyTypes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="88" endline="91">
public virtual Type [] __GetDeclaredInterfaces () {
    return Type.EmptyTypes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="93" endline="96">
public virtual MethodBase [] __GetDeclaredMethods () {
    return Empty < MethodBase >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="98" endline="101">
public virtual __MethodImplMap __GetMethodImplMap () {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="103" endline="106">
public virtual FieldInfo [] __GetDeclaredFields () {
    return Empty < FieldInfo >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="108" endline="111">
public virtual EventInfo [] __GetDeclaredEvents () {
    return Empty < EventInfo >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="113" endline="116">
public virtual PropertyInfo [] __GetDeclaredProperties () {
    return Empty < PropertyInfo >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="118" endline="121">
public virtual Type [] __GetRequiredCustomModifiers () {
    return Type.EmptyTypes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="123" endline="126">
public virtual Type [] __GetOptionalCustomModifiers () {
    return Type.EmptyTypes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="211" endline="214">
internal virtual int GetModuleBuilderToken () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="216" endline="219">
public bool Equals (Type type) {
    return ! ReferenceEquals (type, null) && ReferenceEquals (type.UnderlyingSystemType, this.UnderlyingSystemType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="221" endline="224">
public override bool Equals (object obj) {
    return Equals (obj as Type);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="226" endline="230">
public override int GetHashCode () {
    Type type = this.UnderlyingSystemType;
    return ReferenceEquals (type, this) ? base.GetHashCode () : type.GetHashCode ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="232" endline="235">
public virtual Type [] GetGenericArguments () {
    return Type.EmptyTypes;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="237" endline="240">
public virtual Type [] [] __GetGenericArgumentsRequiredCustomModifiers () {
    return Empty < Type [] >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="242" endline="245">
public virtual Type [] [] __GetGenericArgumentsOptionalCustomModifiers () {
    return Empty < Type [] >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="247" endline="250">
public virtual Type GetGenericTypeDefinition () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="286" endline="289">
public virtual Type [] GetGenericParameterConstraints () {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="296" endline="299">
public virtual int GetArrayRank () {
    throw new NotSupportedException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="302" endline="310">
public virtual Type GetEnumUnderlyingType () {
    if (! this.IsEnum) {
        throw new ArgumentException ();
    }
    CheckBaked ();
    return GetEnumUnderlyingTypeImpl ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="312" endline="323">
internal Type GetEnumUnderlyingTypeImpl () {
    foreach (FieldInfo field in __GetDeclaredFields ()) {
        if (! field.IsStatic) {
            return field.FieldType;
        }
    }
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="325" endline="328">
public override string ToString () {
    return FullName;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="366" endline="369">
internal virtual Type GetGenericTypeArgument (int index) {
    throw new InvalidOperationException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="371" endline="382">
public MemberInfo [] GetDefaultMembers () {
    Type defaultMemberAttribute = this.Module.universe.Import (typeof (System.Reflection.DefaultMemberAttribute));
    foreach (CustomAttributeData cad in CustomAttributeData.GetCustomAttributes (this)) {
        if (cad.Constructor.DeclaringType.Equals (defaultMemberAttribute)) {
            return GetMember ((string) cad.ConstructorArguments [0].Value);
        }
    }
    return Empty < MemberInfo >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="384" endline="387">
public MemberInfo [] GetMember (string name) {
    return GetMember (name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="389" endline="392">
public MemberInfo [] GetMember (string name, BindingFlags bindingAttr) {
    return GetMember (name, MemberTypes.All, bindingAttr);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="394" endline="397">
public MemberInfo [] GetMembers () {
    return GetMembers (BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="399" endline="409">
public MemberInfo [] GetMembers (BindingFlags bindingAttr) {
    List < MemberInfo > members = new List < MemberInfo > ();
    members.AddRange (GetConstructors (bindingAttr));
    members.AddRange (GetMethods (bindingAttr));
    members.AddRange (GetFields (bindingAttr));
    members.AddRange (GetProperties (bindingAttr));
    members.AddRange (GetEvents (bindingAttr));
    members.AddRange (GetNestedTypes (bindingAttr));
    return members.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="411" endline="415">
public MemberInfo [] GetMember (string name, MemberTypes type, BindingFlags bindingAttr) {
    MemberFilter filter = delegate (MemberInfo member, object filterCriteria) {
        return member.Name.Equals (filterCriteria);
    };
    return FindMembers (type, bindingAttr, filter, name);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="417" endline="426">
private static void AddMembers (List < MemberInfo > list, MemberFilter filter, object filterCriteria, MemberInfo [] members) {
    foreach (MemberInfo member in members) {
        if (filter == null || filter (member, filterCriteria)) {
            list.Add (member);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="428" endline="456">
public MemberInfo [] FindMembers (MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria) {
    List < MemberInfo > members = new List < MemberInfo > ();
    if ((memberType & MemberTypes.Constructor) != 0) {
        AddMembers (members, filter, filterCriteria, GetConstructors (bindingAttr));
    }
    if ((memberType & MemberTypes.Method) != 0) {
        AddMembers (members, filter, filterCriteria, GetMethods (bindingAttr));
    }
    if ((memberType & MemberTypes.Field) != 0) {
        AddMembers (members, filter, filterCriteria, GetFields (bindingAttr));
    }
    if ((memberType & MemberTypes.Property) != 0) {
        AddMembers (members, filter, filterCriteria, GetProperties (bindingAttr));
    }
    if ((memberType & MemberTypes.Event) != 0) {
        AddMembers (members, filter, filterCriteria, GetEvents (bindingAttr));
    }
    if ((memberType & MemberTypes.NestedType) != 0) {
        AddMembers (members, filter, filterCriteria, GetNestedTypes (bindingAttr));
    }
    return members.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="458" endline="461">
public EventInfo GetEvent (string name) {
    return GetEvent (name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="463" endline="473">
public EventInfo GetEvent (string name, BindingFlags bindingAttr) {
    foreach (EventInfo evt in GetEvents (bindingAttr)) {
        if (evt.Name == name) {
            return evt;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="475" endline="478">
public EventInfo [] GetEvents () {
    return GetEvents (BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="480" endline="509">
public EventInfo [] GetEvents (BindingFlags bindingAttr) {
    List < EventInfo > list = new List < EventInfo > ();
    Type type = this;
    while (type != null) {
        type.CheckBaked ();
        foreach (EventInfo evt in type.__GetDeclaredEvents ()) {
            if (BindingFlagsMatch (evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic) && BindingFlagsMatch (evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance)) {
                list.Add (evt);
            }
        }
        if ((bindingAttr & BindingFlags.DeclaredOnly) == 0) {
            if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0) {
                bindingAttr &= ~ BindingFlags.Static;
            }
            type = type.BaseType;
        } else {
            break;
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="511" endline="514">
public FieldInfo GetField (string name) {
    return GetField (name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="516" endline="526">
public FieldInfo GetField (string name, BindingFlags bindingAttr) {
    foreach (FieldInfo field in GetFields (bindingAttr)) {
        if (field.Name == name) {
            return field;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="528" endline="531">
public FieldInfo [] GetFields () {
    return GetFields (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="533" endline="561">
public FieldInfo [] GetFields (BindingFlags bindingAttr) {
    List < FieldInfo > list = new List < FieldInfo > ();
    CheckBaked ();
    foreach (FieldInfo field in __GetDeclaredFields ()) {
        if (BindingFlagsMatch (field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic) && BindingFlagsMatch (field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance)) {
            list.Add (field);
        }
    }
    if ((bindingAttr & BindingFlags.DeclaredOnly) == 0) {
        for (Type type = this.BaseType; type != null; type = type.BaseType) {
            type.CheckBaked ();
            foreach (FieldInfo field in type.__GetDeclaredFields ()) {
                if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private && BindingFlagsMatch (field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)) {
                    list.Add (field);
                }
            }
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="563" endline="571">
public Type [] GetInterfaces () {
    List < Type > list = new List < Type > ();
    for (Type type = this; type != null; type = type.BaseType) {
        AddInterfaces (list, type);
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="573" endline="584">
private static void AddInterfaces (List < Type > list, Type type) {
    type.CheckBaked ();
    foreach (Type iface in type.__GetDeclaredInterfaces ()) {
        if (! list.Contains (iface)) {
            list.Add (iface);
            AddInterfaces (list, iface);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="586" endline="620">
public MethodInfo [] GetMethods (BindingFlags bindingAttr) {
    CheckBaked ();
    List < MethodInfo > list = new List < MethodInfo > ();
    foreach (MethodBase mb in __GetDeclaredMethods ()) {
        MethodInfo mi = mb as MethodInfo;
        if (mi != null && BindingFlagsMatch (mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic) && BindingFlagsMatch (mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance)) {
            list.Add (mi);
        }
    }
    if ((bindingAttr & BindingFlags.DeclaredOnly) == 0) {
        for (Type type = this.BaseType; type != null; type = type.BaseType) {
            type.CheckBaked ();
            foreach (MethodBase mb in type.__GetDeclaredMethods ()) {
                MethodInfo mi = mb as MethodInfo;
                if (mi != null && (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private && BindingFlagsMatch (mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic) && BindingFlagsMatch (mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance) && ! FindMethod (list, mi)) {
                    list.Add (mi);
                }
            }
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="622" endline="632">
private static bool FindMethod (List < MethodInfo > methods, MethodInfo method) {
    foreach (MethodInfo m in methods) {
        if (m.Name == method.Name && m.MethodSignature.Equals (method.MethodSignature)) {
            return true;
        }
    }
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="634" endline="637">
public MethodInfo [] GetMethods () {
    return GetMethods (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="639" endline="642">
public MethodInfo GetMethod (string name) {
    return GetMethod (name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="644" endline="659">
public MethodInfo GetMethod (string name, BindingFlags bindingAttr) {
    MethodInfo found = null;
    foreach (MethodInfo method in GetMethods (bindingAttr)) {
        if (method.Name == name) {
            if (found != null) {
                throw new AmbiguousMatchException ();
            }
            found = method;
        }
    }
    return found;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="661" endline="664">
public MethodInfo GetMethod (string name, Type [] types) {
    return GetMethod (name, types, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="666" endline="669">
public MethodInfo GetMethod (string name, Type [] types, ParameterModifier [] modifiers) {
    return GetMethod (name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public, null, types, modifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="671" endline="686">
public MethodInfo GetMethod (string name, BindingFlags bindingAttr, Binder binder, Type [] types, ParameterModifier [] modifiers) {
    MethodInfo found = null;
    foreach (MethodInfo method in GetMethods (bindingAttr)) {
        if (method.Name == name && method.MethodSignature.MatchParameterTypes (types)) {
            if (found != null) {
                throw new AmbiguousMatchException ();
            }
            found = method;
        }
    }
    return found;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="688" endline="692">
public MethodInfo GetMethod (string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type [] types, ParameterModifier [] modifiers) {
    return GetMethod (name, bindingAttr, binder, types, modifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="694" endline="697">
public ConstructorInfo [] GetConstructors () {
    return GetConstructors (BindingFlags.Public | BindingFlags.Instance);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="699" endline="714">
public ConstructorInfo [] GetConstructors (BindingFlags bindingAttr) {
    CheckBaked ();
    List < ConstructorInfo > list = new List < ConstructorInfo > ();
    foreach (MethodBase mb in __GetDeclaredMethods ()) {
        ConstructorInfo constructor = mb as ConstructorInfo;
        if (constructor != null && BindingFlagsMatch (constructor.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic) && BindingFlagsMatch (constructor.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance)) {
            list.Add (constructor);
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="716" endline="719">
public ConstructorInfo GetConstructor (Type [] types) {
    return GetConstructor (BindingFlags.Public | BindingFlags.Instance, null, CallingConventions.Standard, types, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="721" endline="731">
public ConstructorInfo GetConstructor (BindingFlags bindingAttr, Binder binder, Type [] types, ParameterModifier [] modifiers) {
    foreach (ConstructorInfo constructor in GetConstructors (bindingAttr)) {
        if (constructor.MethodSignature.MatchParameterTypes (types)) {
            return constructor;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="733" endline="737">
public ConstructorInfo GetConstructor (BindingFlags bindingAttr, Binder binder, CallingConventions callingConvention, Type [] types, ParameterModifier [] modifiers) {
    return GetConstructor (bindingAttr, binder, types, modifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="739" endline="742">
public Type GetNestedType (string name) {
    return GetNestedType (name, BindingFlags.Public);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="744" endline="754">
public virtual Type GetNestedType (string name, BindingFlags bindingAttr) {
    foreach (Type type in GetNestedTypes (bindingAttr)) {
        if (type.Name == name) {
            return type;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="756" endline="759">
public Type [] GetNestedTypes () {
    return GetNestedTypes (BindingFlags.Public);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="761" endline="773">
public Type [] GetNestedTypes (BindingFlags bindingAttr) {
    CheckBaked ();
    List < Type > list = new List < Type > ();
    foreach (Type type in __GetDeclaredTypes ()) {
        if (BindingFlagsMatch (type.IsNestedPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)) {
            list.Add (type);
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="775" endline="778">
public PropertyInfo [] GetProperties () {
    return GetProperties (BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="780" endline="809">
public PropertyInfo [] GetProperties (BindingFlags bindingAttr) {
    List < PropertyInfo > list = new List < PropertyInfo > ();
    Type type = this;
    while (type != null) {
        type.CheckBaked ();
        foreach (PropertyInfo property in type.__GetDeclaredProperties ()) {
            if (BindingFlagsMatch (property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic) && BindingFlagsMatch (property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance)) {
                list.Add (property);
            }
        }
        if ((bindingAttr & BindingFlags.DeclaredOnly) == 0) {
            if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0) {
                bindingAttr &= ~ BindingFlags.Static;
            }
            type = type.BaseType;
        } else {
            break;
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="811" endline="814">
public PropertyInfo GetProperty (string name) {
    return GetProperty (name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="816" endline="826">
public PropertyInfo GetProperty (string name, BindingFlags bindingAttr) {
    foreach (PropertyInfo prop in GetProperties (bindingAttr)) {
        if (prop.Name == name) {
            return prop;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="828" endline="843">
public PropertyInfo GetProperty (string name, Type returnType) {
    PropertyInfo found = null;
    foreach (PropertyInfo prop in GetProperties ()) {
        if (prop.Name == name && prop.PropertyType.Equals (returnType)) {
            if (found != null) {
                throw new AmbiguousMatchException ();
            }
            found = prop;
        }
    }
    return found;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="845" endline="860">
public PropertyInfo GetProperty (string name, Type [] types) {
    PropertyInfo found = null;
    foreach (PropertyInfo prop in GetProperties ()) {
        if (prop.Name == name && MatchParameterTypes (prop.GetIndexParameters (), types)) {
            if (found != null) {
                throw new AmbiguousMatchException ();
            }
            found = prop;
        }
    }
    return found;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="862" endline="876">
private static bool MatchParameterTypes (ParameterInfo [] parameters, Type [] types) {
    if (parameters.Length == types.Length) {
        for (int i = 0; i < parameters.Length; i ++) {
            if (! parameters [i].ParameterType.Equals (types [i])) {
                return false;
            }
        }
        return true;
    }
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="878" endline="881">
public PropertyInfo GetProperty (string name, Type returnType, Type [] types) {
    return GetProperty (name, returnType, types, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="883" endline="886">
public PropertyInfo GetProperty (string name, Type returnType, Type [] types, ParameterModifier [] modifiers) {
    return GetProperty (name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static, null, returnType, types, modifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="888" endline="903">
public PropertyInfo GetProperty (string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type [] types, ParameterModifier [] modifiers) {
    PropertyInfo found = null;
    foreach (PropertyInfo prop in GetProperties (bindingAttr)) {
        if (prop.Name == name && prop.PropertyType.Equals (returnType) && MatchParameterTypes (prop.GetIndexParameters (), types)) {
            if (found != null) {
                throw new AmbiguousMatchException ();
            }
            found = prop;
        }
    }
    return found;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="905" endline="908">
public Type GetInterface (string name) {
    return GetInterface (name, false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="910" endline="924">
public Type GetInterface (string name, bool ignoreCase) {
    if (ignoreCase) {
        throw new NotImplementedException ();
    }
    foreach (Type type in GetInterfaces ()) {
        if (type.FullName == name) {
            return type;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="926" endline="937">
public Type [] FindInterfaces (TypeFilter filter, object filterCriteria) {
    List < Type > list = new List < Type > ();
    foreach (Type type in GetInterfaces ()) {
        if (filter (type, filterCriteria)) {
            list.Add (type);
        }
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="982" endline="985">
private bool CheckVisibility (TypeAttributes access) {
    return (Attributes & TypeAttributes.VisibilityMask) == access;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1109" endline="1112">
public Type MakeArrayType () {
    return ArrayType.Make (this, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1114" endline="1117">
public Type __MakeArrayType (Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return ArrayType.Make (this, Util.Copy (requiredCustomModifiers), Util.Copy (optionalCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1119" endline="1122">
public Type MakeArrayType (int rank) {
    return MultiArrayType.Make (this, rank, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1124" endline="1127">
public Type __MakeArrayType (int rank, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return MultiArrayType.Make (this, rank, Util.Copy (requiredCustomModifiers), Util.Copy (optionalCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1129" endline="1132">
public Type MakeByRefType () {
    return ByRefType.Make (this, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1134" endline="1137">
public Type __MakeByRefType (Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return ByRefType.Make (this, Util.Copy (requiredCustomModifiers), Util.Copy (optionalCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1139" endline="1142">
public Type MakePointerType () {
    return PointerType.Make (this, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1144" endline="1147">
public Type __MakePointerType (Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return PointerType.Make (this, Util.Copy (requiredCustomModifiers), Util.Copy (optionalCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1149" endline="1152">
public Type MakeGenericType (params Type [] typeArguments) {
    return __MakeGenericType (typeArguments, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1154" endline="1161">
public Type __MakeGenericType (Type [] typeArguments, Type [] [] requiredCustomModifiers, Type [] [] optionalCustomModifiers) {
    if (! this.IsGenericTypeDefinition) {
        throw new InvalidOperationException ();
    }
    return GenericTypeInstance.Make (this, Util.Copy (typeArguments), Util.Copy (requiredCustomModifiers), Util.Copy (optionalCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1163" endline="1206">
public static System.Type __GetSystemType (TypeCode typeCode) {
    switch (typeCode) {
        case TypeCode.Boolean :
            return typeof (System.Boolean);
        case TypeCode.Byte :
            return typeof (System.Byte);
        case TypeCode.Char :
            return typeof (System.Char);
        case TypeCode.DBNull :
            return typeof (System.DBNull);
        case TypeCode.DateTime :
            return typeof (System.DateTime);
        case TypeCode.Decimal :
            return typeof (System.Decimal);
        case TypeCode.Double :
            return typeof (System.Double);
        case TypeCode.Empty :
            return null;
        case TypeCode.Int16 :
            return typeof (System.Int16);
        case TypeCode.Int32 :
            return typeof (System.Int32);
        case TypeCode.Int64 :
            return typeof (System.Int64);
        case TypeCode.Object :
            return typeof (System.Object);
        case TypeCode.SByte :
            return typeof (System.SByte);
        case TypeCode.Single :
            return typeof (System.Single);
        case TypeCode.String :
            return typeof (System.String);
        case TypeCode.UInt16 :
            return typeof (System.UInt16);
        case TypeCode.UInt32 :
            return typeof (System.UInt32);
        case TypeCode.UInt64 :
            return typeof (System.UInt64);
        default :
            throw new ArgumentOutOfRangeException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1208" endline="1287">
public static TypeCode GetTypeCode (Type type) {
    if (type == null) {
        return TypeCode.Empty;
    }
    if (type.IsEnum) {
        type = type.GetEnumUnderlyingType ();
    }
    Universe u = type.Module.universe;
    if (type == u.System_Boolean) {
        return TypeCode.Boolean;
    } else if (type == u.System_Char) {
        return TypeCode.Char;
    } else if (type == u.System_SByte) {
        return TypeCode.SByte;
    } else if (type == u.System_Byte) {
        return TypeCode.Byte;
    } else if (type == u.System_Int16) {
        return TypeCode.Int16;
    } else if (type == u.System_UInt16) {
        return TypeCode.UInt16;
    } else if (type == u.System_Int32) {
        return TypeCode.Int32;
    } else if (type == u.System_UInt32) {
        return TypeCode.UInt32;
    } else if (type == u.System_Int64) {
        return TypeCode.Int64;
    } else if (type == u.System_UInt64) {
        return TypeCode.UInt64;
    } else if (type == u.System_Single) {
        return TypeCode.Single;
    } else if (type == u.System_Double) {
        return TypeCode.Double;
    } else if (type == u.System_DateTime) {
        return TypeCode.DateTime;
    } else if (type == u.System_DBNull) {
        return TypeCode.DBNull;
    } else if (type == u.System_Decimal) {
        return TypeCode.Decimal;
    } else if (type == u.System_String) {
        return TypeCode.String;
    } else {
        return TypeCode.Object;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1295" endline="1339">
public bool IsAssignableFrom (Type type) {
    if (this.Equals (type)) {
        return true;
    } else if (type == null) {
        return false;
    } else if (this.IsArray && type.IsArray) {
        if (this.GetArrayRank () != type.GetArrayRank ()) {
            return false;
        } else if (this.__IsVector && ! type.__IsVector) {
            return false;
        }
        Type e1 = this.GetElementType ();
        Type e2 = type.GetElementType ();
        return e1.IsValueType == e2.IsValueType && e1.IsAssignableFrom (e2);
    } else if (this.IsSealed) {
        return false;
    } else if (this.IsInterface) {
        return Array.IndexOf (type.GetInterfaces (), this) != - 1;
    } else if (type.IsInterface) {
        return this == this.Module.universe.System_Object;
    } else if (type.IsPointer) {
        return this == this.Module.universe.System_Object || this == this.Module.universe.System_ValueType;
    } else {
        return type.IsSubclassOf (this);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1341" endline="1353">
public bool IsSubclassOf (Type type) {
    Type thisType = this.BaseType;
    while (thisType != null) {
        if (thisType.Equals (type)) {
            return true;
        }
        thisType = thisType.BaseType;
    }
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1357" endline="1367">
private bool IsDirectlyImplementedInterface (Type interfaceType) {
    foreach (Type iface in __GetDeclaredInterfaces ()) {
        if (interfaceType.IsAssignableFrom (iface)) {
            return true;
        }
    }
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1369" endline="1414">
public InterfaceMapping GetInterfaceMap (Type interfaceType) {
    CheckBaked ();
    InterfaceMapping map = new InterfaceMapping ();
    if (! IsDirectlyImplementedInterface (interfaceType)) {
        Type baseType = this.BaseType;
        if (baseType == null) {
            throw new ArgumentException ();
        } else {
            map = baseType.GetInterfaceMap (interfaceType);
        }
    } else {
        map.InterfaceMethods = interfaceType.GetMethods (BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
        map.InterfaceType = interfaceType;
        map.TargetMethods = new MethodInfo [map.InterfaceMethods.Length];
        FillInExplicitInterfaceMethods (map.InterfaceMethods, map.TargetMethods);
        MethodInfo [] methods = GetMethods (BindingFlags.Instance | BindingFlags.Public);
        for (int i = 0; i < map.TargetMethods.Length; i ++) {
            if (map.TargetMethods [i] == null) {
                for (int j = 0; j < methods.Length; j ++) {
                    if (methods [j].Name == map.InterfaceMethods [i].Name && methods [j].MethodSignature.Equals (map.InterfaceMethods [i].MethodSignature)) {
                        map.TargetMethods [i] = methods [j];
                    }
                }
            }
        }
        for (Type baseType = this.BaseType; baseType != null && interfaceType.IsAssignableFrom (baseType); baseType = baseType.BaseType) {
            baseType.FillInExplicitInterfaceMethods (map.InterfaceMethods, map.TargetMethods);
        }
    }
    map.TargetType = this;
    return map;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1416" endline="1430">
internal void FillInExplicitInterfaceMethods (MethodInfo [] interfaceMethods, MethodInfo [] targetMethods) {
    __MethodImplMap impl = __GetMethodImplMap ();
    for (int i = 0; i < impl.MethodDeclarations.Length; i ++) {
        for (int j = 0; j < impl.MethodDeclarations [i].Length; j ++) {
            int index = Array.IndexOf (interfaceMethods, impl.MethodDeclarations [i] [j]);
            if (index != - 1 && targetMethods [index] == null) {
                targetMethods [index] = impl.MethodBodies [i];
            }
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1432" endline="1435">
Type IGenericContext.GetGenericTypeArgument (int index) {
    return GetGenericTypeArgument (index);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1437" endline="1440">
Type IGenericContext.GetGenericMethodArgument (int index) {
    throw new BadImageFormatException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1442" endline="1445">
Type IGenericBinder.BindTypeParameter (Type type) {
    return GetGenericTypeArgument (type.GenericParameterPosition);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1447" endline="1450">
Type IGenericBinder.BindMethodParameter (Type type) {
    throw new BadImageFormatException ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1452" endline="1464">
internal virtual Type BindTypeParameters (IGenericBinder binder) {
    if (IsGenericTypeDefinition) {
        Type [] args = GetGenericArguments ();
        Type.InplaceBindTypeParameters (binder, args);
        return GenericTypeInstance.Make (this, args, null, null);
    } else {
        return this;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1466" endline="1472">
internal static void InplaceBindTypeParameters (IGenericBinder binder, Type [] types) {
    for (int i = 0; i < types.Length; i ++) {
        types [i] = types [i].BindTypeParameters (binder);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1474" endline="1484">
internal MethodBase FindMethod (string name, MethodSignature signature) {
    foreach (MethodBase method in __GetDeclaredMethods ()) {
        if (method.Name == name && method.MethodSignature.Equals (signature)) {
            return method;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1486" endline="1496">
internal FieldInfo FindField (string name, FieldSignature signature) {
    foreach (FieldInfo field in __GetDeclaredFields ()) {
        if (field.Name == name && field.FieldSignature.Equals (signature)) {
            return field;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1554" endline="1560">
protected bool EqualsHelper (ElementHolderType other) {
    return other != null && other.elementType.Equals (elementType) && Util.ArrayEquals (other.requiredCustomModifiers, requiredCustomModifiers) && Util.ArrayEquals (other.optionalCustomModifiers, optionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1562" endline="1565">
public override Type [] __GetRequiredCustomModifiers () {
    return Util.Copy (requiredCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1567" endline="1570">
public override Type [] __GetOptionalCustomModifiers () {
    return Util.Copy (optionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1582" endline="1585">
public sealed override string ToString () {
    return elementType.ToString () + GetSuffix ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1587" endline="1590">
public sealed override Type GetElementType () {
    return elementType;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1602" endline="1609">
internal sealed override int GetModuleBuilderToken () {
    if (token == 0) {
        token = ((ModuleBuilder) elementType.Module).ImportType (this);
    }
    return token;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1624" endline="1636">
internal sealed override Type BindTypeParameters (IGenericBinder binder) {
    Type type = elementType.BindTypeParameters (binder);
    Type [] req = BindArray (requiredCustomModifiers, binder);
    Type [] opt = BindArray (optionalCustomModifiers, binder);
    if (ReferenceEquals (type, elementType) && ReferenceEquals (req, requiredCustomModifiers) && ReferenceEquals (opt, optionalCustomModifiers)) {
        return this;
    }
    return Wrap (type, req, opt);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1638" endline="1641">
internal override void CheckBaked () {
    elementType.CheckBaked ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1643" endline="1663">
private static Type [] BindArray (Type [] array, IGenericBinder binder) {
    if (array == null || array.Length == 0) {
        return array;
    }
    Type [] result = array;
    for (int i = 0; i < array.Length; i ++) {
        Type type = array [i].BindTypeParameters (binder);
        if (! ReferenceEquals (type, array [i])) {
            if (result == array) {
                result = (Type []) array.Clone ();
            }
            result [i] = type;
        }
    }
    return result;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1665" endline="1668">
internal sealed override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    return CustomAttributeData.EmptyList;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1677" endline="1680">
internal static Type Make (Type type, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return type.Module.CanonicalizeType (new ArrayType (type, requiredCustomModifiers, optionalCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1692" endline="1699">
public override Type [] __GetDeclaredInterfaces () {
    return new Type [] {this.Module.universe.Import (typeof (IList < >)).MakeGenericType (elementType), this.Module.universe.Import (typeof (ICollection < >)).MakeGenericType (elementType), this.Module.universe.Import (typeof (IEnumerable < >)).MakeGenericType (elementType)};
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1701" endline="1716">
public override MethodBase [] __GetDeclaredMethods () {
    Type [] int32 = new Type [] {this.Module.universe.System_Int32};
    List < MethodBase > list = new List < MethodBase > ();
    list.Add (new BuiltinArrayMethod (this.Module, this, "Set", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, new Type [] {this.Module.universe.System_Int32, elementType}));
    list.Add (new BuiltinArrayMethod (this.Module, this, "Address", CallingConventions.Standard | CallingConventions.HasThis, elementType.MakeByRefType (), int32));
    list.Add (new BuiltinArrayMethod (this.Module, this, "Get", CallingConventions.Standard | CallingConventions.HasThis, elementType, int32));
    list.Add (new ConstructorInfoImpl (new BuiltinArrayMethod (this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
    for (Type type = elementType; type.__IsVector; type = type.GetElementType ()) {
        Array.Resize (ref int32, int32.Length + 1);
        int32 [int32.Length - 1] = int32 [0];
        list.Add (new ConstructorInfoImpl (new BuiltinArrayMethod (this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
    }
    return list.ToArray ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1733" endline="1736">
public override int GetArrayRank () {
    return 1;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1738" endline="1741">
public override bool Equals (object o) {
    return EqualsHelper (o as ArrayType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1743" endline="1746">
public override int GetHashCode () {
    return elementType.GetHashCode () * 5;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1748" endline="1751">
protected override string GetSuffix () {
    return "[]";
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1753" endline="1756">
protected override Type Wrap (Type type, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return Make (type, requiredCustomModifiers, optionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1763" endline="1766">
internal static Type Make (Type type, int rank, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return type.Module.CanonicalizeType (new MultiArrayType (type, rank, requiredCustomModifiers, optionalCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1779" endline="1800">
public override MethodBase [] __GetDeclaredMethods () {
    Type int32 = this.Module.universe.System_Int32;
    Type [] setArgs = new Type [rank + 1];
    Type [] getArgs = new Type [rank];
    Type [] ctorArgs = new Type [rank * 2];
    for (int i = 0; i < rank; i ++) {
        setArgs [i] = int32;
        getArgs [i] = int32;
        ctorArgs [i * 2 + 0] = int32;
        ctorArgs [i * 2 + 1] = int32;
    }
    setArgs [rank] = elementType;
    return new MethodBase [] {new ConstructorInfoImpl (new BuiltinArrayMethod (this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, getArgs)), new ConstructorInfoImpl (new BuiltinArrayMethod (this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, ctorArgs)), new BuiltinArrayMethod (this.Module, this, "Set", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, setArgs), new BuiltinArrayMethod (this.Module, this, "Address", CallingConventions.Standard | CallingConventions.HasThis, elementType.MakeByRefType (), getArgs), new BuiltinArrayMethod (this.Module, this, "Get", CallingConventions.Standard | CallingConventions.HasThis, elementType, getArgs),};
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1812" endline="1815">
public override int GetArrayRank () {
    return rank;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1817" endline="1821">
public override bool Equals (object o) {
    MultiArrayType at = o as MultiArrayType;
    return EqualsHelper (at) && at.rank == rank;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1823" endline="1826">
public override int GetHashCode () {
    return elementType.GetHashCode () * 9 + rank;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1828" endline="1838">
protected override string GetSuffix () {
    if (rank == 1) {
        return "[*]";
    } else {
        return "[" + new String (',', rank - 1) + "]";
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1840" endline="1843">
protected override Type Wrap (Type type, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return Make (type, rank, requiredCustomModifiers, optionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1858" endline="1861">
public override MethodImplAttributes GetMethodImplementationFlags () {
    return MethodImplAttributes.IL;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1868" endline="1871">
public override MethodBody GetMethodBody () {
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1873" endline="1881">
public override ParameterInfo [] GetParameters () {
    ParameterInfo [] parameterInfos = new ParameterInfo [parameterTypes.Length];
    for (int i = 0; i < parameterInfos.Length; i ++) {
        parameterInfos [i] = new ParameterInfoImpl (this, parameterTypes [i], i);
    }
    return parameterInfos;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1926" endline="1929">
public override Type [] GetOptionalCustomModifiers () {
    return Empty < Type >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1931" endline="1934">
public override Type [] GetRequiredCustomModifiers () {
    return Empty < Type >.Array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1955" endline="1958">
internal static Type Make (Type type, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return type.Module.CanonicalizeType (new ByRefType (type, requiredCustomModifiers, optionalCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1965" endline="1968">
public override bool Equals (object o) {
    return EqualsHelper (o as ByRefType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1970" endline="1973">
public override int GetHashCode () {
    return elementType.GetHashCode () * 3;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1990" endline="1993">
protected override string GetSuffix () {
    return "&";
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="1995" endline="1998">
protected override Type Wrap (Type type, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return Make (type, requiredCustomModifiers, optionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2003" endline="2006">
internal static Type Make (Type type, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return type.Module.CanonicalizeType (new PointerType (type, requiredCustomModifiers, optionalCustomModifiers));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2013" endline="2016">
public override bool Equals (object o) {
    return EqualsHelper (o as PointerType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2018" endline="2021">
public override int GetHashCode () {
    return elementType.GetHashCode () * 7;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2038" endline="2041">
protected override string GetSuffix () {
    return "*";
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2043" endline="2046">
protected override Type Wrap (Type type, Type [] requiredCustomModifiers, Type [] optionalCustomModifiers) {
    return Make (type, requiredCustomModifiers, optionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2058" endline="2088">
internal static Type Make (Type type, Type [] typeArguments, Type [] [] requiredCustomModifiers, Type [] [] optionalCustomModifiers) {
    bool identity = true;
    if (type is TypeBuilder || type is BakedType) {
        identity = false;
    } else {
        for (int i = 0; i < typeArguments.Length; i ++) {
            if (typeArguments [i] != type.GetGenericTypeArgument (i) || ! IsEmpty (requiredCustomModifiers, i) || ! IsEmpty (optionalCustomModifiers, i)) {
                identity = false;
                break;
            }
        }
    }
    if (identity) {
        return type;
    } else {
        return type.Module.CanonicalizeType (new GenericTypeInstance (type, typeArguments, requiredCustomModifiers, optionalCustomModifiers));
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2090" endline="2095">
private static bool IsEmpty (Type [] [] mods, int i) {
    return mods == null || mods [i] == null || mods [i].Length == 0;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2105" endline="2111">
public override bool Equals (object o) {
    GenericTypeInstance gt = o as GenericTypeInstance;
    return gt != null && gt.type.Equals (type) && Util.ArrayEquals (gt.args, args) && Util.ArrayEquals (gt.requiredCustomModifiers, requiredCustomModifiers) && Util.ArrayEquals (gt.optionalCustomModifiers, optionalCustomModifiers);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2113" endline="2116">
public override int GetHashCode () {
    return type.GetHashCode () * 3 ^ Util.GetHashCode (args);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2181" endline="2184">
internal override void CheckBaked () {
    type.CheckBaked ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2186" endline="2194">
public override FieldInfo [] __GetDeclaredFields () {
    FieldInfo [] fields = type.__GetDeclaredFields ();
    for (int i = 0; i < fields.Length; i ++) {
        fields [i] = fields [i].BindTypeParameters (this);
    }
    return fields;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2196" endline="2204">
public override Type [] __GetDeclaredInterfaces () {
    Type [] interfaces = type.__GetDeclaredInterfaces ();
    for (int i = 0; i < interfaces.Length; i ++) {
        interfaces [i] = interfaces [i].BindTypeParameters (this);
    }
    return interfaces;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2206" endline="2214">
public override MethodBase [] __GetDeclaredMethods () {
    MethodBase [] methods = type.__GetDeclaredMethods ();
    for (int i = 0; i < methods.Length; i ++) {
        methods [i] = methods [i].BindTypeParameters (this);
    }
    return methods;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2216" endline="2219">
public override Type [] __GetDeclaredTypes () {
    return type.__GetDeclaredTypes ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2221" endline="2229">
public override EventInfo [] __GetDeclaredEvents () {
    EventInfo [] events = type.__GetDeclaredEvents ();
    for (int i = 0; i < events.Length; i ++) {
        events [i] = events [i].BindTypeParameters (this);
    }
    return events;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2231" endline="2239">
public override PropertyInfo [] __GetDeclaredProperties () {
    PropertyInfo [] properties = type.__GetDeclaredProperties ();
    for (int i = 0; i < properties.Length; i ++) {
        properties [i] = properties [i].BindTypeParameters (this);
    }
    return properties;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2241" endline="2258">
public override __MethodImplMap __GetMethodImplMap () {
    __MethodImplMap map = type.__GetMethodImplMap ();
    map.TargetType = this;
    for (int i = 0; i < map.MethodBodies.Length; i ++) {
        map.MethodBodies [i] = (MethodInfo) map.MethodBodies [i].BindTypeParameters (this);
        for (int j = 0; j < map.MethodDeclarations [i].Length; j ++) {
            Type interfaceType = map.MethodDeclarations [i] [j].DeclaringType;
            if (interfaceType.IsGenericType) {
                map.MethodDeclarations [i] [j] = (MethodInfo) map.MethodDeclarations [i] [j].BindTypeParameters (this);
            }
        }
    }
    return map;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2294" endline="2307">
public override string ToString () {
    StringBuilder sb = new StringBuilder (type.FullName);
    sb.Append ('[');
    string sep = "";
    foreach (Type arg in args) {
        sb.Append (sep);
        sb.Append (arg);
        sep = ",";
    }
    sb.Append (']');
    return sb.ToString ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2319" endline="2322">
public override Type GetGenericTypeDefinition () {
    return type;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2324" endline="2327">
public override Type [] GetGenericArguments () {
    return Util.Copy (args);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2329" endline="2332">
public override Type [] [] __GetGenericArgumentsRequiredCustomModifiers () {
    return Util.Copy (requiredCustomModifiers ?? new Type [args.Length] []);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2334" endline="2337">
public override Type [] [] __GetGenericArgumentsOptionalCustomModifiers () {
    return Util.Copy (optionalCustomModifiers ?? new Type [args.Length] []);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2339" endline="2342">
internal override Type GetGenericTypeArgument (int index) {
    return args [index];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2364" endline="2371">
internal override int GetModuleBuilderToken () {
    if (token == 0) {
        token = ((ModuleBuilder) type.Module).ImportType (this);
    }
    return token;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2373" endline="2391">
internal override Type BindTypeParameters (IGenericBinder binder) {
    for (int i = 0; i < args.Length; i ++) {
        Type xarg = args [i].BindTypeParameters (binder);
        if (! ReferenceEquals (xarg, args [i])) {
            Type [] xargs = new Type [args.Length];
            Array.Copy (args, xargs, i);
            xargs [i ++] = xarg;
            for (; i < args.Length; i ++) {
                xargs [i] = args [i].BindTypeParameters (binder);
            }
            return Make (type, xargs, null, null);
        }
    }
    return this;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Type.cs.ifdefed" startline="2393" endline="2396">
internal override IList < CustomAttributeData > GetCustomAttributesData (Type attributeType) {
    return type.GetCustomAttributesData (attributeType);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="42" endline="66">
internal static string Escape (string name) {
    if (name == null) {
        return null;
    }
    StringBuilder sb = null;
    for (int pos = 0; pos < name.Length; pos ++) {
        char c = name [pos];
        if (SpecialChars.IndexOf (c) != - 1) {
            if (sb == null) {
                sb = new StringBuilder (name, 0, pos, name.Length + 3);
            }
            sb.Append ('\\').Append (c);
        } else if (sb != null) {
            sb.Append (c);
        }
    }
    return sb != null ? sb.ToString () : name;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="68" endline="86">
internal static string Unescape (string name) {
    int pos = name.IndexOf ('\\');
    if (pos == - 1) {
        return name;
    }
    StringBuilder sb = new StringBuilder (name, 0, pos, name.Length - 1);
    for (; pos < name.Length; pos ++) {
        char c = name [pos];
        if (c == '\\') {
            c = name [++ pos];
        }
        sb.Append (c);
    }
    return sb.ToString ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="88" endline="107">
internal static TypeNameParser Parse (string typeName, bool throwOnError) {
    if (throwOnError) {
        Parser parser = new Parser (typeName);
        return new TypeNameParser (ref parser, true);
    } else {
        try {
            Parser parser = new Parser (typeName);
            return new TypeNameParser (ref parser, true);
        }
        catch (ArgumentException) {
            return new TypeNameParser ();
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="152" endline="158">
private void Check (bool condition) {
    if (! condition) {
        throw new ArgumentException ("Invalid type name '" + typeName + "'");
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="160" endline="163">
private void Consume (char c) {
    Check (pos < typeName.Length && typeName [pos ++] == c);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="165" endline="176">
private bool TryConsume (char c) {
    if (pos < typeName.Length && typeName [pos] == c) {
        pos ++;
        return true;
    } else {
        return false;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="178" endline="204">
internal string NextNamePart () {
    SkipWhiteSpace ();
    int start = pos;
    for (; pos < typeName.Length; pos ++) {
        char c = typeName [pos];
        if (c == '\\') {
            pos ++;
            Check (pos < typeName.Length && SpecialChars.IndexOf (typeName [pos]) != - 1);
        } else if (SpecialChars.IndexOf (c) != - 1) {
            break;
        }
    }
    Check (pos - start != 0);
    if (start == 0 && pos == typeName.Length) {
        return typeName;
    } else {
        return typeName.Substring (start, pos - start);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="206" endline="212">
internal void ParseNested (ref string [] nested) {
    while (TryConsume ('+')) {
        Add (ref nested, NextNamePart ());
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="214" endline="243">
internal void ParseGenericParameters (ref TypeNameParser [] genericParameters) {
    int saved = pos;
    if (TryConsume ('[')) {
        SkipWhiteSpace ();
        if (TryConsume (']') || TryConsume ('*') || TryConsume (',')) {
            pos = saved;
            return;
        }
        do
            {
                SkipWhiteSpace ();
                if (TryConsume ('[')) {
                    Add (ref genericParameters, new TypeNameParser (ref this, true));
                    Consume (']');
                } else {
                    Add (ref genericParameters, new TypeNameParser (ref this, false));
                }
            } while (TryConsume (','));
        Consume (']');
        SkipWhiteSpace ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="245" endline="269">
internal void ParseModifiers (ref short [] modifiers) {
    while (pos < typeName.Length) {
        switch (typeName [pos]) {
            case '*' :
                pos ++;
                Add (ref modifiers, POINTER);
                break;
            case '&' :
                pos ++;
                Add (ref modifiers, BYREF);
                break;
            case '[' :
                pos ++;
                Add (ref modifiers, ParseArray ());
                Consume (']');
                break;
            default :
                return;
        }
        SkipWhiteSpace ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="271" endline="319">
internal void ParseAssemblyName (bool genericParameter, ref string assemblyName) {
    if (pos < typeName.Length) {
        if (typeName [pos] == ']' && genericParameter) {
        } else {
            Consume (',');
            SkipWhiteSpace ();
            if (genericParameter) {
                int start = pos;
                while (pos < typeName.Length) {
                    char c = typeName [pos];
                    if (c == '\\') {
                        pos ++;
                        Check (pos < typeName.Length && typeName [pos ++] == ']');
                    } else if (c == ']') {
                        break;
                    } else {
                        pos ++;
                    }
                }
                Check (pos < typeName.Length && typeName [pos] == ']');
                assemblyName = typeName.Substring (start, pos - start).Replace ("\\]", "]");
            } else {
                assemblyName = typeName.Substring (pos);
            }
            Check (assemblyName.Length != 0);
        }
    } else {
        Check (! genericParameter);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="321" endline="347">
private short ParseArray () {
    SkipWhiteSpace ();
    Check (pos < typeName.Length);
    char c = typeName [pos];
    if (c == ']') {
        return SZARRAY;
    } else if (c == '*') {
        pos ++;
        SkipWhiteSpace ();
        return 1;
    } else {
        short rank = 1;
        while (TryConsume (',')) {
            Check (rank < short.MaxValue);
            rank ++;
            SkipWhiteSpace ();
        }
        return rank;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="349" endline="355">
private void SkipWhiteSpace () {
    while (pos < typeName.Length && Char.IsWhiteSpace (typeName [pos])) {
        pos ++;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="357" endline="366">
private static void Add < T > (ref T [] array, T elem) {
    if (array == null) {
        array = new T [] {elem};
        return;
    }
    Array.Resize (ref array, array.Length + 1);
    array [array.Length - 1] = elem;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="369" endline="394">
internal Type GetType (Universe universe, Assembly context, bool throwOnError, string originalName) {
    Type type;
    if (assemblyName != null) {
        Assembly asm = universe.Load (assemblyName, context, throwOnError);
        if (asm == null) {
            return null;
        }
        type = asm.GetTypeImpl (name);
    } else if (context == null) {
        type = universe.Mscorlib.GetTypeImpl (name);
    } else {
        type = context.GetTypeImpl (name);
        if (type == null && context != universe.Mscorlib) {
            type = universe.Mscorlib.GetTypeImpl (name);
        }
    }
    return Expand (type, context, throwOnError, originalName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/TypeNameParser.cs.ifdefed" startline="396" endline="456">
internal Type Expand (Type type, Assembly context, bool throwOnError, string originalName) {
    if (type == null) {
        if (throwOnError) {
            throw new TypeLoadException (originalName);
        }
        return null;
    }
    if (nested != null) {
        foreach (string nest in nested) {
            type = type.GetNestedType (nest, BindingFlags.Public | BindingFlags.NonPublic);
            if (type == null) {
                if (throwOnError) {
                    throw new TypeLoadException (originalName);
                }
                return null;
            }
        }
    }
    if (genericParameters != null) {
        Type [] typeArgs = new Type [genericParameters.Length];
        for (int i = 0; i < typeArgs.Length; i ++) {
            typeArgs [i] = genericParameters [i].GetType (type.Assembly.universe, context, throwOnError, originalName);
            if (typeArgs [i] == null) {
                return null;
            }
        }
        type = type.MakeGenericType (typeArgs);
    }
    if (modifiers != null) {
        foreach (short modifier in modifiers) {
            switch (modifier) {
                case SZARRAY :
                    type = type.MakeArrayType ();
                    break;
                case BYREF :
                    type = type.MakeByRefType ();
                    break;
                case POINTER :
                    type = type.MakePointerType ();
                    break;
                default :
                    type = type.MakeArrayType (modifier);
                    break;
            }
        }
    }
    return type;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="150" endline="153">
private Type ImportMscorlibType (System.Type type) {
    return Mscorlib.GetTypeImpl (type.FullName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="446" endline="458">
public Type Import (System.Type type) {
    Type imported;
    if (! importedTypes.TryGetValue (type, out imported)) {
        imported = ImportImpl (type);
        if (imported != null) {
            importedTypes.Add (type, imported);
        }
    }
    return imported;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="460" endline="517">
private Type ImportImpl (System.Type type) {
    if (type.Assembly == typeof (IKVM.Reflection.Type).Assembly) {
        throw new ArgumentException ("Did you really want to import " + type.FullName + "?");
    }
    if (type.HasElementType) {
        if (type.IsArray) {
            if (type.Name.EndsWith ("[]")) {
                return Import (type.GetElementType ()).MakeArrayType ();
            } else {
                return Import (type.GetElementType ()).MakeArrayType (type.GetArrayRank ());
            }
        } else if (type.IsByRef) {
            return Import (type.GetElementType ()).MakeByRefType ();
        } else if (type.IsPointer) {
            return Import (type.GetElementType ()).MakePointerType ();
        } else {
            throw new InvalidOperationException ();
        }
    } else if (type.IsGenericParameter) {
        if (type.DeclaringMethod != null) {
            throw new NotImplementedException ();
        } else {
            return Import (type.DeclaringType).GetGenericArguments () [type.GenericParameterPosition];
        }
    } else if (type.IsGenericType && ! type.IsGenericTypeDefinition) {
        System.Type [] args = type.GetGenericArguments ();
        Type [] importedArgs = new Type [args.Length];
        for (int i = 0; i < args.Length; i ++) {
            importedArgs [i] = Import (args [i]);
        }
        return Import (type.GetGenericTypeDefinition ()).MakeGenericType (importedArgs);
    } else {
        return Import (type.Assembly).GetType (type.FullName);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="519" endline="522">
private Assembly Import (System.Reflection.Assembly asm) {
    return Load (asm.FullName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="524" endline="528">
public RawModule OpenRawModule (string path) {
    path = Path.GetFullPath (path);
    return OpenRawModule (new FileStream (path, FileMode.Open, FileAccess.Read, FileShare.Read), path);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="530" endline="537">
public RawModule OpenRawModule (Stream stream, string location) {
    if (! stream.CanRead || ! stream.CanSeek) {
        throw new NotSupportedException ();
    }
    return new RawModule (new ModuleReader (null, this, stream, location));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="539" endline="549">
public Assembly LoadAssembly (RawModule module) {
    string refname = module.GetAssemblyName ().FullName;
    Assembly asm = GetLoadedAssembly (refname);
    if (asm == null) {
        asm = module.ToAssembly ();
        assemblies.Add (asm);
    }
    return asm;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="551" endline="568">
public Assembly LoadFile (string path) {
    try {
        using (RawModule module = OpenRawModule (path))
        {
            return LoadAssembly (module);
        }}
    catch (IOException x) {
        throw new FileNotFoundException (x.Message, x);
    }
    catch (UnauthorizedAccessException x) {
        throw new FileNotFoundException (x.Message, x);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="570" endline="589">
private Assembly GetLoadedAssembly (string refname) {
    Assembly asm;
    if (! assembliesByName.TryGetValue (refname, out asm)) {
        for (int i = 0; i < assemblies.Count; i ++) {
            AssemblyComparisonResult result;
            if (CompareAssemblyIdentity (refname, false, assemblies [i].FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified) {
                asm = assemblies [i];
                assembliesByName.Add (refname, asm);
                break;
            }
        }
    }
    return asm;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="591" endline="604">
private Assembly GetDynamicAssembly (string refname) {
    foreach (AssemblyBuilder asm in dynamicAssemblies) {
        AssemblyComparisonResult result;
        if (CompareAssemblyIdentity (refname, false, asm.FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified) {
            return asm;
        }
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="606" endline="609">
public Assembly Load (string refname) {
    return Load (refname, null, true);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="611" endline="652">
internal Assembly Load (string refname, Assembly requestingAssembly, bool throwOnError) {
    Assembly asm = GetLoadedAssembly (refname);
    if (asm != null) {
        return asm;
    }
    if (resolvers.Count == 0) {
        asm = DefaultResolver (refname, throwOnError);
    } else {
        ResolveEventArgs args = new ResolveEventArgs (refname, requestingAssembly);
        foreach (ResolveEventHandler evt in resolvers) {
            asm = evt (this, args);
            if (asm != null) {
                break;
            }
        }
        if (asm == null) {
            asm = GetDynamicAssembly (refname);
        }
    }
    if (asm != null) {
        string defname = asm.FullName;
        if (refname != defname) {
            assembliesByName.Add (refname, asm);
        }
        return asm;
    }
    if (throwOnError) {
        throw new FileNotFoundException (refname);
    }
    return null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="654" endline="691">
private Assembly DefaultResolver (string refname, bool throwOnError) {
    Assembly asm = GetDynamicAssembly (refname);
    if (asm != null) {
        return asm;
    }
    string fileName;
    if (throwOnError) {
        try {
            fileName = System.Reflection.Assembly.ReflectionOnlyLoad (refname).Location;
        }
        catch (System.BadImageFormatException x) {
            throw new BadImageFormatException (x.Message, x);
        }
    } else {
        try {
            fileName = System.Reflection.Assembly.ReflectionOnlyLoad (refname).Location;
        }
        catch (System.BadImageFormatException x) {
            throw new BadImageFormatException (x.Message, x);
        }
        catch (FileNotFoundException) {
            return null;
        }
    }
    return LoadFile (fileName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="693" endline="698">
public Type GetType (string assemblyQualifiedTypeName) {
    return GetType (null, assemblyQualifiedTypeName, false);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="700" endline="705">
public Type GetType (string assemblyQualifiedTypeName, bool throwOnError) {
    return GetType (null, assemblyQualifiedTypeName, throwOnError);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="709" endline="717">
public Type GetType (Assembly context, string assemblyQualifiedTypeName, bool throwOnError) {
    TypeNameParser parser = TypeNameParser.Parse (assemblyQualifiedTypeName, throwOnError);
    if (parser.Error) {
        return null;
    }
    return parser.GetType (this, context, throwOnError, assemblyQualifiedTypeName);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="719" endline="728">
public Assembly [] GetAssemblies () {
    Assembly [] array = new Assembly [assemblies.Count + dynamicAssemblies.Count];
    assemblies.CopyTo (array);
    for (int i = 0, j = assemblies.Count; j < array.Length; i ++, j ++) {
        array [j] = dynamicAssemblies [i];
    }
    return array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="731" endline="734">
public bool CompareAssemblyIdentity (string assemblyIdentity1, bool unified1, string assemblyIdentity2, bool unified2, out AssemblyComparisonResult result) {
    return Fusion.CompareAssemblyIdentity (assemblyIdentity1, unified1, assemblyIdentity2, unified2, out result);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="736" endline="739">
public AssemblyBuilder DefineDynamicAssembly (AssemblyName name, AssemblyBuilderAccess access) {
    return DefineDynamicAssemblyImpl (name, access, null, null, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="741" endline="744">
public AssemblyBuilder DefineDynamicAssembly (AssemblyName name, AssemblyBuilderAccess access, string dir) {
    return DefineDynamicAssemblyImpl (name, access, dir, null, null, null);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="749" endline="752">
public AssemblyBuilder DefineDynamicAssembly (AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions) {
    return DefineDynamicAssemblyImpl (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="754" endline="759">
private AssemblyBuilder DefineDynamicAssemblyImpl (AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions) {
    AssemblyBuilder asm = new AssemblyBuilder (this, name, dir, requiredPermissions, optionalPermissions, refusedPermissions);
    dynamicAssemblies.Add (asm);
    return asm;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="761" endline="775">
internal void RenameAssembly (Assembly assembly, AssemblyName oldName) {
    List < string > remove = new List < string > ();
    foreach (KeyValuePair < string, Assembly > kv in assembliesByName) {
        if (kv.Value == assembly) {
            remove.Add (kv.Key);
        }
    }
    foreach (string key in remove) {
        assembliesByName.Remove (key);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Universe.cs.ifdefed" startline="777" endline="793">
public void Dispose () {
    foreach (Assembly asm in assemblies) {
        foreach (Module mod in asm.GetLoadedModules ()) {
            mod.Dispose ();
        }
    }
    foreach (AssemblyBuilder asm in dynamicAssemblies) {
        foreach (Module mod in asm.GetLoadedModules ()) {
            mod.Dispose ();
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="65" endline="68">
void ISerializable.GetObjectData (SerializationInfo info, StreamingContext context) {
    info.SetType (typeof (SingletonSerializationHelper));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="73" endline="76">
public object GetRealObject (StreamingContext context) {
    return Value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="87" endline="96">
internal static Type [] Copy (Type [] array) {
    if (array == null || array.Length == 0) {
        return Type.EmptyTypes;
    }
    Type [] copy = new Type [array.Length];
    Array.Copy (array, copy, array.Length);
    return copy;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="98" endline="110">
internal static Type [] [] Copy (Type [] [] types) {
    if (types == null || types.Length == 0) {
        return types;
    }
    Type [] [] newArray = new Type [types.Length] [];
    for (int i = 0; i < newArray.Length; i ++) {
        newArray [i] = Copy (types [i]);
    }
    return newArray;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="112" endline="124">
internal static T [] ToArray < T, V > (List < V > list, T [] empty) where V : T {
    if (list == null || list.Count == 0) {
        return empty;
    }
    T [] array = new T [list.Count];
    for (int i = 0; i < array.Length; i ++) {
        array [i] = list [i];
    }
    return array;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="127" endline="153">
internal static bool ArrayEquals (Type [] t1, Type [] t2) {
    if (t1 == t2) {
        return true;
    }
    if (t1 == null) {
        return t2.Length == 0;
    } else if (t2 == null) {
        return t1.Length == 0;
    }
    if (t1.Length == t2.Length) {
        for (int i = 0; i < t1.Length; i ++) {
            if (! TypeEquals (t1 [i], t2 [i])) {
                return false;
            }
        }
        return true;
    }
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="155" endline="181">
internal static bool ArrayEquals (Type [] [] t1, Type [] [] t2) {
    if (t1 == t2) {
        return true;
    }
    if (t1 == null) {
        return t2.Length == 0;
    } else if (t2 == null) {
        return t1.Length == 0;
    }
    if (t1.Length == t2.Length) {
        for (int i = 0; i < t1.Length; i ++) {
            if (! ArrayEquals (t1 [i], t2 [i])) {
                return false;
            }
        }
        return true;
    }
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="183" endline="209">
internal static bool ArrayEquals (Type [] [] [] t1, Type [] [] [] t2) {
    if (t1 == t2) {
        return true;
    }
    if (t1 == null) {
        return t2.Length == 0;
    } else if (t2 == null) {
        return t1.Length == 0;
    }
    if (t1.Length == t2.Length) {
        for (int i = 0; i < t1.Length; i ++) {
            if (! ArrayEquals (t1 [i], t2 [i])) {
                return false;
            }
        }
        return true;
    }
    return false;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="211" endline="222">
internal static bool TypeEquals (Type t1, Type t2) {
    if (t1 == t2) {
        return true;
    }
    if (t1 == null) {
        return false;
    }
    return t1.Equals (t2);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="224" endline="240">
internal static int GetHashCode (Type [] types) {
    if (types == null) {
        return 0;
    }
    int h = 0;
    foreach (Type t in types) {
        if (t != null) {
            h *= 3;
            h ^= t.GetHashCode ();
        }
    }
    return h;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="242" endline="253">
internal static int GetHashCode (Type [] [] types) {
    int h = 0;
    if (types != null) {
        foreach (Type [] array in types) {
            h ^= GetHashCode (array);
        }
    }
    return h;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="255" endline="266">
internal static int GetHashCode (Type [] [] [] types) {
    int h = 0;
    if (types != null) {
        foreach (Type [] [] array in types) {
            h ^= GetHashCode (array);
        }
    }
    return h;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="277" endline="282">
internal static int SingleToInt32Bits (float v) {
    SingleConverter c = new SingleConverter ();
    c.f = v;
    return c.i;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Util.cs.ifdefed" startline="284" endline="289">
internal static float Int32BitsToSingle (int v) {
    SingleConverter c = new SingleConverter ();
    c.i = v;
    return c.f;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="65" endline="70">
private void Grow (int minGrow) {
    byte [] newbuf = new byte [Math.Max (buffer.Length + minGrow, buffer.Length * 2)];
    Buffer.BlockCopy (buffer, 0, newbuf, 0, buffer.Length);
    buffer = newbuf;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="73" endline="79">
internal int GetInt32AtCurrentPosition () {
    return buffer [pos] + (buffer [pos + 1] << 8) + (buffer [pos + 2] << 16) + (buffer [pos + 3] << 24);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="82" endline="85">
internal byte GetByteAtCurrentPosition () {
    return buffer [pos];
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="87" endline="93">
internal void Write (byte [] value) {
    if (pos + value.Length > buffer.Length)
        Grow (value.Length);

    Buffer.BlockCopy (value, 0, buffer, pos, value.Length);
    pos += value.Length;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="95" endline="100">
internal void Write (byte value) {
    if (pos == buffer.Length)
        Grow (1);

    buffer [pos ++] = value;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="102" endline="105">
internal void Write (sbyte value) {
    Write ((byte) value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="107" endline="110">
internal void Write (ushort value) {
    Write ((short) value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="112" endline="118">
internal void Write (short value) {
    if (pos + 2 > buffer.Length)
        Grow (2);

    buffer [pos ++] = (byte) value;
    buffer [pos ++] = (byte) (value > > 8);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="120" endline="123">
internal void Write (uint value) {
    Write ((int) value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="125" endline="133">
internal void Write (int value) {
    if (pos + 4 > buffer.Length)
        Grow (4);

    buffer [pos ++] = (byte) value;
    buffer [pos ++] = (byte) (value > > 8);
    buffer [pos ++] = (byte) (value > > 16);
    buffer [pos ++] = (byte) (value > > 24);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="135" endline="138">
internal void Write (ulong value) {
    Write ((long) value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="140" endline="152">
internal void Write (long value) {
    if (pos + 8 > buffer.Length)
        Grow (8);

    buffer [pos ++] = (byte) value;
    buffer [pos ++] = (byte) (value > > 8);
    buffer [pos ++] = (byte) (value > > 16);
    buffer [pos ++] = (byte) (value > > 24);
    buffer [pos ++] = (byte) (value > > 32);
    buffer [pos ++] = (byte) (value > > 40);
    buffer [pos ++] = (byte) (value > > 48);
    buffer [pos ++] = (byte) (value > > 56);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="154" endline="157">
internal void Write (float value) {
    Write (SingleConverter.SingleToInt32Bits (value));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="159" endline="162">
internal void Write (double value) {
    Write (BitConverter.DoubleToInt64Bits (value));
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="164" endline="176">
internal void Write (string str) {
    if (str == null) {
        Write ((byte) 0xFF);
    } else {
        byte [] buf = Encoding.UTF8.GetBytes (str);
        WriteCompressedInt (buf.Length);
        Write (buf);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="178" endline="196">
internal void WriteCompressedInt (int value) {
    if (value <= 0x7F) {
        Write ((byte) value);
    } else if (value <= 0x3FFF) {
        Write ((byte) (0x80 | (value > > 8)));
        Write ((byte) value);
    } else {
        Write ((byte) (0xC0 | (value > > 24)));
        Write ((byte) (value > > 16));
        Write ((byte) (value > > 8));
        Write ((byte) value);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="198" endline="204">
internal void Write (ByteBuffer bb) {
    if (pos + bb.Length > buffer.Length)
        Grow (bb.Length);

    Buffer.BlockCopy (bb.buffer, 0, buffer, pos, bb.Length);
    pos += bb.Length;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="206" endline="209">
internal void WriteTo (System.IO.Stream stream) {
    stream.Write (buffer, 0, this.Length);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="211" endline="215">
internal void Clear () {
    pos = 0;
    __length = 0;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="217" endline="224">
internal void Align (int alignment) {
    if (pos + alignment > buffer.Length)
        Grow (alignment);

    int newpos = (pos + alignment - 1) & ~ (alignment - 1);
    while (pos < newpos)
        buffer [pos ++] = 0;

}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="226" endline="242">
internal void WriteTypeDefOrRefEncoded (int token) {
    switch (token > > 24) {
        case TypeDefTable.Index :
            WriteCompressedInt ((token & 0xFFFFFF) << 2 | 0);
            break;
        case TypeRefTable.Index :
            WriteCompressedInt ((token & 0xFFFFFF) << 2 | 1);
            break;
        case TypeSpecTable.Index :
            WriteCompressedInt ((token & 0xFFFFFF) << 2 | 2);
            break;
        default :
            throw new InvalidOperationException ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="244" endline="258">
internal void Write (System.IO.Stream stream) {
    const int chunkSize = 8192;
    for (;;) {
        if (pos + chunkSize > buffer.Length)
            Grow (chunkSize);

        int read = stream.Read (buffer, pos, chunkSize);
        if (read <= 0) {
            break;
        }
        pos += read;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="260" endline="265">
internal byte [] ToArray () {
    byte [] buf = new byte [pos];
    Buffer.BlockCopy (buffer, 0, buf, 0, pos);
    return buf;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="267" endline="270">
internal static ByteBuffer Wrap (byte [] buf) {
    return new ByteBuffer (buf, buf.Length);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="272" endline="275">
internal static ByteBuffer Wrap (byte [] buf, int length) {
    return new ByteBuffer (buf, length);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="277" endline="287">
internal bool Match (int pos, ByteBuffer bb2, int pos2, int len) {
    for (int i = 0; i < len; i ++) {
        if (buffer [pos + i] != bb2.buffer [pos2 + i]) {
            return false;
        }
    }
    return true;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="289" endline="299">
internal int Hash () {
    int hash = 0;
    int len = this.Length;
    for (int i = 0; i < len; i ++) {
        hash *= 37;
        hash ^= buffer [i];
    }
    return hash;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="301" endline="304">
internal IKVM.Reflection.Reader.ByteReader GetBlob (int offset) {
    return IKVM.Reflection.Reader.ByteReader.FromBlob (buffer, offset);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ByteBuffer.cs.ifdefed" startline="306" endline="309">
internal void Patch (int offset, byte b) {
    buffer [offset] = b;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="37" endline="47">
internal void Write (MetadataWriter mw) {
    int pos = mw.Position;
    WriteImpl (mw);
    Debug.Assert (mw.Position == pos + unalignedlength);
    int align = Length - unalignedlength;
    for (int i = 0; i < align; i ++) {
        mw.Write ((byte) 0);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="69" endline="75">
internal void Freeze () {
    if (frozen)
        throw new InvalidOperationException ();

    frozen = true;
    unalignedlength = GetLength ();
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="82" endline="88">
internal void Freeze (MetadataWriter mw) {
    if (frozen)
        throw new InvalidOperationException ();

    frozen = true;
    unalignedlength = GetLength (mw);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="90" endline="146">
protected override void WriteImpl (MetadataWriter mw) {
    Table [] tables = mw.ModuleBuilder.GetTables ();
    mw.Write (0);
    int ver = mw.ModuleBuilder.MDStreamVersion;
    mw.Write ((byte) (ver > > 16));
    mw.Write ((byte) ver);
    byte heapSizes = 0;
    if (mw.ModuleBuilder.Strings.IsBig) {
        heapSizes |= 0x01;
    }
    if (mw.ModuleBuilder.Guids.IsBig) {
        heapSizes |= 0x02;
    }
    if (mw.ModuleBuilder.Blobs.IsBig) {
        heapSizes |= 0x04;
    }
    mw.Write (heapSizes);
    mw.Write ((byte) 0x10);
    long bit = 1;
    long valid = 0;
    foreach (Table table in tables) {
        if (table != null && table.RowCount > 0) {
            valid |= bit;
        }
        bit <<= 1;
    }
    mw.Write (valid);
    mw.Write (0x0016003301FA00L);
    foreach (Table table in tables) {
        if (table != null && table.RowCount > 0) {
            mw.Write (table.RowCount);
        }
    }
    foreach (Table table in tables) {
        if (table != null && table.RowCount > 0) {
            int pos = mw.Position;
            table.Write (mw);
            Debug.Assert (mw.Position - pos == table.GetLength (mw));
        }
    }
    mw.Write ((byte) 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="148" endline="161">
private int GetLength (MetadataWriter mw) {
    int len = 4 + 4 + 8 + 8;
    foreach (Table table in mw.ModuleBuilder.GetTables ()) {
        if (table != null && table.RowCount > 0) {
            len += 4;
            len += table.GetLength (mw);
        }
    }
    return len + 1;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="175" endline="187">
internal int Add (string str) {
    Debug.Assert (! frozen);
    int offset;
    if (! strings.TryGetValue (str, out offset)) {
        offset = nextOffset;
        nextOffset += System.Text.Encoding.UTF8.GetByteCount (str) + 1;
        list.Add (str);
        strings.Add (str, offset);
    }
    return offset;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="189" endline="192">
protected override int GetLength () {
    return nextOffset;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="194" endline="201">
protected override void WriteImpl (MetadataWriter mw) {
    foreach (string str in list) {
        mw.Write (System.Text.Encoding.UTF8.GetBytes (str));
        mw.Write ((byte) 0);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="220" endline="237">
internal int Add (string str) {
    Debug.Assert (! frozen);
    int offset;
    if (! strings.TryGetValue (str, out offset)) {
        int length = str.Length * 2 + 1 + MetadataWriter.GetCompressedIntLength (str.Length * 2 + 1);
        if (nextOffset + length > 0xFFFFFF) {
            throw new FileFormatLimitationExceededException ("No logical space left to create more user strings.", FileFormatLimitationExceededException.META_E_STRINGSPACE_FULL);
        }
        offset = nextOffset;
        nextOffset += length;
        list.Add (str);
        strings.Add (str, offset);
    }
    return offset;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="239" endline="242">
protected override int GetLength () {
    return nextOffset;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="244" endline="268">
protected override void WriteImpl (MetadataWriter mw) {
    mw.Write ((byte) 0);
    foreach (string str in list) {
        mw.WriteCompressedInt (str.Length * 2 + 1);
        byte hasSpecialChars = 0;
        foreach (char ch in str) {
            mw.Write ((ushort) ch);
            if (hasSpecialChars == 0 && (ch < 0x20 || ch > 0x7E)) {
                if (ch > 0x7E || (ch >= 0x01 && ch <= 0x08) || (ch >= 0x0E && ch <= 0x1F) || ch == 0x27 || ch == 0x2D) {
                    hasSpecialChars = 1;
                }
            }
        }
        mw.Write (hasSpecialChars);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="279" endline="284">
internal int Add (Guid guid) {
    Debug.Assert (! frozen);
    list.Add (guid);
    return list.Count;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="286" endline="289">
protected override int GetLength () {
    return list.Count * 16;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="291" endline="297">
protected override void WriteImpl (MetadataWriter mw) {
    foreach (Guid guid in list) {
        mw.Write (guid.ToByteArray ());
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="318" endline="360">
internal int Add (ByteBuffer bb) {
    Debug.Assert (! frozen);
    if (bb.Length == 0) {
        return 0;
    }
    int lenlen = MetadataWriter.GetCompressedIntLength (bb.Length);
    int hash = bb.Hash ();
    int index = (hash & 0x7FFFFFFF) % map.Length;
    Key [] keys = map;
    int last = index;
    while (keys [index].offset != 0) {
        if (keys [index].hash == hash && keys [index].len == bb.Length && buf.Match (keys [index].offset + lenlen, bb, 0, bb.Length)) {
            return keys [index].offset;
        }
        if (index == last) {
            if (keys [index].next == null) {
                keys [index].next = new Key [4];
                keys = keys [index].next;
                index = 0;
                break;
            }
            keys = keys [index].next;
            index = - 1;
            last = keys.Length - 1;
        }
        index ++;
    }
    int offset = buf.Position;
    buf.WriteCompressedInt (bb.Length);
    buf.Write (bb);
    keys [index].len = bb.Length;
    keys [index].hash = hash;
    keys [index].offset = offset;
    return offset;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="362" endline="365">
protected override int GetLength () {
    return buf.Position;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="367" endline="370">
protected override void WriteImpl (MetadataWriter mw) {
    mw.Write (buf);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/Heaps.cs.ifdefed" startline="377" endline="380">
internal IKVM.Reflection.Reader.ByteReader GetBlob (int blobIndex) {
    return buf.GetBlob (blobIndex);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="56" endline="59">
internal void Write (ByteBuffer bb) {
    bb.WriteTo (stream);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="61" endline="64">
internal void Write (byte [] value) {
    stream.Write (value, 0, value.Length);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="66" endline="69">
internal void Write (byte value) {
    stream.WriteByte (value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="71" endline="74">
internal void Write (ushort value) {
    Write ((short) value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="76" endline="81">
internal void Write (short value) {
    buffer [0] = (byte) value;
    buffer [1] = (byte) (value > > 8);
    stream.Write (buffer, 0, 2);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="83" endline="86">
internal void Write (uint value) {
    Write ((int) value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="88" endline="95">
internal void Write (int value) {
    buffer [0] = (byte) value;
    buffer [1] = (byte) (value > > 8);
    buffer [2] = (byte) (value > > 16);
    buffer [3] = (byte) (value > > 24);
    stream.Write (buffer, 0, 4);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="97" endline="100">
internal void Write (ulong value) {
    Write ((long) value);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="102" endline="113">
internal void Write (long value) {
    buffer [0] = (byte) value;
    buffer [1] = (byte) (value > > 8);
    buffer [2] = (byte) (value > > 16);
    buffer [3] = (byte) (value > > 24);
    buffer [4] = (byte) (value > > 32);
    buffer [5] = (byte) (value > > 40);
    buffer [6] = (byte) (value > > 48);
    buffer [7] = (byte) (value > > 56);
    stream.Write (buffer, 0, 8);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="115" endline="133">
internal void WriteCompressedInt (int value) {
    if (value <= 0x7F) {
        Write ((byte) value);
    } else if (value <= 0x3FFF) {
        Write ((byte) (0x80 | (value > > 8)));
        Write ((byte) value);
    } else {
        Write ((byte) (0xC0 | (value > > 24)));
        Write ((byte) (value > > 16));
        Write ((byte) (value > > 8));
        Write ((byte) value);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="135" endline="149">
internal static int GetCompressedIntLength (int value) {
    if (value <= 0x7F) {
        return 1;
    } else if (value <= 0x3FFF) {
        return 2;
    } else {
        return 4;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="151" endline="161">
internal void WriteStringIndex (int index) {
    if (bigStrings) {
        Write (index);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="163" endline="173">
internal void WriteGuidIndex (int index) {
    if (bigGuids) {
        Write (index);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="175" endline="185">
internal void WriteBlobIndex (int index) {
    if (bigBlobs) {
        Write (index);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="187" endline="213">
internal void WriteTypeDefOrRef (int token) {
    switch (token > > 24) {
        case 0 :
            break;
        case TypeDefTable.Index :
            token = (token & 0xFFFFFF) << 2 | 0;
            break;
        case TypeRefTable.Index :
            token = (token & 0xFFFFFF) << 2 | 1;
            break;
        case TypeSpecTable.Index :
            token = (token & 0xFFFFFF) << 2 | 2;
            break;
        default :
            throw new InvalidOperationException ();
    }
    if (bigTypeDefOrRef) {
        Write (token);
    } else {
        Write ((short) token);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="215" endline="225">
internal void WriteEncodedTypeDefOrRef (int encodedToken) {
    if (bigTypeDefOrRef) {
        Write (encodedToken);
    } else {
        Write ((short) encodedToken);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="227" endline="239">
internal void WriteHasCustomAttribute (int encodedToken) {
    if (bigHasCustomAttribute) {
        Write (encodedToken);
    } else {
        Write ((short) encodedToken);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="241" endline="262">
internal void WriteCustomAttributeType (int token) {
    switch (token > > 24) {
        case MethodDefTable.Index :
            token = (token & 0xFFFFFF) << 3 | 2;
            break;
        case MemberRefTable.Index :
            token = (token & 0xFFFFFF) << 3 | 3;
            break;
        default :
            throw new InvalidOperationException ();
    }
    if (bigCustomAttributeType) {
        Write (token);
    } else {
        Write ((short) token);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="264" endline="274">
internal void WriteField (int index) {
    if (bigField) {
        Write (index & 0xFFFFFF);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="276" endline="286">
internal void WriteMethodDef (int index) {
    if (bigMethodDef) {
        Write (index & 0xFFFFFF);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="288" endline="298">
internal void WriteParam (int index) {
    if (bigParam) {
        Write (index & 0xFFFFFF);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="300" endline="310">
internal void WriteTypeDef (int index) {
    if (bigTypeDef) {
        Write (index & 0xFFFFFF);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="312" endline="322">
internal void WriteEvent (int index) {
    if (bigEvent) {
        Write (index & 0xFFFFFF);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="324" endline="334">
internal void WriteProperty (int index) {
    if (bigProperty) {
        Write (index & 0xFFFFFF);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="336" endline="346">
internal void WriteGenericParam (int index) {
    if (bigGenericParam) {
        Write (index & 0xFFFFFF);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="348" endline="358">
internal void WriteModuleRef (int index) {
    if (bigModuleRef) {
        Write (index & 0xFFFFFF);
    } else {
        Write ((short) index);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="360" endline="387">
internal void WriteResolutionScope (int token) {
    switch (token > > 24) {
        case ModuleTable.Index :
            token = (token & 0xFFFFFF) << 2 | 0;
            break;
        case ModuleRefTable.Index :
            token = (token & 0xFFFFFF) << 2 | 1;
            break;
        case AssemblyRefTable.Index :
            token = (token & 0xFFFFFF) << 2 | 2;
            break;
        case TypeRefTable.Index :
            token = (token & 0xFFFFFF) << 2 | 3;
            break;
        default :
            throw new InvalidOperationException ();
    }
    if (bigResolutionScope) {
        Write (token);
    } else {
        Write ((short) token);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="389" endline="419">
internal void WriteMemberRefParent (int token) {
    switch (token > > 24) {
        case TypeDefTable.Index :
            token = (token & 0xFFFFFF) << 3 | 0;
            break;
        case TypeRefTable.Index :
            token = (token & 0xFFFFFF) << 3 | 1;
            break;
        case ModuleRefTable.Index :
            token = (token & 0xFFFFFF) << 3 | 2;
            break;
        case MethodDefTable.Index :
            token = (token & 0xFFFFFF) << 3 | 3;
            break;
        case TypeSpecTable.Index :
            token = (token & 0xFFFFFF) << 3 | 4;
            break;
        default :
            throw new InvalidOperationException ();
    }
    if (bigMemberRefParent) {
        Write (token);
    } else {
        Write ((short) token);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="421" endline="442">
internal void WriteMethodDefOrRef (int token) {
    switch (token > > 24) {
        case MethodDefTable.Index :
            token = (token & 0xFFFFFF) << 1 | 0;
            break;
        case MemberRefTable.Index :
            token = (token & 0xFFFFFF) << 1 | 1;
            break;
        default :
            throw new InvalidOperationException ();
    }
    if (bigMethodDefOrRef) {
        Write (token);
    } else {
        Write ((short) token);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="444" endline="456">
internal void WriteHasConstant (int encodedToken) {
    if (bigHasConstant) {
        Write (encodedToken);
    } else {
        Write ((short) encodedToken);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="458" endline="470">
internal void WriteHasSemantics (int encodedToken) {
    if (bigHasSemantics) {
        Write (encodedToken);
    } else {
        Write ((short) encodedToken);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="472" endline="498">
internal void WriteImplementation (int token) {
    switch (token > > 24) {
        case 0 :
            break;
        case FileTable.Index :
            token = (token & 0xFFFFFF) << 2 | 0;
            break;
        case AssemblyRefTable.Index :
            token = (token & 0xFFFFFF) << 2 | 1;
            break;
        case ExportedTypeTable.Index :
            token = (token & 0xFFFFFF) << 2 | 2;
            break;
        default :
            throw new InvalidOperationException ();
    }
    if (bigImplementation) {
        Write (token);
    } else {
        Write ((short) token);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="500" endline="512">
internal void WriteTypeOrMethodDef (int encodedToken) {
    if (bigTypeOrMethodDef) {
        Write (encodedToken);
    } else {
        Write ((short) encodedToken);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="514" endline="526">
internal void WriteHasDeclSecurity (int encodedToken) {
    if (bigHasDeclSecurity) {
        Write (encodedToken);
    } else {
        Write ((short) encodedToken);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="528" endline="549">
internal void WriteMemberForwarded (int token) {
    switch (token > > 24) {
        case FieldTable.Index :
            token = (token & 0xFFFFFF) << 1 | 0;
            break;
        case MethodDefTable.Index :
            token = (token & 0xFFFFFF) << 1 | 1;
            break;
        default :
            throw new InvalidOperationException ();
    }
    if (bigMemberForwarded) {
        Write (token);
    } else {
        Write ((short) token);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/MetadataWriter.cs.ifdefed" startline="551" endline="563">
internal void WriteHasFieldMarshal (int encodedToken) {
    if (bigHasFieldMarshal) {
        Write (encodedToken & 0xFFFFFF);
    } else {
        Write ((short) encodedToken);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ModuleWriter.cs.ifdefed" startline="37" endline="300">
internal static void WriteModule (StrongNameKeyPair keyPair, byte [] publicKey, ModuleBuilder moduleBuilder, PEFileKinds fileKind, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine, ResourceSection resources, int entryPointToken) {
    moduleBuilder.FixupMethodBodyTokens ();
    moduleBuilder.ModuleTable.Add (0, moduleBuilder.Strings.Add (moduleBuilder.moduleName), moduleBuilder.Guids.Add (moduleBuilder.ModuleVersionId), 0, 0);
    if (moduleBuilder.UserStrings.IsEmpty) {
        moduleBuilder.UserStrings.Add (" ");
    }
    if (resources != null) {
        resources.Finish ();
    }
    using (FileStream fs = new FileStream (moduleBuilder.FullyQualifiedName, FileMode.Create))
    {
        PEWriter writer = new PEWriter (fs);
        switch (imageFileMachine) {
            case ImageFileMachine.I386 :
                writer.Headers.FileHeader.Machine = IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386;
                writer.Headers.FileHeader.Characteristics |= IMAGE_FILE_HEADER.IMAGE_FILE_32BIT_MACHINE;
                break;
            case ImageFileMachine.AMD64 :
                writer.Headers.FileHeader.Machine = IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64;
                writer.Headers.FileHeader.Characteristics |= IMAGE_FILE_HEADER.IMAGE_FILE_LARGE_ADDRESS_AWARE;
                writer.Headers.FileHeader.SizeOfOptionalHeader = 0xF0;
                writer.Headers.OptionalHeader.Magic = IMAGE_OPTIONAL_HEADER.IMAGE_NT_OPTIONAL_HDR64_MAGIC;
                writer.Headers.OptionalHeader.SizeOfStackReserve = 0x400000;
                writer.Headers.OptionalHeader.SizeOfStackCommit = 0x4000;
                writer.Headers.OptionalHeader.SizeOfHeapCommit = 0x2000;
                break;
            case ImageFileMachine.IA64 :
                writer.Headers.FileHeader.Machine = IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64;
                writer.Headers.FileHeader.Characteristics |= IMAGE_FILE_HEADER.IMAGE_FILE_LARGE_ADDRESS_AWARE;
                writer.Headers.FileHeader.SizeOfOptionalHeader = 0xF0;
                writer.Headers.OptionalHeader.Magic = IMAGE_OPTIONAL_HEADER.IMAGE_NT_OPTIONAL_HDR64_MAGIC;
                writer.Headers.OptionalHeader.SizeOfStackReserve = 0x400000;
                writer.Headers.OptionalHeader.SizeOfStackCommit = 0x4000;
                writer.Headers.OptionalHeader.SizeOfHeapCommit = 0x2000;
                break;
            default :
                throw new ArgumentOutOfRangeException ("imageFileMachine");
        }
        if (fileKind == PEFileKinds.Dll) {
            writer.Headers.FileHeader.Characteristics |= IMAGE_FILE_HEADER.IMAGE_FILE_DLL;
        }
        switch (fileKind) {
            case PEFileKinds.WindowApplication :
                writer.Headers.OptionalHeader.Subsystem = IMAGE_OPTIONAL_HEADER.IMAGE_SUBSYSTEM_WINDOWS_GUI;
                break;
            default :
                writer.Headers.OptionalHeader.Subsystem = IMAGE_OPTIONAL_HEADER.IMAGE_SUBSYSTEM_WINDOWS_CUI;
                break;
        }
        writer.Headers.OptionalHeader.DllCharacteristics = IMAGE_OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE | IMAGE_OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_NO_SEH | IMAGE_OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_NX_COMPAT | IMAGE_OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE;
        CliHeader cliHeader = new CliHeader ();
        cliHeader.Cb = 0x48;
        cliHeader.MajorRuntimeVersion = 2;
        cliHeader.MinorRuntimeVersion = moduleBuilder.MDStreamVersion < 0x20000 ? (ushort) 0 : (ushort) 5;
        if ((portableExecutableKind & PortableExecutableKinds.ILOnly) != 0) {
            cliHeader.Flags |= CliHeader.COMIMAGE_FLAGS_ILONLY;
        }
        if ((portableExecutableKind & PortableExecutableKinds.Required32Bit) != 0) {
            cliHeader.Flags |= CliHeader.COMIMAGE_FLAGS_32BITREQUIRED;
        }
        if (keyPair != null) {
            cliHeader.Flags |= CliHeader.COMIMAGE_FLAGS_STRONGNAMESIGNED;
        }
        if (moduleBuilder.IsPseudoToken (entryPointToken)) {
            entryPointToken = moduleBuilder.ResolvePseudoToken (entryPointToken);
        }
        cliHeader.EntryPointToken = (uint) entryPointToken;
        moduleBuilder.Strings.Freeze ();
        moduleBuilder.UserStrings.Freeze ();
        moduleBuilder.Guids.Freeze ();
        moduleBuilder.Blobs.Freeze ();
        MetadataWriter mw = new MetadataWriter (moduleBuilder, fs);
        moduleBuilder.Tables.Freeze (mw);
        TextSection code = new TextSection (writer, cliHeader, moduleBuilder, ComputeStrongNameSignatureLength (publicKey));
        writer.Headers.OptionalHeader.DataDirectory [1].VirtualAddress = code.ImportDirectoryRVA;
        writer.Headers.OptionalHeader.DataDirectory [1].Size = code.ImportDirectoryLength;
        writer.Headers.OptionalHeader.DataDirectory [12].VirtualAddress = code.ImportAddressTableRVA;
        writer.Headers.OptionalHeader.DataDirectory [12].Size = code.ImportAddressTableLength;
        writer.Headers.OptionalHeader.DataDirectory [14].VirtualAddress = code.ComDescriptorRVA;
        writer.Headers.OptionalHeader.DataDirectory [14].Size = code.ComDescriptorLength;
        if (code.DebugDirectoryLength != 0) {
            writer.Headers.OptionalHeader.DataDirectory [6].VirtualAddress = code.DebugDirectoryRVA;
            writer.Headers.OptionalHeader.DataDirectory [6].Size = code.DebugDirectoryLength;
        }
        writer.Headers.FileHeader.NumberOfSections = 2;
        if (moduleBuilder.initializedData.Length != 0) {
            writer.Headers.FileHeader.NumberOfSections ++;
        }
        if (resources != null && resources.Length != 0) {
            writer.Headers.FileHeader.NumberOfSections ++;
        }
        SectionHeader text = new SectionHeader ();
        text.Name = ".text";
        text.VirtualAddress = code.BaseRVA;
        text.VirtualSize = (uint) code.Length;
        text.PointerToRawData = code.PointerToRawData;
        text.SizeOfRawData = writer.ToFileAlignment ((uint) code.Length);
        text.Characteristics = SectionHeader.IMAGE_SCN_CNT_CODE | SectionHeader.IMAGE_SCN_MEM_EXECUTE | SectionHeader.IMAGE_SCN_MEM_READ;
        SectionHeader sdata = new SectionHeader ();
        sdata.Name = ".sdata";
        sdata.VirtualAddress = text.VirtualAddress + writer.ToSectionAlignment (text.VirtualSize);
        sdata.VirtualSize = (uint) moduleBuilder.initializedData.Length;
        sdata.PointerToRawData = text.PointerToRawData + text.SizeOfRawData;
        sdata.SizeOfRawData = writer.ToFileAlignment ((uint) moduleBuilder.initializedData.Length);
        sdata.Characteristics = SectionHeader.IMAGE_SCN_CNT_INITIALIZED_DATA | SectionHeader.IMAGE_SCN_MEM_READ | SectionHeader.IMAGE_SCN_MEM_WRITE;
        SectionHeader rsrc = new SectionHeader ();
        rsrc.Name = ".rsrc";
        rsrc.VirtualAddress = sdata.VirtualAddress + writer.ToSectionAlignment (sdata.VirtualSize);
        rsrc.PointerToRawData = sdata.PointerToRawData + sdata.SizeOfRawData;
        rsrc.VirtualSize = resources == null ? 0 : (uint) resources.Length;
        rsrc.SizeOfRawData = writer.ToFileAlignment (rsrc.VirtualSize);
        rsrc.Characteristics = SectionHeader.IMAGE_SCN_MEM_READ | SectionHeader.IMAGE_SCN_CNT_INITIALIZED_DATA;
        if (rsrc.SizeOfRawData != 0) {
            writer.Headers.OptionalHeader.DataDirectory [2].VirtualAddress = rsrc.VirtualAddress;
            writer.Headers.OptionalHeader.DataDirectory [2].Size = rsrc.VirtualSize;
        }
        SectionHeader reloc = new SectionHeader ();
        reloc.Name = ".reloc";
        reloc.VirtualAddress = rsrc.VirtualAddress + writer.ToSectionAlignment (rsrc.VirtualSize);
        reloc.VirtualSize = 12;
        reloc.PointerToRawData = rsrc.PointerToRawData + rsrc.SizeOfRawData;
        reloc.SizeOfRawData = writer.ToFileAlignment (reloc.VirtualSize);
        reloc.Characteristics = SectionHeader.IMAGE_SCN_MEM_READ | SectionHeader.IMAGE_SCN_CNT_INITIALIZED_DATA | SectionHeader.IMAGE_SCN_MEM_DISCARDABLE;
        writer.Headers.OptionalHeader.DataDirectory [5].VirtualAddress = reloc.VirtualAddress;
        writer.Headers.OptionalHeader.DataDirectory [5].Size = reloc.VirtualSize;
        writer.Headers.OptionalHeader.SizeOfCode = text.SizeOfRawData;
        writer.Headers.OptionalHeader.SizeOfInitializedData = sdata.SizeOfRawData + rsrc.SizeOfRawData + reloc.SizeOfRawData;
        writer.Headers.OptionalHeader.SizeOfUninitializedData = 0;
        writer.Headers.OptionalHeader.SizeOfImage = reloc.VirtualAddress + writer.ToSectionAlignment (reloc.VirtualSize);
        writer.Headers.OptionalHeader.SizeOfHeaders = text.PointerToRawData;
        writer.Headers.OptionalHeader.BaseOfCode = code.BaseRVA;
        writer.Headers.OptionalHeader.BaseOfData = sdata.VirtualAddress;
        writer.Headers.OptionalHeader.ImageBase = (ulong) moduleBuilder.__ImageBase;
        if (imageFileMachine == ImageFileMachine.IA64) {
            writer.Headers.OptionalHeader.AddressOfEntryPoint = code.StartupStubRVA + 0x20;
        } else {
            writer.Headers.OptionalHeader.AddressOfEntryPoint = code.StartupStubRVA;
        }
        writer.WritePEHeaders ();
        writer.WriteSectionHeader (text);
        if (sdata.SizeOfRawData != 0) {
            writer.WriteSectionHeader (sdata);
        }
        if (rsrc.SizeOfRawData != 0) {
            writer.WriteSectionHeader (rsrc);
        }
        writer.WriteSectionHeader (reloc);
        fs.Seek (text.PointerToRawData, SeekOrigin.Begin);
        code.Write (mw, (int) sdata.VirtualAddress);
        fs.Seek (sdata.PointerToRawData, SeekOrigin.Begin);
        mw.Write (moduleBuilder.initializedData);
        if (rsrc.SizeOfRawData != 0) {
            fs.Seek (rsrc.PointerToRawData, SeekOrigin.Begin);
            resources.Write (mw, rsrc.VirtualAddress);
        }
        fs.Seek (reloc.PointerToRawData, SeekOrigin.Begin);
        uint relocAddress = code.StartupStubRVA;
        switch (imageFileMachine) {
            case ImageFileMachine.I386 : case ImageFileMachine.AMD64 :
                relocAddress += 2;
                break;
            case ImageFileMachine.IA64 :
                relocAddress += 0x20;
                break;
        }
        uint pageRVA = relocAddress & ~ 0xFFFU;
        mw.Write (pageRVA);
        mw.Write (0x000C);
        if (imageFileMachine == ImageFileMachine.I386) {
            mw.Write (0x3000 + relocAddress - pageRVA);
        } else if (imageFileMachine == ImageFileMachine.AMD64) {
            mw.Write (0xA000 + relocAddress - pageRVA);
        } else if (imageFileMachine == ImageFileMachine.IA64) {
            mw.Write ((short) (0xA000 + relocAddress - pageRVA));
            mw.Write ((short) (0xA000 + relocAddress - pageRVA + 8));
        }
        mw.Write (new byte [writer.Headers.OptionalHeader.FileAlignment - reloc.VirtualSize]);
        if (keyPair != null) {
            StrongName (fs, keyPair, writer.HeaderSize, text.PointerToRawData, code.StrongNameSignatureRVA - text.VirtualAddress + text.PointerToRawData, code.StrongNameSignatureLength);
        }
    } if (moduleBuilder.symbolWriter != null) {
        moduleBuilder.WriteSymbolTokenMap ();
        moduleBuilder.symbolWriter.Close ();
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ModuleWriter.cs.ifdefed" startline="302" endline="319">
private static int ComputeStrongNameSignatureLength (byte [] publicKey) {
    if (publicKey == null) {
        return 0;
    } else if (publicKey.Length == 16) {
        return 128;
    } else {
        return publicKey.Length - 32;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ModuleWriter.cs.ifdefed" startline="321" endline="370">
private static void StrongName (FileStream fs, StrongNameKeyPair keyPair, uint headerLength, uint textSectionFileOffset, uint strongNameSignatureFileOffset, uint strongNameSignatureLength) {
    SHA1Managed hash = new SHA1Managed ();
    using (CryptoStream cs = new CryptoStream (Stream.Null, hash, CryptoStreamMode.Write))
    {
        fs.Seek (0, SeekOrigin.Begin);
        byte [] buf = new byte [8192];
        HashChunk (fs, cs, buf, (int) headerLength);
        fs.Seek (textSectionFileOffset, SeekOrigin.Begin);
        HashChunk (fs, cs, buf, (int) (strongNameSignatureFileOffset - textSectionFileOffset));
        fs.Seek (strongNameSignatureLength, SeekOrigin.Current);
        HashChunk (fs, cs, buf, (int) (fs.Length - (strongNameSignatureFileOffset + strongNameSignatureLength)));
    } using (RSA rsa = CryptoHack.CreateRSA (keyPair))
    {
        RSAPKCS1SignatureFormatter sign = new RSAPKCS1SignatureFormatter (rsa);
        byte [] signature = sign.CreateSignature (hash);
        Array.Reverse (signature);
        if (signature.Length != strongNameSignatureLength) {
            throw new InvalidOperationException ("Signature length mismatch");
        }
        fs.Seek (strongNameSignatureFileOffset, SeekOrigin.Begin);
        fs.Write (signature, 0, signature.Length);
    } fs.Seek (0, SeekOrigin.Begin);
    int count = (int) fs.Length / 4;
    BinaryReader br = new BinaryReader (fs);
    long sum = 0;
    for (int i = 0; i < count; i ++) {
        sum += br.ReadUInt32 ();
        int carry = (int) (sum > > 32);
        sum &= 0xFFFFFFFFU;
        sum += carry;
    }
    while ((sum > > 16) != 0) {
        sum = (sum & 0xFFFF) + (sum > > 16);
    }
    sum += fs.Length;
    ByteBuffer bb = new ByteBuffer (4);
    bb.Write ((int) sum);
    fs.Seek (0xD8, SeekOrigin.Begin);
    bb.WriteTo (fs);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ModuleWriter.cs.ifdefed" startline="372" endline="380">
internal static void HashChunk (FileStream fs, CryptoStream cs, byte [] buf, int length) {
    while (length > 0) {
        int read = fs.Read (buf, 0, Math.Min (buf.Length, length));
        cs.Write (buf, 0, read);
        length -= read;
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/PEWriter.cs.ifdefed" startline="62" endline="82">
private void WriteMSDOSHeader () {
    bw.Write (new byte [] {0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00});
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/PEWriter.cs.ifdefed" startline="84" endline="99">
internal void WritePEHeaders () {
    bw.Write (hdr.Signature);
    bw.Write (hdr.FileHeader.Machine);
    bw.Write (hdr.FileHeader.NumberOfSections);
    bw.Write (hdr.FileHeader.TimeDateStamp);
    bw.Write (hdr.FileHeader.PointerToSymbolTable);
    bw.Write (hdr.FileHeader.NumberOfSymbols);
    bw.Write (hdr.FileHeader.SizeOfOptionalHeader);
    bw.Write (hdr.FileHeader.Characteristics);
    hdr.OptionalHeader.Write (bw);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/PEWriter.cs.ifdefed" startline="101" endline="115">
internal void WriteSectionHeader (SectionHeader sectionHeader) {
    byte [] name = new byte [8];
    System.Text.Encoding.UTF8.GetBytes (sectionHeader.Name, 0, sectionHeader.Name.Length, name, 0);
    bw.Write (name);
    bw.Write (sectionHeader.VirtualSize);
    bw.Write (sectionHeader.VirtualAddress);
    bw.Write (sectionHeader.SizeOfRawData);
    bw.Write (sectionHeader.PointerToRawData);
    bw.Write (sectionHeader.PointerToRelocations);
    bw.Write (sectionHeader.PointerToLinenumbers);
    bw.Write (sectionHeader.NumberOfRelocations);
    bw.Write (sectionHeader.NumberOfLinenumbers);
    bw.Write (sectionHeader.Characteristics);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/PEWriter.cs.ifdefed" startline="117" endline="120">
internal uint ToFileAlignment (uint p) {
    return (p + (Headers.OptionalHeader.FileAlignment - 1)) & ~ (Headers.OptionalHeader.FileAlignment - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/PEWriter.cs.ifdefed" startline="122" endline="125">
internal uint ToSectionAlignment (uint p) {
    return (p + (Headers.OptionalHeader.SectionAlignment - 1)) & ~ (Headers.OptionalHeader.SectionAlignment - 1);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/PEWriter.cs.ifdefed" startline="200" endline="272">
internal void Write (BinaryWriter bw) {
    bw.Write (Magic);
    bw.Write (MajorLinkerVersion);
    bw.Write (MinorLinkerVersion);
    bw.Write (SizeOfCode);
    bw.Write (SizeOfInitializedData);
    bw.Write (SizeOfUninitializedData);
    bw.Write (AddressOfEntryPoint);
    bw.Write (BaseOfCode);
    if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        bw.Write (BaseOfData);
        bw.Write ((DWORD) ImageBase);
    } else {
        bw.Write (ImageBase);
    }
    bw.Write (SectionAlignment);
    bw.Write (FileAlignment);
    bw.Write (MajorOperatingSystemVersion);
    bw.Write (MinorOperatingSystemVersion);
    bw.Write (MajorImageVersion);
    bw.Write (MinorImageVersion);
    bw.Write (MajorSubsystemVersion);
    bw.Write (MinorSubsystemVersion);
    bw.Write (Win32VersionValue);
    bw.Write (SizeOfImage);
    bw.Write (SizeOfHeaders);
    bw.Write (CheckSum);
    bw.Write (Subsystem);
    bw.Write (DllCharacteristics);
    if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        bw.Write ((DWORD) SizeOfStackReserve);
    } else {
        bw.Write (SizeOfStackReserve);
    }
    if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        bw.Write ((DWORD) SizeOfStackCommit);
    } else {
        bw.Write (SizeOfStackCommit);
    }
    if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        bw.Write ((DWORD) SizeOfHeapReserve);
    } else {
        bw.Write (SizeOfHeapReserve);
    }
    if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        bw.Write ((DWORD) SizeOfHeapCommit);
    } else {
        bw.Write (SizeOfHeapCommit);
    }
    bw.Write (LoaderFlags);
    bw.Write (NumberOfRvaAndSizes);
    for (int i = 0; i < DataDirectory.Length; i ++) {
        bw.Write (DataDirectory [i].VirtualAddress);
        bw.Write (DataDirectory [i].Size);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="41" endline="44">
internal void AddVersionInfo (ByteBuffer versionInfo) {
    root [new OrdinalOrName (RT_VERSION)] [new OrdinalOrName (1)] [new OrdinalOrName (0)].Data = versionInfo;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="46" endline="88">
internal void AddIcon (byte [] iconFile) {
    BinaryReader br = new BinaryReader (new MemoryStream (iconFile));
    ushort idReserved = br.ReadUInt16 ();
    ushort idType = br.ReadUInt16 ();
    ushort idCount = br.ReadUInt16 ();
    if (idReserved != 0 || idType != 1) {
        throw new ArgumentException ("The supplied byte array is not a valid .ico file.");
    }
    ByteBuffer group = new ByteBuffer (6 + 14 * idCount);
    group.Write (idReserved);
    group.Write (idType);
    group.Write (idCount);
    for (int i = 0; i < idCount; i ++) {
        byte bWidth = br.ReadByte ();
        byte bHeight = br.ReadByte ();
        byte bColorCount = br.ReadByte ();
        byte bReserved = br.ReadByte ();
        ushort wPlanes = br.ReadUInt16 ();
        ushort wBitCount = br.ReadUInt16 ();
        uint dwBytesInRes = br.ReadUInt32 ();
        uint dwImageOffset = br.ReadUInt32 ();
        ushort id = (ushort) (2 + i);
        group.Write (bWidth);
        group.Write (bHeight);
        group.Write (bColorCount);
        group.Write (bReserved);
        group.Write (wPlanes);
        group.Write (wBitCount);
        group.Write (dwBytesInRes);
        group.Write (id);
        byte [] icon = new byte [dwBytesInRes];
        Buffer.BlockCopy (iconFile, (int) dwImageOffset, icon, 0, icon.Length);
        root [new OrdinalOrName (RT_ICON)] [new OrdinalOrName (id)] [new OrdinalOrName (0)].Data = ByteBuffer.Wrap (icon);
    }
    root [new OrdinalOrName (RT_GROUP_ICON)] [new OrdinalOrName (32512)] [new OrdinalOrName (0)].Data = group;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="90" endline="102">
internal void ExtractResources (byte [] buf) {
    ByteReader br = new ByteReader (buf, 0, buf.Length);
    while (br.Length >= 32) {
        br.Align (4);
        RESOURCEHEADER hdr = new RESOURCEHEADER (br);
        if (hdr.DataSize != 0) {
            root [hdr.TYPE] [hdr.NAME] [new OrdinalOrName (hdr.LanguageId)].Data = ByteBuffer.Wrap (br.ReadBytes (hdr.DataSize));
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="104" endline="114">
internal void Finish () {
    if (bb != null) {
        throw new InvalidOperationException ();
    }
    bb = new ByteBuffer (1024);
    linkOffsets = new List < int > ();
    root.Write (bb, linkOffsets);
    root = null;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="121" endline="129">
internal void Write (MetadataWriter mw, uint rva) {
    foreach (int offset in linkOffsets) {
        bb.Position = offset;
        bb.Write (bb.GetInt32AtCurrentPosition () + (int) rva);
    }
    mw.Write (bb);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="188" endline="208">
internal void Write (ByteBuffer bb, List < int > linkOffsets) {
    if (entries.Count != 0) {
        int stringTableOffset = this.DirectoryLength;
        Dictionary < string, int > strings = new Dictionary < string, int > ();
        ByteBuffer stringTable = new ByteBuffer (16);
        int offset = 16 + entries.Count * 8;
        for (int pass = 0; pass < 3; pass ++) {
            Write (bb, pass, 0, ref offset, strings, ref stringTableOffset, stringTable);
        }
        stringTable.Align (4);
        offset += stringTable.Length;
        WriteResourceDataEntries (bb, linkOffsets, ref offset);
        bb.Write (stringTable);
        WriteData (bb);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="210" endline="228">
private void WriteResourceDataEntries (ByteBuffer bb, List < int > linkOffsets, ref int offset) {
    foreach (ResourceDirectoryEntry entry in entries) {
        if (entry.Data != null) {
            linkOffsets.Add (bb.Position);
            bb.Write (offset);
            bb.Write (entry.Data.Length);
            bb.Write (0);
            bb.Write (0);
            offset += (entry.Data.Length + 3) & ~ 3;
        } else {
            entry.WriteResourceDataEntries (bb, linkOffsets, ref offset);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="230" endline="244">
private void WriteData (ByteBuffer bb) {
    foreach (ResourceDirectoryEntry entry in entries) {
        if (entry.Data != null) {
            bb.Write (entry.Data);
            bb.Align (4);
        } else {
            entry.WriteData (bb);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="246" endline="268">
private void Write (ByteBuffer bb, int writeDepth, int currentDepth, ref int offset, Dictionary < string, int > strings, ref int stringTableOffset, ByteBuffer stringTable) {
    if (currentDepth == writeDepth) {
        bb.Write (0);
        bb.Write (0);
        bb.Write (0);
        bb.Write ((ushort) namedEntries);
        bb.Write ((ushort) (entries.Count - namedEntries));
    }
    foreach (ResourceDirectoryEntry entry in entries) {
        if (currentDepth == writeDepth) {
            entry.WriteEntry (bb, ref offset, strings, ref stringTableOffset, stringTable);
        } else {
            entry.Write (bb, writeDepth, currentDepth + 1, ref offset, strings, ref stringTableOffset, stringTable);
        }
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="270" endline="282">
private void WriteEntry (ByteBuffer bb, ref int offset, Dictionary < string, int > strings, ref int stringTableOffset, ByteBuffer stringTable) {
    WriteNameOrOrdinal (bb, OrdinalOrName, strings, ref stringTableOffset, stringTable);
    if (Data == null) {
        bb.Write (0x80000000U | (uint) offset);
    } else {
        bb.Write (offset);
    }
    offset += 16 + entries.Count * 8;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="284" endline="306">
private static void WriteNameOrOrdinal (ByteBuffer bb, OrdinalOrName id, Dictionary < string, int > strings, ref int stringTableOffset, ByteBuffer stringTable) {
    if (id.Name == null) {
        bb.Write ((int) id.Ordinal);
    } else {
        int stringOffset;
        if (! strings.TryGetValue (id.Name, out stringOffset)) {
            stringOffset = stringTableOffset;
            strings.Add (id.Name, stringOffset);
            stringTableOffset += id.Name.Length * 2 + 2;
            stringTable.Write ((ushort) id.Name.Length);
            foreach (char c in id.Name) {
                stringTable.Write ((short) c);
            }
        }
        bb.Write (0x80000000U | (uint) stringOffset);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/ResourceSection.cs.ifdefed" startline="353" endline="370">
private static OrdinalOrName ReadOrdinalOrName (ByteReader br) {
    char c = br.ReadChar ();
    if (c == 0xFFFF) {
        return new OrdinalOrName (br.ReadUInt16 ());
    } else {
        StringBuilder sb = new StringBuilder ();
        while (c != 0) {
            sb.Append (c);
            c = br.ReadChar ();
        }
        return new OrdinalOrName (sb.ToString ());
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/TextSection.cs.ifdefed" startline="241" endline="251">
private void WriteRVA (MetadataWriter mw, uint rva) {
    if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386) {
        mw.Write (rva);
    } else {
        mw.Write ((ulong) rva);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/TextSection.cs.ifdefed" startline="253" endline="370">
internal void Write (MetadataWriter mw, int sdataRVA) {
    moduleBuilder.MethodDef.Fixup (this);
    moduleBuilder.MethodImpl.Fixup (moduleBuilder);
    moduleBuilder.MethodSemantics.Fixup (moduleBuilder);
    moduleBuilder.InterfaceImpl.Fixup ();
    moduleBuilder.MemberRef.Fixup (moduleBuilder);
    moduleBuilder.Constant.Fixup (moduleBuilder);
    moduleBuilder.FieldMarshal.Fixup (moduleBuilder);
    moduleBuilder.DeclSecurity.Fixup (moduleBuilder);
    moduleBuilder.GenericParam.Fixup (moduleBuilder);
    moduleBuilder.CustomAttribute.Fixup (moduleBuilder);
    moduleBuilder.FieldLayout.Fixup (moduleBuilder);
    moduleBuilder.FieldRVA.Fixup (moduleBuilder, sdataRVA);
    moduleBuilder.ImplMap.Fixup (moduleBuilder);
    moduleBuilder.MethodSpec.Fixup (moduleBuilder);
    moduleBuilder.GenericParamConstraint.Fixup (moduleBuilder);
    AssertRVA (mw, ImportAddressTableRVA);
    WriteRVA (mw, ImportHintNameTableRVA);
    WriteRVA (mw, 0);
    AssertRVA (mw, ComDescriptorRVA);
    cliHeader.MetaDataRVA = MetadataRVA;
    cliHeader.MetaDataSize = MetadataLength;
    if (ResourcesLength != 0) {
        cliHeader.ResourcesRVA = ResourcesRVA;
        cliHeader.ResourcesSize = ResourcesLength;
    }
    if (StrongNameSignatureLength != 0) {
        cliHeader.StrongNameSignatureRVA = StrongNameSignatureRVA;
        cliHeader.StrongNameSignatureSize = StrongNameSignatureLength;
    }
    cliHeader.Write (mw);
    for (int i = (int) (MethodBodiesRVA - (ComDescriptorRVA + ComDescriptorLength)); i > 0; i --) {
        mw.Write ((byte) 0);
    }
    mw.Write (moduleBuilder.methodBodies);
    for (int i = (int) (ResourcesRVA - (MethodBodiesRVA + MethodBodiesLength)); i > 0; i --) {
        mw.Write ((byte) 0);
    }
    mw.Write (moduleBuilder.manifestResources);
    for (int i = (int) (MetadataRVA - (ResourcesRVA + ResourcesLength)); i > 0; i --) {
        mw.Write ((byte) 0);
    }
    AssertRVA (mw, MetadataRVA);
    moduleBuilder.WriteMetadata (mw);
    AssertRVA (mw, DebugDirectoryRVA);
    WriteDebugDirectory (mw);
    for (int i = (int) (ImportDirectoryRVA - (DebugDirectoryRVA + DebugDirectoryLength + DebugDirectoryContentsLength)); i > 0; i --) {
        mw.Write ((byte) 0);
    }
    AssertRVA (mw, ImportDirectoryRVA);
    WriteImportDirectory (mw);
    for (int i = (int) (StartupStubRVA - (ImportDirectoryRVA + ImportDirectoryLength)); i > 0; i --) {
        mw.Write ((byte) 0);
    }
    AssertRVA (mw, StartupStubRVA);
    if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64) {
        mw.Write ((ushort) 0xA148);
        mw.Write (peWriter.Headers.OptionalHeader.ImageBase + ImportAddressTableRVA);
        mw.Write ((ushort) 0xE0FF);
    } else if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64) {
        mw.Write (new byte [] {0x0B, 0x48, 0x00, 0x02, 0x18, 0x10, 0xA0, 0x40, 0x24, 0x30, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x10, 0x08, 0x00, 0x12, 0x18, 0x10, 0x60, 0x50, 0x04, 0x80, 0x03, 0x00, 0x60, 0x00, 0x80, 0x00});
        mw.Write (peWriter.Headers.OptionalHeader.ImageBase + StartupStubRVA);
        mw.Write (peWriter.Headers.OptionalHeader.ImageBase + BaseRVA);
    } else {
        mw.Write ((ushort) 0x25FF);
        mw.Write ((uint) peWriter.Headers.OptionalHeader.ImageBase + ImportAddressTableRVA);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/TextSection.cs.ifdefed" startline="372" endline="376">
[Conditional ("DEBUG")] private void AssertRVA (MetadataWriter mw, uint rva) {
    Debug.Assert (mw.Position - PointerToRawData + BaseRVA == rva);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/TextSection.cs.ifdefed" startline="378" endline="397">
private void WriteDebugDirectory (MetadataWriter mw) {
    if (DebugDirectoryLength != 0) {
        IMAGE_DEBUG_DIRECTORY idd = new IMAGE_DEBUG_DIRECTORY ();
        idd.Characteristics = 0;
        idd.TimeDateStamp = peWriter.Headers.FileHeader.TimeDateStamp;
        byte [] buf = SymbolSupport.GetDebugInfo (moduleBuilder.symbolWriter, ref idd);
        idd.PointerToRawData = (DebugDirectoryRVA - BaseRVA) + DebugDirectoryLength + PointerToRawData;
        mw.Write (idd.Characteristics);
        mw.Write (idd.TimeDateStamp);
        mw.Write (idd.MajorVersion);
        mw.Write (idd.MinorVersion);
        mw.Write (idd.Type);
        mw.Write (idd.SizeOfData);
        mw.Write (idd.AddressOfRawData);
        mw.Write (idd.PointerToRawData);
        mw.Write (buf);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/TextSection.cs.ifdefed" startline="399" endline="438">
private void WriteImportDirectory (MetadataWriter mw) {
    mw.Write (ImportDirectoryRVA + 40);
    mw.Write (0);
    mw.Write (0);
    mw.Write (ImportHintNameTableRVA + 14);
    mw.Write (ImportAddressTableRVA);
    mw.Write (new byte [20]);
    mw.Write (ImportHintNameTableRVA);
    int size = 48;
    if (peWriter.Headers.FileHeader.Machine != IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386) {
        size += 4;
        mw.Write (0);
    }
    mw.Write (0);
    for (int i = (int) (ImportHintNameTableRVA - (ImportDirectoryRVA + size)); i > 0; i --) {
        mw.Write ((byte) 0);
    }
    AssertRVA (mw, ImportHintNameTableRVA);
    mw.Write ((ushort) 0);
    if ((peWriter.Headers.FileHeader.Characteristics & IMAGE_FILE_HEADER.IMAGE_FILE_DLL) != 0) {
        mw.Write (System.Text.Encoding.ASCII.GetBytes ("_CorDllMain"));
    } else {
        mw.Write (System.Text.Encoding.ASCII.GetBytes ("_CorExeMain"));
    }
    mw.Write ((byte) 0);
    mw.Write (System.Text.Encoding.ASCII.GetBytes ("mscoree.dll"));
    mw.Write ((ushort) 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/VersionInfo.cs.ifdefed" startline="44" endline="47">
internal void SetName (AssemblyName name) {
    this.name = name;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/VersionInfo.cs.ifdefed" startline="49" endline="52">
internal void SetFileName (string assemblyFileName) {
    this.fileName = assemblyFileName;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/VersionInfo.cs.ifdefed" startline="54" endline="94">
internal void SetAttribute (CustomAttributeBuilder cab) {
    Universe u = cab.Constructor.Module.universe;
    Type type = cab.Constructor.DeclaringType;
    if (copyright == null && type == u.System_Reflection_AssemblyCopyrightAttribute) {
        copyright = (string) cab.GetConstructorArgument (0);
    } else if (trademark == null && type == u.System_Reflection_AssemblyTrademarkAttribute) {
        trademark = (string) cab.GetConstructorArgument (0);
    } else if (product == null && type == u.System_Reflection_AssemblyProductAttribute) {
        product = (string) cab.GetConstructorArgument (0);
    } else if (company == null && type == u.System_Reflection_AssemblyCompanyAttribute) {
        company = (string) cab.GetConstructorArgument (0);
    } else if (description == null && type == u.System_Reflection_AssemblyDescriptionAttribute) {
        description = (string) cab.GetConstructorArgument (0);
    } else if (title == null && type == u.System_Reflection_AssemblyTitleAttribute) {
        title = (string) cab.GetConstructorArgument (0);
    } else if (informationalVersion == null && type == u.System_Reflection_AssemblyInformationalVersionAttribute) {
        informationalVersion = (string) cab.GetConstructorArgument (0);
    } else if (culture == null && type == u.System_Reflection_AssemblyCultureAttribute) {
        culture = (string) cab.GetConstructorArgument (0);
    } else if (fileVersion == null && type == u.System_Reflection_AssemblyFileVersionAttribute) {
        fileVersion = (string) cab.GetConstructorArgument (0);
    }
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/VersionInfo.cs.ifdefed" startline="96" endline="217">
internal void Write (ByteBuffer bb) {
    if (fileVersion == null) {
        if (name.Version != null) {
            fileVersion = name.Version.ToString ();
        } else {
            fileVersion = "0.0.0.0";
        }
    }
    int codepage = 1200;
    int lcid = 0x7f;
    if (name.CultureInfo != null) {
        lcid = name.CultureInfo.LCID;
    }
    if (culture != null) {
        lcid = new CultureInfo (culture).LCID;
    }
    Version filever = ParseVersionRobust (fileVersion);
    int fileVersionMajor = filever.Major;
    int fileVersionMinor = filever.Minor;
    int fileVersionBuild = filever.Build;
    int fileVersionRevision = filever.Revision;
    int productVersionMajor = fileVersionMajor;
    int productVersionMinor = fileVersionMinor;
    int productVersionBuild = fileVersionBuild;
    int productVersionRevision = fileVersionRevision;
    if (informationalVersion != null) {
        Version productver = ParseVersionRobust (informationalVersion);
        productVersionMajor = productver.Major;
        productVersionMinor = productver.Minor;
        productVersionBuild = productver.Build;
        productVersionRevision = productver.Revision;
    }
    ByteBuffer stringTable = new ByteBuffer (512);
    stringTable.Write ((short) 0);
    stringTable.Write ((short) 0);
    stringTable.Write ((short) 1);
    WriteUTF16Z (stringTable, string.Format ("{0:x4}{1:x4}", lcid, codepage));
    stringTable.Align (4);
    WriteString (stringTable, "Comments", description);
    WriteString (stringTable, "CompanyName", company);
    WriteString (stringTable, "FileDescription", title);
    WriteString (stringTable, "FileVersion", fileVersion);
    WriteString (stringTable, "InternalName", name.Name);
    WriteString (stringTable, "LegalCopyright", copyright);
    WriteString (stringTable, "LegalTrademarks", trademark);
    WriteString (stringTable, "OriginalFilename", fileName);
    WriteString (stringTable, "ProductName", product);
    WriteString (stringTable, "ProductVersion", informationalVersion);
    stringTable.Position = 0;
    stringTable.Write ((short) stringTable.Length);
    ByteBuffer stringFileInfo = new ByteBuffer (512);
    stringFileInfo.Write ((short) 0);
    stringFileInfo.Write ((short) 0);
    stringFileInfo.Write ((short) 1);
    WriteUTF16Z (stringFileInfo, "StringFileInfo");
    stringFileInfo.Align (4);
    stringFileInfo.Write (stringTable);
    stringFileInfo.Position = 0;
    stringFileInfo.Write ((short) stringFileInfo.Length);
    byte [] preamble1 = new byte [] {0x34, 0x00, 0x00, 0x00, 0x56, 0x00, 0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00, 0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4F, 0x00, 0x4E, 0x00, 0x5F, 0x00, 0x49, 0x00, 0x4E, 0x00, 0x46, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD, 0x04, 0xEF, 0xFE, 0x00, 0x00, 0x01, 0x00,};
    byte [] preamble2 = new byte [] {0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x56, 0x00, 0x61, 0x00, 0x72, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x04, 0x00, 0x00, 0x00, 0x54, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,};
    bb.Write ((short) (2 + preamble1.Length + 8 + 8 + preamble2.Length + 4 + stringFileInfo.Length));
    bb.Write (preamble1);
    bb.Write ((short) fileVersionMinor);
    bb.Write ((short) fileVersionMajor);
    bb.Write ((short) fileVersionRevision);
    bb.Write ((short) fileVersionBuild);
    bb.Write ((short) productVersionMinor);
    bb.Write ((short) productVersionMajor);
    bb.Write ((short) productVersionRevision);
    bb.Write ((short) productVersionBuild);
    bb.Write (preamble2);
    bb.Write ((short) lcid);
    bb.Write ((short) codepage);
    bb.Write (stringFileInfo);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/VersionInfo.cs.ifdefed" startline="219" endline="226">
private static void WriteUTF16Z (ByteBuffer bb, string str) {
    foreach (char c in str) {
        bb.Write ((short) c);
    }
    bb.Write ((short) 0);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/VersionInfo.cs.ifdefed" startline="228" endline="243">
private static void WriteString (ByteBuffer bb, string name, string value) {
    value = value ?? " ";
    int pos = bb.Position;
    bb.Write ((short) 0);
    bb.Write ((short) (value.Length + 1));
    bb.Write ((short) 1);
    WriteUTF16Z (bb, name);
    bb.Align (4);
    WriteUTF16Z (bb, value);
    bb.Align (4);
    int savedPos = bb.Position;
    bb.Position = pos;
    bb.Write ((short) (savedPos - pos));
    bb.Position = savedPos;
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/VersionInfo.cs.ifdefed" startline="245" endline="253">
private static Version ParseVersionRobust (string ver) {
    int index = 0;
    ushort major = ParseVersionPart (ver, ref index);
    ushort minor = ParseVersionPart (ver, ref index);
    ushort build = ParseVersionPart (ver, ref index);
    ushort revision = ParseVersionPart (ver, ref index);
    return new Version (major, minor, build, revision);
}
</source>
<source file="/Users/farouq/Desktop/semantic/Monoo-2.10/mcs/class/IKVM.Reflection/Writer/VersionInfo.cs.ifdefed" startline="255" endline="278">
private static ushort ParseVersionPart (string str, ref int pos) {
    ushort value = 0;
    while (pos < str.Length) {
        char c = str [pos];
        if (c == '.') {
            pos ++;
            break;
        } else if (c >= '0' && c <= '9') {
            value *= 10;
            value += (ushort) (c - '0');
            pos ++;
        } else {
            break;
        }
    }
    return value;
}
</source>
