<clones  >
<clone_pair groupid="0" nfragments="1598" Csharpe_files="1598" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="226" endline="357">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal GameConfiguration(Configuration cfg)
 		{
 			object obj;
 			
 			// Initialize
 			this.cfg = cfg;
 			this.thingflags = new Dictionary<string, string>();
 			this.defaultthingflags = new List<string>();
 			this.thingcategories = new List<ThingCategory>();
 			this.things = new Dictionary<int, ThingTypeInfo>();
 			this.linedefflags = new Dictionary<string, string>();
 			this.sortedlinedefflags = new List<string>();
 			this.linedefactions = new Dictionary<int, LinedefActionInfo>();
 			this.actioncategories = new List<LinedefActionCategory>();
 			this.sortedlinedefactions = new List<LinedefActionInfo>();
 			this.linedefactivates = new List<LinedefActivateInfo>();
 			this.genactioncategories = new List<GeneralizedCategory>();
 			this.sectoreffects = new Dictionary<int, SectorEffectInfo>();
 			this.sortedsectoreffects = new List<SectorEffectInfo>();
 			this.geneffectoptions = new List<GeneralizedOption>();
 			this.enums = new Dictionary<string, EnumList>();
 			this.skills = new List<SkillInfo>();
 			this.texturesets = new List<DefinedTextureSet>();
 			this.makedoorargs = new int[Linedef.NUM_ARGS];
 			this.maplumps = new Dictionary<string, MapLumpInfo>();
 			this.thingflagstranslation = new List<FlagTranslation>();
 			this.linedefflagstranslation = new List<FlagTranslation>();
 			this.thingfilters = new List<ThingsFilter>();
 			this.thingflagscompare = new List<ThingFlagsCompare>();
 			this.brightnesslevels = new StepsList();
 			this.makedoorflags = new Dictionary<string, bool>();
 			
 			// Read general settings
 			configname = cfg.ReadSetting("game", "<unnamed game>");
 			enginename = cfg.ReadSetting("engine", "");
 			defaultsavecompiler = cfg.ReadSetting("defaultsavecompiler", "");
 			defaulttestcompiler = cfg.ReadSetting("defaulttestcompiler", "");
 			defaulttexturescale = cfg.ReadSetting("defaulttexturescale", 1f);
 			defaultflatscale = cfg.ReadSetting("defaultflatscale", 1f);
 			scaledtextureoffsets = cfg.ReadSetting("scaledtextureoffsets", true);
 			formatinterface = cfg.ReadSetting("formatinterface", "");
 			mixtexturesflats = cfg.ReadSetting("mixtexturesflats", false);
 			generalizedactions = cfg.ReadSetting("generalizedlinedefs", false);
 			generalizedeffects = cfg.ReadSetting("generalizedsectors", false);
 			start3dmodethingtype = cfg.ReadSetting("start3dmode", 0);
 			linedefactivationsfilter = cfg.ReadSetting("linedefactivationsfilter", 0);
 			testparameters = cfg.ReadSetting("testparameters", "");
 			testshortpaths = cfg.ReadSetting("testshortpaths", false);
 			makedoortrack = cfg.ReadSetting("makedoortrack", "-");
 			makedooraction = cfg.ReadSetting("makedooraction", 0);
 			makedooractivate = cfg.ReadSetting("makedooractivate", 0);
 			linetagindicatesectors = cfg.ReadSetting("linetagindicatesectors", false);
 			decorategames = cfg.ReadSetting("decorategames", "");
             skyflatname = cfg.ReadSetting("skyflatname", "F_SKY1");
 			maxtexturenamelength = cfg.ReadSetting("maxtexturenamelength", 8);
 			leftboundary = cfg.ReadSetting("leftboundary", -32768);
 			rightboundary = cfg.ReadSetting("rightboundary", 32767);
 			topboundary = cfg.ReadSetting("topboundary", 32767);
 			bottomboundary = cfg.ReadSetting("bottomboundary", -32768);
 			doomlightlevels = cfg.ReadSetting("doomlightlevels", true);
 			for(int i = 0; i < Linedef.NUM_ARGS; i++) makedoorargs[i] = cfg.ReadSetting("makedoorarg" + i.ToString(CultureInfo.InvariantCulture), 0);
 
 			// Flags have special (invariant culture) conversion
 			// because they are allowed to be written as integers in the configs
 			obj = cfg.ReadSettingObject("soundlinedefflag", 0);
 			if(obj is int) soundlinedefflag = ((int)obj).ToString(CultureInfo.InvariantCulture); else soundlinedefflag = obj.ToString();
 			obj = cfg.ReadSettingObject("singlesidedflag", 0);
 			if(obj is int) singlesidedflag = ((int)obj).ToString(CultureInfo.InvariantCulture); else singlesidedflag = obj.ToString();
 			obj = cfg.ReadSettingObject("doublesidedflag", 0);
 			if(obj is int) doublesidedflag = ((int)obj).ToString(CultureInfo.InvariantCulture); else doublesidedflag = obj.ToString();
 			obj = cfg.ReadSettingObject("impassableflag", 0);
 			if(obj is int) impassableflag = ((int)obj).ToString(CultureInfo.InvariantCulture); else impassableflag = obj.ToString();
 			obj = cfg.ReadSettingObject("upperunpeggedflag", 0);
 			if(obj is int) upperunpeggedflag = ((int)obj).ToString(CultureInfo.InvariantCulture); else upperunpeggedflag = obj.ToString();
 			obj = cfg.ReadSettingObject("lowerunpeggedflag", 0);
 			if(obj is int) lowerunpeggedflag = ((int)obj).ToString(CultureInfo.InvariantCulture); else lowerunpeggedflag = obj.ToString();
 			
 			// Get map lumps
 			maplumpnames = cfg.ReadSetting("maplumpnames", new Hashtable());
 
 			// Get texture and flat sources
 			textureranges = cfg.ReadSetting("textures", new Hashtable());
 			flatranges = cfg.ReadSetting("flats", new Hashtable());
 			patchranges = cfg.ReadSetting("patches", new Hashtable());
 			spriteranges = cfg.ReadSetting("sprites", new Hashtable());
 			colormapranges = cfg.ReadSetting("colormaps", new Hashtable());
 			
 			// Map lumps
 			LoadMapLumps();
 			
 			// Skills
 			LoadSkills();
 
 			// Enums
 			LoadEnums();
 			
 			// Things
 			LoadThingFlags();
 			LoadDefaultThingFlags();
 			LoadThingCategories();
 			
 			// Linedefs
 			LoadLinedefFlags();
 			LoadLinedefActions();
 			LoadLinedefActivations();
 			LoadLinedefGeneralizedActions();
 
 			// Sectors
 			LoadBrightnessLevels();
 			LoadSectorEffects();
 			LoadSectorGeneralizedEffects();
 			
 			// Universal fields
 			linedeffields = LoadUniversalFields("linedef");
 			sectorfields = LoadUniversalFields("sector");
 			sidedeffields = LoadUniversalFields("sidedef");
 			thingfields = LoadUniversalFields("thing");
 			vertexfields = LoadUniversalFields("vertex");
 
 			// Defaults
 			LoadTextureSets();
 			LoadThingFilters();
 
 			// Make door flags
 			LoadMakeDoorFlags();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Compilers\CompilerError.cs" startline="56" endline="63">
<![CDATA[
 		
 		// Constructor
 		public CompilerError(string description, string filename, int linenumber)
 		{
 			this.description = description;
 			this.filename = filename;
 			this.linenumber = linenumber;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\EnumOptionHandler.cs" startline="52" endline="64">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor
 
 		// When set up for an argument
 		public override void SetupArgument(TypeHandlerAttribute attr, ArgumentInfo arginfo)
 		{
 			base.SetupArgument(attr, arginfo);
 
 			// Keep enum list reference
 			list = arginfo.Enum;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Compilers\CompilerError.cs" startline="48" endline="55">
<![CDATA[
 		
 		// Constructor
 		public CompilerError(string description, string filename)
 		{
 			this.description = description;
 			this.filename = filename;
 			this.linenumber = NO_LINE_NUMBER;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\EnumStringsHandler.cs" startline="52" endline="64">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor
 
 		// When set up for an argument
 		public override void SetupArgument(TypeHandlerAttribute attr, ArgumentInfo arginfo)
 		{
 			base.SetupArgument(attr, arginfo);
 
 			// Keep enum list reference
 			list = arginfo.Enum;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\EnumBitsHandler.cs" startline="56" endline="68">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor
 
 		// When set up for an argument
 		public override void SetupArgument(TypeHandlerAttribute attr, ArgumentInfo arginfo)
 		{
 			base.SetupArgument(attr, arginfo);
 
 			// Keep enum list reference
 			list = arginfo.Enum;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalParser.cs" startline="124" endline="133">
<![CDATA[
 		
 		
 		// This raises an error
 		private void RaiseError(int line, string description)
 		{
 			// Raise error
 			cpErrorResult = 1;
 			cpErrorDescription = description;
 			cpErrorLine = line;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="355" endline="374">
<![CDATA[
 
 		/// <summary>
 		/// This finds the closest path from one vertex to another.
 		/// When turnatends is true, the algorithm will continue at the other side of the
 		/// line when a dead end has been reached. Returns null when no path could be found.
 		/// </summary>
 		//public static List<LinedefSide> FindClosestPath(Vertex start, float startangle, Vertex end, bool turnatends)
 		//{
 
 		//}
 
 		/// <summary>
 		/// This finds the closest path from the beginning of a line to the end of the line.
 		/// When turnatends is true, the algorithm will continue at the other side of the
 		/// line when a dead end has been reached. Returns null when no path could be found.
 		/// </summary>
 		public static List<LinedefSide> FindClosestPath(Linedef startline, bool startfront, bool turnatends)
 		{
 			return FindClosestPath(startline, startfront, startline, startfront, turnatends);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="499" endline="507">
<![CDATA[
 		
 		// This changes view position
 		public void PositionView(float x, float y)
 		{
 			// Change position in world coordinates
 			offsetx = x;
 			offsety = y;
 			UpdateTransformations();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\DefinedTextureSet.cs" startline="100" endline="106">
<![CDATA[
 		
 		// This applies the filters and name of one set to this one
 		internal void Apply(TextureSet set)
 		{
 			this.name = set.Name;
 			this.filters = new List<string>(set.Filters);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualThing.cs" startline="203" endline="211">
<![CDATA[
 
 		/// <summary>
 		/// This sets the position to use for the thing geometry.
 		/// </summary>
 		public void SetPosition(Vector3D pos)
 		{
 			pos2d = new Vector2D(pos);
 			position = Matrix.Translation(D3DDevice.V3(pos));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Line2D.cs" startline="65" endline="71">
<![CDATA[
 		
 		// Constructor
 		public Line2D(float x1, float y1, float x2, float y2)
 		{
 			this.v1 = new Vector2D(x1, y1);
 			this.v2 = new Vector2D(x2, y2);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Line2D.cs" startline="83" endline="89">
<![CDATA[
 
 		// This calculates the square of the length
 		public static float GetLengthSq(float dx, float dy)
 		{
 			// Calculate and return the length
 			return dx * dx + dy * dy;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DeserializerStream.cs" startline="54" endline="65">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Destructor
 
 		// Constructor
 		public DeserializerStream(Stream stream)
 		{
 			// Initialize
 			this.stream = stream;
 			this.reader = new BinaryReader(stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Vertex.cs" startline="192" endline="205">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Methods
 
 		// This copies all properties to another thing
 		public void CopyPropertiesTo(Vertex v)
 		{
 			v.BeforePropsChange();
 			
 			// Copy properties
 			v.pos = pos;
 			base.CopyPropertiesTo(v);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="521" endline="531">
<![CDATA[
 
 		// Mouse button pressed
 		public override void OnMouseDown(MouseEventArgs e)
 		{
 			// Save mouse down position
 			mousedownpos = mousepos;
 			mousedownmappos = mousemappos;
 			
 			// Let the base class know
 			base.OnMouseDown(e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Line2D.cs" startline="96" endline="102">
<![CDATA[
 
 		// This tests if the line intersects with the given line coordinates
 		public static bool GetIntersection(Vector2D v1, Vector2D v2, float x3, float y3, float x4, float y4)
 		{
 			float u_ray, u_line;
 			return GetIntersection(v1, v2, x3, y3, x4, y4, out u_ray, out u_line);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Line2D.cs" startline="103" endline="109">
<![CDATA[
 
 		// This tests if the line intersects with the given line coordinates
 		public static bool GetIntersection(Vector2D v1, Vector2D v2, float x3, float y3, float x4, float y4, out float u_ray)
 		{
 			float u_line;
 			return GetIntersection(v1, v2, x3, y3, x4, y4, out u_ray, out u_line);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\GridSetup.cs" startline="180" endline="189">
<![CDATA[
 
 		// This sets the background view
 		internal void SetBackgroundView(int offsetx, int offsety, float scalex, float scaley)
 		{
 			// Set background offset
 			this.backoffsetx = offsetx;
 			this.backoffsety = offsety;
 			this.backscalex = scalex;
 			this.backscaley = scaley;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\PixelColor.cs" startline="61" endline="67">
<![CDATA[
 		{
 			// Initialize
 			this.a = a;
 			this.r = r;
 			this.g = g;
 			this.b = b;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Presentation.cs" startline="95" endline="111">
<![CDATA[
 	}
 	
 	public struct PresentLayer
 	{
 		public RendererLayer layer;
 		public BlendingMode blending;
 		public float alpha;
 		public bool antialiasing;
 
 		// Constructor
 		public PresentLayer(RendererLayer layer, BlendingMode blending, float alpha, bool antialiasing)
 		{
 			this.layer = layer;
 			this.blending = blending;
 			this.alpha = alpha;
 			this.antialiasing = antialiasing;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Presentation.cs" startline="112" endline="120">
<![CDATA[
 
 		// Constructor
 		public PresentLayer(RendererLayer layer, BlendingMode blending, float alpha)
 		{
 			this.layer = layer;
 			this.blending = blending;
 			this.alpha = alpha;
 			this.antialiasing = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="357" endline="363">
<![CDATA[
 
 		// This finds a lump by name, returns -1 when not found
 		public int FindLumpIndex(string name, int start)
 		{
 			// Do search
 			return FindLumpIndex(name, start, lumps.Count - 1);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="1746" endline="1752">
<![CDATA[
 
 		// This remaps tags from a dictionary
 		private static void RenumberTagsHandler(MapElement element, bool actionargument, UniversalType type, ref int value, Dictionary<int, int> tagsmap)
 		{
 			if(value != 0)
 				value = tagsmap[value];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\SelectableElement.cs" startline="87" endline="94">
<![CDATA[
 		
 		// This copies properties to any other element
 		public void CopyPropertiesTo(SelectableElement element)
 		{
 			element.groups = this.groups;
 			element.Selected = this.selected;
 			base.CopyPropertiesTo(element);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="230" endline="237">
<![CDATA[
 
 		// This attaches a sidedef and returns the listitem
 		internal LinkedListNode<Sidedef> AttachSidedefP(Sidedef sd)
 		{
 			updateneeded = true;
 			triangulationneeded = true;
 			return sidedefs.AddLast(sd);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\Docker.cs" startline="57" endline="68">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor
 		
 		// Constructor
 		public Docker(string name, string title, Control control)
 		{
 			this.shortname = name;
 			this.title = title;
 			this.control = control;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypeHandlerAttribute.cs" startline="54" endline="66">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Destructor
 
 		// Constructor
 		public TypeHandlerAttribute(UniversalType index, string name, bool customusable)
 		{
 			// Initialize
 			this.index = (int)index;
 			this.name = name;
 			this.customusable = customusable;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="322" endline="328">
<![CDATA[
 
 		// When an item is double clicked
 		private void resourceitems_DoubleClick(object sender, EventArgs e)
 		{
 			// Click the edit resource button
 			if(editresource.Enabled) editresource_Click(sender, e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataLocation.cs" startline="45" endline="52">
<![CDATA[
 		{
 			// Initialize
 			this.type = type;
 			this.location = location;
 			this.option1 = option1;
 			this.option2 = option2;
 			this.notfortesting = notfortesting;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamWriter.cs" startline="102" endline="112">
<![CDATA[
 
 		#endregion
 
 		#region ================== Writing
 
 		// This writes the structures to a stream
 		// writenamespace may be null to omit writing the namespace to the stream
 		public void Write(MapSet map, Stream stream, string writenamespace)
 		{
 			Write(map.Vertices, map.Linedefs, map.Sidedefs, map.Sectors, map.Things, stream, writenamespace);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\PixelColor.cs" startline="68" endline="77">
<![CDATA[
 
 		// Constructor
 		public PixelColor(PixelColor p, byte a)
 		{
 			// Initialize
 			this.a = a;
 			this.r = p.r;
 			this.g = p.g;
 			this.b = p.b;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipVertex.cs" startline="58" endline="72">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Copy constructor
 		internal EarClipVertex(EarClipVertex v)
 		{
 			// Initialize
 			this.pos = v.pos;
 			this.sidedef = v.sidedef;
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\UniValue.cs" startline="95" endline="104">
<![CDATA[
 
 		// Constructor
 		public UniValue(UniValue v)
 		{
 			this.type = v.type;
 			this.value = v.value;
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Plane.cs" startline="57" endline="71">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructors
 		
 		/// <summary></summary>
 		public Plane(Vector3D normal, float offset)
 		{
 			#if DEBUG
 				if(!normal.IsNormalized())
 					General.Fail("Attempt to create a plane with a vector that is not normalized!");
 			#endif
 			this.normal = normal;
 			this.offset = offset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\ThingClassHandler.cs" startline="88" endline="95">
<![CDATA[
 
 		public override void SetValue(object value)
 		{
 			if(value != null)
 				this.value = value.ToString();
 			else
 				this.value = "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\StringHandler.cs" startline="63" endline="70">
<![CDATA[
 
 		public override void SetValue(object value)
 		{
 			if(value != null)
 				this.value = value.ToString();
 			else
 				this.value = "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\FlatHandler.cs" startline="63" endline="70">
<![CDATA[
 
 		public override void SetValue(object value)
 		{
 			if(value != null)
 				this.value = value.ToString();
 			else
 				this.value = "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TextureHandler.cs" startline="63" endline="70">
<![CDATA[
 
 		public override void SetValue(object value)
 		{
 			if(value != null)
 				this.value = value.ToString();
 			else
 				this.value = "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\SerializerStream.cs" startline="51" endline="63">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Destructor
 
 		// Constructor
 		public SerializerStream(Stream stream)
 		{
 			// Initialize
 			this.stream = stream;
 			this.writer = new BinaryWriter(stream);
 			this.stringstable = new Dictionary<string, ushort>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="136" endline="143">
<![CDATA[
 
 		// This resumes use of this resource
 		public override void Resume()
 		{
 			file = new WAD(location.location, true);
 			is_iwad = (file.Type == WAD.TYPE_IWAD);
 			base.Resume();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Plane.cs" startline="72" endline="82">
<![CDATA[
 
 		/// <summary></summary>
 		public Plane(Vector3D normal, Vector3D position)
 		{
 			#if DEBUG
 				if(!normal.IsNormalized())
 					General.Fail("Attempt to create a plane with a vector that is not normalized!");
 			#endif
 			this.normal = normal;
 			this.offset = -Vector3D.DotProduct(normal, position);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="290" endline="296">
<![CDATA[
 
 		// This scales the vector
 		public Vector3D GetScaled(float s)
 		{
 			// Scale the vector
 			return new Vector3D(x * s, y * s, z * s);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ResourceTextureSet.cs" startline="56" endline="68">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Destructor
 
 		// New texture set constructor
 		public ResourceTextureSet(string name, DataLocation location)
 		{
 			this.name = name;
 			this.location = location;
 			this.textures = new Dictionary<long, ImageData>();
 			this.flats = new Dictionary<long, ImageData>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataReader.cs" startline="40" endline="63">
<![CDATA[
 		protected bool issuspended = false;
 		protected bool isdisposed = false;
 		protected ResourceTextureSet textureset;
 
 		#endregion
 
 		#region ================== Properties
 
 		public DataLocation Location { get { return location; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		public bool IsSuspended { get { return issuspended; } }
 		public ResourceTextureSet TextureSet { get { return textureset; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public DataReader(DataLocation dl)
 		{
 			// Keep information
 			location = dl;
 			textureset = new ResourceTextureSet(GetTitle(), dl);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="420" endline="433">
<![CDATA[
 		
 		
 		// This raises an error
 		private void RaiseError(string file, int line, string description)
 		{
 			// Raise error
 			if(!cpErrorResult)
 			{
 				cpErrorResult = true;
 				cpErrorDescription = description;
 				cpErrorLine = line;
 				cpErrorFile = file;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\EnumOptionHandler.cs" startline="65" endline="73">
<![CDATA[
 
 		// When set up for a universal field
 		public override void SetupField(TypeHandlerAttribute attr, UniversalFieldInfo fieldinfo)
 		{
 			base.SetupField(attr, fieldinfo);
 
 			// Keep enum list reference
 			if(fieldinfo != null) list = fieldinfo.Enum; else list = new EnumList();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\GridSetup.cs" startline="168" endline="179">
<![CDATA[
 
 		// This sets the background
 		internal void SetBackground(string name, int source)
 		{
 			// Set background
 			if(name == null) name = "";
 			this.backsource = source;
 			this.background = name;
 
 			// Find this image
 			LinkBackground();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\EnumStringsHandler.cs" startline="65" endline="73">
<![CDATA[
 
 		// When set up for a universal field
 		public override void SetupField(TypeHandlerAttribute attr, UniversalFieldInfo fieldinfo)
 		{
 			base.SetupField(attr, fieldinfo);
 
 			// Keep enum list reference
 			if(fieldinfo != null) list = fieldinfo.Enum; else list = new EnumList();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\SectorEffectInfo.cs" startline="58" endline="74">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal SectorEffectInfo(int index, string title, bool isknown, bool isgeneralized)
 		{
 			// Initialize
 			this.index = index;
 			this.title = title;
 			this.isknown = isknown;
 			this.isgeneralized = isgeneralized;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="55" endline="62">
<![CDATA[
 		{
 			this.x = x;
 			this.y = y;
 			this.z = z;
 			this.c = c;
 			this.u = u;
 			this.v = v;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="96" endline="106">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(float x, float y, float z, float u, float v)
 		{
 			this.x = x;
 			this.y = y;
 			this.z = z;
 			this.c = -1;
 			this.u = u;
 			this.v = v;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="140" endline="150">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(float x, float y, float z, int c)
 		{
 			this.x = x;
 			this.y = y;
 			this.z = z;
 			this.c = c;
 			this.u = 0.0f;
 			this.v = 0.0f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="300" endline="308">
<![CDATA[
 		
 		// Passive version, does not record the change
 		internal void AttachFrontP(Sidedef s)
 		{
 			// Attach and recalculate
 			front = s;
 			if(front != null) front.SetLinedefP(this);
 			updateneeded = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="319" endline="327">
<![CDATA[
 		
 		// Passive version, does not record the change
 		internal void AttachBackP(Sidedef s)
 		{
 			// Attach and recalculate
 			back = s;
 			if(back != null) back.SetLinedefP(this);
 			updateneeded = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="118" endline="128">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(Vector3D p, float u, float v)
 		{
 			this.x = p.x;
 			this.y = p.y;
 			this.z = p.z;
 			this.c = -1;
 			this.u = u;
 			this.v = v;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="460" endline="476">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Changes
 
 		// This updates all properties
 		public void Update(int offsetx, int offsety, string thigh, string tmid, string tlow)
 		{
 			BeforePropsChange();
 			
 			// Apply changes
 			this.offsetx = offsetx;
 			this.offsety = offsety;
 			SetTextureHigh(thigh);
 			SetTextureMid(tmid);
 			SetTextureLow(tlow);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="74" endline="84">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(Vector3D p, int c, float u, float v)
 		{
 			this.x = p.x;
 			this.y = p.y;
 			this.z = p.z;
 			this.c = c;
 			this.u = u;
 			this.v = v;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1289" endline="1297">
<![CDATA[
 
 		/// <summary>This selects or deselectes geometry based on marked elements.</summary>
 		public void SelectMarkedGeometry(bool mark, bool select)
 		{
 			SelectMarkedVertices(mark, select);
 			SelectMarkedLinedefs(mark, select);
 			SelectMarkedSectors(mark, select);
 			SelectMarkedThings(mark, select);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="63" endline="73">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(float x, float y, float z, int c, Vector2D t)
 		{
 			this.x = x;
 			this.y = y;
 			this.z = z;
 			this.c = c;
 			this.u = t.x;
 			this.v = t.y;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="107" endline="117">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(float x, float y, float z, Vector2D t)
 		{
 			this.x = x;
 			this.y = y;
 			this.z = z;
 			this.c = -1;
 			this.u = t.x;
 			this.v = t.y;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="85" endline="95">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(Vector3D p, int c, Vector2D t)
 		{
 			this.x = p.x;
 			this.y = p.y;
 			this.z = p.z;
 			this.c = c;
 			this.u = t.x;
 			this.v = t.y;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\LinedefActivateInfo.cs" startline="55" endline="72">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal LinedefActivateInfo(string key, string title)
 		{
 			// Initialize
 			this.key = key;
 			this.title = title;
 			
 			// Try parsing key as int for comparison
 			if(!int.TryParse(key, out intkey)) intkey = 0;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\SimpleTextureImage.cs" startline="49" endline="59">
<![CDATA[
 		public SimpleTextureImage(string name, string lumpname, float scalex, float scaley)
 		{
 			// Initialize
 			this.scale.x = scalex;
 			this.scale.y = scaley;
 			this.lumpname = lumpname;
 			SetName(name);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Plotter.cs" startline="62" endline="79">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public Plotter(PixelColor* pixels, int width, int height, int visiblewidth, int visibleheight)
 		{
 			// Initialize
 			this.pixels = pixels;
 			this.width = width;
 			this.height = height;
 			this.visiblewidth = width;
 			this.visibleheight = height;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Plane.cs" startline="145" endline="152">
<![CDATA[
 
 		/// <summary>
 		/// This returns Z on the plane at X, Y
 		/// </summary>
 		public float GetZ(float x, float y)
 		{
 			return (-offset - (normal.x * x + normal.y * y)) / normal.z;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ZDTextParser.cs" startline="77" endline="91">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Parsing
 
 		// This parses the given decorate stream
 		// Returns false on errors
 		public virtual bool Parse(Stream stream, string sourcefilename)
 		{
 			datastream = stream;
 			datareader = new BinaryReader(stream, Encoding.ASCII);
 			sourcename = sourcefilename;
 			datastream.Seek(0, SeekOrigin.Begin);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\PasteOptions.cs" startline="85" endline="92">
<![CDATA[
 		
 		// This reads from configuration
 		internal void ReadConfiguration(Configuration cfg, string path)
 		{
 			changetags = cfg.ReadSetting(path + ".changetags", 0);
 			removeactions = cfg.ReadSetting(path + ".removeactions", false);
 			adjustheights = cfg.ReadSetting(path + ".adjustheights", true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\TexturePatch.cs" startline="71" endline="85">
<![CDATA[
 
 		// Constructor for hires patches
 		public TexturePatch(string lumpname, int x, int y, bool flipx, bool flipy, int rotate, PixelColor blend, float alpha, int style)
 		{
 			// Initialize
 			this.lumpname = lumpname;
 			this.x = x;
 			this.y = y;
 			this.flipx = flipx;
 			this.flipy = flipy;
 			this.rotate = rotate;
 			this.blend = blend;
 			this.alpha = alpha;
 			this.style = (TexturePathRenderStyle)style;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="170" endline="202">
<![CDATA[
 		private bool cpErrorResult = false;
 		private string cpErrorDescription = "";
 		private int cpErrorLine = 0;
 		private string cpErrorFile = "";
 		
 		// Configuration root
 		private IDictionary root = null;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		// Properties
 		public bool ErrorResult { get { return cpErrorResult; } }
 		public string ErrorDescription { get { return cpErrorDescription; } }
 		public int ErrorLine { get { return cpErrorLine; } }
 		public string ErrorFile { get { return cpErrorFile; } }
 		public IDictionary Root { get { return root; } set { root = value; } }
 		public bool Sorted { get { return (root is ListDictionary); } }
 		
 		#endregion
 		
 		#region ================== Constructor / Destructor
 		
 		// Constructor
 		public Configuration()
 		{
 			// Standard new configuration
 			NewConfiguration();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="331" endline="341">
<![CDATA[
 		
 		// This starts a new recording
 		private void StartRecording(string description)
 		{
 			stream = new MemoryStream(STREAM_CAPACITY);
 			ss = new SerializerStream(stream);
 			ss.Begin();
 			commandswritten = 0;
 			propsrecorded = null;
 			snapshot = new UndoSnapshot(description, stream, ticketid);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoSnapshot.cs" startline="60" endline="73">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal UndoSnapshot(string description, MemoryStream recstream, int ticketid)
 		{
 			if(recstream == null) General.Fail("Argument cannot be null!");
 			this.ticketid = ticketid;
 			this.description = description;
 			this.recstream = recstream;
 			this.filename = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="473" endline="492">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Changes
 
 		// This updates all properties
 		public void Update(int hfloor, int hceil, string tfloor, string tceil, int effect, int tag, int brightness)
 		{
 			BeforePropsChange();
 			
 			// Apply changes
 			this.floorheight = hfloor;
 			this.ceilheight = hceil;
 			SetFloorTexture(tfloor);
 			SetCeilTexture(tceil);
 			this.effect = effect;
 			this.tag = tag;
 			this.brightness = brightness;
 			updateneeded = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="1033" endline="1051">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Changes
 		
 		// This updates all properties
 		public void Update(Dictionary<string, bool> flags, int activate, int tag, int action, int[] args)
 		{
 			BeforePropsChange();
 			
 			// Apply changes
 			this.flags = new Dictionary<string, bool>(flags);
 			this.tag = tag;
 			this.activate = activate;
 			this.action = action;
 			this.args = new int[NUM_ARGS];
 			args.CopyTo(this.args, 0);
 			this.updateneeded = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\TextureImage.cs" startline="45" endline="57">
<![CDATA[
 		public TextureImage(string name, int width, int height, float scalex, float scaley)
 		{
 			// Initialize
 			this.width = width;
 			this.height = height;
 			this.scale.x = scalex;
 			this.scale.y = scaley;
 			this.patches = new List<TexturePatch>();
 			SetName(name);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\LinedefAngleSorter.cs" startline="38" endline="49">
<![CDATA[
 		public LinedefAngleSorter(Linedef baseline, bool front, Vertex fromvertex)
 		{
 			// Initialize
 			this.baseline = baseline;
 			this.basevertex = fromvertex;
 			
 			// Determine rotation direction
 			if(baseline.End == basevertex) this.front = !front; else this.front = front;
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Vertex.cs" startline="70" endline="89">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal Vertex(MapSet map, int listindex, Vector2D pos)
 		{
 			// Initialize
 			this.map = map;
 			this.linedefs = new LinkedList<Linedef>();
 			this.listindex = listindex;
 			this.pos = pos;
 			
 			if(map == General.Map.Map)
 				General.Map.UndoRedo.RecAddVertex(this);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\HighResImage.cs" startline="45" endline="58">
<![CDATA[
 		public HighResImage(string name, int width, int height, float scalex, float scaley, bool worldpanning)
 		{
 			// Initialize
 			this.width = width;
 			this.height = height;
 			this.scale.x = scalex;
 			this.scale.y = scaley;
 			this.worldpanning = worldpanning;
 			this.patches = new List<TexturePatch>();
 			SetName(name);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\ClippedStream.cs" startline="43" endline="74">
<![CDATA[
 		private bool isdisposed = false;
 		
 		#endregion
 
 		#region ================== Properties
 
 		public override long Length { get { return length; } }
 		public override long Position { get { return position; } set { this.Seek(value, SeekOrigin.Begin); } }
 		public override bool CanRead { get { return basestream.CanRead; } }
 		public override bool CanSeek { get { return basestream.CanSeek; } }
 		public override bool CanWrite { get { return basestream.CanWrite; }	}
 		public bool IsDisposed { get { return isdisposed; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public ClippedStream(Stream basestream, int offset, int length)
 		{
 			// Can only create from a stream that can seek
 			if(!basestream.CanSeek) throw new ArgumentException("ClippedStream can only be created with a Stream that allows Seeking.");
 
 			// Initialize
 			this.basestream = basestream;
 			this.position = 0;
 			this.offset = offset;
 			this.length = length;
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="410" endline="426">
<![CDATA[
 		
 		// This updates all properties
 		// NOTE
 		public void Update(int type, float x, float y, float zoffset, int angle,
 						   Dictionary<string, bool> flags, int tag, int action, int[] args)
 		{
 			// Apply changes
 			this.type = type;
 			this.anglerad = Angle2D.DoomToReal(angle);
 			this.angledoom = angle;
 			this.flags = new Dictionary<string, bool>(flags);
 			this.tag = tag;
 			this.action = action;
 			this.args = new int[NUM_ARGS];
 			args.CopyTo(this.args, 0);
 			this.Move(x, y, zoffset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Plotter.cs" startline="91" endline="98">
<![CDATA[
 		
 		// This draws a pixel normally
 		public void DrawPixelSolid(int x, int y, ref PixelColor c)
 		{
 			// Draw pixel when within range
 			if((x >= 0) && (x < visiblewidth) && (y >= 0) && (y < visibleheight))
 				pixels[y * width + x] = c;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="49" endline="107">
<![CDATA[
 		private Sector sector = null;
 
 		// List items
 		private LinkedListNode<Thing> selecteditem;
 		
 		// Properties
 		private int type;
 		private Vector3D pos;
 		private int angledoom;		// Angle as entered / stored in file
 		private float anglerad;		// Angle in radians
 		private Dictionary<string, bool> flags;
 		private int tag;
 		private int action;
 		private int[] args;
 
 		// Configuration
 		private float size;
 		private PixelColor color;
 		private bool fixedsize;
 		private float iconoffset;	// Arrow or dot coordinate offset on the texture
 
 		#endregion
 
 		#region ================== Properties
 
 		public MapSet Map { get { return map; } }
 		public int Type { get { return type; } set { BeforePropsChange(); type = value; } }
 		public Vector3D Position { get { return pos; } }
 		public float Angle { get { return anglerad; } }
 		public int AngleDoom { get { return angledoom; } }
 		internal Dictionary<string, bool> Flags { get { return flags; } }
 		public int Action { get { return action; } set { BeforePropsChange(); action = value; } }
 		public int[] Args { get { return args; } }
 		public float Size { get { return size; } }
 		public float IconOffset { get { return iconoffset; } }
 		public PixelColor Color { get { return color; } }
 		public bool FixedSize { get { return fixedsize; } }
 		public int Tag { get { return tag; } set { BeforePropsChange(); tag = value; if((tag < General.Map.FormatInterface.MinTag) || (tag > General.Map.FormatInterface.MaxTag)) throw new ArgumentOutOfRangeException("Tag", "Invalid tag number"); } }
 		public Sector Sector { get { return sector; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal Thing(MapSet map, int listindex)
 		{
 			// Initialize
 			this.map = map;
 			this.listindex = listindex;
 			this.flags = new Dictionary<string, bool>();
 			this.args = new int[NUM_ARGS];
 			
 			if(map == General.Map.Map)
 				General.Map.UndoRedo.RecAddThing(this);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\FileImage.cs" startline="67" endline="84">
<![CDATA[
 
 		// Constructor
 		public FileImage(string name, string filepathname, bool asflat, float scalex, float scaley)
 		{
 			// Initialize
 			this.filepathname = filepathname;
 			this.scale.x = scalex;
 			this.scale.y = scaley;
 			SetName(name);
 
 			if(asflat)
 				probableformat = ImageDataFormat.DOOMFLAT;
 			else
 				probableformat = ImageDataFormat.DOOMPICTURE;
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="273" endline="289">
<![CDATA[
 		
 		// This copies all properties to another line
 		new public void CopyPropertiesTo(Linedef l)
 		{
 			l.BeforePropsChange();
 			
 			// Copy properties
 			l.action = action;
 			l.args = (int[])args.Clone();
 			l.flags = new Dictionary<string, bool>(flags);
 			l.tag = tag;
 			l.updateneeded = true;
 			l.activate = activate;
 			l.impassableflag = impassableflag;
 			l.blocksoundflag = blocksoundflag;
 			base.CopyPropertiesTo(l);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="181" endline="197">
<![CDATA[
 		
 		// This copies all properties to another sidedef
 		public void CopyPropertiesTo(Sidedef s)
 		{
 			s.BeforePropsChange();
 			
 			// Copy properties
 			s.offsetx = offsetx;
 			s.offsety = offsety;
 			s.texnamehigh = texnamehigh;
 			s.texnamemid = texnamemid;
 			s.texnamelow = texnamelow;
 			s.longtexnamehigh = longtexnamehigh;
 			s.longtexnamemid = longtexnamemid;
 			s.longtexnamelow = longtexnamelow;
 			base.CopyPropertiesTo(s);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypeHandler.cs" startline="79" endline="102">
<![CDATA[
 
 		// This sets up the handler for arguments
 		public virtual void SetupArgument(TypeHandlerAttribute attr, ArgumentInfo arginfo)
 		{
 			// Setup
 			this.forargument = true;
 			this.arginfo = arginfo;
 			if(attr != null)
 			{
 				// Set attributes
 				this.attribute = attr;
 				this.index = attr.Index;
 				this.typename = attr.Name;
 				this.customusable = attr.IsCustomUsable;
 			}
 			else
 			{
 				// Indexless
 				this.attribute = null;
 				this.index = -1;
 				this.typename = "Unknown";
 				this.customusable = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypeHandler.cs" startline="103" endline="126">
<![CDATA[
 
 		// This sets up the handler for arguments
 		public virtual void SetupField(TypeHandlerAttribute attr, UniversalFieldInfo fieldinfo)
 		{
 			// Setup
 			this.forargument = false;
 			this.arginfo = arginfo;
 			if(attr != null)
 			{
 				// Set attributes
 				this.attribute = attr;
 				this.index = attr.Index;
 				this.typename = attr.Name;
 				this.customusable = attr.IsCustomUsable;
 			}
 			else
 			{
 				// Indexless
 				this.attribute = null;
 				this.index = -1;
 				this.typename = "Unknown";
 				this.customusable = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Lump.cs" startline="55" endline="91">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		internal WAD Owner { get { return owner; } }
 		internal string Name { get { return name; } }
 		internal long LongName { get { return longname; } }
 		internal byte[] FixedName { get { return fixedname; } }
 		internal int Offset { get { return offset; } }
 		internal int Length { get { return length; } }
 		internal ClippedStream Stream { get { return stream; } }
 		internal bool IsDisposed { get { return isdisposed; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal Lump(Stream data, WAD owner, byte[] fixedname, int offset, int length)
 		{
 			// Initialize
 			this.stream = new ClippedStream(data, offset, length);
 			this.owner = owner;
 			this.fixedname = fixedname;
 			this.offset = offset;
 			this.length = length;
 
 			// Make name
 			this.name = MakeNormalName(fixedname, WAD.ENCODING).ToUpperInvariant();
 			this.fixedname = MakeFixedName(name, WAD.ENCODING);
 			this.longname = MakeLongName(name);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceUpdate.cs" startline="60" endline="75">
<![CDATA[
 		internal SurfaceUpdate(int numvertices, bool updatefloor, bool updateceiling)
 		{
 			this.numvertices = numvertices;
 			this.floortexture = 0;
 			this.ceiltexture = 0;
 			
 			if(updatefloor)
 				this.floorvertices = new FlatVertex[numvertices];
 			else
 				this.floorvertices = null;
 
 			if(updateceiling)
 				this.ceilvertices = new FlatVertex[numvertices];
 			else
 				this.ceilvertices = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="896" endline="1001">
<![CDATA[
 
 		#endregion
 
 		#region ================== Things
 
 		// This makes vertices for a thing
 		// Returns false when not on the screen
 		private bool CreateThingVerts(Thing t, ref FlatVertex[] verts, int offset, PixelColor c)
 		{
 			float circlesize;
 			float arrowsize;
 			int color;
 			
 			// Transform to screen coordinates
 			Vector2D screenpos = ((Vector2D)t.Position).GetTransformed(translatex, translatey, scale, -scale);
 			
 			// Determine sizes
 			if(t.FixedSize && (scale > 1.0f))
 			{
 				circlesize = (t.Size - THING_CIRCLE_SHRINK) * THING_CIRCLE_SIZE;
 				arrowsize = (t.Size - THING_ARROW_SHRINK) * THING_ARROW_SIZE;
 			}
 			else
 			{
 				circlesize = (t.Size - THING_CIRCLE_SHRINK) * scale * THING_CIRCLE_SIZE;
 				arrowsize = (t.Size - THING_ARROW_SHRINK) * scale * THING_ARROW_SIZE;
 			}
 			
 			// Check if the thing is actually on screen
 			if(((screenpos.x + circlesize) > 0.0f) && ((screenpos.x - circlesize) < (float)windowsize.Width) &&
 				((screenpos.y + circlesize) > 0.0f) && ((screenpos.y - circlesize) < (float)windowsize.Height))
 			{
 				// Get integral color
 				color = c.ToInt();
 
 				// Setup fixed rect for circle
 				verts[offset].x = screenpos.x - circlesize;
 				verts[offset].y = screenpos.y - circlesize;
 				verts[offset].c = color;
 				verts[offset].u = 1f / 512f;
 				verts[offset].v = 1f / 128f;
 				offset++;
 				verts[offset].x = screenpos.x + circlesize;
 				verts[offset].y = screenpos.y - circlesize;
 				verts[offset].c = color;
 				verts[offset].u = 0.25f - 1f / 512f;
 				verts[offset].v = 1f / 128f;
 				offset++;
 				verts[offset].x = screenpos.x - circlesize;
 				verts[offset].y = screenpos.y + circlesize;
 				verts[offset].c = color;
 				verts[offset].u = 1f / 512f;
 				verts[offset].v = 1f - 1f / 128f;
 				offset++;
 				verts[offset] = verts[offset - 2];
 				offset++;
 				verts[offset] = verts[offset - 2];
 				offset++;
 				verts[offset].x = screenpos.x + circlesize;
 				verts[offset].y = screenpos.y + circlesize;
 				verts[offset].c = color;
 				verts[offset].u = 0.25f - 1f / 512f;
 				verts[offset].v = 1f - 1f / 128f;
 				offset++;
 
 				float sinarrowsize = (float)Math.Sin(t.Angle + Angle2D.PI * 0.25f) * arrowsize;
 				float cosarrowsize = (float)Math.Cos(t.Angle + Angle2D.PI * 0.25f) * arrowsize;
 				
 				// Setup rotated rect for arrow
 				verts[offset].x = screenpos.x + sinarrowsize;
 				verts[offset].y = screenpos.y + cosarrowsize;
 				verts[offset].c = -1;
 				verts[offset].u = 0.50f + t.IconOffset;
 				verts[offset].v = 0f;
 				offset++;
 				verts[offset].x = screenpos.x - cosarrowsize;
 				verts[offset].y = screenpos.y + sinarrowsize;
 				verts[offset].c = -1;
 				verts[offset].u = 0.75f + t.IconOffset;
 				verts[offset].v = 0f;
 				offset++;
 				verts[offset].x = screenpos.x + cosarrowsize;
 				verts[offset].y = screenpos.y - sinarrowsize;
 				verts[offset].c = -1;
 				verts[offset].u = 0.50f + t.IconOffset;
 				verts[offset].v = 1f;
 				offset++;
 				verts[offset] = verts[offset - 2];
 				offset++;
 				verts[offset] = verts[offset - 2];
 				offset++;
 				verts[offset].x = screenpos.x - sinarrowsize;
 				verts[offset].y = screenpos.y - cosarrowsize;
 				verts[offset].c = -1;
 				verts[offset].u = 0.75f + t.IconOffset;
 				verts[offset].v = 1f;
 				
 				// Done
 				return true;
 			}
 			else
 			{
 				// Not on screen
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Plane.cs" startline="83" endline="93">
<![CDATA[
 
 		/// <summary></summary>
 		public Plane(Vector3D p1, Vector3D p2, Vector3D p3, bool up)
 		{
 			this.normal = Vector3D.CrossProduct(p2 - p1, p3 - p1).GetNormal();
 			
 			if((up && (this.normal.z < 0.0f)) || (!up && (this.normal.z > 0.0f)))
 				this.normal = -this.normal;
 			
 			this.offset = -Vector3D.DotProduct(normal, p3);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="211" endline="229">
<![CDATA[
 		
 		// This copies all properties to another sector
 		public void CopyPropertiesTo(Sector s)
 		{
 			s.BeforePropsChange();
 			
 			// Copy properties
 			s.ceilheight = ceilheight;
 			s.ceiltexname = ceiltexname;
 			s.longceiltexname = longceiltexname;
 			s.floorheight = floorheight;
 			s.floortexname = floortexname;
 			s.longfloortexname = longfloortexname;
 			s.effect = effect;
 			s.tag = tag;
 			s.brightness = brightness;
 			s.updateneeded = true;
 			base.CopyPropertiesTo(s);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="109" endline="135">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal Linedef(MapSet map, int listindex, Vertex start, Vertex end)
 		{
 			// Initialize
 			this.map = map;
 			this.listindex = listindex;
 			this.updateneeded = true;
 			this.args = new int[NUM_ARGS];
 			this.flags = new Dictionary<string, bool>();
 			
 			// Attach to vertices
 			this.start = start;
 			this.startvertexlistitem = start.AttachLinedefP(this);
 			this.end = end;
 			this.endvertexlistitem = end.AttachLinedefP(this);
 			
 			if(map == General.Map.Map)
 				General.Map.UndoRedo.RecAddLinedef(this);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="521" endline="535">
<![CDATA[
 
 		// This sets a flag
 		public void SetFlag(string flagname, bool value)
 		{
 			if(!flags.ContainsKey(flagname) || (IsFlagSet(flagname) != value))
 			{
 				BeforePropsChange();
 				
 				flags[flagname] = value;
 
 				// Cached flags
 				if(flagname == General.Map.Config.SoundLinedefFlag) blocksoundflag = value;
 				if(flagname == General.Map.Config.ImpassableFlag) impassableflag = value;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\FlatQuad.cs" startline="102" endline="117">
<![CDATA[
 
 		// Constructor
 		public FlatQuad(PrimitiveType type, float left, float top, float right, float bottom, float tl, float tt, float tr, float tb)
 		{
 			// Initialize
 			Initialize(type);
 			
 			// Set coordinates
 			if(type == PrimitiveType.TriangleList)
 				SetTriangleListCoordinates(left, top, right, bottom, tl, tt, tr, tb);
 			else if(type == PrimitiveType.TriangleStrip)
 				SetTriangleStripCoordinates(left, top, right, bottom, tl, tt, tr, tb);
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="105" endline="131">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal Sector(MapSet map, int listindex, int index)
 		{
 			// Initialize
 			this.map = map;
 			this.listindex = listindex;
 			this.sidedefs = new LinkedList<Sidedef>();
 			this.fixedindex = index;
 			this.floortexname = "-";
 			this.ceiltexname = "-";
 			this.longfloortexname = MapSet.EmptyLongName;
 			this.longceiltexname = MapSet.EmptyLongName;
 			this.updateneeded = true;
 			this.triangulationneeded = true;
 			this.surfaceentries = new SurfaceEntryCollection();
 
 			if(map == General.Map.Map)
 				General.Map.UndoRedo.RecAddSector(this);
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\PixelColorBlock.cs" startline="51" endline="69">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Destructor
 
 		// Constructor
 		public PixelColorBlock(int width, int height)
 		{
 			// Check input
 			if((width <= 0) || (height <= 0)) throw new ArgumentException("Cannot allocate a memory block of zero size!");
 			
 			// Initialize
 			this.width = width;
 			this.height = height;
 			this.memorysize = width * height * sizeof(PixelColor);
 			this.memory = (PixelColor*)Marshal.AllocCoTaskMem(memorysize);
 			if(this.memory == (PixelColor*)0) throw new OutOfMemoryException();
 			GC.AddMemoryPressure(memorysize);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\ClippedStream.cs" startline="190" endline="206">
<![CDATA[
 		}
 
 		// Asynchronous read from stream
 		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
 		{
 			// Check if this exceeds limits
 			if((this.position + count) > (this.length + 1))
 				throw new ArgumentException("Attempted to read outside the range of the stream.");
 
 			// Seek if needed
 			if(basestream.Position != (this.offset + this.position))
 				basestream.Seek(this.offset + this.position, SeekOrigin.Begin);
 			
 			// Read
 			position += count;
 			return base.BeginRead(buffer, offset, count, callback, state);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\ClippedStream.cs" startline="207" endline="222">
<![CDATA[
 
 		// Asynchronous write to stream
 		public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
 		{
 			// Check if this exceeds limits
 			if((this.position + count) > (this.length + 1))
 				throw new ArgumentException("Attempted to write outside the range of the stream.");
 
 			// Seek if needed
 			if(basestream.Position != (this.offset + this.position))
 				basestream.Seek(this.offset + this.position, SeekOrigin.Begin);
 			
 			// Write
 			position += count;
 			return base.BeginWrite(buffer, offset, count, callback, state);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="187" endline="207">
<![CDATA[
 
 		// This copies all properties to another thing
 		public void CopyPropertiesTo(Thing t)
 		{
 			t.BeforePropsChange();
 			
 			// Copy properties
 			t.type = type;
 			t.anglerad = anglerad;
 			t.angledoom = angledoom;
 			t.pos = pos;
 			t.flags = new Dictionary<string,bool>(flags);
 			t.tag = tag;
 			t.action = action;
 			t.args = (int[])args.Clone();
 			t.size = size;
 			t.color = color;
 			t.iconoffset = iconoffset;
 			t.fixedsize = fixedsize;
 			base.CopyPropertiesTo(t);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ThingsFilter.cs" startline="73" endline="116">
<![CDATA[
 		protected bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public string Name { get { return name; } internal set { name = value; } }
 		public string CategoryName { get { return categoryname; } internal set { categoryname = value; } }
 		internal int ThingType { get { return thingtype; } set { thingtype = value; } }
 		internal int ThingAngle { get { return thingangle; } set { thingangle = value; } }
 		internal int ThingZHeight { get { return thingzheight; } set { thingzheight = value; } }
 		internal int ThingAction { get { return thingaction; } set { thingaction = value; } }
 		internal int[] ThingArgs { get { return thingargs; } set { Array.Copy(value, thingargs, Thing.NUM_ARGS); } }
 		internal int ThingTag { get { return thingtag; } set { thingtag = value; } }
 		internal UniFields ThingCustomFields { get { return customfields; } set { customfields = new UniFields(value); } }
 		internal ICollection<string> RequiredFields { get { return requiredfields; } }
 		internal ICollection<string> ForbiddenFields { get { return forbiddenfields; } }
 		public ICollection<Thing> VisibleThings { get { return visiblethings; } }
 		public ICollection<Thing> HiddenThings { get { return hiddenthings; } }
 		internal bool IsDisposed { get { return isdisposed; } }
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Copy constructor
 		internal ThingsFilter(ThingsFilter f)
 		{
 			// Copy
 			name = f.name;
 			categoryname = f.categoryname;
 			thingtype = f.thingtype;
 			thingzheight = f.thingzheight;
 			thingangle = f.thingangle;
 			thingaction = f.thingaction;
 			thingargs = new int[Thing.NUM_ARGS];
 			Array.Copy(f.thingargs, thingargs, Thing.NUM_ARGS);
 			thingtag = f.thingtag;
 			customfields = new UniFields(f.customfields);
 			requiredfields = new List<string>(f.requiredfields);
 			forbiddenfields = new List<string>(f.forbiddenfields);
 			
 			AdjustForMapFormat();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="84" endline="120">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal Sidedef(MapSet map, int listindex, Linedef l, bool front, Sector s)
 		{
 			// Initialize
 			this.map = map;
 			this.listindex = listindex;
 			this.texnamehigh = "-";
 			this.texnamemid = "-";
 			this.texnamelow = "-";
 			this.longtexnamehigh = MapSet.EmptyLongName;
 			this.longtexnamemid = MapSet.EmptyLongName;
 			this.longtexnamelow = MapSet.EmptyLongName;
 			
 			// Attach linedef
 			this.linedef = l;
 			if(l != null)
 			{
 				if(front)
 					l.AttachFrontP(this);
 				else
 					l.AttachBackP(this);
 			}
 			
 			// Attach sector
 			SetSectorP(s);
 			
 			if(map == General.Map.Map)
 				General.Map.UndoRedo.RecAddSidedef(this);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFileEntry.cs" startline="67" endline="88">
<![CDATA[
 
 		// Constructor
 		public DirectoryFileEntry(string fullname)
 		{
 			// Get the information we need
 			filename = Path.GetFileName(fullname);
 			filetitle = Path.GetFileNameWithoutExtension(fullname);
 			extension = Path.GetExtension(fullname);
 			if(extension.Length > 1)
 				extension = extension.Substring(1);
 			else
 				extension = "";
 			path = Path.GetDirectoryName(fullname);
 			filepathname = Path.Combine(path, filename);
 			filepathtitle = Path.Combine(path, filetitle);
 
 			// Make some lowercase
 			filename = filename.ToLowerInvariant();
 			filetitle = filetitle.ToLowerInvariant();
 			extension = extension.ToLowerInvariant();
 			path = path.ToLowerInvariant();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\LinedefActionInfo.cs" startline="66" endline="95">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal LinedefActionInfo(int index, Configuration cfg, string categoryname, IDictionary<string, EnumList> enums)
 		{
 			string actionsetting = "linedeftypes." + categoryname + "." + index.ToString(CultureInfo.InvariantCulture);
 			
 			// Initialize
 			this.index = index;
 			this.category = categoryname;
 			this.args = new ArgumentInfo[Linedef.NUM_ARGS];
 			this.isgeneralized = false;
 			this.isknown = true;
 			
 			// Read settings
 			this.name = cfg.ReadSetting(actionsetting + ".title", "Unnamed");
 			this.prefix = cfg.ReadSetting(actionsetting + ".prefix", "");
 			this.title = this.prefix + " " + this.name;
 			this.title = this.title.Trim();
 
 			// Read the args
 			for(int i = 0; i < Linedef.NUM_ARGS; i++)
 				this.args[i] = new ArgumentInfo(cfg, actionsetting, i, enums);
 			for(int i = 0; i < Linedef.NUM_ARGS; i++)
 				this.args[i] = new ArgumentInfo(cfg, actionsetting, i, enums);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFileEntry.cs" startline="44" endline="66">
<![CDATA[
 		{
 			// Get the information we need
 			filename = Path.GetFileName(fullname);
 			filetitle = Path.GetFileNameWithoutExtension(fullname);
 			extension = Path.GetExtension(fullname);
 			if(extension.Length > 1)
 				extension = extension.Substring(1);
 			else
 				extension = "";
 			path = Path.GetDirectoryName(fullname);
 			if(path.Length > (frompath.Length + 1))
 				path = path.Substring(frompath.Length + 1);
 			else
 				path = "";
 			filepathname = Path.Combine(path, filename);
 			filepathtitle = Path.Combine(path, filetitle);
 
 			// Make some lowercase
 			filename = filename.ToLowerInvariant();
 			filetitle = filetitle.ToLowerInvariant();
 			extension = extension.ToLowerInvariant();
 			path = path.ToLowerInvariant();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditModeInfo.cs" startline="50" endline="101">
<![CDATA[
 		private BeginActionAttribute switchactionattr = null;
 		private ActionDelegate switchactiondel = null;
 
 		// Mode button
 		private Stream buttonimagestream = null;
 		private Image buttonimage = null;
 		private string buttondesc = null;
 		private int buttonorder = int.MaxValue;
 		
 		#endregion
 
 		#region ================== Properties
 
 		public Plugin Plugin { get { return plugin; } }
 		public Type Type { get { return type; } }
 		public bool IsOptional { get { return ((switchactionattr != null) || (buttonimage != null)) && attribs.Optional; } }
 		public BeginActionAttribute SwitchAction { get { return switchactionattr; } }
 		public Image ButtonImage { get { return buttonimage; } }
 		public string ButtonDesc { get { return buttondesc; } }
 		public EditModeAttribute Attributes { get { return attribs; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public EditModeInfo(Plugin plugin, Type type, EditModeAttribute attr)
 		{
 			// Initialize
 			this.plugin = plugin;
 			this.type = type;
 			this.attribs = attr;
 			
 			// Make switch action info
 			if((attribs.SwitchAction != null) && (attribs.SwitchAction.Length > 0))
 				switchactionattr = new BeginActionAttribute(attribs.SwitchAction);
 			
 			// Make button info
 			if(attr.ButtonImage != null)
 			{
 				buttonimagestream = plugin.GetResourceStream(attr.ButtonImage);
 				if(buttonimagestream != null)
 				{
 					buttonimage = Image.FromStream(buttonimagestream);
 					buttondesc = attr.DisplayName;
 					buttonorder = attr.ButtonOrder;
 				}
 			}
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="478" endline="520">
<![CDATA[
 
 		// Mouse moved inside the display
 		public override void OnMouseMove(MouseEventArgs e)
 		{
 			Vector2D delta;
 
 			// Record last position
 			mouseinside = true;
             mouselastpos = mousepos;
 			mousepos = new Vector2D(e.X, e.Y);
 			mousemappos = renderer2d.DisplayToMap(mousepos);
 			mousebuttons = e.Button;
 			
 			// Update labels in main window
 			General.MainWindow.UpdateCoordinates(mousemappos);
 			
 			// Holding a button?
 			if(e.Button != MouseButtons.None)
 			{
 				// Not dragging?
 				if(mousedragging == MouseButtons.None)
 				{
 					// Check if moved enough pixels for dragging
 					delta = mousedownpos - mousepos;
 					if((Math.Abs(delta.x) > DRAG_START_MOVE_PIXELS) ||
 					   (Math.Abs(delta.y) > DRAG_START_MOVE_PIXELS))
 					{
 						// Dragging starts now
 						mousedragging = e.Button;
 						OnDragStart(e);
 					}
 				}
 			}
 			
 			// Selecting?
 			if(selecting) OnUpdateMultiSelection();
 
             // Panning?
             if (panning) OnUpdateViewPanning();
 			
 			// Let the base class know
 			base.OnMouseMove(e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GeneralizedCategory.cs" startline="28" endline="71">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public string Title { get { return title; } }
 		public int Offset { get { return offset; } }
 		public int Length { get { return length; } }
 		public List<GeneralizedOption> Options { get { return options; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal GeneralizedCategory(string structure, string name, Configuration cfg)
 		{
 			IDictionary opts;
 			
 			// Initialize
 			this.options = new List<GeneralizedOption>();
 			
 			// Read properties
 			this.title = cfg.ReadSetting(structure + "." + name + ".title", "");
 			this.offset = cfg.ReadSetting(structure + "." + name + ".offset", 0);
 			this.length = cfg.ReadSetting(structure + "." + name + ".length", 0);
 			
 			// Read the options
 			opts = cfg.ReadSetting(structure + "." + name, new Hashtable());
 			foreach(DictionaryEntry de in opts)
 			{
 				// Is this an option and not just some value?
 				if(de.Value is IDictionary)
 				{
 					// Add the option
 					this.options.Add(new GeneralizedOption(structure, name, de.Key.ToString(), (IDictionary)de.Value));
 				}
 			}
 			foreach(DictionaryEntry de in opts)
 			{
 				// Is this an option and not just some value?
 				if(de.Value is IDictionary)
 				{
 					// Add the option
 					this.options.Add(new GeneralizedOption(structure, name, de.Key.ToString(), (IDictionary)de.Value));
 				}
 			}
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ThingTypeInfo.cs" startline="210" endline="244">
<![CDATA[
 
 		// Constructor
 		internal ThingTypeInfo(ThingCategory cat, ActorStructure actor)
 		{
 			// Initialize
 			this.index = actor.DoomEdNum;
 			this.category = cat;
 			this.title = "";
 			this.actor = actor;
 			this.isknown = true;
 			this.args = new ArgumentInfo[Linedef.NUM_ARGS];
 			for(int i = 0; i < Linedef.NUM_ARGS; i++) this.args[i] = new ArgumentInfo(i);
 			
 			// Read properties
 			this.sprite = cat.Sprite;
 			this.color = cat.Color;
 			this.arrow = (cat.Arrow != 0);
 			this.radius = cat.Radius;
 			this.height = cat.Height;
 			this.hangs = (cat.Hangs != 0);
 			this.blocking = cat.Blocking;
 			this.errorcheck = cat.ErrorCheck;
 			this.fixedsize = cat.FixedSize;
 			this.absolutez = cat.AbsoluteZ;
 			this.spritescale = new SizeF(cat.SpriteScale, cat.SpriteScale);
 
 			// Safety
 			if(this.radius < 4f) this.radius = 8f;
 			
 			// Apply settings from actor
 			ModifyByDecorateActor(actor);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ThingTypeInfo.cs" startline="170" endline="209">
<![CDATA[
 
 		// Constructor
 		public ThingTypeInfo(ThingCategory cat, int index, string title)
 		{
 			string key = index.ToString(CultureInfo.InvariantCulture);
 
 			// Initialize
 			this.index = index;
 			this.category = cat;
 			this.title = title;
 			this.actor = null;
 			this.isknown = true;
 			this.args = new ArgumentInfo[Linedef.NUM_ARGS];
 			for(int i = 0; i < Linedef.NUM_ARGS; i++) this.args[i] = new ArgumentInfo(i);
 			
 			// Read properties
 			this.sprite = cat.Sprite;
 			this.color = cat.Color;
 			this.arrow = (cat.Arrow != 0);
 			this.radius = cat.Radius;
 			this.height = cat.Height;
 			this.hangs = (cat.Hangs != 0);
 			this.blocking = cat.Blocking;
 			this.errorcheck = cat.ErrorCheck;
 			this.fixedsize = cat.FixedSize;
 			this.absolutez = cat.AbsoluteZ;
 			this.spritescale = new SizeF(cat.SpriteScale, cat.SpriteScale);
 
 			// Safety
 			if(this.radius < 4f) this.radius = 8f;
 			
 			// Make long name for sprite lookup
 			if(this.sprite.Length <= 8)
 				this.spritelongname = Lump.MakeLongName(this.sprite);
 			else
 				this.spritelongname = long.MaxValue;
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\Action.cs" startline="79" endline="121">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal Action(Configuration cfg, string name, string shortname, int key)
 		{
 			// Initialize
 			this.name = name;
 			this.shortname = shortname;
 			this.title = cfg.ReadSetting(shortname + ".title", "[" + name + "]");
 			this.category = cfg.ReadSetting(shortname + ".category", "");
 			this.description = cfg.ReadSetting(shortname + ".description", "");
 			this.allowkeys = cfg.ReadSetting(shortname + ".allowkeys", true);
 			this.allowmouse = cfg.ReadSetting(shortname + ".allowmouse", true);
 			this.allowscroll = cfg.ReadSetting(shortname + ".allowscroll", false);
 			this.disregardshift = cfg.ReadSetting(shortname + ".disregardshift", false);
 			this.disregardcontrol = cfg.ReadSetting(shortname + ".disregardcontrol", false);
 			this.repeat = cfg.ReadSetting(shortname + ".repeat", false);
 			this.defaultkey = cfg.ReadSetting(shortname + ".default", 0);
 			this.begindelegates = new List<ActionDelegate>();
 			this.enddelegates = new List<ActionDelegate>();
 				
 			if(disregardshift)
 				keymask = (int)Keys.Shift;
 			else
 				keymask = 0;
 
 			if(disregardcontrol)
 				keymask |= (int)Keys.Control;
 			
 			keymask = ~keymask;
 
 			if(key == -1)
 			{
 				this.key = -1;
 			}
 			else
 			{
 				this.key = key & keymask;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ButtonsNumericTextbox.cs" startline="75" endline="85">
<![CDATA[
 
 		#endregion
 
 		#region ================== Interface
 
 		// Client size changes
 		protected override void OnClientSizeChanged(EventArgs e)
 		{
 			base.OnClientSizeChanged(e);
 			ClickableNumericTextbox_Resize(this, e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\AngleControl.cs" startline="90" endline="100">
<![CDATA[
 
 		#endregion
 
 		#region ================== Interface
 
 		// Size changed
 		protected override void OnClientSizeChanged(EventArgs e)
 		{
 			base.OnClientSizeChanged(e);
 			AngleControl_Resize(this, e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Plane.cs" startline="117" endline="127">
<![CDATA[
 		
 		/// <summary>
 		/// This returns the smallest distance to the plane and the side on which the point lies.
 		/// > 0 means the point lies on the front of the plane
 		/// < 0 means the point lies behind the plane
 		/// See http
 		/// </summary>
 		public float Distance(Vector3D p)
 		{
 			return Vector3D.DotProduct(normal, p) + offset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\LinedefSide.cs" startline="67" endline="76">
<![CDATA[
 
 		/// <summary>
 		/// This is used to indicate a side of a line without the need for a sidedef.
 		/// </summary>
 		public LinedefSide(Linedef line, bool front)
 		{
 			// Initialize
 			this.line = line;
 			this.front = front;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalEntry.cs" startline="47" endline="58">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public UniversalEntry(string key, object value)
 		{
 			// Initialize
 			this.key = key;
 			this.value = value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\EnumItem.cs" startline="51" endline="62">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor
 
 		// Constructor
 		public EnumItem(string value, string title)
 		{
 			// Initialize
 			this.value = value;
 			this.title = title;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\SkillInfo.cs" startline="53" endline="64">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal SkillInfo(int index, string title)
 		{
 			// Initialize
 			this.index = index;
 			this.title = title;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DeserializerStream.cs" startline="185" endline="191">
<![CDATA[
 
 		public void rVector2D(out Vector2D v)
 		{
 			v = new Vector2D();
 			v.x = reader.ReadSingle();
 			v.y = reader.ReadSingle();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="305" endline="311">
<![CDATA[
 
 		// This scales the vector
 		public Vector2D GetScaled(float s)
 		{
 			// Scale the vector
 			return new Vector2D(x * s, y * s);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\LinedefSide.cs" startline="77" endline="86">
<![CDATA[
 
 		/// <summary>
 		/// This makes a copy of the linedef side.
 		/// </summary>
 		public LinedefSide(LinedefSide original)
 		{
 			// Initialize
 			this.line = original.line;
 			this.front = original.front;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipVertex.cs" startline="84" endline="94">
<![CDATA[
 
 		// Constructor
 		internal EarClipVertex(Vector2D v, Sidedef sidedef)
 		{
 			// Initialize
 			this.pos = v;
 			this.sidedef = sidedef;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GeneralizedBit.cs" startline="30" endline="44">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal GeneralizedBit(int index, string title)
 		{
 			// Initialize
 			this.index = index;
 			this.title = title;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="335" endline="345">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Events
 		
 		// This raises the MouseContainerEnter event
 		private void RaiseMouseContainerEnter(object sender, EventArgs e)
 		{
 			if(MouseContainerEnter != null)
 				MouseContainerEnter(sender, e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="346" endline="352">
<![CDATA[
 
 		// This raises the MouseContainerLeave event
 		private void RaiseMouseContainerLeave(object sender, EventArgs e)
 		{
 			if(MouseContainerLeave != null)
 				MouseContainerLeave(sender, e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\SidedefAngleSorter.cs" startline="37" endline="45">
<![CDATA[
 		public SidedefAngleSorter(Sidedef baseside, Vertex fromvertex)
 		{
 			// Initialize
 			this.baseside = baseside;
 			this.basevertex = fromvertex;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\ColorSetting.cs" startline="49" endline="63">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public ColorSetting(string name, PixelColor color)
 		{
 			// Initialize
 			this.name = name;
 			this.color = color;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\UniValue.cs" startline="71" endline="84">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor
 
 		// Constructor
 		public UniValue(int type, object value)
 		{
 			this.type = type;
 			this.value = value;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\UniValue.cs" startline="85" endline="94">
<![CDATA[
 
 		// Constructor
 		public UniValue(UniversalType type, object value)
 		{
 			this.type = (int)type;
 			this.value = value;
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1659" endline="1670">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Indexing
 		
 		/// <summary>
 		/// Returns the vertex at the specified index. Returns null when index is out of range. This is an O(1) operation.
 		/// </summary>
 		public Vertex GetVertexByIndex(int index)
 		{
 			return index < numvertices ? vertices[index] 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1671" endline="1678">
<![CDATA[
 
 		/// <summary>
 		/// Returns the linedef at the specified index. Returns null when index is out of range. This is an O(1) operation.
 		/// </summary>
 		public Linedef GetLinedefByIndex(int index)
 		{
 			return index < numlinedefs ? linedefs[index] 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1679" endline="1686">
<![CDATA[
 
 		/// <summary>
 		/// Returns the sidedef at the specified index. Returns null when index is out of range. This is an O(1) operation.
 		/// </summary>
 		public Sidedef GetSidedefByIndex(int index)
 		{
 			return index < numsidedefs ? sidedefs[index] 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1687" endline="1694">
<![CDATA[
 
 		/// <summary>
 		/// Returns the sector at the specified index. Returns null when index is out of range. This is an O(1) operation.
 		/// </summary>
 		public Sector GetSectorByIndex(int index)
 		{
 			return index < numsectors ? sectors[index] 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1695" endline="1702">
<![CDATA[
 
 		/// <summary>
 		/// Returns the thing at the specified index. Returns null when index is out of range. This is an O(1) operation.
 		/// </summary>
 		public Thing GetThingByIndex(int index)
 		{
 			return index < numthings ? things[index] 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DeserializerStream.cs" startline="122" endline="128">
<![CDATA[
 
 		public void rwVector3D(ref Vector3D v)
 		{
 			v.x = reader.ReadSingle();
 			v.y = reader.ReadSingle();
 			v.z = reader.ReadSingle();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\AngleForm.cs" startline="81" endline="93">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// Setup from EnumList
 		public void Setup(int value)
 		{
 			setup = true;
 			this.value = value;
 			angle.Value = value;
 			setup = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipVertex.cs" startline="73" endline="83">
<![CDATA[
 
 		// Copy constructor
 		internal EarClipVertex(EarClipVertex v, Sidedef sidedef)
 		{
 			// Initialize
 			this.pos = v.pos;
 			this.sidedef = sidedef;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingBrowserForm.cs" startline="67" endline="77">
<![CDATA[
 		
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Get the result
 			selectedtype = thingslist.GetResult(selectedtype);
 
 			// Done
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="167" endline="180">
<![CDATA[
 
 		// This creates new file headers
 		private void CreateHeaders()
 		{
 			// Default settings
 			type = TYPE_PWAD;
 			lumpsoffset = 12;
 
 			// New lumps array
 			lumps = new List<Lump>(numlumps);
 			
 			// Write the headers
 			WriteHeaders();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer.cs" startline="41" endline="65">
<![CDATA[
 		protected bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		// Disposing
 		public bool IsDisposed { get { return isdisposed; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal Renderer(D3DDevice g)
 		{
 			// Initialize
 			this.graphics = g;
 
 			// Register as resource
 			g.RegisterResource(this);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DeserializerStream.cs" startline="192" endline="199">
<![CDATA[
 
 		public void rVector3D(out Vector3D v)
 		{
 			v = new Vector3D();
 			v.x = reader.ReadSingle();
 			v.y = reader.ReadSingle();
 			v.z = reader.ReadSingle();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="60" endline="84">
<![CDATA[
 		private bool isreadonly = false;
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public string Filename { get { return filename; } }
 		public string Type { get { return type; } }
 		public Encoding Encoding { get { return ENCODING; } }
 		public bool IsReadOnly { get { return isreadonly; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		public List<Lump> Lumps { get { return lumps; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor to open or create a WAD file
 		public WAD(string pathfilename)
 		{
 			// Initialize
 			this.isreadonly = false;
 			this.Open(pathfilename);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceEntry.cs" startline="77" endline="84">
<![CDATA[
 
 		// Constructor that copies the entry, but does not copy the vertices
 		internal SurfaceEntry(SurfaceEntry oldentry)
 		{
 			this.numvertices = oldentry.numvertices;
 			this.bufferindex = oldentry.bufferindex;
 			this.vertexoffset = oldentry.vertexoffset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\PasteOptions.cs" startline="67" endline="74">
<![CDATA[
 		
 		// Copy Constructor
 		public PasteOptions(PasteOptions p)
 		{
 			this.changetags = p.changetags;
 			this.removeactions = p.removeactions;
 			this.adjustheights = p.adjustheights;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\LinedefActionCategory.cs" startline="51" endline="76">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public string Name { get { return name; } }
 		public string Title { get { return title; } }
 		public List<LinedefActionInfo> Actions { get { return actions; } }
 		public bool IsDisposed { get { return isdisposed; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal LinedefActionCategory(string name, string title)
 		{
 			// Initialize
 			this.name = name;
 			this.title = title;
 			this.actions = new List<LinedefActionInfo>();
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\GridSetup.cs" startline="156" endline="167">
<![CDATA[
 
 		// This sets the grid size
 		internal void SetGridSize(int size)
 		{
 			// Change grid
 			this.gridsize = size;
 			this.gridsizef = (float)gridsize;
 			this.gridsizefinv = 1f / gridsizef;
 
 			// Update in main window
 			General.MainWindow.UpdateGrid(gridsize);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualCamera.cs" startline="88" endline="100">
<![CDATA[
 
 		// Key input
 		internal void ProcessMovement(Vector3D deltavec)
 		{
 			// Calculate camera direction vectors
 			Vector3D camvec = Vector3D.FromAngleXYZ(anglexy, anglez);
 
 			// Position the camera
 			position += deltavec;
 			
 			// Target the camera
 			target = position + camvec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Lump.cs" startline="176" endline="187">
<![CDATA[
 		
 		// This renames the lump
 		internal void Rename(string newname)
 		{
 			// Make name
 			this.fixedname = MakeFixedName(newname, WAD.ENCODING);
 			this.name = MakeNormalName(this.fixedname, WAD.ENCODING).ToUpperInvariant();
 			this.longname = MakeLongName(newname);
 
 			// Write changes
 			owner.WriteHeaders();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="131" endline="137">
<![CDATA[
 
 		// Mouse released
 		private void preview_MouseUp(object sender, MouseEventArgs e)
 		{
 			ispressed = false;
 			ShowPreview(FindImage(name.Text));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipPolygon.cs" startline="59" endline="66">
<![CDATA[
 
 		// Constructor
 		internal EarClipPolygon(EarClipPolygon p, EarClipVertex add) 
 		{
 			// Initialize
 			base.AddLast(add);
 			children = new List<EarClipPolygon>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1466" endline="1477">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Tools
 		
 		// This swaps two pointers
 		public static void Swap<T>(ref T a, ref T b)
 		{
 			T t = a;
 			a = b;
 			b = t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="205" endline="211">
<![CDATA[
 		
 		// This moves the caret to a given line and ensures the line is visible
 		public void MoveToLine(int linenumber)
 		{
 			scriptedit.GotoLine(linenumber);
 			EnsureLineVisible(linenumber);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Vertex.cs" startline="177" endline="183">
<![CDATA[
 
 		// Selected
 		protected override void DoSelect()
 		{
 			base.DoSelect();
 			selecteditem = map.SelectedVertices.AddLast(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="326" endline="332">
<![CDATA[
 
 		// Selected
 		protected override void DoSelect()
 		{
 			base.DoSelect();
 			selecteditem = map.SelectedThings.AddLast(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="493" endline="499">
<![CDATA[
 
 		// Selected
 		protected override void DoSelect()
 		{
 			base.DoSelect();
 			selecteditem = map.SelectedLinedefs.AddLast(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="367" endline="373">
<![CDATA[
 
 		// Selected
 		protected override void DoSelect()
 		{
 			base.DoSelect();
 			selecteditem = map.SelectedSectors.AddLast(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="203" endline="210">
<![CDATA[
 		
 		// After deserialization
 		internal void PostDeserialize(MapSet map)
 		{
 			triangles.PostDeserialize(map);
 			updateneeded = true;
 			triangulationneeded = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UnknownImageReader.cs" startline="46" endline="58">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This creates a Bitmap from the given data
 		// Returns null on failure
 		public Bitmap ReadAsBitmap(Stream stream, out int offsetx, out int offsety)
 		{
 			offsetx = int.MinValue;
 			offsety = int.MinValue;
 			return ReadAsBitmap(stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomColormapReader.cs" startline="77" endline="85">
<![CDATA[
 
 		// This creates a Bitmap from the given data
 		// Returns null on failure
 		public Bitmap ReadAsBitmap(Stream stream, out int offsetx, out int offsety)
 		{
 			offsetx = int.MinValue;
 			offsety = int.MinValue;
 			return ReadAsBitmap(stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\FileImageReader.cs" startline="346" endline="358">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This creates a Bitmap from the given data
 		// Returns null on failure
 		public Bitmap ReadAsBitmap(Stream stream, out int offsetx, out int offsety)
 		{
 			offsetx = int.MinValue;
 			offsety = int.MinValue;
 			return ReadAsBitmap(stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomFlatReader.cs" startline="83" endline="91">
<![CDATA[
 
 		// This creates a Bitmap from the given data
 		// Returns null on failure
 		public Bitmap ReadAsBitmap(Stream stream, out int offsetx, out int offsety)
 		{
 			offsetx = int.MinValue;
 			offsety = int.MinValue;
 			return ReadAsBitmap(stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="493" endline="503">
<![CDATA[
 
 		// This sets texture
 		public void SetFloorTexture(string name)
 		{
 			BeforePropsChange();
 			
 			floortexname = name;
 			longfloortexname = Lump.MakeLongName(name);
 			updateneeded = true;
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="504" endline="514">
<![CDATA[
 
 		// This sets texture
 		public void SetCeilTexture(string name)
 		{
 			BeforePropsChange();
 			
 			ceiltexname = name;
 			longceiltexname = Lump.MakeLongName(name);
 			updateneeded = true;
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="861" endline="874">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Record and Playback
 
 		internal void RecAddVertex(Vertex v)
 		{
 			if(!BeginRecordData(StreamCodes.AddVertex)) return;
 			ss.wInt(v.Index);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="929" endline="938">
<![CDATA[
 
 		internal void RecAddLinedef(Linedef l)
 		{
 			if(!BeginRecordData(StreamCodes.AddLinedef)) return;
 			ss.wInt(l.Index);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1093" endline="1102">
<![CDATA[
 
 		internal void RecAddSidedef(Sidedef s)
 		{
 			if(!BeginRecordData(StreamCodes.AddSidedef)) return;
 			ss.wInt(s.Index);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1186" endline="1195">
<![CDATA[
 
 		internal void RecAddSector(Sector s)
 		{
 			if(!BeginRecordData(StreamCodes.AddSector)) return;
 			ss.wInt(s.Index);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1246" endline="1255">
<![CDATA[
 
 		internal void RecAddThing(Thing t)
 		{
 			if(!BeginRecordData(StreamCodes.AddThing)) return;
 			ss.wInt(t.Index);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\NodebuilderInfo.cs" startline="95" endline="105">
<![CDATA[
 
 		// Constructor for "none" nodebuilder
 		public NodebuilderInfo()
 		{
 			// Initialize
 			this.name = "";
 			this.compiler = null;
 			this.title = "[do not build nodes]";
 			this.parameters = "";
 			this.specialoutputfile = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="648" endline="657">
<![CDATA[
 
 		/// <summary>
 		/// Call this to initiate a rectangular multi-selection.
 		/// </summary>
 		protected virtual void StartMultiSelection()
 		{
 			selecting = true;
 			selectstart = mousemappos;
 			selectionrect = new RectangleF(selectstart.x, selectstart.y, 0, 0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="197" endline="208">
<![CDATA[
 
 		#endregion
 
 		#region ================== Loading / Unloading
 
 		// This loads all data resources
 		internal void Load(DataLocationList configlist, DataLocationList maplist, DataLocation maplocation)
 		{
 			DataLocationList all = DataLocationList.Combined(configlist, maplist);
 			all.Add(maplocation);
 			Load(all);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DShader.cs" startline="57" endline="78">
<![CDATA[
 		protected bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		// Disposing
 		public bool IsDisposed { get { return isdisposed; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public D3DShader(ShaderManager manager)
 		{
 			// Initialize
 			this.manager = manager;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DDevice.cs" startline="72" endline="105">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		internal Device Device { get { return device; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		internal RenderTargetControl RenderTarget { get { return rendertarget; } }
 		internal Viewport Viewport { get { return viewport; } }
 		internal ShaderManager Shaders { get { return shaders; } }
 		internal Surface BackBuffer { get { return backbuffer; } }
 		internal Surface DepthBuffer { get { return depthbuffer; } }
 		internal TextFont Font { get { return font; } }
 		internal Texture FontTexture { get { return fonttexture.Texture; } }
 		internal Filter PostFilter { get { return postfilter; } }
 		internal Filter MipGenerateFilter { get { return mipgeneratefilter; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal D3DDevice(RenderTargetControl rendertarget)
 		{
 			// Set render target
 			this.rendertarget = rendertarget;
 
 			// Create resources list
 			resources = new Dictionary<ID3DResource, ID3DResource>();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\ShaderManager.cs" startline="93" endline="110">
<![CDATA[
 
 		// Disposer
 		public void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				UnloadResource();
 
 				// Unregister as resource
 				device.UnregisterResource(this);
 				
 				// Done
 				device = null;
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingInfoPanel.cs" startline="8" endline="52">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ThingInfoPanel()
 		{
 			// Initialize
 			InitializeComponent();
 
 			// Hide stuff when in Doom format
 			hexenformatwidth = infopanel.Width;
 			doomformatwidth = infopanel.Width - 190;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\LinedefInfoPanel.cs" startline="8" endline="51">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public LinedefInfoPanel()
 		{
 			// Initialize
 			InitializeComponent();
 
 			// Hide stuff when in Doom format
 			hexenformatwidth = infopanel.Width;
 			doomformatwidth = infopanel.Width - 190;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ColorImage.cs" startline="45" endline="55">
<![CDATA[
 		public ColorImage(PixelColor color, int width, int height)
 		{
 			// Initialize
 			this.width = width;
 			this.height = height;
 			this.color = color;
 			SetName(color.ToColorValue().ToString());
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualThing.cs" startline="220" endline="229">
<![CDATA[
 		
 		// This sets the vertices for the thing sprite
 		protected void SetVertices(ICollection<WorldVertex> verts)
 		{
 			// Copy vertices
 			vertices = new WorldVertex[verts.Count];
 			verts.CopyTo(vertices, 0);
 			triangles = vertices.Length / 3;
 			updategeo = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="419" endline="427">
<![CDATA[
 		
 		// This adds an item
 		public void Add(string text, ImageData image, object tag, ListViewGroup group)
 		{
 			ImageBrowserItem i = new ImageBrowserItem(text, image, tag);
 			i.ListGroup = group;
 			i.Group = group;
 			items.Add(i);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer.cs" startline="66" endline="82">
<![CDATA[
 
 		// Disposer
 		internal virtual void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 
 				// Unregister resource
 				graphics.UnregisterResource(this);
 				
 				// Done
 				graphics = null;
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoSnapshot.cs" startline="74" endline="83">
<![CDATA[
 
 		// Constructor
 		internal UndoSnapshot(UndoSnapshot info, MemoryStream recstream)
 		{
 			if(recstream == null) General.Fail("Argument cannot be null!");
 			this.ticketid = info.ticketid;
 			this.description = info.description;
 			this.recstream = recstream;
 			this.filename = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\OpenMapOptionsForm.cs" startline="8" endline="59">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public OpenMapOptionsForm(string filepathname)
 		{
 			// Initialize
 			InitializeComponent();
 			this.Text = "Open Map from " + Path.GetFileName(filepathname);
 			this.filepathname = filepathname;
 			this.options = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\ShaderManager.cs" startline="60" endline="92">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public bool Enabled { get { return useshaders; } }
 		public string ShaderTechnique { get { return shadertechnique; } }
 		public Display2DShader Display2D { get { return display2dshader; } }
 		public Things2DShader Things2D { get { return things2dshader; } }
 		public World3DShader World3D { get { return world3dshader; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		internal D3DDevice D3DDevice { get { return device; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public ShaderManager(D3DDevice device)
 		{
 			// Initialize
 			this.device = device;
 			
 			// Load
 			ReloadResource();
 
 			// Register as resource
 			device.RegisterResource(this);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalParser.cs" startline="62" endline="95">
<![CDATA[
 		private int cpErrorResult = 0;
 		private string cpErrorDescription = "";
 		private int cpErrorLine = 0;
 		
 		// Configuration root
 		private UniversalCollection root = null;
 
 		// Settings
 		private bool strictchecking = true;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		// Properties
 		public int ErrorResult { get { return cpErrorResult; } }
 		public string ErrorDescription { get { return cpErrorDescription; } }
 		public int ErrorLine { get { return cpErrorLine; } }
 		public UniversalCollection Root { get { return root; } }
 		public bool StrictChecking { get { return strictchecking; } set { strictchecking = value; } }
 		
 		#endregion
 		
 		#region ================== Constructor / Destructor
 		
 		// Constructor
 		public UniversalParser()
 		{
 			// Standard new configuration
 			NewConfiguration();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="170" endline="202">
<![CDATA[
 		private bool cpErrorResult = false;
 		private string cpErrorDescription = "";
 		private int cpErrorLine = 0;
 		private string cpErrorFile = "";
 		
 		// Configuration root
 		private IDictionary root = null;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		// Properties
 		public bool ErrorResult { get { return cpErrorResult; } }
 		public string ErrorDescription { get { return cpErrorDescription; } }
 		public int ErrorLine { get { return cpErrorLine; } }
 		public string ErrorFile { get { return cpErrorFile; } }
 		public IDictionary Root { get { return root; } set { root = value; } }
 		public bool Sorted { get { return (root is ListDictionary); } }
 		
 		#endregion
 		
 		#region ================== Constructor / Destructor
 		
 		// Constructor
 		public Configuration()
 		{
 			// Standard new configuration
 			NewConfiguration();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="170" endline="202">
<![CDATA[
 		private bool cpErrorResult = false;
 		private string cpErrorDescription = "";
 		private int cpErrorLine = 0;
 		private string cpErrorFile = "";
 		
 		// Configuration root
 		private IDictionary root = null;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		// Properties
 		public bool ErrorResult { get { return cpErrorResult; } }
 		public string ErrorDescription { get { return cpErrorDescription; } }
 		public int ErrorLine { get { return cpErrorLine; } }
 		public string ErrorFile { get { return cpErrorFile; } }
 		public IDictionary Root { get { return root; } set { root = value; } }
 		public bool Sorted { get { return (root is ListDictionary); } }
 		
 		#endregion
 		
 		#region ================== Constructor / Destructor
 		
 		// Constructor
 		public Configuration()
 		{
 			// Standard new configuration
 			NewConfiguration();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ZDTextParser.cs" startline="43" endline="76">
<![CDATA[
 		protected string whitespace = "\n \t\r";
 		protected string specialtokens = "
 		
 		// Input data stream
 		protected Stream datastream;
 		protected BinaryReader datareader;
 		protected string sourcename;
 		
 		// Error report
 		private int errorline;
 		private string errordesc;
 		private string errorsource;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		internal Stream DataStream { get { return datastream; } }
 		internal BinaryReader DataReader { get { return datareader; } }
 		public int ErrorLine { get { return errorline; } }
 		public string ErrorDescription { get { return errordesc; } }
 		public string ErrorSource { get { return errorsource; } }
 		public bool HasError { get { return (errordesc != null); } }
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		protected ZDTextParser()
 		{
 			// Initialize
 			errordesc = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="170" endline="202">
<![CDATA[
 		private bool cpErrorResult = false;
 		private string cpErrorDescription = "";
 		private int cpErrorLine = 0;
 		private string cpErrorFile = "";
 		
 		// Configuration root
 		private IDictionary root = null;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		// Properties
 		public bool ErrorResult { get { return cpErrorResult; } }
 		public string ErrorDescription { get { return cpErrorDescription; } }
 		public int ErrorLine { get { return cpErrorLine; } }
 		public string ErrorFile { get { return cpErrorFile; } }
 		public IDictionary Root { get { return root; } set { root = value; } }
 		public bool Sorted { get { return (root is ListDictionary); } }
 		
 		#endregion
 		
 		#region ================== Constructor / Destructor
 		
 		// Constructor
 		public Configuration()
 		{
 			// Standard new configuration
 			NewConfiguration();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="428" endline="437">
<![CDATA[
 		
 		// This adds an item
 		public void Add(string text, ImageData image, object tag, ListViewGroup group, string tooltiptext)
 		{
 			ImageBrowserItem i = new ImageBrowserItem(text, image, tag);
 			i.ListGroup = group;
 			i.Group = group;
 			i.ToolTipText = tooltiptext;
 			items.Add(i);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\AllTexturesSet.cs" startline="56" endline="67">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Destructor
 
 		// New texture set constructor
 		public AllTextureSet()
 		{
 			this.name = NAME;
 			this.textures = new List<ImageData>();
 			this.flats = new List<ImageData>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\UnknownImage.cs" startline="38" endline="57">
<![CDATA[
 		private Bitmap loadbitmap = null;
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public UnknownImage(Bitmap image)
 		{
 			// Initialize
 			this.width = 0;
 			this.height = 0;
 			this.loadbitmap = image;
 			SetName("");
 			
 			LocalLoadImage();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="477" endline="486">
<![CDATA[
 
 		// This sets texture
 		public void SetTextureHigh(string name)
 		{
 			BeforePropsChange();
 			
 			texnamehigh = name;
 			longtexnamehigh = Lump.MakeLongName(name);
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="487" endline="496">
<![CDATA[
 
 		// This sets texture
 		public void SetTextureMid(string name)
 		{
 			BeforePropsChange();
 			
 			texnamemid = name;
 			longtexnamemid = Lump.MakeLongName(name);
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="497" endline="506">
<![CDATA[
 
 		// This sets texture
 		public void SetTextureLow(string name)
 		{
 			BeforePropsChange();
 			
 			texnamelow = name;
 			longtexnamelow = Lump.MakeLongName(name);
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ButtonsNumericTextbox.cs" startline="48" endline="74">
<![CDATA[
 		private bool ignorebuttonchange = false;
 		private StepsList steps = null;
 		private int stepsize = 1;
 		private System.ComponentModel.IContainer components = null;
 		public ButtonsNumericTextbox()
 		{
 			InitializeComponent();
 			buttons.Value = 0;
 			textbox.MouseWheel += textbox_MouseWheel;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\MatchingTextureSet.cs" startline="66" endline="78">
<![CDATA[
 		
 		// Texture set from defined set
 		public MatchingTextureSet(DefinedTextureSet definedset)
 		{
 			// Copy the name
 			this.name = definedset.Name;
 			
 			// Copy the filters
 			this.filters = new List<string>(definedset.Filters);
 			
 			// Setup
 			Setup();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="225" endline="236">
<![CDATA[
 
 		// Loading
 		private void TextureBrowserForm_Load(object sender, EventArgs e)
 		{
 			// Normal windowstate?
 			if(this.WindowState == FormWindowState.Normal)
 			{
 				// Keep last position and size
 				lastposition = this.Location;
 				lastsize = this.Size;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="237" endline="248">
<![CDATA[
 
 		// Resized
 		private void TextureBrowserForm_ResizeEnd(object sender, EventArgs e)
 		{
 			// Normal windowstate?
 			if(this.WindowState == FormWindowState.Normal)
 			{
 				// Keep last position and size
 				lastposition = this.Location;
 				lastsize = this.Size;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="249" endline="260">
<![CDATA[
 
 		// Moved
 		private void TextureBrowserForm_Move(object sender, EventArgs e)
 		{
 			// Normal windowstate?
 			if(this.WindowState == FormWindowState.Normal)
 			{
 				// Keep last position and size
 				lastposition = this.Location;
 				lastsize = this.Size;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="224" endline="235">
<![CDATA[
 
 		// Loading
 		private void FlatBrowserForm_Load(object sender, EventArgs e)
 		{
 			// Normal windowstate?
 			if(this.WindowState == FormWindowState.Normal)
 			{
 				// Keep last position and size
 				lastposition = this.Location;
 				lastsize = this.Size;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="236" endline="247">
<![CDATA[
 
 		// Resized
 		private void FlatBrowserForm_ResizeEnd(object sender, EventArgs e)
 		{
 			// Normal windowstate?
 			if(this.WindowState == FormWindowState.Normal)
 			{
 				// Keep last position and size
 				lastposition = this.Location;
 				lastsize = this.Size;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="248" endline="259">
<![CDATA[
 
 		// Moved
 		private void FlatBrowserForm_Move(object sender, EventArgs e)
 		{
 			// Normal windowstate?
 			if(this.WindowState == FormWindowState.Normal)
 			{
 				// Keep last position and size
 				lastposition = this.Location;
 				lastsize = this.Size;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="514" endline="525">
<![CDATA[
 		
 		// Window is moved
 		private void MainForm_Move(object sender, EventArgs e)
 		{
 			// Normal windowstate?
 			if(this.WindowState == FormWindowState.Normal)
 			{
 				// Keep last position and size
 				lastposition = this.Location;
 				lastsize = this.Size;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="534" endline="545">
<![CDATA[
 
 		// Window was resized
 		private void MainForm_ResizeEnd(object sender, EventArgs e)
 		{
 			// Normal windowstate?
 			if(this.WindowState == FormWindowState.Normal)
 			{
 				// Keep last position and size
 				lastposition = this.Location;
 				lastsize = this.Size;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptEditorForm.cs" startline="160" endline="171">
<![CDATA[
 
 		// Window resized
 		private void ScriptEditorForm_ResizeEnd(object sender, EventArgs e)
 		{
 			// Normal windowstate?
 			if(this.WindowState == FormWindowState.Normal)
 			{
 				// Keep last position and size
 				lastposition = this.Location;
 				lastsize = this.Size;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptEditorForm.cs" startline="172" endline="183">
<![CDATA[
 
 		// Window moved
 		private void ScriptEditorForm_Move(object sender, EventArgs e)
 		{
 			// Normal windowstate?
 			if(this.WindowState == FormWindowState.Normal)
 			{
 				// Keep last position and size
 				lastposition = this.Location;
 				lastsize = this.Size;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ArgumentInfo.cs" startline="94" endline="103">
<![CDATA[
 
 		// Constructor for unknown argument info
 		internal ArgumentInfo(int argindex)
 		{
 			// Read
 			this.used = false;
 			this.title = "Argument " + (argindex + 1);
 			this.type = 0;
 			this.enumlist = new EnumList();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\OpenMapOptionsForm.cs" startline="8" endline="59">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public OpenMapOptionsForm(string filepathname)
 		{
 			// Initialize
 			InitializeComponent();
 			this.Text = "Open Map from " + Path.GetFileName(filepathname);
 			this.filepathname = filepathname;
 			this.options = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="532" endline="546">
<![CDATA[
 
 		// Mouse button released
 		public override void OnMouseUp(MouseEventArgs e)
 		{
 			// Releasing drag button?
 			if(e.Button == mousedragging)
 			{
 				// No longer dragging
 				OnDragStop(e);
 				mousedragging = MouseButtons.None;
 			}
 			
 			// Let the base class know
 			base.OnMouseUp(e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CustomThingsFilter.cs" startline="48" endline="65">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor for a new filter
 		public CustomThingsFilter()
 		{
 			// Initialize
 			requiredfields = new List<string>();
 			forbiddenfields = new List<string>();
 			categoryname = "";
 			thingtype = -1;
 			name = "Unnamed filter";
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="136" endline="2209">
<![CDATA[
 		private IntPtr libraryptr = IntPtr.Zero;
 		private IntPtr controlptr = IntPtr.Zero;
 		private int directptr;
 
 		// This ignores key combinations so that they are passed
 		// on to the other controls on the parent form
 		private Dictionary<int, int> ignoredkeys;
 		
 		// States
 		private ScriptMarginType indexmargintype;
 		private ScriptIndicatorStyle indexindicatorstyle;
 		
 		#endregion
 
 		#region ================== Properties
 		
 		/// <summary>
 		/// Are white space characters currently visible?
 		/// Returns one of SCWS_* constants.
 		/// </summary>
 		public ScriptWhiteSpace ViewWhitespace
 		{
 			get { return (ScriptWhiteSpace)ViewWS; }
 			set { ViewWS = (int)value; }
 		}
 
 		/// <summary>
 		/// Retrieve the current end of line mode - one of CRLF, CR, or LF.
 		/// </summary>
 		public ScriptEndOfLine EndOfLineMode
 		{
 			get { return (ScriptEndOfLine)EOLMode; }
 			set { EOLMode = (int)value; }
 		}
 
 		/// <summary>
 		/// The type of a margin.
 		/// </summary>
 		public ScriptMarginType MarginType { get { return indexmargintype; } }
 
 		/// <summary>
 		/// The type of a margin.
 		/// </summary>
 		public ScriptIndicatorStyle IndicatorStyle { get { return indexindicatorstyle; } }
 
 		/// <summary>
 		/// Are there any redoable actions in the undo history?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool CanRedo
 		{
 			get
 			{
 				return FastPerform(2016, 0, 0) != 0 ? true 
 			}
 		}
 
 		/// <summary>
 		/// Is there an auto-completion list visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCActive
 		{
 			get
 			{
 				return FastPerform(2102, 0, 0) != 0 ? true 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the position of the caret when the auto-completion list was displayed.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int AutoCPosStart
 		{
 			get
 			{
 				return (int)FastPerform(2103, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Will a paste succeed?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool CanPaste
 		{
 			get
 			{
 				return FastPerform(2173, 0, 0) != 0 ? true 
 			}
 		}
 
 		/// <summary>
 		/// Are there any undoable actions in the undo history?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool CanUndo
 		{
 			get
 			{
 				return FastPerform(2174, 0, 0) != 0 ? true 
 			}
 		}
 
 		/// <summary>
 		/// Is there an active call tip?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsCallTipActive
 		{
 			get
 			{
 				return FastPerform(2202, 0, 0) != 0 ? true 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the position where the caret was before displaying the call tip.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int CallTipPosStart
 		{
 			get
 			{
 				return (int)FastPerform(2203, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Create a new document object.
 		/// Starts with reference count of 1 and not selected into editor.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int CreateDocument
 		{
 			get
 			{
 				return (int)FastPerform(2375, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Get currently selected item position in the auto-completion list
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int AutoCGetCurrent
 		{
 			get
 			{
 				return (int)FastPerform(2445, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Width of the the auto-completion list
 		/// </summary>
 		public int AutoCMaximumWidth
 		{
 			get
 			{
 				return (int)FastPerform(2209, 0, 0);
 			}
 			
 			set
 			{
 				FastPerform(2208, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Height of the the auto-completion list
 		/// </summary>
 		public int AutoCMaximumHeight
 		{
 			get
 			{
 				return (int)FastPerform(2211, 0, 0);
 			}
 
 			set
 			{
 				FastPerform(2210, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Spacing above a line
 		/// </summary>
 		public int ExtraAscent
 		{
 			get
 			{
 				return (int)FastPerform(2526, 0, 0);
 			}
 
 			set
 			{
 				FastPerform(2525, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Spacing below a line
 		/// </summary>
 		public int ExtraDescent
 		{
 			get
 			{
 				return (int)FastPerform(2528, 0, 0);
 			}
 
 			set
 			{
 				FastPerform(2527, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns the number of characters in the document.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int Length
 		{
 			get
 			{
 				return (int)FastPerform(2006, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns the character byte at the position.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int CharAt(int pos)
 		{
 			return (int)FastPerform(2007, (uint)pos, 0);
 		}
 
 		/// <summary>
 		/// Returns the position of the caret.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int CurrentPos
 		{
 			get
 			{
 				return (int)FastPerform(2008, 0, 0);
 			}
 			set
 			{
 				FastPerform(2141, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns the position of the opposite end of the selection to the caret.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int AnchorPosition
 		{
 			get
 			{
 				return (int)FastPerform(2009, 0, 0);
 			}
 			set
 			{
 				FastPerform(2026, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns the style byte at the position.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int StyleAt(int pos)
 		{
 			return (int)FastPerform(2010, (uint)pos, 0);
 		}
 
 		/// <summary>
 		/// Is undo history being collected?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsUndoCollection
 		{
 			get
 			{
 				return FastPerform(2019, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2012, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Are white space characters currently visible?
 		/// Returns one of SCWS_* constants.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int ViewWS
 		{
 			get
 			{
 				return (int)FastPerform(2020, 0, 0);
 			}
 			set
 			{
 				FastPerform(2021, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the position of the last correctly styled character.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int EndStyled
 		{
 			get
 			{
 				return (int)FastPerform(2028, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the current end of line mode - one of CRLF, CR, or LF.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int EOLMode
 		{
 			get
 			{
 				return (int)FastPerform(2030, 0, 0);
 			}
 			set
 			{
 				FastPerform(2031, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Is drawing done first into a buffer or direct to the screen?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsBufferedDraw
 		{
 			get
 			{
 				return FastPerform(2034, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2035, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the visible size of a tab.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int TabWidth
 		{
 			get
 			{
 				return (int)FastPerform(2121, 0, 0);
 			}
 			set
 			{
 				FastPerform(2036, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the type of a margin.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int GetMarginTypeN(int margin)
 		{
 			return (int)FastPerform(2241, (uint)margin, 0);
 		}
 
 		/// <summary>
 		/// Set a margin to be either numeric or symbolic.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetMarginTypeN(int margin, int marginType)
 		{
 			FastPerform(2240, (uint)margin, (uint)marginType);
 		}
 
 		/// <summary>
 		/// Retrieve the width of a margin in pixels.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int GetMarginWidthN(int margin)
 		{
 			return (int)FastPerform(2243, (uint)margin, 0);
 		}
 
 		/// <summary>
 		/// Set the width of a margin to a width expressed in pixels.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetMarginWidthN(int margin, int pixelWidth)
 		{
 			FastPerform(2242, (uint)margin, (uint)pixelWidth);
 		}
 
 		/// <summary>
 		/// Retrieve the marker mask of a margin.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int GetMarginMaskN(int margin)
 		{
 			return (int)FastPerform(2245, (uint)margin, 0);
 		}
 
 		/// <summary>
 		/// Set a mask that determines which markers are displayed in a margin.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetMarginMaskN(int margin, int mask)
 		{
 			FastPerform(2244, (uint)margin, (uint)mask);
 		}
 
 		/// <summary>
 		/// Retrieve the mouse click sensitivity of a margin.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool MarginSensitiveN(int margin)
 		{
 			return FastPerform(2247, (uint)margin, 0) != 0;
 		}
 
 		/// <summary>
 		/// Make a margin sensitive or insensitive to mouse clicks.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void MarginSensitiveN(int margin, bool sensitive)
 		{
 			FastPerform(2246, (uint)margin, (uint)(sensitive ? 1 
 		}
 
 		/// <summary>
 		/// Get the time in milliseconds that the caret is on and off.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int CaretPeriod
 		{
 			get
 			{
 				return (int)FastPerform(2075, 0, 0);
 			}
 			set
 			{
 				FastPerform(2076, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the style of an indicator.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int GetIndicStyle(int indic)
 		{
 			return (int)FastPerform(2081, (uint)indic, 0);
 		}
 
 		/// <summary>
 		/// Set an indicator to plain, squiggle or TT.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetIndicStyle(int indic, int style)
 		{
 			FastPerform(2080, (uint)indic, (uint)style);
 		}
 
 		/// <summary>
 		/// Retrieve the foreground colour of an indicator.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int GetIndicFore(int indic)
 		{
 			return (int)FastPerform(2083, (uint)indic, 0);
 		}
 
 		/// <summary>
 		/// Set the foreground colour of an indicator.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetIndicFore(int indic, int fore)
 		{
 			FastPerform(2082, (uint)indic, (uint)fore);
 		}
 
 		/// <summary>
 		/// Retrieve number of bits in style bytes used to hold the lexical state.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int StyleBits
 		{
 			get
 			{
 				return (int)FastPerform(2091, 0, 0);
 			}
 			set
 			{
 				FastPerform(2090, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the extra styling information for a line.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int GetLineState(int line)
 		{
 			return (int)FastPerform(2093, (uint)line, 0);
 		}
 
 		/// <summary>
 		/// Used to hold extra styling information for each line.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetLineState(int line, int state)
 		{
 			FastPerform(2092, (uint)line, (uint)state);
 		}
 
 		/// <summary>
 		/// Retrieve the last line number that has line state.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int MaxLineState
 		{
 			get
 			{
 				return (int)FastPerform(2094, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Is the background of the line containing the caret in a different colour?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsCaretLineVisible
 		{
 			get
 			{
 				return FastPerform(2095, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2096, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Get the colour of the background of the line containing the caret.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int CaretLineBack
 		{
 			get
 			{
 				return (int)FastPerform(2097, 0, 0);
 			}
 			set
 			{
 				FastPerform(2098, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the auto-completion list separator character.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int AutoCSeparator
 		{
 			get
 			{
 				return (int)FastPerform(2107, 0, 0);
 			}
 			set
 			{
 				FastPerform(2106, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve whether auto-completion cancelled by backspacing before start.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCGetCancelAtStart
 		{
 			get
 			{
 				return FastPerform(2111, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2110, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve whether a single item auto-completion list automatically choose the item.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCGetChooseSingle
 		{
 			get
 			{
 				return FastPerform(2114, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2113, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve state of ignore case flag.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCGetIgnoreCase
 		{
 			get
 			{
 				return FastPerform(2116, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2115, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve whether or not autocompletion is hidden automatically when nothing matches.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCGetAutoHide
 		{
 			get
 			{
 				return FastPerform(2119, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2118, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve whether or not autocompletion deletes any word characters
 		/// after the inserted text upon completion.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCGetDropRestOfWord
 		{
 			get
 			{
 				return FastPerform(2271, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2270, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the auto-completion list type-separator character.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int AutoCTypeSeparator
 		{
 			get
 			{
 				return (int)FastPerform(2285, 0, 0);
 			}
 			set
 			{
 				FastPerform(2286, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve indentation size.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int Indent
 		{
 			get
 			{
 				return (int)FastPerform(2123, 0, 0);
 			}
 			set
 			{
 				FastPerform(2122, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve whether tabs will be used in indentation.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsUseTabs
 		{
 			get
 			{
 				return FastPerform(2125, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2124, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the number of columns that a line is indented.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int GetLineIndentation(int line)
 		{
 			return (int)FastPerform(2127, (uint)line, 0);
 		}
 
 		/// <summary>
 		/// Change the indentation of a line to a number of columns.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetLineIndentation(int line, int indentSize)
 		{
 			FastPerform(2126, (uint)line, (uint)indentSize);
 		}
 
 		/// <summary>
 		/// Retrieve the position before the first non indentation character on a line.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int LineIndentPosition(int line)
 		{
 			return (int)FastPerform(2128, (uint)line, 0);
 		}
 
 		/// <summary>
 		/// Retrieve the column number of a position, taking tab width into account.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int Column(int pos)
 		{
 			return (int)FastPerform(2129, (uint)pos, 0);
 		}
 
 		/// <summary>
 		/// Is the horizontal scroll bar visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsHScrollBar
 		{
 			get
 			{
 				return FastPerform(2131, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2130, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Are the indentation guides visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int IndentationGuides
 		{
 			get
 			{
 				return (int)FastPerform(2133, 0, 0);
 			}
 			set
 			{
 				FastPerform(2132, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Get the highlighted indentation guide column.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int HighlightGuide
 		{
 			get
 			{
 				return (int)FastPerform(2135, 0, 0);
 			}
 			set
 			{
 				FastPerform(2134, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Get the position after the last visible characters on a line.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int LineEndPosition(int line)
 		{
 			return (int)FastPerform(2136, (uint)line, 0);
 		}
 
 		/// <summary>
 		/// Get the code page used to interpret the bytes of the document as characters.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int CodePage
 		{
 			get
 			{
 				return (int)FastPerform(2137, 0, 0);
 			}
 			set
 			{
 				FastPerform(2037, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Get the foreground colour of the caret.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int CaretFore
 		{
 			get
 			{
 				return (int)FastPerform(2138, 0, 0);
 			}
 			set
 			{
 				FastPerform(2069, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// In palette mode?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsUsePalette
 		{
 			get
 			{
 				return FastPerform(2139, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2039, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// In read-only mode?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsReadOnly
 		{
 			get
 			{
 				return FastPerform(2140, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2171, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Returns the position at the start of the selection.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int SelectionStart
 		{
 			get
 			{
 				return (int)FastPerform(2143, 0, 0);
 			}
 			set
 			{
 				FastPerform(2142, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns the position at the end of the selection.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int SelectionEnd
 		{
 			get
 			{
 				return (int)FastPerform(2145, 0, 0);
 			}
 			set
 			{
 				FastPerform(2144, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns the print magnification.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int PrintMagnification
 		{
 			get
 			{
 				return (int)FastPerform(2147, 0, 0);
 			}
 			set
 			{
 				FastPerform(2146, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns the print colour mode.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int PrintColourMode
 		{
 			get
 			{
 				return (int)FastPerform(2149, 0, 0);
 			}
 			set
 			{
 				FastPerform(2148, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the display line at the top of the display.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int FirstVisibleLine
 		{
 			get
 			{
 				return (int)FastPerform(2152, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns the number of lines in the document. There is always at least one.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int LineCount
 		{
 			get
 			{
 				return (int)FastPerform(2154, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns the size in pixels of the left margin.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int MarginLeft
 		{
 			get
 			{
 				return (int)FastPerform(2156, 0, 0);
 			}
 			set
 			{
 				FastPerform(2155, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns the size in pixels of the right margin.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int MarginRight
 		{
 			get
 			{
 				return (int)FastPerform(2158, 0, 0);
 			}
 			set
 			{
 				FastPerform(2157, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Is the document different from when it was last saved?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsModify
 		{
 			get
 			{
 				return FastPerform(2159, 0, 0) != 0;
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the number of characters in the document.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int TextLength
 		{
 			get
 			{
 				return (int)FastPerform(2183, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve a pointer to a function that processes messages for this Scintilla.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int DirectFunction
 		{
 			get
 			{
 				return (int)FastPerform(2184, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve a pointer value to use as the first argument when calling
 		/// the function returned by GetDirectFunction.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int DirectPointer
 		{
 			get
 			{
 				return (int)FastPerform(2185, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Returns true if overtype mode is active otherwise false is returned.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsOvertype
 		{
 			get
 			{
 				return FastPerform(2187, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2186, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Returns the width of the insert mode caret.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int CaretWidth
 		{
 			get
 			{
 				return (int)FastPerform(2189, 0, 0);
 			}
 			set
 			{
 				FastPerform(2188, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Get the position that starts the target.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int TargetStart
 		{
 			get
 			{
 				return (int)FastPerform(2191, 0, 0);
 			}
 			set
 			{
 				FastPerform(2190, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Get the position that ends the target.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int TargetEnd
 		{
 			get
 			{
 				return (int)FastPerform(2193, 0, 0);
 			}
 			set
 			{
 				FastPerform(2192, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Get the search flags used by SearchInTarget.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int SearchFlags
 		{
 			get
 			{
 				return (int)FastPerform(2199, 0, 0);
 			}
 			set
 			{
 				FastPerform(2198, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the fold level of a line.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int GetFoldLevel(int line)
 		{
 			return (int)FastPerform(2223, (uint)line, 0);
 		}
 
 		/// <summary>
 		/// Set the fold level of a line.
 		/// This encodes an integer level along with flags indicating whether the
 		/// line is a header and whether it is effectively white space.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetFoldLevel(int line, int level)
 		{
 			FastPerform(2222, (uint)line, (uint)level);
 		}
 
 		/// <summary>
 		/// Find the last child line of a header line.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int LastChild(int line, int level)
 		{
 			return (int)FastPerform(2224, (uint)line, (uint)level);
 		}
 
 		/// <summary>
 		/// Find the last child line of a header line.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int LastChild(int line)
 		{
 			return (int)FastPerform(2224, (uint)line, 0);
 		}
 
 		/// <summary>
 		/// Find the parent line of a child line.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int FoldParent(int line)
 		{
 			return (int)FastPerform(2225, (uint)line, 0);
 		}
 
 		/// <summary>
 		/// Is a line visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsLineVisible
 		{
 			get
 			{
 				return FastPerform(2228, 0, 0) != 0;
 			}
 		}
 
 		/// <summary>
 		/// Is a header line expanded?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool FoldExpanded(int line)
 		{
 			return FastPerform(2230, (uint)line, 0) != 0;
 		}
 
 		/// <summary>
 		/// Show the children of a header line.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void FoldExpanded(int line, bool expanded)
 		{
 			FastPerform(2229, (uint)line, (uint)(expanded ? 1 
 		}
 
 		/// <summary>
 		/// Does a tab pressed when caret is within indentation indent?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsTabIndents
 		{
 			get
 			{
 				return FastPerform(2261, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2260, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Does a backspace pressed when caret is within indentation unindent?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsBackSpaceUnIndents
 		{
 			get
 			{
 				return FastPerform(2263, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2262, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the time the mouse must sit still to generate a mouse dwell event.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int MouseDwellTime
 		{
 			get
 			{
 				return (int)FastPerform(2265, 0, 0);
 			}
 			set
 			{
 				FastPerform(2264, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve whether text is word wrapped.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int WrapMode
 		{
 			get
 			{
 				return (int)FastPerform(2269, 0, 0);
 			}
 			set
 			{
 				FastPerform(2268, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrive the display mode of visual flags for wrapped lines.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int WrapVisualFlags
 		{
 			get
 			{
 				return (int)FastPerform(2461, 0, 0);
 			}
 			set
 			{
 				FastPerform(2460, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrive the location of visual flags for wrapped lines.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int WrapVisualFlagsLocation
 		{
 			get
 			{
 				return (int)FastPerform(2463, 0, 0);
 			}
 			set
 			{
 				FastPerform(2462, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrive the start indent for wrapped lines.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int WrapStartIndent
 		{
 			get
 			{
 				return (int)FastPerform(2465, 0, 0);
 			}
 			set
 			{
 				FastPerform(2464, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the degree of caching of layout information.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int LayoutCache
 		{
 			get
 			{
 				return (int)FastPerform(2273, 0, 0);
 			}
 			set
 			{
 				FastPerform(2272, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the document width assumed for scrolling.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int ScrollWidth
 		{
 			get
 			{
 				return (int)FastPerform(2275, 0, 0);
 			}
 			set
 			{
 				FastPerform(2274, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve whether the maximum scroll position has the last
 		/// line at the bottom of the view.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int EndAtLastLine
 		{
 			get
 			{
 				return (int)FastPerform(2278, 0, 0);
 			}
 			set
 			{
 				FastPerform(2277, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Is the vertical scroll bar visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsVScrollBar
 		{
 			get
 			{
 				return FastPerform(2281, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2280, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Is drawing done in two phases with backgrounds drawn before faoregrounds?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsTwoPhaseDraw
 		{
 			get
 			{
 				return FastPerform(2283, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2284, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Are the end of line characters visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsViewEOL
 		{
 			get
 			{
 				return FastPerform(2355, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2356, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Retrieve a pointer to the document object.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int DocPointer
 		{
 			get
 			{
 				return (int)FastPerform(2357, 0, 0);
 			}
 			set
 			{
 				FastPerform(2358, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the column number which text should be kept within.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int EdgeColumn
 		{
 			get
 			{
 				return (int)FastPerform(2360, 0, 0);
 			}
 			set
 			{
 				FastPerform(2361, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the edge highlight mode.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int EdgeMode
 		{
 			get
 			{
 				return (int)FastPerform(2362, 0, 0);
 			}
 			set
 			{
 				FastPerform(2363, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the colour used in edge indication.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int EdgeColour
 		{
 			get
 			{
 				return (int)FastPerform(2364, 0, 0);
 			}
 			set
 			{
 				FastPerform(2365, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieves the number of lines completely visible.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int LinesOnScreen
 		{
 			get
 			{
 				return (int)FastPerform(2370, 0, 0);
 			}
 		}
 
 		/// <summary>
 		/// Is the selection rectangular? The alternative is the more common stream selection.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsSelectionIsRectangle
 		{
 			get
 			{
 				return FastPerform(2372, 0, 0) != 0;
 			}
 		}
 
 		/// <summary>
 		/// Set the zoom level. This number of points is added to the size of all fonts.
 		/// It may be positive to magnify or negative to reduce.
 		/// Retrieve the zoom level.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int ZoomLevel
 		{
 			get
 			{
 				return (int)FastPerform(2374, 0, 0);
 			}
 			set
 			{
 				FastPerform(2373, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Get which document modification events are sent to the container.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int ModEventMask
 		{
 			get
 			{
 				return (int)FastPerform(2378, 0, 0);
 			}
 			set
 			{
 				FastPerform(2359, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Change internal focus flag.
 		/// Get internal focus flag.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsFocus
 		{
 			get
 			{
 				return FastPerform(2381, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2380, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Change error status - 0 = OK.
 		/// Get error status.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int Status
 		{
 			get
 			{
 				return (int)FastPerform(2383, 0, 0);
 			}
 			set
 			{
 				FastPerform(2382, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Set whether the mouse is captured when its button is pressed.
 		/// Get whether mouse gets captured.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsMouseDownCaptures
 		{
 			get
 			{
 				return FastPerform(2385, 0, 0) != 0;
 			}
 			set
 			{
 				FastPerform(2384, (uint)(value ? 1 
 			}
 		}
 
 		/// <summary>
 		/// Sets the cursor to one of the SC_CURSOR* values.
 		/// Get cursor type.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int CursorType
 		{
 			get
 			{
 				return (int)FastPerform(2387, 0, 0);
 			}
 			set
 			{
 				FastPerform(2386, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Change the way control characters are displayed
 		/// If symbol is < 32, keep the drawn way, else, use the given character.
 		/// Get the way control characters are displayed.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int ControlCharSymbol
 		{
 			get
 			{
 				return (int)FastPerform(2389, 0, 0);
 			}
 			set
 			{
 				FastPerform(2388, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Get and Set the xOffset (ie, horizonal scroll position).
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int XOffset
 		{
 			get
 			{
 				return (int)FastPerform(2398, 0, 0);
 			}
 			set
 			{
 				FastPerform(2397, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Is printing line wrapped?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int PrintWrapMode
 		{
 			get
 			{
 				return (int)FastPerform(2407, 0, 0);
 			}
 			set
 			{
 				FastPerform(2406, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Get the mode of the current selection.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int SelectionMode
 		{
 			get
 			{
 				return (int)FastPerform(2423, 0, 0);
 			}
 			set
 			{
 				FastPerform(2422, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Retrieve the lexing language of the document.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int Lexer
 		{
 			get
 			{
 				return (int)FastPerform(4002, 0, 0);
 			}
 			set
 			{
 				FastPerform(4001, (uint)value, 0);
 			}
 		}
 
 		/// <summary>
 		/// Clear all the styles and make equivalent to the global default style.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleClearAll()
 		{
 			FastPerform(2050, 0, 0);
 		}
 
 		/// <summary>
 		/// Set the foreground colour of a style.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetFore(int style, int fore)
 		{
 			FastPerform(2051, (uint)style, (uint)fore);
 		}
 
 		/// <summary>
 		/// Set the background colour of a style.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetBack(int style, int back)
 		{
 			FastPerform(2052, (uint)style, (uint)back);
 		}
 
 		/// <summary>
 		/// Set a style to be bold or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetBold(int style, bool bold)
 		{
 			FastPerform(2053, (uint)style, (uint)(bold ? 1 
 		}
 
 		/// <summary>
 		/// Set a style to be italic or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetItalic(int style, bool italic)
 		{
 			FastPerform(2054, (uint)style, (uint)(italic ? 1 
 		}
 
 		/// <summary>
 		/// Set the size of characters of a style.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetSize(int style, int sizePoints)
 		{
 			FastPerform(2055, (uint)style, (uint)sizePoints);
 		}
 
 		/// <summary>
 		/// Set the font of a style.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		unsafe public void StyleSetFont(int style, string fontName)
 		{
 			if(fontName == null || fontName.Equals(""))
 				fontName = "\0\0";
 
 			fixed(byte* b = System.Text.UTF8Encoding.UTF8.GetBytes(fontName))
 				FastPerform(2056, (uint)style, (uint)b);
 		}
 
 
 		/// <summary>
 		/// Set a style to have its end of line filled or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetEOLFilled(int style, bool filled)
 		{
 			FastPerform(2057, (uint)style, (uint)(filled ? 1 
 		}
 
 		/// <summary>
 		/// Set a style to be underlined or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetUnderline(int style, bool underline)
 		{
 			FastPerform(2059, (uint)style, (uint)(underline ? 1 
 		}
 
 		/// <summary>
 		/// Set a style to be mixed case, or to force upper or lower case.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetCase(int style, int caseForce)
 		{
 			FastPerform(2060, (uint)style, (uint)caseForce);
 		}
 
 		/// <summary>
 		/// Set the character set of the font in a style.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetCharacterSet(int style, int characterSet)
 		{
 			FastPerform(2066, (uint)style, (uint)characterSet);
 		}
 
 		/// <summary>
 		/// Set a style to be a hotspot or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetHotSpot(int style, bool hotspot)
 		{
 			FastPerform(2409, (uint)style, (uint)(hotspot ? 1 
 		}
 
 		/// <summary>
 		/// Set a style to be visible or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetVisible(int style, bool visible)
 		{
 			FastPerform(2074, (uint)style, (uint)(visible ? 1 
 		}
 
 		/// <summary>
 		/// Set the set of characters making up words for when moving or selecting by word.
 		/// First sets deaults like SetCharsDefault.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		unsafe public void WordChars(string characters)
 		{
 			if(characters == null || characters.Equals(""))
 				characters = "\0\0";
 
 			fixed(byte* b = System.Text.UTF8Encoding.UTF8.GetBytes(characters))
 				FastPerform(2077, 0, (uint)b);
 		}
 
 
 		/// <summary>
 		/// Set a style to be changeable or not (read only).
 		/// Experimental feature, currently buggy.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetChangeable(int style, bool changeable)
 		{
 			FastPerform(2099, (uint)style, (uint)(changeable ? 1 
 		}
 
 		/// <summary>
 		/// Define a set of characters that when typed will cause the autocompletion to
 		/// choose the selected item.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		unsafe public void AutoCSetFillUps(string characterSet)
 		{
 			if(characterSet == null || characterSet.Equals(""))
 				characterSet = "\0\0";
 
 			fixed(byte* b = System.Text.UTF8Encoding.UTF8.GetBytes(characterSet))
 				FastPerform(2112, 0, (uint)b);
 		}
 
 
 		/// <summary>
 		/// Set a fore colour for active hotspots.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void HotspotActiveFore(bool useSetting, int fore)
 		{
 			FastPerform(2410, (uint)(useSetting ? 1 
 		}
 
 		/// <summary>
 		/// Set a back colour for active hotspots.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void HotspotActiveBack(bool useSetting, int back)
 		{
 			FastPerform(2411, (uint)(useSetting ? 1 
 		}
 
 		/// <summary>
 		/// Set the set of characters making up whitespace for when moving or selecting by word.
 		/// Should be called after SetWordChars.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		unsafe public void WhitespaceChars(string characters)
 		{
 			if(characters == null || characters.Equals(""))
 				characters = "\0\0";
 
 			fixed(byte* b = System.Text.UTF8Encoding.UTF8.GetBytes(characters))
 				FastPerform(2443, 0, (uint)b);
 		}
 
 
 		/// <summary>
 		/// Set up a value that may be used by a lexer for some optional feature.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		unsafe public void Property(string key, string value)
 		{
 			if(key == null || key.Equals(""))
 				key = "\0\0";
 			if(value == null || value.Equals(""))
 				value = "\0\0";
 
 			fixed(byte* b = System.Text.UTF8Encoding.UTF8.GetBytes(value))
 			fixed(byte* b2 = System.Text.UTF8Encoding.UTF8.GetBytes(key))
 				FastPerform(4004, (uint)b2, (uint)b);
 		}
 
 
 		/// <summary>
 		/// Set up the key words used by the lexer.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		unsafe public void KeyWords(int keywordSet, string keyWords)
 		{
 			if(keyWords == null || keyWords.Equals(""))
 				keyWords = "\0\0";
 
 			fixed(byte* b = System.Text.UTF8Encoding.UTF8.GetBytes(keyWords))
 				FastPerform(4005, (uint)keywordSet, (uint)b);
 		}
 
 
 		/// <summary>
 		/// Set the lexing language of the document based on string name.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		unsafe public void LexerLanguage(string language)
 		{
 			if(language == null || language.Equals(""))
 				language = "\0\0";
 
 			fixed(byte* b = System.Text.UTF8Encoding.UTF8.GetBytes(language))
 				FastPerform(4006, 0, (uint)b);
 		}
 		
 		#endregion
 
 		#region ================== Contructor / Disposer
 
 		// Constructor
 		public ScintillaControl()
 		{
 			this.BackColor = SystemColors.Window;
 			
 			// Setup collections
 			ignoredkeys = new Dictionary<int, int>();
 
 			if(!this.DesignMode) Initialize();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapOptions.cs" startline="74" endline="83">
<![CDATA[
 
 			set
 			{
 				// Change the name, but keep previous name
 				if(currentname != value)
 				{
 					if(previousname == "") previousname = currentname;
 					currentname = value;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="208" endline="222">
<![CDATA[
 
 		internal void SetSectorP(Sector newsector)
 		{
 			// Detach from sector
 			if(sector != null) sector.DetachSidedefP(sectorlistitem);
 
 			// Change sector
 			sector = newsector;
 
 			// Attach to sector
 			if(sector != null)
 				sectorlistitem = sector.AttachSidedefP(this);
 
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualGeometry.cs" startline="146" endline="159">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 		
 		// This sets the vertices for this geometry
 		protected void SetVertices(ICollection<WorldVertex> verts)
 		{
 			// Copy vertices
 			vertices = new WorldVertex[verts.Count];
 			verts.CopyTo(vertices, 0);
 			triangles = vertices.Length / 3;
 			if(sector != null) sector.NeedsUpdateGeo = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\BitmapImage.cs" startline="47" endline="62">
<![CDATA[
 		public BitmapImage(Bitmap img, string name)
 		{
 			// Initialize
 			this.img = img;
 			this.AllowUnload = false;
 			SetName(name);
 
 			// Get width and height from image
 			width = img.Size.Width;
 			height = img.Size.Height;
 			scale.x = 1.0f;
 			scale.y = 1.0f;
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\LinedefActionInfo.cs" startline="96" endline="107">
<![CDATA[
 		
 		// Constructor for generalized type display
 		internal LinedefActionInfo(int index, string title, bool isknown, bool isgeneralized)
 		{
 			this.index = index;
 			this.isgeneralized = isgeneralized;
 			this.isknown = isknown;
 			this.title = title;
 			this.args = new ArgumentInfo[Linedef.NUM_ARGS];
 			for(int i = 0; i < Linedef.NUM_ARGS; i++)
 				this.args[i] = new ArgumentInfo(i);
 			for(int i = 0; i < Linedef.NUM_ARGS; i++)
 				this.args[i] = new ArgumentInfo(i);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\BinaryHeap.cs" startline="80" endline="88">
<![CDATA[
 		
 		// This swaps two items in place
 		protected virtual void SwapItems(int index1, int index2)
 		{
 			// Swap items
 			T tempitem = heap[index1];
 			heap[index1] = heap[index2];
 			heap[index2] = tempitem;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1205" endline="1215">
<![CDATA[
 
 		internal void RecRemSector(Sector s)
 		{
 			if(!BeginRecordData(StreamCodes.RemSector)) return;
 			ss.wInt(s.Index);
 			s.ReadWrite(ss);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1265" endline="1275">
<![CDATA[
 
 		internal void RecRemThing(Thing t)
 		{
 			if(!BeginRecordData(StreamCodes.RemThing)) return;
 			ss.wInt(t.Index);
 			t.ReadWrite(ss);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="468" endline="478">
<![CDATA[
 		
 		// This sets a flag
 		public void SetFlag(string flagname, bool value)
 		{
 			if(!flags.ContainsKey(flagname) || (IsFlagSet(flagname) != value))
 			{
 				BeforePropsChange();
 
 				flags[flagname] = value;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="86" endline="117">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Reading
 
 		// This reads a map from the file and returns a MapSet
 		public override MapSet Read(MapSet map, string mapname)
 		{
 			Dictionary<int, Vertex> vertexlink;
 			Dictionary<int, Sector> sectorlink;
 			
 			// Find the index where first map lump begins
 			int firstindex = wad.FindLumpIndex(mapname) + 1;
 
 			// Read vertices
 			vertexlink = ReadVertices(map, firstindex);
 
 			// Read sectors
 			sectorlink = ReadSectors(map, firstindex);
 
 			// Read linedefs and sidedefs
 			ReadLinedefs(map, firstindex, vertexlink, sectorlink);
 
 			// Read things
 			ReadThings(map, firstindex);
 			
 			// Remove unused vertices
 			map.RemoveUnusedVertices();
 			
 			// Return result;
 			return map;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="86" endline="118">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Reading
 
 		// This reads a map from the file and returns a MapSet
 		public override MapSet Read(MapSet map, string mapname)
 		{
 			int firstindex;
 			Dictionary<int, Vertex> vertexlink;
 			Dictionary<int, Sector> sectorlink;
 			
 			// Find the index where first map lump begins
 			firstindex = wad.FindLumpIndex(mapname) + 1;
 
 			// Read vertices
 			vertexlink = ReadVertices(map, firstindex);
 
 			// Read sectors
 			sectorlink = ReadSectors(map, firstindex);
 
 			// Read linedefs and sidedefs
 			ReadLinedefs(map, firstindex, vertexlink, sectorlink);
 
 			// Read things
 			ReadThings(map, firstindex);
 			
 			// Remove unused vertices
 			map.RemoveUnusedVertices();
 			
 			// Return result;
 			return map;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="558" endline="572">
<![CDATA[
 
 		/// <summary>This creates a new linedef and returns it.</summary>
 		public Linedef CreateLinedef(int index, Vertex start, Vertex end)
 		{
 			if(numlinedefs == General.Map.FormatInterface.MaxLinedefs)
 			{
 				General.Interface.DisplayStatus(StatusType.Warning, "Failed to complete operation
 				return null;
 			}
 
 			// Make the linedef
 			Linedef l = new Linedef(this, index, start, end);
 			AddItem(l, ref linedefs, index, ref numlinedefs);
 			return l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\TextLabel.cs" startline="264" endline="274">
<![CDATA[
 
 		// This unloads the resources
 		public void UnloadResource()
 		{
 			// Clean up
 			if(textbuffer != null) textbuffer.Dispose();
 			textbuffer = null;
 
 			// Need to update before we can render
 			updateneeded = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualThing.cs" startline="169" endline="178">
<![CDATA[
 		
 		// This is called before a device is reset
 		// (when resized or display adapter was changed)
 		public void UnloadResource()
 		{
 			// Trash geometry buffer
 			if(geobuffer != null) geobuffer.Dispose();
 			geobuffer = null;
 			updategeo = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualSector.cs" startline="110" endline="123">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This is called before a device is reset
 		// (when resized or display adapter was changed)
 		public virtual void UnloadResource()
 		{
 			// Trash geometry buffer
 			if(geobuffer != null) geobuffer.Dispose();
 			geobuffer = null;
 			updategeo = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\TexturesParser.cs" startline="57" endline="73">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		public TexturesParser()
 		{
 			// Syntax
 			whitespace = "\n \t\r";
 			specialtokens = ",{}\n";
 
 			// Initialize
 			textures = new Dictionary<string, TextureStructure>();
 			flats = new Dictionary<string, TextureStructure>();
 			sprites = new Dictionary<string, TextureStructure>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="252" endline="258">
<![CDATA[
 
 		// This calculates the length
 		public float GetLength()
 		{
 			// Calculate and return the length
 			return (float)Math.Sqrt(x * x + y * y + z * z);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="371" endline="383">
<![CDATA[
 
 		// This moves the thing
 		// NOTE
 		public void Move(float x, float y, float zoffset)
 		{
 			BeforePropsChange();
 			
 			// Change position
 			this.pos = new Vector3D(x, y, zoffset);
 			
 			if(type != General.Map.Config.Start3DModeThingType)
 				General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="308" endline="319">
<![CDATA[
 		
 		// This removes a lump from the WAD file
 		public void Remove(Lump lump)
 		{
 			// Remove from list
 			lumps.Remove(lump);
 			lump.Dispose();
 			numlumps--;
 			
 			// Write the new headers
 			WriteHeaders();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="365" endline="375">
<![CDATA[
 
 		// This ends writing to the record stream
 		private void EndRecordData()
 		{
 			// We write the difference in bytes to the stream so that
 			// the stream can be read from the end backwards
 			int delta = (int)(stream.Length - prevstreamlength);
 			ss.wInt(delta);
 			commandswritten++;
 			isrecordingcommand = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualSector.cs" startline="62" endline="91">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		internal List<VisualGeometry> FixedGeometry { get { return fixedgeometry; } }
 		internal List<VisualGeometry> AllGeometry { get { return allgeometry; } }
 		internal VertexBuffer GeometryBuffer { get { return geobuffer; } }
 		internal bool NeedsUpdateGeo { get { return updategeo; } set { updategeo |= value; } }
 		
 		public bool IsDisposed { get { return isdisposed; } }
 		public Sector Sector { get { return sector; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public VisualSector(Sector s)
 		{
 			// Initialize
 			this.sector = s;
 			allgeometry = new List<VisualGeometry>();
 			fixedgeometry = new List<VisualGeometry>();
 			sidedefgeometry = new Dictionary<Sidedef, List<VisualGeometry>>();
 
 			// Register as resource
 			General.Map.Graphics.RegisterResource(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="458" endline="477">
<![CDATA[
 
 		#endregion
 
 		#region ================== Input
 
 		// Mouse leaves the display
 		public override void OnMouseLeave(EventArgs e)
 		{
 			// Mouse is outside the display
 			mouseinside = false;
 			mousepos = new Vector2D(float.NaN, float.NaN);
 			mousemappos = mousepos;
 			mousebuttons = MouseButtons.None;
 			
 			// Determine new unprojected mouse coordinates
 			General.MainWindow.UpdateCoordinates(mousemappos);
 			
 			// Let the base class know
 			base.OnMouseLeave(e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ThingsFilter.cs" startline="187" endline="202">
<![CDATA[
 
 		// Disposer
 		internal virtual void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				visiblethings = null;
 				hiddenthings = null;
 				thingsvisiblestate = null;
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\AutoSelectTextbox.cs" startline="84" endline="90">
<![CDATA[
 
 		// When key is pressed
 		protected override void OnKeyDown(KeyEventArgs e)
 		{
 			base.OnKeyDown(e);
 			eventcount++;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="151" endline="161">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(Vector3D p, int c)
 		{
 			this.x = p.x;
 			this.y = p.y;
 			this.z = p.z;
 			this.c = c;
 			this.u = 0.0f;
 			this.v = 0.0f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapOptions.cs" startline="87" endline="103">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal MapOptions()
 		{
 			// Initialize
 			this.previousname = "";
 			this.currentname = "";
 			this.configfile = "";
 			this.strictpatches = false;
 			this.resources = new DataLocationList();
 			this.mapconfig = new Configuration(true);
 			this.scriptfiles = new List<string>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="87" endline="141">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public string FilePathName { get { return filepathname; } }
 		public string FileTitle { get { return filetitle; } }
 		public string TempPath { get { return temppath; } }
 		public MapOptions Options { get { return options; } }
 		public MapSet Map { get { return map; } }
 		public DataManager Data { get { return data; } }
 		public bool IsChanged { get { return changed | CheckScriptChanged(); } set { changed |= value; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		internal D3DDevice Graphics { get { return graphics; } }
 		public IRenderer2D Renderer2D { get { return renderer2d; } }
 		public IRenderer3D Renderer3D { get { return renderer3d; } }
 		internal Renderer2D CRenderer2D { get { return renderer2d; } }
 		internal Renderer3D CRenderer3D { get { return renderer3d; } }
 		public GameConfiguration Config { get { return config; } }
 		public ConfigurationInfo ConfigSettings { get { return configinfo; } }
 		public GridSetup Grid { get { return grid; } }
 		public UndoManager UndoRedo { get { return undoredo; } }
 		internal CopyPasteManager CopyPaste { get { return copypaste; } }
 		public IMapSetIO FormatInterface { get { return io; } }
 		internal Launcher Launcher { get { return launcher; } }
 		public ThingsFilter ThingsFilter { get { return thingsfilter; } }
 		internal List<CompilerError> Errors { get { return errors; } }
 		internal ScriptEditorForm ScriptEditor { get { return scriptwindow; } }
 		public VisualCamera VisualCamera { get { return visualcamera; } set { visualcamera = value; } }
 		public bool IsScriptsWindowOpen { get { return (scriptwindow != null) && !scriptwindow.IsDisposed; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal MapManager()
 		{
 			// We have no destructor
 			GC.SuppressFinalize(this);
 
 			// Create temporary path
 			temppath = General.MakeTempDirname();
 			Directory.CreateDirectory(temppath);
 			General.WriteLogLine("Temporary directory
 
 			// Basic objects
 			grid = new GridSetup();
 			undoredo = new UndoManager();
 			copypaste = new CopyPasteManager();
 			launcher = new Launcher(this);
 			thingsfilter = new NullThingsFilter();
 			errors = new List<CompilerError>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptFileDocumentTab.cs" startline="55" endline="72">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		public ScriptFileDocumentTab(ScriptEditorPanel panel, ScriptConfiguration config) 
 		{
 			string ext = "";
 			
 			// Initialize
 			this.filepathname = "";
 			this.config = config;
 			editor.SetupStyles(config);
 			if(config.Extensions.Length > 0) ext = "." + config.Extensions[0];
 			SetTitle("Untitled" + ext);
 			editor.ClearUndoRedo();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="573" endline="587">
<![CDATA[
 
 		/// <summary>This creates a new sidedef and returns it.</summary>
 		public Sidedef CreateSidedef(Linedef l, bool front, Sector s)
 		{
 			if(numsidedefs == int.MaxValue)
 			{
 				General.Interface.DisplayStatus(StatusType.Warning, "Failed to complete operation
 				return null;
 			}
 			
 			// Make the sidedef
 			Sidedef sd = new Sidedef(this, numsidedefs, l, front, s);
 			AddItem(sd, ref sidedefs, numsidedefs, ref numsidedefs);
 			return sd;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapElement.cs" startline="52" endline="72">
<![CDATA[
 		protected bool isdisposed = false;
 		
 		#endregion
 		
 		#region ================== Properties
 
 		public int Index { get { return listindex; } internal set { listindex = value; } }
 		public UniFields Fields { get { return fields; } }
 		public bool Marked { get { return marked; } set { marked = value; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal MapElement()
 		{
 			// Initialize
 			fields = new UniFields(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Presentation.cs" startline="121" endline="129">
<![CDATA[
 
 		// Constructor
 		public PresentLayer(RendererLayer layer, BlendingMode blending)
 		{
 			this.layer = layer;
 			this.blending = blending;
 			this.alpha = 1f;
 			this.antialiasing = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionAttribute.cs" startline="58" endline="73">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		/// <summary>
 		/// This binds a method to an action.
 		/// </summary>
 		/// <param name="action">The action name as defined in Actions.cfg resource.</param>
 		public ActionAttribute(string action)
 		{
 			// Initialize
 			this.action = action;
 			this.baseaction = false;
 			this.library = "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="162" endline="172">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(float x, float y, float z)
 		{
 			this.x = x;
 			this.y = y;
 			this.z = z;
 			this.c = -1;
 			this.u = 0.0f;
 			this.v = 0.0f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PasteOptionsForm.cs" startline="8" endline="62">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public PasteOptionsForm()
 		{
 			InitializeComponent();
 			
 			// Get defaults
 			options = General.Settings.PasteOptions.Copy();
 			pasteoptions.Setup(options);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualCamera.cs" startline="48" endline="64">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Destructor
 
 		// Constructor
 		public VisualCamera()
 		{
 			// Initialize
 			this.movemultiplier = new Vector3D(1.0f, 1.0f, 1.0f);
 			this.position = position;
 			this.anglexy = 0.0f;
 			this.anglez = Angle2D.PI;
 			this.sector = null;
 			
 			PositionAtThing();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="908" endline="919">
<![CDATA[
 		
 		internal void RecPrpVertex(Vertex v)
 		{
 			if(!ignorepropchanges && !isrecordingcommand && !object.ReferenceEquals(v, propsrecorded))
 			{
 				if(!BeginRecordData(StreamCodes.PrpVertex)) return;
 				ss.wInt(v.Index);
 				v.ReadWrite(ss);
 				EndRecordData();
 				propsrecorded = v;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="977" endline="988">
<![CDATA[
 
 		internal void RecPrpLinedef(Linedef l)
 		{
 			if(!ignorepropchanges && !isrecordingcommand && !object.ReferenceEquals(l, propsrecorded))
 			{
 				if(!BeginRecordData(StreamCodes.PrpLinedef)) return;
 				ss.wInt(l.Index);
 				l.ReadWrite(ss);
 				EndRecordData();
 				propsrecorded = l;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1142" endline="1153">
<![CDATA[
 
 		internal void RecPrpSidedef(Sidedef s)
 		{
 			if(!ignorepropchanges && !isrecordingcommand && !object.ReferenceEquals(s, propsrecorded))
 			{
 				if(!BeginRecordData(StreamCodes.PrpSidedef)) return;
 				ss.wInt(s.Index);
 				s.ReadWrite(ss);
 				EndRecordData();
 				propsrecorded = s;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1226" endline="1237">
<![CDATA[
 
 		internal void RecPrpSector(Sector s)
 		{
 			if(!ignorepropchanges && !isrecordingcommand && !object.ReferenceEquals(s, propsrecorded))
 			{
 				if(!BeginRecordData(StreamCodes.PrpSector)) return;
 				ss.wInt(s.Index);
 				s.ReadWrite(ss);
 				EndRecordData();
 				propsrecorded = s;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1286" endline="1297">
<![CDATA[
 
 		internal void RecPrpThing(Thing t)
 		{
 			if(!ignorepropchanges && !isrecordingcommand && !object.ReferenceEquals(t, propsrecorded))
 			{
 				if(!BeginRecordData(StreamCodes.PrpThing)) return;
 				ss.wInt(t.Index);
 				t.ReadWrite(ss);
 				EndRecordData();
 				propsrecorded = t;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\DecorateParser.cs" startline="69" endline="84">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		public DecorateParser()
 		{
 			// Syntax
 			whitespace = "\n \t\r";
 			specialtokens = "
 			
 			// Initialize
 			actors = new Dictionary<string, ActorStructure>();
 			archivedactors = new Dictionary<string, ActorStructure>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="60" endline="84">
<![CDATA[
 		private bool isreadonly = false;
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public string Filename { get { return filename; } }
 		public string Type { get { return type; } }
 		public Encoding Encoding { get { return ENCODING; } }
 		public bool IsReadOnly { get { return isreadonly; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		public List<Lump> Lumps { get { return lumps; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor to open or create a WAD file
 		public WAD(string pathfilename)
 		{
 			// Initialize
 			this.isreadonly = false;
 			this.Open(pathfilename);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="264" endline="292">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Lumps
 
 		// This creates a new lump in the WAD file
 		public Lump Insert(string name, int position, int datalength)
 		{
 			Lump lump;
 
 			// We will be adding a lump
 			numlumps++;
 			
 			// Extend the file
 			file.SetLength(file.Length + datalength + 16);
 			
 			// Create the lump
 			lump = new Lump(file, this, Lump.MakeFixedName(name, ENCODING), lumpsoffset, datalength);
 			lumps.Insert(position, lump);
 			
 			// Advance lumps table offset
 			lumpsoffset += datalength;
 
 			// Write the new headers
 			WriteHeaders();
 
 			// Return the new lump
 			return lump;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="226" endline="239">
<![CDATA[
 
 		// This sets new start vertex
 		public void SetStartVertex(Vertex v)
 		{
 			if(map == General.Map.Map)
 				General.Map.UndoRedo.RecRefLinedefStart(this);
 			
 			// Change start
 			if(startvertexlistitem != null) start.DetachLinedefP(startvertexlistitem);
 			startvertexlistitem = null;
 			start = v;
 			if(start != null) startvertexlistitem = start.AttachLinedefP(this);
 			this.updateneeded = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="240" endline="253">
<![CDATA[
 
 		// This sets new end vertex
 		public void SetEndVertex(Vertex v)
 		{
 			if(map == General.Map.Map)
 				General.Map.UndoRedo.RecRefLinedefEnd(this);
 
 			// Change end
 			if(endvertexlistitem != null) end.DetachLinedefP(endvertexlistitem);
 			endvertexlistitem = null;
 			end = v;
 			if(end != null) endvertexlistitem = end.AttachLinedefP(this);
 			this.updateneeded = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipVertex.cs" startline="125" endline="133">
<![CDATA[
 
 		// This adds to reflexes list
 		public void AddReflex(LinkedList<EarClipVertex> reflexes)
 		{
 			#if DEBUG
 			if(vertslink == null) throw new Exception();
 			#endif
 			if(reflexlink == null) reflexlink = reflexes.AddLast(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipVertex.cs" startline="141" endline="149">
<![CDATA[
 
 		// This adds to eartips list
 		internal void AddEarTip(LinkedList<EarClipVertex> eartips)
 		{
 			#if DEBUG
 			if(vertslink == null) throw new Exception();
 			#endif
 			if(eartiplink == null) eartiplink = eartips.AddLast(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="588" endline="602">
<![CDATA[
 
 		/// <summary>This creates a new sidedef and returns it.</summary>
 		public Sidedef CreateSidedef(int index, Linedef l, bool front, Sector s)
 		{
 			if(numsidedefs == int.MaxValue)
 			{
 				General.Interface.DisplayStatus(StatusType.Warning, "Failed to complete operation
 				return null;
 			}
 
 			// Make the sidedef
 			Sidedef sd = new Sidedef(this, index, l, front, s);
 			AddItem(sd, ref sidedefs, index, ref numsidedefs);
 			return sd;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="384" endline="396">
<![CDATA[
 		
 		// This rotates the thing
 		public void Rotate(float newangle)
 		{
 			BeforePropsChange();
 			
 			// Change angle
 			this.anglerad = newangle;
 			this.angledoom = Angle2D.RealToDoom(newangle);
 			
 			if(type != General.Map.Config.Start3DModeThingType)
 				General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="397" endline="409">
<![CDATA[
 		
 		// This rotates the thing
 		public void Rotate(int newangle)
 		{
 			BeforePropsChange();
 			
 			// Change angle
 			this.anglerad = Angle2D.DoomToReal(newangle);
 			this.angledoom = newangle;
 			
 			if(type != General.Map.Config.Start3DModeThingType)
 				General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1416" endline="1433">
<![CDATA[
 
 		// Things filter selected
 		private void thingfilters_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			// Only possible when a map is open
 			if((General.Map != null) && !updatingfilters)
 			{
 				updatingfilters = true;
 				
 				// Change filter
 				General.Map.ChangeThingFilter(thingfilters.SelectedItem as ThingsFilter);
 
 				updatingfilters = false;
 			}
 			
 			// Lose focus
 			if(!thingfilters.DroppedDown) LoseFocus(sender, e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3FileImage.cs" startline="46" endline="68">
<![CDATA[
 		internal PK3FileImage(PK3Reader datareader, string name, string filepathname, bool asflat)
 		{
 			// Initialize
 			this.datareader = datareader;
 			this.filepathname = filepathname;
 			SetName(name);
 
 			if(asflat)
 			{
 				probableformat = ImageDataFormat.DOOMFLAT;
 				this.scale.x = General.Map.Config.DefaultFlatScale;
 				this.scale.y = General.Map.Config.DefaultFlatScale;
 			}
 			else
 			{
 				probableformat = ImageDataFormat.DOOMPICTURE;
 				this.scale.x = General.Map.Config.DefaultTextureScale;
 				this.scale.y = General.Map.Config.DefaultTextureScale;
 			}
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="164" endline="180">
<![CDATA[
 		
 		// Serialize / deserialize (passive
 		internal void ReadWrite(IReadWriteStream s)
 		{
 			if(!s.IsWriting) BeforePropsChange();
 			
 			base.ReadWrite(s);
 
 			s.rwInt(ref offsetx);
 			s.rwInt(ref offsety);
 			s.rwString(ref texnamehigh);
 			s.rwString(ref texnamemid);
 			s.rwString(ref texnamelow);
 			s.rwLong(ref longtexnamehigh);
 			s.rwLong(ref longtexnamemid);
 			s.rwLong(ref longtexnamelow);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualSector.cs" startline="203" endline="211">
<![CDATA[
 
 		// This gets the geometry list for the specified sidedef
 		public List<VisualGeometry> GetSidedefGeometry(Sidedef sd)
 		{
 			if(sidedefgeometry.ContainsKey(sd))
 				return sidedefgeometry[sd];
 			else
 				return new List<VisualGeometry>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\DecorateParser.cs" startline="209" endline="224">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		/// <summary>
 		/// This returns a supported actor by name. Returns null when no supported actor with the specified name can be found. This operation is of O(1) complexity.
 		/// </summary>
 		public ActorStructure GetActorByName(string name)
 		{
 			name = name.ToLowerInvariant();
 			if(actors.ContainsKey(name))
 				return actors[name];
 			else
 				return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\DecorateParser.cs" startline="239" endline="249">
<![CDATA[
 
 		// This returns an actor by name
 		// Returns null when actor cannot be found
 		internal ActorStructure GetArchivedActorByName(string name)
 		{
 			name = name.ToLowerInvariant();
 			if(archivedactors.ContainsKey(name))
 				return archivedactors[name];
 			else
 				return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\ClippedStream.cs" startline="130" endline="145">
<![CDATA[
 
 		// This writes to the stream
 		public override void Write(byte[] buffer, int offset, int count)
 		{
 			// Check if this exceeds limits
 			if((this.position + count) > (this.length + 1))
 				throw new ArgumentException("Attempted to write outside the range of the stream.");
 
 			// Seek if needed
 			if(basestream.Position != (this.offset + this.position))
 				basestream.Seek(this.offset + this.position, SeekOrigin.Begin);
 
 			// Read from base stream
 			position += count;
 			basestream.Write(buffer, offset, count);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="508" endline="518">
<![CDATA[
 		
 		// This changes zoom
 		public void ScaleView(float scale)
 		{
 			// Change zoom scale
 			this.scale = scale;
 			UpdateTransformations();
 			
 			// Show zoom on main window
 			General.MainWindow.UpdateZoom(scale);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="138" endline="145">
<![CDATA[
 
 		// Mouse leaves
 		private void preview_MouseLeave(object sender, EventArgs e)
 		{
 			ispressed = false;
 			ismouseinside = false;
 			preview.BackColor = SystemColors.AppWorkspace;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="165" endline="175">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 		
 		// This refreshes the control
 		new public void Refresh()
 		{
 			ShowPreview(FindImage(name.Text));
 			base.Refresh();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\GridSetup.cs" startline="139" endline="155">
<![CDATA[
 
 		// Read settings from configuration
 		internal void ReadFromConfig(Configuration cfg, string path)
 		{
 			// Read settings
 			background = cfg.ReadSetting(path + ".background", "");
 			backsource = cfg.ReadSetting(path + ".backsource", 0);
 			backoffsetx = cfg.ReadSetting(path + ".backoffsetx", 0);
 			backoffsety = cfg.ReadSetting(path + ".backoffsety", 0);
 			backscalex = (float)cfg.ReadSetting(path + ".backscalex", 100) / 100.0f;
 			backscaley = (float)cfg.ReadSetting(path + ".backscaley", 100) / 100.0f;
 			gridsize = cfg.ReadSetting(path + ".gridsize", DEFAULT_GRID_SIZE);
 
 			// Setup
 			SetGridSize(gridsize);
 			LinkBackground();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\DefinedTextureSet.cs" startline="59" endline="65">
<![CDATA[
 		
 		// New texture set constructor
 		public DefinedTextureSet(string name)
 		{
 			this.name = name;
 			this.filters = new List<string>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DynamicBitmapImage.cs" startline="47" endline="55">
<![CDATA[
 		public DynamicBitmapImage(Bitmap img, string name) 
 		{
 			// Initialize
 			this.UseColorCorrection = false;
 			this.dynamictexture = true;
 
 			// This resource is volatile
 			General.Map.Graphics.RegisterResource(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\FileImage.cs" startline="45" endline="66">
<![CDATA[
 		public FileImage(string name, string filepathname, bool asflat)
 		{
 			// Initialize
 			this.filepathname = filepathname;
 			SetName(name);
 
 			if(asflat)
 			{
 				probableformat = ImageDataFormat.DOOMFLAT;
 				this.scale.x = General.Map.Config.DefaultFlatScale;
 				this.scale.y = General.Map.Config.DefaultFlatScale;
 			}
 			else
 			{
 				probableformat = ImageDataFormat.DOOMPICTURE;
 				this.scale.x = General.Map.Config.DefaultTextureScale;
 				this.scale.y = General.Map.Config.DefaultTextureScale;
 			}
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="258" endline="280">
<![CDATA[
 		
 		// This triangulates the sector geometry
 		internal void Triangulate()
 		{
 			if(updateneeded)
 			{
 				// Triangulate again?
 				if(triangulationneeded || (triangles == null))
 				{
 					// Triangulate sector
 					triangles = Triangulation.Create(this);
 					triangulationneeded = false;
 					updateneeded = true;
 					
 					// Make label positions
 					labels = Array.AsReadOnly<LabelPositionInfo>(Tools.FindLabelPositions(this).ToArray());
 					
 					// Number of vertices changed?
 					if(triangles.Vertices.Count != surfaceentries.totalvertices)
 						General.Map.CRenderer2D.Surfaces.FreeSurfaces(surfaceentries);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ResourceImage.cs" startline="48" endline="72">
<![CDATA[
 		public ResourceImage(string resourcename)
 		{
 			// Initialize
 			this.assembly = Assembly.GetCallingAssembly();
 			this.resourcename = resourcename;
 			this.AllowUnload = false;
 			SetName(resourcename);
 
 			// Temporarily load resource from memory
 			Stream bitmapdata = assembly.GetManifestResourceStream(resourcename);
 			Bitmap bmp = (Bitmap)Image.FromStream(bitmapdata);
 
 			// Get width and height from image
 			width = bmp.Size.Width;
 			height = bmp.Size.Height;
 			scale.x = 1.0f;
 			scale.y = 1.0f;
 			
 			// Done
 			bmp.Dispose();
 			bitmapdata.Dispose();
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="180" endline="202">
<![CDATA[
 
 		// Serialize / deserialize (passive
 		internal void ReadWrite(IReadWriteStream s)
 		{
 			if(!s.IsWriting)
 			{
 				BeforePropsChange();
 				updateneeded = true;
 			}
 			
 			base.ReadWrite(s);
 
 			s.rwInt(ref fixedindex);
 			s.rwInt(ref floorheight);
 			s.rwInt(ref ceilheight);
 			s.rwString(ref floortexname);
 			s.rwString(ref ceiltexname);
 			s.rwLong(ref longfloortexname);
 			s.rwLong(ref longceiltexname);
 			s.rwInt(ref effect);
 			s.rwInt(ref tag);
 			s.rwInt(ref brightness);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="121" endline="152">
<![CDATA[
 
 		// Disposer
 		public override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Already set isdisposed so that changes can be prohibited
 				isdisposed = true;
 
 				if(map == General.Map.Map)
 					General.Map.UndoRedo.RecRemSidedef(this);
 
 				// Remove from main list
 				map.RemoveSidedef(listindex);
 
 				// Detach from linedef
 				if(linedef != null) linedef.DetachSidedefP(this);
 				
 				// Detach from sector
 				SetSectorP(null);
 
 				// Clean up
 				sectorlistitem = null;
 				linedef = null;
 				map = null;
 				sector = null;
 
 				// Dispose base
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="129" endline="139">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(Vector3D p, Vector2D t)
 		{
 			this.x = p.x;
 			this.y = p.y;
 			this.z = p.z;
 			this.c = -1;
 			this.u = t.x;
 			this.v = t.y;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="293" endline="307">
<![CDATA[
 
 		// This removes a lump from the WAD file by index
 		public void RemoveAt(int index)
 		{
 			Lump l;
 			
 			// Remove from list
 			l = lumps[index];
 			lumps.RemoveAt(index);
 			l.Dispose();
 			numlumps--;
 			
 			// Write the new headers
 			WriteHeaders();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="55" endline="62">
<![CDATA[
 
 		// Constructor
 		public Vector3D(Vector2D v)
 		{
 			this.x = v.x;
 			this.y = v.y;
 			this.z = 0f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalParser.cs" startline="62" endline="95">
<![CDATA[
 		private int cpErrorResult = 0;
 		private string cpErrorDescription = "";
 		private int cpErrorLine = 0;
 		
 		// Configuration root
 		private UniversalCollection root = null;
 
 		// Settings
 		private bool strictchecking = true;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		// Properties
 		public int ErrorResult { get { return cpErrorResult; } }
 		public string ErrorDescription { get { return cpErrorDescription; } }
 		public int ErrorLine { get { return cpErrorLine; } }
 		public UniversalCollection Root { get { return root; } }
 		public bool StrictChecking { get { return strictchecking; } set { strictchecking = value; } }
 		
 		#endregion
 		
 		#region ================== Constructor / Destructor
 		
 		// Constructor
 		public UniversalParser()
 		{
 			// Standard new configuration
 			NewConfiguration();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="108" endline="134">
<![CDATA[
 
 		// Disposer
 		public override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Already set isdisposed so that changes can be prohibited
 				isdisposed = true;
 
 				if(map == General.Map.Map)
 					General.Map.UndoRedo.RecRemThing(this);
 
 				// Remove from main list
 				map.RemoveThing(listindex);
 
 				// Remove from sector
 				//if(sector != null) sector.DetachThing(sectorlistitem);
 				
 				// Clean up
 				map = null;
 				sector = null;
 
 				// Dispose base
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualThing.cs" startline="77" endline="140">
<![CDATA[
 		private bool isdisposed = false;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		internal VertexBuffer GeometryBuffer { get { return geobuffer; } }
 		internal bool NeedsUpdateGeo { get { return updategeo; } }
 		internal int Triangles { get { return triangles; } }
 		internal int RenderPassInt { get { return renderpass; } }
 		internal Matrix Orientation { get { return orientation; } }
 		internal Matrix Position { get { return position; } }
 		internal Matrix CageScales { get { return cagescales; } }
 		internal int CageColor { get { return cagecolor; } }
 
 		/// <summary>
 		/// Set to True to use billboarding for this thing. When using billboarding,
 		/// the geometry will be rotated on the XY plane to face the camera.
 		/// </summary>
 		public bool Billboard { get { return billboard; } set { billboard = value; } }
 
 		/// <summary>
 		/// Returns the Thing that this VisualThing is created for.
 		/// </summary>
 		public Thing Thing { get { return thing; } }
 
 		/// <summary>
 		/// Render pass in which this geometry must be rendered. Default is Solid.
 		/// </summary>
 		public RenderPass RenderPass { get { return (RenderPass)renderpass; } set { renderpass = (int)value; } }
 		
 		/// <summary>
 		/// Image to use as texture on the geometry.
 		/// </summary>
 		public ImageData Texture { get { return texture; } set { texture = value; } }
 
 		/// <summary>
 		/// Disposed or not?
 		/// </summary>
 		public bool IsDisposed { get { return isdisposed; } }
 
 		/// <summary>
 		/// Selected or not? This is only used by the core to determine what color to draw it with.
 		/// </summary>
 		public bool Selected { get { return selected; } set { selected = value; } }
 		
 		#endregion
 		
 		#region ================== Constructor / Destructor
 		
 		// Constructor
 		public VisualThing(Thing t)
 		{
 			// Initialize
 			this.thing = t;
 			this.renderpass = (int)RenderPass.Mask;
 			this.billboard = true;
 			this.orientation = Matrix.Identity;
 			this.position = Matrix.Identity;
 			this.cagescales = Matrix.Identity;
 			
 			// Register as resource
 			General.Map.Graphics.RegisterResource(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="112" endline="187">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public UndoSnapshot NextUndo
 		{
 			get
 			{
 				if(!isundosnapshot && (snapshot != null))
 					return snapshot;
 				else if(undos.Count > 0)
 					return undos[0];
 				else
 					return null;
 			}
 		}
 		
 		public UndoSnapshot NextRedo
 		{
 			get
 			{
 				if(isundosnapshot && (snapshot != null))
 					return snapshot;
 				else if(redos.Count > 0)
 					return redos[0];
 				else
 					return null;
 			}
 		}
 		
 		public bool IsDisposed { get { return isdisposed; } }
 		
 		/// <summary>
 		/// This can be used to ignore insignificant element property changes. Any property changes
 		/// that are made while this is set to True will not be undoable. Use with great care!
 		/// </summary>
 		public bool IgnorePropChanges { get { return ignorepropchanges; } set { ignorepropchanges = value; } }
 		
 		/// <summary>
 		/// After undo or redo, this returns if the geometry changed. This includes add/remove operations
 		/// on sectors, linedefs, sidedefs and vertices, references changes and property changes on vertices.
 		/// </summary>
 		public bool GeometryChanged { get { return geometrychanged; } }
 
 		/// <summary>
 		/// After undo or redo, this returns if things were added/removed. This does not include thing property changes.
 		/// </summary>
 		public bool PopulationChanged { get { return populationchanged; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal UndoManager()
 		{
 			// Initialize
 			ticketid = 1;
 			undos = new List<UndoSnapshot>(MAX_UNDO_LEVELS + 1);
 			redos = new List<UndoSnapshot>(MAX_UNDO_LEVELS + 1);
 			
 			// Bind any methods
 			General.Actions.BindMethods(this);
 
 			// Start background thread
 			backgroundthread = new Thread(new ThreadStart(BackgroundThread));
 			backgroundthread.Name = "Snapshot Compressor";
 			backgroundthread.Priority = ThreadPriority.Lowest;
 			backgroundthread.IsBackground = true;
 			backgroundthread.Start();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="279" endline="302">
<![CDATA[
 
 		// This allocates the arrays to a minimum size so that
 		// a lot of items can be created faster. This function will never
 		// allocate less than the current number of items.
 		public void SetCapacity(int nvertices, int nlinedefs, int nsidedefs, int nsectors, int nthings)
 		{
 			if(freezearrays == 0)
 				throw new Exception("You must call BeginAddRemove before setting the reserved capacity.");
 
 			if(numvertices < nvertices)
 				Array.Resize(ref vertices, nvertices);
 
 			if(numlinedefs < nlinedefs)
 				Array.Resize(ref linedefs, nlinedefs);
 
 			if(numsidedefs < nsidedefs)
 				Array.Resize(ref sidedefs, nsidedefs);
 
 			if(numsectors < nsectors)
 				Array.Resize(ref sectors, nsectors);
 
 			if(numthings < nthings)
 				Array.Resize(ref things, nthings);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapElement.cs" startline="73" endline="83">
<![CDATA[
 
 		// Disposer
 		public virtual void Dispose()
 		{
 			// Clean up
 			fields.Owner = null;
 			fields = null;
 			
 			// Done
 			isdisposed = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Lump.cs" startline="92" endline="106">
<![CDATA[
 
 		// Disposer
 		internal void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				stream.Dispose();
 				owner = null;
 
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="218" endline="226">
<![CDATA[
 
 		// This sets the value
 		public void SetValue(int value)
 		{
 			typehandler.SetValue(value);
 			combobox.SelectedItem = null;
 			combobox.Text = typehandler.GetStringValue();
 			combobox_Validating(this, new CancelEventArgs());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ButtonsNumericTextbox.cs" startline="101" endline="107">
<![CDATA[
 		
 		// Text in textbox changes
 		private void textbox_TextChanged(object sender, EventArgs e)
 		{
 			if(WhenTextChanged != null) WhenTextChanged(sender, e);
 			buttons.Enabled = !textbox.CheckIsRelative();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="146" endline="159">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Management
 		
 		// This sets the status of the texture usage in the map
 		internal void SetUsedInMap(bool used)
 		{
 			if(used != usedinmap)
 			{
 				usedinmap = used;
 				General.Map.Data.ProcessImage(this);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="543" endline="557">
<![CDATA[
 
 		/// <summary>This creates a new linedef and returns it.</summary>
 		public Linedef CreateLinedef(Vertex start, Vertex end)
 		{
 			if(numlinedefs == General.Map.FormatInterface.MaxLinedefs)
 			{
 				General.Interface.DisplayStatus(StatusType.Warning, "Failed to complete operation
 				return null;
 			}
 
 			// Make the linedef
 			Linedef l = new Linedef(this, numlinedefs, start, end);
 			AddItem(l, ref linedefs, numlinedefs, ref numlinedefs);
 			return l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptLumpDocumentTab.cs" startline="58" endline="94">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		public ScriptLumpDocumentTab(ScriptEditorPanel panel, string lumpname, ScriptConfiguration config) 
 		{
 			// Initialize
 			if(lumpname == MapManager.CONFIG_MAP_HEADER)
 			{
 				this.lumpname = MapManager.TEMP_MAP_HEADER;
 				this.ismapheader = true;
 			}
 			else
 			{
 				this.lumpname = lumpname;
 				this.ismapheader = false;
 			}
 			
 			this.config = config;
 			editor.SetupStyles(config);
 			
 			// Load the lump data
 			MemoryStream stream = General.Map.GetLumpData(this.lumpname);
 			if(stream != null)
 			{
 				editor.SetText(stream.ToArray());
 				editor.ClearUndoRedo();
 			}
 			
 			// Done
 			if(ismapheader)
 				SetTitle(General.Map.Options.CurrentName);
 			else
 				SetTitle(this.lumpname.ToUpper());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\ShaderManager.cs" startline="123" endline="138">
<![CDATA[
 
 		// Load resources
 		public void ReloadResource()
 		{
 			Capabilities caps;
 
 			// Check if we can use shaders
 			caps = General.Map.Graphics.Device.Capabilities;
 			useshaders = (caps.PixelShaderVersion.Major >= 2);
 			shadertechnique = "SM20";
 
 			// Initialize effects
 			display2dshader = new Display2DShader(this);
 			things2dshader = new Things2DShader(this);
 			world3dshader = new World3DShader(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ActorStructure.cs" startline="407" endline="419">
<![CDATA[
 		
 		/// <summary>
 		/// This returns a specific value of a specific property as a string. Returns an empty string when the propery does not have the specified value.
 		/// </summary>
 		public string GetPropertyValueString(string propname, int valueindex)
 		{
 			if(props.ContainsKey(propname) && (props[propname].Count > valueindex))
 				return props[propname][valueindex];
 			else if(!skipsuper && (baseclass != null))
 				return baseclass.GetPropertyValueString(propname, valueindex);
 			else
 				return "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\AngleForm.cs" startline="71" endline="80">
<![CDATA[
 
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			this.value = angle.Value;
 			
 			// Done
 			DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PasteOptionsForm.cs" startline="63" endline="74">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Events
 		
 		// Paste clicked
 		private void paste_Click(object sender, EventArgs e)
 		{
 			options = pasteoptions.GetOptions();
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="171" endline="192">
<![CDATA[
 		
 		// This expands the docker
 		public void Expand()
 		{
 			if(!iscollapsed) return;
 
 			controlledselection = true;
 			splitter.Enabled = true;
 			splitter.BackColor = Color.Transparent;
 			splitter.Width = (int)(4.0f * (this.CurrentAutoScaleDimensions.Width / this.AutoScaleDimensions.Width));
 			General.MainWindow.LockUpdate();
 			if(rightalign) this.Left = this.Right - expandedwidth;
 			this.Width = expandedwidth;
 			General.MainWindow.UnlockUpdate();
 			tabs.SelectedIndex = expandedtab;
 			tabs.Invalidate(true);
 			controlledselection = false;
 			
 			iscollapsed = false;
 			
 			if(Expanded != null) Expanded(this, EventArgs.Empty);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="147" endline="170">
<![CDATA[
 		
 		// This collapses the docker
 		public void Collapse()
 		{
 			if(iscollapsed) return;
 
 			controlledselection = true;
 			splitter.Enabled = false;
 			splitter.BackColor = SystemColors.Control;
 			splitter.Width = (int)(2.0f * (this.CurrentAutoScaleDimensions.Width / this.AutoScaleDimensions.Width));
 			expandedtab = tabs.SelectedIndex;
 			expandedwidth = this.Width;
 			tabs.SelectedIndex = -1;
 			General.MainWindow.LockUpdate();
 			if(rightalign) this.Left = this.Right - GetCollapsedWidth();
 			this.Width = GetCollapsedWidth();
 			General.MainWindow.UnlockUpdate();
 			this.Invalidate(true);
 			controlledselection = false;
 			
 			iscollapsed = true;
 			
 			if(Collapsed != null) Collapsed(this, EventArgs.Empty);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1338" endline="1348">
<![CDATA[
 		
 		// This fixes some odd input behaviour
 		private void display_PreviewKeyDown(object sender, PreviewKeyDownEventArgs e)
 		{
 			if((ActiveControl == null) || (ActiveControl == display))
 			{
 				LoseFocus(this, EventArgs.Empty);
 				KeyEventArgs ea = new KeyEventArgs(e.KeyData);
 				MainForm_KeyDown(sender, ea);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="119" endline="130">
<![CDATA[
 		
 		// Mouse pressed
 		private void preview_MouseDown(object sender, MouseEventArgs e)
 		{
 			button = e.Button;
 			if((button == MouseButtons.Left) || ((button == MouseButtons.Right) && allowclear))
 			{
 				ispressed = true;
 				preview.BackColor = AdjustedColor(SystemColors.Highlight, 0.2f);
 				ShowPreview(FindImage(name.Text));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\FlatQuad.cs" startline="44" endline="63">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructors
 
 		// Constructor
 		public FlatQuad(PrimitiveType type, float left, float top, float right, float bottom)
 		{
 			// Initialize
 			Initialize(type);
 			
 			// Set coordinates
 			if(type == PrimitiveType.TriangleList)
 				SetTriangleListCoordinates(left, top, right, bottom, 0f, 0f, 1f, 1f);
 			else if(type == PrimitiveType.TriangleStrip)
 				SetTriangleStripCoordinates(left, top, right, bottom, 0f, 0f, 1f, 1f);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\ClippedStream.cs" startline="103" endline="129">
<![CDATA[
 
 		// This reads from the stream
 		public override int Read(byte[] buffer, int offset, int count)
 		{
 			// Check if this exceeds limits
 			if((this.position + count) > (this.length + 1))
 			{
 				// Read only within limits
 				count = this.length - (int)this.position;
 			}
 
 			// Anything to read?
 			if(count > 0)
 			{
 				// Seek if needed
 				if(basestream.Position != (this.offset + this.position))
 					basestream.Seek(this.offset + this.position, SeekOrigin.Begin);
 
 				// Read from base stream
 				position += count;
 				return basestream.Read(buffer, offset, count);
 			}
 			else
 			{
 				return 0;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="73" endline="116">
<![CDATA[
 		private int mipmaplevels = 0;	// 0 = all mipmaps
 		protected bool dynamictexture;
 		private Texture texture;
 		
 		// Disposing
 		protected bool isdisposed = false;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		public string Name { get { return name; } }
 		public long LongName { get { return longname; } }
 		public bool UseColorCorrection { get { return usecolorcorrection; } set { usecolorcorrection = value; } }
 		public Texture Texture { get { lock(this) { return texture; } } }
 		public bool IsPreviewLoaded { get { return (previewstate == ImageLoadState.Ready); } }
 		public bool IsImageLoaded { get { return (imagestate == ImageLoadState.Ready); } }
 		public bool LoadFailed { get { return loadfailed; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		public bool AllowUnload { get { return allowunload; } set { allowunload = value; } }
 		public ImageLoadState ImageState { get { return imagestate; } internal set { imagestate = value; } }
 		public ImageLoadState PreviewState { get { return previewstate; } internal set { previewstate = value; } }
 		public bool IsReferenced { get { return (references > 0) || usedinmap; } }
 		public bool UsedInMap { get { return usedinmap; } }
 		public int MipMapLevels { get { return mipmaplevels; } set { mipmaplevels = value; } }
 		public int Width { get { return width; } }
 		public int Height { get { return height; } }
 		internal int PreviewIndex { get { return previewindex; } set { previewindex = value; } }
 		public float ScaledWidth { get { return width * scale.x; } }
 		public float ScaledHeight { get { return height * scale.y; } }
 		public Vector2D Scale { get { return scale; } }
 		public bool WorldPanning { get { return worldpanning; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public ImageData()
 		{
 			// Defaults
 			usecolorcorrection = true;
 			allowunload = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ProgramConfiguration.cs" startline="100" endline="181">
<![CDATA[
 		private int defaultbrightness = 192;
 		private int defaultfloorheight = 0;
 		private int defaultceilheight = 128;
 		private string defaultfloortexture;
 		private string defaultceiltexture;
 		private int defaultthingtype = 1;
 		private float defaultthingangle = 0.0f;
 		private List<string> defaultthingflags;
 		
 		#endregion
 
 		#region ================== Properties
 
 		internal Configuration Config { get { return cfg; } }
 		//public int UndoLevels { get { return undolevels; } internal set { undolevels = value; } }
 		public bool BlackBrowsers { get { return blackbrowsers; } internal set { blackbrowsers = value; } }
 		public int VisualFOV { get { return visualfov; } internal set { visualfov = value; } }
 		public int ImageBrightness { get { return imagebrightness; } internal set { imagebrightness = value; } }
 		public float DoubleSidedAlpha { get { return doublesidedalpha; } internal set { doublesidedalpha = value; doublesidedalphabyte = (byte)(doublesidedalpha * 255f); } }
 		public byte DoubleSidedAlphaByte { get { return doublesidedalphabyte; } }
 		public float BackgroundAlpha { get { return backgroundalpha; } internal set { backgroundalpha = value; } }
 		public float VisualMouseSensX { get { return visualmousesensx; } internal set { visualmousesensx = value; } }
 		public float VisualMouseSensY { get { return visualmousesensy; } internal set { visualmousesensy = value; } }
 		public bool QualityDisplay { get { return qualitydisplay; } internal set { qualitydisplay = value; } }
 		public bool SquareThings { get { return squarethings; } internal set { squarethings = value; } }
 		public bool TestMonsters { get { return testmonsters; } internal set { testmonsters = value; } }
 		public int DefaultViewMode { get { return defaultviewmode; } internal set { defaultviewmode = value; } }
 		public bool ClassicBilinear { get { return classicbilinear; } internal set { classicbilinear = value; } }
 		public bool VisualBilinear { get { return visualbilinear; } internal set { visualbilinear = value; } }
 		public int MouseSpeed { get { return mousespeed; } internal set { mousespeed = value; } }
 		public int MoveSpeed { get { return movespeed; } internal set { movespeed = value; } }
 		public float ViewDistance { get { return viewdistance; } internal set { viewdistance = value; } }
 		public bool InvertYAxis { get { return invertyaxis; } internal set { invertyaxis = value; } }
 		public string ScriptFontName { get { return scriptfontname; } internal set { scriptfontname = value; } }
 		public int ScriptFontSize { get { return scriptfontsize; } internal set { scriptfontsize = value; } }
 		public bool ScriptFontBold { get { return scriptfontbold; } internal set { scriptfontbold = value; } }
 		public bool ScriptOnTop { get { return scriptontop; } internal set { scriptontop = value; } }
 		public int PreviewImageSize { get { return previewimagesize; } internal set { previewimagesize = value; } }
 		public int AutoScrollSpeed { get { return autoscrollspeed; } internal set { autoscrollspeed = value; } }
 		public int ZoomFactor { get { return zoomfactor; } internal set { zoomfactor = value; } }
 		public bool ShowErrorsWindow { get { return showerrorswindow; } internal set { showerrorswindow = value; } }
 		public bool AnimateVisualSelection { get { return animatevisualselection; } internal set { animatevisualselection = value; } }
 		public int ScriptTabWidth { get { return scripttabwidth; } internal set { scripttabwidth = value; } }
 		public bool ScriptAutoIndent { get { return scriptautoindent; } internal set { scriptautoindent = value; } }
 		internal int PreviousVersion { get { return previousversion; } }
 		internal PasteOptions PasteOptions { get { return pasteoptions; } set { pasteoptions = value; } }
 		public int DockersPosition { get { return dockersposition; } internal set { dockersposition = value; } }
 		public bool CollapseDockers { get { return collapsedockers; } internal set { collapsedockers = value; } }
 		public int DockersWidth { get { return dockerswidth; } internal set { dockerswidth = value; } }
 		public bool ToolbarScript { get { return toolbarscript; } internal set { toolbarscript = value; } }
 		public bool ToolbarUndo { get { return toolbarundo; } internal set { toolbarundo = value; } }
 		public bool ToolbarCopy { get { return toolbarcopy; } internal set { toolbarcopy = value; } }
 		public bool ToolbarPrefabs { get { return toolbarprefabs; } internal set { toolbarprefabs = value; } }
 		public bool ToolbarFilter { get { return toolbarfilter; } internal set { toolbarfilter = value; } }
 		public bool ToolbarViewModes { get { return toolbarviewmodes; } internal set { toolbarviewmodes = value; } }
 		public bool ToolbarGeometry { get { return toolbargeometry; } internal set { toolbargeometry = value; } }
 		public bool ToolbarTesting { get { return toolbartesting; } internal set { toolbartesting = value; } }
 		public bool ToolbarFile { get { return toolbarfile; } internal set { toolbarfile = value; } }
 		public float FilterAnisotropy { get { return filteranisotropy; } internal set { filteranisotropy = value; } }
 		public bool ShowTextureSizes { get { return showtexturesizes; } internal set { showtexturesizes = value; } }
 		
 		public string DefaultTexture { get { return defaulttexture; } set { defaulttexture = value; } }
 		public string DefaultFloorTexture { get { return defaultfloortexture; } set { defaultfloortexture = value; } }
 		public string DefaultCeilingTexture { get { return defaultceiltexture; } set { defaultceiltexture = value; } }
 		public int DefaultBrightness { get { return defaultbrightness; } set { defaultbrightness = value; } }
 		public int DefaultFloorHeight { get { return defaultfloorheight; } set { defaultfloorheight = value; } }
 		public int DefaultCeilingHeight { get { return defaultceilheight; } set { defaultceilheight = value; } }
 		public int DefaultThingType { get { return defaultthingtype; } set { defaultthingtype = value; } }
 		public float DefaultThingAngle { get { return defaultthingangle; } set { defaultthingangle = value; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal ProgramConfiguration()
 		{
 			// We have no destructor
 			GC.SuppressFinalize(this);
 			defaultthingflags = new List<string>();
 			pasteoptions = new PasteOptions();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="479" endline="501">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Background Loading
 		
 		// This starts background loading
 		private void StartBackgroundLoader()
 		{
 			// Timing
 			loadstarttime = General.Clock.GetCurrentTime();
 			loadfinishtime = 0;
 			
 			// If a loader is already running, stop it first
 			if(backgroundloader != null) StopBackgroundLoader();
 
 			// Start a low priority thread to load images in background
 			General.WriteLogLine("Starting background resource loading...");
 			backgroundloader = new Thread(new ThreadStart(BackgroundLoad));
 			backgroundloader.Name = "Background Loader";
 			backgroundloader.Priority = ThreadPriority.Lowest;
 			backgroundloader.IsBackground = true;
 			backgroundloader.Start();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\BinaryHeap.cs" startline="122" endline="164">
<![CDATA[
 		
 		// This removes an item from the list
 		// This is an O(log n) operation, where n is Count
 		public virtual void RemoveAt(int index)
 		{
 			int newindex = index;
 			
 			// Replace with last item
 			heap[index] = heap[heap.Count - 1];
 			heap.RemoveAt(heap.Count - 1);
 			
 			// Continue while item has at least a left child
 			while(LeftOf(index) < heap.Count)
 			{
 				// Right childs also available?
 				if(RightOf(index) < heap.Count)
 				{
 					// Compare with both childs
 					// NOTE
 					if(heap[index].CompareTo(heap[LeftOf(index)]) < 0) newindex = LeftOf(index);
 					if(heap[newindex].CompareTo(heap[RightOf(index)]) < 0) newindex = RightOf(index);
 				}
 				// Only left child available
 				else
 				{
 					// Compare with left child
 					if(heap[index].CompareTo(heap[LeftOf(index)]) < 0) newindex = LeftOf(index);
 				}
 
 				// Item should move down?
 				if(newindex != index)
 				{
 					// Swap the items
 					SwapItems(index, newindex);
 					index = newindex;
 				}
 				else
 				{
 					// Item is fine where it is, we're done
 					break;
 				}
 			}
 			while(LeftOf(index) < heap.Count)
 			{
 				// Right childs also available?
 				if(RightOf(index) < heap.Count)
 				{
 					// Compare with both childs
 					// NOTE
 					if(heap[index].CompareTo(heap[LeftOf(index)]) < 0) newindex = LeftOf(index);
 					if(heap[newindex].CompareTo(heap[RightOf(index)]) < 0) newindex = RightOf(index);
 				}
 				// Only left child available
 				else
 				{
 					// Compare with left child
 					if(heap[index].CompareTo(heap[LeftOf(index)]) < 0) newindex = LeftOf(index);
 				}
 
 				// Item should move down?
 				if(newindex != index)
 				{
 					// Swap the items
 					SwapItems(index, newindex);
 					index = newindex;
 				}
 				else
 				{
 					// Item is fine where it is, we're done
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ResourceOptionsForm.cs" startline="8" endline="80">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ResourceOptionsForm(DataLocation settings, string caption)
 		{
 			// Initialize
 			InitializeComponent();
 
 			// Set caption
 			this.Text = caption;
 			
 			// Apply settings from ResourceLocation
 			this.res = settings;
 			switch(res.type)
 			{
 				// Setup for WAD File
 				case DataLocation.RESOURCE_WAD
 					wadlocation.Text = res.location;
 					strictpatches.Checked = res.option1;
 					break;
 
 				// Setup for Directory
 				case DataLocation.RESOURCE_DIRECTORY
 					dirlocation.Text = res.location;
 					dir_textures.Checked = res.option1;
 					dir_flats.Checked = res.option2;
 					break;
 					
 				// Setup for PK3 File
 				case DataLocation.RESOURCE_PK3
 					pk3location.Text = res.location;
 					break;
 			}
 			
 			// Select appropriate tab
 			tabs.SelectedIndex = res.type;
 			
 			// Checkbox
 			notfortesting.Checked = res.notfortesting;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ConfigurationInfo.cs" startline="237" endline="259">
<![CDATA[
 		
 		// This applies settings from an object
 		internal void Apply(ConfigurationInfo ci)
 		{
 			this.name = ci.name;
 			this.filename = ci.filename;
 			this.settingskey = ci.settingskey;
 			this.nodebuildersave = ci.nodebuildersave;
 			this.nodebuildertest = ci.nodebuildertest;
 			this.resources = new DataLocationList();
 			this.resources.AddRange(ci.resources);
 			this.testprogram = ci.testprogram;
 			this.testparameters = ci.testparameters;
 			this.testshortpaths = ci.testshortpaths;
 			this.customparameters = ci.customparameters;
 			this.testskill = ci.testskill;
 			this.startmode = ci.startmode;
 			this.texturesets = new List<DefinedTextureSet>();
 			foreach(DefinedTextureSet s in ci.texturesets) this.texturesets.Add(s.Copy());
 			this.thingsfilters = new List<ThingsFilter>();
 			foreach(ThingsFilter f in ci.thingsfilters) this.thingsfilters.Add(new ThingsFilter(f));
 			this.editmodes = new Dictionary<string, bool>(ci.editmodes);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\ClippedStream.cs" startline="146" endline="183">
<![CDATA[
 		
 		// Seek within clipped buffer
 		public override long Seek(long offset, SeekOrigin origin)
 		{
 			// Seeking from beginning
 			if(origin == SeekOrigin.Begin)
 			{
 				// Check if this exceeds limits
 				if((offset > this.length) || (offset < 0))
 					throw new ArgumentException("Attempted to seek outside the range of the stream.");
 				
 				// Seek
 				position = basestream.Seek(this.offset + offset, SeekOrigin.Begin) - this.offset;
 			}
 			// Seeking from current position
 			else if(origin == SeekOrigin.Current)
 			{
 				// Check if this exceeds limits
 				if((this.position + offset > this.length) || (this.position + offset < 0))
 					throw new ArgumentException("Attempted to seek outside the range of the stream.");
 
 				// Seek
 				position = basestream.Seek(this.offset + this.position + offset, SeekOrigin.Begin) - this.offset;
 			}
 			// Seeking from end
 			else
 			{
 				// Check if this exceeds limits
 				if((offset > 0) || (this.length + offset < 0))
 					throw new ArgumentException("Attempted to seek outside the range of the stream.");
 
 				// Seek
 				position = basestream.Seek(this.offset + this.length + offset, SeekOrigin.Begin) - this.offset;
 			}
 
 			// Return new position
 			return position;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="169" endline="196">
<![CDATA[
 		
 		// Disposer
 		internal void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				Unload();
 				missingtexture3d.Dispose();
 				missingtexture3d = null;
 				unknowntexture3d.Dispose();
 				unknowntexture3d = null;
 				hourglass3d.Dispose();
 				hourglass3d = null;
 				crosshair.Dispose();
 				crosshair = null;
 				crosshairbusy.Dispose();
 				crosshairbusy = null;
 				thingbox.Dispose();
 				thingbox = null;
 				whitetexture.Dispose();
 				whitetexture = null;
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ResourceOptionsForm.cs" startline="81" endline="163">
<![CDATA[
 		
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Apply settings to ResourceLocation
 			switch(tabs.SelectedIndex)
 			{
 				// Setup WAD File
 				case DataLocation.RESOURCE_WAD
 
 					// Check if file is specified
 					if((wadlocation.Text.Length == 0) ||
 					   (!File.Exists(wadlocation.Text)))
 					{
 						// No valid wad file specified
 						MessageBox.Show(this, "Please select a valid WAD File resource.", Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Warning);
 					}
 					else
 					{
 						// Apply settings
 						res.type = DataLocation.RESOURCE_WAD;
 						res.location = wadlocation.Text;
 						res.option1 = strictpatches.Checked;
 						res.option2 = false;
 						res.notfortesting = notfortesting.Checked;
 
 						// Done
 						this.DialogResult = DialogResult.OK;
 						this.Close();
 					}
 					break;
 
 				// Setup Directory
 				case DataLocation.RESOURCE_DIRECTORY
 
 					// Check if directory is specified
 					if((dirlocation.Text.Length == 0) ||
 					   (!Directory.Exists(dirlocation.Text)))
 					{
 						// No valid directory specified
 						MessageBox.Show(this, "Please select a valid directory resource.", Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Warning);
 					}
 					else
 					{
 						// Apply settings
 						res.type = DataLocation.RESOURCE_DIRECTORY;
 						res.location = dirlocation.Text;
 						res.option1 = dir_textures.Checked;
 						res.option2 = dir_flats.Checked;
 						res.notfortesting = notfortesting.Checked;
 
 						// Done
 						this.DialogResult = DialogResult.OK;
 						this.Close();
 					}
 					break;
 					
 				// Setup PK3 File
 				case DataLocation.RESOURCE_PK3
 
 					// Check if file is specified
 					if((pk3location.Text.Length == 0) ||
 					   (!File.Exists(pk3location.Text)))
 					{
 						// No valid pk3 file specified
 						MessageBox.Show(this, "Please select a valid PK3 File resource.", Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Warning);
 					}
 					else
 					{
 						// Apply settings
 						res.type = DataLocation.RESOURCE_PK3;
 						res.location = pk3location.Text;
 						res.option1 = false;
 						res.option2 = false;
 						res.notfortesting = notfortesting.Checked;
 
 						// Done
 						this.DialogResult = DialogResult.OK;
 						this.Close();
 					}
 					break;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="43" endline="60">
<![CDATA[
 		private bool ignorebuttonchange = false;
 		private System.ComponentModel.IContainer components = null;
 		public ArgumentBox()
 		{
 			// Initialize
 			InitializeComponent();
 			scrollbuttons.Value = 0;
 			combobox.MouseWheel += combobox_MouseWheel;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="513" endline="527">
<![CDATA[
 		
 		/// <summary>This creates a new vertex and returns it.</summary>
 		public Vertex CreateVertex(Vector2D pos)
 		{
 			if(numvertices == General.Map.FormatInterface.MaxVertices)
 			{
 				General.Interface.DisplayStatus(StatusType.Warning, "Failed to complete operation
 				return null;
 			}
 			
 			// Make the vertex
 			Vertex v = new Vertex(this, numvertices, pos);
 			AddItem(v, ref vertices, numvertices, ref numvertices);
 			return v;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\ClippedStream.cs" startline="247" endline="262">
<![CDATA[
 
 		// This writes a single byte to the stream
 		public override void WriteByte(byte value)
 		{
 			// Check if this exceeds limits
 			if((this.position + 1) > (this.length + 1))
 				throw new ArgumentException("Attempted to write outside the range of the stream.");
 
 			// Seek if needed
 			if(basestream.Position != (this.offset + this.position))
 				basestream.Seek(this.offset + this.position, SeekOrigin.Begin);
 
 			// Read from base stream
 			position++;
 			basestream.WriteByte(value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="136" endline="174">
<![CDATA[
 		
 		// Disposer
 		public override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Already set isdisposed so that changes can be prohibited
 				isdisposed = true;
 
 				// Dispose sidedefs
 				if((front != null) && map.AutoRemove) front.Dispose(); else AttachFrontP(null);
 				if((back != null) && map.AutoRemove) back.Dispose(); else AttachBackP(null);
 				
 				if(map == General.Map.Map)
 					General.Map.UndoRedo.RecRemLinedef(this);
 
 				// Remove from main list
 				map.RemoveLinedef(listindex);
 				
 				// Detach from vertices
 				if(startvertexlistitem != null) start.DetachLinedefP(startvertexlistitem);
 				startvertexlistitem = null;
 				start = null;
 				if(endvertexlistitem != null) end.DetachLinedefP(endvertexlistitem);
 				endvertexlistitem = null;
 				end = null;
 				
 				// Clean up
 				start = null;
 				end = null;
 				front = null;
 				back = null;
 				map = null;
 
 				// Clean up base
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\FlatQuad.cs" startline="130" endline="153">
<![CDATA[
 
 		// This sets the color on all vertices
 		public void SetColors(int clt, int crt, int clb, int crb)
 		{
 			// Determine polygon type
 			if(type == PrimitiveType.TriangleList)
 			{
 				// Go for all vertices to set the color
 				vertices[0].c = clt;
 				vertices[1].c = crt;
 				vertices[2].c = clb;
 				vertices[3].c = clb;
 				vertices[4].c = crt;
 				vertices[5].c = crb;
 			}
 			else if(type == PrimitiveType.TriangleStrip)
 			{
 				// Go for all vertices to set the color
 				vertices[0].c = clt;
 				vertices[1].c = crt;
 				vertices[2].c = clb;
 				vertices[3].c = crb;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="610" endline="649">
<![CDATA[
 
 		#endregion
 
 		#region ================== Start / Finish
 
 		// This begins a drawing session
 		public unsafe bool StartPlotter(bool clear)
 		{
 			if(renderlayer != RenderLayers.None) throw new InvalidOperationException("Renderer starting called before finished previous layer. Call Finish() first!");
 			renderlayer = RenderLayers.Plotter;
 			try { graphics.Device.SetRenderState(RenderState.FogEnable, false); } catch(Exception) { }
 			
 			// Rendertargets available?
 			if(plottertex != null)
 			{
 				// Lock structures rendertarget memory
 				plotlocked = plottertex.LockRectangle(0, LockFlags.NoSystemLock);
 
 				// Create structures plotter
 				plotter = new Plotter((PixelColor*)plotlocked.Data.DataPointer.ToPointer(), plotlocked.Pitch / sizeof(PixelColor), structsize.Height, structsize.Width, structsize.Height);
 				if(clear) plotter.Clear();
 
 				// Redraw grid when structures image was cleared
 				if(clear)
 				{
 					RenderBackgroundGrid();
 					SetupBackground();
 				}
 				
 				// Ready for rendering
 				UpdateTransformations();
 				return true;
 			}
 			else
 			{
 				// Can't render!
 				Finish();
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\WorldVertex.cs" startline="173" endline="183">
<![CDATA[
 
 		// Constructor
 		public WorldVertex(Vector3D p)
 		{
 			this.x = p.x;
 			this.y = p.y;
 			this.z = p.z;
 			this.c = -1;
 			this.u = 0.0f;
 			this.v = 0.0f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualGeometry.cs" startline="77" endline="134">
<![CDATA[
 		private int renderpass = (int)RenderPass.Solid;
 		
 		// Sector buffer info
 		private int vertexoffset;
 		
 		#endregion
 
 		#region ================== Properties
 		
 		// Internal properties
 		internal WorldVertex[] Vertices { get { return vertices; } }
 		internal int VertexOffset { get { return vertexoffset; } set { vertexoffset = value; } }
 		internal int Triangles { get { return triangles; } }
 		internal int RenderPassInt { get { return renderpass; } }
 		internal Color4 ModColor4 { get { return modcolor4; } }
 
 		/// <summary>
 		/// Render pass in which this geometry must be rendered. Default is Solid.
 		/// </summary>
 		public RenderPass RenderPass { get { return (RenderPass)renderpass; } set { renderpass = (int)value; } }
 
 		/// <summary>
 		/// Image to use as texture on this geometry.
 		/// </summary>
 		public ImageData Texture { get { return texture; } set { texture = value; } }
 
 		/// <summary>
 		/// Color to modulate the texture pixels with.
 		/// </summary>
 		public PixelColor ModulateColor { get { return modulatecolor; } set { modcolor4 = value.ToColorValue(); modulatecolor = value; } }
 
 		/// <summary>
 		/// Returns the VisualSector this geometry has been added to.
 		/// </summary>
 		public VisualSector Sector { get { return sector; } internal set { sector = value; } }
 		
 		/// <summary>
 		/// Returns the Sidedef that this geometry is created for. Null for geometry that is sector-wide.
 		/// </summary>
 		public Sidedef Sidedef { get { return sidedef; } }
 
 		/// <summary>
 		/// Selected or not? This is only used by the core to determine what color to draw it with.
 		/// </summary>
 		public bool Selected { get { return selected; } set { selected = value; } }
 
 		#endregion
 
 		#region ================== Constructor / Destructor
 		
 		/// <summary>
 		/// This creates sector-global visual geometry. This geometry is always visible when any of the sector is visible.
 		/// </summary>
 		public VisualGeometry(VisualSector vs)
 		{
 			this.sector = vs;
 			this.ModulateColor = new PixelColor(255, 255, 255, 255);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="349" endline="358">
<![CDATA[
 
 		private void TextureBrowserForm_Shown(object sender, EventArgs e)
 		{
 			// Select texture
 			if(!string.IsNullOrEmpty(selecttextureonfill))
 			{
 				browser.SelectItem(selecttextureonfill, usedgroup);
 				selecttextureonfill = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="348" endline="357">
<![CDATA[
 
 		private void FlatBrowserForm_Shown(object sender, EventArgs e)
 		{
 			// Select texture
 			if(!string.IsNullOrEmpty(selecttextureonfill))
 			{
 				browser.SelectItem(selecttextureonfill, usedgroup);
 				selecttextureonfill = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\MouseInput.cs" startline="82" endline="101">
<![CDATA[
 
 		// Disposer
 		public void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Dispose
 				mouse.Unacquire();
 				mouse.Dispose();
 				dinput.Dispose();
 				
 				// Clean up
 				mouse = null;
 				dinput = null;
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomPictureReader.cs" startline="48" endline="55">
<![CDATA[
 		public DoomPictureReader(Playpal palette)
 		{
 			// Initialize
 			this.palette = palette;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomColormapReader.cs" startline="48" endline="55">
<![CDATA[
 		public DoomColormapReader(Playpal palette)
 		{
 			// Initialize
 			this.palette = palette;
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomFlatReader.cs" startline="48" endline="55">
<![CDATA[
 		public DoomFlatReader(Playpal palette)
 		{
 			// Initialize
 			this.palette = palette;
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\Clock.cs" startline="44" endline="64">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		// Settings
 		public double CurrentTime { get { return currenttime; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public Clock()
 		{
 			GetCurrentTime();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="542" endline="550">
<![CDATA[
 		
 		// This clears all flags
 		public void ClearFlags()
 		{
 			BeforePropsChange();
 			flags.Clear();
 			blocksoundflag = false;
 			impassableflag = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="494" endline="504">
<![CDATA[
 
 		// Window receives focus
 		private void MainForm_Activated(object sender, EventArgs e)
 		{
 			windowactive = true;
 
 			UpdateInterface();
 			ResumeExclusiveMouseInput();
 			ReleaseAllKeys();
 			FocusDisplay();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\ClippedStream.cs" startline="75" endline="91">
<![CDATA[
 
 		// Disposer
 		public new void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Already set isdisposed to prevent recursion
 				isdisposed = true;
 				
 				// Clean up
 				basestream = null;
 				
 				// Dispose base
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\PasteOptions.cs" startline="93" endline="100">
<![CDATA[
 		
 		// This writes to configuration
 		internal void WriteConfiguration(Configuration cfg, string path)
 		{
 			cfg.WriteSetting(path + ".changetags", changetags);
 			cfg.WriteSetting(path + ".removeactions", removeactions);
 			cfg.WriteSetting(path + ".adjustheights", adjustheights);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="505" endline="513">
<![CDATA[
 		
 		// Window loses focus
 		private void MainForm_Deactivate(object sender, EventArgs e)
 		{
 			windowactive = false;
 			
 			BreakExclusiveMouseInput();
 			ReleaseAllKeys();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataReader.cs" startline="64" endline="75">
<![CDATA[
 
 		// Disposer
 		public virtual void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Done
 				textureset = null;
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ThingCategory.cs" startline="171" endline="184">
<![CDATA[
 
 		// Disposer
 		internal void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				things = null;
 
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualBlockMap.cs" startline="75" endline="88">
<![CDATA[
 		
 		// Disposer
 		internal void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				blockmap = null;
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\LinedefActionCategory.cs" startline="77" endline="90">
<![CDATA[
 
 		// Disposer
 		internal void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				actions = null;
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GeneralizedCategory.cs" startline="72" endline="85">
<![CDATA[
 
 		// Disposer
 		internal void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				options = null;
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\Plug.cs" startline="85" endline="100">
<![CDATA[
 
 		/// <summary>
 		/// This is called by the Doom Builder core when the plugin is being disposed.
 		/// </summary>
 		public virtual void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				plugin = null;
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\Plugin.cs" startline="119" endline="132">
<![CDATA[
 
 		// Disposer
 		public void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				asm = null;
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\BlockMap.cs" startline="100" endline="113">
<![CDATA[
 		
 		// Disposer
 		public void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				blockmap = null;
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="350" endline="356">
<![CDATA[
 
 		// This finds a lump by name, returns -1 when not found
 		public int FindLumpIndex(string name)
 		{
 			// Do search
 			return FindLumpIndex(name, 0, lumps.Count - 1);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\TextureSet.cs" startline="49" endline="58">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor / Destructor
 		
 		public TextureSet()
 		{
 			this.name = "Unnamed Set";
 			this.filters = new List<string>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1362" endline="1375">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Marking
 
 		/// <summary>This clears all marks on all elements.</summary>
 		public void ClearAllMarks(bool mark)
 		{
 			ClearMarkedVertices(mark);
 			ClearMarkedThings(mark);
 			ClearMarkedLinedefs(mark);
 			ClearMarkedSectors(mark);
 			ClearMarkedSidedefs(mark);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="173" endline="181">
<![CDATA[
 		
 		// This is called resets when the device is reset
 		// (when resized or display adapter was changed)
 		public override void ReloadResource()
 		{
 			CreateMatrices2D();
 			SetupThingCage();
 			SetupTextures();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\SidedefsTracePath.cs" startline="55" endline="61">
<![CDATA[
 
 		// Constructor
 		public SidedefsTracePath(SidedefsTracePath p, Sidedef add) 
 		{
 			// Initialize
 			base.Add(add);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\LinedefsTracePath.cs" startline="68" endline="74">
<![CDATA[
 
 		// Constructor
 		public LinedefTracePath(LinedefTracePath p, Linedef add) 
 		{
 			// Initialize
 			base.Add(add);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\FlatImage.cs" startline="38" endline="45">
<![CDATA[
 		public FlatImage(string name)
 		{
 			// Initialize
 			SetName(name);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\SpriteImage.cs" startline="47" endline="60">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal SpriteImage(string name)
 		{
 			// Initialize
 			SetName(name);
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ColormapImage.cs" startline="38" endline="45">
<![CDATA[
 		public ColormapImage(string name)
 		{
 			// Initialize
 			SetName(name);
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\MatchingTextureSet.cs" startline="53" endline="65">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Constructor / Destructor
 		
 		// New texture set for quick matching
 		public MatchingTextureSet(ICollection<string> filters)
 		{
 			this.filters = new List<string>(filters);
 			
 			// Setup
 			Setup();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1167" endline="1175">
<![CDATA[
 
 		/// <summary>This clears all selected items</summary>
 		public void ClearAllSelected()
 		{
 			ClearSelectedVertices();
 			ClearSelectedThings();
 			ClearSelectedLinedefs();
 			ClearSelectedSectors();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\PluginManager.cs" startline="52" endline="73">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 		
 		internal List<Plugin> Plugins { get { return plugins; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public PluginManager()
 		{
 			// Make lists
 			this.plugins = new List<Plugin>();
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1406" endline="1415">
<![CDATA[
 
 		/// <summary>This inverts all marks on all elements.</summary>
 		public void InvertAllMarks()
 		{
 			InvertMarkedVertices();
 			InvertMarkedThings();
 			InvertMarkedLinedefs();
 			InvertMarkedSectors();
 			InvertMarkedSidedefs();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditModeInfo.cs" startline="114" endline="127">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 		
 		// This binds the action to switch to this editing mode
 		public void BindSwitchAction()
 		{
 			if((switchactiondel == null) && (switchactionattr != null))
 			{
 				switchactiondel = new ActionDelegate(UserSwitchToMode);
 				General.Actions.BindBeginDelegate(plugin.Assembly, switchactiondel, switchactionattr);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="160" endline="169">
<![CDATA[
 
 		// This adds a normal item
 		public void AddResourceLocation(DataLocation rl)
 		{
 			// Add it
 			AddItem(rl);
 
 			// Raise content changed event
 			if(OnContentChanged != null) OnContentChanged();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditModeInfo.cs" startline="128" endline="137">
<![CDATA[
 		
 		// This unbind the switch action
 		public void UnbindSwitchAction()
 		{
 			if(switchactiondel != null)
 			{
 				General.Actions.UnbindBeginDelegate(plugin.Assembly, switchactiondel, switchactionattr);
 				switchactiondel = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\GridSetup.cs" startline="61" endline="102">
<![CDATA[
 		private string background = "";
 		private int backsource;
 		private ImageData backimage = new UnknownImage(null);
 		private int backoffsetx, backoffsety;
 		private float backscalex, backscaley;
 
 		// Disposing
 		private bool isdisposed;
 		
 		#endregion
 
 		#region ================== Properties
 
 		public int GridSize { get { return gridsize; } }
 		public float GridSizeF { get { return gridsizef; } }
 		internal string BackgroundName { get { return background; } }
 		internal int BackgroundSource { get { return backsource; } }
 		internal ImageData Background { get { return backimage; } }
 		internal int BackgroundX { get { return backoffsetx; } }
 		internal int BackgroundY { get { return backoffsety; } }
 		internal float BackgroundScaleX { get { return backscalex; } }
 		internal float BackgroundScaleY { get { return backscaley; } }
 		internal bool Disposed { get { return isdisposed; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal GridSetup()
 		{
 			// Initialize
 			SetGridSize(DEFAULT_GRID_SIZE);
 			backscalex = 1.0f;
 			backscaley = 1.0f;
 			
 			// Register actions
 			General.Actions.BindMethods(this);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="113" endline="136">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal Renderer3D(D3DDevice graphics) 
 		{
 			// Initialize
 			CreateProjection();
 			CreateMatrices2D();
 			SetupThingCage();
 			SetupTextures();
 			renderthingcages = true;
 			showselection = true;
 			showhighlight = true;
 			
 			// Dummy frustum
 			frustum = new ProjectedFrustum2D(new Vector2D(), 0.0f, 0.0f, PROJ_NEAR_PLANE,
 				General.Settings.ViewDistance, Angle2D.DegToRad((float)General.Settings.VisualFOV));
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PreviewManager.cs" startline="50" endline="97">
<![CDATA[
 		private int maxpreviewwidth = 64;
 		private int maxpreviewheight = 64;
 		
 		// Images
 		private List<Bitmap> images;
 		
 		// Processing
 		private Queue<ImageData> imageque;
 		
 		// Disposing
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		// Constants
 		public int MaxImageWidth { get { return maxpreviewwidth; } }
 		public int MaxImageHeight { get { return maxpreviewheight; } }
 		
 		// Disposing
 		internal bool IsDisposed { get { return isdisposed; } }
 		
 		// Loading
 		internal bool IsLoading
 		{
 			get
 			{
 				return (imageque.Count > 0);
 			}
 		}
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal PreviewManager()
 		{
 			// Initialize
 			images = new List<Bitmap>();
 			imageque = new Queue<ImageData>();
 			maxpreviewwidth = PREVIEW_SIZES[General.Settings.PreviewImageSize];
 			maxpreviewheight = PREVIEW_SIZES[General.Settings.PreviewImageSize];
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ThingCategory.cs" startline="185" endline="194">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 
 		// This sorts the category, if preferred
 		internal void SortIfNeeded()
 		{
 			if(sorted) things.Sort();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="342" endline="354">
<![CDATA[
 
 		// This finishes recording
 		private void FinishRecording()
 		{
 			// End current recording
 			if((stream != null) && (ss != null))
 			{
 				propsrecorded = null;
 				ss.wInt(commandswritten);
 				ss.End();
 				ss = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="8" endline="92">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ImageBrowserControl()
 		{
 			// Initialize
 			InitializeComponent();
 			items = new List<ImageBrowserItem>();
 			
 			// Move textbox with label
 			objectname.Left = label.Right + label.Margin.Right + objectname.Margin.Left;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.Designer.cs" startline="15" endline="22">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				controller = null;
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\ClippedStream.cs" startline="223" endline="230">
<![CDATA[
 
 		// This closes the stream
 		public override void Close()
 		{
 			basestream = null;
 			base.Close();
 			this.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1587" endline="1593">
<![CDATA[
 
 		// This hides redundant seperators and shows single seperators
 		internal void UpdateSeparators()
 		{
 			UpdateToolStripSeparators(toolbar.Items, false);
 			UpdateToolStripSeparators(menumode.DropDownItems, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1109" endline="1128">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Input
 		
 		// This is a tool to lock the mouse in exclusive mode
 		private void StartMouseExclusive()
 		{
 			// Not already locked?
 			if(mouseinput == null)
 			{
 				// Start special input device
 				mouseinput = new MouseInput(this);
 
 				// Lock and hide the mouse in window
 				originalclip = Cursor.Clip;
 				Cursor.Clip = display.RectangleToScreen(display.ClientRectangle);
 				Cursor.Hide();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ActionSelectorControl.cs" startline="8" endline="55">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		private bool controlpressed = false;
 		
 		// Constants
 		private const string NUMBER_SEPERATOR = "\t";
 		
 		// Properties
 		public bool Empty { get { return (number.Text.Length == 0); } set { if(value) number.Text = ""; } }
 		public int Value { get { return GetValue(); } set { number.Text = value.ToString(); } }
 		public List<GeneralizedCategory> GeneralizedCategories { get { return generalizedcategories; } set { generalizedcategories = value; } }
 		
 		// Constructor
 		public ActionSelectorControl()
 		{
 			// Initialize
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="324" endline="332">
<![CDATA[
 		
 		// Resized
 		private void FieldsEditorControl_Resize(object sender, EventArgs e)
 		{
 			// Rearrange controls
 			fieldslist.Size = this.ClientSize;
 			UpdateValueColumn();
 			UpdateBrowseButton();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\CheckboxArrayControl.cs" startline="8" endline="53">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public CheckboxArrayControl()
 		{
 			// Initialize
 			InitializeComponent();
 
 			// Setup
 			checkboxes = new List<CheckBox>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="8" endline="94">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public FieldsEditorControl()
 		{
 			InitializeComponent();
 			autoinsertuserprefix = true;
 			enumscombo.Location = new Point(-1000, 1);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CopyPasteManager.cs" startline="52" endline="78">
<![CDATA[
 		private bool isdisposed = false;
 		
 		// Last inserted prefab
 		private string lastprefabfile;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		public bool IsDisposed { get { return isdisposed; } }
 		public bool IsPreviousPrefabAvailable { get { return (lastprefabfile != null); } }
 
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		internal CopyPasteManager()
 		{
 			// Initialize
 			
 			// Bind any methods
 			General.Actions.BindMethods(this);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1146" endline="1160">
<![CDATA[
 		
 		// This requests exclusive mouse input
 		public void StartExclusiveMouseInput()
 		{
 			// Only when not already in exclusive mode
 			if(!mouseexclusive)
 			{
 				General.WriteLogLine("Starting exclusive mouse input mode...");
 				
 				// Start special input device
 				StartMouseExclusive();
 				mouseexclusive = true;
 				mouseexclusivebreaklevel = 0;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="8" endline="66">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		private Point dialogoffset = new Point(40, 20);
 
 		#endregion
 
 		#region ================== Properties
 
 		public Point DialogOffset { get { return dialogoffset; } set { dialogoffset = value; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public ResourceListEditor()
 		{
 			// Initialize
 			InitializeComponent();
 			ResizeColumnHeader();
 
 			// Start with a clear list
 			resourceitems.Items.Clear();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="280" endline="294">
<![CDATA[
 
 		// This zooms to a specific level
 		public void SetZoom(float newscale)
 		{
 			// Zoom now
 			renderer2d.ScaleView(newscale);
 			this.OnViewChanged();
 
 			// Redraw
 			//General.Map.Map.Update();
 			General.MainWindow.RedrawDisplay();
 
 			// Give a new mousemove event to update coordinates
 			if(mouseinside) OnMouseMove(new MouseEventArgs(mousebuttons, 0, (int)mousepos.x, (int)mousepos.y, 0));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipVertex.cs" startline="114" endline="124">
<![CDATA[
 		
 		// This removes the item from all lists
 		internal void Remove()
 		{
 			vertslink.List.Remove(vertslink);
 			if(reflexlink != null) reflexlink.List.Remove(reflexlink);
 			if(eartiplink != null) eartiplink.List.Remove(eartiplink);
 			reflexlink = null;
 			eartiplink = null;
 			vertslink = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DShader.cs" startline="79" endline="94">
<![CDATA[
 
 		// Disposer
 		public virtual void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				manager = null;
 				if(effect != null) effect.Dispose();
 				vertexdecl.Dispose();
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="885" endline="896">
<![CDATA[
 
 		internal void RecRemVertex(Vertex v)
 		{
 			if(!BeginRecordData(StreamCodes.RemVertex)) return;
 			ss.wInt(v.Index);
 			ss.wVector2D(v.Position);
 			v.ReadWrite(ss);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="156" endline="172">
<![CDATA[
 
 		#endregion
 
 		#region ================== Management
 
 		// This is called before a device is reset
 		// (when resized or display adapter was changed)
 		public override void UnloadResource()
 		{
 			crosshairverts = null;
 			if(thingcage != null) thingcage.Dispose();
 			if(selectionimage != null) selectionimage.Dispose();
 			if(highlightimage != null) highlightimage.Dispose();
 			thingcage = null;
 			selectionimage = null;
 			highlightimage = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ButtonsNumericTextbox.cs" startline="165" endline="172">
<![CDATA[
 
 		// Key pressed in textbox
 		private void textbox_KeyDown(object sender, KeyEventArgs e)
 		{
 			// Enter key?
 			if((e.KeyData == Keys.Enter) && (WhenEnterPressed != null))
 				WhenEnterPressed(this, EventArgs.Empty);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="382" endline="393">
<![CDATA[
 		
 		// Use short paths changed
 		private void shortpaths_CheckedChanged(object sender, EventArgs e)
 		{
 			// Leave when no configuration selected
 			if(configinfo == null) return;
 			
 			// Apply to selected configuration
 			configinfo.TestShortPaths = shortpaths.Checked;
 			
 			CreateParametersExample();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="394" endline="405">
<![CDATA[
 		
 		// Skill changes
 		private void skill_ValueChanges(object sender, EventArgs e)
 		{
 			// Leave when no configuration selected
 			if(configinfo == null) return;
 			
 			// Apply to selected configuration
 			configinfo.TestSkill = skill.Value;
 			
 			CreateParametersExample();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="220" endline="234">
<![CDATA[
 
         // This sets the view to be centered at x,y
         private void ScrollTo(float x, float y)
         {
             // Scroll now
             renderer2d.PositionView(x, y);
             this.OnViewChanged();
 
             // Redraw
             General.MainWindow.RedrawDisplay();
 
             // Determine new unprojected mouse coordinates
             mousemappos = renderer2d.DisplayToMap(mousepos);
             General.MainWindow.UpdateCoordinates(mousemappos);
         }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ActionBrowserForm.cs" startline="263" endline="272">
<![CDATA[
 		
 		// Double clicking on item
 		private void actions_DoubleClick(object sender, EventArgs e)
 		{
 			// Action node selected?
 			if((actions.SelectedNode != null) && (actions.SelectedNode.Tag is LinedefActionInfo))
 			{
 				if(apply.Enabled) apply_Click(this, EventArgs.Empty);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="232" endline="243">
<![CDATA[
 		
 		// Resource locations changed
 		private void resourcelocations_OnContentChanged()
 		{
 			// Leave when no configuration selected
 			if(configinfo == null) return;
 			
 			// Apply to selected configuration
 			configinfo.Resources.Clear();
 			configinfo.Resources.AddRange(configdata.GetResources());
 			if(!preventchanges) reloadresources = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="238" endline="257">
<![CDATA[
 
 		// This detaches a sidedef
 		internal void DetachSidedefP(LinkedListNode<Sidedef> l)
 		{
 			// Not disposing?
 			if(!isdisposed)
 			{
 				// Remove sidedef
 				updateneeded = true;
 				triangulationneeded = true;
 				sidedefs.Remove(l);
 
 				// No more sidedefs left?
 				if((sidedefs.Count == 0) && map.AutoRemove)
 				{
 					// This sector is now useless, dispose it
 					this.Dispose();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipVertex.cs" startline="134" endline="140">
<![CDATA[
 
 		// This removes from reflexes list
 		internal void RemoveReflex()
 		{
 			if(reflexlink != null) reflexlink.List.Remove(reflexlink);
 			reflexlink = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipVertex.cs" startline="150" endline="156">
<![CDATA[
 
 		// This removes from eartips list
 		internal void RemoveEarTip()
 		{
 			if(eartiplink != null) eartiplink.List.Remove(eartiplink);
 			eartiplink = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ScriptConfiguration.cs" startline="237" endline="247">
<![CDATA[
 		
 		// This returns the function definition for a keyword
 		// Returns null when no function definition exists
 		// NOTE
 		public string GetFunctionDefinition(string keyword)
 		{
 			if(keywords.ContainsKey(keyword))
 				return keywords[keyword];
 			else
 				return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypesManager.cs" startline="184" endline="191">
<![CDATA[
 
 		// This returns the attribute with the give type
 		public TypeHandlerAttribute GetAttribute(int type)
 		{
 			// Do we have a handler type for this?
 			if(handlertypes.ContainsKey(type)) return handlertypes[type];
 				else return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptFindReplaceForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\GridSetupForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\AngleForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\VertexInfoPanel.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\EffectBrowserForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\CheckboxArrayControl.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\SectorEditForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\OpenMapOptionsForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\CustomFieldsForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\AboutForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PasteOptionsForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingInfoPanel.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ResourceOptionsForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\LinedefEditForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ButtonsNumericTextbox.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ActionSelectorControl.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\PasteOptionsControl.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\SectorInfoPanel.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptEditorForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\BitFlagsForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ColorControl.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\VertexEditForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlagsForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if (disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingBrowserForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingEditForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\LinedefInfoPanel.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingBrowserControl.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MapOptionsForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ErrorsForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\AngleControl.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ActionBrowserForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextEditForm.Designer.cs" startline="18" endline="24">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.Designer.cs" startline="15" endline="21">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.Designer.cs" startline="15" endline="22">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				if(bmp != null) bmp.Dispose();
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\World3DShader.cs" startline="153" endline="161">
<![CDATA[
 
 		// This sets the modulation color
 		public void SetModulateColor(int modcolor)
 		{
 			if(manager.Enabled)
 			{
 				effect.SetValue(modulatecolor, new Color4(modcolor));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\World3DShader.cs" startline="162" endline="170">
<![CDATA[
 
 		// This sets the highlight color
 		public void SetHighlightColor(int hicolor)
 		{
 			if(manager.Enabled)
 			{
 				effect.SetValue(highlightcolor, new Color4(hicolor));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Vertex.cs" startline="184" endline="191">
<![CDATA[
 
 		// Deselect
 		protected override void DoUnselect()
 		{
 			base.DoUnselect();
 			if(selecteditem.List != null) selecteditem.List.Remove(selecteditem);
 			selecteditem = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="333" endline="340">
<![CDATA[
 
 		// Deselect
 		protected override void DoUnselect()
 		{
 			base.DoUnselect();
 			if(selecteditem.List != null) selecteditem.List.Remove(selecteditem);
 			selecteditem = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="500" endline="507">
<![CDATA[
 
 		// Deselect
 		protected override void DoUnselect()
 		{
 			base.DoUnselect();
 			if(selecteditem.List != null) selecteditem.List.Remove(selecteditem);
 			selecteditem = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="374" endline="381">
<![CDATA[
 
 		// Deselect
 		protected override void DoUnselect()
 		{
 			base.DoUnselect();
 			if(selecteditem.List != null) selecteditem.List.Remove(selecteditem);
 			selecteditem = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ResourceOptionsForm.cs" startline="172" endline="182">
<![CDATA[
 
 		// Browse WAD File clicked
 		private void browsewad_Click(object sender, EventArgs e)
 		{
 			// Browse for WAD File
 			if(wadfiledialog.ShowDialog(this) == DialogResult.OK)
 			{
 				// Use this file
 				wadlocation.Text = wadfiledialog.FileName;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ResourceOptionsForm.cs" startline="183" endline="193">
<![CDATA[
 
 		// Browse Directory clicked
 		private void browsedir_Click(object sender, EventArgs e)
 		{
 			// Browse for Directory
 			if(dirdialog.ShowDialog(this) == DialogResult.OK)
 			{
 				// Use this directory
 				dirlocation.Text = dirdialog.SelectedPath;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ResourceOptionsForm.cs" startline="194" endline="204">
<![CDATA[
 
 		// Browse PK3 File clicked
 		private void browsepk3_Click(object sender, EventArgs e)
 		{
 			// Browse for PK3 File
 			if(pk3filedialog.ShowDialog(this) == DialogResult.OK)
 			{
 				// Use this file
 				pk3location.Text = pk3filedialog.FileName;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2671" endline="2683">
<![CDATA[
 
 		public void EnableProcessing()
 		{
 			// Increase count
 			processingcount++;
 
 			// If not already enabled, enable processing now
 			if(!processor.Enabled)
 			{
 				processor.Enabled = true;
 				lastupdatetime = General.Clock.GetCurrentTime();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.Designer.cs" startline="15" endline="22">
<![CDATA[
 		{
 			if(disposing && (components != null))
 			{
 				CleanUp();
 				components.Dispose();
 			}
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="266" endline="275">
<![CDATA[
 		
 		// Test application changed
 		private void testapplication_TextChanged(object sender, EventArgs e)
 		{
 			// Leave when no configuration selected
 			if(configinfo == null) return;
 
 			// Apply to selected configuration
 			configinfo.TestProgram = testapplication.Text;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="599" endline="609">
<![CDATA[
 		
 		// Open script clicked
 		private void buttonopen_Click(object sender, EventArgs e)
 		{
 			// Show open file dialog
 			if(openfile.ShowDialog(this.ParentForm) == DialogResult.OK)
 			{
 				// TODO
 				OpenFile(openfile.FileName);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="154" endline="164">
<![CDATA[
 
 		// Mouse moves
 		private void preview_MouseMove(object sender, MouseEventArgs e)
 		{
 			if(!ismouseinside)
 			{
 				ismouseinside = true;
 				preview.BackColor = SystemColors.Highlight;
 				ShowPreview(FindImage(name.Text));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="276" endline="289">
<![CDATA[
 
 		// Test parameters changed
 		private void testparameters_TextChanged(object sender, EventArgs e)
 		{
 			// Leave when no configuration selected
 			if(configinfo == null) return;
 
 			// Apply to selected configuration
 			configinfo = listconfigs.SelectedItems[0].Tag as ConfigurationInfo;
 			configinfo.TestParameters = testparameters.Text;
 
 			// Show example result
 			CreateParametersExample();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="205" endline="219">
<![CDATA[
 
 		// This scrolls anywhere
 		private void ScrollBy(float deltax, float deltay)
 		{
 			// Scroll now
 			renderer2d.PositionView(renderer2d.OffsetX + deltax, renderer2d.OffsetY + deltay);
 			this.OnViewChanged();
 			
 			// Redraw
 			General.MainWindow.RedrawDisplay();
 
 			// Determine new unprojected mouse coordinates
 			mousemappos = renderer2d.DisplayToMap(mousepos);
 			General.MainWindow.UpdateCoordinates(mousemappos);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\PasteOptionsControl.cs" startline="51" endline="65">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		// This sets the options from the given PasteOptions
 		public void Setup(PasteOptions options)
 		{
 			// Setup controls
 			keeptags.Checked = (options.ChangeTags == 0);
 			renumbertags.Checked = (options.ChangeTags == 1);
 			removetags.Checked = (options.ChangeTags == 2);
 			removeactions.Checked = options.RemoveActions;
 			adjustheights.Checked = options.AdjustHeights;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="950" endline="962">
<![CDATA[
 
 		internal void RecRemLinedef(Linedef l)
 		{
 			if(!BeginRecordData(StreamCodes.RemLinedef)) return;
 			ss.wInt(l.Index);
 			ss.wInt(l.Start.Index);
 			ss.wInt(l.End.Index);
 			l.ReadWrite(ss);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptDocumentTab.cs" startline="296" endline="309">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Events
 		
 		// Mouse released
 		protected override void OnMouseUp(MouseEventArgs e)
 		{
 			base.OnMouseUp(e);
 
 			// Focus to the editor!
 			editor.Focus();
 			editor.GrabFocus();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptDocumentTab.cs" startline="310" endline="319">
<![CDATA[
 		
 		// Receiving focus?
 		protected override void OnGotFocus(EventArgs e)
 		{
 			base.OnGotFocus(e);
 			
 			// Focus to the editor!
 			editor.Focus();
 			editor.GrabFocus();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="146" endline="153">
<![CDATA[
 		
 		// Mouse enters
 		private void preview_MouseEnter(object sender, EventArgs e)
 		{
 			ismouseinside = true;
 			preview.BackColor = SystemColors.Highlight;
 			ShowPreview(FindImage(name.Text));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingBrowserForm.cs" startline="8" endline="56">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ThingBrowserForm(int type)
 		{
 			InitializeComponent();
 
 			// Setup list
 			thingslist.Setup();
 
 			// Select given type
 			thingslist.SelectType(type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1113" endline="1126">
<![CDATA[
 
 		internal void RecRemSidedef(Sidedef s)
 		{
 			if(!BeginRecordData(StreamCodes.RemSidedef)) return;
 			ss.wInt(s.Index);
 			ss.wInt(s.Line.Index);
 			ss.wBool(s.IsFront);
 			ss.wInt(s.Sector.Index);
 			s.ReadWrite(ss);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="349" endline="355">
<![CDATA[
 
 		// Item dragged
 		private void resourceitems_DragOver(object sender, DragEventArgs e)
 		{
 			// Raise content changed event
 			if(OnContentChanged != null) OnContentChanged();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="356" endline="362">
<![CDATA[
 
 		// Item dropped
 		private void resourceitems_DragDrop(object sender, DragEventArgs e)
 		{
 			// Raise content changed event
 			if(OnContentChanged != null) OnContentChanged();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\UniFields.cs" startline="62" endline="68">
<![CDATA[
 		
 		/// <summary>Call this before making changes to the fields, or they may not be updated correctly with undo/redo!</summary>
 		public void BeforeFieldsChange()
 		{
 			if(owner != null)
 				owner.BeforeFieldsChange();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="551" endline="561">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Events
 
 		// Called when the window that contains this panel closes
 		public void OnClose()
 		{
 			// Close the sub windows now
 			if(findreplaceform != null) findreplaceform.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualSector.cs" startline="192" endline="202">
<![CDATA[
 
 		/// <summary>
 		/// This removes all geometry.
 		/// </summary>
 		public void ClearGeometry()
 		{
 			allgeometry.Clear();
 			fixedgeometry.Clear();
 			sidedefgeometry.Clear();
 			updategeo = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="969" endline="979">
<![CDATA[
 
 		// Display size changes
 		private void display_Resize(object sender, EventArgs e)
 		{
 			// Resizing
 			//if(!displayresized) General.LockWindowUpdate(display.Handle);
 			displayresized = true;
 			
 			// Request redraw
 			if(!redrawtimer.Enabled) redrawtimer.Enabled = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="118" endline="128">
<![CDATA[
 
 		// When browse button is clicked
 		private void button_Click(object sender, EventArgs e)
 		{
 			// Browse for a value
 			typehandler.Browse(this);
 			combobox.SelectedItem = null;
 			combobox.Text = typehandler.GetStringValue();
 			combobox.Focus();
 			combobox.SelectAll();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="303" endline="313">
<![CDATA[
 		
 		// Texture set selected
 		private void texturesets_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			// Anything slected?
 			if(texturesets.SelectedItems.Count > 0)
 			{
 				selectedset = texturesets.SelectedItems[0];
 				FillImagesList(null);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="380" endline="390">
<![CDATA[
 
 		// This flags the line needs an update because it moved
 		public void NeedUpdate()
 		{
 			// Update this line
 			updateneeded = true;
 
 			// Update sectors as well
 			if(front != null) front.Sector.UpdateNeeded = true;
 			if(back != null) back.Sector.UpdateNeeded = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\SerializerStream.cs" startline="96" endline="105">
<![CDATA[
 
 		public void rwString(ref string v)
 		{
 			ushort index;
 			if(stringstable.ContainsKey(v))
 				index = stringstable[v];
 			else
 				index = stringstable[v] = (ushort)stringstable.Count;
 			writer.Write(index);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\GridSetupForm.cs" startline="127" endline="142">
<![CDATA[
 
 		// Browse file
 		private void selectfile_Click(object sender, EventArgs e)
 		{
 			// Browse for file
 			if(browsefile.ShowDialog(this) == DialogResult.OK)
 			{
 				// Set this file as background
 				backgroundname = browsefile.FileName;
 				backgroundsource = GridSetup.SOURCE_FILE;
 				ImageData img = new FileImage(backgroundname, backgroundname, false, 1.0f, 1.0f);
 				img.LoadImage();
 				General.DisplayZoomedImage(backgroundimage, new Bitmap(img.GetBitmap()));
 				img.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="713" endline="731">
<![CDATA[
 		
 		private void RemoveItem<T>(ref T[] array, int index, ref int counter) where T
 		{
 			if(index == (counter - 1))
 			{
 				array[index] = null;
 			}
 			else
 			{
 				array[index] = array[counter - 1];
 				array[index].Index = index;
 				array[counter - 1] = null;
 			}
 			
 			counter--;
 
 			if(freezearrays == 0)
 				Array.Resize(ref array, counter);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorRow.cs" startline="214" endline="228">
<![CDATA[
 		
 		// This undefines the field
 		// ONLY VALID FOR FIXED FIELDS
 		// You should just delete non-fixed fields
 		public void Undefine()
 		{
 			// Must be fixed!
 			if(!isfixed) throw new InvalidOperationException();
 			
 			// Now undefined
 			fieldtype.SetValue(fieldinfo.Default);
 			this.Cells[2].Value = fieldtype.GetStringValue();
 			this.DefaultCellStyle.ForeColor = SystemColors.GrayText;
 			isdefined = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="304" endline="314">
<![CDATA[
 		
 		// Texture set selected
 		private void texturesets_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			// Anything slected?
 			if(texturesets.SelectedItems.Count > 0)
 			{
 				selectedset = texturesets.SelectedItems[0];
 				FillImagesList();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="147" endline="165">
<![CDATA[
 		
 		// Scroll buttons clicked
 		private void scrollbuttons_ValueChanged(object sender, EventArgs e)
 		{
 			if(!ignorebuttonchange)
 			{
 				ignorebuttonchange = true;
 				if(!CheckIsRelative())
 				{
 					typehandler.SetValue(combobox.Text);
 					int newvalue = GetResult(0) - scrollbuttons.Value;
 					if(newvalue < 0) newvalue = 0;
 					combobox.Text = newvalue.ToString();
 					combobox_Validating(sender, new CancelEventArgs());
 				}
 				scrollbuttons.Value = 0;
 				ignorebuttonchange = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="328" endline="349">
<![CDATA[
 
 		// This detaches a sidedef from the front
 		internal void DetachSidedefP(Sidedef s)
 		{
 			// Sidedef is on the front?
 			if(front == s)
 			{
 				// Remove sidedef reference
 				if(front != null) front.SetLinedefP(null);
 				front = null;
 				updateneeded = true;
 			}
 			// Sidedef is on the back?
 			else if(back == s)
 			{
 				// Remove sidedef reference
 				if(back != null) back.SetLinedefP(null);
 				back = null;
 				updateneeded = true;
 			}
 			//else throw new Exception("Specified Sidedef is not attached to this Linedef.");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\AngleControl.cs" startline="8" endline="89">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public AngleControl()
 		{
 			// Initialize
 			InitializeComponent();
 
 			// Make array from buttons
 			buttons = new RadioButton[8];
 			buttons[0] = button0;
 			buttons[1] = button1;
 			buttons[2] = button2;
 			buttons[3] = button3;
 			buttons[4] = button4;
 			buttons[5] = button5;
 			buttons[6] = button6;
 			buttons[7] = button7;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="254" endline="272">
<![CDATA[
 
 		// This detaches a vertex
 		internal void DetachVertexP(Vertex v)
 		{
 			if(v == start)
 			{
 				if(startvertexlistitem != null) start.DetachLinedefP(startvertexlistitem);
 				startvertexlistitem = null;
 				start = null;
 			}
 			else if(v == end)
 			{
 				if(endvertexlistitem != null) end.DetachLinedefP(endvertexlistitem);
 				endvertexlistitem = null;
 				end = null;
 			}
 			else 
 				throw new Exception("Specified Vertex is not attached to this Linedef.");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ButtonsNumericTextbox.cs" startline="92" endline="100">
<![CDATA[
 
 		// Control resizes
 		private void ClickableNumericTextbox_Resize(object sender, EventArgs e)
 		{
 			buttons.Height = textbox.Height + 4;
 			textbox.Width = ClientRectangle.Width - buttons.Width - 2;
 			buttons.Left = textbox.Width + 2;
 			this.Height = buttons.Height;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="137" endline="155">
<![CDATA[
 
 		// Disposer
 		internal override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				if(thingcage != null) thingcage.Dispose();
 				if(selectionimage != null) selectionimage.Dispose();
 				if(highlightimage != null) highlightimage.Dispose();
 				thingcage = null;
 				selectionimage = null;
 				highlightimage = null;
 				
 				// Done
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\GridSetup.cs" startline="190" endline="216">
<![CDATA[
 		
 		// This finds and links the background image
 		internal void LinkBackground()
 		{
 			// Dispose image if needed
 			if(backimage is FileImage) (backimage as FileImage).Dispose();
 			
 			// Where to load background from?
 			switch(backsource)
 			{
 				case SOURCE_TEXTURES
 					backimage = General.Map.Data.GetTextureImage(background);
 					break;
 
 				case SOURCE_FLATS
 					backimage = General.Map.Data.GetFlatImage(background);
 					break;
 
 				case SOURCE_FILE
 					backimage = new FileImage(background, background, false, 1.0f, 1.0f);
 					break;
 			}
 
 			// Make sure it is loaded
 			backimage.LoadImage();
 			backimage.CreateTexture();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Display2DShader.cs" startline="87" endline="103">
<![CDATA[
 
 		// Disposer
 		public override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				if(texture1 != null) texture1.Dispose();
 				if(rendersettings != null) rendersettings.Dispose();
 				if(transformsettings != null) transformsettings.Dispose();
 				if(filtersettings != null) filtersettings.Dispose();
 				
 				// Done
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptFileDocumentTab.cs" startline="211" endline="225">
<![CDATA[
 
 		// This changes the script configurations
 		public override void ChangeScriptConfig(ScriptConfiguration newconfig)
 		{
 			string ext = "";
 
 			this.config = newconfig;
 			editor.SetupStyles(config);
 
 			if(filepathname.Length == 0)
 			{
 				if(config.Extensions.Length > 0) ext = "." + config.Extensions[0];
 				SetTitle("Untitled" + ext);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="278" endline="299">
<![CDATA[
 
 		// This opens the Find & Replace subwindow
 		public void OpenFindAndReplace()
 		{
 			if(findreplaceform == null)
 				findreplaceform = new ScriptFindReplaceForm();
 
 			try
 			{
 				if(findreplaceform.Visible)
 					findreplaceform.Focus();
 				else
 					findreplaceform.Show(this.ParentForm);
 
 				if(ActiveTab.SelectionEnd != ActiveTab.SelectionStart)
 					findreplaceform.SetFindText(ActiveTab.GetSelectedText());
 			}
 			catch(Exception)
 			{
 				// If we can't pop up the find/replace form right now, thats just too bad.
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="96" endline="111">
<![CDATA[
 		
 		// Image clicked
 		private void preview_Click(object sender, EventArgs e)
 		{
 			ispressed = false;
 			preview.BackColor = SystemColors.Highlight;
 			ShowPreview(FindImage(name.Text));
 			if(button == MouseButtons.Right)
 			{
 				if(allowclear) name.Text = "-";
 			}
 			else if(button == MouseButtons.Left)
 			{
 				name.Text = BrowseImage(name.Text);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2480" endline="2501">
<![CDATA[
 
 		// Show thing info
 		public void ShowThingInfo(Thing t)
 		{
 			if(t.IsDisposed)
 			{
 				HideInfo();
 				return;
 			}
 
 			lastinfoobject = t;
 			modename.Visible = false;
 			if(linedefinfo.Visible) linedefinfo.Hide();
 			if(vertexinfo.Visible) vertexinfo.Hide();
 			if(sectorinfo.Visible) sectorinfo.Hide();
 			if(IsInfoPanelExpanded) thinginfo.ShowInfo(t);
 
 			// Show info on collapsed label
 			ThingTypeInfo ti = General.Map.Data.GetThingInfo(t.Type);
 			labelcollapsedinfo.Text = t.Type + " - " + ti.Title;
 			labelcollapsedinfo.Refresh();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ActorStructure.cs" startline="394" endline="406">
<![CDATA[
 		
 		/// <summary>
 		/// This returns values of a specific property as a complete string. Returns an empty string when the propery has no values.
 		/// </summary>
 		public string GetPropertyAllValues(string propname)
 		{
 			if(props.ContainsKey(propname) && (props[propname].Count > 0))
 				return string.Join(" ", props[propname].ToArray());
 			else if(!skipsuper && (baseclass != null))
 				return baseclass.GetPropertyAllValues(propname);
 			else
 				return "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorRow.cs" startline="229" endline="238">
<![CDATA[
 
 		// This defines the field
 		public void Define(object value)
 		{
 			// Now defined
 			fieldtype.SetValue(value);
 			this.Cells[2].Value = fieldtype.GetStringValue();
 			this.DefaultCellStyle.ForeColor = SystemColors.WindowText;
 			isdefined = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptFileDocumentTab.cs" startline="169" endline="186">
<![CDATA[
 		
 		// This saves the document to a new file
 		// Return true when successfully saved
 		public override bool SaveAs(string filename)
 		{
 			string oldfilename = filepathname;
 			filepathname = filename;
 			if(this.Save())
 			{
 				SetTitle(Path.GetFileName(filepathname));
 				return true;
 			}
 			else
 			{
 				this.filepathname = oldfilename;
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ColorControl.cs" startline="45" endline="59">
<![CDATA[
 
 		// Button clicked
 		private void button_Click(object sender, EventArgs e)
 		{
 			// Mouse up first
 			button_MouseUp(sender, new MouseEventArgs(MouseButtons.Left, 1, 0, 0, 0));
 			
 			// Show color dialog
 			dialog.Color = panel.BackColor;
 			if(dialog.ShowDialog(this.ParentForm) == DialogResult.OK)
 			{
 				// Apply new color
 				panel.BackColor = dialog.Color;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\MouseInput.cs" startline="46" endline="81">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public bool IsDisposed { get { return isdisposed; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public MouseInput(Control source)
 		{
 			// Initialize
 			dinput = new DirectInput();
 			
 			// Start mouse input
 			mouse = new Mouse(dinput);
 			if(mouse == null) throw new Exception("No mouse device found.");
 			
 			// Set mouse input settings
 			mouse.Properties.AxisMode = DeviceAxisMode.Relative;
 			
 			// Set cooperative level
 			mouse.SetCooperativeLevel(source,
 				CooperativeLevel.Nonexclusive | CooperativeLevel.Foreground);
 			
 			// Aquire device
 			try { mouse.Acquire(); }
 			catch(Exception) { }
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorRow.cs" startline="239" endline="254">
<![CDATA[
 
 		// This changes the type
 		public void ChangeType(int typeindex)
 		{
 			// Can't do this for a fixed field!
 			if(isfixed) throw new InvalidOperationException();
 			
 			// Different?
 			if(typeindex != fieldtype.Index)
 			{
 				// Change field type!
 				TypeHandlerAttribute attrib = General.Types.GetAttribute(typeindex);
 				fieldtype = General.Types.GetFieldHandler(typeindex, this.Cells[2].Value);
 				this.Cells[1].Value = fieldtype.GetDisplayType();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\SerializerStream.cs" startline="138" endline="147">
<![CDATA[
 
 		public void wString(string v)
 		{
 			ushort index;
 			if(stringstable.ContainsKey(v))
 				index = stringstable[v];
 			else
 				index = stringstable[v] = (ushort)stringstable.Count;
 			writer.Write(index);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="125" endline="138">
<![CDATA[
 		
 		public bool IsLoading
 		{
 			get
 			{
 				if(imageque != null)
 				{
 					return (backgroundloader != null) && backgroundloader.IsAlive && ((imageque.Count > 0) || previews.IsLoading);
 				}
 				else
 				{
 					return false;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ActorStructure.cs" startline="461" endline="473">
<![CDATA[
 		
 		/// <summary>
 		/// This returns the status of a flag.
 		/// </summary>
 		public bool GetFlagValue(string flag, bool defaultvalue)
 		{
 			if(flags.ContainsKey(flag))
 				return flags[flag];
 			else if(!skipsuper && (baseclass != null))
 				return baseclass.GetFlagValue(flag, defaultvalue);
 			else
 				return defaultvalue;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="188" endline="206">
<![CDATA[
 
 		// This manually creates an action
 		private void CreateAction(Configuration cfg, string name, string shortname)
 		{
 			// Action does not exist yet?
 			if(!actions.ContainsKey(name))
 			{
 				// Read the key from configuration
 				int key = General.Settings.ReadSetting("shortcuts." + name, -1);
 
 				// Create an action
 				actions.Add(name, new Action(cfg, name, shortname, key));
 			}
 			else
 			{
 				// Action already exists!
 				General.ErrorLogger.Add(ErrorType.Warning, "Action '" + name + "' already exists. Action names must be unique.");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="218" endline="224">
<![CDATA[
 		
 		// Doublelicking an item
 		private void list_DoubleClick(object sender, EventArgs e)
 		{
 			if(!preventselection && (list.SelectedItems.Count > 0))
 				if(SelectedItemDoubleClicked != null) SelectedItemDoubleClicked();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualThing.cs" startline="141" endline="158">
<![CDATA[
 
 		// Disposer
 		public virtual void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				if(geobuffer != null) geobuffer.Dispose();
 				geobuffer = null;
 
 				// Unregister resource
 				General.Map.Graphics.UnregisterResource(this);
 
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualSector.cs" startline="92" endline="109">
<![CDATA[
 
 		// Disposer
 		public virtual void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				if(geobuffer != null) geobuffer.Dispose();
 				geobuffer = null;
 
 				// Unregister resource
 				General.Map.Graphics.UnregisterResource(this);
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="460" endline="469">
<![CDATA[
 		
 		// This makes a list of the redo levels in order they will be undone
 		public List<UndoSnapshot> GetRedoList()
 		{
 			List<UndoSnapshot> list = new List<UndoSnapshot>(redos.Count + 1);
 			if(isundosnapshot && (snapshot != null))
 				list.Add(snapshot);
 			list.AddRange(redos);
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="551" endline="573">
<![CDATA[
 		
 		// This flips the linedef's vertex attachments
 		public void FlipVertices()
 		{
 			// make sure the start/end vertices are not automatically
 			// deleted if they do not belong to any other line
 			General.Map.Map.AutoRemove = false;
 
 			// Flip vertices
 			Vertex oldstart = start;
 			Vertex oldend = end;
 			SetStartVertex(oldend);
 			SetEndVertex(oldstart);
 
 			General.Map.Map.AutoRemove = true;
 			
 			// For drawing, the interior now lies on the other side
 			frontinterior = !frontinterior;
 
 			// Update required (angle changed)
 			NeedUpdate();
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1462" endline="1483">
<![CDATA[
 		
 		// This changes thing filter
 		public void ChangeThingFilter(ThingsFilter newfilter)
 		{
 			// We have a special filter for null
 			if(newfilter == null) newfilter = new NullThingsFilter();
 			
 			// Deactivate old filter
 			if(thingsfilter != null) thingsfilter.Deactivate();
 
 			// Change
 			thingsfilter = newfilter;
 
 			// Activate filter
 			thingsfilter.Activate();
 
 			// Update interface
 			General.MainWindow.ReflectThingsFilter();
 
 			// Redraw
 			General.MainWindow.RedrawDisplay();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="769" endline="776">
<![CDATA[
 
 		// This updates the Value column width
 		private void UpdateValueColumn()
 		{
 			int fieldnamewidth = fieldname.Visible ? fieldname.Width 
 			int fieldtypewidth = fieldtype.Visible ? fieldtype.Width 
 			fieldvalue.Width = fieldslist.ClientRectangle.Width - fieldnamewidth - fieldtypewidth - SystemInformation.VerticalScrollBarWidth - 10;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="997" endline="1007">
<![CDATA[
 
 		internal void RecRefLinedefStart(Linedef l)
 		{
 			if(!BeginRecordData(StreamCodes.RefLinedefStart)) return;
 			ss.wInt(l.Index);
 			if(l.Start != null) ss.wInt(l.Start.Index); else ss.wInt(-1);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1021" endline="1031">
<![CDATA[
 
 		internal void RecRefLinedefEnd(Linedef l)
 		{
 			if(!BeginRecordData(StreamCodes.RefLinedefEnd)) return;
 			ss.wInt(l.Index);
 			if(l.End != null) ss.wInt(l.End.Index); else ss.wInt(-1);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1045" endline="1055">
<![CDATA[
 
 		internal void RecRefLinedefFront(Linedef l)
 		{
 			if(!BeginRecordData(StreamCodes.RefLinedefFront)) return;
 			ss.wInt(l.Index);
 			if(l.Front != null) ss.wInt(l.Front.Index); else ss.wInt(-1);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1069" endline="1079">
<![CDATA[
 
 		internal void RecRefLinedefBack(Linedef l)
 		{
 			if(!BeginRecordData(StreamCodes.RefLinedefBack)) return;
 			ss.wInt(l.Index);
 			if(l.Back != null) ss.wInt(l.Back.Index); else ss.wInt(-1);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1162" endline="1172">
<![CDATA[
 
 		internal void RecRefSidedefSector(Sidedef s)
 		{
 			if(!BeginRecordData(StreamCodes.RefSidedefSector)) return;
 			ss.wInt(s.Index);
 			if(s.Sector != null) ss.wInt(s.Sector.Index); else ss.wInt(-1);
 			EndRecordData();
 
 			//LogRecordInfo("REC
 			propsrecorded = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\AutoSelectTextbox.cs" startline="74" endline="83">
<![CDATA[
 		
 		// When mouse pressed down
 		protected override void OnMouseDown(MouseEventArgs e)
 		{
 			base.OnMouseDown(e);
 
 			// Select all text when this mouseclick gives focus
 			if(eventcount == 0) this.SelectAll();
 			eventcount++;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="252" endline="263">
<![CDATA[
 		
 		// This flushes writing changes
 		public void Flush()
 		{
 			// Only possible when not read-only
 			if(!isreadonly)
 			{
 				// Flush writing changes
 				if(writer != null) writer.Flush();
 				if(file != null) file.Flush();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="582" endline="594">
<![CDATA[
 		
 		// Start mode combobox changed
 		private void startmode_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			if(preventchanges || (configinfo == null)) return;
 			
 			// Apply start mode
 			if(startmode.SelectedItem != null)
 			{
 				EditModeInfo emi = (startmode.SelectedItem as EditModeInfo);
 				configinfo.StartMode = emi.Type.Name;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="358" endline="378">
<![CDATA[
 		
 		// Tab selected
 		private void tabs_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			if(!controlledselection)
 			{
 				// Keep track of previous selected tab
 				previousselected = currentselected;
 				if(tabs.SelectedTab != null)
 				{
 					Docker d = (tabs.SelectedTab.Tag as Docker);
 					currentselected = d.FullName;
 				}
 				else
 				{
 					currentselected = null;
 				}
 			}
 			
 			General.MainWindow.FocusDisplay();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="722" endline="746">
<![CDATA[
 		
 		// This applies the contents of the enums combobox and hides (if opened)
 		private void ApplyEnums(bool hide)
 		{
 			// Enums combobox shown?
 			if((enumscombo.Visible) && (enumscombo.Tag is FieldsEditorRow))
 			{
 				// Get the row
 				FieldsEditorRow frow = (enumscombo.Tag as FieldsEditorRow);
 
 				// Take the selected value and apply it
 				ApplyValue(frow, enumscombo.Text);
 				
 				// Updated
 				frow.CellChanged();
 			}
 			
 			if(hide)
 			{
 				// Hide combobox
 				enumscombo.Tag = null;
 				enumscombo.Visible = false;
 				enumscombo.Items.Clear();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="671" endline="681">
<![CDATA[
 
 		// This takes sidedef settings if not taken yet
 		private static void TakeSidedefSettings(ref SidedefSettings settings, Sidedef side)
 		{
 			if((side.LongHighTexture != MapSet.EmptyLongName) && (settings.newtexhigh == null))
 				settings.newtexhigh = side.HighTexture;
 			if((side.LongMiddleTexture != MapSet.EmptyLongName) && (settings.newtexmid == null))
 				settings.newtexmid = side.MiddleTexture;
 			if((side.LongLowTexture != MapSet.EmptyLongName) && (settings.newtexlow == null))
 				settings.newtexlow = side.LowTexture;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="123" endline="145">
<![CDATA[
 		
 		// Disposer
 		public virtual void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				lock(this)
 				{
 					// Clean up
 					if(bitmap != null) bitmap.Dispose();
 					if(texture != null) texture.Dispose();
 					bitmap = null;
 					texture = null;
 					
 					// Done
 					usedinmap = false;
 					imagestate = ImageLoadState.None;
 					previewstate = ImageLoadState.None;
 					isdisposed = true;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2432" endline="2452">
<![CDATA[
 
 		// Show vertex info
 		public void ShowVertexInfo(Vertex v)
 		{
 			if(v.IsDisposed)
 			{
 				HideInfo();
 				return;
 			}
 
 			lastinfoobject = v;
 			modename.Visible = false;
 			if(linedefinfo.Visible) linedefinfo.Hide();
 			if(sectorinfo.Visible) sectorinfo.Hide();
 			if(thinginfo.Visible) thinginfo.Hide();
 			if(IsInfoPanelExpanded) vertexinfo.ShowInfo(v);
 
 			// Show info on collapsed label
 			labelcollapsedinfo.Text = v.Position.x.ToString("0.##") + ", " + v.Position.y.ToString("0.##");
 			labelcollapsedinfo.Refresh();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptDocumentTab.cs" startline="75" endline="102">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor
 		
 		// Constructor
 		public ScriptDocumentTab(ScriptEditorPanel panel)
 		{
 			// Keep panel
 			this.panel = panel;
 			
 			// Make the script control
 			editor = new ScriptEditorControl();
 			editor.Location = new Point(EDITOR_BORDER_LEFT, EDITOR_BORDER_TOP);
 			editor.Size = new Size(this.ClientSize.Width - EDITOR_BORDER_LEFT - EDITOR_BORDER_RIGHT,
 								   this.ClientSize.Height - EDITOR_BORDER_TOP - EDITOR_BORDER_BOTTOM);
 			editor.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
 			editor.Name = "editor";
 			editor.TabStop = true;
 			editor.TabIndex = 0;
 			this.Controls.Add(editor);
 
 			// Bind events
 			editor.OnExplicitSaveTab += panel.ExplicitSaveCurrentTab;
 			editor.OnOpenScriptBrowser += panel.OpenBrowseScript;
 			editor.OnOpenFindAndReplace += panel.OpenFindAndReplace;
 			editor.OnFindNext += panel.FindNext;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptFindReplaceForm.cs" startline="75" endline="81">
<![CDATA[
 
 		// This sets the text to find
 		public void SetFindText(string text)
 		{
 			findtext.Text = text;
 			findtext.SelectAll();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapOptions.cs" startline="273" endline="280">
<![CDATA[
 		
 		// This copies resources from a list
 		internal void CopyResources(DataLocationList fromlist)
 		{
 			// Clear this list
 			resources.Clear();
 			resources.AddRange(fromlist);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2366" endline="2377">
<![CDATA[
 		
 		// This displays the current mode name
 		internal void DisplayModeName(string name)
 		{
 			if(lastinfoobject == null)
 			{
 				labelcollapsedinfo.Text = name;
 				labelcollapsedinfo.Refresh();
 			}
 			modename.Text = name;
 			modename.Refresh();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="277" endline="291">
<![CDATA[
 
 		// Remove resource
 		private void deleteresource_Click(object sender, EventArgs e)
 		{
 			// Anything selected?
 			if(resourceitems.SelectedItems.Count > 0)
 			{
 				// Remove it
 				resourceitems.Items.Remove(resourceitems.SelectedItems[0]);
 				ResizeColumnHeader();
 
 				// Raise content changed event
 				if(OnContentChanged != null) OnContentChanged();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="188" endline="211">
<![CDATA[
 
 		// Disposer
 		internal void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Unbind any methods
 				General.Actions.UnbindMethods(this);
 
 				// Stop the thread and wait for it to end
 				backgroundthread.Interrupt();
 				backgroundthread.Join();
 				backgroundthread = null;
 				
 				// Clean up
 				ClearUndos();
 				ClearRedos();
 				General.WriteLogLine("All undo and redo levels cleared.");
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="373" endline="385">
<![CDATA[
 		
 		// This sets up the default view
 		public void SetDefaultZoom()
 		{
 			// View middle of map at 50% zoom
 			renderer2d.ScaleView(0.5f);
 			renderer2d.PositionView(0.0f, 0.0f);
 			this.OnViewChanged();
 			General.MainWindow.RedrawDisplay();
 
 			// Give a new mousemove event to update coordinates
 			if(mouseinside) OnMouseMove(new MouseEventArgs(mousebuttons, 0, (int)mousepos.x, (int)mousepos.y, 0));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="176" endline="194">
<![CDATA[
 		
 		// This redraws the image preview
 		private void ShowPreview(Image image)
 		{
 			// Dispose old image
 			preview.BackgroundImage = null;
 			if(bmp != null)
 			{
 				bmp.Dispose();
 				bmp = null;
 			}
 			
 			if(image != null)
 			{
 				// Show it centered
 				General.DisplayZoomedImage(preview, image);
 				preview.Refresh();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="208" endline="216">
<![CDATA[
 
 		// Cancel clicked
 		private void cancel_Click(object sender, EventArgs e)
 		{
 			// No selection, close
 			selectedname = "";
 			DialogResult = DialogResult.Cancel;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="207" endline="215">
<![CDATA[
 
 		// Cancel clicked
 		private void cancel_Click(object sender, EventArgs e)
 		{
 			// No selection, close
 			selectedname = "";
 			DialogResult = DialogResult.Cancel;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditModeInfo.cs" startline="102" endline="113">
<![CDATA[
 
 		// Disposer
 		public void Dispose()
 		{
 			// Dispose
 			UnbindSwitchAction();
 			buttonimage.Dispose();
 			buttonimagestream.Dispose();
 
 			// Clean up
 			plugin = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="355" endline="364">
<![CDATA[
 		
 		// This begins writing to the record stream
 		private bool BeginRecordData(StreamCodes code)
 		{
 			if((ss == null) || isdisposed) return false;
 			isrecordingcommand = true;
 			prevstreamlength = stream.Length;
 			ss.wByte((byte)code);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\LinedefInfoPanel.cs" startline="224" endline="241">
<![CDATA[
 
 		// When visible changed
 		protected override void OnVisibleChanged(EventArgs e)
 		{
 			// Hiding panels
 			if(!this.Visible)
 			{
 				fronthightex.BackgroundImage = null;
 				frontmidtex.BackgroundImage = null;
 				frontlowtex.BackgroundImage = null;
 				backhightex.BackgroundImage = null;
 				backmidtex.BackgroundImage = null;
 				backlowtex.BackgroundImage = null;
 			}
 
 			// Call base
 			base.OnVisibleChanged(e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\ClippedStream.cs" startline="231" endline="246">
<![CDATA[
 		
 		// This reads a single byte from the stream
 		public override int ReadByte()
 		{
 			// Check if this exceeds limits
 			if((this.position + 1) > (this.length + 1))
 				throw new ArgumentException("Attempted to read outside the range of the stream.");
 
 			// Seek if needed
 			if(basestream.Position != (this.offset + this.position))
 				basestream.Seek(this.offset + this.position, SeekOrigin.Begin);
 
 			// Read from base stream
 			position++;
 			return basestream.ReadByte();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2378" endline="2392">
<![CDATA[
 		
 		// This hides all info panels
 		public void HideInfo()
 		{
 			// Hide them all
 			lastinfoobject = null;
 			if(linedefinfo.Visible) linedefinfo.Hide();
 			if(vertexinfo.Visible) vertexinfo.Hide();
 			if(sectorinfo.Visible) sectorinfo.Hide();
 			if(thinginfo.Visible) thinginfo.Hide();
 			labelcollapsedinfo.Text = modename.Text;
 			labelcollapsedinfo.Refresh();
 			modename.Visible = ((General.Map != null) && IsInfoPanelExpanded);
 			modename.Refresh();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MapOptionsForm.cs" startline="8" endline="79">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public MapOptionsForm(MapOptions options)
 		{
 			int index;
 			
 			// Initialize
 			InitializeComponent();
 
 			// Keep settings
 			this.options = options;
 
 			// Go for all configurations
 			for(int i = 0; i < General.Configs.Count; i++)
 			{
 				// Add config name to list
 				index = config.Items.Add(General.Configs[i]);
 
 				// Is this configuration currently selected?
 				if(string.Compare(General.Configs[i].Filename, options.ConfigFile, true) == 0)
 				{
 					// Select this item
 					config.SelectedIndex = index;
 				}
 			}
 			for(int i = 0; i < General.Configs.Count; i++)
 			{
 				// Add config name to list
 				index = config.Items.Add(General.Configs[i]);
 
 				// Is this configuration currently selected?
 				if(string.Compare(General.Configs[i].Filename, options.ConfigFile, true) == 0)
 				{
 					// Select this item
 					config.SelectedIndex = index;
 				}
 			}
 
 			// Set the level name
 			levelname.Text = options.CurrentName;
 
 			// Set strict patches loading
 			strictpatches.Checked = options.StrictPatches;
 
 			// Fill the resources list
 			datalocations.EditResourceLocationList(options.Resources);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualThing.cs" startline="230" endline="258">
<![CDATA[
 		
 		// This updates the visual thing
 		public virtual void Update()
 		{
 			// Do we need to update the geometry buffer?
 			if(updategeo)
 			{
 				// Trash geometry buffer
 				if(geobuffer != null) geobuffer.Dispose();
 				geobuffer = null;
 
 				// Any vertics?
 				if(vertices.Length > 0)
 				{
 					// Make a new buffer
 					geobuffer = new VertexBuffer(General.Map.Graphics.Device, WorldVertex.Stride * vertices.Length,
 												 Usage.WriteOnly | Usage.Dynamic, VertexFormat.None, Pool.Default);
 
 					// Fill the buffer
 					DataStream bufferstream = geobuffer.Lock(0, WorldVertex.Stride * vertices.Length, LockFlags.Discard);
 					bufferstream.WriteRange<WorldVertex>(vertices);
 					geobuffer.Unlock();
 					bufferstream.Dispose();
 				}
 
 				// Done
 				updategeo = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="191" endline="207">
<![CDATA[
 
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Set selected name and close
 			if(browser.SelectedItem != null)
 			{
 				selectedname = browser.SelectedItem.Text;
 				DialogResult = DialogResult.OK;
 			}
 			else
 			{
 				selectedname = "";
 				DialogResult = DialogResult.Cancel;
 			}
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="190" endline="206">
<![CDATA[
 
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Set selected name and close
 			if(browser.SelectedItem != null)
 			{
 				selectedname = browser.SelectedItem.Text;
 				DialogResult = DialogResult.OK;
 			}
 			else
 			{
 				selectedname = "";
 				DialogResult = DialogResult.Cancel;
 			}
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="289" endline="314">
<![CDATA[
 
 		// Tab changes
 		private void tabs_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			// Enable/disable stuff with tabs
 			if(tabs.SelectedTab != tabkeys)
 			{
 				this.AcceptButton = apply;
 				this.CancelButton = cancel;
 				apply.TabStop = true;
 				cancel.TabStop = true;
 				tabs.TabStop = true;
 			}
 			else
 			{
 				this.AcceptButton = null;
 				this.CancelButton = null;
 				apply.TabStop = false;
 				cancel.TabStop = false;
 				tabs.TabStop = false;
 			}
 			
 			colorsgroup1.Visible = (tabs.SelectedTab == tabcolors);
 			//colorsgroup2.Visible = (tabs.SelectedTab == tabcolors);
 			colorsgroup3.Visible = (tabs.SelectedTab == tabcolors);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="368" endline="395">
<![CDATA[
 
 		// This destroys the rendertargets
 		public void DestroyRendertargets()
 		{
 			// Trash rendertargets
 			if(plottertex != null) plottertex.Dispose();
 			if(thingstex != null) thingstex.Dispose();
 			if(overlaytex != null) overlaytex.Dispose();
 			if(surfacetex != null) surfacetex.Dispose();
 			if(backtex != null) backtex.Dispose();
 			if(screenverts != null) screenverts.Dispose();
 			plottertex = null;
 			thingstex = null;
 			backtex = null;
 			screenverts = null;
 			overlaytex = null;
 			surfacetex = null;
 			
 			// Trash things batch buffer
 			if(thingsvertices != null) thingsvertices.Dispose();
 			thingsvertices = null;
 			lastgridscale = -1f;
 			lastgridsize = 0;
 
 			// Trash font
 			if(font != null) font.Dispose();
 			font = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptEditorForm.cs" startline="61" endline="76">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		// This asks to save files and returns the result
 		// Also does implicit saves
 		// Returns false when cancelled by the user
 		public bool AskSaveAll()
 		{
 			// Implicit-save the script lumps
 			editor.ImplicitSave();
 			
 			// Save other scripts
 			return editor.AskSaveAll();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="980" endline="986">
<![CDATA[
 		
 		// This requests a delayed redraw
 		public void DelayedRedraw()
 		{
 			// Request redraw
 			if(!redrawtimer.Enabled) redrawtimer.Enabled = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DeserializerStream.cs" startline="66" endline="86">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// Management
 		public void Begin()
 		{
 			// First 4 bytes are reserved for the offset of the strings table
 			stringtablepos = reader.ReadInt32();
 			stream.Seek(stringtablepos, SeekOrigin.Begin);
 			
 			// Read the strings
 			List<string> strings = new List<string>();
 			while(stream.Position < (int)stream.Length)
 				strings.Add(reader.ReadString());
 			while(stream.Position < (int)stream.Length)
 				strings.Add(reader.ReadString());
 			stringstable = strings.ToArray();
 
 			// Back to start
 			stream.Seek(4, SeekOrigin.Begin);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1247" endline="1253">
<![CDATA[
 
 		// This applies the changed status for internal scripts
 		internal void ApplyScriptChanged()
 		{
 			// Remember if lumps are changed
 			scriptschanged |= scriptwindow.Editor.CheckImplicitChanges();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesController.cs" startline="82" endline="93">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This adds a preferences tab
 		public void AddTab(TabPage tab)
 		{
 			if(!allowaddtab) throw new InvalidOperationException("Tab pages can only be added when the dialog is being initialized");
 
 			form.AddTabPage(tab);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="160" endline="166">
<![CDATA[
 		
 		// This adds a reference
 		public void AddReference()
 		{
 			references++;
 			if(references == 1) General.Map.Data.ProcessImage(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="107" endline="172">
<![CDATA[
 		private RenderLayers renderlayer = RenderLayers.None;
 		
 		// Surfaces
 		private SurfaceManager surfaces;
 		
 		// Images
 		private ResourceImage[] thingtexture;
 		
 		// View settings (world coordinates)
 		private ViewMode viewmode;
 		private float scale;
 		private float scaleinv;
 		private float offsetx;
 		private float offsety;
 		private float translatex;
 		private float translatey;
 		private float linenormalsize;
 		private float lastgridscale = -1f;
 		private int lastgridsize;
 		private float lastgridx;
 		private float lastgridy;
 		private RectangleF viewport;
 		private RectangleF yviewport;
 
 		// Presentation
 		private Presentation present;
 		
 		#endregion
 
 		#region ================== Properties
 
 		public float OffsetX { get { return offsetx; } }
 		public float OffsetY { get { return offsety; } }
 		public float TranslateX { get { return translatex; } }
 		public float TranslateY { get { return translatey; } }
 		public float Scale { get { return scale; } }
 		public int VertexSize { get { return vertexsize; } }
 		public ViewMode ViewMode { get { return viewmode; } }
 		public SurfaceManager Surfaces { get { return surfaces; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		internal Renderer2D(D3DDevice graphics) 
 		{
 			// Load thing textures
 			thingtexture = new ResourceImage[NUM_THING_TEXTURES];
 			for(int i = 0; i < NUM_THING_TEXTURES; i++)
 			{
 				thingtexture[i] = new ResourceImage("CodeImp.DoomBuilder.Resources.Thing2D_" + i.ToString(CultureInfo.InvariantCulture) + ".png");
 				thingtexture[i].UseColorCorrection = false;
 				thingtexture[i].LoadImage();
 				thingtexture[i].CreateTexture();
 			}
 			for(int i = 0; i < NUM_THING_TEXTURES; i++)
 			{
 				thingtexture[i] = new ResourceImage("CodeImp.DoomBuilder.Resources.Thing2D_" + i.ToString(CultureInfo.InvariantCulture) + ".png");
 				thingtexture[i].UseColorCorrection = false;
 				thingtexture[i].LoadImage();
 				thingtexture[i].CreateTexture();
 			}
 
 			// Create surface manager
 			surfaces = new SurfaceManager();
 
 			// Create rendertargets
 			CreateRendertargets();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoSnapshot.cs" startline="114" endline="140">
<![CDATA[
 		
 		// This moves the snapshot from memory to harddisk
 		internal void WriteToFile()
 		{
 			lock(this)
 			{
 				if(isdisposed) return;
 				if(isondisk) return;
 				isondisk = true;
 				
 				// Compress data
 				recstream.Seek(0, SeekOrigin.Begin);
 				MemoryStream outstream = new MemoryStream((int)recstream.Length);
 				BZip2.Compress(recstream, outstream, 300000);
 
 				// Make temporary file
 				filename = General.MakeTempFilename(General.Map.TempPath, "snapshot");
 
 				// Write data to file
 				File.WriteAllBytes(filename, outstream.ToArray());
 
 				// Remove data from memory
 				recstream.Dispose();
 				recstream = null;
 				outstream.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1275" endline="1289">
<![CDATA[
 		
 		// This checks if the scripts are changed
 		internal bool CheckScriptChanged()
 		{
 			if(scriptwindow != null)
 			{
 				// Check if scripts are changed			
 				return scriptschanged || scriptwindow.Editor.CheckImplicitChanges();
 			}
 			else
 			{
 				// Check if scripts are changed			
 				return scriptschanged;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="364" endline="371">
<![CDATA[
 
 		private void autoscrollspeed_ValueChanged(object sender, EventArgs e)
 		{
 			if(autoscrollspeed.Value == 0)
 				autoscrollspeedlabel.Text = "Off";
 			else
 				autoscrollspeedlabel.Text = autoscrollspeed.Value.ToString() + "x";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualSector.cs" startline="172" endline="191">
<![CDATA[
 
 		/// <summary>
 		/// This adds geometry for this sector. If the geometry inherits from VisualSidedef then it
 		/// will be added to the SidedefGeometry, otherwise it will be added as FixedGeometry.
 		/// </summary>
 		public void AddGeometry(VisualGeometry geo)
 		{
 			updategeo = true;
 			allgeometry.Add(geo);
 			if(geo.Sidedef != null)
 			{
 				if(!sidedefgeometry.ContainsKey(geo.Sidedef))
 					sidedefgeometry[geo.Sidedef] = new List<VisualGeometry>(3);
 				sidedefgeometry[geo.Sidedef].Add(geo);
 			}
 			else
 			{
 				fixedgeometry.Add(geo);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="640" endline="661">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Events
 		
 		// Layout needs to be re-organized
 		protected override void OnLayout(LayoutEventArgs e)
 		{
 			base.OnLayout(e);
 
 			// With or without functions bar?
 			if(functionbar.Visible)
 			{
 				scriptpanel.Top = functionbar.Bottom + 6;
 				scriptpanel.Height = this.ClientSize.Height - scriptpanel.Top;
 			}
 			else
 			{
 				scriptpanel.Top = 0;
 				scriptpanel.Height = this.ClientSize.Height;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="100" endline="119">
<![CDATA[
 		
 		// Disposer
 		public void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Flush all changes
 				Flush();
 				
 				// Clean up
 				if(lumps != null) foreach(Lump l in lumps) l.Dispose();
 				if(writer != null) writer.Close();
 				if(reader != null) reader.Close();
 				if(file != null) file.Dispose();
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="610" endline="637">
<![CDATA[
 
 		/// <summary>This creates a new sector and returns it.</summary>
 		public Sector CreateSector(int index)
 		{
 			int fixedindex;
 
 			if(numsectors == General.Map.FormatInterface.MaxSectors)
 			{
 				General.Interface.DisplayStatus(StatusType.Warning, "Failed to complete operation
 				return null;
 			}
 
 			// Do we have any index holes we can use?
 			if(indexholes.Count > 0)
 			{
 				// Take one of the index holes
 				fixedindex = indexholes[indexholes.Count - 1];
 				indexholes.RemoveAt(indexholes.Count - 1);
 			}
 			else
 			{
 				// Make a new index
 				fixedindex = lastsectorindex++;
 			}
 			
 			// Make the sector
 			return CreateSectorEx(fixedindex, index);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="202" endline="225">
<![CDATA[
 		
 		// Key released
 		private void listconfigs_KeyUp(object sender, KeyEventArgs e)
 		{
 			// Nothing selected?
 			if(listconfigs.SelectedItems.Count == 0)
 			{
 				// Disable panels
 				gameconfig = null;
 				configinfo = null;
 				configdata.FixedResourceLocationList(new DataLocationList());
 				configdata.EditResourceLocationList(new DataLocationList());
 				nodebuildersave.SelectedIndex = -1;
 				nodebuildertest.SelectedIndex = -1;
 				testapplication.Text = "";
 				testparameters.Text = "";
 				shortpaths.Checked = false;
 				skill.Value = 0;
 				skill.ClearInfo();
 				customparameters.Checked = false;
 				tabs.Enabled = false;
 				listtextures.Items.Clear();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1193" endline="1228">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Script Editing
 		
 		// Show the script editor
 		[BeginAction("openscripteditor")]
 		internal void ShowScriptEditor()
 		{
 			Cursor.Current = Cursors.WaitCursor;
 			
 			if(scriptwindow == null)
 			{
 				// Load the window
 				scriptwindow = new ScriptEditorForm();
 			}
 			
 			// Window not yet visible?
 			if(!scriptwindow.Visible)
 			{
 				// Show the window
 				if(General.Settings.ScriptOnTop)
 				{
 					if(scriptwindow.Visible && (scriptwindow.Owner == null)) scriptwindow.Hide();
 					scriptwindow.Show(General.MainWindow);
 				}
 				else
 				{
 					if(scriptwindow.Visible && (scriptwindow.Owner != null)) scriptwindow.Hide();
 					scriptwindow.Show();
 				}
 			}
 			scriptwindow.Activate();
 			scriptwindow.Focus();
 			Cursor.Current = Cursors.Default;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="716" endline="747">
<![CDATA[
 
 		// This ends a drawing session
 		public void Finish()
 		{
 			// Clean up plotter
 			if(renderlayer == RenderLayers.Plotter)
 			{
 				if(plottertex != null) plottertex.UnlockRectangle(0);
 				if(plotlocked.Data != null) plotlocked.Data.Dispose();
 				plotter = null;
 			}
 			
 			// Clean up things / overlay
 			if((renderlayer == RenderLayers.Things) || (renderlayer == RenderLayers.Overlay) || (renderlayer == RenderLayers.Surface))
 			{
 				// Stop rendering
 				graphics.FinishRendering();
 				
 				// Release rendertarget
 				try
 				{
 					graphics.Device.DepthStencilSurface = graphics.DepthBuffer;
 					graphics.Device.SetRenderTarget(0, graphics.BackBuffer);
 				}
 				catch(Exception) { }
 				if(targetsurface != null) targetsurface.Dispose();
 				targetsurface = null;
 			}
 			
 			// Done
 			renderlayer = RenderLayers.None;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DDevice.cs" startline="106" endline="126">
<![CDATA[
 
 		// Disposer
 		internal void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				foreach(ID3DResource res in resources.Values) res.UnloadResource();
 				if(shaders != null) shaders.Dispose();
 				rendertarget = null;
 				if(backbuffer != null) backbuffer.Dispose();
 				if(depthbuffer != null) depthbuffer.Dispose();
 				if(device != null) device.Dispose();
 				if(font != null) font.Dispose();
 				if(fonttexture != null) fonttexture.Dispose();
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\World3DShader.cs" startline="96" endline="116">
<![CDATA[
 
 		// Disposer
 		public override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				if(texture1 != null) texture1.Dispose();
 				if(worldviewproj != null) worldviewproj.Dispose();
 				if(minfiltersettings != null) minfiltersettings.Dispose();
 				if(magfiltersettings != null) magfiltersettings.Dispose();
 				if(mipfiltersettings != null) mipfiltersettings.Dispose();
 				if(modulatecolor != null) modulatecolor.Dispose();
 				if(highlightcolor != null) highlightcolor.Dispose();
 				if(maxanisotropysetting != null) maxanisotropysetting.Dispose();
 
 				// Done
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ActorStructure.cs" startline="487" endline="499">
<![CDATA[
 		
 		/// <summary>
 		/// This returns a specific state, or null when the state can't be found.
 		/// </summary>
 		public StateStructure GetState(string statename)
 		{
 			if(states.ContainsKey(statename))
 				return states[statename];
 			else if(!skipsuper && (baseclass != null))
 				return baseclass.GetState(statename);
 			else
 				return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\EffectBrowserForm.cs" startline="182" endline="191">
<![CDATA[
 		
 		// Double-clicked on item
 		private void effects_DoubleClick(object sender, EventArgs e)
 		{
 			// Effect selected?
 			if((effects.SelectedItems.Count > 0) && (effects.SelectedItems[0].Tag is SectorEffectInfo))
 			{
 				if(apply.Enabled) apply_Click(this, EventArgs.Empty);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="321" endline="336">
<![CDATA[
 
 		// This updates the floor surface
 		public void UpdateFloorSurface()
 		{
 			if(flatvertices == null) return;
 			
 			// Create floor vertices
 			SurfaceUpdate updateinfo = new SurfaceUpdate(flatvertices.Length, true, false);
 			flatvertices.CopyTo(updateinfo.floorvertices, 0);
 			General.Plugins.OnSectorFloorSurfaceUpdate(this, ref updateinfo.floorvertices);
 			updateinfo.floortexture = longfloortexname;
 			
 			// Update entry
 			General.Map.CRenderer2D.Surfaces.UpdateSurfaces(surfaceentries, updateinfo);
 			General.Map.CRenderer2D.Surfaces.UnlockBuffers();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="337" endline="352">
<![CDATA[
 
 		// This updates the ceiling surface
 		public void UpdateCeilingSurface()
 		{
 			if(flatvertices == null) return;
 
 			// Create ceiling vertices
 			SurfaceUpdate updateinfo = new SurfaceUpdate(flatvertices.Length, false, true);
 			flatvertices.CopyTo(updateinfo.ceilvertices, 0);
 			General.Plugins.OnSectorCeilingSurfaceUpdate(this, ref updateinfo.ceilvertices);
 			updateinfo.ceiltexture = longceiltexname;
 			
 			// Update entry
 			General.Map.CRenderer2D.Surfaces.UpdateSurfaces(surfaceentries, updateinfo);
 			General.Map.CRenderer2D.Surfaces.UnlockBuffers();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="351" endline="381">
<![CDATA[
 
 		// Customize parameters (un)checked
 		private void customparameters_CheckedChanged(object sender, EventArgs e)
 		{
 			// Leave when no configuration selected
 			if(configinfo == null) return;
 
 			// Apply to selected configuration
 			configinfo.CustomParameters = customparameters.Checked;
 
 			// Update interface
 			labelparameters.Visible = customparameters.Checked;
 			testparameters.Visible = customparameters.Checked;
 			shortpaths.Visible = customparameters.Checked;
 
 			// Check if a map is loaded
 			if(General.Map != null)
 			{
 				// Show parameters example result
 				labelresult.Visible = customparameters.Checked;
 				testresult.Visible = customparameters.Checked;
 				noresultlabel.Visible = false;
 			}
 			else
 			{
 				// Cannot show parameters example result
 				labelresult.Visible = false;
 				testresult.Visible = false;
 				noresultlabel.Visible = customparameters.Checked;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="253" endline="287">
<![CDATA[
 		
 		// This removes textures that are not required
 		public void RemoveUnneededTextures(bool removemiddle, bool force)
 		{
 			BeforePropsChange();
 			
 			// The middle texture can be removed regardless of any sector tag or linedef action
 			if(!MiddleRequired() && removemiddle)
 			{
 				this.texnamemid = "-";
 				this.longtexnamemid = MapSet.EmptyLongName;
 				General.Map.IsChanged = true;
 			}
 
 			// Check if the line or sectors have no action or tags because
 			// if they do, any texture on this side could be needed
 			if(((linedef.Tag <= 0) && (linedef.Action == 0) && (sector.Tag <= 0) &&
 			    ((Other == null) || (Other.sector.Tag <= 0))) ||
 			   force)
 			{
 				if(!HighRequired())
 				{
 					this.texnamehigh = "-";
 					this.longtexnamehigh = MapSet.EmptyLongName;
 					General.Map.IsChanged = true;
 				}
 
 				if(!LowRequired())
 				{
 					this.texnamelow = "-";
 					this.longtexnamelow = MapSet.EmptyLongName;
 					General.Map.IsChanged = true;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="653" endline="667">
<![CDATA[
 
 		/// <summary>This creates a new thing and returns it.</summary>
 		public Thing CreateThing()
 		{
 			if(numthings == General.Map.FormatInterface.MaxThings)
 			{
 				General.Interface.DisplayStatus(StatusType.Warning, "Failed to complete operation
 				return null;
 			}
 
 			// Make the thing
 			Thing t = new Thing(this, numthings);
 			AddItem(t, ref things, numthings, ref numthings);
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="120" endline="166">
<![CDATA[
 
 		#endregion
 
 		#region ================== IO
 
 		// Open a WAD file
 		private void Open(string pathfilename)
 		{
 			FileAccess access;
 			FileShare share;
 			
 			// Determine if opening for read only
 			if(isreadonly)
 			{
 				// Read only
 				access = FileAccess.Read;
 				share = FileShare.ReadWrite;
 			}
 			else
 			{
 				// Private access
 				access = FileAccess.ReadWrite;
 				share = FileShare.Read;
 			}
 			
 			// Keep filename
 			filename = pathfilename;
 			
 			// Open the file stream
 			file = File.Open(pathfilename, FileMode.OpenOrCreate, access, share);
 
 			// Create file handling tools
 			reader = new BinaryReader(file, ENCODING);
 			if(!isreadonly) writer = new BinaryWriter(file, ENCODING);
 
 			// Is the WAD file zero length?
 			if(file.Length == 0)
 			{
 				// Create the headers in file
 				CreateHeaders();
 			}
 			else
 			{
 				// Read information from file
 				ReadHeaders();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Vertex.cs" startline="143" endline="160">
<![CDATA[
 
 		// This detaches a linedef
 		internal void DetachLinedefP(LinkedListNode<Linedef> l)
 		{
 			// Not disposing?
 			if(!isdisposed)
 			{
 				// Remove linedef
 				linedefs.Remove(l);
 
 				// No more linedefs left?
 				if((linedefs.Count == 0) && map.AutoRemove)
 				{
 					// This vertex is now useless, dispose it
 					this.Dispose();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditingManager.cs" startline="201" endline="218">
<![CDATA[
 		
 		// This disengages a volatile mode, leaving the choice to cancel or accept to the editing mode
 		public bool DisengageVolatileMode()
 		{
 			// Volatile mode?
 			if((General.Map != null) && (mode != null) && mode.Attributes.Volatile && !disengaging)
 			{
 				// Change back to normal mode
 				disengaging = true;
 				ChangeMode(prevstablemode.Name);
 				return true;
 			}
 			else
 			{
 				// Mode is not volatile
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="394" endline="408">
<![CDATA[
 		
 		// This begins adding items
 		public void BeginAdding(bool keepselectedindex)
 		{
 			if(keepselectedindex && (list.SelectedItems.Count > 0))
 				keepselected = list.SelectedIndices[0];
 			else
 				keepselected = -1;
 			
 			// Clean list
 			items.Clear();
 			
 			// Stop updating
 			refreshtimer.Enabled = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="215" endline="233">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Resources
 
 		// This loads the textures for highlight and selection if we need them
 		private void SetupTextures()
 		{
 			if(!graphics.Shaders.Enabled)
 			{
 				highlightimage = new ColorImage(General.Colors.Highlight, 32, 32);
 				highlightimage.LoadImage();
 				highlightimage.CreateTexture();
 				
 				selectionimage = new ColorImage(General.Colors.Selection, 32, 32);
 				selectionimage.LoadImage();
 				selectionimage.CreateTexture();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="166" endline="217">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		// This sets up the control for a specific argument
 		public void Setup(ArgumentInfo arginfo)
 		{
 			int oldvalue = 0;
 			
 			// Get the original value
 			if(typehandler != null) oldvalue = typehandler.GetIntValue();
 			
 			// Get the type handler
 			typehandler = General.Types.GetArgumentHandler(arginfo);
 			
 			// Clear combobox
 			combobox.SelectedItem = null;
 			combobox.Items.Clear();
 
 			// Check if this supports enumerated options
 			if(typehandler.IsEnumerable)
 			{
 				// Show the combobox
 				button.Visible = false;
 				scrollbuttons.Visible = false;
 				combobox.DropDownStyle = ComboBoxStyle.DropDown;
 				combobox.Items.AddRange(typehandler.GetEnumList().ToArray());
 			}
 			// Check if browsable
 			else if(typehandler.IsBrowseable)
 			{
 				// Show the button
 				button.Visible = true;
 				button.Image = typehandler.BrowseImage;
 				scrollbuttons.Visible = false;
 				combobox.DropDownStyle = ComboBoxStyle.Simple;
 			}
 			else
 			{
 				// Show textbox with scroll buttons
 				button.Visible = false;
 				scrollbuttons.Visible = true;
 				combobox.DropDownStyle = ComboBoxStyle.Simple;
 			}
 			
 			// Setup layout
 			ArgumentBox_Resize(this, EventArgs.Empty);
 			
 			// Re-apply value
 			SetValue(oldvalue);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="405" endline="459">
<![CDATA[
 
 		// This copies textures to another sidedef
 		// And possibly also the offsets
 		public void AddTexturesTo(Sidedef s)
 		{
 			int copyoffsets = 0;
 
 			// s cannot be null
 			if(s == null) return;
 
 			s.BeforePropsChange();
 
 			// Upper texture set?
 			if((texnamehigh.Length > 0) && (texnamehigh[0] != '-'))
 			{
 				// Copy upper texture
 				s.texnamehigh = texnamehigh;
 				s.longtexnamehigh = longtexnamehigh;
 
 				// Counts as a half coice for copying offsets
 				copyoffsets += 1;
 			}
 
 			// Middle texture set?
 			if((texnamemid.Length > 0) && (texnamemid[0] != '-'))
 			{
 				// Copy middle texture
 				s.texnamemid = texnamemid;
 				s.longtexnamemid = longtexnamemid;
 
 				// Counts for copying offsets
 				copyoffsets += 2;
 			}
 
 			// Lower texture set?
 			if((texnamelow.Length > 0) && (texnamelow[0] != '-'))
 			{
 				// Copy middle texture
 				s.texnamelow = texnamelow;
 				s.longtexnamelow = longtexnamelow;
 
 				// Counts as a half coice for copying offsets
 				copyoffsets += 1;
 			}
 
 			// Copy offsets also?
 			if(copyoffsets >= 2)
 			{
 				// Copy offsets
 				s.offsetx = offsetx;
 				s.offsety = offsety;
 			}
 
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="595" endline="613">
<![CDATA[
 
 		// Key released
 		private void listactions_KeyUp(object sender, KeyEventArgs e)
 		{
 			// Nothing selected?
 			if(listactions.SelectedItems.Count == 0)
 			{
 				// Disable panel
 				actioncontrolpanel.Enabled = false;
 				actiontitle.Text = "(select an action from the list)";
 				actiondescription.Text = "";
 				actionkey.Text = "";
 				actioncontrol.SelectedIndex = -1;
 				disregardshiftlabel.Visible = false;
 			}
 			
 			// Show actions with same key
 			UpdateKeyUsedActions();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="265" endline="278">
<![CDATA[
 
 		// Cancel clicked
 		private void cancel_Click(object sender, EventArgs e)
 		{
 			// Let the plugins know
 			controller.RaiseCancel();
 
 			// Let the plugins know we're closing
 			General.Plugins.OnClosePreferences(controller);
 
 			// Close
 			this.DialogResult = DialogResult.Cancel;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\BinaryHeap.cs" startline="89" endline="107">
<![CDATA[
 
 		// This adds an item to the list
 		// This is an O(log n) operation, where n is Count
 		public virtual void Add(T item)
 		{
 			int index = heap.Count;
 			
 			// Add to the end of the heap
 			heap.Add(item);
 			
 			// Continue until the item is at the top
 			// or compares higher to the parent item
 			while((index > 0) && (heap[index].CompareTo(heap[ParentOf(index)]) > 0))
 			{
 				// Swap with parent item
 				SwapItems(index, ParentOf(index));
 				index = ParentOf(index);
 			}
 			while((index > 0) && (heap[index].CompareTo(heap[ParentOf(index)]) > 0))
 			{
 				// Swap with parent item
 				SwapItems(index, ParentOf(index));
 				index = ParentOf(index);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\FlatQuad.cs" startline="64" endline="85">
<![CDATA[
 
 		// Constructor
 		public FlatQuad(PrimitiveType type, float left, float top, float right, float bottom, float twidth, float theight)
 		{
 			float twd, thd;
 			
 			// Initialize
 			Initialize(type);
 
 			// Determine texture size dividers
 			twd = 1f / twidth;
 			thd = 1f / theight;
 			
 			// Set coordinates
 			if(type == PrimitiveType.TriangleList)
 				SetTriangleListCoordinates(left, top, right, bottom, twd, thd, 1f - twd, 1f - thd);
 			else if(type == PrimitiveType.TriangleStrip)
 				SetTriangleStripCoordinates(left, top, right, bottom, twd, thd, 1f - twd, 1f - thd);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\PixelColorBlock.cs" startline="79" endline="88">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This clears the memory black
 		public void Clear()
 		{
 			if(memorysize > 0) General.ZeroMemory(new IntPtr(memory), (int)memorysize);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\GridSetup.cs" startline="103" endline="121">
<![CDATA[
 
 		// Disposer
 		internal void Dispose()
 		{
 			if(!isdisposed)
 			{
 				// Dispose image if needed
 				if(backimage is FileImage) (backimage as FileImage).Dispose();
 				
 				// Clean up
 				backimage = null;
 
 				// Unregister actions
 				General.Actions.UnbindMethods(this);
 
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoSnapshot.cs" startline="84" endline="96">
<![CDATA[
 
 		// Disposer
 		internal void Dispose()
 		{
 			lock(this)
 			{
 				isdisposed = true;
 				if(recstream != null) recstream.Dispose();
 				recstream = null;
 				if(isondisk) File.Delete(filename);
 				isondisk = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="181" endline="223">
<![CDATA[
 		
 		// This reads the WAD header and lumps table
 		private void ReadHeaders()
 		{
 			int offset, length;
 			byte[] fixedname;
 			
 			// Make sure the write is finished writing
 			if(!isreadonly) writer.Flush();
 
 			// Seek to beginning
 			file.Seek(0, SeekOrigin.Begin);
 
 			// Read WAD type
 			type = ENCODING.GetString(reader.ReadBytes(4));
 			
 			// Number of lumps
 			numlumps = reader.ReadInt32();
 			if(numlumps < 0) throw new IOException("Invalid number of lumps in wad file.");
 
 			// Lumps table offset
 			lumpsoffset = reader.ReadInt32();
 			if(lumpsoffset < 0) throw new IOException("Invalid lumps offset in wad file.");
 
 			// Seek to the lumps table
 			file.Seek(lumpsoffset, SeekOrigin.Begin);
 			
 			// Dispose old lumps and create new list
 			if(lumps != null) foreach(Lump l in lumps) l.Dispose();
 			lumps = new List<Lump>(numlumps);
 
 			// Go for all lumps
 			for(int i = 0; i < numlumps; i++)
 			{
 				// Read lump information
 				offset = reader.ReadInt32();
 				length = reader.ReadInt32();
 				fixedname = reader.ReadBytes(8);
 
 				// Create the lump
 				lumps.Add(new Lump(file, this, fixedname, offset, length));
 			}
 			for(int i = 0; i < numlumps; i++)
 			{
 				// Read lump information
 				offset = reader.ReadInt32();
 				length = reader.ReadInt32();
 				fixedname = reader.ReadBytes(8);
 
 				// Create the lump
 				lumps.Add(new Lump(file, this, fixedname, offset, length));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ButtonsNumericTextbox.Designer.cs" startline="22" endline="72">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.buttons = new System.Windows.Forms.VScrollBar();
 			this.textbox = new CodeImp.DoomBuilder.Controls.NumericTextbox();
 			this.SuspendLayout();
 			// 
 			// buttons
 			// 
 			this.buttons.LargeChange = 10000;
 			this.buttons.Location = new System.Drawing.Point(163, 0);
 			this.buttons.Maximum = 10000;
 			this.buttons.Minimum = -10000;
 			this.buttons.Name = "buttons";
 			this.buttons.Size = new System.Drawing.Size(18, 24);
 			this.buttons.TabIndex = 1;
 			this.buttons.ValueChanged += new System.EventHandler(this.buttons_ValueChanged);
 			// 
 			// textbox
 			// 
 			this.textbox.AllowDecimal = false;
 			this.textbox.AllowNegative = false;
 			this.textbox.AllowRelative = false;
 			this.textbox.ImeMode = System.Windows.Forms.ImeMode.Off;
 			this.textbox.Location = new System.Drawing.Point(0, 2);
 			this.textbox.Name = "textbox";
 			this.textbox.Size = new System.Drawing.Size(160, 20);
 			this.textbox.TabIndex = 0;
 			this.textbox.TextChanged += new System.EventHandler(this.textbox_TextChanged);
 			this.textbox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.textbox_KeyDown);
 			// 
 			// ButtonsNumericTextbox
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.buttons);
 			this.Controls.Add(this.textbox);
 			this.Name = "ButtonsNumericTextbox";
 			this.Size = new System.Drawing.Size(289, 68);
 			this.Layout += new System.Windows.Forms.LayoutEventHandler(this.ClickableNumericTextbox_Layout);
 			this.Resize += new System.EventHandler(this.ClickableNumericTextbox_Resize);
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2324" endline="2359">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Info Panels
 
 		// This toggles the panel expanded / collapsed
 		[BeginAction("toggleinfopanel")]
 		internal void ToggleInfoPanel()
 		{
 			if(IsInfoPanelExpanded)
 			{
 				panelinfo.Height = buttontoggleinfo.Height + buttontoggleinfo.Top;
 				buttontoggleinfo.Text = "5";	// Arrow up
 				if(linedefinfo.Visible) linedefinfo.Hide();
 				if(vertexinfo.Visible) vertexinfo.Hide();
 				if(sectorinfo.Visible) sectorinfo.Hide();
 				if(thinginfo.Visible) thinginfo.Hide();
 				modename.Visible = false;
 				labelcollapsedinfo.Visible = true;
 				itemtoggleinfo.Checked = false;
 			}
 			else
 			{
 				panelinfo.Height = heightpanel1.Height;
 				buttontoggleinfo.Text = "6";	// Arrow down
 				labelcollapsedinfo.Visible = false;
 				itemtoggleinfo.Checked = true;
 				if(lastinfoobject is Vertex) ShowVertexInfo(lastinfoobject as Vertex);
 				else if(lastinfoobject is Linedef) ShowLinedefInfo(lastinfoobject as Linedef);
 				else if(lastinfoobject is Sector) ShowSectorInfo(lastinfoobject as Sector);
 				else if(lastinfoobject is Thing) ShowThingInfo(lastinfoobject as Thing);
 				else HideInfo();
 			}
 
 			FocusDisplay();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ButtonsNumericTextbox.cs" startline="108" endline="145">
<![CDATA[
 		
 		// Buttons changed
 		private void buttons_ValueChanged(object sender, EventArgs e)
 		{
 			if(!ignorebuttonchange)
 			{
 				ignorebuttonchange = true;
 				if(!textbox.CheckIsRelative())
 				{
 					if(steps != null)
 					{
 						if(buttons.Value < 0)
 							textbox.Text = steps.GetNextHigher(textbox.GetResult(0)).ToString();
 						else if(buttons.Value > 0)
 							textbox.Text = steps.GetNextLower(textbox.GetResult(0)).ToString();
 					}
 					else if(textbox.AllowDecimal)
 					{
 						float newvalue = textbox.GetResultFloat(0.0f) - (float)(buttons.Value * stepsize);
 						if((newvalue < 0.0f) && !textbox.AllowNegative) newvalue = 0.0f;
 						textbox.Text = newvalue.ToString();
 					}
 					else
 					{
 						int newvalue = textbox.GetResult(0) - (buttons.Value * stepsize);
 						if((newvalue < 0) && !textbox.AllowNegative) newvalue = 0;
 						textbox.Text = newvalue.ToString();
 					}
 				}
 				
 				buttons.Value = 0;
 				
 				if(WhenButtonsClicked != null)
 					WhenButtonsClicked(this, EventArgs.Empty);
 				
 				ignorebuttonchange = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\World3DShader.cs" startline="117" endline="152">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This sets the constant settings
 		public void SetConstants(bool bilinear, bool useanisotropic, float maxanisotropy)
 		{
 			if(manager.Enabled)
 			{
 				if(bilinear)
 				{
 					if(useanisotropic)
 					{
 						effect.SetValue(magfiltersettings, (int)TextureFilter.Linear);
 						effect.SetValue(minfiltersettings, (int)TextureFilter.Anisotropic);
 						effect.SetValue(mipfiltersettings, (int)TextureFilter.Linear);
 						effect.SetValue(maxanisotropysetting, maxanisotropy);
 					}
 					else
 					{
 						effect.SetValue(magfiltersettings, (int)TextureFilter.Linear);
 						effect.SetValue(minfiltersettings, (int)TextureFilter.Linear);
 						effect.SetValue(mipfiltersettings, (int)TextureFilter.Linear);
 						effect.SetValue(maxanisotropysetting, 1.0f);
 					}
 				}
 				else
 				{
 					effect.SetValue(magfiltersettings, (int)TextureFilter.Point);
 					effect.SetValue(minfiltersettings, (int)TextureFilter.Point);
 					effect.SetValue(mipfiltersettings, (int)TextureFilter.Linear);
 					effect.SetValue(maxanisotropysetting, 1.0f);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\OpenMapOptionsForm.cs" startline="383" endline="389">
<![CDATA[
 
 		// Map name doubleclicked
 		private void mapslist_DoubleClick(object sender, EventArgs e)
 		{
 			// Click OK
 			if(mapslist.SelectedItems.Count > 0) apply.PerformClick();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapOptions.cs" startline="228" endline="250">
<![CDATA[
 		
 		// This adds a resource location and returns the index where the item was added
 		internal int AddResource(DataLocation res)
 		{
 			// Get a fully qualified path
 			res.location = Path.GetFullPath(res.location);
 			
 			// Go for all items in the list
 			for(int i = 0; i < resources.Count; i++)
 			{
 				// Check if location is already added
 				if(Path.GetFullPath(resources[i].location) == res.location)
 				{
 					// Update the item in the list
 					resources[i] = res;
 					return i;
 				}
 			}
 			for(int i = 0; i < resources.Count; i++)
 			{
 				// Check if location is already added
 				if(Path.GetFullPath(resources[i].location) == res.location)
 				{
 					// Update the item in the list
 					resources[i] = res;
 					return i;
 				}
 			}
 
 			// Add to list
 			resources.Add(res);
 			return resources.Count - 1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="125" endline="146">
<![CDATA[
 		
 		// This sets up the controls for left or right alignment
 		public void Setup(bool right)
 		{
 			rightalign = right;
 			if(rightalign)
 			{
 				splitter.Dock = DockStyle.Left;
 				tabs.Alignment = TabAlignment.Right;
 				tabs.Location = new Point(0, 0);
 				tabs.Size = new Size(this.ClientRectangle.Width + 2, this.ClientRectangle.Height);
 			}
 			else
 			{
 				splitter.Dock = DockStyle.Right;
 				tabs.Alignment = TabAlignment.Left;
 				tabs.Location = new Point(-2, 0);
 				tabs.Size = new Size(this.ClientRectangle.Width + 2, this.ClientRectangle.Height);
 			}
 			
 			tabs.SendToBack();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2402" endline="2431">
<![CDATA[
 		
 		// Show linedef info
 		public void ShowLinedefInfo(Linedef l)
 		{
 			if(l.IsDisposed)
 			{
 				HideInfo();
 				return;
 			}
 			
 			lastinfoobject = l;
 			modename.Visible = false;
 			if(vertexinfo.Visible) vertexinfo.Hide();
 			if(sectorinfo.Visible) sectorinfo.Hide();
 			if(thinginfo.Visible) thinginfo.Hide();
 			if(IsInfoPanelExpanded) linedefinfo.ShowInfo(l);
 
 			// Show info on collapsed label
 			if(General.Map.Config.LinedefActions.ContainsKey(l.Action))
 			{
 				LinedefActionInfo act = General.Map.Config.LinedefActions[l.Action];
 				labelcollapsedinfo.Text = act.ToString();
 			}
 			else if(l.Action == 0)
 				labelcollapsedinfo.Text = l.Action.ToString() + " - None";
 			else
 				labelcollapsedinfo.Text = l.Action.ToString() + " - Unknown";
 			
 			labelcollapsedinfo.Refresh();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="653" endline="723">
<![CDATA[
 		public void DisplayStatus(StatusInfo newstatus)
 		{
 			// Stop timers
 			if(!newstatus.displayed)
 			{
 				statusresetter.Stop();
 				statusflasher.Stop();
 				statusflashicon = false;
 			}
 			
 			// Determine what to do specifically for this status type
 			switch(newstatus.type)
 			{
 				// When no particular information is to be displayed.
 				// The messages displayed depends on running background processes.
 				case StatusType.Ready
 					if((General.Map != null) && (General.Map.Data != null) && General.Map.Data.IsLoading)
 						newstatus.message = STATUS_LOADING_TEXT;
 					else
 						newstatus.message = STATUS_READY_TEXT;
 					break;
 
 				// Shows information without flashing the icon.
 				case StatusType.Info
 					if(!newstatus.displayed)
 					{
 						statusresetter.Interval = INFO_RESET_DELAY;
 						statusresetter.Start();
 					}
 					break;
 					
 				// Shows action information and flashes up the status icon once.	
 				case StatusType.Action
 					if(!newstatus.displayed)
 					{
 						statusflashicon = true;
 						statusflasher.Interval = ACTION_FLASH_INTERVAL;
 						statusflashcount = ACTION_FLASH_COUNT;
 						statusflasher.Start();
 						statusresetter.Interval = ACTION_RESET_DELAY;
 						statusresetter.Start();
 					}
 					break;
 					
 				// Shows a warning, makes a warning sound and flashes a warning icon.
 				case StatusType.Warning
 					if(!newstatus.displayed)
 					{
 						MessageBeep(MessageBeepType.Warning);
 						statusflasher.Interval = WARNING_FLASH_INTERVAL;
 						statusflashcount = WARNING_FLASH_COUNT;
 						statusflasher.Start();
 						statusresetter.Interval = WARNING_RESET_DELAY;
 						statusresetter.Start();
 					}
 					break;
 			}
 			
 			// Update status description
 			status = newstatus;
 			status.displayed = true;
 			if(statuslabel.Text != status.message)
 				statuslabel.Text = status.message;
 			
 			// Update icon as well
 			UpdateStatusIcon();
 			
 			// Refresh
 			statusbar.Invalidate();
 			this.Update();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="438" endline="496">
<![CDATA[
 
 		// This fills the list based on the objectname filter
 		private void RefillList(bool selectfirst)
 		{
 			visibleitems = new List<ImageBrowserItem>();
 			
 			// Begin updating list
 			updating = true;
 			//list.SuspendLayout();
 			list.BeginUpdate();
 			
 			// Clear list first
 			// Group property of items will be set to null, we will restore it later
 			list.Items.Clear();
 			
 			// Go for all items
 			foreach(ImageBrowserItem i in items)
 			{
 				// Add item if valid
 				if(ValidateItem(i))
 				{
 					i.Group = i.ListGroup;
 					i.Selected = false;
 					visibleitems.Add(i);
 				}
 			}
 			foreach(ImageBrowserItem i in items)
 			{
 				// Add item if valid
 				if(ValidateItem(i))
 				{
 					i.Group = i.ListGroup;
 					i.Selected = false;
 					visibleitems.Add(i);
 				}
 			}
 			
 			// Fill list
 			visibleitems.Sort();
 			ListViewItem[] array = new ListViewItem[visibleitems.Count];
 			for(int i = 0; i < visibleitems.Count; i++) array[i] = visibleitems[i];
 			list.Items.AddRange(array);
 			
 			// Done updating list
 			updating = false;
 			list.EndUpdate();
 			list.Invalidate();
 			//list.ResumeLayout();
 			
 			// Make selection?
 			if(!preventselection && (list.Items.Count > 0))
 			{
 				// Select specific item?
 				if(keepselected > -1)
 				{
 					list.Items[keepselected].Selected = true;
 					list.Items[keepselected].EnsureVisible();
 				}
 				// Select first item?
 				else if(selectfirst)
 				{
 					SelectFirstItem();
 				}
 			}
 			
 			// Raise event
 			if((SelectedItemChanged != null) && !preventselection) SelectedItemChanged();
 			UpdateTextureSizeLabel();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\SerializerStream.cs" startline="124" endline="130">
<![CDATA[
 
 		public void rwVector3D(ref Vector3D v)
 		{
 			writer.Write(v.x);
 			writer.Write(v.y);
 			writer.Write(v.z);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ErrorsForm.cs" startline="8" endline="52">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ErrorsForm()
 		{
 			InitializeComponent();
 			FillList();
 			checkerrors.Start();
 			checkshow.Checked = General.Settings.ShowErrorsWindow;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="691" endline="707">
<![CDATA[
 
         /// <summary>
         /// This is called automatically when the mouse is moved while panning
         /// </summary>
         protected virtual void OnUpdateViewPanning()
         {
 			// We can only drag the map when the mouse pointer is inside
 			// otherwise we don't have coordinates where to drag the map to
 			if(mouseinside && !float.IsNaN(mouselastpos.x) && !float.IsNaN(mouselastpos.y))
 			{
 				// Get the map coordinates of the last mouse posision (before it moved)
 				Vector2D lastmappos = renderer2d.DisplayToMap(mouselastpos);
 				
 				// Do the scroll
 				ScrollBy(lastmappos.x - mousemappos.x, lastmappos.y - mousemappos.y);
 			}
         }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorRow.cs" startline="141" endline="175">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 		
 		// Browse for value
 		public void Browse(IWin32Window parent)
 		{
 			if(fieldtype != null)
 			{
 				// Browse for value
 				fieldtype.Browse(parent);
 
 				// This is a fixed field?
 				if(isfixed)
 				{
 					// Does this match the default setting?
 					if(fieldtype.GetValue().Equals(fieldinfo.Default))
 					{
 						// Undefine this field!
 						Undefine();
 					}
 					else
 					{
 						// Define
 						Define(fieldtype.GetValue());
 					}
 				}
 				else
 				{
 					// Define
 					Define(fieldtype.GetValue());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\Plug.cs" startline="38" endline="84">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 		
 		#region ================== Properties
 		
 		// Internals
 		internal Plugin Plugin { get { return plugin; } set { plugin = value; } }
 		
 		/// <summary>
 		/// Indicates if the plugin has been disposed.
 		/// </summary>
 		public bool IsDisposed { get { return isdisposed; } }
 		
 		/// <summary>
 		/// Override this to return a more descriptive name for your plugin.
 		/// Default is the library filename without extension.
 		/// </summary>
 		public virtual string Name { get { return plugin.Name; } }
 
 		/// <summary>
 		/// Override this to return the minimum revision of the Doom Builder 2 core that is
 		/// required to use this plugin. You can find the revision number in the About dialog,
 		/// it is the right most part of the version number.
 		/// </summary>
 		public virtual int MinimumRevision { get { return 0; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		/// <summary>
 		/// This is the key link between the Doom Builder core and the plugin.
 		/// Every plugin must expose a single class that inherits this class.
 		/// <para>
 		/// NOTE
 		/// is not yet fully initialized. Instead, use the Initialize method to do
 		/// your initializations.
 		/// </para>
 		/// </summary>
 		public Plug()
 		{
 			// Initialize
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\CRC.cs" startline="47" endline="59">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public CRC()
 		{
 			crc = new Crc32();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="681" endline="689">
<![CDATA[
 
 		// Scrolling
 		private void fieldslist_Scroll(object sender, ScrollEventArgs e)
 		{
 			// Stop any cell editing
 			ApplyEnums(true);
 			fieldslist.EndEdit();
 			HideBrowseButton();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\Launcher.cs" startline="54" endline="67">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Destructor
 
 		// Constructor
 		public Launcher(MapManager manager)
 		{
 			// Initialize
 			CleanTempFile(manager);
 
 			// Bind actions
 			General.Actions.BindMethods(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\BlockMap.cs" startline="68" endline="77">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		public BlockMap(RectangleF range)
 		{
 			Initialize(range, 128);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1432" endline="1443">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Debug
 		
 		// This shows a major failure
 		public static void Fail(string message)
 		{
 			General.WriteLogLine("FAIL
 			Debug.Fail(message);
 			Terminate(false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="584" endline="598">
<![CDATA[
 		
 		// When new script is clicked
 		private void buttonnew_Click(object sender, EventArgs e)
 		{
 			// Get the script config to use
 			ScriptConfiguration scriptconfig = ((sender as ToolStripMenuItem).Tag as ScriptConfiguration);
 			
 			// Create new document
 			ScriptFileDocumentTab t = new ScriptFileDocumentTab(this, scriptconfig);
 			tabs.TabPages.Add(t);
 			tabs.SelectedTab = t;
 			
 			// Done
 			UpdateToolbar(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="244" endline="254">
<![CDATA[
 
 		// Nodebuilder selection changed
 		private void nodebuildersave_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			// Leave when no configuration selected
 			if(configinfo == null) return;
 			
 			// Apply to selected configuration
 			if(nodebuildersave.SelectedItem != null)
 				configinfo.NodebuilderSave = (nodebuildersave.SelectedItem as NodebuilderInfo).Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="255" endline="265">
<![CDATA[
 
 		// Nodebuilder selection changed
 		private void nodebuildertest_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			// Leave when no configuration selected
 			if(configinfo == null) return;
 
 			// Apply to selected configuration
 			if(nodebuildertest.SelectedItem != null)
 				configinfo.NodebuilderTest = (nodebuildertest.SelectedItem as NodebuilderInfo).Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ColorControl.cs" startline="60" endline="72">
<![CDATA[
 
 		// Resized
 		private void ColorControl_Resize(object sender, EventArgs e)
 		{
 			try
 			{
 				button.Left = ClientSize.Width - button.Width;
 				panel.Left = ClientSize.Width - button.Width - panel.Width - 3;
 				label.Left = 0;
 				label.Width = panel.Left;
 			}
 			catch(Exception) { }
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="787" endline="804">
<![CDATA[
 		
 		// This collects a visual sector's geometry for rendering
 		public void AddSectorGeometry(VisualGeometry g)
 		{
 			// Must have a texture and vertices
 			if((g.Texture != null) && (g.Triangles > 0))
 			{
 				// Texture group not yet collected?
 				if(!geometry[g.RenderPassInt].ContainsKey(g.Texture))
 				{
 					// Create texture group
 					geometry[g.RenderPassInt].Add(g.Texture, new BinaryHeap<VisualGeometry>());
 				}
 				
 				// Add geometry to texture group
 				geometry[g.RenderPassInt][g.Texture].Add(g);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="805" endline="826">
<![CDATA[
 
 		// This collects a visual sector's geometry for rendering
 		public void AddThingGeometry(VisualThing t)
 		{
 			// Make sure the distance to camera is calculated
 			t.CalculateCameraDistance(cameraposition);
 			thingsbydistance.Add(t);
 			
 			// Must have a texture!
 			if(t.Texture != null)
 			{
 				// Texture group not yet collected?
 				if(!things[t.RenderPassInt].ContainsKey(t.Texture))
 				{
 					// Create texture group
 					things[t.RenderPassInt].Add(t.Texture, new List<VisualThing>());
 				}
 
 				// Add geometry to texture group
 				things[t.RenderPassInt][t.Texture].Add(t);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="182" endline="192">
<![CDATA[
 		
 		// This unloads the image
 		public virtual void UnloadImage()
 		{
 			lock(this)
 			{
 				if(bitmap != null) bitmap.Dispose();
 				bitmap = null;
 				imagestate = ImageLoadState.None;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="690" endline="700">
<![CDATA[
 
 		// Mouse up event
 		private void fieldslist_MouseUp(object sender, MouseEventArgs e)
 		{
 			// Focus to enums combobox when visible
 			if(enumscombo.Visible)
 			{
 				enumscombo.Focus();
 				enumscombo.SelectAll();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1254" endline="1274">
<![CDATA[
 		
 		// Close the script editor
 		// Specify true for the closing parameter when
 		// the window is already in the closing process
 		internal void CloseScriptEditor(bool closing)
 		{
 			if(scriptwindow != null)
 			{
 				if(!scriptwindow.IsDisposed)
 				{
 					// Remember what files were open
 					scriptwindow.Editor.WriteOpenFilesToConfiguration();
 					
 					// Close now
 					if(!closing) scriptwindow.Close();
 				}
 				
 				// Done
 				scriptwindow = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="445" endline="466">
<![CDATA[
 		
 		// This joins the sector with another sector
 		// This sector will be disposed
 		public void Join(Sector other)
 		{
 			// Any sidedefs to move?
 			if(sidedefs.Count > 0)
 			{
 				// Change secter reference on my sidedefs
 				// This automatically disposes this sector
 				while(sidedefs != null)
 					sidedefs.First.Value.SetSector(other);
 				while(sidedefs != null)
 					sidedefs.First.Value.SetSector(other);
 			}
 			else
 			{
 				// No sidedefs attached
 				// Dispose manually
 				this.Dispose();
 			}
 			
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1129" endline="1145">
<![CDATA[
 
 		// This is a tool to unlock the mouse
 		private void StopMouseExclusive()
 		{
 			// Locked?
 			if(mouseinput != null)
 			{
 				// Stop special input device
 				mouseinput.Dispose();
 				mouseinput = null;
 
 				// Release and show the mouse
 				Cursor.Clip = originalclip;
 				Cursor.Position = display.PointToScreen(new Point(display.ClientSize.Width / 2, display.ClientSize.Height / 2));
 				Cursor.Show();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="391" endline="404">
<![CDATA[
 		
 		// This creates a checksum from the sidedef properties
 		// Used for faster sidedefs compression
 		public uint GetChecksum()
 		{
 			CRC crc = new CRC();
 			crc.Add(sector.FixedIndex);
 			crc.Add(offsetx);
 			crc.Add(offsety);
 			crc.Add(longtexnamehigh);
 			crc.Add(longtexnamelow);
 			crc.Add(longtexnamemid);
 			return (uint)(crc.Value & 0x00000000FFFFFFFF);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="368" endline="377">
<![CDATA[
 		
 		// This applies the matrices
 		private void ApplyMatrices3D()
 		{
 			worldviewproj = world * view3d * projection;
 			graphics.Shaders.World3D.WorldViewProj = worldviewproj;
 			graphics.Device.SetTransform(TransformState.World, world);
 			graphics.Device.SetTransform(TransformState.Projection, projection);
 			graphics.Device.SetTransform(TransformState.View, view3d);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptFindReplaceForm.cs" startline="8" endline="52">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ScriptFindReplaceForm()
 		{
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\AngleForm.cs" startline="8" endline="58">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public AngleForm()
 		{
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\VertexInfoPanel.cs" startline="8" endline="41">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public VertexInfoPanel()
 		{
 			// Initialize
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\CustomFieldsForm.cs" startline="8" endline="51">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public CustomFieldsForm()
 		{
 			// Initialize
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\PasteOptionsControl.cs" startline="8" endline="50">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public PasteOptionsControl()
 		{
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\SectorInfoPanel.cs" startline="8" endline="41">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public SectorInfoPanel()
 		{
 			// Initialize
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\BitFlagsForm.cs" startline="8" endline="59">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public BitFlagsForm()
 		{
 			// Initialize
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ColorControl.cs" startline="8" endline="40">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ColorControl()
 		{
 			// Initialize
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlagsForm.cs" startline="8" endline="34">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public FlagsForm()
 		{
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="8" endline="68">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ImageSelectorControl()
 		{
 			// Initialize
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingBrowserControl.cs" startline="8" endline="75">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ThingBrowserControl()
 		{
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="8" endline="70">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ScriptEditorPanel()
 		{
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextEditForm.cs" startline="11" endline="47">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public TextEditForm()
 		{
 			// Initialize
 			InitializeComponent();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="221" endline="231">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Input
 
 		// Mouse input
 		public override void OnMouseInput(Vector2D delta)
 		{
 			base.OnMouseInput(delta);
 			General.Map.VisualCamera.ProcessMouseInput(delta);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptEditorForm.cs" startline="8" endline="60">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ScriptEditorForm()
 		{
 			InitializeComponent();
 			editor.Initialize();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="231" endline="238">
<![CDATA[
 
 		// This hides the texture size label
 		private void texturesizetimer_Tick(object sender, EventArgs e)
 		{
 			texturesizetimer.Stop();
 			texturesize.Visible = false;
 			texturesizelabel.Visible = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="872" endline="884">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Display
 
 		// This shows the splash screen on display
 		internal void ShowSplashDisplay()
 		{
 			// Change display to show splash logo
 			display.SetSplashLogoDisplay();
 			display.Cursor = Cursors.Default;
 			this.Update();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\PixelColorBlock.cs" startline="70" endline="78">
<![CDATA[
 
 		// Destructor
 		~PixelColorBlock()
 		{
 			// Terminate
 			Marshal.FreeCoTaskMem(new IntPtr(memory));
 			GC.RemoveMemoryPressure(memorysize);
 			memorysize = 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\DelayedForm.cs" startline="59" endline="72">
<![CDATA[
 
 		// When the form is to be shown
 		private void formshowtimer_Tick(object sender, EventArgs e)
 		{
 			// Get rid of the timer
 			formshowtimer.Dispose();
 			formshowtimer = null;
 			
 			if(!this.IsDisposed)
 			{
 				// Make the form visible
 				this.Opacity = 100;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DirectoryReader.cs" startline="45" endline="55">
<![CDATA[
 		public DirectoryReader(DataLocation dl) 
 		{
 			General.WriteLogLine("Opening directory resource '" + location.location + "'");
 			
 			// Initialize
 			files = new DirectoryFilesList(dl.location, true);
 			Initialize();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingBrowserControl.cs" startline="103" endline="114">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Methods
 
 		// Select a type
 		public void SelectType(int type)
 		{
 			// Set type index
 			typeid.Text = type.ToString();
 			typeid_TextChanged(this, EventArgs.Empty);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="562" endline="573">
<![CDATA[
 
 		// This removes a previously made undo
 		public void WithdrawUndo()
 		{
 			// Previously, withdrawing an undo level was possible, because each undo level contained
 			// an entire snapshot of the map. With the new progressive undo system, you cannot ignore
 			// any changes, so we have to actually perform the undo and trash the redo it creates.
 			PerformUndo(1, false);
 			ClearAllRedos();
 			
 			General.Plugins.OnUndoWithdrawn();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1154" endline="1168">
<![CDATA[
 		
 		// This selects a group
 		private void SelectGroup(int groupindex)
 		{
 			// Select
 			int groupmask = 0x01 << groupindex;
 			map.SelectVerticesByGroup(groupmask);
 			map.SelectLinedefsByGroup(groupmask);
 			map.SelectSectorsByGroup(groupmask);
 			map.SelectThingsByGroup(groupmask);
 			
 			// Redraw to show selection
 			General.Interface.DisplayStatus(StatusType.Action, "Selected group " + groupindex);
 			General.Interface.RedrawDisplay();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Things2DShader.cs" startline="101" endline="117">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This sets the settings
 		public void SetSettings(float alpha)
 		{
 			if(manager.Enabled)
 			{
 				Vector4 values = new Vector4(0.0f, 0.0f, 1.0f, alpha);
 				effect.SetValue(rendersettings, values);
 				Matrix world = manager.D3DDevice.Device.GetTransform(TransformState.World);
 				Matrix view = manager.D3DDevice.Device.GetTransform(TransformState.View);
 				effect.SetValue(transformsettings, Matrix.Multiply(world, view));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="666" endline="700">
<![CDATA[
 
 		// Special key selected
 		private void actioncontrol_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			KeyControl key;
 
 			// Leave when not allowed to update
 			if(!allowapplycontrol) return;
 
 			// Anything selected?
 			if((actioncontrol.SelectedIndex > -1) && (listactions.SelectedItems.Count > 0))
 			{
 				// Begin updating
 				allowapplycontrol = false;
 
 				// Remove text from textbox
 				actionkey.Text = "";
 
 				// Get the key control
 				key = (KeyControl)actioncontrol.SelectedItem;
 
 				// Apply the key combination
 				listactions.SelectedItems[0].SubItems[1].Text = Actions.Action.GetShortcutKeyDesc(key.key);
 				listactions.SelectedItems[0].SubItems[1].Tag = key.key;
 				
 				// Show actions with same key
 				UpdateKeyUsedActions();
 				
 				// Focus to the input box
 				actionkey.Focus();
 
 				// Done
 				allowapplycontrol = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypesManager.cs" startline="86" endline="99">
<![CDATA[
 
 		// Disposer
 		public void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				handlertypes.Clear();
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="358" endline="370">
<![CDATA[
 
 		// This moves the thing
 		// NOTE
 		public void Move(Vector2D newpos)
 		{
 			BeforePropsChange();
 			
 			// Change position
 			this.pos = new Vector3D(newpos.x, newpos.y, pos.z);
 			
 			if(type != General.Map.Config.Start3DModeThingType)
 				General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.cs" startline="212" endline="222">
<![CDATA[
 		
 		// Texture doubleclicked
 		private void matcheslist_SelectedItemDoubleClicked()
 		{
 			// Add texture name to the list
 			if(matcheslist.SelectedItem != null)
 				filters.Items.Add(matcheslist.SelectedItem.Text);
 			
 			// Run the timer
 			filterstimer.Start();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="579" endline="593">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 
 		/// <summary>
 		/// Automatically called by the core when this editing mode is engaged.
 		/// </summary>
 		public override void OnEngage()
 		{
 			// Clear display overlay
 			renderer.StartOverlay(true);
 			renderer.Finish();
 			base.OnEngage();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptDocumentTab.cs" startline="285" endline="295">
<![CDATA[
 		
 		// This returns the selected text
 		public string GetSelectedText()
 		{
 			byte[] data = editor.GetText();
 			string text = Encoding.GetEncoding(config.CodePage).GetString(data);
 			if(editor.SelectionStart < editor.SelectionEnd)
 				return text.Substring(editor.SelectionStart, editor.SelectionEnd - editor.SelectionStart);
 			else
 				return "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="341" endline="357">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Changes
 
 		// This moves the thing
 		// NOTE
 		public void Move(Vector3D newpos)
 		{
 			BeforePropsChange();
 			
 			// Change position
 			this.pos = newpos;
 			
 			if(type != General.Map.Config.Start3DModeThingType)
 				General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\DelayedForm.cs" startline="42" endline="48">
<![CDATA[
 		public DelayedForm()
 		{
 			// Create a timer that we need to show the form
 			formshowtimer = new Timer();
 			formshowtimer.Interval = 1;
 			formshowtimer.Tick += new EventHandler(formshowtimer_Tick);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1500" endline="1509">
<![CDATA[
 
 		// This renders a single vertex
 		public void PlotVertex(Vertex v, int colorindex)
 		{
 			// Transform vertex coordinates
 			Vector2D nv = v.Position.GetTransformed(translatex, translatey, scale, -scale);
 
 			// Draw pixel here
 			plotter.DrawVertexSolid((int)nv.x, (int)nv.y, vertexsize, ref General.Colors.Colors[colorindex], ref General.Colors.BrightColors[colorindex], ref General.Colors.DarkColors[colorindex]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="149" endline="160">
<![CDATA[
 
 		#endregion
 
 		#region ================== Scroll / Zoom
 
 		// This scrolls the view north
 		[BeginAction("scrollnorth", BaseAction = true)]
 		public virtual void ScrollNorth()
 		{
 			// Scroll
 			ScrollBy(0f, 100f / renderer2d.Scale);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="161" endline="168">
<![CDATA[
 
 		// This scrolls the view south
 		[BeginAction("scrollsouth", BaseAction = true)]
 		public virtual void ScrollSouth()
 		{
 			// Scroll
 			ScrollBy(0f, -100f / renderer2d.Scale);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="169" endline="176">
<![CDATA[
 
 		// This scrolls the view west
 		[BeginAction("scrollwest", BaseAction = true)]
 		public virtual void ScrollWest()
 		{
 			// Scroll
 			ScrollBy(-100f / renderer2d.Scale, 0f);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="177" endline="184">
<![CDATA[
 
 		// This scrolls the view east
 		[BeginAction("scrolleast", BaseAction = true)]
 		public virtual void ScrollEast()
 		{
 			// Scroll
 			ScrollBy(100f / renderer2d.Scale, 0f);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="268" endline="277">
<![CDATA[
 		
 		// This closed the Find & Replace subwindow
 		public void CloseFindReplace(bool closing)
 		{
 			if(findreplaceform != null)
 			{
 				if(!closing) findreplaceform.Close();
 				findreplaceform = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="635" endline="643">
<![CDATA[
 		
 		// This flashes the status icon
 		private void statusflasher_Tick(object sender, EventArgs e)
 		{
 			statusflashicon = !statusflashicon;
 			UpdateStatusIcon();
 			statusflashcount--;
 			if(statusflashcount == 0) statusflasher.Stop();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="701" endline="721">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Private Methods
 
 		// This applies a value to a row
 		private void ApplyValue(FieldsEditorRow frow, object value)
 		{
 			// Defined?
 			if((value != null) && (!frow.IsFixed || !frow.Info.Default.Equals(value)))
 			{
 				frow.Define(value);
 			}
 			else if(frow.IsFixed)
 			{
 				frow.Undefine();
 			}
 			
 			if(OnFieldValueChanged != null)
 				OnFieldValueChanged(frow.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="635" endline="664">
<![CDATA[
 
 		// This is called by Save and Save All to save a script
 		// Returns false when cancelled by the user
 		private bool SaveScript(ScriptDocumentTab t)
 		{
 			// Do we have to do a save as?
 			if(t.IsSaveAsRequired)
 			{
 				// Setup save dialog
 				string scriptfilter = t.Config.Description + "|*." + string.Join(";*.", t.Config.Extensions);
 				savefile.Filter = scriptfilter + "|All files|*.*";
 				if(savefile.ShowDialog(this.ParentForm) == DialogResult.OK)
 				{
 					// Save to new filename
 					t.SaveAs(savefile.FileName);
 					return true;
 				}
 				else
 				{
 					// Cancelled
 					return false;
 				}
 			}
 			else
 			{
 				// Save to same filename
 				t.Save();
 				return true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptLumpDocumentTab.cs" startline="118" endline="127">
<![CDATA[
 		
 		// Implicit save
 		public override bool Save()
 		{
 			// Store the lump data
 			MemoryStream stream = new MemoryStream(editor.GetText());
 			General.Map.SetLumpData(lumpname, stream);
 			editor.IsChanged = false;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TanColorTable.cs" startline="273" endline="285">
<![CDATA[
 		}
 
 		private Dictionary<KnownColors, Color> ColorTable
 		{
 			get
 			{
 				if(this.tanRGB == null)
 				{
 					this.tanRGB = new Dictionary<KnownColors, Color>((int)KnownColors.LastKnownColor);
 					TanColorTable.InitTanLunaColors(ref this.tanRGB);
 				}
 				return this.tanRGB;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ProgramConfiguration.cs" startline="449" endline="456">
<![CDATA[
 
 		// This applies default settings to a thing
 		public void ApplyDefaultThingSettings(Thing t)
 		{
 			t.Type = defaultthingtype;
 			t.Rotate(defaultthingangle);
 			foreach(string f in defaultthingflags) t.SetFlag(f, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="223" endline="236">
<![CDATA[
 
 		// This sets the linedef
 		public void SetLinedef(Linedef ld, bool front)
 		{
 			if(linedef != null) linedef.DetachSidedefP(this);
 			
 			if(ld != null)
 			{
 				if(front)
 					ld.AttachFront(this);
 				else
 					ld.AttachBack(this);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ResourceImage.cs" startline="73" endline="97">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			Stream bitmapdata;
 
 			lock(this)
 			{
 				// No failure checking here. I anything fails here, it is not the user's fault,
 				// because the resources this loads are in the assembly.
 				
 				// Get resource from memory
 				bitmapdata = assembly.GetManifestResourceStream(resourcename);
 				if(bitmap != null) bitmap.Dispose();
 				bitmap = (Bitmap)Image.FromStream(bitmapdata);
 				bitmapdata.Dispose();
 				
 				// Pass on to base
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Things2DShader.cs" startline="85" endline="100">
<![CDATA[
 
 		// Disposer
 		public override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				if(texture1 != null) texture1.Dispose();
 				if(rendersettings != null) rendersettings.Dispose();
 				if(transformsettings != null) transformsettings.Dispose();
 
 				// Done
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="339" endline="353">
<![CDATA[
 
 		// Cell clicked
 		private void fieldslist_CellClick(object sender, DataGridViewCellEventArgs e)
 		{
 			ApplyEnums(true);
 
 			// Anything selected
 			if(fieldslist.SelectedCells.Count > 0)
 			{
 				if(e.RowIndex == fieldslist.NewRowIndex)
 					fieldslist.BeginEdit(false);
 				else if(e.ColumnIndex > 0)
 					fieldslist.BeginEdit(true);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="363" endline="385">
<![CDATA[
 		
 		// This selectes the first item
 		private void SelectFirstItem()
 		{
 			ListViewItem lvi;
 			
 			// Not when selecting is prevented
 			if(preventselection) return;
 			
 			// Select first
 			if(list.Items.Count > 0)
 			{
 				list.SelectedItems.Clear();
 				lvi = list.GetItemAt(list.TileSize.Width / 2, list.TileSize.Height / 2);
 				if(lvi != null)
 				{
 					lvi.Selected = true;
 					lvi.EnsureVisible();
 				}
 			}
 
 			UpdateTextureSizeLabel();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1909" endline="1929">
<![CDATA[
 		
 		#endregion
 
 		#region ================== File Menu
 
 		// This sets up the file menu
 		private void UpdateFileMenu()
 		{
 			// Enable/disable items
 			itemclosemap.Enabled = (General.Map != null);
 			itemsavemap.Enabled = (General.Map != null);
 			itemsavemapas.Enabled = (General.Map != null);
 			itemsavemapinto.Enabled = (General.Map != null);
 			itemtestmap.Enabled = (General.Map != null);
 
 			// Toolbar icons
 			buttonnewmap.Enabled = itemnewmap.Enabled;
 			buttonopenmap.Enabled = itemopenmap.Enabled;
 			buttonsavemap.Enabled = itemsavemap.Enabled;
 			buttontest.Enabled = itemtestmap.Enabled;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1551" endline="1576">
<![CDATA[
 
 		// Removes a button
 		public void RemoveButton(ToolStripItem button)
 		{
 			// Find in the list and remove it
 			PluginToolbarButton buttoninfo = new PluginToolbarButton();
 			for(int i = 0; i < pluginbuttons.Count; i++)
 			{
 				if(pluginbuttons[i].button == button)
 				{
 					buttoninfo = pluginbuttons[i];
 					pluginbuttons.RemoveAt(i);
 					break;
 				}
 			}
 			for(int i = 0; i < pluginbuttons.Count; i++)
 			{
 				if(pluginbuttons[i].button == button)
 				{
 					buttoninfo = pluginbuttons[i];
 					pluginbuttons.RemoveAt(i);
 					break;
 				}
 			}
 
 			if(buttoninfo.button != null)
 			{
 				// Unbind visible changed event
 				if(!(button is ToolStripSeparator)) button.VisibleChanged -= buttonvisiblechangedhandler;
 
 				// Remove button from toolbar
 				toolbar.Items.Remove(button);
 				UpdateSeparators();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="446" endline="459">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Public Methods
 		
 		// This makes a list of the undo levels in order they will be undone
 		public List<UndoSnapshot> GetUndoList()
 		{
 			List<UndoSnapshot> list = new List<UndoSnapshot>(undos.Count + 1);
 			if(!isundosnapshot && (snapshot != null))
 				list.Add(snapshot);
 			list.AddRange(undos);
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="333" endline="350">
<![CDATA[
 
 		// Browse test program
 		private void browsetestprogram_Click(object sender, EventArgs e)
 		{
 			// Set initial directory
 			if(testapplication.Text.Length > 0)
 			{
 				try { testprogramdialog.InitialDirectory = Path.GetDirectoryName(testapplication.Text); }
 				catch(Exception) { }
 			}
 			
 			// Browse for test program
 			if(testprogramdialog.ShowDialog() == DialogResult.OK)
 			{
 				// Apply
 				testapplication.Text = testprogramdialog.FileName;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="290" endline="300">
<![CDATA[
 		
 		// This creates a new parameters example
 		private void CreateParametersExample()
 		{
 			// Map loaded?
 			if(General.Map != null)
 			{
 				// Make converted parameters
 				testresult.Text = General.Map.Launcher.ConvertParameters(testparameters.Text, skill.Value, shortpaths.Checked);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="766" endline="776">
<![CDATA[
 		
 		// This finishes rendering
 		public void Finish()
 		{
 			General.Plugins.OnPresentDisplayBegin();
 
 			// Done
 			graphics.FinishRendering();
 			graphics.Present();
 			highlighted = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="574" endline="583">
<![CDATA[
 		
 		// This registers an XPM image for the autocomplete list
 		private unsafe void RegisterAutoCompleteImage(ImageIndex index, byte[] imagedata)
 		{
 			// Convert to string
 			string bigstring = Encoding.UTF8.GetString(imagedata);
 			
 			// Register image
 			scriptedit.RegisterImage((int)index, bigstring);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="584" endline="593">
<![CDATA[
 
 		// This registers an XPM image for the markes list
 		private unsafe void RegisterMarkerImage(ImageIndex index, byte[] imagedata)
 		{
 			// Convert to string
 			string bigstring = Encoding.UTF8.GetString(imagedata);
 
 			// Register image
 			scriptedit.MarkerDefinePixmap((int)index, bigstring);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="194" endline="200">
<![CDATA[
 
 		public override void OnUndoEnd()
 		{
 			base.OnUndoEnd();
 			ResourcesReloadedPartial();
 			renderer.SetCrosshairBusy(false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="208" endline="214">
<![CDATA[
 
 		public override void OnRedoEnd()
 		{
 			base.OnRedoEnd();
 			ResourcesReloadedPartial();
 			renderer.SetCrosshairBusy(false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1813" endline="1826">
<![CDATA[
 		
 		// Removes a menu
 		public void RemoveMenu(ToolStripMenuItem menu)
 		{
 			// We actually have no idea in which menu this item is,
 			// so try removing from all menus and the top strip
 			menufile.DropDownItems.Remove(menu);
 			menuedit.DropDownItems.Remove(menu);
 			menuview.DropDownItems.Remove(menu);
 			menuprefabs.DropDownItems.Remove(menu);
 			menutools.DropDownItems.Remove(menu);
 			menuhelp.DropDownItems.Remove(menu);
 			menumain.Items.Remove(menu);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\LinedefEditForm.cs" startline="306" endline="313">
<![CDATA[
 		
 		// Front side (un)checked
 		private void frontside_CheckStateChanged(object sender, EventArgs e)
 		{
 			// Enable/disable panel
 			// NOTE
 			frontgroup.Enabled = (frontside.CheckState != CheckState.Unchecked);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\LinedefEditForm.cs" startline="314" endline="321">
<![CDATA[
 
 		// Back side (un)checked
 		private void backside_CheckStateChanged(object sender, EventArgs e)
 		{
 			// Enable/disable panel
 			// NOTE
 			backgroup.Enabled = (backside.CheckState != CheckState.Unchecked);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="373" endline="384">
<![CDATA[
 
 		// This unbinds a delegate manually
 		internal void UnbindBeginDelegate(Assembly asm, ActionDelegate d, BeginActionAttribute a)
 		{
 			string actionname;
 
 			// Make proper name
 			actionname = a.GetFullActionName(asm);
 
 			// Unbind delegate to action
 			actions[actionname].UnbindBegin(d);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="385" endline="396">
<![CDATA[
 
 		// This unbinds a delegate manually
 		internal void UnbindEndDelegate(Assembly asm, ActionDelegate d, EndActionAttribute a)
 		{
 			string actionname;
 
 			// Make proper name
 			actionname = a.GetFullActionName(asm);
 
 			// Unbind delegate to action
 			actions[actionname].UnbindEnd(d);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\SectorInfoPanel.cs" startline="75" endline="88">
<![CDATA[
 
 		// When visible changed
 		protected override void OnVisibleChanged(EventArgs e)
 		{
 			// Hiding panels
 			if(!this.Visible)
 			{
 				floortex.BackgroundImage = null;
 				ceilingtex.BackgroundImage = null;
 			}
 
 			// Call base
 			base.OnVisibleChanged(e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersTabsControl.cs" startline="78" endline="89">
<![CDATA[
 
 		// Disposer
 		protected override void Dispose(bool disposing)
 		{
 			if(tabsimage != null)
 			{
 				tabsimage.Dispose();
 				tabsimage = null;
 			}
 			
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\GridSetup.cs" startline="285" endline="300">
<![CDATA[
 
 		// This changes grid size
 		// Note
 		[BeginAction("griddec")]
 		internal void IncreaseGrid()
 		{
 			// Not higher than 1024
 			if(gridsize <= 512)
 			{
 				// Change grid
 				SetGridSize(gridsize << 1);
 
 				// Redraw display
 				General.MainWindow.RedrawDisplay();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\MatchingTextureSet.cs" startline="144" endline="161">
<![CDATA[
 		
 		// This matches a name against the regex and adds a texture to
 		// the list if it matches. Returns true when matched and added.
 		internal bool AddTexture(ImageData image)
 		{
 			// Check against regex
 			if(regex.IsMatch(image.Name.ToUpperInvariant()))
 			{
 				// Matches! Add it.
 				textures.Add(image);
 				return true;
 			}
 			else
 			{
 				// Doesn't match
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\MatchingTextureSet.cs" startline="162" endline="179">
<![CDATA[
 
 		// This matches a name against the regex and adds a flat to
 		// the list if it matches. Returns true when matched and added.
 		internal bool AddFlat(ImageData image)
 		{
 			// Check against regex
 			if(regex.IsMatch(image.Name.ToUpperInvariant()))
 			{
 				// Matches! Add it.
 				flats.Add(image);
 				return true;
 			}
 			else
 			{
 				// Doesn't match
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="120" endline="129">
<![CDATA[
 
 		#endregion
 
 		#region ================== Rendering
 
 		// Draw item
 		private void list_DrawItem(object sender, DrawListViewItemEventArgs e)
 		{
 			if(!updating) (e.Item as ImageBrowserItem).Draw(e.Graphics, e.Bounds);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptDocumentTab.cs" startline="103" endline="114">
<![CDATA[
 		
 		// Disposer
 		protected override void Dispose(bool disposing)
 		{
 			// Remove events
 			editor.OnExplicitSaveTab -= panel.ExplicitSaveCurrentTab;
 			editor.OnOpenScriptBrowser -= panel.OpenBrowseScript;
 			editor.OnOpenFindAndReplace -= panel.OpenFindAndReplace;
 			editor.OnFindNext -= panel.FindNext;
 			
 			base.Dispose(disposing);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1445" endline="1461">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 
 		// This updates everything after the configuration or settings have been changed
 		internal void UpdateConfiguration()
 		{
 			// Update map
 			map.UpdateConfiguration();
 
 			// Update settings
 			renderer3d.CreateProjection();
 
 			// Things filters
 			General.MainWindow.UpdateThingsFilters();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="195" endline="216">
<![CDATA[
 		
 		// This must determine and return the image to show
 		protected abstract Image FindImage(string imagename);
 
 		// This must show the image browser and return the selected texture name
 		protected abstract string BrowseImage(string imagename);
 
 		// This determines the result value
 		public string GetResult(string original)
 		{
 			// Anyting entered?
 			if(name.Text.Trim().Length > 0)
 			{
 				// Return the new value
 				return name.Text;
 			}
 			else
 			{
 				// Nothing given, keep original value
 				return original;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="778" endline="793">
<![CDATA[
 
 		// This changes zoom display
 		internal void UpdateZoom(float scale)
 		{
 			// Update scale label
 			if(float.IsNaN(scale))
 				zoomlabel.Text = "--";
 			else
 			{
 				scale *= 100;
 				zoomlabel.Text = scale.ToString("##0") + "%";
 			}
 
 			// Update status bar
 			//statusbar.Update();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="454" endline="461">
<![CDATA[
 		
 		// Texture Set selected/deselected
 		private void listtextures_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			edittextureset.Enabled = (listtextures.SelectedItems.Count > 0);
 			removetextureset.Enabled = (listtextures.SelectedItems.Count > 0);
 			copytexturesets.Enabled = (listtextures.SelectedItems.Count > 0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Lump.cs" startline="157" endline="169">
<![CDATA[
 
 		// This copies lump data to another lump
 		internal void CopyTo(Lump lump)
 		{
 			BinaryReader reader;
 
 			// Create a reader
 			reader = new BinaryReader(stream);
 
 			// Copy bytes over
 			stream.Seek(0, SeekOrigin.Begin);
 			lump.Stream.Write(reader.ReadBytes((int)stream.Length), 0, (int)stream.Length);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\GridSetupForm.cs" startline="76" endline="90">
<![CDATA[
 
 		// Show Background changed
 		private void showbackground_CheckedChanged(object sender, EventArgs e)
 		{
 			// Enable/disable controls
 			selecttexture.Enabled = showbackground.Checked;
 			selectflat.Enabled = showbackground.Checked;
 			selectfile.Enabled = showbackground.Checked;
 			backoffset.Enabled = showbackground.Checked;
 			backscale.Enabled = showbackground.Checked;
 			backoffsetx.Enabled = showbackground.Checked;
 			backoffsety.Enabled = showbackground.Checked;
 			backscalex.Enabled = showbackground.Checked;
 			backscaley.Enabled = showbackground.Checked;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="409" endline="418">
<![CDATA[
 
 		// This ends adding items
 		public void EndAdding()
 		{
 			// Fill list with items
 			RefillList(true);
 
 			// Start updating
 			refreshtimer.Enabled = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1176" endline="1189">
<![CDATA[
 
 		// This temporarely breaks exclusive mode and counts the break level
 		public void BreakExclusiveMouseInput()
 		{
 			// Only when in exclusive mode
 			if(mouseexclusive)
 			{
 				// Stop special input device
 				StopMouseExclusive();
 				
 				// Count the break level
 				mouseexclusivebreaklevel++;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="254" endline="268">
<![CDATA[
 
 		// This checks and removes a level when the limit is reached
 		private void LimitUndoRedoLevel(List<UndoSnapshot> list)
 		{
 			UndoSnapshot u;
 			
 			// Too many?
 			if(list.Count > MAX_UNDO_LEVELS)
 			{
 				// Remove one and dispose map
 				u = list[list.Count - 1];
 				u.Dispose();
 				list.RemoveAt(list.Count - 1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.cs" startline="54" endline="67">
<![CDATA[
 		
 		// This initializes the set
 		public void Setup(DefinedTextureSet set)
 		{
 			// Keep reference
 			textureset = set;
 			
 			// Set name
 			name.Text = set.Name;
 			
 			// Fill filters list
 			foreach(string s in set.Filters)
 				filters.Items.Add(s);
 			foreach(string s in set.Filters)
 				filters.Items.Add(s);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\SerializerStream.cs" startline="76" endline="88">
<![CDATA[
 
 		public void End()
 		{
 			// Write the offset bytes
 			int offset = (int)writer.BaseStream.Length;
 			writer.Seek(0, SeekOrigin.Begin);
 			writer.Write(offset);
 
 			// Write the strings
 			writer.Seek(0, SeekOrigin.End);
 			foreach(KeyValuePair<string, ushort> str in stringstable)
 				writer.Write(str.Key);
 			foreach(KeyValuePair<string, ushort> str in stringstable)
 				writer.Write(str.Key);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Display2DShader.cs" startline="104" endline="123">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This sets the settings
 		public void SetSettings(float texelx, float texely, float fsaafactor, float alpha, bool bilinear)
 		{
 			if(manager.Enabled)
 			{
 				Vector4 values = new Vector4(texelx, texely, fsaafactor, alpha);
 				effect.SetValue(rendersettings, values);
 				Matrix world = manager.D3DDevice.Device.GetTransform(TransformState.World);
 				Matrix view = manager.D3DDevice.Device.GetTransform(TransformState.View);
 				effect.SetValue(transformsettings, Matrix.Multiply(world, view));
 				TextureFilter filter = TextureFilter.Point;
 				if(bilinear) filter = TextureFilter.Linear;
 				effect.SetValue<int>(filtersettings, (int)filter);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="883" endline="901">
<![CDATA[
 		
 		// This writes a copy of the data to a lump in the temp file
 		public void SetLumpData(string lumpname, MemoryStream data)
 		{
 			int insertindex = tempwad.Lumps.Count;
 			
 			// Remove the lump if it already exists
 			int li = tempwad.FindLumpIndex(lumpname);
 			if(li > -1)
 			{
 				insertindex = li;
 				tempwad.RemoveAt(li);
 			}
 			
 			// Insert new lump
 			Lump l = tempwad.Insert(lumpname, insertindex, (int)data.Length);
 			l.Stream.Seek(0, SeekOrigin.Begin);
 			data.WriteTo(l.Stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\AngleControl.cs" startline="136" endline="164">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Control
 
 		// This sets an angle manually
 		private void SetAngle(int newangle, bool changebuttons)
 		{
 			bool changed;
 			
 			// Normalize and apply angle
 			changed = (newangle != angle);
 			angle = newangle;
 			
 			// Check if it matches an angle from the buttons
 			if(changebuttons)
 			{
 				settingangle = true;
 				for(int i = 0; i < 8; i++)
 					buttons[i].Checked = (angle == i * 45);
 				for(int i = 0; i < 8; i++)
 					buttons[i].Checked = (angle == i * 45);
 				settingangle = false;
 			}
 			
 			// Redraw
 			this.Invalidate();
 			
 			// Raise event
 			if((ValueChanged != null) && changed) ValueChanged(this, EventArgs.Empty);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="292" endline="321">
<![CDATA[
 		
 		// Item selected
 		private void resourceitems_ItemSelectionChanged(object sender, ListViewItemSelectionChangedEventArgs e)
 		{
 			// Anything selected
 			if(resourceitems.SelectedItems.Count > 0)
 			{
 				// Go for all selected items
 				for(int i = resourceitems.SelectedItems.Count - 1; i >= 0; i--)
 				{
 					// Item grayed? Then deselect.
 					if(resourceitems.SelectedItems[i].ForeColor != SystemColors.WindowText)
 						resourceitems.SelectedItems[i].Selected = false;
 				}
 				for(int i = resourceitems.SelectedItems.Count - 1; i >= 0; i--)
 				{
 					// Item grayed? Then deselect.
 					if(resourceitems.SelectedItems[i].ForeColor != SystemColors.WindowText)
 						resourceitems.SelectedItems[i].Selected = false;
 				}
 			}
 
 			// Anything selected
 			if(resourceitems.SelectedItems.Count > 0)
 			{
 				// Enable buttons
 				editresource.Enabled = true;
 				deleteresource.Enabled = true;
 			}
 			else
 			{
 				// Disable buttons
 				editresource.Enabled = false;
 				deleteresource.Enabled = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="86" endline="117">
<![CDATA[
 
 		// When the entered value needs to be validated
 		private void combobox_Validating(object sender, CancelEventArgs e)
 		{
 			string str = combobox.Text.Trim().ToLowerInvariant();
 			str = str.TrimStart('+', '-');
 			int num;
 			
 			// Anything in the box?
 			if(combobox.Text.Trim().Length > 0)
 			{
 				// Prefixed?
 				if(CheckIsRelative())
 				{
 					// Try parsing to number
 					if(!int.TryParse(str, NumberStyles.Integer, CultureInfo.CurrentCulture, out num))
 					{
 						// Invalid relative number
 						combobox.SelectedItem = null;
 						combobox.Text = "";
 					}
 				}
 				else
 				{
 					// Set the value. The type handler will validate it
 					// and make the best possible choice.
 					typehandler.SetValue(combobox.Text);
 					combobox.SelectedItem = null;
 					combobox.Text = typehandler.GetStringValue();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="597" endline="634">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Statusbar
 		
 		// This updates the status bar
 		private void UpdateStatusbar()
 		{
 			// Map open?
 			if(General.Map != null)
 			{
 				// Enable items
 				xposlabel.Enabled = true;
 				yposlabel.Enabled = true;
 				poscommalabel.Enabled = true;
 				zoomlabel.Enabled = true;
 				buttonzoom.Enabled = true;
 				gridlabel.Enabled = true;
 				buttongrid.Enabled = true;
 				configlabel.Text = General.Map.Config.Name;
 			}
 			else
 			{
 				// Disable items
 				xposlabel.Text = "--";
 				yposlabel.Text = "--";
 				xposlabel.Enabled = false;
 				yposlabel.Enabled = false;
 				poscommalabel.Enabled = false;
 				zoomlabel.Enabled = false;
 				buttonzoom.Enabled = false;
 				gridlabel.Enabled = false;
 				buttongrid.Enabled = false;
 				configlabel.Text = "";
 			}
 			
 			UpdateStatusIcon();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2777" endline="2785">
<![CDATA[
 		
 		// Mouse enters dockers window
 		private void dockerspanel_MouseContainerEnter(object sender, EventArgs e)
 		{
 			if(General.Settings.CollapseDockers)
 				dockerscollapser.Start();
 			
 			dockerspanel.Expand();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DShader.cs" startline="150" endline="159">
<![CDATA[
 
 		// This applies the shader
 		public void Begin()
 		{
 			// Set vertex declaration
 			General.Map.Graphics.Device.VertexDeclaration = vertexdecl;
 
 			// Set effect
 			if(manager.Enabled) effect.Begin(FX.DoNotSaveState);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1309" endline="1325">
<![CDATA[
 
 		// This gets thing information by index
 		// Returns null when thing type info could not be found
 		public ThingTypeInfo GetThingInfoEx(int thingtype)
 		{
 			// Index in config?
 			if(thingtypes.ContainsKey(thingtype))
 			{
 				// Return from config
 				return thingtypes[thingtype];
 			}
 			else
 			{
 				// No such thing type known
 				return null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ScriptConfiguration.cs" startline="201" endline="214">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 		
 		// This returns the correct case for a keyword
 		// Returns the same keyword as the input when it cannot be found
 		public string GetKeywordCase(string keyword)
 		{
 			if(lowerkeywords.ContainsKey(keyword.ToLowerInvariant()))
 				return lowerkeywords[keyword.ToLowerInvariant()];
 			else
 				return keyword;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ScriptConfiguration.cs" startline="215" endline="224">
<![CDATA[
 
 		// This returns the correct case for a constant
 		// Returns the same constant as the input when it cannot be found
 		public string GetConstantCase(string constant)
 		{
 			if(lowerconstants.ContainsKey(constant.ToLowerInvariant()))
 				return lowerconstants[constant.ToLowerInvariant()];
 			else
 				return constant;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="224" endline="251">
<![CDATA[
 
 		// This reads the WAD header and lumps table
 		public void WriteHeaders()
 		{
 			// Seek to beginning
 			file.Seek(0, SeekOrigin.Begin);
 
 			// Write WAD type
 			writer.Write(ENCODING.GetBytes(type));
 
 			// Number of lumps
 			writer.Write(numlumps);
 
 			// Lumps table offset
 			writer.Write(lumpsoffset);
 
 			// Seek to the lumps table
 			file.Seek(lumpsoffset, SeekOrigin.Begin);
 
 			// Go for all lumps
 			for(int i = 0; i < lumps.Count; i++)
 			{
 				// Write lump information
 				writer.Write(lumps[i].Offset);
 				writer.Write(lumps[i].Length);
 				writer.Write(lumps[i].FixedName);
 			}
 			for(int i = 0; i < lumps.Count; i++)
 			{
 				// Write lump information
 				writer.Write(lumps[i].Offset);
 				writer.Write(lumps[i].Length);
 				writer.Write(lumps[i].FixedName);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="61" endline="79">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Events
 
 		// When control resizes
 		private void ArgumentBox_Resize(object sender, EventArgs e)
 		{
 			if(button.Visible)
 				combobox.Width = ClientRectangle.Width - button.Width - 2;
 			else if(scrollbuttons.Visible)
 				combobox.Width = ClientRectangle.Width - scrollbuttons.Width - 2;
 			else
 				combobox.Width = ClientRectangle.Width;
 
 			button.Left = ClientRectangle.Width - button.Width;
 			scrollbuttons.Left = ClientRectangle.Width - scrollbuttons.Width;
 			Height = button.Height;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ButtonsNumericTextbox.cs" startline="146" endline="164">
<![CDATA[
 
 		// Mouse wheel used
 		private void textbox_MouseWheel(object sender, MouseEventArgs e)
 		{
 			if(steps != null)
 			{
 				if(e.Delta > 0)
 					textbox.Text = steps.GetNextHigher(textbox.GetResult(0)).ToString();
 				else if(e.Delta < 0)
 					textbox.Text = steps.GetNextLower(textbox.GetResult(0)).ToString();
 			}
 			else
 			{
 				if(e.Delta < 0)
 					buttons.Value += 1;
 				else if(e.Delta > 0)
 					buttons.Value -= 1;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="127" endline="159">
<![CDATA[
 
 		// This will edit the given list
 		public void EditResourceLocationList(DataLocationList list)
 		{
 			// Start editing list
 			resourceitems.BeginUpdate();
 
 			// Scroll to top
 			if(resourceitems.Items.Count > 0)
 				resourceitems.TopItem = resourceitems.Items[0];
 			
 			// Go for all items
 			for(int i = resourceitems.Items.Count - 1; i >= 0; i--)
 			{
 				// Remove item unless fixed
 				if(resourceitems.Items[i].ForeColor == SystemColors.WindowText)
 					resourceitems.Items.RemoveAt(i);
 			}
 			for(int i = resourceitems.Items.Count - 1; i >= 0; i--)
 			{
 				// Remove item unless fixed
 				if(resourceitems.Items[i].ForeColor == SystemColors.WindowText)
 					resourceitems.Items.RemoveAt(i);
 			}
 
 			// Go for all items
 			for(int i = 0; i < list.Count; i++)
 			{
 				// Add item
 				AddItem(list[i]);
 			}
 			for(int i = 0; i < list.Count; i++)
 			{
 				// Add item
 				AddItem(list[i]);
 			}
 
 			// Done
 			resourceitems.EndUpdate();
 			ResizeColumnHeader();
 			
 			// Raise content changed event
 			if(OnContentChanged != null) OnContentChanged();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Vertex.cs" startline="262" endline="293">
<![CDATA[
 		
 		// This joins another vertex
 		// Which means this vertex is removed and the other is kept!
 		public void Join(Vertex other)
 		{
 			// If either of the two vertices was selected, keep the other selected
 			if(this.Selected) other.Selected = true;
 			if(this.marked) other.marked = true;
 
 			// Any linedefs to move?
 			if(linedefs.Count > 0)
 			{
 				// Detach all linedefs and attach them to the other
 				// This will automatically dispose this vertex
 				while(linedefs != null)
 				{
 					// Move the line to the other vertex
 					if(linedefs.First.Value.Start == this)
 						linedefs.First.Value.SetStartVertex(other);
 					else
 						linedefs.First.Value.SetEndVertex(other);
 				}
 				while(linedefs != null)
 				{
 					// Move the line to the other vertex
 					if(linedefs.First.Value.Start == this)
 						linedefs.First.Value.SetStartVertex(other);
 					else
 						linedefs.First.Value.SetEndVertex(other);
 				}
 			}
 			else
 			{
 				// No lines attached
 				// Dispose manually
 				this.Dispose();
 			}
 
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="650" endline="682">
<![CDATA[
 
 		// This begins a drawing session
 		public unsafe bool StartThings(bool clear)
 		{
 			if(renderlayer != RenderLayers.None) throw new InvalidOperationException("Renderer starting called before finished previous layer. Call Finish() first!");
 			renderlayer = RenderLayers.Things;
 			try { graphics.Device.SetRenderState(RenderState.FogEnable, false); } catch(Exception) { }
 			
 			// Rendertargets available?
 			if(thingstex != null)
 			{
 				// Set the rendertarget to the things texture
 				targetsurface = thingstex.GetSurfaceLevel(0);
 				if(graphics.StartRendering(clear, General.Colors.Background.WithAlpha(0).ToColorValue(), targetsurface, null))
 				{
 					// Ready for rendering
 					UpdateTransformations();
 					return true;
 				}
 				else
 				{
 					// Can't render!
 					Finish();
 					return false;
 				}
 			}
 			else
 			{
 				// Can't render!
 				Finish();
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="683" endline="715">
<![CDATA[
 
 		// This begins a drawing session
 		public unsafe bool StartOverlay(bool clear)
 		{
 			if(renderlayer != RenderLayers.None) throw new InvalidOperationException("Renderer starting called before finished previous layer. Call Finish() first!");
 			renderlayer = RenderLayers.Overlay;
 			try { graphics.Device.SetRenderState(RenderState.FogEnable, false); } catch(Exception) { }
 			
 			// Rendertargets available?
 			if(overlaytex != null)
 			{
 				// Set the rendertarget to the things texture
 				targetsurface = overlaytex.GetSurfaceLevel(0);
 				if(graphics.StartRendering(clear, General.Colors.Background.WithAlpha(0).ToColorValue(), targetsurface, null))
 				{
 					// Ready for rendering
 					UpdateTransformations();
 					return true;
 				}
 				else
 				{
 					// Can't render!
 					Finish();
 					return false;
 				}
 			}
 			else
 			{
 				// Can't render!
 				Finish();
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\StateStructure.cs" startline="167" endline="201">
<![CDATA[
 		
 		// This version of GetSprite uses a callstack to check if it isn't going into an endless loop
 		private string GetSprite(int index, List<StateStructure> prevstates)
 		{
 			// If we have sprite of our own, see if we can return this index
 			if(index < sprites.Count)
 			{
 				return sprites[index];
 			}
 			
 			// Otherwise, continue searching where goto tells us to go
 			if(gotostate != null)
 			{
 				// Find the class
 				ActorStructure a = parser.GetArchivedActorByName(gotostate.ClassName);
 				if(a != null)
 				{
 					StateStructure s = a.GetState(gotostate.StateName);
 					if((s != null) && !prevstates.Contains(s))
 					{
 						prevstates.Add(this);
 						return s.GetSprite(gotostate.SpriteOffset, prevstates);
 					}
 				}
 			}
 			
 			// If there is no goto keyword used, just give us one of our sprites if we can
 			if(sprites.Count > 0)
 			{
 				// The following behavior should really depend on the flow control keyword (loop or stop) but who cares.
 				return sprites[0];
 			}
 			
 			return "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingEditForm.cs" startline="188" endline="218">
<![CDATA[
 
 		// Selected type changes
 		private void thingtype_OnTypeChanged(ThingTypeInfo value)
 		{
 			thinginfo = value;
 
 			// Update preview image
 			if(thinginfo != null)
 			{
 				if(thinginfo.Sprite.ToLowerInvariant().StartsWith(DataManager.INTERNAL_PREFIX) &&
 				   (thinginfo.Sprite.Length > DataManager.INTERNAL_PREFIX.Length))
 				{
 					General.DisplayZoomedImage(spritetex, General.Map.Data.GetSpriteImage(thinginfo.Sprite).GetBitmap());
 				}
 				else if((thinginfo.Sprite.Length <= 8) && (thinginfo.Sprite.Length > 0))
 				{
 					General.DisplayZoomedImage(spritetex, General.Map.Data.GetSpriteImage(thinginfo.Sprite).GetPreview());
 				}
 				else
 				{
 					spritetex.BackgroundImage = null;
 				}
 			}
 			else
 			{
 				spritetex.BackgroundImage = null;
 			}
 			
 			// Update arguments
 			action_ValueChanges(this, EventArgs.Empty);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\EffectBrowserForm.cs" startline="137" endline="173">
<![CDATA[
 		
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Presume no result
 			selectedeffect = 0;
 			
 			// Predefined action?
 			if(tabs.SelectedTab == tabeffects)
 			{
 				// Effect selected?
 				if((effects.SelectedItems.Count > 0) && (effects.SelectedItems[0].Tag is SectorEffectInfo))
 				{
 					// Our result
 					selectedeffect = (effects.SelectedItems[0].Tag as SectorEffectInfo).Index;
 				}
 			}
 			// Generalized action
 			else
 			{
 				// Go for all options
 				for(int i = 0; i < MAX_OPTIONS; i++)
 				{
 					// Option used?
 					if(i < General.Map.Config.GenEffectOptions.Count)
 					{
 						// Add selected bits
 						if(options[i].SelectedIndex > -1)
 							selectedeffect += (options[i].SelectedItem as GeneralizedBit).Index;
 					}
 				}
 				for(int i = 0; i < MAX_OPTIONS; i++)
 				{
 					// Option used?
 					if(i < General.Map.Config.GenEffectOptions.Count)
 					{
 						// Add selected bits
 						if(options[i].SelectedIndex > -1)
 							selectedeffect += (options[i].SelectedItem as GeneralizedBit).Index;
 					}
 				}
 			}
 			
 			// Done
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="379" endline="388">
<![CDATA[
 		
 		// Splitting begins
 		private void splitter_MouseDown(object sender, MouseEventArgs e)
 		{
 			if(e.Button == MouseButtons.Left)
 			{
 				splitstartoffset = e.X;
 				splitter.BackColor = SystemColors.Highlight;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="539" endline="553">
<![CDATA[
 
 		// This sets the world matrix for transformation
 		private void SetWorldTransformation(bool transform)
 		{
 			if(transform)
 			{
 				Matrix translate = Matrix.Translation(translatex, translatey, 0f);
 				Matrix scaling = Matrix.Scaling(scale, -scale, 1f);
 				graphics.Device.SetTransform(TransformState.World, Matrix.Multiply(translate, scaling));
 			}
 			else
 			{
 				graphics.Device.SetTransform(TransformState.World, Matrix.Identity);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="135" endline="146">
<![CDATA[
 
 		// Mouse wheel used
 		private void combobox_MouseWheel(object sender, MouseEventArgs e)
 		{
 			if(scrollbuttons.Visible)
 			{
 				if(e.Delta < 0)
 					scrollbuttons.Value += 1;
 				else if(e.Delta > 0)
 					scrollbuttons.Value -= 1;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="302" endline="323">
<![CDATA[
 
 		#endregion
 
 		#region ================== Events
 
 		// Column header clicked
 		private void fieldslist_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
 		{
 			// Save sort order
 			if(fieldslist.SortedColumn != null)
 			{
 				int sortcolumn = fieldslist.SortedColumn.Index;
 				int sortorder = (int)fieldslist.SortOrder;
 				General.Settings.WriteSetting("customfieldssortcolumn", sortcolumn);
 				General.Settings.WriteSetting("customfieldssortorder", sortorder);
 			}
 			
 			// Stop any cell editing
 			ApplyEnums(true);
 			fieldslist.EndEdit();
 			HideBrowseButton();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="682" endline="689">
<![CDATA[
 		
 		// This applies defaults to a sidedef
 		private static void ApplyDefaultsToSidedef(Sidedef sd, SidedefSettings defaults)
 		{
 			if(sd.HighRequired() && sd.HighTexture.StartsWith("-")) sd.SetTextureHigh(defaults.newtexhigh);
 			if(sd.MiddleRequired() && sd.MiddleTexture.StartsWith("-")) sd.SetTextureMid(defaults.newtexmid);
 			if(sd.LowRequired() && sd.LowTexture.StartsWith("-")) sd.SetTextureLow(defaults.newtexlow);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="996" endline="1026">
<![CDATA[
 		
 		// This changes sidedefs (used for joining lines)
 		// target
 		// front
 		// newside
 		//				If this is null, no sidedef will be created (only removed)
 		// Returns false when the operation could not be completed.
 		private bool JoinChangeSidedefs(Linedef target, bool front, Sidedef newside)
 		{
 			Sidedef sd;
 			
 			// Change sidedefs
 			if(front)
 			{
 				if(target.front != null) target.front.Dispose();
 			}
 			else
 			{
 				if(target.back != null) target.back.Dispose();
 			}
 			
 			if(newside != null)
 			{
 				sd = map.CreateSidedef(target, front, newside.Sector);
 				if(sd == null) return false;
 				newside.CopyPropertiesTo(sd);
 				sd.Marked = newside.Marked;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1298" endline="1330">
<![CDATA[
 
 		// When a key is released
 		private void MainForm_KeyUp(object sender, KeyEventArgs e)
 		{
 			int mod = 0;
 			
 			// Keep key modifiers
 			alt = e.Alt;
 			shift = e.Shift;
 			ctrl = e.Control;
 			if(alt) mod |= (int)Keys.Alt;
 			if(shift) mod |= (int)Keys.Shift;
 			if(ctrl) mod |= (int)Keys.Control;
 			
 			// Don't process any keys when they are meant for other input controls
 			if((ActiveControl == null) || (ActiveControl == display))
 			{
 				// Invoke any actions associated with this key
 				General.Actions.UpdateModifiers(mod);
 				e.Handled = General.Actions.KeyReleased((int)e.KeyData);
 				
 				// Invoke on editing mode
 				if((General.Map != null) && (General.Editing.Mode != null))
 				{
 					General.Plugins.OnEditKeyUp(e);
 					General.Editing.Mode.OnKeyUp(e);
 				}
 				
 				// Handled
 				if(e.Handled)
 					e.SuppressKeyPress = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\IntegerHandler.cs" startline="53" endline="84">
<![CDATA[
 		{
 			int result;
 			
 			// Null?
 			if(value == null)
 			{
 				this.value = 0;
 			}
 			// Compatible type?
 			else if((value is int) || (value is float) || (value is bool))
 			{
 				// Set directly
 				this.value = Convert.ToInt32(value);
 			}
 			else
 			{
 				// Try parsing as string
 				if(int.TryParse(value.ToString(), NumberStyles.Integer, CultureInfo.CurrentCulture, out result))
 				{
 					this.value = result;
 				}
 				else
 				{
 					this.value = 0;
 				}
 			}
 
 			if(forargument)
 			{
 				this.value = General.Clamp(this.value, General.Map.FormatInterface.MinArgument, General.Map.FormatInterface.MaxArgument);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="191" endline="197">
<![CDATA[
 		
 		// This fixes the column header in the list
 		private void ResizeColumnHeader()
 		{
 			// Resize column header to full extend
 			column.Width = resourceitems.ClientSize.Width - SystemInformation.VerticalScrollBarWidth;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="638" endline="660">
<![CDATA[
 		
 		// This adds an image for background loading or unloading
 		internal void ProcessImage(ImageData img)
 		{
 			// Load this image?
 			if((img.ImageState == ImageLoadState.None) && img.IsReferenced)
 			{
 				// Add for loading
 				img.ImageState = ImageLoadState.Loading;
 				lock(imageque) { imageque.Enqueue(img); }
 			}
 			
 			// Unload this image?
 			if((img.ImageState == ImageLoadState.Ready) && !img.IsReferenced && img.AllowUnload)
 			{
 				// Add for unloading
 				img.ImageState = ImageLoadState.Unloading;
 				lock(imageque) { imageque.Enqueue(img); }
 			}
 			
 			// Update icon
 			General.SendMessage(General.MainWindow.Handle, (int)MainForm.ThreadMessages.UpdateStatus, 0, 0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="132" endline="168">
<![CDATA[
 
 		// Disposer
 		public override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Already set isdisposed so that changes can be prohibited
 				isdisposed = true;
 				
 				// Dispose the sidedefs that are attached to this sector
 				// because a sidedef cannot exist without reference to its sector.
 				if(map.AutoRemove)
 					foreach(Sidedef sd in sidedefs) sd.Dispose();
 				else
 					foreach(Sidedef sd in sidedefs) sd.SetSectorP(null);
 				
 				if(map == General.Map.Map)
 					General.Map.UndoRedo.RecRemSector(this);
 
 				// Remove from main list
 				map.RemoveSector(listindex);
 				
 				// Register the index as free
 				map.AddSectorIndexHole(fixedindex);
 				
 				// Free surface entry
 				General.Map.CRenderer2D.Surfaces.FreeSurfaces(surfaceentries);
 
 				// Clean up
 				sidedefs = null;
 				map = null;
 				
 				// Dispose base
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1102" endline="1159">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Surface
 
 		// This redraws the surface
 		public void RedrawSurface()
 		{
 			if(renderlayer != RenderLayers.None) throw new InvalidOperationException("Renderer starting called before finished previous layer. Call Finish() first!");
 			renderlayer = RenderLayers.Surface;
 
 			// Rendertargets available?
 			if(surfacetex != null)
 			{
 				// Set the rendertarget to the surface texture
 				targetsurface = surfacetex.GetSurfaceLevel(0);
 				if(graphics.StartRendering(true, General.Colors.Background.WithAlpha(0).ToColorValue(), targetsurface, null))
 				{
 					// Make sure anything we need is loaded
 					General.Map.Data.UnknownTexture3D.CreateTexture();
 
 					// Set transformations
 					UpdateTransformations();
 
 					// Set states
 					graphics.Device.SetRenderState(RenderState.CullMode, Cull.None);
 					graphics.Device.SetRenderState(RenderState.ZEnable, false);
 					graphics.Device.SetRenderState(RenderState.AlphaBlendEnable, false);
 					graphics.Device.SetRenderState(RenderState.AlphaTestEnable, false);
 					graphics.Device.SetRenderState(RenderState.TextureFactor, -1);
 					graphics.Device.SetRenderState(RenderState.FogEnable, false);
 					SetWorldTransformation(true);
 					graphics.Shaders.Display2D.SetSettings(1f, 1f, 0f, 1f, General.Settings.ClassicBilinear);
 					
 					// Prepare for rendering
 					switch(viewmode)
 					{
 						case ViewMode.Brightness
 							surfaces.RenderSectorBrightness(yviewport);
 							surfaces.RenderSectorSurfaces(graphics);
 							break;
 							
 						case ViewMode.FloorTextures
 							surfaces.RenderSectorFloors(yviewport);
 							surfaces.RenderSectorSurfaces(graphics);
 							break;
 							
 						case ViewMode.CeilingTextures
 							surfaces.RenderSectorCeilings(yviewport);
 							surfaces.RenderSectorSurfaces(graphics);
 							break;
 					}
 				}
 			}
 			
 			// Done
 			Finish();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="95" endline="109">
<![CDATA[
 
 		#endregion
 
 		#region ================== Setup / Apply
 
 		// This sets up the control
 		public void Setup(string elementname)
 		{
 			// Keep element name
 			this.elementname = elementname;
 			
 			// Make types list
 			fieldtype.Items.Clear();
 			fieldtype.Items.AddRange(General.Types.GetCustomUseAttributes());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ActionSelectorControl.cs" startline="249" endline="255">
<![CDATA[
 		
 		// Selection made
 		private void list_SelectionChangeCommitted(object sender, EventArgs e)
 		{
 			INumberedTitle item = (INumberedTitle)list.SelectedItem;
 			number.Text = item.Index.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="685" endline="707">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Palette
 
 		// This loads the PLAYPAL palette
 		private void LoadPalette()
 		{
 			// Go for all opened containers
 			for(int i = containers.Count - 1; i >= 0; i--)
 			{
 				// Load palette
 				palette = containers[i].LoadPalette();
 				if(palette != null) break;
 			}
 			for(int i = containers.Count - 1; i >= 0; i--)
 			{
 				// Load palette
 				palette = containers[i].LoadPalette();
 				if(palette != null) break;
 			}
 
 			// Make empty palette when still no palette found
 			if(palette == null)
 			{
 				General.ErrorLogger.Add(ErrorType.Warning, "None of the loaded resources define a color palette. Did you forget to configure an IWAD for this game configuration?");
 				palette = new Playpal();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DDevice.cs" startline="442" endline="475">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Rendering
 
 		// This begins a drawing session
 		public bool StartRendering(bool clear, Color4 backcolor, Surface target, Surface depthbuffer)
 		{
 			// Check if we can render
 			if(CheckAvailability())
 			{
 				// Set rendertarget
 				device.DepthStencilSurface = depthbuffer;
 				device.SetRenderTarget(0, target);
 				
 				// Clear the screen
 				if(clear)
 				{
 					if(depthbuffer != null)
 						device.Clear(ClearFlags.Target | ClearFlags.ZBuffer, backcolor, 1f, 0);
 					else
 						device.Clear(ClearFlags.Target, backcolor, 1f, 0);
 				}
 
 				// Ready to render
 				device.BeginScene();
 				return true;
 			}
 			else
 			{
 				// Minimized, you cannot see anything
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="865" endline="880">
<![CDATA[
 		
 		// This returns an image by long
 		public ImageData GetTextureImage(long longname)
 		{
 			// Does this texture exist?
 			if(textures.ContainsKey(longname))
 			{
 				// Return texture
 				return textures[longname];
 			}
 			else
 			{
 				// Return null image
 				return new UnknownImage(Properties.Resources.UnknownImage);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="954" endline="969">
<![CDATA[
 
 		// This returns an image by long
 		public ImageData GetFlatImage(long longname)
 		{
 			// Does this flat exist?
 			if(flats.ContainsKey(longname))
 			{
 				// Return flat
 				return flats[longname];
 			}
 			else
 			{
 				// Return null image
 				return new UnknownImage(Properties.Resources.UnknownImage);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Vertex.cs" startline="221" endline="245">
<![CDATA[
 
 		// This moves the vertex
 		public void Move(Vector2D newpos)
 		{
 			// Do we actually move?
 			if(newpos != pos)
 			{
 				BeforePropsChange();
 				
 				// Change position
 				pos = newpos;
 
 				#if DEBUG
 				if(float.IsNaN(pos.x) || float.IsNaN(pos.y) ||
 				   float.IsInfinity(pos.x) || float.IsInfinity(pos.y))
 				{
 					General.Fail("Invalid vertex position! The given vertex coordinates cannot be NaN or Infinite.");
 				}
 				#endif
 
 				// Let all lines know they need an update
 				foreach(Linedef l in linedefs) l.NeedUpdate();
 				General.Map.IsChanged = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="314" endline="330">
<![CDATA[
 
 		/// <summary>
 		/// This checks if a texture is required
 		/// </summary>
 		public bool LowRequired()
 		{
 			// Doublesided?
 			if(Other != null)
 			{
 				// Texture is required when floor of other side is higher
 				return (Other.sector.FloorHeight > this.sector.FloorHeight);
 			}
 			else
 			{
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1293" endline="1308">
<![CDATA[
 		
 		// This gets thing information by index
 		public ThingTypeInfo GetThingInfo(int thingtype)
 		{
 			// Index in config?
 			if(thingtypes.ContainsKey(thingtype))
 			{
 				// Return from config
 				return thingtypes[thingtype];
 			}
 			else
 			{
 				// Create unknown thing info
 				return new ThingTypeInfo(thingtype);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2281" endline="2297">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 
 		// Perform a command (using SendMessage)
 		protected UInt32 SlowPerform(UInt32 message, UInt32 wParam, UInt32 lParam)
 		{
 			if(controlptr != IntPtr.Zero)
 			{
 				return (UInt32)General.SendMessage(controlptr, message, (int)wParam, (int)lParam);
 			}
 			else
 			{
 				return 0;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2298" endline="2310">
<![CDATA[
 
 		// Immediately perform a command (send directly to control)
 		protected UInt32 FastPerform(UInt32 message, UInt32 wParam, UInt32 lParam)
 		{
 			if(controlptr != IntPtr.Zero)
 			{
 				return (UInt32)Perform(directptr, message, (UInt32)wParam, (UInt32)lParam);
 			}
 			else
 			{
 				return 0;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="288" endline="304">
<![CDATA[
 		
 		/// <summary>
 		/// This checks if a texture is required
 		/// </summary>
 		public bool HighRequired()
 		{
 			// Doublesided?
 			if(Other != null)
 			{
 				// Texture is required when ceiling of other side is lower
 				return (Other.sector.CeilHeight < this.sector.CeilHeight);
 			}
 			else
 			{
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MapOptionsForm.cs" startline="203" endline="225">
<![CDATA[
 
 		// Game configuration chosen
 		private void config_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			ConfigurationInfo ci;
 			
 			// Anything selected?
 			if(config.SelectedIndex > -1)
 			{
 				// Get the info
 				ci = (ConfigurationInfo)config.SelectedItem;
 
 				// No lump name in the name field?
 				if(levelname.Text.Trim().Length == 0)
 				{
 					// Get default lump name from configuration
 					levelname.Text = ci.DefaultLumpName;
 				}
 				
 				// Show resources
 				datalocations.FixedResourceLocationList(ci.Resources);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1708" endline="1730">
<![CDATA[
 		
 		// This adds an editing mode seperator on the toolbar and menu
 		internal void AddEditModeSeperator()
 		{
 			ToolStripSeparator item;
 			int index;
 			
 			// Create a button
 			index = toolbar.Items.IndexOf(seperatormodes);
 			item = new ToolStripSeparator();
 			item.Margin = new Padding(6, 0, 6, 0);
 			toolbar.Items.Insert(index, item);
 			editmodeitems.Add(item);
 			
 			// Create menu item
 			index = menumode.DropDownItems.Count;
 			item = new ToolStripSeparator();
 			item.Margin = new Padding(0, 3, 0, 3);
 			menumode.DropDownItems.Insert(index, item);
 			editmodeitems.Add(item);
 			
 			UpdateSeparators();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditModeInfo.cs" startline="171" endline="186">
<![CDATA[
 		
 		// This switches to the mode
 		public void SwitchToMode()
 		{
 			EditMode newmode;
 			
 			// Only when a map is opened
 			if(General.Map != null)
 			{
 				// Create instance
 				newmode = plugin.CreateObject<EditMode>(type);
 
 				// Switch mode
 				General.Editing.ChangeMode(newmode);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="212" endline="234">
<![CDATA[
 
 		#endregion
 
 		#region ================== Private Methods
 
 		// This clears the redos
 		private void ClearRedos()
 		{
 			lock(redos)
 			{
 				// Dispose all redos
 				foreach(UndoSnapshot u in redos) u.Dispose();
 				redos.Clear();
 				
 				// If the current snapshot is meant for redo, trash it also
 				if(isundosnapshot && (snapshot != null))
 				{
 					FinishRecording();
 					isundosnapshot = false;
 					snapshot = null;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\CustomFieldsForm.cs" startline="63" endline="84">
<![CDATA[
 		
 		// This sets up the dialog
 		public void Setup(string title, string elementname, ICollection<MapElement> elements, List<UniversalFieldInfo> fixedfields)
 		{
 			// Initialize
 			this.elements = elements;
 			this.Text = title;
 			
 			// Fill universal fields list
 			fieldslist.ListFixedFields(fixedfields);
 
 			// Initialize custom fields editor
 			fieldslist.Setup(elementname);
 
 			// Setup from first element
 			MapElement fe = General.GetByIndex(elements, 0);
 			fieldslist.SetValues(fe.Fields, true);
 			
 			// Setup from all elements
 			foreach(MapElement e in elements)
 				fieldslist.SetValues(e.Fields, false);
 			foreach(MapElement e in elements)
 				fieldslist.SetValues(e.Fields, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="730" endline="758">
<![CDATA[
 		
 		// This updates the status icon
 		internal void UpdateStatusIcon()
 		{
 			int statusicon = 0;
 			int statusflashindex = statusflashicon ? 1 
 			
 			// Loading icon?
 			if((General.Map != null) && (General.Map.Data != null) && General.Map.Data.IsLoading)
 				statusicon = 1;
 			
 			// Status type
 			switch(status.type)
 			{
 				case StatusType.Ready
 				case StatusType.Info
 				case StatusType.Action
 					statuslabel.Image = STATUS_IMAGES[statusflashindex, statusicon];
 					break;
 				
 				case StatusType.Busy
 					statuslabel.Image = STATUS_IMAGES[statusflashindex, 2];
 					break;
 					
 				case StatusType.Warning
 					statuslabel.Image = STATUS_IMAGES[statusflashindex, 3];
 					break;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="650" endline="666">
<![CDATA[
 
 		// Browse clicked
 		private void browsebutton_Click(object sender, EventArgs e)
 		{
 			// Any row selected?
 			if(fieldslist.SelectedRows.Count > 0)
 			{
 				// Get selected row
 				DataGridViewRow row = fieldslist.SelectedRows[0];
 				if(row is FieldsEditorRow)
 				{
 					// Browse
 					(row as FieldsEditorRow).Browse(this.ParentForm);
 					fieldslist.Focus();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="386" endline="408">
<![CDATA[
 		
 		// User deletes a row
 		private void fieldslist_UserDeletingRow(object sender, DataGridViewRowCancelEventArgs e)
 		{
 			// Get the row
 			FieldsEditorRow row = e.Row as FieldsEditorRow;
 			
 			// Fixed field?
 			if(row.IsFixed)
 			{
 				// Just undefine the field
 				row.Undefine();
 				e.Cancel = true;
 
 				if(OnFieldUndefined != null)
 					OnFieldUndefined(row.Name);
 			}
 			else
 			{
 				if(OnFieldDeleted != null)
 					OnFieldDeleted(row.Name);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingBrowserControl.cs" startline="143" endline="160">
<![CDATA[
 
 		#endregion
 
 		#region ================== Events
 
 		// List double-clicked
 		private void typelist_DoubleClick(object sender, EventArgs e)
 		{
 			if(typelist.SelectedNode != null)
 			{
 				// Node is a child node?
 				TreeNode n = typelist.SelectedNode;
 				if((n.Nodes.Count == 0) && (n.Tag != null) && (n.Tag is ThingTypeInfo))
 				{
 					if((OnTypeDoubleClicked != null) && (typeid.Text.Length > 0)) OnTypeDoubleClicked();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="235" endline="253">
<![CDATA[
 
 		// This clears the undos
 		private void ClearUndos()
 		{
 			lock(undos)
 			{
 				// Dispose all undos
 				foreach(UndoSnapshot u in undos) u.Dispose();
 				undos.Clear();
 				
 				// If the current snapshot is meant for undo, trash it also
 				if(!isundosnapshot && (snapshot != null))
 				{
 					FinishRecording();
 					isundosnapshot = false;
 					snapshot = null;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="159" endline="169">
<![CDATA[
 
 		// Delete Selected clicked
 		private void deletefilter_Click(object sender, EventArgs e)
 		{
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Remove item
 				listfilters.Items.Remove(listfilters.SelectedItems[0]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingBrowserControl.cs" startline="121" endline="136">
<![CDATA[
 
 		// This clears the type
 		public void ClearSelectedType()
 		{
 			doupdatenode = false;
 
 			// Clear selection
 			typelist.SelectedNode = null;
 			typeid.Text = "";
 
 			// Collapse nodes
 			foreach(TreeNode n in nodes)
 				if(n.Parent.IsExpanded) n.Parent.Collapse();
 			foreach(TreeNode n in nodes)
 				if(n.Parent.IsExpanded) n.Parent.Collapse();
 			
 			doupdatenode = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="299" endline="318">
<![CDATA[
 		
 		// Rename filter
 		private void filtername_Validating(object sender, CancelEventArgs e)
 		{
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Get selected filter
 				ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 
 				// Name changed?
 				if(f.Name != filtername.Text)
 				{
 					// Update name
 					f.Name = filtername.Text;
 					listfilters.SelectedItems[0].Text = f.Name;
 					listfilters.Sort();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.cs" startline="68" endline="83">
<![CDATA[
 
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Apply name
 			textureset.Name = name.Text;
 			
 			// Apply filters
 			textureset.Filters.Clear();
 			foreach(ListViewItem i in filters.Items) textureset.Filters.Add(i.Text);
 			
 			// Done
 			matcheslist.CleanUp();
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="623" endline="657">
<![CDATA[
 
 		// Key combination pressed
 		private void actionkey_KeyDown(object sender, KeyEventArgs e)
 		{
 			int key = (int)e.KeyData;
 			e.SuppressKeyPress = true;
 
 			// Leave when not allowed to update
 			if(!allowapplycontrol) return;
 
 			// Anything selected?
 			if(listactions.SelectedItems.Count > 0)
 			{
 				// Begin updating
 				allowapplycontrol = false;
 				
 				// Remove modifier keys from the key if needed
 				if(disregardshift) key &= ~(int)Keys.Shift;
 				if(disregardcontrol) key &= ~(int)Keys.Control;
 				
 				// Deselect anything from the combobox
 				actioncontrol.SelectedIndex = -1;
 				
 				// Apply the key combination
 				listactions.SelectedItems[0].SubItems[1].Text = Actions.Action.GetShortcutKeyDesc(key);
 				listactions.SelectedItems[0].SubItems[1].Tag = key;
 				actionkey.Text = Actions.Action.GetShortcutKeyDesc(key);
 				
 				// Show actions with same key
 				UpdateKeyUsedActions();
 				
 				// Done
 				allowapplycontrol = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="509" endline="529">
<![CDATA[
 		
 		// This updates the texture size label
 		private void UpdateTextureSizeLabel()
 		{
 			if((list.SelectedItems.Count == 0) ||
 			   (splitter.Panel2.ClientSize.Width < (texturesize.Location.X + texturesize.Size.Width)))
 			{
 				texturesizetimer.Start();
 			}
 			else
 			{
 				texturesizetimer.Stop();
 				ImageBrowserItem lvi = (list.SelectedItems[0] as ImageBrowserItem);
 				if(lvi.icon.IsPreviewLoaded)
 					texturesize.Text = lvi.icon.Width + " x " + lvi.icon.Height;
 				else
 					texturesize.Text = "unknown";
 				texturesize.Visible = true;
 				texturesizelabel.Visible = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ThingsFlagsCompare.cs" startline="108" endline="137">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// Compares the flag of the two things.
 		// Returns
 		// -1 if the flag does not overlap
 		//	0 if the flag should be ignored
 		//	1 if the flag overlaps
 		public int Compare(Thing t1, Thing t2)
 		{
 			bool t1flag;
 			bool t2flag;
 
 			// Check if the flags exist
 			if (!t1.Flags.ContainsKey(flag) || !t2.Flags.ContainsKey(flag))
 				return 0;
 
 			// tag flag inversion into account
 			t1flag = invert ? !t1.Flags[flag] 
 			t2flag = invert ? !t2.Flags[flag] 
 
 			if (comparemethod == CompareMethod.And && (t1flag && t2flag))
 				return 1;
 			else if (comparemethod == CompareMethod.Equal && (t1flag == t2flag))
 				return 1;
 	
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Vertex.cs" startline="90" endline="125">
<![CDATA[
 
 		// Disposer
 		public override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Already set isdisposed so that changes can be prohibited
 				isdisposed = true;
 
 				if(map.AutoRemove)
 				{
 					// Dispose the lines that are attached to this vertex
 					// because a linedef cannot exist without 2 vertices.
 					foreach(Linedef ld in linedefs) ld.Dispose();
 				}
 				else
 				{
 					// Detach from linedefs
 					foreach(Linedef ld in linedefs) ld.DetachVertexP(this);
 				}
 				
 				if(map == General.Map.Map)
 					General.Map.UndoRedo.RecRemVertex(this);
 				
 				// Remove from main list
 				map.RemoveVertex(listindex);
 
 				// Clean up
 				linedefs = null;
 				map = null;
 
 				// Dispose base
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="775" endline="818">
<![CDATA[
 
 		// This splits this line by vertex v
 		// Returns the new line resulting from the split, or null when it failed
 		public Linedef Split(Vertex v)
 		{
 			Linedef nl;
 			Sidedef nsd;
 
 			// Copy linedef and change vertices
 			nl = map.CreateLinedef(v, end);
 			if(nl == null) return null;
 			CopyPropertiesTo(nl);
 			SetEndVertex(v);
 			nl.Selected = this.Selected;
 			nl.marked = this.marked;
 			
 			// Copy front sidedef if exists
 			if(front != null)
 			{
 				nsd = map.CreateSidedef(nl, true, front.Sector);
 				if(nsd == null) return null;
 				front.CopyPropertiesTo(nsd);
 				nsd.Marked = front.Marked;
 
 				// Make texture offset adjustments
 				nsd.OffsetX += (int)Vector2D.Distance(this.start.Position, this.end.Position);
 			}
 
 			// Copy back sidedef if exists
 			if(back != null)
 			{
 				nsd = map.CreateSidedef(nl, false, back.Sector);
 				if(nsd == null) return null;
 				back.CopyPropertiesTo(nsd);
 				nsd.Marked = back.Marked;
 				
 				// Make texture offset adjustments
 				back.OffsetX += (int)Vector2D.Distance(nl.start.Position, nl.end.Position);
 			}
 
 			// Return result
 			General.Map.IsChanged = true;
 			return nl;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1731" endline="1758">
<![CDATA[
 		
 		// This adds an editing mode button to the toolbar and edit menu
 		internal void AddEditModeButton(EditModeInfo modeinfo)
 		{
 			ToolStripItem item;
 			int index;
 
 			string controlname = modeinfo.ButtonDesc.Replace("&", "&&");
 			
 			// Create a button
 			index = toolbar.Items.IndexOf(seperatormodes);
 			item = new ToolStripButton(modeinfo.ButtonDesc, modeinfo.ButtonImage, new EventHandler(EditModeButtonHandler));
 			item.DisplayStyle = ToolStripItemDisplayStyle.Image;
 			item.Tag = modeinfo;
 			toolbar.Items.Insert(index, item);
 			editmodeitems.Add(item);
 			
 			// Create menu item
 			index = menumode.DropDownItems.Count;
 			item = new ToolStripMenuItem(controlname, modeinfo.ButtonImage, new EventHandler(EditModeButtonHandler));
 			item.Tag = modeinfo;
 			menumode.DropDownItems.Insert(index, item);
 			editmodeitems.Add(item);
 			item.Visible = true;
 			
 			ApplyShortcutKeys(menumode.DropDownItems);
 			UpdateSeparators();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="97" endline="126">
<![CDATA[
 		
 		// This will show a fixed list
 		public void FixedResourceLocationList(DataLocationList list)
 		{
 			// Start editing list
 			resourceitems.BeginUpdate();
 			
 			// Go for all items
 			for(int i = resourceitems.Items.Count - 1; i >= 0; i--)
 			{
 				// Remove item if fixed
 				if(resourceitems.Items[i].ForeColor != SystemColors.WindowText)
 					resourceitems.Items.RemoveAt(i);
 			}
 			for(int i = resourceitems.Items.Count - 1; i >= 0; i--)
 			{
 				// Remove item if fixed
 				if(resourceitems.Items[i].ForeColor != SystemColors.WindowText)
 					resourceitems.Items.RemoveAt(i);
 			}
 			
 			// Go for all items
 			for(int i = list.Count - 1; i >= 0; i--)
 			{
 				// Add item as fixed
 				resourceitems.Items.Insert(0, new ListViewItem(list[i].location));
 				resourceitems.Items[0].Tag = list[i];
 				resourceitems.Items[0].ImageIndex = GetIconIndex(list[i].type, true);
 
 				// Set disabled
 				resourceitems.Items[0].ForeColor = SystemColors.GrayText;
 			}
 			for(int i = list.Count - 1; i >= 0; i--)
 			{
 				// Add item as fixed
 				resourceitems.Items.Insert(0, new ListViewItem(list[i].location));
 				resourceitems.Items[0].Tag = list[i];
 				resourceitems.Items[0].ImageIndex = GetIconIndex(list[i].type, true);
 
 				// Set disabled
 				resourceitems.Items[0].ForeColor = SystemColors.GrayText;
 			}
 
 			// Done
 			resourceitems.EndUpdate();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\ShaderManager.cs" startline="111" endline="122">
<![CDATA[
 
 		#endregion
 
 		#region ================== Resources
 
 		// Clean up resources
 		public void UnloadResource()
 		{
 			display2dshader.Dispose();
 			things2dshader.Dispose();
 			world3dshader.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2118" endline="2127">
<![CDATA[
 
 		// Action to toggle snap to grid
 		[BeginAction("togglesnap")]
 		internal void ToggleSnapToGrid()
 		{
 			buttonsnaptogrid.Checked = !buttonsnaptogrid.Checked;
 			itemsnaptogrid.Checked = buttonsnaptogrid.Checked;
 			string onoff = buttonsnaptogrid.Checked ? "ON" 
 			DisplayStatus(StatusType.Action, "Snap to grid is now " + onoff + " by default.");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2128" endline="2137">
<![CDATA[
 
 		// Action to toggle auto merge
 		[BeginAction("toggleautomerge")]
 		internal void ToggleAutoMerge()
 		{
 			buttonautomerge.Checked = !buttonautomerge.Checked;
 			itemautomerge.Checked = buttonautomerge.Checked;
 			string onoff = buttonautomerge.Checked ? "ON" 
 			DisplayStatus(StatusType.Action, "Snap to geometry is now " + onoff + " by default.");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="725" endline="732">
<![CDATA[
 		
 		// Undo clicked
 		private void buttonundo_Click(object sender, EventArgs e)
 		{
 			ScriptDocumentTab t = (tabs.SelectedTab as ScriptDocumentTab);
 			t.Undo();
 			UpdateToolbar(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="733" endline="740">
<![CDATA[
 		
 		// Redo clicked
 		private void buttonredo_Click(object sender, EventArgs e)
 		{
 			ScriptDocumentTab t = (tabs.SelectedTab as ScriptDocumentTab);
 			t.Redo();
 			UpdateToolbar(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="741" endline="748">
<![CDATA[
 		
 		// Cut clicked
 		private void buttoncut_Click(object sender, EventArgs e)
 		{
 			ScriptDocumentTab t = (tabs.SelectedTab as ScriptDocumentTab);
 			t.Cut();
 			UpdateToolbar(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="749" endline="756">
<![CDATA[
 		
 		// Copy clicked
 		private void buttoncopy_Click(object sender, EventArgs e)
 		{
 			ScriptDocumentTab t = (tabs.SelectedTab as ScriptDocumentTab);
 			t.Copy();
 			UpdateToolbar(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="757" endline="764">
<![CDATA[
 
 		// Paste clicked
 		private void buttonpaste_Click(object sender, EventArgs e)
 		{
 			ScriptDocumentTab t = (tabs.SelectedTab as ScriptDocumentTab);
 			t.Paste();
 			UpdateToolbar(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="408" endline="418">
<![CDATA[
 		
 		// This destroys the Direct3D texture
 		public void ReleaseTexture()
 		{
 			lock(this)
 			{
 				// Trash it
 				if(texture != null) texture.Dispose();
 				texture = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\VertexEditForm.cs" startline="8" endline="77">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public VertexEditForm()
 		{
 			InitializeComponent();
 
 			// Fill universal fields list
 			fieldslist.ListFixedFields(General.Map.Config.VertexFields);
 
 			// Custom fields?
 			if(!General.Map.FormatInterface.HasCustomFields)
 				tabs.TabPages.Remove(tabcustom);
 			
 			// Decimals allowed?
 			if(General.Map.FormatInterface.VertexDecimals > 0)
 			{
 				positionx.AllowDecimal = true;
 				positiony.AllowDecimal = true;
 			}
 
 			// Initialize custom fields editor
 			fieldslist.Setup("vertex");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1531" endline="1587">
<![CDATA[
 		internal void ReloadResources()
 		{
 			DataLocation maplocation;
 			StatusInfo oldstatus;
 			Cursor oldcursor;
 			
 			// Keep old display info
 			oldstatus = General.MainWindow.Status;
 			oldcursor = Cursor.Current;
 			
 			// Show status
 			General.MainWindow.DisplayStatus(StatusType.Busy, "Reloading data resources...");
 			Cursor.Current = Cursors.WaitCursor;
 			
 			// Clean up
 			data.Dispose();
 			data = null;
 			config = null;
 			configinfo = null;
 			GC.Collect();
 			GC.WaitForPendingFinalizers();
 			
 			// Reload game configuration
 			General.WriteLogLine("Reloading game configuration...");
 			configinfo = General.GetConfigurationInfo(options.ConfigFile);
 			config = new GameConfiguration(General.LoadGameConfiguration(options.ConfigFile));
 			General.Editing.UpdateCurrentEditModes();
 			
 			// Reload data resources
 			General.WriteLogLine("Reloading data resources...");
 			data = new DataManager();
 			if(!string.IsNullOrEmpty(filepathname))
 			{
 				maplocation = new DataLocation(DataLocation.RESOURCE_WAD, filepathname, false, false, false);
 				data.Load(configinfo.Resources, options.Resources, maplocation);
 			}
 			else
 			{
 				data.Load(configinfo.Resources, options.Resources);
 			}
 			
 			// Apply new settings to map elements
 			map.UpdateConfiguration();
 
 			// Re-link the background image
 			grid.LinkBackground();
 			
 			// Inform all plugins that the resources are reloaded
 			General.Plugins.ReloadResources();
 			
 			// Inform editing mode that the resources are reloaded
 			if(General.Editing.Mode != null) General.Editing.Mode.OnReloadResources();
 			
 			// Reset status
 			General.MainWindow.DisplayStatus(oldstatus);
 			Cursor.Current = oldcursor;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\OpenMapOptionsForm.cs" startline="315" endline="363">
<![CDATA[
 		
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Configuration selected?
 			if(config.SelectedIndex == -1)
 			{
 				// Select a configuration!
 				MessageBox.Show(this, "Please select a game configuration to use for editing your map.", Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Warning);
 				config.Focus();
 				return;
 			}
 			
 			// Collect information
 			ConfigurationInfo configinfo = General.Configs[config.SelectedIndex];
 			DataLocationList locations = datalocations.GetResources();
 			
 			// No map selected?
 			if(mapslist.SelectedItems.Count == 0)
 			{
 				// Choose a map!
 				MessageBox.Show(this, "Please select a map to load for editing.", Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Warning);
 				mapslist.Focus();
 				return;
 			}
 			
 			// Check if we should warn the user for missing resources
 			if((wadfile.Type != WAD.TYPE_IWAD) && (locations.Count == 0) && (configinfo.Resources.Count == 0))
 			{
 				if(MessageBox.Show(this, "You are about to load a map without selecting any resources. Textures, flats and " +
 										 "sprites may not be shown correctly or may not show up at all. Do you want to continue?", Application.ProductName,
 										 MessageBoxButtons.YesNo, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button2) == DialogResult.No)
 				{
 					return;
 				}
 			}
 			
 			// Apply changes
 			options.ClearResources();
 			options.ConfigFile = configinfo.Filename;
 			options.CurrentName = mapslist.SelectedItems[0].Text;
 			options.StrictPatches = strictpatches.Checked;
 			options.CopyResources(locations);
 
 			// Hide window
 			wadfile.Dispose();
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="920" endline="928">
<![CDATA[
 
 		internal void PlayPrpVertex(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			Vertex v = General.Map.Map.GetVertexByIndex(index);
 			v.ReadWrite(ds);
 			v.Marked = true;
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1216" endline="1225">
<![CDATA[
 
 		internal void PlayRemSector(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			//LogRecordInfo("PLY
 			Sector s = General.Map.Map.CreateSector(index);
 			s.ReadWrite(ds);
 			s.Marked = true;
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1276" endline="1285">
<![CDATA[
 
 		internal void PlayRemThing(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			//LogRecordInfo("PLY
 			Thing t = General.Map.Map.CreateThing(index);
 			t.ReadWrite(ds);
 			t.Marked = true;
 			populationchanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DDevice.cs" startline="383" endline="441">
<![CDATA[
 		
 		// This resets the device and returns true on success
 		internal bool Reset()
 		{
 			PresentParameters displaypp;
 
 			// Test the cooperative level
 			Result coopresult = device.TestCooperativeLevel();
 			
 			// Can we reset?
 			//if(coopresult.Name != "D3DERR_DEVICENOTRESET")
 			{
 				// Unload all Direct3D resources
 				foreach(ID3DResource res in resources.Values) res.UnloadResource();
 
 				// Lose backbuffers
 				if(backbuffer != null) backbuffer.Dispose();
 				if(depthbuffer != null) depthbuffer.Dispose();
 				backbuffer = null;
 				depthbuffer = null;
 
 				// Make present parameters
 				displaypp = CreatePresentParameters(adapter);
 
 				try
 				{
 					// Reset the device
 					device.Reset(displaypp);
 				}
 				catch(Exception)
 				{
 					// Failed to re-initialize
 					return false;
 				}
 
 				// Keep a reference to the original buffers
 				backbuffer = device.GetBackBuffer(0, 0);
 				depthbuffer = device.DepthStencilSurface;
 
 				// Get the viewport
 				viewport = device.Viewport;
 
 				// Reload all Direct3D resources
 				foreach(ID3DResource res in resources.Values) res.ReloadResource();
 
 				// Re-apply settings
 				SetupSettings();
 				
 				// Success
 				return true;
 			}
 			/*
 			else
 			{
 				// Failed
 				return false;
 			}
 			*/
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2453" endline="2479">
<![CDATA[
 
 		// Show sector info
 		public void ShowSectorInfo(Sector s)
 		{
 			if(s.IsDisposed)
 			{
 				HideInfo();
 				return;
 			}
 
 			lastinfoobject = s;
 			modename.Visible = false;
 			if(linedefinfo.Visible) linedefinfo.Hide();
 			if(vertexinfo.Visible) vertexinfo.Hide();
 			if(thinginfo.Visible) thinginfo.Hide();
 			if(IsInfoPanelExpanded) sectorinfo.ShowInfo(s);
 
 			// Show info on collapsed label
 			if(General.Map.Config.SectorEffects.ContainsKey(s.Effect))
 				labelcollapsedinfo.Text = General.Map.Config.SectorEffects[s.Effect].ToString();
 			else if(s.Effect == 0)
 				labelcollapsedinfo.Text = s.Effect.ToString() + " - Normal";
 			else
 				labelcollapsedinfo.Text = s.Effect.ToString() + " - Unknown";
 
 			labelcollapsedinfo.Refresh();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2138" endline="2177">
<![CDATA[
 		
 		#endregion
 
 		#region ================== View Menu
 
 		// This sets up the modes menu
 		private void UpdateViewMenu()
 		{
 			// Menu items
 			itemthingsfilter.Enabled = (General.Map != null);
 			itemscripteditor.Enabled = (General.Map != null);
 			itemfittoscreen.Enabled = (General.Map != null);
 			menuzoom.Enabled = (General.Map != null);
 			itemtoggleinfo.Checked = IsInfoPanelExpanded;
 			
 			// View mode items
 			for(int i = 0; i < Renderer2D.NUM_VIEW_MODES; i++)
 			{
 				// NOTE
 				// need to be disabled for non-classic modes
 				if(General.Map == null)
 				{
 					viewmodesbuttons[i].Enabled = false;
 					viewmodesbuttons[i].Checked = false;
 					viewmodesitems[i].Enabled = false;
 					viewmodesitems[i].Checked = false;
 				}
 				else
 				{
 					// Check the correct item
 					viewmodesbuttons[i].Checked = (i == (int)General.Map.CRenderer2D.ViewMode);
 					viewmodesitems[i].Checked = (i == (int)General.Map.CRenderer2D.ViewMode);
 				}
 			}
 			for(int i = 0; i < Renderer2D.NUM_VIEW_MODES; i++)
 			{
 				// NOTE
 				// need to be disabled for non-classic modes
 				if(General.Map == null)
 				{
 					viewmodesbuttons[i].Enabled = false;
 					viewmodesbuttons[i].Checked = false;
 					viewmodesitems[i].Enabled = false;
 					viewmodesitems[i].Checked = false;
 				}
 				else
 				{
 					// Check the correct item
 					viewmodesbuttons[i].Checked = (i == (int)General.Map.CRenderer2D.ViewMode);
 					viewmodesitems[i].Checked = (i == (int)General.Map.CRenderer2D.ViewMode);
 				}
 			}
 			
 			// Toolbar icons
 			thingfilters.Enabled = (General.Map != null);
 			buttonthingsfilter.Enabled = (General.Map != null);
 			buttonscripteditor.Enabled = (General.Map != null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ErrorsForm.cs" startline="88" endline="94">
<![CDATA[
 
 		// Closing
 		private void ErrorsForm_FormClosing(object sender, FormClosingEventArgs e)
 		{
 			checkerrors.Stop();
 			General.Settings.ShowErrorsWindow = checkshow.Checked;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ActionSelectorControl.cs" startline="186" endline="216">
<![CDATA[
 
 		// Number changes
 		private void number_TextChanged(object sender, EventArgs e)
 		{
 			int itemindex = -1;
 			INumberedTitle item;
 			
 			// Not nothing?
 			if(number.Text.Length > 0)
 			{
 				// Find the index in the list
 				for(int i = 0; i < list.Items.Count; i++)
 				{
 					// This is the item we're looking for?
 					item = (INumberedTitle)list.Items[i];
 					if(item.Index.ToString() == number.Text)
 					{
 						// Found it
 						itemindex = i;
 						break;
 					}
 				}
 				for(int i = 0; i < list.Items.Count; i++)
 				{
 					// This is the item we're looking for?
 					item = (INumberedTitle)list.Items[i];
 					if(item.Index.ToString() == number.Text)
 					{
 						// Found it
 						itemindex = i;
 						break;
 					}
 				}
 			}
 
 			// Select item
 			if(list.SelectedIndex != itemindex) list.SelectedIndex = itemindex;
 			list.Refresh();
 			
 			// Raise change event
 			if(ValueChanges != null) ValueChanges(this, EventArgs.Empty);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3FileImage.cs" startline="69" endline="117">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			// Leave when already loaded
 			if(this.IsImageLoaded) return;
 
 			lock(this)
 			{
 				// Load file data
 				if(bitmap != null) bitmap.Dispose(); bitmap = null;
 				MemoryStream filedata = datareader.ExtractFile(filepathname);
 
 				// Get a reader for the data
 				IImageReader reader = ImageDataFormat.GetImageReader(filedata, probableformat, General.Map.Data.Palette);
 				if(!(reader is UnknownImageReader))
 				{
 					// Load the image
 					filedata.Seek(0, SeekOrigin.Begin);
 					try { bitmap = reader.ReadAsBitmap(filedata); }
 					catch(InvalidDataException)
 					{
 						// Data cannot be read!
 						bitmap = null;
 					}
 				}
 				
 				// Not loaded?
 				if(bitmap == null)
 				{
 					General.ErrorLogger.Add(ErrorType.Error, "Image file '" + filepathname + "' data format could not be read, while loading texture '" + this.Name + "'");
 					loadfailed = true;
 				}
 				else
 				{
 					// Get width and height from image
 					width = bitmap.Size.Width;
 					height = bitmap.Size.Height;
 				}
 				
 				// Pass on to base
 				filedata.Dispose();
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="793" endline="818">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Things
 
 		// This finds and returns a sprite stream
 		public override List<Stream> GetDecorateData(string pname)
 		{
 			List<Stream> streams = new List<Stream>();
 			int lumpindex;
 			
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 			
 			// Find all lumps named 'DECORATE'
 			lumpindex = file.FindLumpIndex(pname);
 			while(lumpindex > -1)
 			{
 				streams.Add(file.Lumps[lumpindex].Stream);
 				
 				// Find next
 				lumpindex = file.FindLumpIndex(pname, lumpindex + 1);
 			}
 			while(lumpindex > -1)
 			{
 				streams.Add(file.Lumps[lumpindex].Stream);
 				
 				// Find next
 				lumpindex = file.FindLumpIndex(pname, lumpindex + 1);
 			}
 			
 			return streams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="478" endline="488">
<![CDATA[
 		
 		private void fieldslist_Validated(object sender, EventArgs e)
 		{
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Get selected filter
 				ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 				fieldslist.Apply(f.ThingCustomFields);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="170" endline="190">
<![CDATA[
 
 		// This adds a normal item
 		private void AddItem(DataLocation rl)
 		{
 			int index;
 
 			// Start editing list
 			resourceitems.BeginUpdate();
 
 			// Add item
 			index = resourceitems.Items.Count;
 			resourceitems.Items.Add(new ListViewItem(rl.location));
 			resourceitems.Items[index].Tag = rl;
 			resourceitems.Items[index].ImageIndex = GetIconIndex(rl.type, false);
 			
 			// Set normal color
 			resourceitems.Items[index].ForeColor = SystemColors.WindowText;
 
 			// Done
 			resourceitems.EndUpdate();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="99" endline="168">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public Playpal Palette { get { return palette; } }
 		public PreviewManager Previews { get { return previews; } }
 		public ICollection<ImageData> Textures { get { return textures.Values; } }
 		public ICollection<ImageData> Flats { get { return flats.Values; } }
 		public List<string> TextureNames { get { return texturenames; } }
 		public List<string> FlatNames { get { return flatnames; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		public ImageData MissingTexture3D { get { return missingtexture3d; } }
 		public ImageData UnknownTexture3D { get { return unknowntexture3d; } }
 		public ImageData Hourglass3D { get { return hourglass3d; } }
 		public ImageData Crosshair3D { get { return crosshair; } }
 		public ImageData CrosshairBusy3D { get { return crosshairbusy; } }
 		public ImageData ThingBox { get { return thingbox; } }
 		public ImageData WhiteTexture { get { return whitetexture; } }
 		public List<ThingCategory> ThingCategories { get { return thingcategories; } }
 		public ICollection<ThingTypeInfo> ThingTypes { get { return thingtypes.Values; } }
 		public DecorateParser Decorate { get { return decorate; } }
 		internal ICollection<MatchingTextureSet> TextureSets { get { return texturesets; } }
 		internal ICollection<ResourceTextureSet> ResourceTextureSets { get { return resourcetextures; } }
 		internal AllTextureSet AllTextureSet { get { return alltextures; } }
 		
 		public bool IsLoading
 		{
 			get
 			{
 				if(imageque != null)
 				{
 					return (backgroundloader != null) && backgroundloader.IsAlive && ((imageque.Count > 0) || previews.IsLoading);
 				}
 				else
 				{
 					return false;
 				}
 			}
 		}
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal DataManager()
 		{
 			// We have no destructor
 			GC.SuppressFinalize(this);
 
 			// Load special images
 			missingtexture3d = new ResourceImage("CodeImp.DoomBuilder.Resources.MissingTexture3D.png");
 			missingtexture3d.LoadImage();
 			unknowntexture3d = new ResourceImage("CodeImp.DoomBuilder.Resources.UnknownTexture3D.png");
 			unknowntexture3d.LoadImage();
 			hourglass3d = new ResourceImage("CodeImp.DoomBuilder.Resources.Hourglass3D.png");
 			hourglass3d.LoadImage();
 			crosshair = new ResourceImage("CodeImp.DoomBuilder.Resources.Crosshair.png");
 			crosshair.LoadImage();
 			crosshairbusy = new ResourceImage("CodeImp.DoomBuilder.Resources.CrosshairBusy.png");
 			crosshairbusy.LoadImage();
 			thingbox = new ResourceImage("CodeImp.DoomBuilder.Resources.ThingBox.png");
 			thingbox.LoadImage();
 			whitetexture = new ResourceImage("CodeImp.DoomBuilder.Resources.White.png");
 			whitetexture.UseColorCorrection = false;
 			whitetexture.LoadImage();
 			whitetexture.CreateTexture();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingBrowserControl.cs" startline="261" endline="273">
<![CDATA[
 
 		private void ThingBrowserControl_SizeChanged(object sender, EventArgs e)
 		{
 			infopanel.Top = this.ClientSize.Height - infopanel.Height;
 			infopanel.Width = this.ClientSize.Width;
 			typelist.Width = this.ClientSize.Width;
 			typelist.Height = infopanel.Top;
 
 			blockingcaption.Left = infopanel.Width / 2;
 			blockinglabel.Left = blockingcaption.Right + blockingcaption.Margin.Right;
 			sizecaption.Left = blockingcaption.Right - sizecaption.Width;
 			sizelabel.Left = sizecaption.Right + sizecaption.Margin.Right;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListView.cs" startline="214" endline="241">
<![CDATA[
 
 		// When items are first dragged over
 		protected override void OnDragEnter(DragEventArgs e)
 		{
 			// Pass on to base
 			base.OnDragEnter(e);
 
 			// Check if our data format is present
 			if(!e.Data.GetDataPresent(DataFormats.Text))
 			{
 				// No effect
 				e.Effect = DragDropEffects.None;
 				return;
 			}
 
 			// Check if the data matches our data
 			String text = (String)e.Data.GetData(DRAG_TYPE.GetType());
 			if(text.CompareTo(DRAG_TYPE + base.Name) == 0)
 			{
 				// We're moving these items
 				e.Effect = DragDropEffects.Move;
 			}
 			else
 			{
 				// No effect
 				e.Effect = DragDropEffects.None;	
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ActionBrowserForm.cs" startline="165" endline="209">
<![CDATA[
 		
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			GeneralizedCategory sc;
 			
 			// Presume no result
 			selectedaction = 0;
 			
 			// Predefined action?
 			if(tabs.SelectedTab == tabactions)
 			{
 				// Action node selected?
 				if((actions.SelectedNode != null) && (actions.SelectedNode.Tag is LinedefActionInfo))
 				{
 					// Our result
 					selectedaction = (actions.SelectedNode.Tag as LinedefActionInfo).Index;
 				}
 			}
 			// Generalized action
 			else
 			{
 				// Category selected?
 				if(category.SelectedIndex > -1)
 				{
 					// Add category bits and go for all options
 					sc = category.SelectedItem as GeneralizedCategory;
 					selectedaction = sc.Offset;
 					for(int i = 0; i < MAX_OPTIONS; i++)
 					{
 						// Option used?
 						if(i < sc.Options.Count)
 						{
 							// Add selected bits
 							if(options[i].SelectedIndex > -1)
 								selectedaction += (options[i].SelectedItem as GeneralizedBit).Index;
 						}
 					}
 					for(int i = 0; i < MAX_OPTIONS; i++)
 					{
 						// Option used?
 						if(i < sc.Options.Count)
 						{
 							// Add selected bits
 							if(options[i].SelectedIndex > -1)
 								selectedaction += (options[i].SelectedItem as GeneralizedBit).Index;
 						}
 					}
 				}
 			}
 			
 			// Done
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1930" endline="1971">
<![CDATA[
 
 		// This sets the recent files from configuration
 		private void CreateRecentFiles()
 		{
 			int insertindex;
 			bool anyitems = false;
 			string filename;
 			
 			// Where to insert
 			insertindex = menufile.DropDownItems.IndexOf(itemnorecent);
 			
 			// Create all items
 			recentitems = new ToolStripMenuItem[MAX_RECENT_FILES];
 			for(int i = 0; i < MAX_RECENT_FILES; i++)
 			{
 				// Create item
 				recentitems[i] = new ToolStripMenuItem("");
 				recentitems[i].Tag = "";
 				recentitems[i].Click += new EventHandler(recentitem_Click);
 				menufile.DropDownItems.Insert(insertindex + i, recentitems[i]);
 
 				// Get configuration setting
 				filename = General.Settings.ReadSetting("recentfiles.file" + i, "");
 				if(filename != "")
 				{
 					// Set up item
 					int number = i + 1;
 					recentitems[i].Text = "&" + number.ToString() + "  " + GetDisplayFilename(filename);
 					recentitems[i].Tag = filename;
 					recentitems[i].Visible = true;
 					anyitems = true;
 				}
 				else
 				{
 					// Hide item
 					recentitems[i].Visible = false;
 				}
 			}
 			for(int i = 0; i < MAX_RECENT_FILES; i++)
 			{
 				// Create item
 				recentitems[i] = new ToolStripMenuItem("");
 				recentitems[i].Tag = "";
 				recentitems[i].Click += new EventHandler(recentitem_Click);
 				menufile.DropDownItems.Insert(insertindex + i, recentitems[i]);
 
 				// Get configuration setting
 				filename = General.Settings.ReadSetting("recentfiles.file" + i, "");
 				if(filename != "")
 				{
 					// Set up item
 					int number = i + 1;
 					recentitems[i].Text = "&" + number.ToString() + "  " + GetDisplayFilename(filename);
 					recentitems[i].Tag = filename;
 					recentitems[i].Visible = true;
 					anyitems = true;
 				}
 				else
 				{
 					// Hide item
 					recentitems[i].Visible = false;
 				}
 			}
 
 			// Hide the no recent item when there are items
 			itemnorecent.Visible = !anyitems;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="303" endline="327">
<![CDATA[
 		
 		// This ends add/remove operations and crops the arrays
 		public void EndAddRemove()
 		{
 			if(freezearrays > 0)
 				freezearrays--;
 
 			if(freezearrays == 0)
 			{
 				if(numvertices < vertices.Length)
 					Array.Resize(ref vertices, numvertices);
 
 				if(numlinedefs < linedefs.Length)
 					Array.Resize(ref linedefs, numlinedefs);
 
 				if(numsidedefs < sidedefs.Length)
 					Array.Resize(ref sidedefs, numsidedefs);
 
 				if(numsectors < sectors.Length)
 					Array.Resize(ref sectors, numsectors);
 
 				if(numthings < things.Length)
 					Array.Resize(ref things, numthings);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="350" endline="379">
<![CDATA[
 		
 		// This updates the line when changes have been made
 		public void UpdateCache()
 		{
 			// Update if needed
 			if(updateneeded)
 			{
 				// Delta vector
 				Vector2D delta = end.Position - start.Position;
 
 				// Recalculate values
 				lengthsq = delta.GetLengthSq();
 				length = (float)Math.Sqrt(lengthsq);
 				if(length > 0f) lengthinv = 1f / length; else lengthinv = 1f / 0.0000000001f;
 				if(lengthsq > 0f) lengthsqinv = 1f / lengthsq; else lengthsqinv = 1f / 0.0000000001f;
 				angle = delta.GetAngle();
 				float l = Math.Min(start.Position.x, end.Position.x);
 				float t = Math.Min(start.Position.y, end.Position.y);
 				float r = Math.Max(start.Position.x, end.Position.x);
 				float b = Math.Max(start.Position.y, end.Position.y);
 				rect = new RectangleF(l, t, r - l, b - t);
 				
 				// Cached flags
 				blocksoundflag = IsFlagSet(General.Map.Config.SoundLinedefFlag);
 				impassableflag = IsFlagSet(General.Map.Config.ImpassableFlag);
 				
 				// Updated
 				updateneeded = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="618" endline="639">
<![CDATA[
 
 		// Time to delete rows
 		private void deleterowstimer_Tick(object sender, EventArgs e)
 		{
 			// Stop timer
 			deleterowstimer.Stop();
 			
 			// Delete all rows that must be deleted
 			for(int i = fieldslist.Rows.Count - 1; i >= 0; i--)
 			{
 				if(fieldslist.Rows[i].ReadOnly)
 					try { fieldslist.Rows.RemoveAt(i); } catch(Exception) { }
 				else
 					fieldslist.Rows[i].Visible = true;
 			}
 			for(int i = fieldslist.Rows.Count - 1; i >= 0; i--)
 			{
 				if(fieldslist.Rows[i].ReadOnly)
 					try { fieldslist.Rows.RemoveAt(i); } catch(Exception) { }
 				else
 					fieldslist.Rows[i].Visible = true;
 			}
 
 			// Update new row
 			SetupNewRowStyle();
 			
 			// Update button
 			UpdateBrowseButton();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="374" endline="384">
<![CDATA[
 		
 		private void filterangle_WhenTextChanged(object sender, EventArgs e)
 		{
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Get selected filter
 				ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 				f.ThingAngle = filterangle.GetResult(-1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="393" endline="403">
<![CDATA[
 		
 		private void filterzheight_WhenTextChanged(object sender, EventArgs e)
 		{
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Get selected filter
 				ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 				f.ThingZHeight = filterzheight.GetResult(int.MinValue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="452" endline="462">
<![CDATA[
 		
 		private void filtertag_WhenTextChanged(object sender, EventArgs e)
 		{
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Get selected filter
 				ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 				f.ThingTag = filtertag.GetResult(-1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\PluginManager.cs" startline="74" endline="87">
<![CDATA[
 
 		// Disposer
 		public void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				foreach(Plugin p in plugins) p.Dispose();
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="272" endline="298">
<![CDATA[
 
 		#endregion	
 
 		#region ================== Filter Settings
 
 		// Category changed
 		private void filtercategory_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Get selected filter
 				ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 				
 				// Category selected
 				if((filtercategory.SelectedIndex > -1) && (filtercategory.SelectedItem is ThingCategory))
 				{
 					// Set new category name
 					f.CategoryName = (filtercategory.SelectedItem as ThingCategory).Name;
 				}
 				else
 				{
 					// Unset category name
 					f.CategoryName = "";
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1484" endline="1510">
<![CDATA[
 		
 		// This sets a new mapset for editing
 		internal void ChangeMapSet(MapSet newmap)
 		{
 			// Let the plugin and editing mode know
 			General.Plugins.OnMapSetChangeBegin();
 			if(General.Editing.Mode != null) General.Editing.Mode.OnMapSetChangeBegin();
 			this.visualcamera.Sector = null;
 
 			// Can't have a selection in an old map set
 			map.ClearAllSelected();
 
 			// Reset surfaces
 			renderer2d.Surfaces.Reset();
 			
 			// Apply
 			map.Dispose();
 			map = newmap;
 			map.UpdateConfiguration();
 			map.SnapAllToAccuracy();
 			map.Update();
 			thingsfilter.Update();
 			
 			// Let the plugin and editing mode know
 			General.Plugins.OnMapSetChangeEnd();
 			if(General.Editing.Mode != null) General.Editing.Mode.OnMapSetChangeEnd();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="426" endline="457">
<![CDATA[
 
 		// This finds and adds visible sectors
 		private void ProcessSidedefCulling(Sidedef sd)
 		{
 			VisualSector vs;
 			
 			// Find the visualsector and make it if needed
 			if(allsectors.ContainsKey(sd.Sector))
 			{
 				// Take existing visualsector
 				vs = allsectors[sd.Sector];
 			}
 			else
 			{
 				// Make new visualsector
 				vs = CreateVisualSector(sd.Sector);
 				if(vs != null) allsectors.Add(sd.Sector, vs);
 			}
 			
 			if(vs != null)
 			{
 				// Add to visible sectors if not added yet
 				if(!visiblesectors.ContainsKey(sd.Sector))
 				{
 					visiblesectors.Add(sd.Sector, vs);
 					visiblegeometry.AddRange(vs.FixedGeometry);
 				}
 				
 				// Add sidedef geometry
 				visiblegeometry.AddRange(vs.GetSidedefGeometry(sd));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3Reader.cs" startline="45" endline="78">
<![CDATA[
 		public PK3Reader(DataLocation dl) 
 		{
 			General.WriteLogLine("Opening PK3 resource '" + location.location + "'");
 
 			if(!File.Exists(location.location))
 				throw new FileNotFoundException("Could not find the file \"" + location.location + "\"", location.location);
 			
 			// Open the zip file
 			ZipInputStream zipstream = OpenPK3File();
 			
 			// Make list of all files
 			List<DirectoryFileEntry> fileentries = new List<DirectoryFileEntry>();
 			ZipEntry entry = zipstream.GetNextEntry();
 			while(entry != null)
 			{
 				if(entry.IsFile) fileentries.Add(new DirectoryFileEntry(entry.Name));
 				
 				// Next
 				entry = zipstream.GetNextEntry();
 			}
 			while(entry != null)
 			{
 				if(entry.IsFile) fileentries.Add(new DirectoryFileEntry(entry.Name));
 				
 				// Next
 				entry = zipstream.GetNextEntry();
 			}
 
 			// Make files list
 			files = new DirectoryFilesList(fileentries);
 
 			// Done with the zip file
 			zipstream.Close();
 			zipstream.Dispose();
 			
 			// Initialize without path (because we use paths relative to the PK3 file)
 			Initialize();
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorRow.cs" startline="176" endline="213">
<![CDATA[
 		
 		// This is called when a cell is edited
 		public void CellChanged()
 		{
 			// This gdmn grid thing returns the chosen value as string instead
 			// of the object type I added to the combobox...
 			if(this.Cells[1].Value is string)
 			{
 				// Find the TypeHandlerAttribute with this name
 				TypeHandlerAttribute attrib = General.Types.GetNamedAttribute(this.Cells[1].Value.ToString());
 
 				// Different?
 				if(attrib.Index != fieldtype.Index)
 				{
 					// Change field type!
 					this.ChangeType(attrib.Index);
 				}
 			}
 			
 			// Anything in the box?
 			if((this.Cells[2].Value != null) && (this.Cells[2].Value.ToString().Length > 0))
 			{
 				// Validate value
 				fieldtype.SetValue(this.Cells[2].Value);
 				this.Cells[2].Value = fieldtype.GetStringValue();
 
 				// This is a fixed field?
 				if(isfixed)
 				{
 					// Does this match the default setting?
 					if(fieldtype.GetValue().Equals(fieldinfo.Default))
 					{
 						// Undefine this field!
 						Undefine();
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\VertexInfoPanel.Designer.cs" startline="22" endline="81">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.Label label1;
 			this.vertexinfo = new System.Windows.Forms.GroupBox();
 			this.position = new System.Windows.Forms.Label();
 			label1 = new System.Windows.Forms.Label();
 			this.vertexinfo.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// label1
 			// 
 			label1.AutoSize = true;
 			label1.Location = new System.Drawing.Point(13, 34);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(47, 14);
 			label1.TabIndex = 2;
 			label1.Text = "Position
 			// 
 			// vertexinfo
 			// 
 			this.vertexinfo.Controls.Add(this.position);
 			this.vertexinfo.Controls.Add(label1);
 			this.vertexinfo.Location = new System.Drawing.Point(0, 0);
 			this.vertexinfo.Name = "vertexinfo";
 			this.vertexinfo.Size = new System.Drawing.Size(163, 100);
 			this.vertexinfo.TabIndex = 0;
 			this.vertexinfo.TabStop = false;
 			this.vertexinfo.Text = " Vertex ";
 			// 
 			// position
 			// 
 			this.position.AutoSize = true;
 			this.position.Location = new System.Drawing.Point(66, 34);
 			this.position.Name = "position";
 			this.position.Size = new System.Drawing.Size(25, 14);
 			this.position.TabIndex = 3;
 			this.position.Text = "0, 0";
 			// 
 			// VertexInfoPanel
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.vertexinfo);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.MaximumSize = new System.Drawing.Size(10000, 100);
 			this.MinimumSize = new System.Drawing.Size(100, 100);
 			this.Name = "VertexInfoPanel";
 			this.Size = new System.Drawing.Size(393, 100);
 			this.vertexinfo.ResumeLayout(false);
 			this.vertexinfo.PerformLayout();
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1987" endline="2022">
<![CDATA[
 		
 		// This adds a recent file to the list
 		internal void AddRecentFile(string filename)
 		{
 			int movedownto = MAX_RECENT_FILES - 1;
 			
 			// Check if this file is already in the list
 			for(int i = 0; i < MAX_RECENT_FILES; i++)
 			{
 				// File same as this item?
 				if(string.Compare(filename, recentitems[i].Tag.ToString(), true) == 0)
 				{
 					// Move down to here so that this item will disappear
 					movedownto = i;
 					break;
 				}
 			}
 			for(int i = 0; i < MAX_RECENT_FILES; i++)
 			{
 				// File same as this item?
 				if(string.Compare(filename, recentitems[i].Tag.ToString(), true) == 0)
 				{
 					// Move down to here so that this item will disappear
 					movedownto = i;
 					break;
 				}
 			}
 			
 			// Go for all items, except the last one, backwards
 			for(int i = movedownto - 1; i >= 0; i--)
 			{
 				// Move recent file down the list
 				int number = i + 2;
 				recentitems[i + 1].Text = "&" + number.ToString() + "  " + GetDisplayFilename(recentitems[i].Tag.ToString());
 				recentitems[i + 1].Tag = recentitems[i].Tag.ToString();
 				recentitems[i + 1].Visible = (recentitems[i].Tag.ToString() != "");
 			}
 			for(int i = movedownto - 1; i >= 0; i--)
 			{
 				// Move recent file down the list
 				int number = i + 2;
 				recentitems[i + 1].Text = "&" + number.ToString() + "  " + GetDisplayFilename(recentitems[i].Tag.ToString());
 				recentitems[i + 1].Tag = recentitems[i].Tag.ToString();
 				recentitems[i + 1].Visible = (recentitems[i].Tag.ToString() != "");
 			}
 
 			// Add new file at the top
 			recentitems[0].Text = "&1  " + GetDisplayFilename(filename);
 			recentitems[0].Tag = filename;
 			recentitems[0].Visible = true;
 
 			// Hide the no recent item
 			itemnorecent.Visible = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DDevice.cs" startline="261" endline="332">
<![CDATA[
 		
 		// This initializes the graphics
 		public bool Initialize()
 		{
 			PresentParameters displaypp;
 			DeviceType devtype;
 			
 			// Use default adapter
 			this.adapter = 0; // Manager.Adapters.Default.Adapter;
 
 			try
 			{
 				// Make present parameters
 				displaypp = CreatePresentParameters(adapter);
 
 				// Determine device type for compatability with NVPerfHUD
 				if(d3d.Adapters[adapter].Details.Description.EndsWith(NVPERFHUD_ADAPTER))
 					devtype = DeviceType.Reference;
 				else
 					devtype = DeviceType.Hardware;
 
 				// Get the device capabilities
 				devicecaps = d3d.GetDeviceCaps(adapter, devtype);
 
 				// Check if this adapter supports TnL
 				if((devicecaps.DeviceCaps & DeviceCaps.HWTransformAndLight) != 0)
 				{
 					// Initialize with hardware TnL
 					device = new Device(d3d, adapter, devtype, rendertarget.Handle,
 								CreateFlags.HardwareVertexProcessing, displaypp);
 				}
 				else
 				{
 					// Initialize with software TnL
 					device = new Device(d3d, adapter, devtype, rendertarget.Handle,
 								CreateFlags.SoftwareVertexProcessing, displaypp);
 				}
 			}
 			catch(Exception)
 			{
 				// Failed
 				MessageBox.Show(General.MainWindow, "Unable to initialize the Direct3D video device. Another application may have taken exclusive mode on this video device or the device does not support Direct3D at all.", Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Error);
 				return false;
 			}
 
 			// Add event to cancel resize event
 			//device.DeviceResizing += new CancelEventHandler(CancelResize);
 
 			// Keep a reference to the original buffers
 			backbuffer = device.GetBackBuffer(0, 0);
 			depthbuffer = device.DepthStencilSurface;
 
 			// Get the viewport
 			viewport = device.Viewport;
 
 			// Create shader manager
 			shaders = new ShaderManager(this);
 			
 			// Font
 			postfilter = Filter.Box;		// Only for the font. This will be reset in SetupSettings (see below)
 			font = new TextFont();
 			fonttexture = new ResourceImage("CodeImp.DoomBuilder.Resources.Font.png");
 			fonttexture.LoadImage();
 			fonttexture.MipMapLevels = 2;
 			fonttexture.CreateTexture();
 			
 			// Initialize settings
 			SetupSettings();
 			
 			// Done
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="532" endline="594">
<![CDATA[
 		
 		// Item selected
 		private void listactions_ItemSelectionChanged(object sender, ListViewItemSelectionChangedEventArgs e)
 		{
 			Actions.Action action;
 			KeyControl keycontrol;
 			string disregardkeys = "";
 			int key;
 
 			// Anything selected?
 			if(listactions.SelectedItems.Count > 0)
 			{
 				// Begin updating
 				allowapplycontrol = false;
 
 				// Get the selected action
 				action = General.Actions[listactions.SelectedItems[0].Name];
 				key = (int)listactions.SelectedItems[0].SubItems[1].Tag;
 				disregardshift = action.DisregardShift;
 				disregardcontrol = action.DisregardControl;
 				
 				// Enable panel
 				actioncontrolpanel.Enabled = true;
 				actiontitle.Text = action.Title;
 				actiondescription.Text = action.Description;
 				actioncontrol.SelectedIndex = -1;
 				actionkey.Text = "";
 				
 				if(disregardshift && disregardcontrol)
 					disregardkeys = "Shift and Control";
 				else if(disregardshift)
 					disregardkeys = "Shift";
 				else if(disregardcontrol)
 					disregardkeys = "Control";
 
 				disregardshiftlabel.Text = disregardshiftlabel.Tag.ToString().Replace("%s", disregardkeys);
 				disregardshiftlabel.Visible = disregardshift | disregardcontrol;
 				
 				// Fill special controls list
 				FillControlsList(action);
 				
 				// See if the key is in the combobox
 				for(int i = 0; i < actioncontrol.Items.Count; i++)
 				{
 					// Select it when the key is found here
 					keycontrol = (KeyControl)actioncontrol.Items[i];
 					if(keycontrol.key == key) actioncontrol.SelectedIndex = i;
 				}
 				for(int i = 0; i < actioncontrol.Items.Count; i++)
 				{
 					// Select it when the key is found here
 					keycontrol = (KeyControl)actioncontrol.Items[i];
 					if(keycontrol.key == key) actioncontrol.SelectedIndex = i;
 				}
 
 				// Otherwise display the key in the textbox
 				if(actioncontrol.SelectedIndex == -1)
 					actionkey.Text = Actions.Action.GetShortcutKeyDesc(key);
 				
 				// Show actions with same key
 				UpdateKeyUsedActions();
 				
 				// Focus to the input box
 				actionkey.Focus();
 
 				// Done
 				allowapplycontrol = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="129" endline="141">
<![CDATA[
 		}
 		
 		public UndoSnapshot NextRedo
 		{
 			get
 			{
 				if(isundosnapshot && (snapshot != null))
 					return snapshot;
 				else if(redos.Count > 0)
 					return redos[0];
 				else
 					return null;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2786" endline="2807">
<![CDATA[
 		
 		// Automatic collapsing
 		private void dockerscollapser_Tick(object sender, EventArgs e)
 		{
 			if(General.Settings.CollapseDockers)
 			{
 				if(!dockerspanel.IsFocused)
 				{
 					Point p = this.PointToClient(Cursor.Position);
 					Rectangle r = new Rectangle(dockerspanel.Location, dockerspanel.Size);
 					if(!r.IntersectsWith(new Rectangle(p, Size.Empty)))
 					{
 						dockerspanel.Collapse();
 						dockerscollapser.Stop();
 					}
 				}
 			}
 			else
 			{
 				dockerscollapser.Stop();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="777" endline="821">
<![CDATA[
 
 		// This updates the button
 		private void UpdateBrowseButton()
 		{
 			FieldsEditorRow frow = null;
 			DataGridViewRow row = null;
 
 			// Any row selected?
 			if(fieldslist.SelectedRows.Count > 0)
 			{
 				// Get selected row
 				row = fieldslist.SelectedRows[0];
 				if(row is FieldsEditorRow) frow = row as FieldsEditorRow;
 
 				// Not the new row and FieldsEditorRow available?
 				if((row.Index < fieldslist.NewRowIndex) && (frow != null))
 				{
 					// Browse button available for this type?
 					if(frow.TypeHandler.IsBrowseable && !frow.TypeHandler.IsEnumerable)
 					{
 						Rectangle cellrect = fieldslist.GetCellDisplayRectangle(2, row.Index, false);
 
 						// Show button
 						enumscombo.Visible = false;
 						browsebutton.Image = frow.TypeHandler.BrowseImage;
 						browsebutton.Location = new Point(cellrect.Right - browsebutton.Width, cellrect.Top);
 						browsebutton.Height = cellrect.Height;
 						Console.WriteLine(cellrect.Height.ToString());
 						browsebutton.Visible = true;
 					}
 					else
 					{
 						HideBrowseButton();
 					}
 				}
 				else
 				{
 					HideBrowseButton();
 				}
 			}
 			else
 			{
 				HideBrowseButton();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="796" endline="828">
<![CDATA[
 
 		// This renders all grid
 		private void RenderBackgroundGrid()
 		{
 			Plotter gridplotter;
 			DataRectangle lockedrect;
 			
 			// Do we need to redraw grid?
 			if((lastgridsize != General.Map.Grid.GridSize) || (lastgridscale != scale) ||
 			   (lastgridx != offsetx) || (lastgridy != offsety))
 			{
 				// Lock background rendertarget memory
 				lockedrect = backtex.LockRectangle(0, LockFlags.NoSystemLock);
 
 				// Create a plotter
 				gridplotter = new Plotter((PixelColor*)lockedrect.Data.DataPointer.ToPointer(), lockedrect.Pitch / sizeof(PixelColor), backsize.Height, backsize.Width, backsize.Height);
 				gridplotter.Clear();
 
 				// Render normal grid
 				RenderGrid(General.Map.Grid.GridSize, General.Colors.Grid, gridplotter);
 
 				// Render 64 grid
 				if(General.Map.Grid.GridSize <= 64) RenderGrid(64f, General.Colors.Grid64, gridplotter);
 
 				// Done
 				backtex.UnlockRectangle(0);
 				lockedrect.Data.Dispose();
 				lastgridscale = scale;
 				lastgridsize = General.Map.Grid.GridSize;
 				lastgridx = offsetx;
 				lastgridy = offsety;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\OpenMapOptionsForm.cs" startline="390" endline="433">
<![CDATA[
 
 		// Map name selected
 		private void mapslist_ItemSelectionChanged(object sender, ListViewItemSelectionChangedEventArgs e)
 		{
 			DataLocationList locations;
 			DataLocationList listedlocations;
 			
 			// Map previously selected?
 			if((selectedmapname != null) && (selectedmapname != ""))
 			{
 				// Get locations from previous selected map settings
 				locations = new DataLocationList(mapsettings, "maps." + selectedmapname + ".resources");
 				listedlocations = datalocations.GetResources();
 				
 				// Remove data locations that this map has in its config
 				foreach(DataLocation dl in locations)
 					listedlocations.Remove(dl);
 				foreach(DataLocation dl in locations)
 					listedlocations.Remove(dl);
 
 				// Set new data locations
 				datalocations.EditResourceLocationList(listedlocations);
 
 				// Done
 				selectedmapname = null;
 			}
 			
 			// Anything selected?
 			if(mapslist.SelectedItems.Count > 0)
 			{
 				// Get the map name
 				selectedmapname = mapslist.SelectedItems[0].Text;
 				options = new MapOptions(mapsettings, selectedmapname);
 				
 				// Get locations from previous selected map settings
 				locations = new DataLocationList(mapsettings, "maps." + selectedmapname + ".resources");
 				listedlocations = datalocations.GetResources();
 
 				// Add data locations that this map has in its config
 				foreach(DataLocation dl in locations)
 					if(!listedlocations.Contains(dl)) listedlocations.Add(dl);
 				foreach(DataLocation dl in locations)
 					if(!listedlocations.Contains(dl)) listedlocations.Add(dl);
 
 				// Set new data locations
 				datalocations.EditResourceLocationList(listedlocations);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="186" endline="225">
<![CDATA[
 		
 		// Serialize / deserialize (passive
 		internal void ReadWrite(IReadWriteStream s)
 		{
 			if(!s.IsWriting)
 			{
 				BeforePropsChange();
 				updateneeded = true;
 			}
 			
 			base.ReadWrite(s);
 			
 			if(s.IsWriting)
 			{
 				s.wInt(flags.Count);
 				
 				foreach(KeyValuePair<string, bool> f in flags)
 				{
 					s.wString(f.Key);
 					s.wBool(f.Value);
 				}
 				foreach(KeyValuePair<string, bool> f in flags)
 				{
 					s.wString(f.Key);
 					s.wBool(f.Value);
 				}
 			}
 			else
 			{
 				int c; s.rInt(out c);
 
 				flags = new Dictionary<string, bool>(c);
 				for(int i = 0; i < c; i++)
 				{
 					string t; s.rString(out t);
 					bool b; s.rBool(out b);
 					flags.Add(t, b);
 				}
 				for(int i = 0; i < c; i++)
 				{
 					string t; s.rString(out t);
 					bool b; s.rBool(out b);
 					flags.Add(t, b);
 				}
 			}
 
 			s.rwInt(ref action);
 			s.rwInt(ref activate);
 			s.rwInt(ref tag);
 			for(int i = 0; i < NUM_ARGS; i++) s.rwInt(ref args[i]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="269" endline="326">
<![CDATA[
 
 		// This sets up the interface
 		internal void SetupInterface()
 		{
 			float scalex = this.CurrentAutoScaleDimensions.Width / this.AutoScaleDimensions.Width;
 			float scaley = this.CurrentAutoScaleDimensions.Height / this.AutoScaleDimensions.Height;
 			
 			// Setup docker
 			if(General.Settings.DockersPosition != 2)
 			{
 				LockUpdate();
 				dockerspanel.Visible = true;
 				dockersspace.Visible = true;
 
 				// We can't place the docker easily when collapsed
 				dockerspanel.Expand();
 
 				// Setup docker width
 				if(General.Settings.DockersWidth < dockerspanel.GetCollapsedWidth())
 					General.Settings.DockersWidth = dockerspanel.GetCollapsedWidth();
 
 				// Determine fixed space required
 				if(General.Settings.CollapseDockers)
 					dockersspace.Width = dockerspanel.GetCollapsedWidth();
 				else
 					dockersspace.Width = General.Settings.DockersWidth;
 
 				// Setup docker
 				if(General.Settings.DockersPosition == 0)
 				{
 					dockersspace.Dock = DockStyle.Left;
 					dockerspanel.Setup(false);
 					dockerspanel.Location = dockersspace.Location;
 					dockerspanel.Anchor = AnchorStyles.Left | AnchorStyles.Top | AnchorStyles.Bottom;
 				}
 				else
 				{
 					dockersspace.Dock = DockStyle.Right;
 					dockerspanel.Setup(true);
 					dockerspanel.Location = new Point(dockersspace.Right - General.Settings.DockersWidth, dockersspace.Top);
 					dockerspanel.Anchor = AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom;
 				}
 
 				dockerspanel.Width = General.Settings.DockersWidth;
 				dockerspanel.Height = dockersspace.Height;
 				dockerspanel.BringToFront();
 
 				if(General.Settings.CollapseDockers)
 					dockerspanel.Collapse();
 				
 				UnlockUpdate();
 			}
 			else
 			{
 				dockerspanel.Visible = false;
 				dockersspace.Visible = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2808" endline="2819">
<![CDATA[
 		
 		// User resizes the docker
 		private void dockerspanel_UserResize(object sender, EventArgs e)
 		{
 			General.Settings.DockersWidth = dockerspanel.Width;
 
 			if(!General.Settings.CollapseDockers)
 			{
 				dockersspace.Width = dockerspanel.Width;
 				dockerspanel.Left = dockersspace.Left;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptDocumentTab.cs" startline="143" endline="159">
<![CDATA[
 		
 		// This creates error marks for errors that apply to this file
 		public virtual void MarkScriptErrors(IEnumerable<CompilerError> errors)
 		{
 			// Clear all marks
 			ClearMarks();
 			
 			// Go for all errors that apply to this script
 			foreach(CompilerError e in errors)
 			{
 				if(VerifyErrorForScript(e))
 				{
 					// Add a mark on the line where this error occurred
 					editor.AddMark(e.linenumber);
 				}
 			}
 			foreach(CompilerError e in errors)
 			{
 				if(VerifyErrorForScript(e))
 				{
 					// Add a mark on the line where this error occurred
 					editor.AddMark(e.linenumber);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="355" endline="368">
<![CDATA[
 		
 		private void filtertype_ValueChanges(object sender, EventArgs e)
 		{
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Get selected filter
 				ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 				if(filtertype.Empty)
 					f.ThingType = -1;
 				else
 					f.ThingType = filtertype.GetValue();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1588" endline="1640">
<![CDATA[
 
 		// Game Configuration action
 		[BeginAction("mapoptions")]
 		internal void ShowMapOptions()
 		{
 			// Cancel volatile mode, if any
 			General.Editing.DisengageVolatileMode();
 			
 			// Show map options dialog
 			MapOptionsForm optionsform = new MapOptionsForm(options);
 			if(optionsform.ShowDialog(General.MainWindow) == DialogResult.OK)
 			{
 				// Update interface
 				General.MainWindow.UpdateInterface();
 
 				// Stop data manager
 				data.Dispose();
 				
 				// Apply new options
 				this.options = optionsform.Options;
 
 				// Load new game configuration
 				General.WriteLogLine("Loading game configuration...");
 				configinfo = General.GetConfigurationInfo(options.ConfigFile);
 				config = new GameConfiguration(General.LoadGameConfiguration(options.ConfigFile));
 				configinfo.ApplyDefaults(config);
 				General.Editing.UpdateCurrentEditModes();
 				
 				// Setup new map format IO
 				General.WriteLogLine("Initializing map format interface " + config.FormatInterface + "...");
 				io = MapSetIO.Create(config.FormatInterface, tempwad, this);
 
 				// Create required lumps if they don't exist yet
 				CreateRequiredLumps(tempwad, TEMP_MAP_HEADER);
 
 				// Let the plugins know
 				General.Plugins.MapReconfigure();
 				
 				// Update interface
 				General.MainWindow.SetupInterface();
 				General.MainWindow.UpdateThingsFilters();
 				General.MainWindow.UpdateInterface();
 				
 				// Reload resources
 				ReloadResources();
 				
 				// Done
 				General.MainWindow.DisplayReady();
 			}
 
 			// Done
 			optionsform.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="354" endline="385">
<![CDATA[
 
 		// Cell doubleclicked
 		private void fieldslist_CellDoubleClick(object sender, DataGridViewCellEventArgs e)
 		{
 			FieldsEditorRow frow = null;
 			
 			// Anything selected
 			if(fieldslist.SelectedRows.Count > 0 && e.RowIndex > -1)
 			{
 				// Get the row
 				DataGridViewRow row = fieldslist.Rows[e.RowIndex];
 				if(row is FieldsEditorRow) frow = row as FieldsEditorRow;
 				
 				// First column?
 				if(e.ColumnIndex == 0)
 				{
 					// Not a fixed field?
 					if((frow != null) && !frow.IsFixed)
 					{
 						lasteditfieldname = frow.Name;
 						fieldslist.CurrentCell = fieldslist.SelectedRows[0].Cells[0];
 						fieldslist.CurrentCell.ReadOnly = false;
 
 						if((e.RowIndex == fieldslist.NewRowIndex) ||
 						   frow.Name.StartsWith(FIELD_PREFIX_SUGGESTION, true, CultureInfo.InvariantCulture))
 							fieldslist.BeginEdit(false);
 						else
 							fieldslist.BeginEdit(true);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualBlockMap.cs" startline="114" endline="128">
<![CDATA[
 		
 		// This returns the block with the given coordinates
 		// Creates the block if it doesn't exist yet
 		public VisualBlockEntry GetBlock(Point p)
 		{
 			ulong k = GetBlockKey(p);
 			if(blockmap.ContainsKey(k))
 			{
 				return blockmap[k];
 			}
 			else
 			{
 				return (blockmap[k] = new VisualBlockEntry());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="235" endline="254">
<![CDATA[
 
 		// This determines which sector the thing is in and links it
 		public void DetermineSector(VisualBlockMap blockmap)
 		{
 			Linedef nl;
 
 			// Find nearest sectors using the blockmap
 			List<Sector> possiblesectors = blockmap.GetBlock(blockmap.GetBlockCoordinates(pos)).Sectors;
 
 			// Check in which sector we are
 			sector = null;
 			foreach(Sector s in possiblesectors)
 			{
 				if(s.Intersect(pos))
 				{
 					sector = s;
 					break;
 				}
 			}
 			foreach(Sector s in possiblesectors)
 			{
 				if(s.Intersect(pos))
 				{
 					sector = s;
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="309" endline="322">
<![CDATA[
 
 		// This clears all error marks and hides the errors list
 		public void ClearErrors()
 		{
 			// Hide list
 			splitter.Panel2Collapsed = true;
 			errorlist.Items.Clear();
 
 			// Clear marks
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				t.ClearMarks();
 			}
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				t.ClearMarks();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="840" endline="857">
<![CDATA[
 
 		// This serializes sidedefs
 		private void WriteSidedefs(SerializerStream stream)
 		{
 			stream.wInt(numsidedefs);
 
 			// Go for all sidedefs
 			foreach(Sidedef sd in sidedefs)
 			{
 				stream.wInt(sd.Line.SerializedIndex);
 				
 				stream.wInt(sd.Sector.SerializedIndex);
 
 				stream.wBool(sd.IsFront);
 
 				sd.ReadWrite(stream);
 			}
 			foreach(Sidedef sd in sidedefs)
 			{
 				stream.wInt(sd.Line.SerializedIndex);
 				
 				stream.wInt(sd.Sector.SerializedIndex);
 
 				stream.wBool(sd.IsFront);
 
 				sd.ReadWrite(stream);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="483" endline="501">
<![CDATA[
 		
 		// Paste copied texture sets
 		private void pastetexturesets_Click(object sender, EventArgs e)
 		{
 			if(copiedsets != null)
 			{
 				// Add copies
 				foreach(DefinedTextureSet ts in copiedsets)
 				{
 					DefinedTextureSet s = ts.Copy();
 					ListViewItem item = listtextures.Items.Add(s.Name);
 					item.Tag = s;
 					item.ImageIndex = 0;
 					configinfo.TextureSets.Add(s);
 				}
 				foreach(DefinedTextureSet ts in copiedsets)
 				{
 					DefinedTextureSet s = ts.Copy();
 					ListViewItem item = listtextures.Items.Add(s.Name);
 					item.Tag = s;
 					item.ImageIndex = 0;
 					configinfo.TextureSets.Add(s);
 				}
 				listtextures.Sort();
 				reloadresources = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingBrowserControl.cs" startline="183" endline="249">
<![CDATA[
 
 		// Thing type index changed
 		private void typeid_TextChanged(object sender, EventArgs e)
 		{
 			bool knownthing = false;
 
 			// Any text?
 			if(typeid.Text.Length > 0)
 			{
 				// Get the info
 				thinginfo = General.Map.Data.GetThingInfoEx(typeid.GetResult(0));
 				if(thinginfo != null)
 				{
 					knownthing = true;
 
 					// Size
 					sizelabel.Text = (thinginfo.Radius * 2) + " x " + thinginfo.Height;
 
 					// Hangs from ceiling
 					if(thinginfo.Hangs) positionlabel.Text = "Ceiling"; else positionlabel.Text = "Floor";
 
 					// Blocking
 					switch(thinginfo.Blocking)
 					{
 						case ThingTypeInfo.THING_BLOCKING_NONE
 						case ThingTypeInfo.THING_BLOCKING_FULL
 						case ThingTypeInfo.THING_BLOCKING_HEIGHT
 						default
 					}
 				}
 
 				if(doupdatenode)
 				{
 					doupdatetextbox = false;
 					int typeindex = typeid.GetResult(0);
 					typelist.SelectedNode = null;
 					foreach(TreeNode n in nodes)
 					{
 						// Matching node?
 						if((n.Tag as ThingTypeInfo).Index == typeindex)
 						{
 							// Select this
 							n.Parent.Expand();
 							typelist.SelectedNode = n;
 							n.EnsureVisible();
 						}
 					}
 					foreach(TreeNode n in nodes)
 					{
 						// Matching node?
 						if((n.Tag as ThingTypeInfo).Index == typeindex)
 						{
 							// Select this
 							n.Parent.Expand();
 							typelist.SelectedNode = n;
 							n.EnsureVisible();
 						}
 					}
 					doupdatetextbox = true;
 				}
 			}
 			else
 			{
 				thinginfo = null;
 				if(doupdatenode) typelist.SelectedNode = null;
 			}
 
 			// No known thing?
 			if(!knownthing)
 			{
 				sizelabel.Text = "-";
 				positionlabel.Text = "-";
 				blockinglabel.Text = "-";
 			}
 
 			// Raise event
 			if(OnTypeChanged != null) OnTypeChanged(thinginfo);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditingManager.cs" startline="425" endline="442">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Actions
 		
 		/// <summary>
 		/// This cancels the current mode.
 		/// </summary>
 		[BeginAction("cancelmode")]
 		public void CancelMode()
 		{
 			// Let the mode know
 			if(mode != null)
 			{
 				General.Plugins.OnEditCancel();
 				mode.OnCancel();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditingManager.cs" startline="443" endline="456">
<![CDATA[
 		
 		/// <summary>
 		/// This accepts the changes in the current mode.
 		/// </summary>
 		[BeginAction("acceptmode")]
 		public void AcceptMode()
 		{
 			// Let the mode know
 			if(mode != null)
 			{
 				General.Plugins.OnEditAccept();
 				mode.OnAccept();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingBrowserForm.Designer.cs" startline="22" endline="90">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.thingslist = new CodeImp.DoomBuilder.Controls.ThingBrowserControl();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.SuspendLayout();
 			// 
 			// thingslist
 			// 
 			this.thingslist.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.thingslist.Location = new System.Drawing.Point(9, 12);
 			this.thingslist.Name = "thingslist";
 			this.thingslist.Size = new System.Drawing.Size(394, 383);
 			this.thingslist.TabIndex = 0;
 			this.thingslist.OnTypeDoubleClicked += new CodeImp.DoomBuilder.Controls.ThingBrowserControl.TypeDoubleClickDeletegate(this.thingslist_OnTypeDoubleClicked);
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(291, 416);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 27);
 			this.cancel.TabIndex = 2;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(171, 416);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 27);
 			this.apply.TabIndex = 1;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// ThingBrowserForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(412, 453);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.thingslist);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "ThingBrowserForm";
 			this.Opacity = 0;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Edit Thing";
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlagsForm.Designer.cs" startline="22" endline="89">
<![CDATA[
 
 		#region Vom Windows Form-Designer generierter Code
 
 		/// <summary>
 		/// Erforderliche Methode f?r die Designerunterst?tzung.
 		/// Der Inhalt der Methode darf nicht mit dem Code-Editor gedert werden.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.flags = new CodeImp.DoomBuilder.Controls.CheckboxArrayControl();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.SuspendLayout();
 			// 
 			// flags
 			// 
 			this.flags.AutoScroll = true;
 			this.flags.Columns = 2;
 			this.flags.Location = new System.Drawing.Point(12, 12);
 			this.flags.Name = "flags";
 			this.flags.Size = new System.Drawing.Size(361, 163);
 			this.flags.TabIndex = 0;
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(195, 187);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(91, 25);
 			this.cancel.TabIndex = 4;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.apply.Location = new System.Drawing.Point(98, 187);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(91, 25);
 			this.apply.TabIndex = 3;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// FlagsForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(385, 224);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.flags);
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "FlagsForm";
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Flags";
 			this.Load += new System.EventHandler(this.LinedefFlagsForm_Load);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.Designer.cs" startline="22" endline="85">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.combobox = new System.Windows.Forms.ComboBox();
 			this.button = new System.Windows.Forms.Button();
 			this.scrollbuttons = new System.Windows.Forms.VScrollBar();
 			this.SuspendLayout();
 			// 
 			// combobox
 			// 
 			this.combobox.DropDownWidth = 130;
 			this.combobox.Location = new System.Drawing.Point(0, 1);
 			this.combobox.Name = "combobox";
 			this.combobox.Size = new System.Drawing.Size(149, 22);
 			this.combobox.TabIndex = 0;
 			this.combobox.Validating += new System.ComponentModel.CancelEventHandler(this.combobox_Validating);
 			this.combobox.TextChanged += new System.EventHandler(this.combobox_TextChanged);
 			// 
 			// button
 			// 
 			this.button.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.button.Image = global
 			this.button.Location = new System.Drawing.Point(153, 0);
 			this.button.Name = "button";
 			this.button.Padding = new System.Windows.Forms.Padding(0, 0, 1, 2);
 			this.button.Size = new System.Drawing.Size(28, 24);
 			this.button.TabIndex = 1;
 			this.button.UseVisualStyleBackColor = true;
 			this.button.Visible = false;
 			this.button.Click += new System.EventHandler(this.button_Click);
 			// 
 			// scrollbuttons
 			// 
 			this.scrollbuttons.LargeChange = 10000;
 			this.scrollbuttons.Location = new System.Drawing.Point(186, -1);
 			this.scrollbuttons.Maximum = 10000;
 			this.scrollbuttons.Minimum = -10000;
 			this.scrollbuttons.Name = "scrollbuttons";
 			this.scrollbuttons.Size = new System.Drawing.Size(18, 24);
 			this.scrollbuttons.TabIndex = 2;
 			this.scrollbuttons.Visible = false;
 			this.scrollbuttons.ValueChanged += new System.EventHandler(this.scrollbuttons_ValueChanged);
 			// 
 			// ArgumentBox
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.scrollbuttons);
 			this.Controls.Add(this.button);
 			this.Controls.Add(this.combobox);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.Name = "ArgumentBox";
 			this.Size = new System.Drawing.Size(268, 64);
 			this.Layout += new System.Windows.Forms.LayoutEventHandler(this.ArgumentBox_Layout);
 			this.Resize += new System.EventHandler(this.ArgumentBox_Resize);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="84" endline="167">
<![CDATA[
 		private string curfunctionname = "";
 		private int curargumentindex = 0;
 		private int curfunctionstartpos = 0;
 		private System.ComponentModel.IContainer components = null;
 		public ScriptEditorControl()
 		{
 			// Initialize
 			InitializeComponent();
 			
 			// Script editor properties
 			// Unfortunately, these cannot be set using the designer
 			// because the control is not really loaded in design mode
 			scriptedit.AutoCMaximumHeight = 8;
 			scriptedit.AutoCSeparator = ' ';
 			scriptedit.AutoCTypeSeparator = '?';
 			scriptedit.AutoCSetFillUps("\r\n();[]");	// I should put this in the script configs
 			scriptedit.CaretWidth = 2;
 			scriptedit.EndAtLastLine = 1;
 			scriptedit.EndOfLineMode = ScriptEndOfLine.CRLF;
 			scriptedit.IsAutoCGetChooseSingle = true;
 			scriptedit.IsAutoCGetIgnoreCase = true;
 			scriptedit.IsBackSpaceUnIndents = true;
 			scriptedit.IsBufferedDraw = true;
 			scriptedit.IsCaretLineVisible = false;
 			scriptedit.IsHScrollBar = true;
 			scriptedit.IndentationGuides = (int)ScriptIdentGuides.None;
 			scriptedit.IsMouseDownCaptures = true;
 			scriptedit.IsTabIndents = true;
 			scriptedit.IsUndoCollection = true;
 			scriptedit.IsUseTabs = true;
 			scriptedit.IsViewEOL = false;
 			scriptedit.IsVScrollBar = true;
 			scriptedit.SetFoldFlags((int)ScriptFoldFlag.Box);
 			scriptedit.TabWidth = 4;
 			scriptedit.Indent = 4;
 			scriptedit.ExtraAscent = 1;
 			scriptedit.ExtraDescent = 1;
 			scriptedit.CursorType = -1;
 
 			// Symbol margin
 			scriptedit.SetMarginTypeN(0, (int)ScriptMarginType.Symbol);
 			scriptedit.SetMarginWidthN(0, 20);
 			scriptedit.SetMarginMaskN(0, -1);	// all
 			
 			// Line numbers margin
 			scriptedit.SetMarginTypeN(1, (int)ScriptMarginType.Number);
 			scriptedit.SetMarginWidthN(1, 40);
 			scriptedit.SetMarginMaskN(1, 0);	// none
 
 			// Spacing margin
 			scriptedit.SetMarginTypeN(2, (int)ScriptMarginType.Symbol);
 			scriptedit.SetMarginWidthN(2, 5);
 			scriptedit.SetMarginMaskN(2, 0);	// none
 			
 			// Setup with default script config
 			// Disabled, the form designer doesn't like this
 			//SetupStyles(new ScriptConfiguration());
 
 			// Images
 			RegisterAutoCompleteImage(ImageIndex.ScriptConstant, Resources.ScriptConstant);
 			RegisterAutoCompleteImage(ImageIndex.ScriptKeyword, Resources.ScriptKeyword);
 			RegisterMarkerImage(ImageIndex.ScriptError, Resources.ScriptError);
 
 			// Events
 			scriptedit.ModEventMask = 0x7FFFF;	// Which events to receive (see also ScriptModificationFlags)
 			scriptedit.Modified += new ScintillaControl.ModifiedHandler(scriptedit_Modified);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\BitFlagsForm.Designer.cs" startline="22" endline="93">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.options = new CodeImp.DoomBuilder.Controls.CheckboxArrayControl();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.SuspendLayout();
 			// 
 			// options
 			// 
 			this.options.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.options.AutoScroll = true;
 			this.options.Columns = 1;
 			this.options.Location = new System.Drawing.Point(25, 21);
 			this.options.Name = "options";
 			this.options.Size = new System.Drawing.Size(164, 158);
 			this.options.TabIndex = 0;
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(106, 198);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(91, 25);
 			this.cancel.TabIndex = 2;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(9, 198);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(91, 25);
 			this.apply.TabIndex = 1;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// BitFlagsForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(206, 232);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.options);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "BitFlagsForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Options";
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="142" endline="214">
<![CDATA[
 		
 		// Disposer
 		internal bool Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Let the plugins know
 				General.Plugins.OnMapCloseBegin();
 				
 				// Stop processing
 				General.MainWindow.StopProcessing();
 				
 				// Close script editor
 				CloseScriptEditor(false);
 				
 				// Change to no mode
 				General.Editing.ChangeMode((EditMode)null);
 				
 				// Unbind any methods
 				General.Actions.UnbindMethods(this);
 				
 				// Dispose
 				if(grid != null) grid.Dispose();
 				if(launcher != null) launcher.Dispose();
 				if(copypaste != null) copypaste.Dispose();
 				if(undoredo != null) undoredo.Dispose();
 				General.WriteLogLine("Unloading data resources...");
 				if(data != null) data.Dispose();
 				General.WriteLogLine("Closing temporary file...");
 				if(tempwad != null) tempwad.Dispose();
 				General.WriteLogLine("Unloading map data...");
 				if(map != null) map.Dispose();
 				General.WriteLogLine("Stopping graphics device...");
 				if(renderer2d != null) renderer2d.Dispose();
 				if(renderer3d != null) renderer3d.Dispose();
 				if(graphics != null) graphics.Dispose();
 				visualcamera = null;
 				grid = null;
 				launcher = null;
 				copypaste = null;
 				undoredo = null;
 				data = null;
 				tempwad = null;
 				map = null;
 				renderer2d = null;
 				renderer3d = null;
 				graphics = null;
 				
 				// We may spend some time to clean things up here
 				GC.Collect();
 				
 				// Remove temp file
 				General.WriteLogLine("Removing temporary directory...");
 				try { Directory.Delete(temppath, true); } catch(Exception e)
 				{
 					General.WriteLogLine(e.GetType().Name + "
 					General.WriteLogLine("Failed to remove temporary directory!");
 				}
 				
 				// Let the plugins know
 				General.Plugins.OnMapCloseEnd();
 				
 				// Done
 				isdisposed = true;
 				return true;
 			}
 			else
 			{
 				// Already closed
 				return true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\DefinedTextureSet.cs" startline="66" endline="90">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		// This writes the texture set to configuration
 		internal void WriteToConfig(Configuration cfg, string path)
 		{
 			IDictionary dic;
 			
 			// Fill structure
 			dic = new ListDictionary();
 			
 			// Add name
 			dic.Add("name", name);
 			
 			for(int i = 0; i < filters.Count; i++)
 			{
 				// Add filters
 				dic.Add("filter" + i.ToString(), filters[i].ToUpperInvariant());
 			}
 			for(int i = 0; i < filters.Count; i++)
 			{
 				// Add filters
 				dic.Add("filter" + i.ToString(), filters[i].ToUpperInvariant());
 			}
 			
 			// Write to config
 			cfg.WriteSetting(path, dic);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="63" endline="79">
<![CDATA[
 
 		// Constructor for custom list
 		public DirectoryFilesList(ICollection<DirectoryFileEntry> sourceentries)
 		{
 			int index = 0;
 			entries = new DirectoryFileEntry[sourceentries.Count];
 			hashedentries = new Dictionary<string, DirectoryFileEntry>(sourceentries.Count);
 			foreach(DirectoryFileEntry e in sourceentries)
 			{
 				entries[index] = e;
 				string hashkey = e.filepathname.ToLowerInvariant();
 				if(hashedentries.ContainsKey(hashkey))
 					throw new IOException("Multiple files with the same filename in the same directory are not allowed. See
 				hashedentries.Add(hashkey, e);
 				index++;
 			}
 			foreach(DirectoryFileEntry e in sourceentries)
 			{
 				entries[index] = e;
 				string hashkey = e.filepathname.ToLowerInvariant();
 				if(hashedentries.ContainsKey(hashkey))
 					throw new IOException("Multiple files with the same filename in the same directory are not allowed. See
 				hashedentries.Add(hashkey, e);
 				index++;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\VertexEditForm.cs" startline="78" endline="118">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Methods
 
 		// This sets up the form to edit the given vertices
 		public void Setup(ICollection<Vertex> vertices)
 		{
 			// Keep this list
 			this.vertices = vertices;
 			if(vertices.Count > 1) this.Text = "Edit Vertices (" + vertices.Count + ")";
 
 			////////////////////////////////////////////////////////////////////////
 			// Set all options to the first vertex properties
 			////////////////////////////////////////////////////////////////////////
 
 			// Get first vertex
 			Vertex vc = General.GetByIndex(vertices, 0);
 
 			// Position
 			positionx.Text = vc.Position.x.ToString();
 			positiony.Text = vc.Position.y.ToString();
 			
 			// Custom fields
 			fieldslist.SetValues(vc.Fields, true);
 			
 			////////////////////////////////////////////////////////////////////////
 			// Now go for all sectors and change the options when a setting is different
 			////////////////////////////////////////////////////////////////////////
 
 			// Go for all vertices
 			foreach(Vertex v in vertices)
 			{
 				// Position
 				if(positionx.Text != v.Position.x.ToString()) positionx.Text = "";
 				if(positiony.Text != v.Position.y.ToString()) positiony.Text = "";
 
 				// Custom fields
 				fieldslist.SetValues(v.Fields, false);
 			}
 			foreach(Vertex v in vertices)
 			{
 				// Position
 				if(positionx.Text != v.Position.x.ToString()) positionx.Text = "";
 				if(positiony.Text != v.Position.y.ToString()) positiony.Text = "";
 
 				// Custom fields
 				fieldslist.SetValues(v.Fields, false);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\CustomFieldsForm.cs" startline="85" endline="96">
<![CDATA[
 		
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Apply fields to all elements
 			foreach(MapElement el in elements) fieldslist.Apply(el.Fields);
 			
 			// Done
 			General.Map.IsChanged = true;
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ColorImage.cs" startline="56" endline="101">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			// Leave when already loaded
 			if(this.IsImageLoaded) return;
 			if((width == 0) || (height == 0)) return;
 
 			lock(this)
 			{
 				// Create bitmap
 				try
 				{
 					if(bitmap != null) bitmap.Dispose();
 					bitmap = new Bitmap(width, height, PixelFormat.Format32bppArgb);
 					BitmapData bitmapdata = bitmap.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
 					PixelColor* pixels = (PixelColor*)bitmapdata.Scan0.ToPointer();
 					for(int i = 0; i < (width * height); i++)
 					{
 						*pixels = color;
 						pixels++;
 					}
 					for(int i = 0; i < (width * height); i++)
 					{
 						*pixels = color;
 						pixels++;
 					}
 					bitmap.UnlockBits(bitmapdata);
 				}
 				catch(Exception e)
 				{
 					// Unable to make bitmap
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to create color image '" + this.Name + "'. " + e.GetType().Name + "
 					loadfailed = true;
 				}
 
 				// Dispose bitmap if load failed
 				if(loadfailed && (bitmap != null))
 				{
 					bitmap.Dispose();
 					bitmap = null;
 				}
 				
 				// Pass on to base
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PasteOptionsForm.Designer.cs" startline="22" endline="91">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.paste = new System.Windows.Forms.Button();
 			this.cancel = new System.Windows.Forms.Button();
 			this.pasteoptions = new CodeImp.DoomBuilder.Controls.PasteOptionsControl();
 			this.SuspendLayout();
 			// 
 			// paste
 			// 
 			this.paste.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.paste.Location = new System.Drawing.Point(272, 278);
 			this.paste.Name = "paste";
 			this.paste.Size = new System.Drawing.Size(112, 25);
 			this.paste.TabIndex = 3;
 			this.paste.Text = "Paste";
 			this.paste.UseVisualStyleBackColor = true;
 			this.paste.Click += new System.EventHandler(this.paste_Click);
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(390, 278);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 4;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// pasteoptions
 			// 
 			this.pasteoptions.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.pasteoptions.Location = new System.Drawing.Point(12, 12);
 			this.pasteoptions.Name = "pasteoptions";
 			this.pasteoptions.Size = new System.Drawing.Size(490, 260);
 			this.pasteoptions.TabIndex = 5;
 			// 
 			// PasteOptionsForm
 			// 
 			this.AcceptButton = this.paste;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(514, 318);
 			this.ControlBox = false;
 			this.Controls.Add(this.pasteoptions);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.paste);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "PasteOptionsForm";
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Paste Special";
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ColorControl.Designer.cs" startline="22" endline="92">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.label = new System.Windows.Forms.Label();
 			this.panel = new System.Windows.Forms.Panel();
 			this.button = new System.Windows.Forms.Button();
 			this.dialog = new System.Windows.Forms.ColorDialog();
 			this.SuspendLayout();
 			// 
 			// label
 			// 
 			this.label.Location = new System.Drawing.Point(-3, 0);
 			this.label.Name = "label";
 			this.label.Size = new System.Drawing.Size(175, 23);
 			this.label.TabIndex = 0;
 			this.label.Text = "Color name
 			this.label.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
 			// 
 			// panel
 			// 
 			this.panel.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(255)))), ((int)(((byte)(128)))), ((int)(((byte)(0)))));
 			this.panel.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.panel.Location = new System.Drawing.Point(178, 0);
 			this.panel.Name = "panel";
 			this.panel.Size = new System.Drawing.Size(27, 23);
 			this.panel.TabIndex = 1;
 			// 
 			// button
 			// 
 			this.button.BackColor = System.Drawing.SystemColors.Control;
 			this.button.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Center;
 			this.button.FlatStyle = System.Windows.Forms.FlatStyle.Popup;
 			this.button.Image = global
 			this.button.Location = new System.Drawing.Point(322, 0);
 			this.button.Name = "button";
 			this.button.Padding = new System.Windows.Forms.Padding(0, 0, 2, 3);
 			this.button.Size = new System.Drawing.Size(26, 23);
 			this.button.TabIndex = 2;
 			this.button.UseVisualStyleBackColor = false;
 			this.button.MouseMove += new System.Windows.Forms.MouseEventHandler(this.button_MouseMove);
 			this.button.Click += new System.EventHandler(this.button_Click);
 			this.button.MouseDown += new System.Windows.Forms.MouseEventHandler(this.button_MouseDown);
 			this.button.MouseUp += new System.Windows.Forms.MouseEventHandler(this.button_MouseUp);
 			// 
 			// dialog
 			// 
 			this.dialog.FullOpen = true;
 			// 
 			// ColorControl
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.BackColor = System.Drawing.Color.Transparent;
 			this.Controls.Add(this.button);
 			this.Controls.Add(this.panel);
 			this.Controls.Add(this.label);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.MinimumSize = new System.Drawing.Size(100, 23);
 			this.Name = "ColorControl";
 			this.Size = new System.Drawing.Size(348, 23);
 			this.Resize += new System.EventHandler(this.ColorControl_Resize);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\AngleForm.Designer.cs" startline="22" endline="91">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.angle = new CodeImp.DoomBuilder.Controls.AngleControl();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.SuspendLayout();
 			// 
 			// angle
 			// 
 			this.angle.BackColor = System.Drawing.SystemColors.Control;
 			this.angle.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.angle.Location = new System.Drawing.Point(60, 22);
 			this.angle.Name = "angle";
 			this.angle.Size = new System.Drawing.Size(84, 84);
 			this.angle.TabIndex = 0;
 			this.angle.Value = 0;
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(105, 131);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(91, 25);
 			this.cancel.TabIndex = 2;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.apply.Location = new System.Drawing.Point(8, 131);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(91, 25);
 			this.apply.TabIndex = 1;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// AngleForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(204, 165);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.angle);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "AngleForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Angle";
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ActionSelectorControl.Designer.cs" startline="22" endline="93">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.number = new CodeImp.DoomBuilder.Controls.AutoSelectTextbox();
 			this.list = new System.Windows.Forms.ComboBox();
 			this.numberpanel = new System.Windows.Forms.Panel();
 			this.numberpanel.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// number
 			// 
 			this.number.BorderStyle = System.Windows.Forms.BorderStyle.None;
 			this.number.ImeMode = System.Windows.Forms.ImeMode.Off;
 			this.number.Location = new System.Drawing.Point(3, 1);
 			this.number.Name = "number";
 			this.number.Size = new System.Drawing.Size(43, 13);
 			this.number.TabIndex = 0;
 			this.number.Text = "402";
 			this.number.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
 			this.number.TextChanged += new System.EventHandler(this.number_TextChanged);
 			this.number.KeyDown += new System.Windows.Forms.KeyEventHandler(this.number_KeyDown);
 			this.number.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.number_KeyPress);
 			// 
 			// list
 			// 
 			this.list.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawFixed;
 			this.list.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.list.FormattingEnabled = true;
 			this.list.IntegralHeight = false;
 			this.list.Location = new System.Drawing.Point(57, 0);
 			this.list.MaxDropDownItems = 15;
 			this.list.Name = "list";
 			this.list.Size = new System.Drawing.Size(251, 21);
 			this.list.TabIndex = 1;
 			this.list.TabStop = false;
 			this.list.DrawItem += new System.Windows.Forms.DrawItemEventHandler(this.list_DrawItem);
 			this.list.SelectionChangeCommitted += new System.EventHandler(this.list_SelectionChangeCommitted);
 			this.list.DropDownClosed += new System.EventHandler(this.list_DropDownClosed);
 			// 
 			// numberpanel
 			// 
 			this.numberpanel.BackColor = System.Drawing.SystemColors.Window;
 			this.numberpanel.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.numberpanel.Controls.Add(this.number);
 			this.numberpanel.Location = new System.Drawing.Point(0, 0);
 			this.numberpanel.Name = "numberpanel";
 			this.numberpanel.Size = new System.Drawing.Size(53, 21);
 			this.numberpanel.TabIndex = 0;
 			// 
 			// ActionSelectorControl
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.BackColor = System.Drawing.Color.Transparent;
 			this.Controls.Add(this.numberpanel);
 			this.Controls.Add(this.list);
 			this.Cursor = System.Windows.Forms.Cursors.Default;
 			this.Name = "ActionSelectorControl";
 			this.Size = new System.Drawing.Size(382, 21);
 			this.Layout += new System.Windows.Forms.LayoutEventHandler(this.ActionSelectorControl_Layout);
 			this.Resize += new System.EventHandler(this.ActionSelectorControl_Resize);
 			this.numberpanel.ResumeLayout(false);
 			this.numberpanel.PerformLayout();
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="502" endline="522">
<![CDATA[
 		
 		// This will add the default sets from game configuration
 		private void restoretexturesets_Click(object sender, EventArgs e)
 		{
 			// Ask nicely first
 			if(MessageBox.Show(this, "This will add the default Texture Sets from the Game Configuration. Do you want to continue?",
 				"Add Default Sets", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes)
 			{
 				// Add copies
 				foreach(DefinedTextureSet ts in gameconfig.TextureSets)
 				{
 					DefinedTextureSet s = ts.Copy();
 					ListViewItem item = listtextures.Items.Add(s.Name);
 					item.Tag = s;
 					item.ImageIndex = 0;
 					configinfo.TextureSets.Add(s);
 				}
 				foreach(DefinedTextureSet ts in gameconfig.TextureSets)
 				{
 					DefinedTextureSet s = ts.Copy();
 					ListViewItem item = listtextures.Items.Add(s.Name);
 					item.Tag = s;
 					item.ImageIndex = 0;
 					configinfo.TextureSets.Add(s);
 				}
 				listtextures.Sort();
 				reloadresources = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="215" endline="302">
<![CDATA[
 
 		#endregion
 
 		#region ================== New / Open
 		
 		// Initializes for a new map
 		internal bool InitializeNewMap(MapOptions options)
 		{
 			string tempfile;
 			
 			// Apply settings
 			this.filetitle = "unnamed.wad";
 			this.filepathname = "";
 			this.changed = false;
 			this.options = options;
 
 			General.WriteLogLine("Creating new map '" + options.CurrentName + "' with configuration '" + options.ConfigFile + "'");
 
 			// Initiate graphics
 			General.WriteLogLine("Initializing graphics device...");
 			graphics = new D3DDevice(General.MainWindow.Display);
 			if(!graphics.Initialize()) return false;
 			
 			// Create renderers
 			renderer2d = new Renderer2D(graphics);
 			renderer3d = new Renderer3D(graphics);
 			
 			// Load game configuration
 			General.WriteLogLine("Loading game configuration...");
 			configinfo = General.GetConfigurationInfo(options.ConfigFile);
 			config = new GameConfiguration(General.LoadGameConfiguration(options.ConfigFile));
 			configinfo.ApplyDefaults(config);
 			General.Editing.UpdateCurrentEditModes();
 			
 			// Create map data
 			map = new MapSet();
 			
 			// Create temp wadfile
 			tempfile = General.MakeTempFilename(temppath);
 			General.WriteLogLine("Creating temporary file
 			#if DEBUG
 				tempwad = new WAD(tempfile);
 			#else
 				try { tempwad = new WAD(tempfile); }
 				catch(Exception e)
 				{
 					General.ShowErrorMessage("Error while creating a temporary wad file
 					return false;
 				}
 			#endif
 			
 			// Read the map from temp file
 			General.WriteLogLine("Initializing map format interface " + config.FormatInterface + "...");
 			io = MapSetIO.Create(config.FormatInterface, tempwad, this);
 
 			// Create required lumps
 			General.WriteLogLine("Creating map data structures...");
 			tempwad.Insert(TEMP_MAP_HEADER, 0, 0);
 			io.Write(map, TEMP_MAP_HEADER, 1);
 			CreateRequiredLumps(tempwad, TEMP_MAP_HEADER);
 			
 			// Load data manager
 			General.WriteLogLine("Loading data resources...");
 			data = new DataManager();
 			data.Load(configinfo.Resources, options.Resources);
 			
 			// Update structures
 			options.ApplyGridSettings();
 			map.UpdateConfiguration();
 			map.Update();
 			thingsfilter.Update();
 			
 			// Bind any methods
 			General.Actions.BindMethods(this);
 
 			// Set defaults
 			this.visualcamera = new VisualCamera();
 			General.Editing.ChangeMode(configinfo.StartMode);
 			ClassicMode cmode = (General.Editing.Mode as ClassicMode);
 			if(cmode != null) cmode.SetZoom(0.5f);
 			renderer2d.SetViewMode((ViewMode)General.Settings.DefaultViewMode);
 			General.Settings.SetDefaultThingFlags(config.DefaultThingFlags);
 			
 			// Success
 			this.changed = false;
 			General.WriteLogLine("Map creation done");
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextEditForm.Designer.cs" startline="25" endline="104">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.textbox = new System.Windows.Forms.TextBox();
 			this.SuspendLayout();
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(354, 220);
 			this.cancel.Margin = new System.Windows.Forms.Padding(1);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 2;
 			this.cancel.TabStop = false;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(235, 220);
 			this.apply.Margin = new System.Windows.Forms.Padding(1);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 1;
 			this.apply.TabStop = false;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// textbox
 			// 
 			this.textbox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.textbox.Location = new System.Drawing.Point(10, 10);
 			this.textbox.Margin = new System.Windows.Forms.Padding(1);
 			this.textbox.Multiline = true;
 			this.textbox.Name = "textbox";
 			this.textbox.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
 			this.textbox.Size = new System.Drawing.Size(456, 194);
 			this.textbox.TabIndex = 0;
 			this.textbox.TabStop = false;
 			// 
 			// TextEditForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(476, 255);
 			this.Controls.Add(this.textbox);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "TextEditForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Edit Text";
 			this.Activated += new System.EventHandler(this.TextEditForm_Activated);
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\OpenMapOptionsForm.cs" startline="71" endline="163">
<![CDATA[
 
 		// This loads the settings and attempt to find a suitable config
 		private void LoadSettings()
 		{
 			string dbsfile;
 			string gameconfig;
 			int index;
 			
 			// Busy
 			Cursor.Current = Cursors.WaitCursor;
 
 			// Check if the file exists
 			if(!File.Exists(filepathname))
 			{
 				// WAD file does not exist
 				MessageBox.Show(this, "Could not open the WAD file
 				this.DialogResult = DialogResult.Cancel;
 				this.Close();
 				return;
 			}
 			
 			try
 			{
 				// Open the WAD file
 				wadfile = new WAD(filepathname, true);
 			}
 			catch(Exception)
 			{
 				// Unable to open WAD file (or its config)
 				MessageBox.Show(this, "Could not open the WAD file for reading. Please make sure the file you selected is valid and is not in use by any other application.", Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Error);
 				if(wadfile != null) wadfile.Dispose();
 				this.DialogResult = DialogResult.Cancel;
 				this.Close();
 				return;
 			}
 
 			// Open the Map Settings configuration
 			dbsfile = filepathname.Substring(0, filepathname.Length - 4) + ".dbs";
 			if(File.Exists(dbsfile))
 				try { mapsettings = new Configuration(dbsfile, true); }
 				catch(Exception) { mapsettings = new Configuration(true); }
 			else
 				mapsettings = new Configuration(true);
 			
 			// Check strict patches box
 			if(options != null)
 				strictpatches.Checked = options.StrictPatches;
 			else
 				strictpatches.Checked = mapsettings.ReadSetting("strictpatches", false);
 			
 			// Check what game configuration is preferred
 			if(options != null)
 				gameconfig = options.ConfigFile;
 			else
 				gameconfig = mapsettings.ReadSetting("gameconfig", "");
 
 			// Go for all configurations
 			for(int i = 0; i < General.Configs.Count; i++)
 			{
 				// Add config name to list
 				index = config.Items.Add(General.Configs[i]);
 
 				// This is the preferred game configuration?
 				if(General.Configs[i].Filename == gameconfig)
 				{
 					// Select this item
 					config.SelectedIndex = index;
 				}
 			}
 			for(int i = 0; i < General.Configs.Count; i++)
 			{
 				// Add config name to list
 				index = config.Items.Add(General.Configs[i]);
 
 				// This is the preferred game configuration?
 				if(General.Configs[i].Filename == gameconfig)
 				{
 					// Select this item
 					config.SelectedIndex = index;
 				}
 			}
 
 			// Still no configuration selected?
 			if(config.SelectedIndex == -1)
 			{
 				// Then go for all configurations to find a suitable one
 				for(int i = 0; i < General.Configs.Count; i++)
 				{
 					// Check if a resource location is set for this configuration
 					if(General.Configs[i].Resources.Count > 0)
 					{
 						// Match the wad against this configuration
 						if(MatchConfiguration(General.Configs[i].Filename, wadfile))
 						{
 							// Select this item
 							config.SelectedIndex = i;
 							break;
 						}
 					}
 				}
 				for(int i = 0; i < General.Configs.Count; i++)
 				{
 					// Check if a resource location is set for this configuration
 					if(General.Configs[i].Resources.Count > 0)
 					{
 						// Match the wad against this configuration
 						if(MatchConfiguration(General.Configs[i].Filename, wadfile))
 						{
 							// Select this item
 							config.SelectedIndex = i;
 							break;
 						}
 					}
 				}
 			}
 			
 			// Done
 			Cursor.Current = Cursors.Default;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\CustomFieldsForm.Designer.cs" startline="22" endline="104">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.fieldslist = new CodeImp.DoomBuilder.Controls.FieldsEditorControl();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.SuspendLayout();
 			// 
 			// fieldslist
 			// 
 			this.fieldslist.AllowInsert = true;
 			this.fieldslist.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.fieldslist.AutoInsertUserPrefix = true;
 			this.fieldslist.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.fieldslist.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.fieldslist.Location = new System.Drawing.Point(10, 10);
 			this.fieldslist.Margin = new System.Windows.Forms.Padding(1);
 			this.fieldslist.Name = "fieldslist";
 			this.fieldslist.PropertyColumnVisible = true;
 			this.fieldslist.PropertyColumnWidth = 150;
 			this.fieldslist.Size = new System.Drawing.Size(506, 310);
 			this.fieldslist.TabIndex = 0;
 			this.fieldslist.TypeColumnVisible = true;
 			this.fieldslist.TypeColumnWidth = 100;
 			this.fieldslist.ValueColumnVisible = true;
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(404, 336);
 			this.cancel.Margin = new System.Windows.Forms.Padding(1);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 2;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(285, 336);
 			this.apply.Margin = new System.Windows.Forms.Padding(1);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 1;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// CustomFieldsForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(526, 371);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.fieldslist);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "CustomFieldsForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "CustomFieldsForm";
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.CustomFieldsForm_HelpRequested);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="273" endline="300">
<![CDATA[
 
 		// This finds and returns a colormap stream
 		public override Stream GetColormapData(string pname)
 		{
 			Lump lump;
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Strictly read patches only between C_START and C_END?
 			if(strictpatches)
 			{
 				// Find the lump in ranges
 				foreach(LumpRange range in colormapranges)
 				{
 					lump = file.FindLump(pname, range.start, range.end);
 					if(lump != null) return lump.Stream;
 				}
 				foreach(LumpRange range in colormapranges)
 				{
 					lump = file.FindLump(pname, range.start, range.end);
 					if(lump != null) return lump.Stream;
 				}
 			}
 			else
 			{
 				// Find the lump anywhere
 				lump = file.FindLump(pname);
 				if(lump != null) return lump.Stream;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="530" endline="557">
<![CDATA[
 
 		// This finds and returns a patch stream
 		public override Stream GetPatchData(string pname)
 		{
 			Lump lump;
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Strictly read patches only between P_START and P_END?
 			if(strictpatches)
 			{
 				// Find the lump in ranges
 				foreach(LumpRange range in patchranges)
 				{
 					lump = file.FindLump(pname, range.start, range.end);
 					if(lump != null) return lump.Stream;
 				}
 				foreach(LumpRange range in patchranges)
 				{
 					lump = file.FindLump(pname, range.start, range.end);
 					if(lump != null) return lump.Stream;
 				}
 			}
 			else
 			{
 				// Find the lump anywhere
 				lump = file.FindLump(pname);
 				if(lump != null) return lump.Stream;
 			}
 			
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\OpenMapOptionsForm.cs" startline="364" endline="372">
<![CDATA[
 		
 		// Cancel clicked
 		private void cancel_Click(object sender, EventArgs e)
 		{
 			// Just hide window
 			wadfile.Dispose();
 			this.DialogResult = DialogResult.Cancel;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.cs" startline="84" endline="92">
<![CDATA[
 
 		// Cancel clicked
 		private void cancel_Click(object sender, EventArgs e)
 		{
 			// Be gone.
 			matcheslist.CleanUp();
 			this.DialogResult = DialogResult.Cancel;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\BitmapImage.cs" startline="63" endline="82">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			lock(this)
 			{
 				// No failure checking here. I anything fails here, it is not the user's fault,
 				// because the resources this loads are in the assembly.
 
 				// Get resource from memory
 				bitmap = img;
 
 				// Pass on to base
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="406" endline="423">
<![CDATA[
 
 		// Make new texture set
 		private void addtextureset_Click(object sender, EventArgs e)
 		{
 			DefinedTextureSet s = new DefinedTextureSet("New Texture Set");
 			TextureSetForm form = new TextureSetForm();
 			form.Setup(s);
 			if(form.ShowDialog(this) == DialogResult.OK)
 			{
 				// Add to texture sets
 				configinfo.TextureSets.Add(s);
 				ListViewItem item = listtextures.Items.Add(s.Name);
 				item.Tag = s;
 				item.ImageIndex = 0;
 				listtextures.Sort();
 				reloadresources = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2741" endline="2754">
<![CDATA[
 		
 		// This removes a docker
 		public bool RemoveDocker(Docker d)
 		{
 			// Make sure the full name is set with the plugin name as prefix
 			Plugin plugin = General.Plugins.FindPluginByAssembly(Assembly.GetCallingAssembly());
 			d.MakeFullName(plugin.Name.ToLowerInvariant());
 			
 			// We must release all keys because the focus may be stolen when
 			// this was the selected docker (the previous docker is automatically selected)
 			ReleaseAllKeys();
 			
 			return dockerspanel.Remove(d);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2755" endline="2767">
<![CDATA[
 		
 		// This selects a docker
 		public bool SelectDocker(Docker d)
 		{
 			// Make sure the full name is set with the plugin name as prefix
 			Plugin plugin = General.Plugins.FindPluginByAssembly(Assembly.GetCallingAssembly());
 			d.MakeFullName(plugin.Name.ToLowerInvariant());
 			
 			// We must release all keys because the focus will be stolen
 			ReleaseAllKeys();
 			
 			return dockerspanel.SelectDocker(d);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="787" endline="801">
<![CDATA[
 
 		/// <summary>
 		/// This is called when the blockmap needs to be refilled, because it was invalidated.
 		/// This usually happens when geometry is changed by undo, redo, cut or paste actions.
 		/// Lines and Things are added to the block map by the base implementation.
 		/// </summary>
 		protected virtual void FillBlockMap()
 		{
 			if(blockmap != null) blockmap.Dispose();
 			blockmap = new VisualBlockMap();
 			
 			blockmap.AddLinedefsSet(General.Map.Map.Linedefs);
 			blockmap.AddThingsSet(General.Map.Map.Things);
 			blockmap.AddSectorsSet(General.Map.Map.Sectors);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="658" endline="665">
<![CDATA[
 
 		// Key combination displayed
 		private void actionkey_TextChanged(object sender, EventArgs e)
 		{
 			// Cursor to the end
 			actionkey.SelectionStart = actionkey.Text.Length;
 			actionkey.SelectionLength = 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Vertex.cs" startline="161" endline="176">
<![CDATA[
 
 		// Serialize / deserialize
 		internal void ReadWrite(IReadWriteStream s)
 		{
 			if(!s.IsWriting) BeforePropsChange();
 			
 			base.ReadWrite(s);
 			
 			s.rwVector2D(ref pos);
 			
 			if(s.IsWriting)
 			{
 				// Let all lines know they need an update
 				foreach(Linedef l in linedefs) l.NeedUpdate();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.cs" startline="8" endline="53">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public TextureSetForm()
 		{
 			InitializeComponent();
 			matcheslist.ApplySettings();
 			
 			// Show/hide components
 			matchesbutton.Visible = (General.Map != null);
 			nomatchesbutton.Visible = (General.Map != null);
 			matcheslist.Visible = (General.Map != null);
 			noresultlabel.Visible = (General.Map == null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1043" endline="1053">
<![CDATA[
 
 		// Mouse enters
 		private void display_MouseEnter(object sender, EventArgs e)
 		{
 			mouseinside = true;
 			if((General.Map != null) && (mouseinput == null) && (General.Editing.Mode != null))
 			{
 				General.Plugins.OnEditMouseEnter(e);
 				General.Editing.Mode.OnMouseEnter(e);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1054" endline="1064">
<![CDATA[
 
 		// Mouse leaves
 		private void display_MouseLeave(object sender, EventArgs e)
 		{
 			mouseinside = false;
 			if((General.Map != null) && (mouseinput == null) && (General.Editing.Mode != null))
 			{
 				General.Plugins.OnEditMouseLeave(e);
 				General.Editing.Mode.OnMouseLeave(e);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditModeInfo.cs" startline="187" endline="206">
<![CDATA[
 
 		// This switches to the mode with arguments
 		public void SwitchToMode(object[] args)
 		{
 			EditMode newmode;
 
 			// Only when a map is opened
 			if(General.Map != null)
 			{
 				// Create instance
 				newmode = plugin.CreateObjectA<EditMode>(type, args);
 
 				// Switch mode
 				if(!General.Editing.ChangeMode(newmode))
 				{
 					// When cancelled, dispose mode
 					newmode.Dispose();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingBrowserControl.cs" startline="161" endline="182">
<![CDATA[
 		
 		// Thing type selection changed
 		private void typelist_AfterSelect(object sender, TreeViewEventArgs e)
 		{
 			if(doupdatetextbox)
 			{
 				// Anything selected?
 				if(typelist.SelectedNode != null)
 				{
 					TreeNode n = typelist.SelectedNode;
 
 					// Node is a child node?
 					if((n.Nodes.Count == 0) && (n.Tag != null) && (n.Tag is ThingTypeInfo))
 					{
 						ThingTypeInfo ti = (n.Tag as ThingTypeInfo);
 
 						// Show info
 						typeid.Text = ti.Index.ToString();
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="201" endline="217">
<![CDATA[
 		
 		// Selection changed
 		private void list_ItemSelectionChanged(object sender, ListViewItemSelectionChangedEventArgs e)
 		{
 			// Prevent selecting?
 			if(preventselection)
 			{
 				foreach(ListViewItem i in list.SelectedItems) i.Selected = false;
 			}
 			else
 			{
 				// Raise event
 				if(SelectedItemChanged != null) SelectedItemChanged();
 			}
 
 			UpdateTextureSizeLabel();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="821" endline="839">
<![CDATA[
 
 		// This serializes linedefs
 		private void WriteLinedefs(SerializerStream stream)
 		{
 			stream.wInt(numlinedefs);
 
 			// Go for all lines
 			int index = 0;
 			foreach(Linedef l in linedefs)
 			{
 				l.SerializedIndex = index++;
 				
 				stream.wInt(l.Start.SerializedIndex);
 				
 				stream.wInt(l.End.SerializedIndex);
 
 				l.ReadWrite(stream);
 			}
 			foreach(Linedef l in linedefs)
 			{
 				l.SerializedIndex = index++;
 				
 				stream.wInt(l.Start.SerializedIndex);
 				
 				stream.wInt(l.End.SerializedIndex);
 
 				l.ReadWrite(stream);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="227" endline="234">
<![CDATA[
 
 		// This clears the value
 		public void ClearValue()
 		{
 			typehandler.SetValue("");
 			combobox.SelectedItem = null;
 			combobox.Text = "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="522" endline="542">
<![CDATA[
 		
 		// This unlocks the locked buffers
 		public void UnlockBuffers()
 		{
 			if(!resourcesunloaded)
 			{
 				foreach(VertexBuffer vb in lockedbuffers)
 				{
 					if(vb.Tag != null)
 					{
 						DataStream bstream = (DataStream)vb.Tag;
 						vb.Unlock();
 						bstream.Dispose();
 						vb.Tag = null;
 					}
 				}
 				foreach(VertexBuffer vb in lockedbuffers)
 				{
 					if(vb.Tag != null)
 					{
 						DataStream bstream = (DataStream)vb.Tag;
 						vb.Unlock();
 						bstream.Dispose();
 						vb.Tag = null;
 					}
 				}
 
 				// Clear list
 				lockedbuffers = new List<VertexBuffer>();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1691" endline="1707">
<![CDATA[
 		
 		// This removes the config-specific editing mode buttons
 		internal void RemoveEditModeButtons()
 		{
 			// Go for all items
 			foreach(ToolStripItem i in editmodeitems)
 			{
 				// Remove it and restart
 				toolbar.Items.Remove(i);
 				menumode.DropDownItems.Remove(i);
 				i.Dispose();
 			}
 			foreach(ToolStripItem i in editmodeitems)
 			{
 				// Remove it and restart
 				toolbar.Items.Remove(i);
 				menumode.DropDownItems.Remove(i);
 				i.Dispose();
 			}
 			
 			// Done
 			editmodeitems.Clear();
 			UpdateSeparators();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionAttribute.cs" startline="74" endline="92">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This makes the proper name
 		public string GetFullActionName(Assembly asm)
 		{
 			string asmname;
 
 			if(library.Length > 0)
 				asmname = library.ToLowerInvariant();
 			else if(baseaction)
 				asmname = General.ThisAssembly.GetName().Name.ToLowerInvariant();
 			else
 				asmname = asm.GetName().Name.ToLowerInvariant();
 
 			return asmname + "_" + action;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1510" endline="1519">
<![CDATA[
 
 		// This renders a single vertex at specified coordinates
 		public void PlotVertexAt(Vector2D v, int colorindex)
 		{
 			// Transform vertex coordinates
 			Vector2D nv = v.GetTransformed(translatex, translatey, scale, -scale);
 
 			// Draw pixel here
 			plotter.DrawVertexSolid((int)nv.x, (int)nv.y, vertexsize, ref General.Colors.Colors[colorindex], ref General.Colors.BrightColors[colorindex], ref General.Colors.DarkColors[colorindex]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1697" endline="1720">
<![CDATA[
 
 		// This shows an image in a panel either zoomed or centered depending on size
 		public static void DisplayZoomedImage(Panel panel, Image image)
 		{
 			// Set the image
 			panel.BackgroundImage = image;
 			
 			// Image not null?
 			if(image != null)
 			{
 				// Small enough to fit in panel?
 				if((image.Size.Width < panel.ClientRectangle.Width) &&
 				   (image.Size.Height < panel.ClientRectangle.Height))
 				{
 					// Display centered
 					panel.BackgroundImageLayout = ImageLayout.Center;
 				}
 				else
 				{
 					// Display zoomed
 					panel.BackgroundImageLayout = ImageLayout.Zoom;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\SectorEditForm.cs" startline="8" endline="67">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public SectorEditForm()
 		{
 			// Initialize
 			InitializeComponent();
 
 			// Fill effects list
 			effect.AddInfo(General.Map.Config.SortedSectorEffects.ToArray());
 			
 			// Fill universal fields list
 			fieldslist.ListFixedFields(General.Map.Config.SectorFields);
 
 			// Initialize image selectors
 			floortex.Initialize();
 			ceilingtex.Initialize();
 
 			// Set steps for brightness field
 			brightness.StepValues = General.Map.Config.BrightnessLevels;
 
 			// Custom fields?
 			if(!General.Map.FormatInterface.HasCustomFields)
 				tabs.TabPages.Remove(tabcustom);
 			
 			// Initialize custom fields editor
 			fieldslist.Setup("sector");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="424" endline="439">
<![CDATA[
 
 		// Edit texture set
 		private void edittextureset_Click(object sender, EventArgs e)
 		{
 			// Texture Set selected?
 			if(listtextures.SelectedItems.Count > 0)
 			{
 				DefinedTextureSet s = (listtextures.SelectedItems[0].Tag as DefinedTextureSet);
 				TextureSetForm form = new TextureSetForm();
 				form.Setup(s);
 				form.ShowDialog(this);
 				listtextures.SelectedItems[0].Text = s.Name;
 				listtextures.Sort();
 				reloadresources = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\LinedefsTracePath.cs" startline="61" endline="67">
<![CDATA[
 
 		// Constructor
 		public LinedefTracePath(ICollection<LinedefSide> lines) 
 		{
 			// Initialize
 			foreach(LinedefSide ls in lines) base.Add(ls.Line);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="468" endline="482">
<![CDATA[
 		
 		// Copy selected texture sets
 		private void copytexturesets_Click(object sender, EventArgs e)
 		{
 			// Make copies
 			copiedsets = new List<DefinedTextureSet>();
 			foreach(ListViewItem item in listtextures.SelectedItems)
 			{
 				DefinedTextureSet s = (item.Tag as DefinedTextureSet);
 				copiedsets.Add(s.Copy());
 			}
 			foreach(ListViewItem item in listtextures.SelectedItems)
 			{
 				DefinedTextureSet s = (item.Tag as DefinedTextureSet);
 				copiedsets.Add(s.Copy());
 			}
 			
 			// Enable button
 			pastetexturesets.Enabled = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="668" endline="682">
<![CDATA[
 
 		/// <summary>This creates a new thing and returns it.</summary>
 		public Thing CreateThing(int index)
 		{
 			if(numthings == General.Map.FormatInterface.MaxThings)
 			{
 				General.Interface.DisplayStatus(StatusType.Warning, "Failed to complete operation
 				return null;
 			}
 
 			// Make the thing
 			Thing t = new Thing(this, index);
 			AddItem(t, ref things, index, ref numthings);
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoSnapshot.cs" startline="97" endline="113">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Methods
 
 		// This returns the map data
 		internal MemoryStream GetStream()
 		{
 			lock(this)
 			{
 				// Restore into memory if needed
 				if(isondisk) RestoreFromFile();
 				
 				// Return the buffer
 				return recstream;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="375" endline="398">
<![CDATA[
 
 		// This loads the texture definitions from a TEXTURES lump
 		public static void LoadHighresTextures(Stream stream, string filename, ref List<ImageData> images, Dictionary<long, ImageData> textures, Dictionary<long, ImageData> flats)
 		{
 			// Parse the data
 			TexturesParser parser = new TexturesParser();
 			parser.Parse(stream, filename);
 
 			// Make the textures
 			foreach(TextureStructure t in parser.Textures)
 			{
 				if(t.Name.Length > 0)
 				{
 					// Add the texture
 					ImageData img = t.MakeImage(textures, flats);
 					images.Add(img);
 				}
 				else
 				{
 					// Can't load image without name
 					General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed texture from \"" + filename + "\". Please consider giving names to your resources.");
 				}
 			}
 			foreach(TextureStructure t in parser.Textures)
 			{
 				if(t.Name.Length > 0)
 				{
 					// Add the texture
 					ImageData img = t.MakeImage(textures, flats);
 					images.Add(img);
 				}
 				else
 				{
 					// Can't load image without name
 					General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed texture from \"" + filename + "\". Please consider giving names to your resources.");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="661" endline="684">
<![CDATA[
 
 		// This loads the flat definitions from a TEXTURES lump
 		public static void LoadHighresFlats(Stream stream, string filename, ref List<ImageData> images, Dictionary<long, ImageData> textures, Dictionary<long, ImageData> flats)
 		{
 			// Parse the data
 			TexturesParser parser = new TexturesParser();
 			parser.Parse(stream, filename);
 
 			// Make the textures
 			foreach(TextureStructure t in parser.Flats)
 			{
 				if(t.Name.Length > 0)
 				{
 					// Add the texture
 					ImageData img = t.MakeImage(textures, flats);
 					images.Add(img);
 				}
 				else
 				{
 					// Can't load image without name
 					General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed flat from \"" + filename + "\". Please consider giving names to your resources.");
 				}
 			}
 			foreach(TextureStructure t in parser.Flats)
 			{
 				if(t.Name.Length > 0)
 				{
 					// Add the texture
 					ImageData img = t.MakeImage(textures, flats);
 					images.Add(img);
 				}
 				else
 				{
 					// Can't load image without name
 					General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed flat from \"" + filename + "\". Please consider giving names to your resources.");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="733" endline="756">
<![CDATA[
 
 		// This loads the sprites definitions from a TEXTURES lump
 		public static void LoadHighresSprites(Stream stream, string filename, ref List<ImageData> images, Dictionary<long, ImageData> textures, Dictionary<long, ImageData> flats)
 		{
 			// Parse the data
 			TexturesParser parser = new TexturesParser();
 			parser.Parse(stream, filename);
 			
 			// Make the textures
 			foreach(TextureStructure t in parser.Sprites)
 			{
 				if(t.Name.Length > 0)
 				{
 					// Add the sprite
 					ImageData img = t.MakeImage(textures, flats);
 					images.Add(img);
 				}
 				else
 				{
 					// Can't load image without name
 					General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed sprite from \"" + filename + "\". Please consider giving names to your resources.");
 				}
 			}
 			foreach(TextureStructure t in parser.Sprites)
 			{
 				if(t.Name.Length > 0)
 				{
 					// Add the sprite
 					ImageData img = t.MakeImage(textures, flats);
 					images.Add(img);
 				}
 				else
 				{
 					// Can't load image without name
 					General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed sprite from \"" + filename + "\". Please consider giving names to your resources.");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="349" endline="374">
<![CDATA[
 		
 		// This loads a range of textures
 		private void LoadTexturesRange(int startindex, int endindex, ref List<ImageData> images, PatchNames pnames)
 		{
 			// Determine default scale
 			float defaultscale = General.Map.Config.DefaultTextureScale;
 			
 			// Go for all lumps between start and end exclusive
 			for(int i = startindex + 1; i < endindex; i++)
 			{
 				// Lump not zero length?
 				if(file.Lumps[i].Length > 0)
 				{
 					// Make the image
 					SimpleTextureImage image = new SimpleTextureImage(file.Lumps[i].Name, file.Lumps[i].Name, defaultscale, defaultscale);
 					
 					// Add image to collection
 					images.Add(image);
 				}
 				else
 				{
 					// Can't load image without name
 					General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed texture from lump index " + i + ". Please consider giving names to your resources.");
 				}
 			}
 			for(int i = startindex + 1; i < endindex; i++)
 			{
 				// Lump not zero length?
 				if(file.Lumps[i].Length > 0)
 				{
 					// Make the image
 					SimpleTextureImage image = new SimpleTextureImage(file.Lumps[i].Name, file.Lumps[i].Name, defaultscale, defaultscale);
 					
 					// Add image to collection
 					images.Add(image);
 				}
 				else
 				{
 					// Can't load image without name
 					General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed texture from lump index " + i + ". Please consider giving names to your resources.");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PreviewManager.cs" startline="98" endline="112">
<![CDATA[
 
 		// Disposer
 		internal void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				foreach(Bitmap b in images) b.Dispose();
 				images = null;
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.cs" startline="116" endline="123">
<![CDATA[
 		
 		// Double clicking an item
 		private void filters_DoubleClick(object sender, EventArgs e)
 		{
 			// Edit item
 			if(filters.SelectedItems.Count == 1)
 				filters.SelectedItems[0].BeginEdit();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="385" endline="392">
<![CDATA[
 		
 		private void browseangle_Click(object sender, EventArgs e)
 		{
 			AngleForm af = new AngleForm();
 			af.Setup(filterangle.GetResult(-1));
 			if(af.ShowDialog() == DialogResult.OK)
 				filterangle.Text = af.Value.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="703" endline="732">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Sprite
 
 		// This loads the textures
 		public override ICollection<ImageData> LoadSprites()
 		{
 			List<ImageData> images = new List<ImageData>();
 			string rangestart, rangeend;
 			int lumpindex;
 			
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 			
 			// Load TEXTURES lump file
 			lumpindex = file.FindLumpIndex("TEXTURES");
 			while(lumpindex > -1)
 			{
 				MemoryStream filedata = new MemoryStream(file.Lumps[lumpindex].Stream.ReadAllBytes());
 				WADReader.LoadHighresSprites(filedata, "TEXTURES", ref images, null, null);
 				filedata.Dispose();
 				
 				// Find next
 				lumpindex = file.FindLumpIndex("TEXTURES", lumpindex + 1);
 			}
 			while(lumpindex > -1)
 			{
 				MemoryStream filedata = new MemoryStream(file.Lumps[lumpindex].Stream.ReadAllBytes());
 				WADReader.LoadHighresSprites(filedata, "TEXTURES", ref images, null, null);
 				filedata.Dispose();
 				
 				// Find next
 				lumpindex = file.FindLumpIndex("TEXTURES", lumpindex + 1);
 			}
 			
 			// Return result
 			return images;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptEditorForm.Designer.cs" startline="22" endline="65">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ScriptEditorForm));
 			this.editor = new CodeImp.DoomBuilder.Controls.ScriptEditorPanel();
 			this.SuspendLayout();
 			// 
 			// editor
 			// 
 			this.editor.BackColor = System.Drawing.SystemColors.Control;
 			this.editor.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.editor.Location = new System.Drawing.Point(0, 0);
 			this.editor.Name = "editor";
 			this.editor.Size = new System.Drawing.Size(729, 578);
 			this.editor.TabIndex = 0;
 			this.editor.TabStop = false;
 			// 
 			// ScriptEditorForm
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.ClientSize = new System.Drawing.Size(729, 578);
 			this.Controls.Add(this.editor);
 			this.DoubleBuffered = true;
 			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
 			this.KeyPreview = true;
 			this.Name = "ScriptEditorForm";
 			this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
 			this.Text = "Doom Builder Script Editor";
 			this.Load += new System.EventHandler(this.ScriptEditorForm_Load);
 			this.Shown += new System.EventHandler(this.ScriptEditorForm_Shown);
 			this.Move += new System.EventHandler(this.ScriptEditorForm_Move);
 			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.ScriptEditorForm_FormClosing);
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.ScriptEditorForm_HelpRequested);
 			this.ResizeEnd += new System.EventHandler(this.ScriptEditorForm_ResizeEnd);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\AngleControl.cs" startline="165" endline="178">
<![CDATA[
 		
 		// When checked state of a button changes
 		private void button_CheckedChanged(object sender, EventArgs e)
 		{
 			if(!settingangle)
 			{
 				// Check if we can get the angle from one of the buttons
 				for(int i = 0; i < 8; i++)
 					if(buttons[i].Checked) SetAngle(i * 45, false);
 				for(int i = 0; i < 8; i++)
 					if(buttons[i].Checked) SetAngle(i * 45, false);
 
 				// Raise event
 				if(ButtonClicked != null) ButtonClicked(this, EventArgs.Empty);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="287" endline="312">
<![CDATA[
 		
 		// This selectes the previous docker
 		public void SelectPrevious()
 		{
 			if(!string.IsNullOrEmpty(previousselected))
 			{
 				int index = 0;
 				foreach(TabPage page in tabs.TabPages)
 				{
 					if((page.Tag as Docker).FullName == previousselected)
 					{
 						if(iscollapsed)
 						{
 							previousselected = currentselected;
 							expandedtab = index;
 						}
 						else
 							tabs.SelectedTab = page;
 						
 						break;
 					}
 					
 					index++;
 				}
 				foreach(TabPage page in tabs.TabPages)
 				{
 					if((page.Tag as Docker).FullName == previousselected)
 					{
 						if(iscollapsed)
 						{
 							previousselected = currentselected;
 							expandedtab = index;
 						}
 						else
 							tabs.SelectedTab = page;
 						
 						break;
 					}
 					
 					index++;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\TextureStructure.cs" startline="259" endline="282">
<![CDATA[
 
 		// This makes a HighResImage texture for this texture
 		internal HighResImage MakeImage(Dictionary<long, ImageData> textures, Dictionary<long, ImageData> flats)
 		{
 			float scalex, scaley;
 			
 			// Determine default scale
 			float defaultscale = General.Map.Config.DefaultTextureScale;
 
 			// Determine scale for texture
 			if(xscale == 0.0f) scalex = defaultscale; else scalex = 1f / xscale;
 			if(yscale == 0.0f) scaley = defaultscale; else scaley = 1f / yscale;
 
 			// Make texture
 			HighResImage tex = new HighResImage(name, width, height, scalex, scaley, worldpanning);
 
 			// Add patches
 			foreach(PatchStructure p in patches)
 			{
 				tex.AddPatch(new TexturePatch(p.Name.ToUpperInvariant(), p.OffsetX, p.OffsetY, p.FlipX, p.FlipY, 0, new PixelColor(0, 0, 0, 0), p.Alpha, 0));
 			}
 			foreach(PatchStructure p in patches)
 			{
 				tex.AddPatch(new TexturePatch(p.Name.ToUpperInvariant(), p.OffsetX, p.OffsetY, p.FlipX, p.FlipY, 0, new PixelColor(0, 0, 0, 0), p.Alpha, 0));
 			}
 			
 			return tex;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="775" endline="792">
<![CDATA[
 		
 		// This checks if the given sprite exists
 		public override bool GetSpriteExists(string pname)
 		{
 			Lump lump;
 			
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find the lump in ranges
 			foreach(LumpRange range in spriteranges)
 			{
 				lump = file.FindLump(pname, range.start, range.end);
 				if(lump != null) return true;
 			}
 			foreach(LumpRange range in spriteranges)
 			{
 				lump = file.FindLump(pname, range.start, range.end);
 				if(lump != null) return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="130" endline="155">
<![CDATA[
 
 		// Refresher
 		private void refreshtimer_Tick(object sender, EventArgs e)
 		{
 			bool allpreviewsloaded = true;
 			
 			// Go for all items
 			foreach(ImageBrowserItem i in list.Items)
 			{
 				// Check if there are still previews that are not loaded
 				allpreviewsloaded &= i.IsPreviewLoaded;
 				
 				// Items needs to be redrawn?
 				if(i.CheckRedrawNeeded())
 				{
 					// Refresh item in list
 					//list.RedrawItems(i.Index, i.Index, false);
 					list.Invalidate();
 				}
 			}
 			foreach(ImageBrowserItem i in list.Items)
 			{
 				// Check if there are still previews that are not loaded
 				allpreviewsloaded &= i.IsPreviewLoaded;
 				
 				// Items needs to be redrawn?
 				if(i.CheckRedrawNeeded())
 				{
 					// Refresh item in list
 					//list.RedrawItems(i.Index, i.Index, false);
 					list.Invalidate();
 				}
 			}
 
 			// If all previews were loaded, stop this timer
 			if(allpreviewsloaded) refreshtimer.Stop();
 			
 			UpdateTextureSizeLabel();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="123" endline="136">
<![CDATA[
 		
 		// This adds a list of fixed fields (in undefined state)
 		public void ListFixedFields(List<UniversalFieldInfo> list)
 		{
 			// Add all fields
 			foreach(UniversalFieldInfo uf in list)
 				fieldslist.Rows.Add(new FieldsEditorRow(fieldslist, uf));
 			foreach(UniversalFieldInfo uf in list)
 				fieldslist.Rows.Add(new FieldsEditorRow(fieldslist, uf));
 
 			// Sort fields
 			Sort();
 
 			// Update new row
 			SetupNewRowStyle();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\TextLabel.cs" startline="127" endline="143">
<![CDATA[
 
 		// Diposer
 		public void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				UnloadResource();
 				
 				// Unregister resource
 				General.Map.Graphics.UnregisterResource(this);
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="569" endline="586">
<![CDATA[
 
 		// Linedef activates
 		private void LoadLinedefActivations()
 		{
 			IDictionary dic;
 			int bitvalue;
 
 			// Get linedef activations
 			dic = cfg.ReadSetting("linedefactivations", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				// Add to the list
 				linedefactivates.Add(new LinedefActivateInfo(de.Key.ToString(), de.Value.ToString()));
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Add to the list
 				linedefactivates.Add(new LinedefActivateInfo(de.Key.ToString(), de.Value.ToString()));
 			}
 
 			// Sort the list
 			linedefactivates.Sort();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="183" endline="193">
<![CDATA[
 
 		#endregion
 
 		#region ================== Events
 
 		public override bool OnUndoBegin()
 		{
 			renderer.SetCrosshairBusy(true);
 			General.Interface.RedrawDisplay();
 			return base.OnUndoBegin();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="201" endline="207">
<![CDATA[
 
 		public override bool OnRedoBegin()
 		{
 			renderer.SetCrosshairBusy(true);
 			General.Interface.RedrawDisplay();
 			return base.OnRedoBegin();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ActionSelectorControl.cs" startline="56" endline="72">
<![CDATA[
 
 		// This returns the numeric value
 		public int GetValue()
 		{
 			int val = 0;
 
 			if(number.Text.Length > 0)
 			{
 				try
 				{
 					val = Convert.ToInt32(number.Text);
 				}
 				catch(Exception e) { }
 			}
 			
 			return val;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="640" endline="649">
<![CDATA[
 
 		// Selection changes
 		private void fieldslist_SelectionChanged(object sender, EventArgs e)
 		{
 			browsebutton.Visible = false;
 			ApplyEnums(true);
 			
 			// Update button
 			UpdateBrowseButton();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="440" endline="453">
<![CDATA[
 		
 		// Remove texture set
 		private void removetextureset_Click(object sender, EventArgs e)
 		{
 			// Texture Set selected?
 			while(listtextures.SelectedItems.Count > 0)
 			{
 				// Remove from config info and list
 				DefinedTextureSet s = (listtextures.SelectedItems[0].Tag as DefinedTextureSet);
 				configinfo.TextureSets.Remove(s);
 				listtextures.SelectedItems[0].Remove();
 				reloadresources = true;
 			}
 			while(listtextures.SelectedItems.Count > 0)
 			{
 				// Remove from config info and list
 				DefinedTextureSet s = (listtextures.SelectedItems[0].Tag as DefinedTextureSet);
 				configinfo.TextureSets.Remove(s);
 				listtextures.SelectedItems[0].Remove();
 				reloadresources = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="366" endline="384">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Loading
 		
 		// This loads the map lumps
 		private void LoadMapLumps()
 		{
 			IDictionary dic;
 			
 			// Get map lumps list
 			dic = cfg.ReadSetting("maplumpnames", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				// Make map lumps
 				MapLumpInfo lumpinfo = new MapLumpInfo(de.Key.ToString(), cfg);
 				maplumps.Add(de.Key.ToString(), lumpinfo);
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Make map lumps
 				MapLumpInfo lumpinfo = new MapLumpInfo(de.Key.ToString(), cfg);
 				maplumps.Add(de.Key.ToString(), lumpinfo);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1290" endline="1309">
<![CDATA[
 
 		// This compiles all lumps that require compiling and stores the results
 		// Returns true when our code worked properly (even when the compiler returned errors)
 		private bool CompileScriptLumps()
 		{
 			bool success = true;
 			errors.Clear();
 			
 			// Go for all the map lumps
 			foreach(MapLumpInfo lumpinfo in config.MapLumps.Values)
 			{
 				// Is this a script lump?
 				if(lumpinfo.script != null)
 				{
 					// Compile it now
 					success &= CompileLump(lumpinfo.name, false);
 				}
 			}
 			foreach(MapLumpInfo lumpinfo in config.MapLumps.Values)
 			{
 				// Is this a script lump?
 				if(lumpinfo.script != null)
 				{
 					// Compile it now
 					success &= CompileLump(lumpinfo.name, false);
 				}
 			}
 			return success;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="143" endline="158">
<![CDATA[
 
 		// New Filter clicked
 		private void addfilter_Click(object sender, EventArgs e)
 		{
 			ThingsFilter newf = new ThingsFilter();
 
 			// Make item in list and select it
 			ListViewItem item = new ListViewItem(newf.Name);
 			item.Tag = newf;
 			listfilters.Items.Add(item);
 			item.Selected = true;
 
 			// Focus on the name field
 			filtername.Focus();
 			filtername.SelectAll();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.cs" startline="76" endline="89">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Events
 
 		// When resized
 		private void ImageSelectorControl_Resize(object sender, EventArgs e)
 		{
 			// Fixed size
 			preview.Width = this.ClientSize.Width;
 			preview.Height = this.ClientSize.Height - name.Height - 4;
 			name.Width = this.ClientSize.Width;
 			name.Top = this.ClientSize.Height - name.Height;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="625" endline="661">
<![CDATA[
 
 		// This adds a surface entry to the list of surfaces
 		private void AddSurfaceEntryForRendering(SurfaceEntry entry, long longimagename)
 		{
 			// Determine texture to use
 			ImageData img;
 			if(longimagename == 0)
 			{
 				img = General.Map.Data.WhiteTexture;
 			}
 			else
 			{
 				if(General.Map.Data.GetFlatExists(longimagename))
 				{
 					img = General.Map.Data.GetFlatImageKnown(longimagename);
 					
 					// Is the texture loaded?
 					if(img.IsImageLoaded && !img.LoadFailed)
 					{
 						if(img.Texture == null) img.CreateTexture();
 					}
 					else
 					{
 						img = General.Map.Data.WhiteTexture;
 					}
 				}
 				else
 				{
 					img = General.Map.Data.UnknownTexture3D;
 				}
 			}
 			
 			// Store by texture
 			if(!surfaces.ContainsKey(img))
 				surfaces.Add(img, new List<SurfaceEntry>());
 			surfaces[img].Add(entry);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="403" endline="410">
<![CDATA[
 
 		// This returns a list of all actions
 		internal Action[] GetAllActions()
 		{
 			Action[] list = new Action[actions.Count];
 			actions.Values.CopyTo(list, 0);
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapElement.cs" startline="84" endline="113">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// Serialize / deserialize
 		internal void ReadWrite(IReadWriteStream s)
 		{
 			int c = fields.Count;
 			s.rwInt(ref c);
 
 			if(s.IsWriting)
 			{
 				foreach(KeyValuePair<string, UniValue> f in fields)
 				{
 					s.wString(f.Key);
 					f.Value.ReadWrite(s);
 				}
 				foreach(KeyValuePair<string, UniValue> f in fields)
 				{
 					s.wString(f.Key);
 					f.Value.ReadWrite(s);
 				}
 			}
 			else
 			{
 				fields = new UniFields(this, c);
 				for(int i = 0; i < c; i++)
 				{
 					string t; s.rString(out t);
 					UniValue v = new UniValue(); v.ReadWrite(s);
 					fields.Add(t, v);
 				}
 				for(int i = 0; i < c; i++)
 				{
 					string t; s.rString(out t);
 					UniValue v = new UniValue(); v.ReadWrite(s);
 					fields.Add(t, v);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\BitFlagsForm.cs" startline="107" endline="120">
<![CDATA[
 
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			this.value = 0;
 			
 			// Go for all checkboxes to make the final value
 			foreach(CheckBox b in options.Checkboxes)
 				if(b.Checked) value |= (int)b.Tag;
 			foreach(CheckBox b in options.Checkboxes)
 				if(b.Checked) value |= (int)b.Tag;
 			
 			// Done
 			DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="722" endline="742">
<![CDATA[
 
 		// Default thing flags
 		private void LoadDefaultThingFlags()
 		{
 			IDictionary dic;
 
 			// Get linedef flags
 			dic = cfg.ReadSetting("defaultthingflags", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				// Check if flag exists
 				if(thingflags.ContainsKey(de.Key.ToString()))
 				{
 					defaultthingflags.Add(de.Key.ToString());
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'defaultthingflags' contains unknown thing flags in game configuration '" + this.Name + "'");
 				}
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Check if flag exists
 				if(thingflags.ContainsKey(de.Key.ToString()))
 				{
 					defaultthingflags.Add(de.Key.ToString());
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'defaultthingflags' contains unknown thing flags in game configuration '" + this.Name + "'");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="121" endline="144">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Management
 
 		// Called when all resource must be unloaded
 		public void UnloadResource()
 		{
 			resourcesunloaded = true;
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				// Dispose vertex buffers
 				for(int i = 0; i < set.Value.buffers.Count; i++)
 				{
 					if(set.Value.buffers[i] != null)
 					{
 						set.Value.buffers[i].Dispose();
 						set.Value.buffers[i] = null;
 					}
 				}
 				for(int i = 0; i < set.Value.buffers.Count; i++)
 				{
 					if(set.Value.buffers[i] != null)
 					{
 						set.Value.buffers[i].Dispose();
 						set.Value.buffers[i] = null;
 					}
 				}
 			}
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				// Dispose vertex buffers
 				for(int i = 0; i < set.Value.buffers.Count; i++)
 				{
 					if(set.Value.buffers[i] != null)
 					{
 						set.Value.buffers[i].Dispose();
 						set.Value.buffers[i] = null;
 					}
 				}
 			}
 			
 			lockedbuffers.Clear();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="555" endline="581">
<![CDATA[
 		
 		// This refills the start mode cobobox
 		private void RefillStartModes()
 		{
 			// Refill the startmode combobox
 			startmode.Items.Clear();
 			foreach(ListViewItem item in listmodes.Items)
 			{
 				if(item.Checked)
 				{
 					EditModeInfo emi = (item.Tag as EditModeInfo);
 					if(emi.Attributes.SafeStartMode)
 					{
 						int newindex = startmode.Items.Add(emi);
 						if(emi.Type.Name == configinfo.StartMode) startmode.SelectedIndex = newindex;
 					}
 				}
 			}
 			foreach(ListViewItem item in listmodes.Items)
 			{
 				if(item.Checked)
 				{
 					EditModeInfo emi = (item.Tag as EditModeInfo);
 					if(emi.Attributes.SafeStartMode)
 					{
 						int newindex = startmode.Items.Add(emi);
 						if(emi.Type.Name == configinfo.StartMode) startmode.SelectedIndex = newindex;
 					}
 				}
 			}
 			
 			// Select the first in the combobox if none are selected
 			if((startmode.SelectedItem == null) && (startmode.Items.Count > 0))
 			{
 				startmode.SelectedIndex = 0;
 				EditModeInfo emi = (startmode.SelectedItem as EditModeInfo);
 				configinfo.StartMode = emi.Type.Name;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="281" endline="320">
<![CDATA[
 		
 		// This makes new vertices as well as floor and ceiling surfaces
 		internal void CreateSurfaces()
 		{
 			if(updateneeded)
 			{
 				// Brightness color
 				int brightint = General.Map.Renderer2D.CalculateBrightness(brightness);
 				
 				// Make vertices
 				flatvertices = new FlatVertex[triangles.Vertices.Count];
 				for(int i = 0; i < triangles.Vertices.Count; i++)
 				{
 					flatvertices[i].x = triangles.Vertices[i].x;
 					flatvertices[i].y = triangles.Vertices[i].y;
 					flatvertices[i].z = 1.0f;
 					flatvertices[i].c = brightint;
 					flatvertices[i].u = triangles.Vertices[i].x;
 					flatvertices[i].v = triangles.Vertices[i].y;
 				}
 				for(int i = 0; i < triangles.Vertices.Count; i++)
 				{
 					flatvertices[i].x = triangles.Vertices[i].x;
 					flatvertices[i].y = triangles.Vertices[i].y;
 					flatvertices[i].z = 1.0f;
 					flatvertices[i].c = brightint;
 					flatvertices[i].u = triangles.Vertices[i].x;
 					flatvertices[i].v = triangles.Vertices[i].y;
 				}
 
 				// Create bounding box
 				bbox = CreateBBox();
 				
 				// Make update info (this lets the plugin fill in texture coordinates and such)
 				SurfaceUpdate updateinfo = new SurfaceUpdate(flatvertices.Length, true, true);
 				flatvertices.CopyTo(updateinfo.floorvertices, 0);
 				General.Plugins.OnSectorFloorSurfaceUpdate(this, ref updateinfo.floorvertices);
 				flatvertices.CopyTo(updateinfo.ceilvertices, 0);
 				General.Plugins.OnSectorCeilingSurfaceUpdate(this, ref updateinfo.ceilvertices);
 				updateinfo.floortexture = longfloortexname;
 				updateinfo.ceiltexture = longceiltexname;
 
 				// Update surfaces
 				General.Map.CRenderer2D.Surfaces.UpdateSurfaces(surfaceentries, updateinfo);
 
 				// Updated
 				updateneeded = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2727" endline="2740">
<![CDATA[
 
 		#endregion
 
 		#region ================== Dockers
 		
 		// This adds a docker
 		public void AddDocker(Docker d)
 		{
 			// Make sure the full name is set with the plugin name as prefix
 			Plugin plugin = General.Plugins.FindPluginByAssembly(Assembly.GetCallingAssembly());
 			d.MakeFullName(plugin.Name.ToLowerInvariant());
 			
 			dockerspanel.Add(d);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\SerializerStream.cs" startline="166" endline="172">
<![CDATA[
 
 		public void wVector3D(Vector3D v)
 		{
 			writer.Write(v.x);
 			writer.Write(v.y);
 			writer.Write(v.z);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="523" endline="547">
<![CDATA[
 		
 		// This is called when an editing mode item is checked or unchecked
 		private void listmodes_ItemChecked(object sender, ItemCheckedEventArgs e)
 		{
 			// Leave when no configuration selected
 			if(configinfo == null) return;
 			
 			// Apply changes
 			EditModeInfo emi = (e.Item.Tag as EditModeInfo);
 			bool currentstate = (configinfo.EditModes.ContainsKey(emi.Type.FullName) && configinfo.EditModes[emi.Type.FullName]);
 			if(e.Item.Checked && !currentstate)
 			{
 				// Add
 				configinfo.EditModes[emi.Type.FullName] = true;
 			}
 			else if(!e.Item.Checked && currentstate)
 			{
 				// Remove
 				configinfo.EditModes[emi.Type.FullName] = false;
 			}
 			
 			preventchanges = true;
 			RefillStartModes();
 			preventchanges = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\EnumStringsHandler.cs" startline="74" endline="127">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		public override void SetValue(object value)
 		{
 			this.value = null;
 
 			// Input null?
 			if(value == null)
 			{
 				this.value = new EnumItem("", "");
 			}
 			else
 			{
 				// No match found yet?
 				if(this.value == null)
 				{
 					// First try to match the value against the enum values
 					foreach(EnumItem item in list)
 					{
 						// Matching value?
 						if(item.Value == value.ToString())
 						{
 							// Set this value
 							this.value = item;
 						}
 					}
 					foreach(EnumItem item in list)
 					{
 						// Matching value?
 						if(item.Value == value.ToString())
 						{
 							// Set this value
 							this.value = item;
 						}
 					}
 				}
 
 				// No match found yet?
 				if(this.value == null)
 				{
 					// Try to match against the titles
 					foreach(EnumItem item in list)
 					{
 						// Matching value?
 						if(item.Title.ToLowerInvariant() == value.ToString().ToLowerInvariant())
 						{
 							// Set this value
 							this.value = item;
 						}
 					}
 					foreach(EnumItem item in list)
 					{
 						// Matching value?
 						if(item.Title.ToLowerInvariant() == value.ToString().ToLowerInvariant())
 						{
 							// Set this value
 							this.value = item;
 						}
 					}
 				}
 
 				// Still no match found?
 				if(this.value == null)
 				{
 					// Make a dummy value
 					this.value = new EnumItem(value.ToString(), value.ToString());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="235" endline="279">
<![CDATA[
 
 		// This zooms
 		private void ZoomBy(float deltaz)
 		{
 			Vector2D zoompos, clientsize, diff;
 			float newscale;
 			
 			// This will be the new zoom scale
 			newscale = renderer2d.Scale * deltaz;
 
 			// Limit scale
 			if(newscale > SCALE_MAX) newscale = SCALE_MAX;
 			if(newscale < SCALE_MIN) newscale = SCALE_MIN;
 			
 			// Get the dimensions of the display
 			clientsize = new Vector2D(General.Map.Graphics.RenderTarget.ClientSize.Width,
 									  General.Map.Graphics.RenderTarget.ClientSize.Height);
 			
 			// When mouse is inside display
 			if(mouseinside)
 			{
 				// Zoom into or from mouse position
 				zoompos = (mousepos / clientsize) - new Vector2D(0.5f, 0.5f);
 			}
 			else
 			{
 				// Zoom into or from center
 				zoompos = new Vector2D(0f, 0f);
 			}
 
 			// Calculate view position difference
 			diff = ((clientsize / newscale) - (clientsize / renderer2d.Scale)) * zoompos;
 
 			// Zoom now
 			renderer2d.PositionView(renderer2d.OffsetX - diff.x, renderer2d.OffsetY + diff.y);
 			renderer2d.ScaleView(newscale);
 			this.OnViewChanged();
 
 			// Redraw
 			//General.Map.Map.Update();
 			General.MainWindow.RedrawDisplay();
 			
 			// Give a new mousemove event to update coordinates
 			if(mouseinside) OnMouseMove(new MouseEventArgs(mousebuttons, 0, (int)mousepos.x, (int)mousepos.y, 0));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ActionBrowserForm.cs" startline="218" endline="262">
<![CDATA[
 
 		// Generalized category selected
 		private void category_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			GeneralizedCategory ac;
 			
 			// Category selected?
 			if(category.SelectedIndex > -1)
 			{
 				// Get the category
 				ac = category.SelectedItem as GeneralizedCategory;
 				
 				// Go for all options
 				for(int i = 0; i < MAX_OPTIONS; i++)
 				{
 					// Option used in selected category?
 					if(i < ac.Options.Count)
 					{
 						// Setup controls
 						optionlbls[i].Text = ac.Options[i].Name + "
 						options[i].Items.Clear();
 						options[i].Items.AddRange(ac.Options[i].Bits.ToArray());
 						
 						// Show option
 						options[i].Visible = true;
 						optionlbls[i].Visible = true;
 					}
 					else
 					{
 						// Hide option
 						options[i].Visible = false;
 						optionlbls[i].Visible = false;
 					}
 				}
 				for(int i = 0; i < MAX_OPTIONS; i++)
 				{
 					// Option used in selected category?
 					if(i < ac.Options.Count)
 					{
 						// Setup controls
 						optionlbls[i].Text = ac.Options[i].Name + "
 						options[i].Items.Clear();
 						options[i].Items.AddRange(ac.Options[i].Bits.ToArray());
 						
 						// Show option
 						options[i].Visible = true;
 						optionlbls[i].Visible = true;
 					}
 					else
 					{
 						// Hide option
 						options[i].Visible = false;
 						optionlbls[i].Visible = false;
 					}
 				}
 			}
 			else
 			{
 				// Hide all options
 				for(int i = 0; i < MAX_OPTIONS; i++)
 				{
 					options[i].Visible = false;
 					optionlbls[i].Visible = false;
 				}
 				for(int i = 0; i < MAX_OPTIONS; i++)
 				{
 					options[i].Visible = false;
 					optionlbls[i].Visible = false;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="428" endline="441">
<![CDATA[
 
 		// This invokes the Begin and End of the given action
 		public bool InvokeAction(string actionname)
 		{
 			if(Exists(actionname))
 			{
 				actions[actionname].Invoke();
 				return true;
 			}
 			else
 			{
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptFileDocumentTab.cs" startline="187" endline="210">
<![CDATA[
 		
 		// This opens a file and returns true when successful
 		public bool Open(string filepathname)
 		{
 			try
 			{
 				// Read the file
 				editor.SetText(File.ReadAllBytes(filepathname));
 			}
 			catch(Exception e)
 			{
 				// Failed
 				General.ErrorLogger.Add(ErrorType.Error, "Cannot open file '" + filepathname + "' for reading. Make sure the path exists and that the file is not in use by another application.");
 				General.WriteLogLine(e.GetType().Name + "
 				General.ShowErrorMessage("Unable to open file \"" + filepathname + "\" for reading. Make sure the path exists and that the file is not in use by another application.", MessageBoxButtons.OK);
 				return false;
 			}
 			
 			// Setup
 			this.filepathname = filepathname;
 			SetTitle(Path.GetFileName(filepathname));
 			editor.ClearUndoRedo();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\LinedefInfoPanel.cs" startline="242" endline="277">
<![CDATA[
 
 		// This shows a sidedef texture in a panel
 		private void DisplaySidedefTexture(Panel panel, string name, bool required)
 		{
 			// Check if name is a "none" texture
 			if((name.Length < 1) || (name[0] == '-'))
 			{
 				// Determine image to show
 				if(required)
 					panel.BackgroundImage = CodeImp.DoomBuilder.Properties.Resources.MissingTexture;
 				else
 					panel.BackgroundImage = null;
 			}
 			else
 			{
 				// Set the image
 				panel.BackgroundImage = General.Map.Data.GetTextureImage(name).GetPreview();
 			}
 			
 			// Image not null?
 			if(panel.BackgroundImage != null)
 			{
 				// Small enough to fit in panel?
 				if((panel.BackgroundImage.Size.Width < panel.ClientRectangle.Width) &&
 				   (panel.BackgroundImage.Size.Height < panel.ClientRectangle.Height))
 				{
 					// Display centered
 					panel.BackgroundImageLayout = ImageLayout.Center;
 				}
 				else
 				{
 					// Display zoomed
 					panel.BackgroundImageLayout = ImageLayout.Zoom;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ConfigurationInfo.cs" startline="260" endline="304">
<![CDATA[
 		
 		// This applies the defaults
 		internal void ApplyDefaults(GameConfiguration gameconfig)
 		{
 			// Some of the defaults can only be applied from game configuration
 			if(gameconfig != null)
 			{
 				// No nodebuildes set?
 				if(nodebuildersave == MISSING_NODEBUILDER) nodebuildersave = gameconfig.DefaultSaveCompiler;
 				if(nodebuildertest == MISSING_NODEBUILDER) nodebuildertest = gameconfig.DefaultTestCompiler;
 				
 				// No texture sets?
 				if(texturesets.Count == 0)
 				{
 					// Copy the default texture sets from the game configuration
 					foreach(DefinedTextureSet s in gameconfig.TextureSets)
 					{
 						// Add a copy to our list
 						texturesets.Add(s.Copy());
 					}
 					foreach(DefinedTextureSet s in gameconfig.TextureSets)
 					{
 						// Add a copy to our list
 						texturesets.Add(s.Copy());
 					}
 				}
 				
 				// No things filters?
 				if(thingsfilters.Count == 0)
 				{
 					// Copy the things filters from game configuration
 					foreach(ThingsFilter f in gameconfig.ThingsFilters)
 					{
 						thingsfilters.Add(new ThingsFilter(f));
 					}
 					foreach(ThingsFilter f in gameconfig.ThingsFilters)
 					{
 						thingsfilters.Add(new ThingsFilter(f));
 					}
 				}
 			}
 			
 			// Go for all available editing modes
 			foreach(EditModeInfo info in General.Editing.ModesInfo)
 			{
 				// Is this a mode thats is optional?
 				if(info.IsOptional)
 				{
 					// Add if not listed yet
 					if(!editmodes.ContainsKey(info.Type.FullName))
 						editmodes.Add(info.Type.FullName, info.Attributes.UseByDefault);
 				}
 			}
 			foreach(EditModeInfo info in General.Editing.ModesInfo)
 			{
 				// Is this a mode thats is optional?
 				if(info.IsOptional)
 				{
 					// Add if not listed yet
 					if(!editmodes.ContainsKey(info.Type.FullName))
 						editmodes.Add(info.Type.FullName, info.Attributes.UseByDefault);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypesManager.cs" startline="100" endline="122">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This returns the type handler for the given argument
 		public TypeHandler GetArgumentHandler(ArgumentInfo arginfo)
 		{
 			Type t = typeof(NullHandler);
 			TypeHandlerAttribute ta = null;
 			
 			// Do we have a handler type for this?
 			if(handlertypes.ContainsKey(arginfo.Type))
 			{
 				ta = handlertypes[arginfo.Type];
 				t = ta.Type;
 			}
 
 			// Create instance
 			TypeHandler th = (TypeHandler)General.ThisAssembly.CreateInstance(t.FullName);
 			th.SetupArgument(ta, arginfo);
 			return th;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\PasteOptionsControl.cs" startline="66" endline="83">
<![CDATA[
 		
 		// This returns the options as set by the user
 		public PasteOptions GetOptions()
 		{
 			PasteOptions options = new PasteOptions();
 			
 			// Collect settings
 			if(keeptags.Checked)
 				options.ChangeTags = 0;
 			else if(renumbertags.Checked)
 				options.ChangeTags = 1;
 			else if(removetags.Checked)
 				options.ChangeTags = 2;
 			options.RemoveActions = removeactions.Checked;
 			options.AdjustHeights = adjustheights.Checked;
 			
 			return options;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1118" endline="1178">
<![CDATA[
 		
 		// This returns an image by long
 		public ImageData GetSpriteImage(string name)
 		{
 			// Is this referring to an internal sprite image?
 			if((name.Length > INTERNAL_PREFIX.Length) && name.ToLowerInvariant().StartsWith(INTERNAL_PREFIX))
 			{
 				// Get the internal sprite
 				string internalname = name.Substring(INTERNAL_PREFIX.Length).ToLowerInvariant();
 				if(internalsprites.ContainsKey(internalname))
 				{
 					return internalsprites[internalname];
 				}
 				else
 				{
 					return new UnknownImage(Properties.Resources.UnknownImage);
 				}
 			}
 			else
 			{
 				// Get the long name
 				long longname = Lump.MakeLongName(name);
 
 				// Sprite already loaded?
 				if(sprites.ContainsKey(longname))
 				{
 					// Return exiting sprite
 					return sprites[longname];
 				}
 				else
 				{
 					Stream spritedata = null;
 					
 					// Go for all opened containers
 					for(int i = containers.Count - 1; i >= 0; i--)
 					{
 						// This contain provides this sprite?
 						spritedata = containers[i].GetSpriteData(name);
 						if(spritedata != null) break;
 					}
 					for(int i = containers.Count - 1; i >= 0; i--)
 					{
 						// This contain provides this sprite?
 						spritedata = containers[i].GetSpriteData(name);
 						if(spritedata != null) break;
 					}
 					
 					// Found anything?
 					if(spritedata != null)
 					{
 						// Make new sprite image
 						SpriteImage image = new SpriteImage(name);
 
 						// Add to collection
 						sprites.Add(longname, image);
 
 						// Return result
 						return image;
 					}
 					else
 					{
 						// Return null image
 						return new UnknownImage(Properties.Resources.UnknownImage);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="146" endline="186">
<![CDATA[
 		
 		// Serialize / deserialize
 		internal void ReadWrite(IReadWriteStream s)
 		{
 			if(!s.IsWriting) BeforePropsChange();
 			
 			base.ReadWrite(s);
 
 			if(s.IsWriting)
 			{
 				s.wInt(flags.Count);
 				
 				foreach(KeyValuePair<string, bool> f in flags)
 				{
 					s.wString(f.Key);
 					s.wBool(f.Value);
 				}
 				foreach(KeyValuePair<string, bool> f in flags)
 				{
 					s.wString(f.Key);
 					s.wBool(f.Value);
 				}
 			}
 			else
 			{
 				int c; s.rInt(out c);
 
 				flags = new Dictionary<string, bool>(c);
 				for(int i = 0; i < c; i++)
 				{
 					string t; s.rString(out t);
 					bool b; s.rBool(out b);
 					flags.Add(t, b);
 				}
 				for(int i = 0; i < c; i++)
 				{
 					string t; s.rString(out t);
 					bool b; s.rBool(out b);
 					flags.Add(t, b);
 				}
 			}
 			
 			s.rwInt(ref type);
 			s.rwVector3D(ref pos);
 			s.rwInt(ref angledoom);
 			s.rwInt(ref tag);
 			s.rwInt(ref action);
 			for(int i = 0; i < NUM_ARGS; i++) s.rwInt(ref args[i]);
 			
 			if(!s.IsWriting)
 				anglerad = Angle2D.DoomToReal(angledoom);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="323" endline="361">
<![CDATA[
 		
 		// This shows the errors panel with the given errors
 		// Also updates the scripts with markers for the given errors
 		public void ShowErrors(IEnumerable<CompilerError> errors)
 		{
 			// Copy list
 			if(errors != null)
 				compilererrors = new List<CompilerError>(errors);
 			else
 				compilererrors = new List<CompilerError>();
 			
 			// Fill list
 			errorlist.BeginUpdate();
 			errorlist.Items.Clear();
 			int listindex = 1;
 			foreach(CompilerError e in compilererrors)
 			{
 				ListViewItem ei = new ListViewItem(listindex.ToString());
 				ei.ImageIndex = 0;
 				ei.SubItems.Add(e.description);
 				if(e.filename.StartsWith("?"))
 					ei.SubItems.Add(e.filename.Replace("?", "") + " (line " + e.linenumber.ToString() + ")");
 				else
 					ei.SubItems.Add(Path.GetFileName(e.filename) + " (line " + e.linenumber.ToString() + ")");
 				ei.Tag = e;
 				errorlist.Items.Add(ei);
 				listindex++;
 			}
 			foreach(CompilerError e in compilererrors)
 			{
 				ListViewItem ei = new ListViewItem(listindex.ToString());
 				ei.ImageIndex = 0;
 				ei.SubItems.Add(e.description);
 				if(e.filename.StartsWith("?"))
 					ei.SubItems.Add(e.filename.Replace("?", "") + " (line " + e.linenumber.ToString() + ")");
 				else
 					ei.SubItems.Add(Path.GetFileName(e.filename) + " (line " + e.linenumber.ToString() + ")");
 				ei.Tag = e;
 				errorlist.Items.Add(ei);
 				listindex++;
 			}
 			errorlist.EndUpdate();
 			
 			// Show marks on scripts
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				t.MarkScriptErrors(compilererrors);
 			}
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				t.MarkScriptErrors(compilererrors);
 			}
 			
 			// Show/hide panel
 			splitter.Panel2Collapsed = (errorlist.Items.Count == 0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="301" endline="348">
<![CDATA[
 
 		#endregion
 
 		#region ================== Textures
 
 		// This loads the textures
 		public override ICollection<ImageData> LoadTextures(PatchNames pnames)
 		{
 			List<ImageData> images = new List<ImageData>();
 			string rangestart, rangeend;
 			int lumpindex;
 			Lump lump;
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Load two sets of textures, if available
 			lump = file.FindLump("TEXTURE1");
 			if(lump != null) LoadTextureSet("TEXTURE1", lump.Stream, ref images, pnames);
 			lump = file.FindLump("TEXTURE2");
 			if(lump != null) LoadTextureSet("TEXTURE2", lump.Stream, ref images, pnames);
 			
 			// Read ranges from configuration
 			foreach(LumpRange range in textureranges)
 			{
 				// Load texture range
 				LoadTexturesRange(range.start, range.end, ref images, pnames);
 			}
 			foreach(LumpRange range in textureranges)
 			{
 				// Load texture range
 				LoadTexturesRange(range.start, range.end, ref images, pnames);
 			}
 			
 			// Load TEXTURES lump file
 			lumpindex = file.FindLumpIndex("TEXTURES");
 			while(lumpindex > -1)
 			{
 				MemoryStream filedata = new MemoryStream(file.Lumps[lumpindex].Stream.ReadAllBytes());
 				WADReader.LoadHighresTextures(filedata, "TEXTURES", ref images, null, null);
 				filedata.Dispose();
 				
 				// Find next
 				lumpindex = file.FindLumpIndex("TEXTURES", lumpindex + 1);
 			}
 			while(lumpindex > -1)
 			{
 				MemoryStream filedata = new MemoryStream(file.Lumps[lumpindex].Stream.ReadAllBytes());
 				WADReader.LoadHighresTextures(filedata, "TEXTURES", ref images, null, null);
 				filedata.Dispose();
 				
 				// Find next
 				lumpindex = file.FindLumpIndex("TEXTURES", lumpindex + 1);
 			}
 			
 			// Add images to the container-specific texture set
 			foreach(ImageData img in images)
 				textureset.AddTexture(img);
 			foreach(ImageData img in images)
 				textureset.AddTexture(img);
 
 			// Return result
 			return images;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageSelectorControl.Designer.cs" startline="23" endline="77">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.preview = new System.Windows.Forms.Panel();
 			this.name = new CodeImp.DoomBuilder.Controls.AutoSelectTextbox();
 			this.SuspendLayout();
 			// 
 			// preview
 			// 
 			this.preview.BackColor = System.Drawing.SystemColors.AppWorkspace;
 			this.preview.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Zoom;
 			this.preview.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.preview.Location = new System.Drawing.Point(0, 0);
 			this.preview.Name = "preview";
 			this.preview.Size = new System.Drawing.Size(68, 60);
 			this.preview.TabIndex = 1;
 			this.preview.MouseLeave += new System.EventHandler(this.preview_MouseLeave);
 			this.preview.MouseMove += new System.Windows.Forms.MouseEventHandler(this.preview_MouseMove);
 			this.preview.Click += new System.EventHandler(this.preview_Click);
 			this.preview.MouseDown += new System.Windows.Forms.MouseEventHandler(this.preview_MouseDown);
 			this.preview.MouseUp += new System.Windows.Forms.MouseEventHandler(this.preview_MouseUp);
 			this.preview.MouseEnter += new System.EventHandler(this.preview_MouseEnter);
 			// 
 			// name
 			// 
 			this.name.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
 			this.name.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.CustomSource;
 			this.name.CharacterCasing = System.Windows.Forms.CharacterCasing.Upper;
 			this.name.Location = new System.Drawing.Point(0, 64);
 			this.name.MaxLength = 8;
 			this.name.Name = "name";
 			this.name.Size = new System.Drawing.Size(68, 20);
 			this.name.TabIndex = 2;
 			this.name.TextChanged += new System.EventHandler(this.name_TextChanged);
 			// 
 			// ImageSelectorControl
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.name);
 			this.Controls.Add(this.preview);
 			this.Name = "ImageSelectorControl";
 			this.Size = new System.Drawing.Size(115, 136);
 			this.Layout += new System.Windows.Forms.LayoutEventHandler(this.ImageSelectorControl_Layout);
 			this.Resize += new System.EventHandler(this.ImageSelectorControl_Resize);
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1434" endline="1484">
<![CDATA[
 		
 		// This updates the things filter on the toolbar
 		internal void UpdateThingsFilters()
 		{
 			// Only possible to list filters when a map is open
 			if(General.Map != null)
 			{
 				ThingsFilter oldfilter = null;
 				if(thingfilters.SelectedIndex > -1)
 					oldfilter = thingfilters.SelectedItem as ThingsFilter;
 				
 				updatingfilters = true;
 
 				// Clear the list
 				thingfilters.Items.Clear();
 
 				// Add null filter
 				if(General.Map.ThingsFilter is NullThingsFilter)
 					thingfilters.Items.Add(General.Map.ThingsFilter);
 				else
 					thingfilters.Items.Add(new NullThingsFilter());
 
 				// Add all filters
 				foreach(ThingsFilter f in General.Map.ConfigSettings.ThingsFilters)
 					thingfilters.Items.Add(f);
 				foreach(ThingsFilter f in General.Map.ConfigSettings.ThingsFilters)
 					thingfilters.Items.Add(f);
 
 				// Select current filter
 				foreach(ThingsFilter f in thingfilters.Items)
 					if(f == General.Map.ThingsFilter) thingfilters.SelectedItem = f;
 				foreach(ThingsFilter f in thingfilters.Items)
 					if(f == General.Map.ThingsFilter) thingfilters.SelectedItem = f;
 
 				updatingfilters = false;
 				
 				// No filter selected?
 				if(thingfilters.SelectedIndex == -1)
 				{
 					// Select the first and update
 					thingfilters.SelectedIndex = 0;
 				}
 				// Another filter got selected?
 				else if(oldfilter != (thingfilters.SelectedItem as ThingsFilter))
 				{
 					// Update!
 					thingfilters_SelectedIndexChanged(this, EventArgs.Empty);
 				}
 			}
 			else
 			{
 				// Clear the list
 				thingfilters.Items.Clear();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Plane.cs" startline="94" endline="116">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		/// <summary>
 		/// This tests for intersection with a line.
 		/// See http
 		/// </summary>
 		public bool GetIntersection(Vector3D from, Vector3D to, ref float u_ray)
 		{
 			float w = Vector3D.DotProduct(normal, from - to);
 			if(w != 0.0f)
 			{
 				float v = Vector3D.DotProduct(normal, from);
 				u_ray = (offset + v) / w;
 				return true;
 			}
 			else
 			{
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\TextureSelectorControl.cs" startline="48" endline="57">
<![CDATA[
 
 		// Setup
 		public override void Initialize()
 		{
 			base.Initialize();
 			
 			// Fill autocomplete list
 			name.AutoCompleteCustomSource.AddRange(General.Map.Data.TextureNames.ToArray());
 			allowclear = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalMapSetIO.cs" startline="165" endline="193">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Writing
 
 		// This writes a MapSet to the file
 		public override void Write(MapSet map, string mapname, int position)
 		{
 			UniversalStreamWriter udmfwriter = new UniversalStreamWriter();
 			
 			// Write map to memory stream
 			MemoryStream memstream = new MemoryStream();
 			memstream.Seek(0, SeekOrigin.Begin);
 			udmfwriter.RememberCustomTypes = true;
 			udmfwriter.Write(map, memstream, manager.Config.EngineName);
 
 			// Find insert position and remove old lump
 			int insertpos = MapManager.RemoveSpecificLump(wad, "TEXTMAP", position, MapManager.TEMP_MAP_HEADER, manager.Config.MapLumpNames);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 
 			// Create the lump from memory
 			Lump lump = wad.Insert("TEXTMAP", insertpos, (int)memstream.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			memstream.WriteTo(lump.Stream);
 
 			// Done
 			memstream.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="194" endline="213">
<![CDATA[
 		
 		// After deserialization we need to find the actual sidedefs back
 		internal void PostDeserialize(MapSet map)
 		{
 			// Find our sidedefs
 			List<Sidedef> sides = new List<Sidedef>(sidedefindices.Length);
 			for(int i = 0; i < sidedefindices.Length; i++)
 			{
 				if(sidedefindices[i] >= 0)
 					sides.Add(map.SidedefIndices[sidedefindices[i]);
 				else
 					sides.Add(null);
 			}
 			for(int i = 0; i < sidedefindices.Length; i++)
 			{
 				if(sidedefindices[i] >= 0)
 					sides.Add(map.SidedefIndices[sidedefindices[i]);
 				else
 					sides.Add(null);
 			}
 			
 			// We don't need this array any longer
 			sidedefindices = null;
 			
 			// Keep readonly array
 			sidedefs = Array.AsReadOnly<Sidedef>(sides.ToArray());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlagsForm.cs" startline="87" endline="108">
<![CDATA[
 
 		private void apply_Click(object sender, EventArgs e)
 		{
 			value = "";
 
 			foreach (CheckBox c in flags.Checkboxes)
 			{
 				if(c.Checked == false) continue;
 
 				foreach (KeyValuePair<string, string> lf in flagdefs)
 				{
 					if (lf.Value == c.Text)
 					{
 						if (value != "") value += ",";
 						value += lf.Key.ToString();
 					}
 				}
 				foreach (KeyValuePair<string, string> lf in flagdefs)
 				{
 					if (lf.Value == c.Text)
 					{
 						if (value != "") value += ",";
 						value += lf.Key.ToString();
 					}
 				}
 			}
 			foreach (CheckBox c in flags.Checkboxes)
 			{
 				if(c.Checked == false) continue;
 
 				foreach (KeyValuePair<string, string> lf in flagdefs)
 				{
 					if (lf.Value == c.Text)
 					{
 						if (value != "") value += ",";
 						value += lf.Key.ToString();
 					}
 				}
 			}
 
 			DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlagsForm.cs" startline="35" endline="67">
<![CDATA[
 
 		// Setup from EnumList
 		public void Setup(string value, IDictionary<string, string> inflags)
 		{
 			setup = true;
 			this.value = value;
 			flagdefs = inflags;
 
 			// Fill flags list
 			foreach (KeyValuePair<string, string> tf in flagdefs)
 				flags.Add(tf.Value, tf.Key);
 			foreach (KeyValuePair<string, string> tf in flagdefs)
 				flags.Add(tf.Value, tf.Key);
 
 			// Parse the value string and check the boxes if necessary
 			if (value.Trim() != "")
 			{
 				foreach (string s in value.Split(','))
 				{
 					string str = s.Trim();
 
 					// Make sure the given flag actually exists
 					if(!flagdefs.ContainsKey(str))
 						continue;
 
 					foreach (CheckBox c in flags.Checkboxes)
 					{
 						if (c.Text == flagdefs[str])
 							c.Checked = true;
 					}
 					foreach (CheckBox c in flags.Checkboxes)
 					{
 						if (c.Text == flagdefs[str])
 							c.Checked = true;
 					}
 				}
 				foreach (string s in value.Split(','))
 				{
 					string str = s.Trim();
 
 					// Make sure the given flag actually exists
 					if(!flagdefs.ContainsKey(str))
 						continue;
 
 					foreach (CheckBox c in flags.Checkboxes)
 					{
 						if (c.Text == flagdefs[str])
 							c.Checked = true;
 					}
 				}
 			}
 
 			setup = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipPolygon.cs" startline="174" endline="198">
<![CDATA[
 		
 		// This inserts a polygon if it is a child of this one
 		public bool InsertChild(EarClipPolygon p)
 		{
 			// Polygon must have at least 1 vertex
 			if(p.Count == 0) return false;
 			
 			// Check if it can be inserted at a lower level
 			foreach(EarClipPolygon child in children)
 			{
 				if(child.InsertChild(p)) return true;
 			}
 			foreach(EarClipPolygon child in children)
 			{
 				if(child.InsertChild(p)) return true;
 			}
 
 			// Check if it can be inserted here
 			if(this.Intersect(p.First.Value.Position))
 			{
 				// Make the polygon the inverse of this one
 				p.Inner = !inner;
 				children.Add(p);
 				return true;
 			}
 
 			// Can't insert it as a child
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1161" endline="1175">
<![CDATA[
 		
 		// This stops exclusive mouse input
 		public void StopExclusiveMouseInput()
 		{
 			// Only when in exclusive mode
 			if(mouseexclusive)
 			{
 				General.WriteLogLine("Stopping exclusive mouse input mode...");
 
 				// Stop special input device
 				StopMouseExclusive();
 				mouseexclusive = false;
 				mouseexclusivebreaklevel = 0;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1281" endline="1292">
<![CDATA[
 		
 		// This loads Decorate data from a specific file or lump name
 		private void LoadDecorateFromLocation(DecorateParser parser, string location)
 		{
 			//General.WriteLogLine("Including DECORATE resource '" + location + "'...");
 			List<Stream> decostreams = currentreader.GetDecorateData(location);
 			foreach(Stream decodata in decostreams)
 			{
 				// Parse this data
 				parser.Parse(decodata, location);
 			}
 			foreach(Stream decodata in decostreams)
 			{
 				// Parse this data
 				parser.Parse(decodata, location);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="558" endline="575">
<![CDATA[
 
 		// This finds and returns a texture stream
 		public override Stream GetTextureData(string pname)
 		{
 			Lump lump;
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find the lump in ranges
 			foreach(LumpRange range in textureranges)
 			{
 				lump = file.FindLump(pname, range.start, range.end);
 				if(lump != null) return lump.Stream;
 			}
 			foreach(LumpRange range in textureranges)
 			{
 				lump = file.FindLump(pname, range.start, range.end);
 				if(lump != null) return lump.Stream;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="685" endline="702">
<![CDATA[
 		
 		// This finds and returns a patch stream
 		public override Stream GetFlatData(string pname)
 		{
 			Lump lump;
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find the lump in ranges
 			foreach(LumpRange range in flatranges)
 			{
 				lump = file.FindLump(pname, range.start, range.end);
 				if(lump != null) return lump.Stream;
 			}
 			foreach(LumpRange range in flatranges)
 			{
 				lump = file.FindLump(pname, range.start, range.end);
 				if(lump != null) return lump.Stream;
 			}
 			
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="757" endline="774">
<![CDATA[
 		
 		// This finds and returns a sprite stream
 		public override Stream GetSpriteData(string pname)
 		{
 			Lump lump;
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find the lump in ranges
 			foreach(LumpRange range in spriteranges)
 			{
 				lump = file.FindLump(pname, range.start, range.end);
 				if(lump != null) return lump.Stream;
 			}
 			foreach(LumpRange range in spriteranges)
 			{
 				lump = file.FindLump(pname, range.start, range.end);
 				if(lump != null) return lump.Stream;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\BitFlagsForm.cs" startline="60" endline="98">
<![CDATA[
 
 		#endregion
 
 		#region ================== Events
 
 		// When a checkbox is clicked
 		private void box_CheckedChanged(object sender, EventArgs e)
 		{
 			if(!setup)
 			{
 				// Now setting up
 				setup = true;
 
 				// Get this checkbox
 				CheckBox thisbox = (sender as CheckBox);
 				
 				// Checking or unchecking?
 				if(thisbox.Checked)
 				{
 					// Go for all other options
 					foreach(CheckBox b in options.Checkboxes)
 					{
 						// Not the same box?
 						if(b != sender)
 						{
 							// Overlapping bit flags?
 							if(((int)b.Tag & (int)thisbox.Tag) != 0)
 							{
 								// Uncheck the other
 								b.Checked = false;
 							}
 						}
 					}
 					foreach(CheckBox b in options.Checkboxes)
 					{
 						// Not the same box?
 						if(b != sender)
 						{
 							// Overlapping bit flags?
 							if(((int)b.Tag & (int)thisbox.Tag) != 0)
 							{
 								// Uncheck the other
 								b.Checked = false;
 							}
 						}
 					}
 				}
 
 				// Done
 				setup = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\BitFlagsForm.cs" startline="121" endline="164">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 		
 		// Setup from EnumList
 		public void Setup(EnumList flags, int value)
 		{
 			setup = true;
 			this.value = value;
 			
 			// Make a checkbox for each item
 			foreach(EnumItem item in flags)
 			{
 				// Make the checkbox
 				CheckBox box = options.Add(item.Title, item.GetIntValue());
 				
 				// Bind checking event
 				box.CheckedChanged += new EventHandler(box_CheckedChanged);
 
 				// Checking the box?
 				if((value & (int)box.Tag) == (int)box.Tag)
 				{
 					box.Checked = true;
 					
 					// Go for all other checkboxes
 					foreach(CheckBox b in options.Checkboxes)
 					{
 						// Not the same box?
 						if(b != box)
 						{
 							// Overlapping bit flags?
 							if(((int)b.Tag & (int)box.Tag) != 0)
 							{
 								// Uncheck the other
 								b.Checked = false;
 							}
 						}
 					}
 					foreach(CheckBox b in options.Checkboxes)
 					{
 						// Not the same box?
 						if(b != box)
 						{
 							// Overlapping bit flags?
 							if(((int)b.Tag & (int)box.Tag) != 0)
 							{
 								// Uncheck the other
 								b.Checked = false;
 							}
 						}
 					}
 				}
 			}
 			foreach(EnumItem item in flags)
 			{
 				// Make the checkbox
 				CheckBox box = options.Add(item.Title, item.GetIntValue());
 				
 				// Bind checking event
 				box.CheckedChanged += new EventHandler(box_CheckedChanged);
 
 				// Checking the box?
 				if((value & (int)box.Tag) == (int)box.Tag)
 				{
 					box.Checked = true;
 					
 					// Go for all other checkboxes
 					foreach(CheckBox b in options.Checkboxes)
 					{
 						// Not the same box?
 						if(b != box)
 						{
 							// Overlapping bit flags?
 							if(((int)b.Tag & (int)box.Tag) != 0)
 							{
 								// Uncheck the other
 								b.Checked = false;
 							}
 						}
 					}
 				}
 			}
 
 			setup = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1485" endline="1513">
<![CDATA[
 
 		// This selects the things filter based on the filter set on the map manager
 		internal void ReflectThingsFilter()
 		{
 			if(!updatingfilters)
 			{
 				updatingfilters = true;
 				
 				// Select current filter
 				bool selecteditemfound = false;
 				foreach(ThingsFilter f in thingfilters.Items)
 				{
 					if(f == General.Map.ThingsFilter)
 					{
 						thingfilters.SelectedItem = f;
 						selecteditemfound = true;
 					}
 				}
 				foreach(ThingsFilter f in thingfilters.Items)
 				{
 					if(f == General.Map.ThingsFilter)
 					{
 						thingfilters.SelectedItem = f;
 						selecteditemfound = true;
 					}
 				}
 
 				// Not in the list?
 				if(!selecteditemfound)
 				{
 					// Select nothing
 					thingfilters.SelectedIndex = -1;
 				}
 
 				updatingfilters = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="587" endline="608">
<![CDATA[
 
 		// Linedef generalized actions
 		private void LoadLinedefGeneralizedActions()
 		{
 			IDictionary dic;
 
 			// Get linedef activations
 			dic = cfg.ReadSetting("gen_linedeftypes", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				// Check for valid structure
 				if(de.Value is IDictionary)
 				{
 					// Add category
 					genactioncategories.Add(new GeneralizedCategory("gen_linedeftypes", de.Key.ToString(), cfg));
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'gen_linedeftypes' contains invalid entries in game configuration '" + this.Name + "'");
 				}
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Check for valid structure
 				if(de.Value is IDictionary)
 				{
 					// Add category
 					genactioncategories.Add(new GeneralizedCategory("gen_linedeftypes", de.Key.ToString(), cfg));
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'gen_linedeftypes' contains invalid entries in game configuration '" + this.Name + "'");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="574" endline="585">
<![CDATA[
 
 		// This flips the sidedefs
 		public void FlipSidedefs()
 		{
 			// Flip sidedefs
 			Sidedef oldfront = front;
 			Sidedef oldback = back;
 			AttachFront(oldback);
 			AttachBack(oldfront);
 			
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypesManager.cs" startline="143" endline="162">
<![CDATA[
 
 		// This returns the type handler for a given universal field
 		public TypeHandler GetFieldHandler(UniversalFieldInfo fieldinfo)
 		{
 			Type t = typeof(NullHandler);
 			TypeHandlerAttribute ta = null;
 
 			// Do we have a handler type for this?
 			if(handlertypes.ContainsKey(fieldinfo.Type))
 			{
 				ta = handlertypes[fieldinfo.Type];
 				t = ta.Type;
 			}
 
 			// Create instance
 			TypeHandler th = (TypeHandler)General.ThisAssembly.CreateInstance(t.FullName);
 			th.SetupField(ta, fieldinfo);
 			th.SetValue(fieldinfo.Default);
 			return th;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1229" endline="1246">
<![CDATA[
 		
 		// This asks the user to save changes in script files
 		// Returns false when cancelled by the user
 		internal bool AskSaveScriptChanges()
 		{
 			// Window open?
 			if(scriptwindow != null)
 			{
 				// Ask to save changes
 				// This also saves implicitly
 				return scriptwindow.AskSaveAll();
 			}
 			else
 			{
 				// No problems
 				return true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1088" endline="1095">
<![CDATA[
 		
 		// This adds a thing in the things buffer for rendering
 		public void RenderThing(Thing t, PixelColor c, float alpha)
 		{
 			List<Thing> things = new List<Thing>(1);
 			things.Add(t);
 			RenderThingsBatch(things, alpha, true, c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="121" endline="128">
<![CDATA[
 			{
 				if(!isundosnapshot && (snapshot != null))
 					return snapshot;
 				else if(undos.Count > 0)
 					return undos[0];
 				else
 					return null;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DDevice.cs" startline="340" endline="364">
<![CDATA[
 		
 		// This creates present parameters
 		private PresentParameters CreatePresentParameters(int adapter)
 		{
 			PresentParameters displaypp = new PresentParameters();
 			DisplayMode currentmode;
 			
 			// Get current display mode
 			currentmode = d3d.Adapters[adapter].CurrentDisplayMode;
 
 			// Make present parameters
 			displaypp.Windowed = true;
 			displaypp.SwapEffect = SwapEffect.Discard;
 			displaypp.BackBufferCount = 1;
 			displaypp.BackBufferFormat = currentmode.Format;
 			displaypp.BackBufferWidth = rendertarget.ClientSize.Width;
 			displaypp.BackBufferHeight = rendertarget.ClientSize.Height;
 			displaypp.EnableAutoDepthStencil = true;
 			displaypp.AutoDepthStencilFormat = Format.D16;
 			displaypp.Multisample = MultisampleType.None;
 			displaypp.PresentationInterval = PresentInterval.Immediate;
 
 			// Return result
 			return displaypp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="385" endline="399">
<![CDATA[
 		
 		// This loads the enumerations
 		private void LoadEnums()
 		{
 			IDictionary dic;
 
 			// Get enums list
 			dic = cfg.ReadSetting("enums", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				// Make new enum
 				EnumList list = new EnumList(de.Key.ToString(), cfg);
 				enums.Add(de.Key.ToString(), list);
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Make new enum
 				EnumList list = new EnumList(de.Key.ToString(), cfg);
 				enums.Add(de.Key.ToString(), list);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditingManager.cs" startline="157" endline="177">
<![CDATA[
 		
 		// This binds all editing mode switch actions for the available modes only
 		private void BindAvailableSwitchActions()
 		{
 			// In case of VisualMode, we only bind the switch action
 			// of the VisualMode to switch back to the previous mode
 			if(mode is VisualMode)
 			{
 				// Bind only the switch action for this mode
 				EditModeInfo info = GetEditModeInfo(mode.GetType());
 				info.BindSwitchAction();
 			}
 			else
 			{
 				// Bind all available mode swtich actions
 				foreach(EditModeInfo emi in usedmodes)
 				{
 					emi.BindSwitchAction();
 				}
 				foreach(EditModeInfo emi in usedmodes)
 				{
 					emi.BindSwitchAction();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="771" endline="803">
<![CDATA[
 		
 		// User double-clicks and error in the list
 		private void errorlist_ItemActivate(object sender, EventArgs e)
 		{
 			// Anything selection?
 			if(errorlist.SelectedItems.Count > 0)
 			{
 				// Get the compiler error
 				CompilerError err = (CompilerError)errorlist.SelectedItems[0].Tag;
 				
 				// Show the tab with the script that matches
 				bool foundscript = false;
 				foreach(ScriptDocumentTab t in tabs.TabPages)
 				{
 					if(t.VerifyErrorForScript(err))
 					{
 						tabs.SelectedTab = t;
 						t.MoveToLine(err.linenumber);
 						foundscript = true;
 						break;
 					}
 				}
 				foreach(ScriptDocumentTab t in tabs.TabPages)
 				{
 					if(t.VerifyErrorForScript(err))
 					{
 						tabs.SelectedTab = t;
 						t.MoveToLine(err.linenumber);
 						foundscript = true;
 						break;
 					}
 				}
 
 				// If we don't have the script opened, see if we can find the file and open the script
 				if(!foundscript && File.Exists(err.filename))
 				{
 					ScriptDocumentTab t = OpenFile(err.filename);
 					if(t != null) t.MoveToLine(err.linenumber);
 				}
 				
 				ForceFocus();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="329" endline="348">
<![CDATA[
 
 		// Returns a list of the resources
 		public DataLocationList GetResources()
 		{
 			DataLocationList list = new DataLocationList();
 
 			// Go for all items
 			for(int i = 0; i < resourceitems.Items.Count; i++)
 			{
 				// Item not grayed?
 				if(resourceitems.Items[i].ForeColor == SystemColors.WindowText)
 				{
 					// Add item to list
 					list.Add((DataLocation)resourceitems.Items[i].Tag);
 				}
 			}
 			for(int i = 0; i < resourceitems.Items.Count; i++)
 			{
 				// Item not grayed?
 				if(resourceitems.Items[i].ForeColor == SystemColors.WindowText)
 				{
 					// Add item to list
 					list.Add((DataLocation)resourceitems.Items[i].Tag);
 				}
 			}
 
 			// Return result
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="185" endline="204">
<![CDATA[
 		
 		// This replaces the selection with the given text
 		public void ReplaceSelection(string replacement)
 		{
 			Encoding encoder = Encoding.GetEncoding(scriptedit.CodePage);
 			string text = encoder.GetString(GetText());
 			int selectionstart = scriptedit.SelectionStart;
 			
 			// Make new text
 			StringBuilder newtext = new StringBuilder(text.Length + replacement.Length);
 			newtext.Append(text.Substring(0, scriptedit.SelectionStart));
 			newtext.Append(replacement);
 			newtext.Append(text.Substring(scriptedit.SelectionEnd));
 			
 			SetText(encoder.GetBytes(newtext.ToString()));
 			
 			// Adjust selection
 			scriptedit.SelectionStart = selectionstart;
 			scriptedit.SelectionEnd = selectionstart + replacement.Length;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\DefinedTextureSet.cs" startline="45" endline="58">
<![CDATA[
 		public DefinedTextureSet(Configuration cfg, string path)
 		{
 			// Read the name
 			name = cfg.ReadSetting(path + ".name", "Unnamed Set");
 			
 			// Read the filters
 			IDictionary dic = cfg.ReadSetting(path, new Hashtable());
 			filters = new List<string>(dic.Count);
 			foreach(DictionaryEntry de in dic)
 			{
 				// If not the name of this texture set, add value as filter
 				if(de.Key.ToString() != "name") filters.Add(de.Value.ToString().ToUpperInvariant());
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// If not the name of this texture set, add value as filter
 				if(de.Key.ToString() != "name") filters.Add(de.Value.ToString().ToUpperInvariant());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.cs" startline="101" endline="109">
<![CDATA[
 		
 		// Remove selected items
 		private void removefilter_Click(object sender, EventArgs e)
 		{
 			foreach(ListViewItem i in filters.SelectedItems) i.Remove();
 			
 			// Run the timer
 			filterstimer.Start();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamWriter.cs" startline="304" endline="322">
<![CDATA[
 
 		// This adds custom fields from a map element to a collection
 		private void AddCustomFields(MapElement element, string elementname, UniversalCollection collection)
 		{
 			// Add custom fields
 			foreach(KeyValuePair<string, UniValue> f in element.Fields)
 			{
 				// Not a managed field?
 				if(!config.SettingExists("managedfields." + elementname + "." + f.Key))
 				{
 					// Add type information to DBS file for map
 					if(remembercustomtypes)
 						General.Map.Options.SetUniversalFieldType(elementname, f.Key, f.Value.Type);
 
 					// Store field
 					collection.Add(f.Key, f.Value.Value);
 				}
 			}
 			foreach(KeyValuePair<string, UniValue> f in element.Fields)
 			{
 				// Not a managed field?
 				if(!config.SettingExists("managedfields." + elementname + "." + f.Key))
 				{
 					// Add type information to DBS file for map
 					if(remembercustomtypes)
 						General.Map.Options.SetUniversalFieldType(elementname, f.Key, f.Value.Type);
 
 					// Store field
 					collection.Add(f.Key, f.Value.Value);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="208" endline="234">
<![CDATA[
 
 		// This determines which sector the thing is in and links it
 		public void DetermineSector()
 		{
 			Linedef nl;
 
 			// Find the nearest linedef on the map
 			nl = map.NearestLinedef(pos);
 			if(nl != null)
 			{
 				// Check what side of line we are at
 				if(nl.SideOfLine(pos) < 0f)
 				{
 					// Front side
 					if(nl.Front != null) sector = nl.Front.Sector; else sector = null;
 				}
 				else
 				{
 					// Back side
 					if(nl.Back != null) sector = nl.Back.Sector; else sector = null;
 				}
 			}
 			else
 			{
 				sector = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="792" endline="811">
<![CDATA[
 
 		// Make door flags
 		private void LoadMakeDoorFlags()
 		{
 			IDictionary dic;
 
 			dic = cfg.ReadSetting("makedoorflags", new Hashtable());
 			foreach (DictionaryEntry de in dic)
 			{
 				// Using minus will unset the flag
 				if (de.Key.ToString()[0] == '-')
 				{
 					makedoorflags[de.Key.ToString().TrimStart('-')] = false;
 				}
 				else
 				{
 					makedoorflags[de.Key.ToString()] = true;
 				}
 			}
 			foreach (DictionaryEntry de in dic)
 			{
 				// Using minus will unset the flag
 				if (de.Key.ToString()[0] == '-')
 				{
 					makedoorflags[de.Key.ToString().TrimStart('-')] = false;
 				}
 				else
 				{
 					makedoorflags[de.Key.ToString()] = true;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\EnumList.cs" startline="54" endline="67">
<![CDATA[
 
 		// Constructor to load from dictionary
 		internal EnumList(IDictionary dic)
 		{
 			int index;
 
 			// Read the dictionary
 			foreach(DictionaryEntry de in dic)
 			{
 				// Add item
 				EnumItem item = new EnumItem(de.Key.ToString(), de.Value.ToString());
 				base.Add(item);
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Add item
 				EnumItem item = new EnumItem(de.Key.ToString(), de.Value.ToString());
 				base.Add(item);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="669" endline="690">
<![CDATA[
 
 		// Sector generalized effects
 		private void LoadSectorGeneralizedEffects()
 		{
 			IDictionary dic;
 
 			// Get sector effects
 			dic = cfg.ReadSetting("gen_sectortypes", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				// Check for valid structure
 				if(de.Value is IDictionary)
 				{
 					// Add option
 					geneffectoptions.Add(new GeneralizedOption("gen_sectortypes", "", de.Key.ToString(), de.Value as IDictionary));
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'gen_sectortypes' contains invalid entries in game configuration '" + this.Name + "'");
 				}
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Check for valid structure
 				if(de.Value is IDictionary)
 				{
 					// Add option
 					geneffectoptions.Add(new GeneralizedOption("gen_sectortypes", "", de.Key.ToString(), de.Value as IDictionary));
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'gen_sectortypes' contains invalid entries in game configuration '" + this.Name + "'");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="642" endline="668">
<![CDATA[
 
 		// Brightness levels
 		private void LoadBrightnessLevels()
 		{
 			IDictionary dic;
 			int level;
 
 			// Get brightness levels structure
 			dic = cfg.ReadSetting("sectorbrightness", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				// Try paring the level
 				if(int.TryParse(de.Key.ToString(),
 					NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite,
 					CultureInfo.InvariantCulture, out level))
 				{
 					brightnesslevels.Add(level);
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'sectorbrightness' contains invalid keys in game configuration '" + this.Name + "'");
 				}
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Try paring the level
 				if(int.TryParse(de.Key.ToString(),
 					NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite,
 					CultureInfo.InvariantCulture, out level))
 				{
 					brightnesslevels.Add(level);
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'sectorbrightness' contains invalid keys in game configuration '" + this.Name + "'");
 				}
 			}
 
 			// Sort the list
 			brightnesslevels.Sort();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="96" endline="120">
<![CDATA[
 		
 		// Disposer
 		public void Dispose()
 		{
 			if(sets != null)
 			{
 				General.Map.Graphics.UnregisterResource(this);
 				
 				// Dispose all sets
 				foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 				{
 					// Dispose vertex buffers
 					for(int i = 0; i < set.Value.buffers.Count; i++)
 					{
 						if(set.Value.buffers[i] != null)
 						{
 							set.Value.buffers[i].Dispose();
 							set.Value.buffers[i] = null;
 						}
 					}
 					for(int i = 0; i < set.Value.buffers.Count; i++)
 					{
 						if(set.Value.buffers[i] != null)
 						{
 							set.Value.buffers[i].Dispose();
 							set.Value.buffers[i] = null;
 						}
 					}
 				}
 				foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 				{
 					// Dispose vertex buffers
 					for(int i = 0; i < set.Value.buffers.Count; i++)
 					{
 						if(set.Value.buffers[i] != null)
 						{
 							set.Value.buffers[i].Dispose();
 							set.Value.buffers[i] = null;
 						}
 					}
 				}
 				
 				sets = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="609" endline="641">
<![CDATA[
 
 		// Sector effects
 		private void LoadSectorEffects()
 		{
 			IDictionary dic;
 			SectorEffectInfo si;
 			int actionnumber;
 			
 			// Get sector effects
 			dic = cfg.ReadSetting("sectortypes", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				// Try paring the action number
 				if(int.TryParse(de.Key.ToString(),
 					NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite,
 					CultureInfo.InvariantCulture, out actionnumber))
 				{
 					// Make effects
 					si = new SectorEffectInfo(actionnumber, de.Value.ToString(), true, false);
 					
 					// Add action to category and sorted list
 					sortedsectoreffects.Add(si);
 					sectoreffects.Add(actionnumber, si);
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'sectortypes' contains invalid keys in game configuration '" + this.Name + "'");
 				}
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Try paring the action number
 				if(int.TryParse(de.Key.ToString(),
 					NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite,
 					CultureInfo.InvariantCulture, out actionnumber))
 				{
 					// Make effects
 					si = new SectorEffectInfo(actionnumber, de.Value.ToString(), true, false);
 					
 					// Add action to category and sorted list
 					sortedsectoreffects.Add(si);
 					sectoreffects.Add(actionnumber, si);
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'sectortypes' contains invalid keys in game configuration '" + this.Name + "'");
 				}
 			}
 
 			// Sort the actions list
 			sortedsectoreffects.Sort();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PreviewManager.cs" startline="251" endline="261">
<![CDATA[
 		
 		// This adds an image for preview creation
 		internal void AddImage(ImageData image)
 		{
 			lock(imageque)
 			{
 				// Add to list
 				image.PreviewState = ImageLoadState.Loading;
 				imageque.Enqueue(image);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\PluginManager.cs" startline="88" endline="100">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 		
 		// This creates a list of assemblies
 		public List<Assembly> GetPluginAssemblies()
 		{
 			List<Assembly> asms = new List<Assembly>(plugins.Count);
 			foreach(Plugin p in plugins)
 				asms.Add(p.Assembly);
 			foreach(Plugin p in plugins)
 				asms.Add(p.Assembly);
 			return asms;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\Action.cs" startline="241" endline="262">
<![CDATA[
 
 		// This raises events for this action
 		internal void Begin()
 		{
 			List<ActionDelegate> delegateslist;
 
 			General.Plugins.OnActionBegin(this);
 
 			// Method bound?
 			if(begindelegates.Count > 0)
 			{
 				// Copy delegates list
 				delegateslist = new List<ActionDelegate>(begindelegates);
 				
 				// Invoke all the delegates
 				General.Actions.Current = this;
 				General.Actions.ResetExclusiveRequest();
 				foreach(ActionDelegate ad in delegateslist) ad.Invoke();
 				General.Actions.ResetExclusiveRequest();
 				General.Actions.Current = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\Action.cs" startline="263" endline="284">
<![CDATA[
 
 		// This raises events for this action
 		internal void End()
 		{
 			List<ActionDelegate> delegateslist;
 
 			// Method bound?
 			if(enddelegates.Count > 0)
 			{
 				// Copy delegates list
 				delegateslist = new List<ActionDelegate>(enddelegates);
 
 				// Invoke all the delegates
 				General.Actions.Current = this;
 				General.Actions.ResetExclusiveRequest();
 				foreach(ActionDelegate ad in delegateslist) ad.Invoke();
 				General.Actions.ResetExclusiveRequest();
 				General.Actions.Current = null;
 			}
 			
 			General.Plugins.OnActionEnd(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="262" endline="286">
<![CDATA[
 		
 		// This selects a docker
 		public bool SelectDocker(Docker d)
 		{
 			int index = 0;
 			foreach(TabPage page in tabs.TabPages)
 			{
 				if((page.Tag as Docker) == d)
 				{
 					if(iscollapsed)
 					{
 						previousselected = currentselected;
 						expandedtab = index;
 					}
 					else
 						tabs.SelectedTab = page;
 					
 					return true;
 				}
 				
 				index++;
 			}
 			foreach(TabPage page in tabs.TabPages)
 			{
 				if((page.Tag as Docker) == d)
 				{
 					if(iscollapsed)
 					{
 						previousselected = currentselected;
 						expandedtab = index;
 					}
 					else
 						tabs.SelectedTab = page;
 					
 					return true;
 				}
 				
 				index++;
 			}
 			
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="649" endline="679">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Processing
 		
 		/// <summary>
 		/// This disposes all resources. Needed geometry will be rebuild automatically.
 		/// </summary>
 		protected virtual void ResourcesReloaded()
 		{
 			// Dispose
 			foreach(KeyValuePair<Sector, VisualSector> vs in allsectors)
 				if(vs.Value != null) vs.Value.Dispose();
 			foreach(KeyValuePair<Sector, VisualSector> vs in allsectors)
 				if(vs.Value != null) vs.Value.Dispose();
 				
 			foreach(KeyValuePair<Thing, VisualThing> vt in allthings)
 				if(vt.Value != null) vt.Value.Dispose();
 			foreach(KeyValuePair<Thing, VisualThing> vt in allthings)
 				if(vt.Value != null) vt.Value.Dispose();
 				
 			// Clear collections
 			allsectors.Clear();
 			allthings.Clear();
 			visiblesectors.Clear();
 			visibleblocks.Clear();
 			visiblegeometry.Clear();
 			visiblethings.Clear();
 			
 			// Make new blockmap
 			FillBlockMap();
 
 			// Visibility culling (this re-creates the needed resources)
 			DoCulling();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1196" endline="1204">
<![CDATA[
 
 		internal void PlayAddSector(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			//LogRecordInfo("PLY
 			Sector s = General.Map.Map.GetSectorByIndex(index);
 			s.Dispose();
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1256" endline="1264">
<![CDATA[
 
 		internal void PlayAddThing(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			//LogRecordInfo("PLY
 			Thing t = General.Map.Map.GetThingByIndex(index);
 			t.Dispose();
 			populationchanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="93" endline="112">
<![CDATA[
 		
 		// This applies the application settings
 		public void ApplySettings()
 		{
 			// Force black background?
 			if(General.Settings.BlackBrowsers)
 			{
 				list.BackColor = Color.Black;
 				list.ForeColor = Color.White;
 			}
 
 			// Set the size of preview images
 			if(General.Map != null)
 			{
 				int itemwidth = General.Map.Data.Previews.MaxImageWidth + 26;
 				int itemheight = General.Map.Data.Previews.MaxImageHeight + 26;
 				if(General.Settings.ShowTextureSizes) itemheight += 12;
 				list.TileSize = new Size(itemwidth, itemheight);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\NullThingsFilter.cs" startline="55" endline="68">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This updates the lists
 		public override void Update()
 		{
 			// Make lists
 			visiblethings = new List<Thing>(General.Map.Map.Things);
 			hiddenthings = new List<Thing>(0);
 			thingsvisiblestate = new Dictionary<Thing, bool>(General.Map.Map.Things.Count);
 			foreach(Thing t in visiblethings) thingsvisiblestate.Add(t, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ErrorsForm.cs" startline="138" endline="146">
<![CDATA[
 		
 		#endregion
 
 		private void ErrorsForm_Shown(object sender, EventArgs e)
 		{
 			if(grid.Rows.Count > 0)
 				grid.Rows[0].Selected = false;
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ZDTextParser.cs" startline="271" endline="295">
<![CDATA[
 
 		// This reads the rest of the line
 		// Returns null when the end of the stream has been reached
 		protected internal string ReadLine()
 		{
 			string token = "";
 
 			// Return null when the end of the stream has been reached
 			if(datastream.Position == datastream.Length) return null;
 
 			// Start reading
 			char c = (char)datareader.ReadByte();
 			while(c != '\n')
 			{
 				token += c;
 				
 				// Next character
 				if(datastream.Position < datastream.Length)
 					c = (char)datareader.Read();
 				else
 					break;
 			}
 			while(c != '\n')
 			{
 				token += c;
 				
 				// Next character
 				if(datastream.Position < datastream.Length)
 					c = (char)datareader.Read();
 				else
 					break;
 			}
 
 			return token.Trim();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ActorStructure.cs" startline="517" endline="530">
<![CDATA[
 		
 		/// <summary>
 		/// This checks if this actor is meant for the current decorate game support
 		/// </summary>
 		public bool CheckActorSupported()
 		{
 			// Check if we want to include this actor
 			string includegames = General.Map.Config.DecorateGames.ToLowerInvariant();
 			bool includeactor = (props["game"].Count == 0);
 			foreach(string g in props["game"])
 				includeactor |= includegames.Contains(g);
 			foreach(string g in props["game"])
 				includeactor |= includegames.Contains(g);
 			
 			return includeactor;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="358" endline="365">
<![CDATA[
 
 		// Destructor
 		~GameConfiguration()
 		{
 			foreach(ThingCategory tc in thingcategories) tc.Dispose();
 			foreach(LinedefActionCategory ac in actioncategories) ac.Dispose();
 			foreach (ThingFlagsCompare tfc in thingflagscompare) tfc.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1008" endline="1047">
<![CDATA[
 		
 		// This loads the sprites that we really need for things
 		private int LoadThingSprites()
 		{
 			// Go for all things
 			foreach(ThingTypeInfo ti in General.Map.Data.ThingTypes)
 			{
 				// Valid sprite name?
 				if((ti.Sprite.Length > 0) && (ti.Sprite.Length <= 8))
 				{
 					ImageData image = null;
 					
 					// Sprite not in our collection yet?
 					if(!sprites.ContainsKey(ti.SpriteLongName))
 					{
 						// Find sprite data
 						Stream spritedata = GetSpriteData(ti.Sprite);
 						if(spritedata != null)
 						{
 							// Make new sprite image
 							image = new SpriteImage(ti.Sprite);
 							
 							// Add to collection
 							sprites.Add(ti.SpriteLongName, image);
 						}
 					}
 					else
 					{
 						image = sprites[ti.SpriteLongName];
 					}
 					
 					// Add to preview manager
 					if(image != null)
 						previews.AddImage(image);
 				}
 			}
 			foreach(ThingTypeInfo ti in General.Map.Data.ThingTypes)
 			{
 				// Valid sprite name?
 				if((ti.Sprite.Length > 0) && (ti.Sprite.Length <= 8))
 				{
 					ImageData image = null;
 					
 					// Sprite not in our collection yet?
 					if(!sprites.ContainsKey(ti.SpriteLongName))
 					{
 						// Find sprite data
 						Stream spritedata = GetSpriteData(ti.Sprite);
 						if(spritedata != null)
 						{
 							// Make new sprite image
 							image = new SpriteImage(ti.Sprite);
 							
 							// Add to collection
 							sprites.Add(ti.SpriteLongName, image);
 						}
 					}
 					else
 					{
 						image = sprites[ti.SpriteLongName];
 					}
 					
 					// Add to preview manager
 					if(image != null)
 						previews.AddImage(image);
 				}
 			}
 			
 			// Output info
 			return sprites.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="204" endline="231">
<![CDATA[
 		
 		// This adds a docker
 		public void Add(Docker d)
 		{
 			// Set up page
 			TabPage page = new TabPage(d.Title);
 			page.SuspendLayout();
 			page.Font = this.Font;
 			page.Tag = d;
 			page.UseVisualStyleBackColor = false;
 			page.Controls.Add(d.Control);
 			d.Control.Dock = DockStyle.Fill;
 			tabs.TabPages.Add(page);
 			page.ResumeLayout(true);
 			if(iscollapsed) tabs.SelectedIndex = -1;
 			
 			// Go for all controls to add events
 			Queue<Control> todo = new Queue<Control>();
 			todo.Enqueue(d.Control);
 			while(todo.Count > 0)
 			{
 				Control c = todo.Dequeue();
 				c.MouseEnter += RaiseMouseContainerEnter;
 				c.MouseLeave += RaiseMouseContainerLeave;
 				foreach(Control cc in c.Controls)
 					todo.Enqueue(cc);
 				foreach(Control cc in c.Controls)
 					todo.Enqueue(cc);
 			}
 			while(todo.Count > 0)
 			{
 				Control c = todo.Dequeue();
 				c.MouseEnter += RaiseMouseContainerEnter;
 				c.MouseLeave += RaiseMouseContainerLeave;
 				foreach(Control cc in c.Controls)
 					todo.Enqueue(cc);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\UniFields.cs" startline="33" endline="40">
<![CDATA[
 
 		// Copy constructor (makes a deep copy)
 		///<summary></summary>
 		public UniFields(UniFields copyfrom) 
 		{
 			foreach(KeyValuePair<string, UniValue> v in copyfrom)
 				this.Add(v.Key, new UniValue(v.Value));
 			foreach(KeyValuePair<string, UniValue> v in copyfrom)
 				this.Add(v.Key, new UniValue(v.Value));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\EnumList.cs" startline="68" endline="82">
<![CDATA[
 
 		// Constructor to load from configuration
 		internal EnumList(string name, Configuration cfg)
 		{
 			int index;
 			
 			// Read the list from configuration
 			IDictionary dic = cfg.ReadSetting("enums." + name, new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				// Add item
 				EnumItem item = new EnumItem(de.Key.ToString(), de.Value.ToString());
 				base.Add(item);
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Add item
 				EnumItem item = new EnumItem(de.Key.ToString(), de.Value.ToString());
 				base.Add(item);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\GridSetupForm.cs" startline="91" endline="108">
<![CDATA[
 
 		// Browse texture
 		private void selecttexture_Click(object sender, EventArgs e)
 		{
 			string result;
 			
 			// Browse for texture
 			result = TextureBrowserForm.Browse(this, backgroundname);
 			if(result != null)
 			{
 				// Set this texture as background
 				backgroundname = result;
 				backgroundsource = GridSetup.SOURCE_TEXTURES;
 				ImageData img = General.Map.Data.GetTextureImage(result);
 				img.LoadImage();
 				General.DisplayZoomedImage(backgroundimage, img.GetBitmap());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\GridSetupForm.cs" startline="109" endline="126">
<![CDATA[
 
 		// Browse flat
 		private void selectflat_Click(object sender, EventArgs e)
 		{
 			string result;
 
 			// Browse for flat
 			result = FlatBrowserForm.Browse(this, backgroundname);
 			if(result != null)
 			{
 				// Set this flat as background
 				backgroundname = result;
 				backgroundsource = GridSetup.SOURCE_FLATS;
 				ImageData img = General.Map.Data.GetFlatImage(result);
 				img.LoadImage();
 				General.DisplayZoomedImage(backgroundimage, img.GetBitmap());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListView.cs" startline="65" endline="121">
<![CDATA[
 
 		#endregion
 
 		#region ================== Overrides
 
 		// When items are dropped
 		protected override void OnDragDrop(DragEventArgs e)
 		{
 			int dropindex, i;
 			ListViewItem insertatitem;
 			Point cp;
 
 			// Pass on to base
 			base.OnDragDrop(e);
 
 			// Leave when no items being dragged
 			if(dragitems.Count == 0) return;
 
 			// Determine where to insert
 			cp = base.PointToClient(new Point(e.X, e.Y));
 			insertatitem = base.GetItemAt(cp.X, cp.Y);
 
 			// Leave when nowhere to insert or same as selected item
 			if((insertatitem == null) || (dragitems.Contains(insertatitem))) return;
 			
 			// Leave when item is grayed
 			if(insertatitem.ForeColor != SystemColors.WindowText) return;
 			
 			// Begin updating
 			base.BeginUpdate();
 			
 			// Determine index where to insert
 			dropindex = insertatitem.Index;
 			if(dropindex > dragitems[0].Index) dropindex++;
 
 			// Deselect items
 			DeselectAll();
 
 			// Insert items
 			for(i = dragitems.Count - 1; i >= 0; i--)
 			{
 				// Insert a copy of the item here
 				base.Items.Insert(dropindex, (ListViewItem)dragitems[i].Clone());
 				base.Items[dropindex].Selected = true;
 			}
 			for(i = dragitems.Count - 1; i >= 0; i--)
 			{
 				// Insert a copy of the item here
 				base.Items.Insert(dropindex, (ListViewItem)dragitems[i].Clone());
 				base.Items[dropindex].Selected = true;
 			}
 
 			// Remove old items
 			foreach(ListViewItem lvi in dragitems)
 			{
 				// Remove item from list
 				base.Items.Remove(lvi);
 			}
 			foreach(ListViewItem lvi in dragitems)
 			{
 				// Remove item from list
 				base.Items.Remove(lvi);
 			}
 
 			// Done
 			base.EndUpdate();
 			dragitems.Clear();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="404" endline="446">
<![CDATA[
 
 		private void filteraction_ValueChanges(object sender, EventArgs e)
 		{
 			int showaction = 0;
 			ArgumentInfo[] arginfo;
 
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Get selected filter
 				ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 				if(filteraction.Empty)
 					f.ThingAction = -1;
 				else
 					f.ThingAction = filteraction.GetValue();
 			}
 			
 			// Only when line type is known, otherwise use the thing arguments
 			if(General.Map.Config.LinedefActions.ContainsKey(filteraction.Value)) showaction = filteraction.Value;
 			arginfo = General.Map.Config.LinedefActions[showaction].Args;
 			
 			// Change the argument descriptions
 			arg0label.Text = arginfo[0].Title + "
 			arg1label.Text = arginfo[1].Title + "
 			arg2label.Text = arginfo[2].Title + "
 			arg3label.Text = arginfo[3].Title + "
 			arg4label.Text = arginfo[4].Title + "
 			arg0label.Enabled = arginfo[0].Used;
 			arg1label.Enabled = arginfo[1].Used;
 			arg2label.Enabled = arginfo[2].Used;
 			arg3label.Enabled = arginfo[3].Used;
 			arg4label.Enabled = arginfo[4].Used;
 			if(arg0label.Enabled) arg0.ForeColor = SystemColors.WindowText; else arg0.ForeColor = SystemColors.GrayText;
 			if(arg1label.Enabled) arg1.ForeColor = SystemColors.WindowText; else arg1.ForeColor = SystemColors.GrayText;
 			if(arg2label.Enabled) arg2.ForeColor = SystemColors.WindowText; else arg2.ForeColor = SystemColors.GrayText;
 			if(arg3label.Enabled) arg3.ForeColor = SystemColors.WindowText; else arg3.ForeColor = SystemColors.GrayText;
 			if(arg4label.Enabled) arg4.ForeColor = SystemColors.WindowText; else arg4.ForeColor = SystemColors.GrayText;
 			arg0.Setup(arginfo[0]);
 			arg1.Setup(arginfo[1]);
 			arg2.Setup(arginfo[2]);
 			arg3.Setup(arginfo[3]);
 			arg4.Setup(arginfo[4]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="963" endline="976">
<![CDATA[
 
 		internal void PlayRemLinedef(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			int sindex; ds.rInt(out sindex);
 			int eindex; ds.rInt(out eindex);
 			//LogRecordInfo("PLY
 			Vertex vs = General.Map.Map.GetVertexByIndex(sindex);
 			Vertex ve = General.Map.Map.GetVertexByIndex(eindex);
 			Linedef l = General.Map.Map.CreateLinedef(index, vs, ve);
 			l.ReadWrite(ds);
 			l.Marked = true;
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="662" endline="697">
<![CDATA[
 		
 		// This renders the sorted sector surfaces
 		internal void RenderSectorSurfaces(D3DDevice graphics)
 		{
 			if(!resourcesunloaded)
 			{
 				graphics.Shaders.Display2D.Begin();
 				foreach(KeyValuePair<ImageData, List<SurfaceEntry>> imgsurfaces in surfaces)
 				{
 					// Set texture
 					graphics.Shaders.Display2D.Texture1 = imgsurfaces.Key.Texture;
 					if(!graphics.Shaders.Enabled) graphics.Device.SetTexture(0, imgsurfaces.Key.Texture);
 
 					graphics.Shaders.Display2D.BeginPass(1);
 					
 					// Go for all surfaces
 					VertexBuffer lastbuffer = null;
 					foreach(SurfaceEntry entry in imgsurfaces.Value)
 					{
 						// Set the vertex buffer
 						SurfaceBufferSet set = sets[entry.numvertices];
 						if(set.buffers[entry.bufferindex] != lastbuffer)
 						{
 							lastbuffer = set.buffers[entry.bufferindex];
 							graphics.Device.SetStreamSource(0, lastbuffer, 0, FlatVertex.Stride);
 						}
 
 						// Draw
 						graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, entry.vertexoffset + (entry.numvertices * surfacevertexoffsetmul), entry.numvertices / 3);
 					}
 					foreach(SurfaceEntry entry in imgsurfaces.Value)
 					{
 						// Set the vertex buffer
 						SurfaceBufferSet set = sets[entry.numvertices];
 						if(set.buffers[entry.bufferindex] != lastbuffer)
 						{
 							lastbuffer = set.buffers[entry.bufferindex];
 							graphics.Device.SetStreamSource(0, lastbuffer, 0, FlatVertex.Stride);
 						}
 
 						// Draw
 						graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, entry.vertexoffset + (entry.numvertices * surfacevertexoffsetmul), entry.numvertices / 3);
 					}
 					
 					graphics.Shaders.Display2D.EndPass();
 				}
 				foreach(KeyValuePair<ImageData, List<SurfaceEntry>> imgsurfaces in surfaces)
 				{
 					// Set texture
 					graphics.Shaders.Display2D.Texture1 = imgsurfaces.Key.Texture;
 					if(!graphics.Shaders.Enabled) graphics.Device.SetTexture(0, imgsurfaces.Key.Texture);
 
 					graphics.Shaders.Display2D.BeginPass(1);
 					
 					// Go for all surfaces
 					VertexBuffer lastbuffer = null;
 					foreach(SurfaceEntry entry in imgsurfaces.Value)
 					{
 						// Set the vertex buffer
 						SurfaceBufferSet set = sets[entry.numvertices];
 						if(set.buffers[entry.bufferindex] != lastbuffer)
 						{
 							lastbuffer = set.buffers[entry.bufferindex];
 							graphics.Device.SetStreamSource(0, lastbuffer, 0, FlatVertex.Stride);
 						}
 
 						// Draw
 						graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, entry.vertexoffset + (entry.numvertices * surfacevertexoffsetmul), entry.numvertices / 3);
 					}
 					
 					graphics.Shaders.Display2D.EndPass();
 				}
 				graphics.Shaders.Display2D.End();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="193" endline="214">
<![CDATA[
 
 		// This returns the bitmap image
 		public Bitmap GetBitmap()
 		{
 			lock(this)
 			{
 				// Image loaded successfully?
 				if(!loadfailed && (imagestate == ImageLoadState.Ready) && (bitmap != null))
 				{
 					return bitmap;
 				}
 				// Image loading failed?
 				else if(loadfailed)
 				{
 					return Properties.Resources.Failed;
 				}
 				else
 				{
 					return Properties.Resources.Hourglass;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\SectorEditForm.cs" startline="68" endline="127">
<![CDATA[
 		
 		// This sets up the form to edit the given sectors
 		public void Setup(ICollection<Sector> sectors)
 		{
 			Sector sc;
 			
 			// Keep this list
 			this.sectors = sectors;
 			if(sectors.Count > 1) this.Text = "Edit Sectors (" + sectors.Count + ")";
 
 			////////////////////////////////////////////////////////////////////////
 			// Set all options to the first sector properties
 			////////////////////////////////////////////////////////////////////////
 
 			// Get first sector
 			sc = General.GetByIndex(sectors, 0);
 
 			// Effects
 			effect.Value = sc.Effect;
 			brightness.Text = sc.Brightness.ToString();
 
 			// Floor/ceiling
 			floorheight.Text = sc.FloorHeight.ToString();
 			ceilingheight.Text = sc.CeilHeight.ToString();
 			floortex.TextureName = sc.FloorTexture;
 			ceilingtex.TextureName = sc.CeilTexture;
 
 			// Action
 			tag.Text = sc.Tag.ToString();
 
 			// Custom fields
 			fieldslist.SetValues(sc.Fields, true);
 			
 			////////////////////////////////////////////////////////////////////////
 			// Now go for all sectors and change the options when a setting is different
 			////////////////////////////////////////////////////////////////////////
 
 			// Go for all sectors
 			foreach(Sector s in sectors)
 			{
 				// Effects
 				if(s.Effect != effect.Value) effect.Empty = true;
 				if(s.Brightness.ToString() != brightness.Text) brightness.Text = "";
 
 				// Floor/Ceiling
 				if(s.FloorHeight.ToString() != floorheight.Text) floorheight.Text = "";
 				if(s.CeilHeight.ToString() != ceilingheight.Text) ceilingheight.Text = "";
 				if(s.FloorTexture != floortex.TextureName) floortex.TextureName = "";
 				if(s.CeilTexture != ceilingtex.TextureName) ceilingtex.TextureName = "";
 
 				// Action
 				if(s.Tag.ToString() != tag.Text) tag.Text = "";
 
 				// Custom fields
 				fieldslist.SetValues(s.Fields, false);
 			}
 			foreach(Sector s in sectors)
 			{
 				// Effects
 				if(s.Effect != effect.Value) effect.Empty = true;
 				if(s.Brightness.ToString() != brightness.Text) brightness.Text = "";
 
 				// Floor/Ceiling
 				if(s.FloorHeight.ToString() != floorheight.Text) floorheight.Text = "";
 				if(s.CeilHeight.ToString() != ceilingheight.Text) ceilingheight.Text = "";
 				if(s.FloorTexture != floortex.TextureName) floortex.TextureName = "";
 				if(s.CeilTexture != ceilingtex.TextureName) ceilingtex.TextureName = "";
 
 				// Action
 				if(s.Tag.ToString() != tag.Text) tag.Text = "";
 
 				// Custom fields
 				fieldslist.SetValues(s.Fields, false);
 			}
 
 			// Show sector height
 			UpdateSectorHeight();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="487" endline="561">
<![CDATA[
 		
 		/// <summary>
 		/// This makes an undo and returns the unique ticket id. Also automatically indicates that the map is changed.
 		/// </summary>
 		/// <param name="description">Any description you want the undo to be named. Should be something related to the changes you are about to make.</param>
 		/// <param name="groupsource">The object creating the undo. All objects from within the same plugin are equal, so it is safe to just use 'this' everywhere. This is only used for undo grouping and you can use 'null' if you don't want undo grouping.</param>
 		/// <param name="groupid">The undo group id you want this undo level to group with (undos only group together if the previous undo has the same source, id and tag). Group 0 indicates no grouping.</param>
 		/// <param name="grouptag">The undo group tag you want this undo level to group with (undos only group together if the previous undo has the same source, id and tag). Use at your own discretion.</param>
 		/// <returns>Ticket ID that identifies the created undo level. Returns -1 when no undo level was created.</returns>
 		public int CreateUndo(string description, object groupsource, int groupid, int grouptag)
 		{
 			UndoSnapshot u;
 			Plugin p = null;
 			string groupsourcename = "Null";
 			
 			// Figure out the source plugin
 			if(groupsource != null)
 			{
 				p = General.Plugins.FindPluginByAssembly(groupsource.GetType().Assembly);
 				if(p != null) groupsourcename = p.Name;
 			}
 
 			// Not the same as previous group, or no grouping desired...
 			if((p == null) || (lastgroupplugin == null) || (p != lastgroupplugin) ||
 			   (groupid == 0) || (lastgroupid == 0) || (groupid != lastgroupid) ||
 			   (grouptag != lastgrouptag))
 			{
 				FinishRecording();
 				
 				// Next ticket id
 				if(++ticketid == int.MaxValue) ticketid = 1;
 				
 				General.WriteLogLine("Creating undo snapshot \"" + description + "\", Source " + groupsourcename + ", Group " + groupid + ", Tag " + grouptag + ", Ticket ID " + ticketid + "...");
 				
 				if((snapshot != null) && !isundosnapshot)
 				{
 					lock(undos)
 					{
 						// The current top of the stack can now be written to disk
 						// because it is no longer the next immediate undo level
 						if(undos.Count > 0) undos[0].StoreOnDisk = true;
 						
 						// Put it on the stack
 						undos.Insert(0, snapshot);
 						LimitUndoRedoLevel(undos);
 					}
 				}
 
 				StartRecording(description);
 				isundosnapshot = false;
 
 				// Clear all redos
 				ClearRedos();
 
 				// Keep grouping info
 				lastgroupplugin = p;
 				lastgroupid = groupid;
 				lastgrouptag = grouptag;
 				
 				// Map changes!
 				General.Map.IsChanged = true;
 
 				// Update
 				dobackgroundwork = true;
 				General.Plugins.OnUndoCreated();
 				General.MainWindow.UpdateInterface();
 				
 				// Done
 				return ticketid;
 			}
 			else
 			{
 				return -1;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditingManager.cs" startline="219" endline="232">
<![CDATA[
 		
 		// This returns specific editing mode info by name
 		internal EditModeInfo GetEditModeInfo(string editmodename)
 		{
 			// Find the edit mode
 			foreach(EditModeInfo emi in usedmodes)
 			{
 				// Mode matches class name?
 				if(emi.Type.Name == editmodename) return emi;
 			}
 			foreach(EditModeInfo emi in usedmodes)
 			{
 				// Mode matches class name?
 				if(emi.Type.Name == editmodename) return emi;
 			}
 			
 			// No such mode found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="660" endline="679">
<![CDATA[
 
 		// This returns all action names for a given key
 		public Action[] GetActionsByKey(int key)
 		{
 			List<Action> actionnames = new List<Action>();
 
 			// Go for all actions
 			foreach(KeyValuePair<string, Action> a in actions)
 			{
 				// This action is associated with this key?
 				if(a.Value.KeyMatches(key))
 				{
 					// List short name
 					actionnames.Add(a.Value);
 				}
 			}
 			foreach(KeyValuePair<string, Action> a in actions)
 			{
 				// This action is associated with this key?
 				if(a.Value.KeyMatches(key))
 				{
 					// List short name
 					actionnames.Add(a.Value);
 				}
 			}
 
 			// Return result;
 			return actionnames.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="856" endline="873">
<![CDATA[
 
 		// This gets the generalized action category from action number
 		public GeneralizedCategory GetGeneralizedActionCategory(int action)
 		{
 			// Only actions above 0
 			if(action > 0)
 			{
 				// Go for all categories
 				foreach(GeneralizedCategory ac in genactioncategories)
 				{
 					// Check if the action is within range of this category
 					if((action >= ac.Offset) && (action < (ac.Offset + ac.Length))) return ac;
 				}
 				foreach(GeneralizedCategory ac in genactioncategories)
 				{
 					// Check if the action is within range of this category
 					if((action >= ac.Offset) && (action < (ac.Offset + ac.Length))) return ac;
 				}
 			}
 
 			// Not generalized
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditingManager.cs" startline="67" endline="127">
<![CDATA[
 		private bool isdisposed = false;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		internal List<EditModeInfo> ModesInfo { get { return allmodes; } }
 		public EditMode Mode { get { return mode; } }
 		public EditMode NewMode { get { return newmode; } }
 		public Type PreviousMode { get { return prevmode; } }
 		public Type PreviousStableMode { get { return prevstablemode; } }
 		public Type PreviousClassicMode { get { return prevclassicmode; } }
 		public bool IsDisposed { get { return isdisposed; } }
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		internal EditingManager()
 		{
 			// Initialize
 			allmodes = new List<EditModeInfo>();
 			usedmodes = new List<EditModeInfo>();
 			groups = new List<string>();
 			
 			// Bind any methods
 			General.Actions.BindMethods(this);
 			
 			// Make list of all editing modes we can find
 			foreach(Plugin p in General.Plugins.Plugins)
 			{
 				// For all classes that inherit from EditMode
 				Type[] editclasses = p.FindClasses(typeof(EditMode));
 				foreach(Type t in editclasses)
 				{
 					// For all defined EditMode attributes
 					EditModeAttribute[]  emattrs = (EditModeAttribute[])t.GetCustomAttributes(typeof(EditModeAttribute), false);
 					foreach(EditModeAttribute a in emattrs)
 					{
 						// Make edit mode information
 						EditModeInfo modeinfo = new EditModeInfo(p, t, a);
 						allmodes.Add(modeinfo);
 						
 						// Add group if not added yet
 						if(!groups.Contains(modeinfo.Attributes.ButtonGroup))
 							groups.Add(modeinfo.Attributes.ButtonGroup);
 					}
 					foreach(EditModeAttribute a in emattrs)
 					{
 						// Make edit mode information
 						EditModeInfo modeinfo = new EditModeInfo(p, t, a);
 						allmodes.Add(modeinfo);
 						
 						// Add group if not added yet
 						if(!groups.Contains(modeinfo.Attributes.ButtonGroup))
 							groups.Add(modeinfo.Attributes.ButtonGroup);
 					}
 				}
 				foreach(Type t in editclasses)
 				{
 					// For all defined EditMode attributes
 					EditModeAttribute[]  emattrs = (EditModeAttribute[])t.GetCustomAttributes(typeof(EditModeAttribute), false);
 					foreach(EditModeAttribute a in emattrs)
 					{
 						// Make edit mode information
 						EditModeInfo modeinfo = new EditModeInfo(p, t, a);
 						allmodes.Add(modeinfo);
 						
 						// Add group if not added yet
 						if(!groups.Contains(modeinfo.Attributes.ButtonGroup))
 							groups.Add(modeinfo.Attributes.ButtonGroup);
 					}
 				}
 			}
 			foreach(Plugin p in General.Plugins.Plugins)
 			{
 				// For all classes that inherit from EditMode
 				Type[] editclasses = p.FindClasses(typeof(EditMode));
 				foreach(Type t in editclasses)
 				{
 					// For all defined EditMode attributes
 					EditModeAttribute[]  emattrs = (EditModeAttribute[])t.GetCustomAttributes(typeof(EditModeAttribute), false);
 					foreach(EditModeAttribute a in emattrs)
 					{
 						// Make edit mode information
 						EditModeInfo modeinfo = new EditModeInfo(p, t, a);
 						allmodes.Add(modeinfo);
 						
 						// Add group if not added yet
 						if(!groups.Contains(modeinfo.Attributes.ButtonGroup))
 							groups.Add(modeinfo.Attributes.ButtonGroup);
 					}
 				}
 			}
 			
 			// Sort the lists
 			allmodes.Sort();
 			groups.Sort();
 			
 			// Update modes
 			UpdateCurrentEditModes();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListView.cs" startline="122" endline="213">
<![CDATA[
 		
 		// When items are dragged over
 		protected override void OnDragOver(DragEventArgs e)
 		{
 			int dropindex, i;
 			ListViewItem insertatitem;
 			Point cp;
 
 			// Check if our data format is present
 			if(!e.Data.GetDataPresent(DataFormats.Text))
 			{
 				e.Effect = DragDropEffects.None;
 				return;
 			}
 
 			// Check if the data matches our data
 			String text = (String)e.Data.GetData(DRAG_TYPE.GetType());
 			if(text.CompareTo(DRAG_TYPE + this.Name) == 0)
 			{
 				// Determine where to insert
 				cp = base.PointToClient(new Point(e.X, e.Y));
 				insertatitem = base.GetItemAt(cp.X, cp.Y);
 				if(insertatitem == null)
 				{
 					// Cannot insert here
 					e.Effect = DragDropEffects.None;
 					return;
 				}
 
 				// Item is one of the items being dragged?
 				if(dragitems.Contains(insertatitem))
 				{
 					// Show move possibility, but dont do anything
 					e.Effect = DragDropEffects.Move;
 					insertatitem.EnsureVisible();
 					return;
 				}
 
 				// Check if item is grayed
 				if(insertatitem.ForeColor != SystemColors.WindowText)
 				{
 					// Cannot insert here
 					e.Effect = DragDropEffects.None;
 					insertatitem.EnsureVisible();
 					return;
 				}
 				
 				// Pass on to base
 				base.OnDragOver(e);
 
 				// Can insert here
 				e.Effect = DragDropEffects.Move;
 				insertatitem.EnsureVisible();
 
 				// Determine index where to insert
 				dropindex = insertatitem.Index;
 				if(dropindex > dragitems[0].Index) dropindex++;
 
 				// Begin updating
 				base.BeginUpdate();
 
 				// Deselect items
 				DeselectAll();
 
 				// Insert items
 				for(i = dragitems.Count - 1; i >= 0; i--)
 				{
 					// Insert a copy of the item here
 					base.Items.Insert(dropindex, (ListViewItem)dragitems[i].Clone());
 					base.Items[dropindex].Selected = true;
 				}
 				for(i = dragitems.Count - 1; i >= 0; i--)
 				{
 					// Insert a copy of the item here
 					base.Items.Insert(dropindex, (ListViewItem)dragitems[i].Clone());
 					base.Items[dropindex].Selected = true;
 				}
 
 				// Remove old items
 				foreach(ListViewItem lvi in dragitems)
 				{
 					// Remove item from list
 					base.Items.Remove(lvi);
 				}
 				foreach(ListViewItem lvi in dragitems)
 				{
 					// Remove item from list
 					base.Items.Remove(lvi);
 				}
 
 				// Copy selected items to the list
 				dragitems.Clear();
 				foreach(ListViewItem lvi in base.SelectedItems) dragitems.Add(lvi);
 				
 				// Done
 				base.EndUpdate();
 			}
 			else
 			{
 				// Cannot insert here
 				e.Effect = DragDropEffects.None;	
 			}
 		}		
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditingManager.cs" startline="291" endline="405">
<![CDATA[
 		
 		//
 		// This changes the editing mode.
 		// Order in which events occur for the old and new modes
 		// 
 		// - Constructor of new mode is called
 		// - Disengage of old mode is called
 		// ----- Mode switches -----
 		// - Engage of new mode is called
 		// - Dispose of old mode is called
 		//
 		// Returns false when cancelled
 		public bool ChangeMode(EditMode nextmode)
 		{
 			EditMode oldmode = mode;
 			
 			if(nextmode != null)
 			{
 				// Verify that this mode is usable
 				bool allowuse = false;
 				foreach(EditModeInfo emi in usedmodes)
 				{
 					if(emi.Type.FullName == nextmode.GetType().FullName)
 					{
 						allowuse = true;
 						break;
 					}
 				}
 				foreach(EditModeInfo emi in usedmodes)
 				{
 					if(emi.Type.FullName == nextmode.GetType().FullName)
 					{
 						allowuse = true;
 						break;
 					}
 				}
 
 				if(!allowuse)
 				{
 					General.Interface.MessageBeep(MessageBeepType.Error);
 					General.WriteLogLine("Attempt to switch to an invalid edit mode " + nextmode.GetType().Name + "!");
 					return false;
 				}
 				else
 				{
 					General.WriteLogLine("Preparing to change editing mode to " + nextmode.GetType().Name + "...");
 				}
 			}
 			else
 			{
 				General.WriteLogLine("Stopping editing mode...");
 			}
 			
 			// Remember previous mode
 			newmode = nextmode;
 			if(mode != null)
 			{
 				prevmode = mode.GetType();
 				if(!mode.Attributes.Volatile)
 				{
 					prevstablemode = prevmode;
 					if(mode is ClassicMode) prevclassicmode = prevmode;
 				}
 			}
 			else
 			{
 				prevmode = null;
 				prevstablemode = null;
 				prevclassicmode = null;
 			}
 			
 			// Let the plugins know beforehand and check if not cancelled
 			if(General.Plugins.ModeChanges(oldmode, newmode))
 			{
 				// Disenagage old mode
 				disengaging = true;
 				if(oldmode != null)
 				{
 					General.Plugins.OnEditDisengage(oldmode, newmode);
 					oldmode.OnDisengage();
 				}
 				
 				// Reset cursor
 				General.Interface.SetCursor(Cursors.Default);
 				
 				// Apply new mode
 				General.WriteLogLine("Editing mode changes from " + TypeNameOrNull(oldmode) + " to " + TypeNameOrNull(nextmode));
 				General.WriteLogLine("Previous stable mode is " + TypeNameOrNull(prevstablemode) + ", previous classic mode is " + TypeNameOrNull(prevclassicmode));
 				mode = newmode;
 				disengaging = false;
 				
 				// Engage new mode
 				if(newmode != null)
 				{
 					newmode.OnEngage();
 					General.Plugins.OnEditEngage(oldmode, newmode);
 				}
 				
 				// Bind new switch actions
 				UnbindSwitchActions();
 				BindAvailableSwitchActions();
 				
 				// Update the interface
 				General.MainWindow.EditModeChanged();
 				
 				// Dispose old mode
 				if(oldmode != null) oldmode.Dispose();
 				
 				// Done switching
 				General.WriteLogLine("Editing mode change complete.");
 				newmode = null;
 				
 				// Redraw the display
 				General.MainWindow.RedrawDisplay();
 				return true;
 			}
 			else
 			{
 				// Cancelled
 				General.WriteLogLine("Editing mode change cancelled.");
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorRow.cs" startline="261" endline="277">
<![CDATA[
 		
 		// This returns the result
 		public object GetResult(object value)
 		{
 			// Anything in the box?
 			if((this.Cells[2].Value != null) && (this.Cells[2].Value.ToString().Length > 0))
 			{
 				// Return validated value
 				fieldtype.SetValue(this.Cells[2].Value);
 				return fieldtype.GetValue();
 			}
 			else
 			{
 				// Return old value
 				return value;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1518" endline="1550">
<![CDATA[
 		private void AddButton(ToolStripItem button, ToolbarSection section, Plugin plugin)
 		{
 			// Fix tags to full action names
 			ToolStripItemCollection items = new ToolStripItemCollection(toolbar, new ToolStripItem[0]);
 			items.Add(button);
 			RenameTagsToFullActions(items, plugin);
 
 			// Add to the list so we can update it as needed
 			PluginToolbarButton buttoninfo = new PluginToolbarButton();
 			buttoninfo.button = button;
 			buttoninfo.section = section;
 			pluginbuttons.Add(buttoninfo);
 			
 			// Bind visible changed event
 			if(!(button is ToolStripSeparator)) button.VisibleChanged += buttonvisiblechangedhandler;
 			
 			// Insert the button in the right section
 			switch(section)
 			{
 				case ToolbarSection.File
 				case ToolbarSection.Script
 				case ToolbarSection.UndoRedo
 				case ToolbarSection.CopyPaste
 				case ToolbarSection.Prefabs
 				case ToolbarSection.Things
 				case ToolbarSection.Views
 				case ToolbarSection.Geometry
 				case ToolbarSection.Testing
 				case ToolbarSection.Custom
 			}
 			
 			UpdateToolbar();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\EnumOptionHandler.cs" startline="74" endline="145">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Methods
 		
 		public override void SetValue(object value)
 		{
 			this.value = null;
 
 			// Input null?
 			if(value == null)
 			{
 				this.value = new EnumItem("0", "NULL");
 			}
 			else
 			{
 				// Compatible type?
 				if((value is int) || (value is float) || (value is bool))
 				{
 					int intvalue = Convert.ToInt32(value);
 
 					// First try to match the value against the enum values
 					foreach(EnumItem item in list)
 					{
 						// Matching value?
 						if(item.GetIntValue() == intvalue)
 						{
 							// Set this value
 							this.value = item;
 						}
 					}
 					foreach(EnumItem item in list)
 					{
 						// Matching value?
 						if(item.GetIntValue() == intvalue)
 						{
 							// Set this value
 							this.value = item;
 						}
 					}
 				}
 
 				// No match found yet?
 				if(this.value == null)
 				{
 					// First try to match the value against the enum values
 					foreach(EnumItem item in list)
 					{
 						// Matching value?
 						if(item.Value == value.ToString())
 						{
 							// Set this value
 							this.value = item;
 						}
 					}
 					foreach(EnumItem item in list)
 					{
 						// Matching value?
 						if(item.Value == value.ToString())
 						{
 							// Set this value
 							this.value = item;
 						}
 					}
 				}
 
 				// No match found yet?
 				if(this.value == null)
 				{
 					// Try to match against the titles
 					foreach(EnumItem item in list)
 					{
 						// Matching value?
 						if(item.Title.ToLowerInvariant() == value.ToString().ToLowerInvariant())
 						{
 							// Set this value
 							this.value = item;
 						}
 					}
 					foreach(EnumItem item in list)
 					{
 						// Matching value?
 						if(item.Title.ToLowerInvariant() == value.ToString().ToLowerInvariant())
 						{
 							// Set this value
 							this.value = item;
 						}
 					}
 				}
 
 				// Still no match found?
 				if(this.value == null)
 				{
 					// Make a dummy value
 					this.value = new EnumItem(value.ToString(), value.ToString());
 					this.value = new EnumItem(this.value.GetIntValue().ToString(CultureInfo.InvariantCulture), value.ToString());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\SectorEditForm.cs" startline="128" endline="172">
<![CDATA[
 
 		// This updates the sector height field
 		private void UpdateSectorHeight()
 		{
 			bool showheight = true;
 			int delta = 0;
 			Sector first = null;
 			
 			// Check all selected sectors
 			foreach(Sector s in sectors)
 			{
 				if(first == null)
 				{
 					// First sector in list
 					delta = s.CeilHeight - s.FloorHeight;
 					showheight = true;
 					first = s;
 				}
 				else
 				{
 					if(delta != (s.CeilHeight - s.FloorHeight))
 					{
 						// We can't show heights because the delta
 						// heights for the sectors is different
 						showheight = false;
 						break;
 					}
 				}
 			}
 			foreach(Sector s in sectors)
 			{
 				if(first == null)
 				{
 					// First sector in list
 					delta = s.CeilHeight - s.FloorHeight;
 					showheight = true;
 					first = s;
 				}
 				else
 				{
 					if(delta != (s.CeilHeight - s.FloorHeight))
 					{
 						// We can't show heights because the delta
 						// heights for the sectors is different
 						showheight = false;
 						break;
 					}
 				}
 			}
 
 			if(showheight)
 			{
 				int fh = floorheight.GetResult(first.FloorHeight);
 				int ch = ceilingheight.GetResult(first.CeilHeight);
 				int height = ch - fh;
 				sectorheight.Text = height.ToString();
 				sectorheight.Visible = true;
 				sectorheightlabel.Visible = true;
 			}
 			else
 			{
 				sectorheight.Visible = false;
 				sectorheightlabel.Visible = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1447" endline="1461">
<![CDATA[
 
 		// This renders the linedefs of a sector
 		public void PlotSector(Sector s)
 		{
 			// Go for all sides in the sector
 			foreach(Sidedef sd in s.Sidedefs)
 			{
 				// Render this linedef
 				PlotLinedef(sd.Line, DetermineLinedefColor(sd.Line));
 
 				// Render the two vertices on top
 				PlotVertex(sd.Line.Start, DetermineVertexColor(sd.Line.Start));
 				PlotVertex(sd.Line.End, DetermineVertexColor(sd.Line.End));
 			}
 			foreach(Sidedef sd in s.Sidedefs)
 			{
 				// Render this linedef
 				PlotLinedef(sd.Line, DetermineLinedefColor(sd.Line));
 
 				// Render the two vertices on top
 				PlotVertex(sd.Line.Start, DetermineVertexColor(sd.Line.Start));
 				PlotVertex(sd.Line.End, DetermineVertexColor(sd.Line.End));
 			}
 		}	
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="42" endline="62">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor to fill list from directory and optionally subdirectories
 		public DirectoryFilesList(string path, bool subdirectories)
 		{
 			path = Path.GetFullPath(path);
 			string[] files = Directory.GetFiles(path, "*", subdirectories ? SearchOption.AllDirectories 
 			entries = new DirectoryFileEntry[files.Length];
 			hashedentries = new Dictionary<string, DirectoryFileEntry>(files.Length);
 			for(int i = 0; i < files.Length; i++)
 			{
 				entries[i] = new DirectoryFileEntry(files[i], path);
 				string hashkey = entries[i].filepathname.ToLowerInvariant();
 				if(hashedentries.ContainsKey(hashkey))
 					throw new IOException("Multiple files with the same filename in the same directory are not allowed. See
 				hashedentries.Add(hashkey, entries[i]);
 			}
 			for(int i = 0; i < files.Length; i++)
 			{
 				entries[i] = new DirectoryFileEntry(files[i], path);
 				string hashkey = entries[i].filepathname.ToLowerInvariant();
 				if(hashedentries.ContainsKey(hashkey))
 					throw new IOException("Multiple files with the same filename in the same directory are not allowed. See
 				hashedentries.Add(hashkey, entries[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="235" endline="272">
<![CDATA[
 
 		// This loads a range of colormaps
 		private void LoadColormapsRange(string startlump, string endlump, ref List<ImageData> images)
 		{
 			int startindex, endindex;
 			float defaultscale;
 			ColormapImage image;
 
 			// Determine default scale
 			defaultscale = General.Map.Config.DefaultTextureScale;
 
 			// Continue until no more start can be found
 			startindex = file.FindLumpIndex(startlump);
 			while(startindex > -1)
 			{
 				// Find end index
 				endindex = file.FindLumpIndex(endlump, startindex + 1);
 				if(endindex > -1)
 				{
 					// Go for all lumps between start and end exclusive
 					for(int i = startindex + 1; i < endindex; i++)
 					{
 						// Lump not zero-length?
 						if(file.Lumps[i].Length > 0)
 						{
 							// Make the image object
 							image = new ColormapImage(file.Lumps[i].Name);
 
 							// Add image to collection
 							images.Add(image);
 						}
 					}
 					for(int i = startindex + 1; i < endindex; i++)
 					{
 						// Lump not zero-length?
 						if(file.Lumps[i].Length > 0)
 						{
 							// Make the image object
 							image = new ColormapImage(file.Lumps[i].Name);
 
 							// Add image to collection
 							images.Add(image);
 						}
 					}
 				}
 
 				// Find the next start
 				startindex = file.FindLumpIndex(startlump, startindex + 1);
 			}
 			while(startindex > -1)
 			{
 				// Find end index
 				endindex = file.FindLumpIndex(endlump, startindex + 1);
 				if(endindex > -1)
 				{
 					// Go for all lumps between start and end exclusive
 					for(int i = startindex + 1; i < endindex; i++)
 					{
 						// Lump not zero-length?
 						if(file.Lumps[i].Length > 0)
 						{
 							// Make the image object
 							image = new ColormapImage(file.Lumps[i].Name);
 
 							// Add image to collection
 							images.Add(image);
 						}
 					}
 				}
 
 				// Find the next start
 				startindex = file.FindLumpIndex(startlump, startindex + 1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="623" endline="660">
<![CDATA[
 
 		// This loads a range of flats
 		private void LoadFlatsRange(string startlump, string endlump, ref List<ImageData> images)
 		{
 			int startindex, endindex;
 			float defaultscale;
 			FlatImage image;
 
 			// Determine default scale
 			defaultscale = General.Map.Config.DefaultTextureScale;
 
 			// Continue until no more start can be found
 			startindex = file.FindLumpIndex(startlump);
 			while(startindex > -1)
 			{
 				// Find end index
 				endindex = file.FindLumpIndex(endlump, startindex + 1);
 				if(endindex > -1)
 				{
 					// Go for all lumps between start and end exclusive
 					for(int i = startindex + 1; i < endindex; i++)
 					{
 						// Lump not zero-length?
 						if(file.Lumps[i].Length > 0)
 						{
 							// Make the image object
 							image = new FlatImage(file.Lumps[i].Name);
 
 							// Add image to collection
 							images.Add(image);
 						}
 					}
 					for(int i = startindex + 1; i < endindex; i++)
 					{
 						// Lump not zero-length?
 						if(file.Lumps[i].Length > 0)
 						{
 							// Make the image object
 							image = new FlatImage(file.Lumps[i].Name);
 
 							// Add image to collection
 							images.Add(image);
 						}
 					}
 				}
 				
 				// Find the next start
 				startindex = file.FindLumpIndex(startlump, startindex + 1);
 			}
 			while(startindex > -1)
 			{
 				// Find end index
 				endindex = file.FindLumpIndex(endlump, startindex + 1);
 				if(endindex > -1)
 				{
 					// Go for all lumps between start and end exclusive
 					for(int i = startindex + 1; i < endindex; i++)
 					{
 						// Lump not zero-length?
 						if(file.Lumps[i].Length > 0)
 						{
 							// Make the image object
 							image = new FlatImage(file.Lumps[i].Name);
 
 							// Add image to collection
 							images.Add(image);
 						}
 					}
 				}
 				
 				// Find the next start
 				startindex = file.FindLumpIndex(startlump, startindex + 1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="278" endline="310">
<![CDATA[
 
 		// This selects an item by name
 		public void SelectItem(string name, ListViewGroup preferredgroup)
 		{
 			ListViewItem lvi = null;
 
 			// Not when selecting is prevented
 			if(preventselection) return;
 
 			// Search in preferred group first
 			if(preferredgroup != null)
 			{
 				foreach(ListViewItem item in list.Items)
 				{
 					if(string.Compare(item.Text, name, true) == 0)
 					{
 						lvi = item;
 						if(item.Group == preferredgroup) break;
 					}
 				}
 				foreach(ListViewItem item in list.Items)
 				{
 					if(string.Compare(item.Text, name, true) == 0)
 					{
 						lvi = item;
 						if(item.Group == preferredgroup) break;
 					}
 				}
 			}
 			
 			// Select the item
 			if(lvi != null)
 			{
 				// Select this item
 				list.SelectedItems.Clear();
 				lvi.Selected = true;
 				lvi.EnsureVisible();
 			}
 
 			UpdateTextureSizeLabel();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\FlagTranslation.cs" startline="49" endline="81">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor
 
 		// Constructor
 		public FlagTranslation(DictionaryEntry de)
 		{
 			// Initialize
 			this.fields = new List<string>();
 			this.values = new List<bool>();
 			
 			// Set the flag
 			if(!int.TryParse(de.Key.ToString(), out flag))
 				General.ErrorLogger.Add(ErrorType.Warning, "Invalid flag translation key in configuration. The key must be numeric.");
 
 			// Set the fields
 			string[] fieldstrings = de.Value.ToString().Split(',');
 			foreach(string f in fieldstrings)
 			{
 				string ft = f.Trim();
 				if(ft.StartsWith("!"))
 				{
 					fields.Add(ft.Substring(1).Trim());
 					values.Add(false);
 				}
 				else
 				{
 					fields.Add(ft);
 					values.Add(true);
 				}
 			}
 			foreach(string f in fieldstrings)
 			{
 				string ft = f.Trim();
 				if(ft.StartsWith("!"))
 				{
 					fields.Add(ft.Substring(1).Trim());
 					values.Add(false);
 				}
 				else
 				{
 					fields.Add(ft);
 					values.Add(true);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GeneralizedOption.cs" startline="56" endline="95">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal GeneralizedOption(string structure, string cat, string name, IDictionary bitslist)
 		{
 			int index;
 			string fullpath;
 			
 			// Determine path
 			if(cat.Length > 0) fullpath = structure + "." + cat;
 				else fullpath = structure;
 
 			// Initialize
 			this.name = CultureInfo.CurrentCulture.TextInfo.ToTitleCase(name);
 			this.bits = new List<GeneralizedBit>();
 
 			// Go for all bits
 			foreach(DictionaryEntry de in bitslist)
 			{
 				// Check if the item key is numeric
 				if(int.TryParse(de.Key.ToString(), NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, CultureInfo.InvariantCulture, out index))
 				{
 					// Add to list
 					this.bits.Add(new GeneralizedBit(index, de.Value.ToString()));
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure '" + fullpath + "." + name + "' contains invalid entries. The keys must be numeric.");
 				}
 			}
 			foreach(DictionaryEntry de in bitslist)
 			{
 				// Check if the item key is numeric
 				if(int.TryParse(de.Key.ToString(), NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, CultureInfo.InvariantCulture, out index))
 				{
 					// Add to list
 					this.bits.Add(new GeneralizedBit(index, de.Value.ToString()));
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure '" + fullpath + "." + name + "' contains invalid entries. The keys must be numeric.");
 				}
 			}
 			
 			// Sort the list
 			bits.Sort();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptDocumentTab.cs" startline="226" endline="278">
<![CDATA[
 		
 		// Find next result
 		public bool FindNext(FindReplaceOptions options)
 		{
 			byte[] data = editor.GetText();
 			string text = Encoding.GetEncoding(config.CodePage).GetString(data);
 			StringComparison mode = options.CaseSensitive ? StringComparison.CurrentCulture 
 			int startpos = Math.Max(editor.SelectionStart, editor.SelectionEnd);
 			bool wrapped = false;
 			
 			while(true)
 			{
 				int result = text.IndexOf(options.FindText, startpos, mode);
 				if(result > -1)
 				{
 					// Check to see if it is the whole word
 					if(options.WholeWord)
 					{
 						// Veryfy that we have found a whole word
 						string foundword = editor.GetWordAt(result + 1);
 						if(foundword.Length != options.FindText.Length)
 						{
 							startpos = result + 1;
 							result = -1;
 						}
 					}
 					
 					// Still ok?
 					if(result > -1)
 					{
 						// Select the result
 						editor.SelectionStart = result;
 						editor.SelectionEnd = result + options.FindText.Length;
 						editor.EnsureLineVisible(editor.LineFromPosition(editor.SelectionEnd));
 						return true;
 					}
 				}
 				else
 				{
 					// If we haven't tried from the start, try from the start now
 					if((startpos > 0) && !wrapped)
 					{
 						startpos = 0;
 						wrapped = true;
 					}
 					else
 					{
 						// Can't find it
 						return false;
 					}
 				}
 			}
 			while(true)
 			{
 				int result = text.IndexOf(options.FindText, startpos, mode);
 				if(result > -1)
 				{
 					// Check to see if it is the whole word
 					if(options.WholeWord)
 					{
 						// Veryfy that we have found a whole word
 						string foundword = editor.GetWordAt(result + 1);
 						if(foundword.Length != options.FindText.Length)
 						{
 							startpos = result + 1;
 							result = -1;
 						}
 					}
 					
 					// Still ok?
 					if(result > -1)
 					{
 						// Select the result
 						editor.SelectionStart = result;
 						editor.SelectionEnd = result + options.FindText.Length;
 						editor.EnsureLineVisible(editor.LineFromPosition(editor.SelectionEnd));
 						return true;
 					}
 				}
 				else
 				{
 					// If we haven't tried from the start, try from the start now
 					if((startpos > 0) && !wrapped)
 					{
 						startpos = 0;
 						wrapped = true;
 					}
 					else
 					{
 						// Can't find it
 						return false;
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1473" endline="1492">
<![CDATA[
 		
 		// This renders a single linedef
 		public void PlotLinedef(Linedef l, PixelColor c)
 		{
 			// Transform vertex coordinates
 			Vector2D v1 = l.Start.Position.GetTransformed(translatex, translatey, scale, -scale);
 			Vector2D v2 = l.End.Position.GetTransformed(translatex, translatey, scale, -scale);
 
 			// Draw line
 			plotter.DrawLineSolid((int)v1.x, (int)v1.y, (int)v2.x, (int)v2.y, ref c);
 
 			// Calculate normal indicator
 			float mx = (v2.x - v1.x) * 0.5f;
 			float my = (v2.y - v1.y) * 0.5f;
 
 			// Draw normal indicator
 			plotter.DrawLineSolid((int)(v1.x + mx), (int)(v1.y + my),
 								  (int)((v1.x + mx) - (my * l.LengthInv) * linenormalsize),
 								  (int)((v1.y + my) + (mx * l.LengthInv) * linenormalsize), ref c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ActorStructure.cs" startline="500" endline="516">
<![CDATA[
 		
 		/// <summary>
 		/// This creates a list of all states, also those inherited from the base class.
 		/// </summary>
 		public Dictionary<string, StateStructure> GetAllStates()
 		{
 			Dictionary<string, StateStructure> list = new Dictionary<string, StateStructure>(states);
 			
 			if(!skipsuper && (baseclass != null))
 			{
 				Dictionary<string, StateStructure> baselist = baseclass.GetAllStates();
 				foreach(KeyValuePair<string, StateStructure> s in baselist)
 					if(!list.ContainsKey(s.Key)) list.Add(s.Key, s.Value);
 				foreach(KeyValuePair<string, StateStructure> s in baselist)
 					if(!list.ContainsKey(s.Key)) list.Add(s.Key, s.Value);
 			}
 			
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="743" endline="763">
<![CDATA[
 
 		// Skills
 		private void LoadSkills()
 		{
 			IDictionary dic;
 
 			// Get skills
 			dic = cfg.ReadSetting("skills", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				int num = 0;
 				if(int.TryParse(de.Key.ToString(), out num))
 				{
 					skills.Add(new SkillInfo(num, de.Value.ToString()));
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'skills' contains invalid skill numbers in game configuration '" + this.Name + "'");
 				}
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				int num = 0;
 				if(int.TryParse(de.Key.ToString(), out num))
 				{
 					skills.Add(new SkillInfo(num, de.Value.ToString()));
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Structure 'skills' contains invalid skill numbers in game configuration '" + this.Name + "'");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1087" endline="1117">
<![CDATA[
 		
 		// This loads the internal sprites
 		private void LoadInternalSprites()
 		{
 			// Add sprite icon files from directory
 			string[] files = Directory.GetFiles(General.SpritesPath, "*.png", SearchOption.TopDirectoryOnly);
 			foreach(string spritefile in files)
 			{
 				ImageData img = new FileImage(Path.GetFileNameWithoutExtension(spritefile).ToLowerInvariant(), spritefile, false);
 				img.LoadImage();
 				img.AllowUnload = false;
 				internalsprites.Add(img.Name, img);
 			}
 			foreach(string spritefile in files)
 			{
 				ImageData img = new FileImage(Path.GetFileNameWithoutExtension(spritefile).ToLowerInvariant(), spritefile, false);
 				img.LoadImage();
 				img.AllowUnload = false;
 				internalsprites.Add(img.Name, img);
 			}
 			
 			// Add some internal resources
 			if(!internalsprites.ContainsKey("nothing"))
 			{
 				ImageData img = new ResourceImage("CodeImp.DoomBuilder.Resources.Nothing.png");
 				img.LoadImage();
 				img.AllowUnload = false;
 				internalsprites.Add("nothing", img);
 			}
 			
 			if(!internalsprites.ContainsKey("unknownthing"))
 			{
 				ImageData img = new ResourceImage("CodeImp.DoomBuilder.Resources.UnknownThing.png");
 				img.LoadImage();
 				img.AllowUnload = false;
 				internalsprites.Add("unknownthing", img);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="173" endline="190">
<![CDATA[
 
 		// Disposer
 		internal override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Destroy rendertargets
 				DestroyRendertargets();
 				foreach(ResourceImage i in thingtexture) i.Dispose();
 				
 				// Dispose surface manager
 				surfaces.Dispose();
 				
 				// Done
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="607" endline="624">
<![CDATA[
 
 		// This renders all sector brightness levels
 		internal void RenderSectorBrightness(RectangleF viewport)
 		{
 			surfaces = new Dictionary<ImageData, List<SurfaceEntry>>();
 			surfacevertexoffsetmul = 0;
 			
 			// Go for all surfaces as they are sorted in the buffers, so that
 			// they are automatically already sorted by vertexbuffer
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					if(entry.bbox.IntersectsWith(viewport))
 						AddSurfaceEntryForRendering(entry, 0);
 				}
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					if(entry.bbox.IntersectsWith(viewport))
 						AddSurfaceEntryForRendering(entry, 0);
 				}
 			}
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					if(entry.bbox.IntersectsWith(viewport))
 						AddSurfaceEntryForRendering(entry, 0);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="505" endline="521">
<![CDATA[
 
 		// This frees the given surface entry
 		public void FreeSurfaces(SurfaceEntryCollection entries)
 		{
 			foreach(SurfaceEntry e in entries)
 			{
 				if((e.numvertices > 0) && (e.bufferindex > -1))
 				{
 					SurfaceBufferSet set = sets[e.numvertices];
 					set.entries.Remove(e);
 					SurfaceEntry newentry = new SurfaceEntry(e);
 					set.holes.Add(newentry);
 				}
 				e.numvertices = -1;
 				e.bufferindex = -1;
 			}
 			foreach(SurfaceEntry e in entries)
 			{
 				if((e.numvertices > 0) && (e.bufferindex > -1))
 				{
 					SurfaceBufferSet set = sets[e.numvertices];
 					set.entries.Remove(e);
 					SurfaceEntry newentry = new SurfaceEntry(e);
 					set.holes.Add(newentry);
 				}
 				e.numvertices = -1;
 				e.bufferindex = -1;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1103" endline="1112">
<![CDATA[
 
 		internal void PlayAddSidedef(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			//LogRecordInfo("PLY
 			Sidedef s = General.Map.Map.GetSidedefByIndex(index);
 			if(s.Sector != null) s.Sector.Marked = true;
 			s.Dispose();
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="764" endline="777">
<![CDATA[
 		
 		// Texture Sets
 		private void LoadTextureSets()
 		{
 			IDictionary dic;
 
 			// Get sets
 			dic = cfg.ReadSetting("texturesets", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				DefinedTextureSet s = new DefinedTextureSet(cfg, "texturesets." + de.Key.ToString());
 				texturesets.Add(s);
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				DefinedTextureSet s = new DefinedTextureSet(cfg, "texturesets." + de.Key.ToString());
 				texturesets.Add(s);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="778" endline="791">
<![CDATA[
 		
 		// Thing Filters
 		private void LoadThingFilters()
 		{
 			IDictionary dic;
 
 			// Get sets
 			dic = cfg.ReadSetting("thingsfilters", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				ThingsFilter f = new ThingsFilter(cfg, "thingsfilters." + de.Key.ToString());
 				thingfilters.Add(f);
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				ThingsFilter f = new ThingsFilter(cfg, "thingsfilters." + de.Key.ToString());
 				thingfilters.Add(f);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1428" endline="1446">
<![CDATA[
 
 		#endregion
 
 		#region ================== Geometry
 
 		// This renders the linedefs of a sector with special color
 		public void PlotSector(Sector s, PixelColor c)
 		{
 			// Go for all sides in the sector
 			foreach(Sidedef sd in s.Sidedefs)
 			{
 				// Render this linedef
 				PlotLinedef(sd.Line, c);
 
 				// Render the two vertices on top
 				PlotVertex(sd.Line.Start, DetermineVertexColor(sd.Line.Start));
 				PlotVertex(sd.Line.End, DetermineVertexColor(sd.Line.End));
 			}
 			foreach(Sidedef sd in s.Sidedefs)
 			{
 				// Render this linedef
 				PlotLinedef(sd.Line, c);
 
 				// Render the two vertices on top
 				PlotVertex(sd.Line.Start, DetermineVertexColor(sd.Line.Start));
 				PlotVertex(sd.Line.End, DetermineVertexColor(sd.Line.End));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ResourceTextureSet.cs" startline="101" endline="121">
<![CDATA[
 
 		// Mix the textures and flats
 		internal void MixTexturesAndFlats()
 		{
 			// Make a copy of the flats only
 			Dictionary<long, ImageData> flatsonly = new Dictionary<long, ImageData>(flats);
 			
 			// Add textures to flats
 			foreach(KeyValuePair<long, ImageData> t in textures)
 			{
 				if(!flats.ContainsKey(t.Key))
 					flats.Add(t.Key, t.Value);
 			}
 			foreach(KeyValuePair<long, ImageData> t in textures)
 			{
 				if(!flats.ContainsKey(t.Key))
 					flats.Add(t.Key, t.Value);
 			}
 			
 			// Add flats to textures
 			foreach(KeyValuePair<long, ImageData> f in flatsonly)
 			{
 				if(!textures.ContainsKey(f.Key))
 					textures.Add(f.Key, f.Value);
 			}
 			foreach(KeyValuePair<long, ImageData> f in flatsonly)
 			{
 				if(!textures.ContainsKey(f.Key))
 					textures.Add(f.Key, f.Value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="382" endline="420">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		// This checks if the given point is inside the sector polygon
 		public bool Intersect(Vector2D p)
 		{
 			uint c = 0;
 			
 			// Go for all sidedefs
 			foreach(Sidedef sd in sidedefs)
 			{
 				// Get vertices
 				Vector2D v1 = sd.Line.Start.Position;
 				Vector2D v2 = sd.Line.End.Position;
 				
 				// Determine min/max values
 				float miny = Math.Min(v1.y, v2.y);
 				float maxy = Math.Max(v1.y, v2.y);
 				float maxx = Math.Max(v1.x, v2.x);
 				
 				// Check for intersection
 				if((p.y > miny) && (p.y <= maxy))
 				{
 					if(p.x <= maxx)
 					{
 						if(v1.y != v2.y)
 						{
 							float xint = (p.y - v1.y) * (v2.x - v1.x) / (v2.y - v1.y) + v1.x;
 							if((v1.x == v2.x) || (p.x <= xint)) c++;
 						}
 					}
 				}
 			}
 			foreach(Sidedef sd in sidedefs)
 			{
 				// Get vertices
 				Vector2D v1 = sd.Line.Start.Position;
 				Vector2D v2 = sd.Line.End.Position;
 				
 				// Determine min/max values
 				float miny = Math.Min(v1.y, v2.y);
 				float maxy = Math.Max(v1.y, v2.y);
 				float maxx = Math.Max(v1.x, v2.x);
 				
 				// Check for intersection
 				if((p.y > miny) && (p.y <= maxy))
 				{
 					if(p.x <= maxx)
 					{
 						if(v1.y != v2.y)
 						{
 							float xint = (p.y - v1.y) * (v2.x - v1.x) / (v2.y - v1.y) + v1.x;
 							if((v1.x == v2.x) || (p.x <= xint)) c++;
 						}
 					}
 				}
 			}
 			
 			// Inside this polygon?
 			return ((c & 0x00000001UL) != 0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="313" endline="334">
<![CDATA[
 		
 		// This sorts tabs by their full name
 		public void SortTabs(IEnumerable<string> fullnames)
 		{
 			Dictionary<string, TabPage> pages = new Dictionary<string, TabPage>(tabs.TabPages.Count);
 			foreach(TabPage p in tabs.TabPages) pages.Add((p.Tag as Docker).FullName, p);
 			tabs.TabPages.Clear();
 			
 			// Add tabs in order as in fullnames
 			foreach(string name in fullnames)
 			{
 				if(pages.ContainsKey(name))
 				{
 					tabs.TabPages.Add(pages[name]);
 					pages.Remove(name);
 				}
 			}
 			foreach(string name in fullnames)
 			{
 				if(pages.ContainsKey(name))
 				{
 					tabs.TabPages.Add(pages[name]);
 					pages.Remove(name);
 				}
 			}
 			
 			// Add remaining tabs
 			foreach(KeyValuePair<string, TabPage> p in pages)
 				tabs.TabPages.Add(p.Value);
 			foreach(KeyValuePair<string, TabPage> p in pages)
 				tabs.TabPages.Add(p.Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualSector.cs" startline="132" endline="171">
<![CDATA[
 		
 		// This updates the visual sector
 		public void Update()
 		{
 			DataStream bufferstream;
 			int numverts = 0;
 			int v = 0;
 			
 			// Trash geometry buffer
 			if(geobuffer != null) geobuffer.Dispose();
 			geobuffer = null;
 			
 			// Count the number of vertices there are
 			foreach(VisualGeometry g in allgeometry) if(g.Vertices != null) numverts += g.Vertices.Length;
 			
 			// Any vertics?
 			if(numverts > 0)
 			{
 				// Make a new buffer
 				geobuffer = new VertexBuffer(General.Map.Graphics.Device, WorldVertex.Stride * numverts,
 											 Usage.WriteOnly | Usage.Dynamic, VertexFormat.None, Pool.Default);
 
 				// Fill the buffer
 				bufferstream = geobuffer.Lock(0, WorldVertex.Stride * numverts, LockFlags.Discard);
 				foreach(VisualGeometry g in allgeometry)
 				{
 					if((g.Vertices != null) && (g.Vertices.Length > 0))
 					{
 						bufferstream.WriteRange<WorldVertex>(g.Vertices);
 						g.VertexOffset = v;
 						v += g.Vertices.Length;
 					}
 				}
 				foreach(VisualGeometry g in allgeometry)
 				{
 					if((g.Vertices != null) && (g.Vertices.Length > 0))
 					{
 						bufferstream.WriteRange<WorldVertex>(g.Vertices);
 						g.VertexOffset = v;
 						v += g.Vertices.Length;
 					}
 				}
 				geobuffer.Unlock();
 				bufferstream.Dispose();
 			}
 			
 			// Done
 			updategeo = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="321" endline="341">
<![CDATA[
 
 		// This fills the list of textures, depending on the selected texture set
 		private void FillImagesList()
 		{
 			// Get the selected texture set
 			IFilledTextureSet set = (selectedset.Tag as IFilledTextureSet);
 			
 			// Start adding
 			browser.BeginAdding(false);
 			
 			// Add all available textures and mark the images for temporary loading
 			foreach(ImageData img in set.Textures)
 				browser.Add(img.Name, img, img, availgroup);
 			foreach(ImageData img in set.Textures)
 				browser.Add(img.Name, img, img, availgroup);
 			
 			// Add all used textures and mark the images for permanent loading
 			foreach(ImageData img in set.Textures)
 				if(img.UsedInMap) browser.Add(img.Name, img, img, usedgroup);
 			foreach(ImageData img in set.Textures)
 				if(img.UsedInMap) browser.Add(img.Name, img, img, usedgroup);
 			
 			// Done adding
 			browser.EndAdding();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="320" endline="340">
<![CDATA[
 
 		// This fills the list of textures, depending on the selected texture set
 		private void FillImagesList(string selectflat)
 		{
 			// Get the selected texture set
 			IFilledTextureSet set = (selectedset.Tag as IFilledTextureSet);
 
 			// Start adding
 			browser.BeginAdding(false);
 
 			// Add all used flats
 			foreach(ImageData img in set.Flats)
 				if(img.UsedInMap) browser.Add(img.Name, img, img, usedgroup);
 			foreach(ImageData img in set.Flats)
 				if(img.UsedInMap) browser.Add(img.Name, img, img, usedgroup);
 
 			// Add all available flats
 			foreach(ImageData img in set.Flats)
 				browser.Add(img.Name, img, img, availgroup);
 			foreach(ImageData img in set.Flats)
 				browser.Add(img.Name, img, img, availgroup);
 
 			// Done adding
 			browser.EndAdding();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="120" endline="139">
<![CDATA[
 
 		// This returns a list of all files that are in the given path and optionally in subdirectories
 		public List<string> GetAllFiles(string path, bool subdirectories)
 		{
 			path = CorrectPath(path).ToLowerInvariant();
 			if(subdirectories)
 			{
 				List<string> files = new List<string>(entries.Length);
 				for(int i = 0; i < entries.Length; i++)
 					if(entries[i].path.StartsWith(path)) files.Add(entries[i].filepathname);
 				for(int i = 0; i < entries.Length; i++)
 					if(entries[i].path.StartsWith(path)) files.Add(entries[i].filepathname);
 				return files;
 			}
 			else
 			{
 				List<string> files = new List<string>(entries.Length);
 				for(int i = 0; i < entries.Length; i++)
 					if(entries[i].path == path) files.Add(entries[i].filepathname);
 				for(int i = 0; i < entries.Length; i++)
 					if(entries[i].path == path) files.Add(entries[i].filepathname);
 				return files;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingEditForm.cs" startline="8" endline="92">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		private bool preventchanges = false;
 		
 		#endregion
 
 		#region ================== Properties
 
 		#endregion
 
 		#region ================== Constructor
 
 		// Constructor
 		public ThingEditForm()
 		{
 			// Initialize
 			InitializeComponent();
 			
 			// Fill flags list
 			foreach(KeyValuePair<string, string> tf in General.Map.Config.ThingFlags)
 				flags.Add(tf.Value, tf.Key);
 			foreach(KeyValuePair<string, string> tf in General.Map.Config.ThingFlags)
 				flags.Add(tf.Value, tf.Key);
 
 			// Fill actions list
 			action.GeneralizedCategories = General.Map.Config.GenActionCategories;
 			action.AddInfo(General.Map.Config.SortedLinedefActions.ToArray());
 
 			// Fill universal fields list
 			fieldslist.ListFixedFields(General.Map.Config.ThingFields);
 			
 			// Initialize custom fields editor
 			fieldslist.Setup("thing");
 
 			// Custom fields?
 			if(!General.Map.FormatInterface.HasCustomFields)
 				tabs.TabPages.Remove(tabcustom);
 			
 			// Tag/Effects?
 			if(!General.Map.FormatInterface.HasThingAction && !General.Map.FormatInterface.HasThingTag)
 				tabs.TabPages.Remove(tabeffects);
 			
 			// Thing height?
 			height.Visible = General.Map.FormatInterface.HasThingHeight;
 			heightlabel.Visible = General.Map.FormatInterface.HasThingHeight;
 			
 			// Setup types list
 			thingtype.Setup();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="8" endline="95">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		private bool preventchanges = false;
 		private bool reloadresources = false;
 
 		// Properties
 		public bool ReloadResources { get { return reloadresources; } }
 
 		// Constructor
 		public ConfigForm()
 		{
 			ListViewItem lvi;
 			
 			// Initialize
 			InitializeComponent();
 			
 			// Make list column header full width
 			columnname.Width = listconfigs.ClientRectangle.Width - SystemInformation.VerticalScrollBarWidth - 2;
 			
 			// Fill list of configurations
 			foreach(ConfigurationInfo ci in General.Configs)
 			{
 				// Add a copy
 				lvi = listconfigs.Items.Add(ci.Name);
 				lvi.Tag = ci.Clone();
 
 				// This is the current configuration?
 				if((General.Map != null) && (General.Map.ConfigSettings.Filename == ci.Filename))
 					lvi.Selected = true;
 			}
 			foreach(ConfigurationInfo ci in General.Configs)
 			{
 				// Add a copy
 				lvi = listconfigs.Items.Add(ci.Name);
 				lvi.Tag = ci.Clone();
 
 				// This is the current configuration?
 				if((General.Map != null) && (General.Map.ConfigSettings.Filename == ci.Filename))
 					lvi.Selected = true;
 			}
 			
 			// No skill
 			skill.Value = 0;
 			
 			// Nodebuilders are allowed to be empty
 			nodebuildersave.Items.Add(new NodebuilderInfo());
 			nodebuildertest.Items.Add(new NodebuilderInfo());
 			
 			// Fill comboboxes with nodebuilders
 			nodebuildersave.Items.AddRange(General.Nodebuilders.ToArray());
 			nodebuildertest.Items.AddRange(General.Nodebuilders.ToArray());
 			
 			// Fill list of editing modes
 			foreach(EditModeInfo emi in General.Editing.ModesInfo)
 			{
 				// Is this mode selectable by the user?
 				if(emi.IsOptional)
 				{
 					lvi = listmodes.Items.Add(emi.Attributes.DisplayName);
 					lvi.Tag = emi;
 					lvi.SubItems.Add(emi.Plugin.Plug.Name);
 				}
 			}
 			foreach(EditModeInfo emi in General.Editing.ModesInfo)
 			{
 				// Is this mode selectable by the user?
 				if(emi.IsOptional)
 				{
 					lvi = listmodes.Items.Add(emi.Attributes.DisplayName);
 					lvi.Tag = emi;
 					lvi.SubItems.Add(emi.Plugin.Plug.Name);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="461" endline="499">
<![CDATA[
 		
 		// Linedef flags
 		private void LoadLinedefFlags()
 		{
 			IDictionary dic;
 			
 			// Get linedef flags
 			dic = cfg.ReadSetting("linedefflags", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 				linedefflags.Add(de.Key.ToString(), de.Value.ToString());
 			foreach(DictionaryEntry de in dic)
 				linedefflags.Add(de.Key.ToString(), de.Value.ToString());
 			
 			// Get translations
 			dic = cfg.ReadSetting("linedefflagstranslation", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 				linedefflagstranslation.Add(new FlagTranslation(de));
 			foreach(DictionaryEntry de in dic)
 				linedefflagstranslation.Add(new FlagTranslation(de));
 			
 			// Sort flags?
 			MapSetIO io = MapSetIO.Create(formatinterface);
 			if(io.HasNumericLinedefFlags)
 			{
 				// Make list for integers that we can sort
 				List<int> sortlist = new List<int>(linedefflags.Count);
 				foreach(KeyValuePair<string, string> f in linedefflags)
 				{
 					int num;
 					if(int.TryParse(f.Key, NumberStyles.Integer, CultureInfo.InvariantCulture, out num)) sortlist.Add(num);
 				}
 				foreach(KeyValuePair<string, string> f in linedefflags)
 				{
 					int num;
 					if(int.TryParse(f.Key, NumberStyles.Integer, CultureInfo.InvariantCulture, out num)) sortlist.Add(num);
 				}
 				
 				// Sort
 				sortlist.Sort();
 				
 				// Make list of strings
 				foreach(int i in sortlist)
 					sortedlinedefflags.Add(i.ToString(CultureInfo.InvariantCulture));
 				foreach(int i in sortlist)
 					sortedlinedefflags.Add(i.ToString(CultureInfo.InvariantCulture));
 			}
 			
 			// Sort the flags, because they must be compared highest first!
 			linedefflagstranslation.Sort();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="1469" endline="1533">
<![CDATA[
 
 		#endregion
 
 		#region ================== Texture Floodfill
 
 		// This performs texture floodfill along all walls that match with the same texture
 		// NOTE
 		// When resetsidemarks is set to true, all sidedefs will first be marked false (not aligned).
 		// Setting resetsidemarks to false is usefull to fill only within a specific selection
 		// (set the marked property to true for the sidedefs outside the selection)
 		public static void FloodfillTextures(Sidedef start, long originaltexture, ImageData filltexture, bool resetsidemarks)
 		{
 			Stack<SidedefFillJob> todo = new Stack<SidedefFillJob>(50);
 
 			// Mark all sidedefs false (they will be marked true when the texture is aligned)
 			if(resetsidemarks) General.Map.Map.ClearMarkedSidedefs(false);
 			
 			// Begin with first sidedef
 			if(SidedefTextureMatch(start, originaltexture))
 			{
 				SidedefFillJob first = new SidedefFillJob();
 				first.sidedef = start;
 				first.forward = true;
 				todo.Push(first);
 			}
 			
 			// Continue until nothing more to align
 			while(todo.Count > 0)
 			{
 				// Get the align job to do
 				SidedefFillJob j = todo.Pop();
 
 				// Apply texturing
 				if(j.sidedef.LongHighTexture == originaltexture) j.sidedef.SetTextureHigh(filltexture.Name);
 				if((((j.sidedef.MiddleTexture.Length > 0) && (j.sidedef.MiddleTexture[0] != '-')) || j.sidedef.MiddleRequired()) &&
 				   (j.sidedef.LongMiddleTexture == originaltexture)) j.sidedef.SetTextureMid(filltexture.Name);
 				if(j.sidedef.LongLowTexture == originaltexture) j.sidedef.SetTextureLow(filltexture.Name);
 				j.sidedef.Marked = true;
 				
 				if(j.forward)
 				{
 					Vertex v;
 
 					// Add sidedefs forward (connected to the right vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.End 
 					AddSidedefsForFloodfill(todo, v, true, originaltexture);
 
 					// Add sidedefs backward (connected to the left vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.Start 
 					AddSidedefsForFloodfill(todo, v, false, originaltexture);
 				}
 				else
 				{
 					Vertex v;
 
 					// Add sidedefs backward (connected to the left vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.Start 
 					AddSidedefsForFloodfill(todo, v, false, originaltexture);
 
 					// Add sidedefs forward (connected to the right vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.End 
 					AddSidedefsForFloodfill(todo, v, true, originaltexture);
 				}
 			}
 			while(todo.Count > 0)
 			{
 				// Get the align job to do
 				SidedefFillJob j = todo.Pop();
 
 				// Apply texturing
 				if(j.sidedef.LongHighTexture == originaltexture) j.sidedef.SetTextureHigh(filltexture.Name);
 				if((((j.sidedef.MiddleTexture.Length > 0) && (j.sidedef.MiddleTexture[0] != '-')) || j.sidedef.MiddleRequired()) &&
 				   (j.sidedef.LongMiddleTexture == originaltexture)) j.sidedef.SetTextureMid(filltexture.Name);
 				if(j.sidedef.LongLowTexture == originaltexture) j.sidedef.SetTextureLow(filltexture.Name);
 				j.sidedef.Marked = true;
 				
 				if(j.forward)
 				{
 					Vertex v;
 
 					// Add sidedefs forward (connected to the right vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.End 
 					AddSidedefsForFloodfill(todo, v, true, originaltexture);
 
 					// Add sidedefs backward (connected to the left vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.Start 
 					AddSidedefsForFloodfill(todo, v, false, originaltexture);
 				}
 				else
 				{
 					Vertex v;
 
 					// Add sidedefs backward (connected to the left vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.Start 
 					AddSidedefsForFloodfill(todo, v, false, originaltexture);
 
 					// Add sidedefs forward (connected to the right vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.End 
 					AddSidedefsForFloodfill(todo, v, true, originaltexture);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="303" endline="423">
<![CDATA[
 
 		// Initializes for an existing map
 		internal bool InitializeOpenMap(string filepathname, MapOptions options)
 		{
 			WAD mapwad;
 			string tempfile;
 			DataLocation maplocation;
 			
 			// Apply settings
 			this.filetitle = Path.GetFileName(filepathname);
 			this.filepathname = filepathname;
 			this.changed = false;
 			this.options = options;
 			
 			General.WriteLogLine("Opening map '" + options.CurrentName + "' with configuration '" + options.ConfigFile + "'");
 
 			// Initiate graphics
 			General.WriteLogLine("Initializing graphics device...");
 			graphics = new D3DDevice(General.MainWindow.Display);
 			if(!graphics.Initialize()) return false;
 
 			// Create renderers
 			renderer2d = new Renderer2D(graphics);
 			renderer3d = new Renderer3D(graphics);
 
 			// Load game configuration
 			General.WriteLogLine("Loading game configuration...");
 			configinfo = General.GetConfigurationInfo(options.ConfigFile);
 			config = new GameConfiguration(General.LoadGameConfiguration(options.ConfigFile));
 			configinfo.ApplyDefaults(config);
 			General.Editing.UpdateCurrentEditModes();
 			
 			// Create map data
 			map = new MapSet();
 			
 			// Create temp wadfile
 			tempfile = General.MakeTempFilename(temppath);
 			General.WriteLogLine("Creating temporary file
 			#if DEBUG
 				tempwad = new WAD(tempfile);
 			#else
 				try { tempwad = new WAD(tempfile); }
 				catch(Exception e)
 				{
 					General.ShowErrorMessage("Error while creating a temporary wad file
 					return false;
 				}
 			#endif
 			
 			// Now open the map file
 			General.WriteLogLine("Opening source file
 			#if DEBUG
 				mapwad = new WAD(filepathname, true);
 			#else
 				try { mapwad = new WAD(filepathname, true); }
 				catch(Exception e)
 				{
 					General.ShowErrorMessage("Error while opening source wad file
 					return false;
 				}
 			#endif
 			
 			// Copy the map lumps to the temp file
 			General.WriteLogLine("Copying map lumps to temporary file...");
 			CopyLumpsByType(mapwad, options.CurrentName, tempwad, TEMP_MAP_HEADER,
 							true, true, true, true);
 			
 			// Close the map file
 			mapwad.Dispose();
 			
 			// Read the map from temp file
 			map.BeginAddRemove();
 			General.WriteLogLine("Initializing map format interface " + config.FormatInterface + "...");
 			io = MapSetIO.Create(config.FormatInterface, tempwad, this);
 			General.WriteLogLine("Reading map data structures from file...");
 			#if DEBUG
 				map = io.Read(map, TEMP_MAP_HEADER);
 			#else
 				try { map = io.Read(map, TEMP_MAP_HEADER); }
 				catch(Exception e)
 				{
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to read the map data structures with the specified configuration. " + e.GetType().Name + "
 					General.ShowErrorMessage("Unable to read the map data structures with the specified configuration.", MessageBoxButtons.OK);
 					return false;
 				}
 			#endif
 			map.EndAddRemove();
 			
 			// Load data manager
 			General.WriteLogLine("Loading data resources...");
 			data = new DataManager();
 			maplocation = new DataLocation(DataLocation.RESOURCE_WAD, filepathname, options.StrictPatches, false, false);
 			data.Load(configinfo.Resources, options.Resources, maplocation);
 
 			// Remove unused sectors
 			map.RemoveUnusedSectors(true);
 			
 			// Update structures
 			options.ApplyGridSettings();
 			map.UpdateConfiguration();
 			map.SnapAllToAccuracy();
 			map.Update();
 			thingsfilter.Update();
 			
 			// Bind any methods
 			General.Actions.BindMethods(this);
 
 			// Set defaults
 			this.visualcamera = new VisualCamera();
 			General.Editing.ChangeMode(configinfo.StartMode);
 			renderer2d.SetViewMode((ViewMode)General.Settings.DefaultViewMode);
 			General.Settings.SetDefaultThingFlags(config.DefaultThingFlags);
 
 			// Center map in screen
 			if(General.Editing.Mode is ClassicMode) (General.Editing.Mode as ClassicMode).CenterInScreen();
 			
 			// Success
 			this.changed = false;
 			General.WriteLogLine("Map loading done");
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2896" endline="2909">
<![CDATA[
 
 		/// <summary>This removes unused vertices.</summary>
 		public void RemoveUnusedVertices()
 		{
 			// Go for all vertices
 			int index = numvertices - 1;
 			while(index >= 0)
 			{
 				if((vertices[index] != null) && (vertices[index].Linedefs.Count == 0))
 					vertices[index].Dispose();
 				else
 					index--;
 			}
 			while(index >= 0)
 			{
 				if((vertices[index] != null) && (vertices[index].Linedefs.Count == 0))
 					vertices[index].Dispose();
 				else
 					index--;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingEditForm.cs" startline="219" endline="261">
<![CDATA[
 		
 		// Action changes
 		private void action_ValueChanges(object sender, EventArgs e)
 		{
 			int showaction = 0;
 			ArgumentInfo[] arginfo;
 
 			// Only when line type is known, otherwise use the thing arguments
 			if(General.Map.Config.LinedefActions.ContainsKey(action.Value)) showaction = action.Value;
 			if((showaction == 0) && (thinginfo != null)) arginfo = thinginfo.Args; else arginfo = General.Map.Config.LinedefActions[showaction].Args;
 			
 			// Change the argument descriptions
 			arg0label.Text = arginfo[0].Title + "
 			arg1label.Text = arginfo[1].Title + "
 			arg2label.Text = arginfo[2].Title + "
 			arg3label.Text = arginfo[3].Title + "
 			arg4label.Text = arginfo[4].Title + "
 			arg0label.Enabled = arginfo[0].Used;
 			arg1label.Enabled = arginfo[1].Used;
 			arg2label.Enabled = arginfo[2].Used;
 			arg3label.Enabled = arginfo[3].Used;
 			arg4label.Enabled = arginfo[4].Used;
 			if(arg0label.Enabled) arg0.ForeColor = SystemColors.WindowText; else arg0.ForeColor = SystemColors.GrayText;
 			if(arg1label.Enabled) arg1.ForeColor = SystemColors.WindowText; else arg1.ForeColor = SystemColors.GrayText;
 			if(arg2label.Enabled) arg2.ForeColor = SystemColors.WindowText; else arg2.ForeColor = SystemColors.GrayText;
 			if(arg3label.Enabled) arg3.ForeColor = SystemColors.WindowText; else arg3.ForeColor = SystemColors.GrayText;
 			if(arg4label.Enabled) arg4.ForeColor = SystemColors.WindowText; else arg4.ForeColor = SystemColors.GrayText;
 			arg0.Setup(arginfo[0]);
 			arg1.Setup(arginfo[1]);
 			arg2.Setup(arginfo[2]);
 			arg3.Setup(arginfo[3]);
 			arg4.Setup(arginfo[4]);
 
 			// Zero all arguments when linedef action 0 (normal) is chosen
 			if(!preventchanges && (showaction == 0))
 			{
 				arg0.SetValue(0);
 				arg1.SetValue(0);
 				arg2.SetValue(0);
 				arg3.SetValue(0);
 				arg4.SetValue(0);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="429" endline="438">
<![CDATA[
 		
 		
 		// This returns the ScriptStyleType for a given Scintilla style
 		private ScriptStyleType GetScriptStyle(int scintillastyle)
 		{
 			if(stylelookup.ContainsKey(scintillastyle))
 				return stylelookup[scintillastyle];
 			else
 				return ScriptStyleType.PlainText;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="455" endline="467">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 		
 		// This checks and returns a flag without creating it
 		public bool IsFlagSet(string flagname)
 		{
 			if(flags.ContainsKey(flagname))
 				return flags[flagname];
 			else
 				return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="508" endline="520">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 
 		// This checks and returns a flag without creating it
 		public bool IsFlagSet(string flagname)
 		{
 			if(flags.ContainsKey(flagname))
 				return flags[flagname];
 			else
 				return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="632" endline="699">
<![CDATA[
 
 		// This returns all points at which the line intersects with the grid
 		public List<Vector2D> GetGridIntersections()
 		{
 			List<Vector2D> coords = new List<Vector2D>();
 			Vector2D v = new Vector2D();
 			float gx, gy, minx, maxx, miny, maxy;
 			bool reversex, reversey;
 			
 			if(start.Position.x > end.Position.x)
 			{
 				minx = end.Position.x;
 				maxx = start.Position.x;
 				reversex = true;
 			}
 			else
 			{
 				minx = start.Position.x;
 				maxx = end.Position.x;
 				reversex = false;
 			}
 
 			if(start.Position.y > end.Position.y)
 			{
 				miny = end.Position.y;
 				maxy = start.Position.y;
 				reversey = true;
 			}
 			else
 			{
 				miny = start.Position.y;
 				maxy = end.Position.y;
 				reversey = false;
 			}
 
 			// Go for all vertical grid lines in between line start and end
 			gx = General.Map.Grid.GetHigher(minx);
 			if(gx < maxx)
 			{
 				for(; gx < maxx; gx += General.Map.Grid.GridSizeF)
 				{
 					// Add intersection point at this x coordinate
 					float u = (gx - minx) / (maxx - minx);
 					if(reversex) u = 1.0f - u;
 					v.x = gx;
 					v.y = start.Position.y + (end.Position.y - start.Position.y) * u;
 					coords.Add(v);
 				}
 				for(; gx < maxx; gx += General.Map.Grid.GridSizeF)
 				{
 					// Add intersection point at this x coordinate
 					float u = (gx - minx) / (maxx - minx);
 					if(reversex) u = 1.0f - u;
 					v.x = gx;
 					v.y = start.Position.y + (end.Position.y - start.Position.y) * u;
 					coords.Add(v);
 				}
 			}
 			
 			// Go for all horizontal grid lines in between line start and end
 			gy = General.Map.Grid.GetHigher(miny);
 			if(gy < maxy)
 			{
 				for(; gy < maxy; gy += General.Map.Grid.GridSizeF)
 				{
 					// Add intersection point at this y coordinate
 					float u = (gy - miny) / (maxy - miny);
 					if(reversey) u = 1.0f - u;
 					v.x = start.Position.x + (end.Position.x - start.Position.x) * u;
 					v.y = gy;
 					coords.Add(v);
 				}
 				for(; gy < maxy; gy += General.Map.Grid.GridSizeF)
 				{
 					// Add intersection point at this y coordinate
 					float u = (gy - miny) / (maxy - miny);
 					if(reversey) u = 1.0f - u;
 					v.x = start.Position.x + (end.Position.x - start.Position.x) * u;
 					v.y = gy;
 					coords.Add(v);
 				}
 			}
 			
 			// Profit
 			return coords;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="409" endline="480">
<![CDATA[
 
 		// User selects a cell for editing
 		private void fieldslist_CellBeginEdit(object sender, DataGridViewCellCancelEventArgs e)
 		{
 			// Field name cell?
 			if(e.ColumnIndex == 0)
 			{
 				// New row index?
 				if(e.RowIndex == fieldslist.NewRowIndex)
 				{
 					// Remove all text
 					fieldslist.Rows[e.RowIndex].Cells[0].Style.ForeColor = SystemColors.WindowText;
 					if(autoinsertuserprefix)
 						fieldslist.Rows[e.RowIndex].Cells[0].Value = FIELD_PREFIX_SUGGESTION;
 					else
 						fieldslist.Rows[e.RowIndex].Cells[0].Value = "";
 				}
 			}
 			// Value cell?
 			else if(e.ColumnIndex == 2)
 			{
 				// Get the row
 				FieldsEditorRow frow = null;
 				DataGridViewRow row = fieldslist.Rows[e.RowIndex];
 				if(row is FieldsEditorRow)
 				{
 					// Get specializedrow
 					frow = row as FieldsEditorRow;
 
 					// Enumerable?
 					if(frow.TypeHandler.IsEnumerable)
 					{
 						// Fill combo with enums
 						enumscombo.SelectedItem = null;
 						enumscombo.Text = "";
 						enumscombo.Items.Clear();
 						enumscombo.Items.AddRange(frow.TypeHandler.GetEnumList().ToArray());
 						enumscombo.Tag = frow;
 						
 						// Lock combo to enums?
 						if(frow.TypeHandler.IsLimitedToEnums)
 							enumscombo.DropDownStyle = ComboBoxStyle.DropDownList;
 						else
 							enumscombo.DropDownStyle = ComboBoxStyle.DropDown;
 						
 						// Position combobox
 						Rectangle cellrect = fieldslist.GetCellDisplayRectangle(2, row.Index, false);
 						enumscombo.Location = new Point(cellrect.Left, cellrect.Top);
 						enumscombo.Width = cellrect.Width;
 						int internalheight = cellrect.Height - (enumscombo.Height - enumscombo.ClientRectangle.Height) - 6;
 						General.SendMessage(enumscombo.Handle, General.CB_SETITEMHEIGHT, -1, internalheight);
 						
 						// Select the value of this field (for DropDownList style combo)
 						foreach(EnumItem i in enumscombo.Items)
 						{
 							// Matches?
 							if(string.Compare(i.Title, frow.TypeHandler.GetStringValue(), true, CultureInfo.InvariantCulture) == 0)
 							{
 								// Select this item
 								enumscombo.SelectedItem = i;
 							}
 						}
 						foreach(EnumItem i in enumscombo.Items)
 						{
 							// Matches?
 							if(string.Compare(i.Title, frow.TypeHandler.GetStringValue(), true, CultureInfo.InvariantCulture) == 0)
 							{
 								// Select this item
 								enumscombo.SelectedItem = i;
 							}
 						}
 
 						// Put the display text in the text (for DropDown style combo)
 						enumscombo.Text = frow.TypeHandler.GetStringValue();
 						
 						// Show combo
 						enumscombo.Show();
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="961" endline="991">
<![CDATA[
 		
 		// This copies all lumps, except those of a specific map
 		private void CopyAllLumpsExceptMap(WAD source, WAD target, string sourcemapname)
 		{
 			// Go for all lumps
 			bool skipping = false;
 			foreach(Lump srclump in source.Lumps)
 			{
 				// Check if we should stop skipping lumps here
 				if(skipping && !config.MapLumpNames.Contains(srclump.Name))
 				{
 					// Stop skipping
 					skipping = false;
 				}
 				
 				// Check if we should start skipping lumps here
 				if(!skipping && (srclump.Name == sourcemapname))
 				{
 					// We have encountered the map header, start skipping!
 					skipping = true;
 				}
 
 				// Not skipping this lump?
 				if(!skipping)
 				{
 					// Copy lump over!
 					Lump tgtlump = target.Insert(srclump.Name, target.Lumps.Count, srclump.Length);
 					srclump.CopyTo(tgtlump);
 				}
 			}
 			foreach(Lump srclump in source.Lumps)
 			{
 				// Check if we should stop skipping lumps here
 				if(skipping && !config.MapLumpNames.Contains(srclump.Name))
 				{
 					// Stop skipping
 					skipping = false;
 				}
 				
 				// Check if we should start skipping lumps here
 				if(!skipping && (srclump.Name == sourcemapname))
 				{
 					// We have encountered the map header, start skipping!
 					skipping = true;
 				}
 
 				// Not skipping this lump?
 				if(!skipping)
 				{
 					// Copy lump over!
 					Lump tgtlump = target.Insert(srclump.Name, target.Lumps.Count, srclump.Length);
 					srclump.CopyTo(tgtlump);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="411" endline="446">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Cutting
 
 		// This cuts into outer polygons to solve inner polygons and make the polygon tree flat
 		private void DoCutting(List<EarClipPolygon> polys)
 		{
 			Queue<EarClipPolygon> todo = new Queue<EarClipPolygon>(polys);
 			
 			// Begin processing outer polygons
 			while(todo.Count > 0)
 			{
 				// Get outer polygon to process
 				EarClipPolygon p = todo.Dequeue();
 
 				// Any inner polygons to work with?
 				if(p.Children.Count > 0)
 				{
 					// Go for all the children
 					foreach(EarClipPolygon c in p.Children)
 					{
 						// The children of the children are outer polygons again,
 						// so move them to the root and add for processing
 						polys.AddRange(c.Children);
 						foreach(EarClipPolygon sc in c.Children) todo.Enqueue(sc);
 
 						// Remove from inner polygon
 						c.Children.Clear();
 					}
 					foreach(EarClipPolygon c in p.Children)
 					{
 						// The children of the children are outer polygons again,
 						// so move them to the root and add for processing
 						polys.AddRange(c.Children);
 						foreach(EarClipPolygon sc in c.Children) todo.Enqueue(sc);
 
 						// Remove from inner polygon
 						c.Children.Clear();
 					}
 
 					// Now do some cutting on this polygon to merge the inner polygons
 					MergeInnerPolys(p);
 				}
 			}
 			while(todo.Count > 0)
 			{
 				// Get outer polygon to process
 				EarClipPolygon p = todo.Dequeue();
 
 				// Any inner polygons to work with?
 				if(p.Children.Count > 0)
 				{
 					// Go for all the children
 					foreach(EarClipPolygon c in p.Children)
 					{
 						// The children of the children are outer polygons again,
 						// so move them to the root and add for processing
 						polys.AddRange(c.Children);
 						foreach(EarClipPolygon sc in c.Children) todo.Enqueue(sc);
 
 						// Remove from inner polygon
 						c.Children.Clear();
 					}
 
 					// Now do some cutting on this polygon to merge the inner polygons
 					MergeInnerPolys(p);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="436" endline="454">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Suspend / Resume
 
 		// This suspends data resources
 		internal void Suspend()
 		{
 			// Stop background loader
 			StopBackgroundLoader();
 			
 			// Go for all containers
 			foreach(DataReader d in containers)
 			{
 				// Suspend
 				General.WriteLogLine("Suspended data resource '" + d.Location.location + "'");
 				d.Suspend();
 			}
 			foreach(DataReader d in containers)
 			{
 				// Suspend
 				General.WriteLogLine("Suspended data resource '" + d.Location.location + "'");
 				d.Suspend();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="567" endline="588">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Rendering
 		
 		// This renders all sector floors
 		internal void RenderSectorFloors(RectangleF viewport)
 		{
 			surfaces = new Dictionary<ImageData, List<SurfaceEntry>>();
 			surfacevertexoffsetmul = 0;
 			
 			// Go for all surfaces as they are sorted in the buffers, so that
 			// they are automatically already sorted by vertexbuffer
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					if(entry.bbox.IntersectsWith(viewport))
 						AddSurfaceEntryForRendering(entry, entry.floortexture);
 				}
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					if(entry.bbox.IntersectsWith(viewport))
 						AddSurfaceEntryForRendering(entry, entry.floortexture);
 				}
 			}
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					if(entry.bbox.IntersectsWith(viewport))
 						AddSurfaceEntryForRendering(entry, entry.floortexture);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="589" endline="606">
<![CDATA[
 		
 		// This renders all sector ceilings
 		internal void RenderSectorCeilings(RectangleF viewport)
 		{
 			surfaces = new Dictionary<ImageData, List<SurfaceEntry>>();
 			surfacevertexoffsetmul = 1;
 			
 			// Go for all surfaces as they are sorted in the buffers, so that
 			// they are automatically already sorted by vertexbuffer
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					if(entry.bbox.IntersectsWith(viewport))
 						AddSurfaceEntryForRendering(entry, entry.ceiltexture);
 				}
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					if(entry.bbox.IntersectsWith(viewport))
 						AddSurfaceEntryForRendering(entry, entry.ceiltexture);
 				}
 			}
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					if(entry.bbox.IntersectsWith(viewport))
 						AddSurfaceEntryForRendering(entry, entry.ceiltexture);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="201" endline="234">
<![CDATA[
 
 		#endregion
 
 		#region ================== Colormaps
 
 		// This loads the textures
 		public override ICollection<ImageData> LoadColormaps()
 		{
 			List<ImageData> images = new List<ImageData>();
 			string rangestart, rangeend;
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Read ranges from configuration
 			foreach(DictionaryEntry r in General.Map.Config.ColormapRanges)
 			{
 				// Read start and end
 				rangestart = General.Map.Config.ReadSetting("colormaps." + r.Key + ".start", "");
 				rangeend = General.Map.Config.ReadSetting("colormaps." + r.Key + ".end", "");
 				if((rangestart.Length > 0) && (rangeend.Length > 0))
 				{
 					// Load texture range
 					LoadColormapsRange(rangestart, rangeend, ref images);
 				}
 			}
 			foreach(DictionaryEntry r in General.Map.Config.ColormapRanges)
 			{
 				// Read start and end
 				rangestart = General.Map.Config.ReadSetting("colormaps." + r.Key + ".start", "");
 				rangeend = General.Map.Config.ReadSetting("colormaps." + r.Key + ".end", "");
 				if((rangestart.Length > 0) && (rangeend.Length > 0))
 				{
 					// Load texture range
 					LoadColormapsRange(rangestart, rangeend, ref images);
 				}
 			}
 
 			// Add images to the container-specific texture set
 			foreach(ImageData img in images)
 				textureset.AddFlat(img);
 			foreach(ImageData img in images)
 				textureset.AddFlat(img);
 
 			// Return result
 			return images;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="370" endline="407">
<![CDATA[
 
 		// This updates a dynamic texture
 		public void UpdateTexture()
 		{
 			if(!dynamictexture)
 				throw new Exception("The image must be a dynamic image to support direct updating.");
 			
 			lock(this)
 			{
 				if((texture != null) && !texture.Disposed)
 				{
 					// Lock the bitmap and texture
 					BitmapData bmpdata = bitmap.LockBits(new Rectangle(0, 0, bitmap.Size.Width, bitmap.Size.Height), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
 					DataRectangle texdata = texture.LockRectangle(0, LockFlags.Discard);
 
 					// Copy data
 					int* bp = (int*)bmpdata.Scan0.ToPointer();
 					int* tp = (int*)texdata.Data.DataPointer.ToPointer();
 					for(int y = 0; y < bmpdata.Height; y++)
 					{
 						for(int x = 0; x < bmpdata.Width; x++)
 						{
 							*tp = *bp;
 							bp++;
 							tp++;
 						}
 						for(int x = 0; x < bmpdata.Width; x++)
 						{
 							*tp = *bp;
 							bp++;
 							tp++;
 						}
 
 						// Skip extra data in texture
 						int extrapitch = (texdata.Pitch >> 2) - bmpdata.Width;
 						tp += extrapitch;
 					}
 					for(int y = 0; y < bmpdata.Height; y++)
 					{
 						for(int x = 0; x < bmpdata.Width; x++)
 						{
 							*tp = *bp;
 							bp++;
 							tp++;
 						}
 
 						// Skip extra data in texture
 						int extrapitch = (texdata.Pitch >> 2) - bmpdata.Width;
 						tp += extrapitch;
 					}
 
 					// Unlock
 					texture.UnlockRectangle(0);
 					bitmap.UnlockBits(bmpdata);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="576" endline="622">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Flats
 
 		// This loads the textures
 		public override ICollection<ImageData> LoadFlats()
 		{
 			List<ImageData> images = new List<ImageData>();
 			string rangestart, rangeend;
 			int lumpindex;
 			
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Read ranges from configuration
 			foreach(DictionaryEntry r in General.Map.Config.FlatRanges)
 			{
 				// Read start and end
 				rangestart = General.Map.Config.ReadSetting("flats." + r.Key + ".start", "");
 				rangeend = General.Map.Config.ReadSetting("flats." + r.Key + ".end", "");
 				if((rangestart.Length > 0) && (rangeend.Length > 0))
 				{
 					// Load texture range
 					LoadFlatsRange(rangestart, rangeend, ref images);
 				}
 			}
 			foreach(DictionaryEntry r in General.Map.Config.FlatRanges)
 			{
 				// Read start and end
 				rangestart = General.Map.Config.ReadSetting("flats." + r.Key + ".start", "");
 				rangeend = General.Map.Config.ReadSetting("flats." + r.Key + ".end", "");
 				if((rangestart.Length > 0) && (rangeend.Length > 0))
 				{
 					// Load texture range
 					LoadFlatsRange(rangestart, rangeend, ref images);
 				}
 			}
 
 			// Load TEXTURES lump file
 			lumpindex = file.FindLumpIndex("TEXTURES");
 			while(lumpindex > -1)
 			{
 				MemoryStream filedata = new MemoryStream(file.Lumps[lumpindex].Stream.ReadAllBytes());
 				WADReader.LoadHighresFlats(filedata, "TEXTURES", ref images, null, null);
 				filedata.Dispose();
 
 				// Find next
 				lumpindex = file.FindLumpIndex("TEXTURES", lumpindex + 1);
 			}
 			while(lumpindex > -1)
 			{
 				MemoryStream filedata = new MemoryStream(file.Lumps[lumpindex].Stream.ReadAllBytes());
 				WADReader.LoadHighresFlats(filedata, "TEXTURES", ref images, null, null);
 				filedata.Dispose();
 
 				// Find next
 				lumpindex = file.FindLumpIndex("TEXTURES", lumpindex + 1);
 			}
 			
 			// Add images to the container-specific texture set
 			foreach(ImageData img in images)
 				textureset.AddFlat(img);
 			foreach(ImageData img in images)
 				textureset.AddFlat(img);
 
 			// Return result
 			return images;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="330" endline="369">
<![CDATA[
 		
 		// This creates the Direct3D texture
 		public virtual void CreateTexture()
 		{
 			MemoryStream memstream;
 			
 			lock(this)
 			{
 				// Only do this when texture is not created yet
 				if(((texture == null) || (texture.Disposed)) && this.IsImageLoaded && !loadfailed)
 				{
 					Image img = bitmap;
 					if(loadfailed) img = Properties.Resources.Failed;
 					
 					// Write to memory stream and read from memory
 					memstream = new MemoryStream((img.Size.Width * img.Size.Height * 4) + 4096);
 					img.Save(memstream, ImageFormat.Bmp);
 					memstream.Seek(0, SeekOrigin.Begin);
 					if(dynamictexture)
 					{
 						texture = Texture.FromStream(General.Map.Graphics.Device, memstream, (int)memstream.Length,
 										img.Size.Width, img.Size.Height, mipmaplevels, Usage.Dynamic, Format.A8R8G8B8,
 										Pool.Default, General.Map.Graphics.PostFilter, General.Map.Graphics.MipGenerateFilter, 0);
 					}
 					else
 					{
 						texture = Texture.FromStream(General.Map.Graphics.Device, memstream, (int)memstream.Length,
 										img.Size.Width, img.Size.Height, mipmaplevels, Usage.None, Format.Unknown,
 										Pool.Managed, General.Map.Graphics.PostFilter, General.Map.Graphics.MipGenerateFilter, 0);
 					}
 					memstream.Dispose();
 					
 					if(dynamictexture)
 					{
 						if((width != texture.GetLevelDescription(0).Width) || (height != texture.GetLevelDescription(0).Height))
 							throw new Exception("Could not create a texture with the same size as the image.");
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="829" endline="862">
<![CDATA[
 
 		// This verifies if the nodebuilder lumps exist in a WAD file
 		private bool VerifyNodebuilderLumps(WAD wad, string mapheader)
 		{
 			bool lumpscomplete = false;
 			
 			// Find the map header in source
 			int srcindex = wad.FindLumpIndex(mapheader);
 			if(srcindex > -1)
 			{
 				// Go for all the map lump names
 				lumpscomplete = true;
 				foreach(DictionaryEntry ml in config.MapLumpNames)
 				{
 					// Read lump settings from map config
 					bool lumpnodebuild = config.ReadSetting("maplumpnames." + ml.Key + ".nodebuild", false);
 					bool lumpallowempty = config.ReadSetting("maplumpnames." + ml.Key + ".allowempty", false);
 
 					// Check if this lump should exist
 					if(lumpnodebuild && !lumpallowempty)
 					{
 						// Find the lump in the source
 						if(wad.FindLump(ml.Key.ToString(), srcindex, srcindex + config.MapLumpNames.Count + 2) == null)
 						{
 							// Missing a lump!
 							lumpscomplete = false;
 							break;
 						}
 					}
 				}
 				foreach(DictionaryEntry ml in config.MapLumpNames)
 				{
 					// Read lump settings from map config
 					bool lumpnodebuild = config.ReadSetting("maplumpnames." + ml.Key + ".nodebuild", false);
 					bool lumpallowempty = config.ReadSetting("maplumpnames." + ml.Key + ".allowempty", false);
 
 					// Check if this lump should exist
 					if(lumpnodebuild && !lumpallowempty)
 					{
 						// Find the lump in the source
 						if(wad.FindLump(ml.Key.ToString(), srcindex, srcindex + config.MapLumpNames.Count + 2) == null)
 						{
 							// Missing a lump!
 							lumpscomplete = false;
 							break;
 						}
 					}
 				}
 			}
 
 			return lumpscomplete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="8" endline="113">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ThingsFiltersForm()
 		{
 			settingup = true;
 			
 			// Initialize
 			InitializeComponent();
 			
 			// Fill types list
 			List<ThingTypeInfo> thingtypes = new List<ThingTypeInfo>(General.Map.Data.ThingTypes);
 			INumberedTitle[] typeitems = new INumberedTitle[thingtypes.Count];
 			for(int i = 0; i < thingtypes.Count; i++) typeitems[i] = thingtypes[i];
 			filtertype.AddInfo(typeitems);
 			
 			// Fill the categories combobox
 			filtercategory.Items.Add("(any category)");
 			filtercategory.Items.AddRange(General.Map.Data.ThingCategories.ToArray());
 			
 			// Fill actions list
 			filteraction.GeneralizedCategories = General.Map.Config.GenActionCategories;
 			filteraction.AddInfo(General.Map.Config.SortedLinedefActions.ToArray());
 			
 			// Initialize custom fields editor
 			fieldslist.ListNoFixedFields();
 			fieldslist.Setup("thing");
 			
 			// Fill checkboxes list
 			foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 			{
 				CheckBox box = filterfields.Add(flag.Value, flag.Key);
 				box.ThreeState = true;
 				box.CheckStateChanged += new EventHandler(filterfield_Check);
 			}
 			foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 			{
 				CheckBox box = filterfields.Add(flag.Value, flag.Key);
 				box.ThreeState = true;
 				box.CheckStateChanged += new EventHandler(filterfield_Check);
 			}
 			
 			// Fill list of filters
 			foreach(ThingsFilter f in General.Map.ConfigSettings.ThingsFilters)
 			{
 				// Make a copy (we don't want to modify the filters until OK is clicked)
 				ThingsFilter nf = new ThingsFilter(f);
 				
 				// Make item in list
 				ListViewItem item = new ListViewItem(nf.Name);
 				item.Tag = nf;
 				listfilters.Items.Add(item);
 				
 				// Select item if this is the current filter
 				if(General.Map.ThingsFilter == f) item.Selected = true;
 			}
 			foreach(ThingsFilter f in General.Map.ConfigSettings.ThingsFilters)
 			{
 				// Make a copy (we don't want to modify the filters until OK is clicked)
 				ThingsFilter nf = new ThingsFilter(f);
 				
 				// Make item in list
 				ListViewItem item = new ListViewItem(nf.Name);
 				item.Tag = nf;
 				listfilters.Items.Add(item);
 				
 				// Select item if this is the current filter
 				if(General.Map.ThingsFilter == f) item.Selected = true;
 			}
 			
 			// Sort the list
 			listfilters.Sort();
 			
 			// Map format specific fields
 			filterzheight.Visible = General.Map.FormatInterface.HasThingHeight;
 			labelzheight.Visible = General.Map.FormatInterface.HasThingHeight;
 			argumentspanel.Visible = General.Map.FormatInterface.HasActionArgs;
 			labeltag.Visible = General.Map.FormatInterface.HasThingTag;
 			filtertag.Visible = General.Map.FormatInterface.HasThingTag;
 			if(!General.Map.FormatInterface.HasCustomFields)
 				tabs.TabPages.Remove(tabcustom);
 			if(!General.Map.FormatInterface.HasThingAction && !General.Map.FormatInterface.HasThingTag)
 				tabs.TabPages.Remove(tabaction);
 			
 			// Done
 			settingup = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="838" endline="855">
<![CDATA[
 		
 		// This checks if an action is generalized or predefined
 		public static bool IsGeneralized(int action, List<GeneralizedCategory> categories)
 		{
 			// Only actions above 0
 			if(action > 0)
 			{
 				// Go for all categories
 				foreach(GeneralizedCategory ac in categories)
 				{
 					// Check if the action is within range of this category
 					if((action >= ac.Offset) && (action < (ac.Offset + ac.Length))) return true;
 				}
 				foreach(GeneralizedCategory ac in categories)
 				{
 					// Check if the action is within range of this category
 					if((action >= ac.Offset) && (action < (ac.Offset + ac.Length))) return true;
 				}
 			}
 
 			// Not generalized
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="84" endline="104">
<![CDATA[
 		
 		// Disposer
 		public override void Dispose()
 		{
 			// Not already disposed?
 			if(!isdisposed)
 			{
 				// Clean up
 				foreach(WADReader wr in wads) wr.Dispose();
 				
 				// Remove temp files
 				foreach(WADReader wr in wads)
 				{
 					try { File.Delete(wr.Location.location); }
 					catch(Exception) { }
 				}
 				foreach(WADReader wr in wads)
 				{
 					try { File.Delete(wr.Location.location); }
 					catch(Exception) { }
 				}
 				
 				// Done
 				base.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="708" endline="742">
<![CDATA[
 
 		#endregion
 
 		#region ================== Colormaps
 
 		// This loads the colormaps
 		private int LoadColormaps(Dictionary<long, ImageData> list)
 		{
 			ICollection<ImageData> images;
 			int counter = 0;
 
 			// Go for all opened containers
 			foreach(DataReader dr in containers)
 			{
 				// Load colormaps
 				images = dr.LoadColormaps();
 				if(images != null)
 				{
 					// Go for all colormaps
 					foreach(ImageData img in images)
 					{
 						// Add or replace in flats list
 						list.Remove(img.LongName);
 						list.Add(img.LongName, img);
 						counter++;
 
 						// Add to preview manager
 						previews.AddImage(img);
 					}
 					foreach(ImageData img in images)
 					{
 						// Add or replace in flats list
 						list.Remove(img.LongName);
 						list.Add(img.LongName, img);
 						counter++;
 
 						// Add to preview manager
 						previews.AddImage(img);
 					}
 				}
 			}
 			foreach(DataReader dr in containers)
 			{
 				// Load colormaps
 				images = dr.LoadColormaps();
 				if(images != null)
 				{
 					// Go for all colormaps
 					foreach(ImageData img in images)
 					{
 						// Add or replace in flats list
 						list.Remove(img.LongName);
 						list.Add(img.LongName, img);
 						counter++;
 
 						// Add to preview manager
 						previews.AddImage(img);
 					}
 				}
 			}
 
 			// Output info
 			return counter;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="881" endline="915">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Flats
 
 		// This loads the flats
 		private int LoadFlats(Dictionary<long, ImageData> list)
 		{
 			ICollection<ImageData> images;
 			int counter = 0;
 			
 			// Go for all opened containers
 			foreach(DataReader dr in containers)
 			{
 				// Load flats
 				images = dr.LoadFlats();
 				if(images != null)
 				{
 					// Go for all flats
 					foreach(ImageData img in images)
 					{
 						// Add or replace in flats list
 						list.Remove(img.LongName);
 						list.Add(img.LongName, img);
 						counter++;
 
 						// Add to preview manager
 						previews.AddImage(img);
 					}
 					foreach(ImageData img in images)
 					{
 						// Add or replace in flats list
 						list.Remove(img.LongName);
 						list.Add(img.LongName, img);
 						counter++;
 
 						// Add to preview manager
 						previews.AddImage(img);
 					}
 				}
 			}
 			foreach(DataReader dr in containers)
 			{
 				// Load flats
 				images = dr.LoadFlats();
 				if(images != null)
 				{
 					// Go for all flats
 					foreach(ImageData img in images)
 					{
 						// Add or replace in flats list
 						list.Remove(img.LongName);
 						list.Add(img.LongName, img);
 						counter++;
 
 						// Add to preview manager
 						previews.AddImage(img);
 					}
 				}
 			}
 
 			// Output info
 			return counter;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="564" endline="598">
<![CDATA[
 		
 		// This will call the associated actions for a keypress
 		// Returns true when the key invokes any action
 		internal bool BeginActionByKey(int key, bool repeated)
 		{
 			bool invoked = false;
 			
 			// Get all actions for which a begin is bound
 			List<Action> boundactions = new List<Action>(actions.Count);
 			foreach(KeyValuePair<string, Action> a in actions)
 				if(a.Value.BeginBound) boundactions.Add(a.Value);
 			foreach(KeyValuePair<string, Action> a in actions)
 				if(a.Value.BeginBound) boundactions.Add(a.Value);
 			
 			// Go for all actions
 			foreach(Action a in boundactions)
 			{
 				// This action is associated with this key?
 				if(a.KeyMatches(key))
 				{
 					invoked = true;
 					
 					// Allowed to repeat?
 					if(a.Repeat || !repeated)
 					{
 						// Invoke action
 						a.Begin();
 					}
 					else
 					{
 						//General.WriteLogLine("Action \"" + a.Value.Name + "\" failed because it does not support repeating activation!");
 					}
 				}
 			}
 			foreach(Action a in boundactions)
 			{
 				// This action is associated with this key?
 				if(a.KeyMatches(key))
 				{
 					invoked = true;
 					
 					// Allowed to repeat?
 					if(a.Repeat || !repeated)
 					{
 						// Invoke action
 						a.Begin();
 					}
 					else
 					{
 						//General.WriteLogLine("Action \"" + a.Value.Name + "\" failed because it does not support repeating activation!");
 					}
 				}
 			}
 
 			return invoked;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="398" endline="422">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Writing
 
 		// This writes a MapSet to the file
 		public override void Write(MapSet map, string mapname, int position)
 		{
 			Dictionary<Vertex, int> vertexids = new Dictionary<Vertex,int>();
 			Dictionary<Sidedef, int> sidedefids = new Dictionary<Sidedef,int>();
 			Dictionary<Sector, int> sectorids = new Dictionary<Sector,int>();
 			
 			// First index everything
 			foreach(Vertex v in map.Vertices) vertexids.Add(v, vertexids.Count);
 			foreach(Sidedef sd in map.Sidedefs) sidedefids.Add(sd, sidedefids.Count);
 			foreach(Sector s in map.Sectors) sectorids.Add(s, sectorids.Count);
 			
 			// Write lumps to wad (note the backwards order because they
 			// are all inserted at position+1 when not found)
 			WriteSectors(map, position, manager.Config.MapLumpNames);
 			WriteVertices(map, position, manager.Config.MapLumpNames);
 			WriteSidedefs(map, position, manager.Config.MapLumpNames, sectorids);
 			WriteLinedefs(map, position, manager.Config.MapLumpNames, sidedefids, vertexids);
 			WriteThings(map, position, manager.Config.MapLumpNames);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="413" endline="437">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Writing
 
 		// This writes a MapSet to the file
 		public override void Write(MapSet map, string mapname, int position)
 		{
 			Dictionary<Vertex, int> vertexids = new Dictionary<Vertex,int>();
 			Dictionary<Sidedef, int> sidedefids = new Dictionary<Sidedef,int>();
 			Dictionary<Sector, int> sectorids = new Dictionary<Sector,int>();
 			
 			// First index everything
 			foreach(Vertex v in map.Vertices) vertexids.Add(v, vertexids.Count);
 			foreach(Sidedef sd in map.Sidedefs) sidedefids.Add(sd, sidedefids.Count);
 			foreach(Sector s in map.Sectors) sectorids.Add(s, sectorids.Count);
 			
 			// Write lumps to wad (note the backwards order because they
 			// are all inserted at position+1 when not found)
 			WriteSectors(map, position, manager.Config.MapLumpNames);
 			WriteVertices(map, position, manager.Config.MapLumpNames);
 			WriteSidedefs(map, position, manager.Config.MapLumpNames, sectorids);
 			WriteLinedefs(map, position, manager.Config.MapLumpNames, sidedefids, vertexids);
 			WriteThings(map, position, manager.Config.MapLumpNames);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="500" endline="568">
<![CDATA[
 
 		// Linedef actions and action categories
 		private void LoadLinedefActions()
 		{
 			Dictionary<string, LinedefActionCategory> cats = new Dictionary<string, LinedefActionCategory>();
 			IDictionary dic;
 			LinedefActionInfo ai;
 			LinedefActionCategory ac;
 			int actionnumber;
 			
 			// Get linedef categories
 			dic = cfg.ReadSetting("linedeftypes", new Hashtable());
 			foreach(DictionaryEntry cde in dic)
 			{
 				if(cde.Value is IDictionary)
 				{
 					// Read category title
 					string cattitle = cfg.ReadSetting("linedeftypes." + cde.Key + ".title", "");
 
 					// Make or get category
 					if(cats.ContainsKey(cde.Key.ToString()))
 						ac = cats[cde.Key.ToString()];
 					else
 					{
 						ac = new LinedefActionCategory(cde.Key.ToString(), cattitle);
 						cats.Add(cde.Key.ToString(), ac);
 					}
 
 					// Go for all line types in category
 					IDictionary catdic = cfg.ReadSetting("linedeftypes." + cde.Key, new Hashtable());
 					foreach(DictionaryEntry de in catdic)
 					{
 						// Check if the item key is numeric
 						if(int.TryParse(de.Key.ToString(),
 							NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite,
 							CultureInfo.InvariantCulture, out actionnumber))
 						{
 							// Check if the item value is a structure
 							if(de.Value is IDictionary)
 							{
 								// Make the line type
 								ai = new LinedefActionInfo(actionnumber, cfg, cde.Key.ToString(), enums);
 
 								// Add action to category and sorted list
 								sortedlinedefactions.Add(ai);
 								linedefactions.Add(actionnumber, ai);
 								ac.Add(ai);
 							}
 							else
 							{
 								// Failure
 								if(de.Value != null)
 									General.ErrorLogger.Add(ErrorType.Warning, "Structure 'linedeftypes' contains invalid types in game configuration '" + this.Name + "'. All types must be expanded structures.");
 							}
 						}
 					}
 					foreach(DictionaryEntry de in catdic)
 					{
 						// Check if the item key is numeric
 						if(int.TryParse(de.Key.ToString(),
 							NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite,
 							CultureInfo.InvariantCulture, out actionnumber))
 						{
 							// Check if the item value is a structure
 							if(de.Value is IDictionary)
 							{
 								// Make the line type
 								ai = new LinedefActionInfo(actionnumber, cfg, cde.Key.ToString(), enums);
 
 								// Add action to category and sorted list
 								sortedlinedefactions.Add(ai);
 								linedefactions.Add(actionnumber, ai);
 								ac.Add(ai);
 							}
 							else
 							{
 								// Failure
 								if(de.Value != null)
 									General.ErrorLogger.Add(ErrorType.Warning, "Structure 'linedeftypes' contains invalid types in game configuration '" + this.Name + "'. All types must be expanded structures.");
 							}
 						}
 					}
 				}
 			}
 			foreach(DictionaryEntry cde in dic)
 			{
 				if(cde.Value is IDictionary)
 				{
 					// Read category title
 					string cattitle = cfg.ReadSetting("linedeftypes." + cde.Key + ".title", "");
 
 					// Make or get category
 					if(cats.ContainsKey(cde.Key.ToString()))
 						ac = cats[cde.Key.ToString()];
 					else
 					{
 						ac = new LinedefActionCategory(cde.Key.ToString(), cattitle);
 						cats.Add(cde.Key.ToString(), ac);
 					}
 
 					// Go for all line types in category
 					IDictionary catdic = cfg.ReadSetting("linedeftypes." + cde.Key, new Hashtable());
 					foreach(DictionaryEntry de in catdic)
 					{
 						// Check if the item key is numeric
 						if(int.TryParse(de.Key.ToString(),
 							NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite,
 							CultureInfo.InvariantCulture, out actionnumber))
 						{
 							// Check if the item value is a structure
 							if(de.Value is IDictionary)
 							{
 								// Make the line type
 								ai = new LinedefActionInfo(actionnumber, cfg, cde.Key.ToString(), enums);
 
 								// Add action to category and sorted list
 								sortedlinedefactions.Add(ai);
 								linedefactions.Add(actionnumber, ai);
 								ac.Add(ai);
 							}
 							else
 							{
 								// Failure
 								if(de.Value != null)
 									General.ErrorLogger.Add(ErrorType.Warning, "Structure 'linedeftypes' contains invalid types in game configuration '" + this.Name + "'. All types must be expanded structures.");
 							}
 						}
 					}
 				}
 			}
 
 			// Sort the actions list
 			sortedlinedefactions.Sort();
 			
 			// Copy categories to final list
 			actioncategories.Clear();
 			actioncategories.AddRange(cats.Values);
 
 			// Sort the categories list
 			actioncategories.Sort();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1338" endline="1373">
<![CDATA[
 
 		// This renders a filled rectangle with given color
 		public void RenderRectangleFilled(RectangleF rect, PixelColor c, bool transformrect, ImageData texture)
 		{
 			// Calculate positions
 			Vector2D lt = new Vector2D(rect.Left, rect.Top);
 			Vector2D rb = new Vector2D(rect.Right, rect.Bottom);
 			if(transformrect)
 			{
 				lt = lt.GetTransformed(translatex, translatey, scale, -scale);
 				rb = rb.GetTransformed(translatex, translatey, scale, -scale);
 			}
 
 			// Make quad
 			FlatQuad quad = new FlatQuad(PrimitiveType.TriangleStrip, lt.x, lt.y, rb.x, rb.y);
 			quad.SetColors(c.ToInt());
 
 			// Set renderstates for rendering
 			graphics.Device.SetRenderState(RenderState.CullMode, Cull.None);
 			graphics.Device.SetRenderState(RenderState.ZEnable, false);
 			graphics.Device.SetRenderState(RenderState.AlphaBlendEnable, false);
 			graphics.Device.SetRenderState(RenderState.AlphaTestEnable, false);
 			graphics.Device.SetRenderState(RenderState.TextureFactor, -1);
 			graphics.Device.SetRenderState(RenderState.FogEnable, false);
 			SetWorldTransformation(false);
 			graphics.Device.SetTexture(0, texture.Texture);
 			graphics.Shaders.Display2D.Texture1 = texture.Texture;
 			graphics.Shaders.Display2D.SetSettings(1f, 1f, 0f, 1f, General.Settings.ClassicBilinear);
 
 			// Draw
 			graphics.Shaders.Display2D.Begin();
 			graphics.Shaders.Display2D.BeginPass(1);
 			quad.Render(graphics);
 			graphics.Shaders.Display2D.EndPass();
 			graphics.Shaders.Display2D.End();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\FlatImage.cs" startline="46" endline="117">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			Stream lumpdata;
 			MemoryStream mem;
 			IImageReader reader;
 			byte[] membytes;
 			
 			// Leave when already loaded
 			if(this.IsImageLoaded) return;
 
 			lock(this)
 			{
 				// Get the lump data stream
 				lumpdata = General.Map.Data.GetFlatData(Name);
 				if(lumpdata != null)
 				{
 					// Copy lump data to memory
 					lumpdata.Seek(0, SeekOrigin.Begin);
 					membytes = new byte[(int)lumpdata.Length];
 					lumpdata.Read(membytes, 0, (int)lumpdata.Length);
 					mem = new MemoryStream(membytes);
 					mem.Seek(0, SeekOrigin.Begin);
 
 					// Get a reader for the data
 					reader = ImageDataFormat.GetImageReader(mem, ImageDataFormat.DOOMFLAT, General.Map.Data.Palette);
 					if(reader is UnknownImageReader)
 					{
 						// Data is in an unknown format!
 						General.ErrorLogger.Add(ErrorType.Error, "Flat lump '" + Name + "' data format could not be read. Does this lump contain valid picture data at all?");
 						bitmap = null;
 					}
 					else
 					{
 						// Read data as bitmap
 						mem.Seek(0, SeekOrigin.Begin);
 						if(bitmap != null) bitmap.Dispose();
 						bitmap = reader.ReadAsBitmap(mem);
 					}
 
 					// Done
 					mem.Dispose();
 
 					if(bitmap != null)
 					{
 						// Get width and height from image and set the scale
 						width = bitmap.Size.Width;
 						height = bitmap.Size.Height;
 						scale.x = General.Map.Config.DefaultFlatScale;
 						scale.y = General.Map.Config.DefaultFlatScale;
 					}
 					else
 					{
 						loadfailed = true;
 					}
 				}
 				else
 				{
 					// Missing a patch lump!
 					General.ErrorLogger.Add(ErrorType.Error, "Missing flat lump '" + Name + "'. Did you forget to include required resources?");
 					loadfailed = true;
 				}
 
 				// Pass on to base
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ColormapImage.cs" startline="46" endline="117">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			Stream lumpdata;
 			MemoryStream mem;
 			IImageReader reader;
 			byte[] membytes;
 
 			// Leave when already loaded
 			if(this.IsImageLoaded) return;
 
 			lock(this)
 			{
 				// Get the lump data stream
 				lumpdata = General.Map.Data.GetColormapData(Name);
 				if(lumpdata != null)
 				{
 					// Copy lump data to memory
 					lumpdata.Seek(0, SeekOrigin.Begin);
 					membytes = new byte[(int)lumpdata.Length];
 					lumpdata.Read(membytes, 0, (int)lumpdata.Length);
 					mem = new MemoryStream(membytes);
 					mem.Seek(0, SeekOrigin.Begin);
 
 					// Get a reader for the data
 					reader = ImageDataFormat.GetImageReader(mem, ImageDataFormat.DOOMCOLORMAP, General.Map.Data.Palette);
 					if(reader is UnknownImageReader)
 					{
 						// Data is in an unknown format!
 						General.ErrorLogger.Add(ErrorType.Error, "Colormap lump '" + Name + "' data format could not be read. Does this lump contain valid colormap data at all?");
 						bitmap = null;
 					}
 					else
 					{
 						// Read data as bitmap
 						mem.Seek(0, SeekOrigin.Begin);
 						if(bitmap != null) bitmap.Dispose();
 						bitmap = reader.ReadAsBitmap(mem);
 					}
 
 					// Done
 					mem.Dispose();
 
 					if(bitmap != null)
 					{
 						// Get width and height from image and set the scale
 						width = bitmap.Size.Width;
 						height = bitmap.Size.Height;
 						scale.x = General.Map.Config.DefaultFlatScale;
 						scale.y = General.Map.Config.DefaultFlatScale;
 					}
 					else
 					{
 						loadfailed = true;
 					}
 				}
 				else
 				{
 					// Missing a patch lump!
 					General.ErrorLogger.Add(ErrorType.Error, "Missing colormap lump '" + Name + "'. Did you forget to include required resources?");
 					loadfailed = true;
 				}
 
 				// Pass on to base
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2070" endline="2117">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Edit Menu
 
 		// This sets up the edit menu
 		private void UpdateEditMenu()
 		{
 			// No edit menu when no map open
 			//menuedit.Visible = (General.Map != null);
 			
 			// Enable/disable items
 			itemundo.Enabled = (General.Map != null) && (General.Map.UndoRedo.NextUndo != null);
 			itemredo.Enabled = (General.Map != null) && (General.Map.UndoRedo.NextRedo != null);
 			itemcut.Enabled = (General.Map != null) && (General.Editing.Mode != null) && General.Editing.Mode.Attributes.AllowCopyPaste;
 			itemcopy.Enabled = (General.Map != null) && (General.Editing.Mode != null) && General.Editing.Mode.Attributes.AllowCopyPaste;
 			itempaste.Enabled = (General.Map != null) && (General.Editing.Mode != null) && General.Editing.Mode.Attributes.AllowCopyPaste;
 			itempastespecial.Enabled = (General.Map != null) && (General.Editing.Mode != null) && General.Editing.Mode.Attributes.AllowCopyPaste;
 			itemmapoptions.Enabled = (General.Map != null);
 			itemsnaptogrid.Enabled = (General.Map != null);
 			itemautomerge.Enabled = (General.Map != null);
 			itemgridsetup.Enabled = (General.Map != null);
 			itemgridinc.Enabled = (General.Map != null);
 			itemgriddec.Enabled = (General.Map != null);
 
 			// Determine undo description
 			if(itemundo.Enabled)
 				itemundo.Text = "Undo " + General.Map.UndoRedo.NextUndo.Description;
 			else
 				itemundo.Text = "Undo";
 
 			// Determine redo description
 			if(itemredo.Enabled)
 				itemredo.Text = "Redo " + General.Map.UndoRedo.NextRedo.Description;
 			else
 				itemredo.Text = "Redo";
 			
 			// Toolbar icons
 			buttonundo.Enabled = itemundo.Enabled;
 			buttonredo.Enabled = itemredo.Enabled;
 			buttonundo.ToolTipText = itemundo.Text;
 			buttonredo.ToolTipText = itemredo.Text;
 			buttonsnaptogrid.Enabled = (General.Map != null);
 			buttonautomerge.Enabled = (General.Map != null);
 			buttoncut.Enabled = itemcut.Enabled;
 			buttoncopy.Enabled = itemcopy.Enabled;
 			buttonpaste.Enabled = itempaste.Enabled;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="102" endline="201">
<![CDATA[
 
 		// Configuration item selected
 		private void listconfigs_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			NodebuilderInfo ni;
 			
 			// Item selected?
 			if(listconfigs.SelectedItems.Count > 0)
 			{
 				// Enable panels
 				tabs.Enabled = true;
 
 				preventchanges = true;
 				
 				// Get config info of selected item
 				configinfo = listconfigs.SelectedItems[0].Tag as ConfigurationInfo;
 				
 				// Load the game configuration
 				gameconfig = new GameConfiguration(General.LoadGameConfiguration(configinfo.Filename));
 
 				// Set defaults
 				configinfo.ApplyDefaults(gameconfig);
 				
 				// Fill resources list
 				configdata.EditResourceLocationList(configinfo.Resources);
 				
 				// Go for all nodebuilder save items
 				nodebuildersave.SelectedIndex = -1;
 				for(int i = 0; i < nodebuildersave.Items.Count; i++)
 				{
 					// Get item
 					ni = nodebuildersave.Items[i] as NodebuilderInfo;
 					
 					// Item matches configuration setting?
 					if(string.Compare(ni.Name, configinfo.NodebuilderSave, false) == 0)
 					{
 						// Select this item
 						nodebuildersave.SelectedIndex = i;
 						break;
 					}
 				}
 				for(int i = 0; i < nodebuildersave.Items.Count; i++)
 				{
 					// Get item
 					ni = nodebuildersave.Items[i] as NodebuilderInfo;
 					
 					// Item matches configuration setting?
 					if(string.Compare(ni.Name, configinfo.NodebuilderSave, false) == 0)
 					{
 						// Select this item
 						nodebuildersave.SelectedIndex = i;
 						break;
 					}
 				}
 				
 				// Go for all nodebuilder test items
 				nodebuildertest.SelectedIndex = -1;
 				for(int i = 0; i < nodebuildertest.Items.Count; i++)
 				{
 					// Get item
 					ni = nodebuildertest.Items[i] as NodebuilderInfo;
 					
 					// Item matches configuration setting?
 					if(string.Compare(ni.Name, configinfo.NodebuilderTest, false) == 0)
 					{
 						// Select this item
 						nodebuildertest.SelectedIndex = i;
 						break;
 					}
 				}
 				for(int i = 0; i < nodebuildertest.Items.Count; i++)
 				{
 					// Get item
 					ni = nodebuildertest.Items[i] as NodebuilderInfo;
 					
 					// Item matches configuration setting?
 					if(string.Compare(ni.Name, configinfo.NodebuilderTest, false) == 0)
 					{
 						// Select this item
 						nodebuildertest.SelectedIndex = i;
 						break;
 					}
 				}
 				
 				// Fill skills list
 				skill.ClearInfo();
 				skill.AddInfo(gameconfig.Skills.ToArray());
 				
 				// Set test application and parameters
 				if(!configinfo.CustomParameters)
 				{
 					configinfo.TestParameters = gameconfig.TestParameters;
 					configinfo.TestShortPaths = gameconfig.TestShortPaths;
 				}
 				testapplication.Text = configinfo.TestProgram;
 				testparameters.Text = configinfo.TestParameters;
 				shortpaths.Checked = configinfo.TestShortPaths;
 				int skilllevel = configinfo.TestSkill;
 				skill.Value = skilllevel - 1;
 				skill.Value = skilllevel;
 				customparameters.Checked = configinfo.CustomParameters;
 				
 				// Fill texture sets list
 				listtextures.Items.Clear();
 				foreach(DefinedTextureSet ts in configinfo.TextureSets)
 				{
 					ListViewItem item = listtextures.Items.Add(ts.Name);
 					item.Tag = ts;
 					item.ImageIndex = 0;
 				}
 				foreach(DefinedTextureSet ts in configinfo.TextureSets)
 				{
 					ListViewItem item = listtextures.Items.Add(ts.Name);
 					item.Tag = ts;
 					item.ImageIndex = 0;
 				}
 				listtextures.Sort();
 				
 				// Go for all the editing modes in the list
 				foreach(ListViewItem lvi in listmodes.Items)
 				{
 					EditModeInfo emi = (lvi.Tag as EditModeInfo);
 					lvi.Checked = (configinfo.EditModes.ContainsKey(emi.Type.FullName) && configinfo.EditModes[emi.Type.FullName]);
 				}
 				foreach(ListViewItem lvi in listmodes.Items)
 				{
 					EditModeInfo emi = (lvi.Tag as EditModeInfo);
 					lvi.Checked = (configinfo.EditModes.ContainsKey(emi.Type.FullName) && configinfo.EditModes[emi.Type.FullName]);
 				}
 				
 				// Fill start modes
 				RefillStartModes();
 
 				// Done
 				preventchanges = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="968" endline="989">
<![CDATA[
 
 		// This deserializes sidedefs
 		private void ReadSidedefs(DeserializerStream stream, Linedef[] linedefsarray, Sector[] sectorsarray)
 		{
 			int c; stream.rInt(out c);
 
 			// Go for all sidedefs
 			for(int i = 0; i < c; i++)
 			{
 				int lineindex, sectorindex;
 				bool front;
 				
 				stream.rInt(out lineindex);
 
 				stream.rInt(out sectorindex);
 
 				stream.rBool(out front);
 
 				Sidedef sd = CreateSidedef(linedefsarray[lineindex], front, sectorsarray[sectorindex]);
 				sd.ReadWrite(stream);
 			}
 			for(int i = 0; i < c; i++)
 			{
 				int lineindex, sectorindex;
 				bool front;
 				
 				stream.rInt(out lineindex);
 
 				stream.rInt(out sectorindex);
 
 				stream.rBool(out front);
 
 				Sidedef sd = CreateSidedef(linedefsarray[lineindex], front, sectorsarray[sectorindex]);
 				sd.ReadWrite(stream);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\GridSetupForm.cs" startline="150" endline="176">
<![CDATA[
 
 		// Apply
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Apply
 			General.Map.Grid.SetGridSize(gridsize.GetResult(General.Map.Grid.GridSize));
 			General.Map.Grid.SetBackgroundView(backoffsetx.GetResult(General.Map.Grid.BackgroundX),
 											   backoffsety.GetResult(General.Map.Grid.BackgroundY),
 											   backscalex.GetResult((int)(General.Map.Grid.BackgroundScaleX * 100.0f)) / 100.0f,
 											   backscaley.GetResult((int)(General.Map.Grid.BackgroundScaleY * 100.0f)) / 100.0f);
 			
 			// Background image?
 			if(showbackground.Checked)
 			{
 				// Set background image
 				General.Map.Grid.SetBackground(backgroundname, backgroundsource);
 			}
 			else
 			{
 				// No background image
 				General.Map.Grid.SetBackground(null, 0);
 			}
 
 			// Done
 			DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\VertexEditForm.cs" startline="119" endline="158">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Events
 
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			string undodesc = "vertex";
 
 			// Verify the coordinates
 			if((positionx.GetResultFloat(0.0f) < General.Map.FormatInterface.MinCoordinate) || (positionx.GetResultFloat(0.0f) > General.Map.FormatInterface.MaxCoordinate) ||
 			   (positiony.GetResultFloat(0.0f) < General.Map.FormatInterface.MinCoordinate) || (positiony.GetResultFloat(0.0f) > General.Map.FormatInterface.MaxCoordinate))
 			{
 				General.ShowWarningMessage("Vertex coordinates must be between " + General.Map.FormatInterface.MinCoordinate + " and " + General.Map.FormatInterface.MaxCoordinate + ".", MessageBoxButtons.OK);
 				return;
 			}
 			
 			// Make undo
 			if(vertices.Count > 1) undodesc = vertices.Count + " vertices";
 			General.Map.UndoRedo.CreateUndo("Edit " + undodesc);
 
 			// Go for all vertices
 			foreach(Vertex v in vertices)
 			{
 				// Apply position
 				Vector2D p = new Vector2D();
 				p.x = General.Clamp(positionx.GetResultFloat(v.Position.x), (float)General.Map.FormatInterface.MinCoordinate, (float)General.Map.FormatInterface.MaxCoordinate);
 				p.y = General.Clamp(positiony.GetResultFloat(v.Position.y), (float)General.Map.FormatInterface.MinCoordinate, (float)General.Map.FormatInterface.MaxCoordinate);
 				v.Move(p);
 				
 				// Custom fields
 				fieldslist.Apply(v.Fields);
 			}
 			foreach(Vertex v in vertices)
 			{
 				// Apply position
 				Vector2D p = new Vector2D();
 				p.x = General.Clamp(positionx.GetResultFloat(v.Position.x), (float)General.Map.FormatInterface.MinCoordinate, (float)General.Map.FormatInterface.MaxCoordinate);
 				p.y = General.Clamp(positiony.GetResultFloat(v.Position.y), (float)General.Map.FormatInterface.MinCoordinate, (float)General.Map.FormatInterface.MaxCoordinate);
 				v.Move(p);
 				
 				// Custom fields
 				fieldslist.Apply(v.Fields);
 			}
 			
 			// Done
 			General.Map.IsChanged = true;
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1326" endline="1357">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Tools
 
 		/// <summary>
 		/// This finds the first IWAD resource.
 		/// Returns false when not found.
 		/// </summary>
 		public bool FindFirstIWAD(out DataLocation result)
 		{
 			// Go for all data containers
 			foreach(DataReader dr in containers)
 			{
 				// Container is a WAD file?
 				if(dr is WADReader)
 				{
 					// Check if it is an IWAD
 					WADReader wr = dr as WADReader;
 					if(wr.IsIWAD)
 					{
 						// Return location!
 						result = wr.Location;
 						return true;
 					}
 				}
 			}
 			foreach(DataReader dr in containers)
 			{
 				// Container is a WAD file?
 				if(dr is WADReader)
 				{
 					// Check if it is an IWAD
 					WADReader wr = dr as WADReader;
 					if(wr.IsIWAD)
 					{
 						// Return location!
 						result = wr.Location;
 						return true;
 					}
 				}
 			}
 
 			// No IWAD found
 			result = new DataLocation();
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="989" endline="996">
<![CDATA[
 
 		internal void PlayPrpLinedef(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			Linedef l = General.Map.Map.GetLinedefByIndex(index);
 			l.ReadWrite(ds);
 			l.Marked = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1154" endline="1161">
<![CDATA[
 
 		internal void PlayPrpSidedef(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			Sidedef s = General.Map.Map.GetSidedefByIndex(index);
 			s.ReadWrite(ds);
 			s.Marked = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1238" endline="1245">
<![CDATA[
 
 		internal void PlayPrpSector(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			Sector s = General.Map.Map.GetSectorByIndex(index);
 			s.ReadWrite(ds);
 			s.Marked = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1298" endline="1305">
<![CDATA[
 
 		internal void PlayPrpThing(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			Thing t = General.Map.Map.GetThingByIndex(index);
 			t.ReadWrite(ds);
 			t.Marked = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="875" endline="884">
<![CDATA[
 
 		internal void PlayAddVertex(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			//LogRecordInfo("PLY
 			Vertex v = General.Map.Map.GetVertexByIndex(index);
 			foreach(Linedef l in v.Linedefs) l.Marked = true;
 			v.Dispose();
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypesManager.cs" startline="123" endline="142">
<![CDATA[
 
 		// This returns the type handler for a custom universal field
 		public TypeHandler GetFieldHandler(int type, object defaultsetting)
 		{
 			Type t = typeof(NullHandler);
 			TypeHandlerAttribute ta = null;
 
 			// Do we have a handler type for this?
 			if(handlertypes.ContainsKey(type))
 			{
 				ta = handlertypes[type];
 				t = ta.Type;
 			}
 
 			// Create instance
 			TypeHandler th = (TypeHandler)General.ThisAssembly.CreateInstance(t.FullName);
 			th.SetupField(ta, null);
 			th.SetValue(defaultsetting);
 			return th;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="640" endline="659">
<![CDATA[
 		
 		// This returns all action names for a given key
 		public string[] GetActionNamesByKey(int key)
 		{
 			List<string> actionnames = new List<string>();
 			
 			// Go for all actions
 			foreach(KeyValuePair<string, Action> a in actions)
 			{
 				// This action is associated with this key?
 				if(a.Value.KeyMatches(key))
 				{
 					// List short name
 					actionnames.Add(a.Value.ShortName);
 				}
 			}
 			foreach(KeyValuePair<string, Action> a in actions)
 			{
 				// This action is associated with this key?
 				if(a.Value.KeyMatches(key))
 				{
 					// List short name
 					actionnames.Add(a.Value.ShortName);
 				}
 			}
 
 			// Return result;
 			return actionnames.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="365" endline="385">
<![CDATA[
 
 		// This removes all sidedefs which has a sidedefs on the other side
 		// of the same line that refers to the same sector. These are removed
 		// because they are useless and make the triangulation inefficient.
 		private void RemoveDoubleSidedefReferences(Dictionary<Sidedef, bool> todosides, ICollection<Sidedef> sides)
 		{
 			// Go for all sides
 			foreach(Sidedef sd in sides)
 			{
 				// Double sided?
 				if(sd.Other != null)
 				{
 					// Referring to the same sector on both sides?
 					if(sd.Sector == sd.Other.Sector)
 					{
 						// Remove this one
 						todosides.Remove(sd);
 					}
 				}
 			}
 			foreach(Sidedef sd in sides)
 			{
 				// Double sided?
 				if(sd.Other != null)
 				{
 					// Referring to the same sector on both sides?
 					if(sd.Sector == sd.Other.Sector)
 					{
 						// Remove this one
 						todosides.Remove(sd);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="114" endline="134">
<![CDATA[
 
 		#endregion
 
 		#region ================== Management
 
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Clear all filters and add the new ones
 			General.Map.ConfigSettings.ThingsFilters.Clear();
 			foreach(ListViewItem item in listfilters.Items)
 				General.Map.ConfigSettings.ThingsFilters.Add(item.Tag as ThingsFilter);
 			foreach(ListViewItem item in listfilters.Items)
 				General.Map.ConfigSettings.ThingsFilters.Add(item.Tag as ThingsFilter);
 			
 			// Update stuff
 			General.Map.ChangeThingFilter(new NullThingsFilter());
 			General.MainWindow.UpdateThingsFilters();
 			
 			// Close
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\CheckboxArrayControl.cs" startline="54" endline="72">
<![CDATA[
 
 		// This adds a checkbox
 		public CheckBox Add(string text, object tag)
 		{
 			// Make new checkbox
 			CheckBox c = new CheckBox();
 			c.AutoSize = true;
 			//c.FlatStyle = FlatStyle.System;
 			c.UseVisualStyleBackColor = true;
 			c.Text = text;
 			c.Tag = tag;
 
 			// Add to list
 			this.Controls.Add(c);
 			checkboxes.Add(c);
 
 			// Return checkbox
 			return c;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="452" endline="463">
<![CDATA[
 		
 		// This copies images from a collection unless they already exist in the list
 		private void AddImagesToList(Dictionary<long, ImageData> targetlist, ICollection<ImageData> sourcelist)
 		{
 			// Go for all source images
 			foreach(ImageData src in sourcelist)
 			{
 				// Check if exists in target list
 				if(!targetlist.ContainsKey(src.LongName))
 					targetlist.Add(src.LongName, src);
 			}
 			foreach(ImageData src in sourcelist)
 			{
 				// Check if exists in target list
 				if(!targetlist.ContainsKey(src.LongName))
 					targetlist.Add(src.LongName, src);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="806" endline="820">
<![CDATA[
 
 		// This serializes vertices
 		private void WriteVertices(SerializerStream stream)
 		{
 			stream.wInt(numvertices);
 
 			// Go for all vertices
 			int index = 0;
 			foreach(Vertex v in vertices)
 			{
 				v.SerializedIndex = index++;
 				
 				v.ReadWrite(stream);
 			}
 			foreach(Vertex v in vertices)
 			{
 				v.SerializedIndex = index++;
 				
 				v.ReadWrite(stream);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="858" endline="872">
<![CDATA[
 
 		// This serializes sectors
 		private void WriteSectors(SerializerStream stream)
 		{
 			stream.wInt(numsectors);
 
 			// Go for all sectors
 			int index = 0;
 			foreach(Sector s in sectors)
 			{
 				s.SerializedIndex = index++;
 
 				s.ReadWrite(stream);
 			}
 			foreach(Sector s in sectors)
 			{
 				s.SerializedIndex = index++;
 
 				s.ReadWrite(stream);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.cs" startline="301" endline="324">
<![CDATA[
 		
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			ConfigurationInfo ci;
 			
 			// Apply configuration items
 			foreach(ListViewItem lvi in listconfigs.Items)
 			{
 				// Get configuration item
 				ci = lvi.Tag as ConfigurationInfo;
 				
 				// Find same configuration info in originals
 				foreach(ConfigurationInfo oci in General.Configs)
 				{
 					// Apply settings when they match
 					if(string.Compare(ci.Filename, oci.Filename) == 0) oci.Apply(ci);
 				}
 				foreach(ConfigurationInfo oci in General.Configs)
 				{
 					// Apply settings when they match
 					if(string.Compare(ci.Filename, oci.Filename) == 0) oci.Apply(ci);
 				}
 			}
 			foreach(ListViewItem lvi in listconfigs.Items)
 			{
 				// Get configuration item
 				ci = lvi.Tag as ConfigurationInfo;
 				
 				// Find same configuration info in originals
 				foreach(ConfigurationInfo oci in General.Configs)
 				{
 					// Apply settings when they match
 					if(string.Compare(ci.Filename, oci.Filename) == 0) oci.Apply(ci);
 				}
 			}
 			
 			// Close
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditingManager.cs" startline="144" endline="156">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Switch Actions
 		
 		// This unbinds all editing mode switch actions
 		private void UnbindSwitchActions()
 		{
 			foreach(EditModeInfo emi in allmodes)
 			{
 				emi.UnbindSwitchAction();
 			}
 			foreach(EditModeInfo emi in allmodes)
 			{
 				emi.UnbindSwitchAction();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="300" endline="308">
<![CDATA[
 
 		// This refreshes all settings
 		public void RefreshSettings()
 		{
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				t.RefreshSettings();
 			}
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				t.RefreshSettings();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\PluginManager.cs" startline="222" endline="232">
<![CDATA[
 
 		#endregion
 
 		#region ================== Events
 		
 		public bool ModeChanges(EditMode oldmode, EditMode newmode)
 		{
 			bool result = true;
 			foreach(Plugin p in plugins) result &= p.Plug.OnModeChange(oldmode, newmode);
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\EnumList.cs" startline="83" endline="100">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This gets an item by value
 		// Returns null when item could not be found
 		public EnumItem GetByEnumIndex(string value)
 		{
 			// Find the item
 			foreach(EnumItem i in this)
 			{
 				if(i.Value == value) return i;
 			}
 			foreach(EnumItem i in this)
 			{
 				if(i.Value == value) return i;
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="349" endline="380">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Colormaps
 
 		// This loads the textures
 		public override ICollection<ImageData> LoadColormaps()
 		{
 			Dictionary<long, ImageData> images = new Dictionary<long, ImageData>();
 			ICollection<ImageData> collection;
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Load from wad files
 			// Note the backward order, because the last wad's images have priority
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				collection = wads[i].LoadColormaps();
 				AddImagesToList(images, collection);
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				collection = wads[i].LoadColormaps();
 				AddImagesToList(images, collection);
 			}
 
 			// Add images from flats directory
 			collection = LoadDirectoryImages(COLORMAPS_DIR, ImageDataFormat.DOOMCOLORMAP, true);
 			AddImagesToList(images, collection);
 
 			// Add images to the container-specific texture set
 			foreach(ImageData img in images.Values)
 				textureset.AddFlat(img);
 			foreach(ImageData img in images.Values)
 				textureset.AddFlat(img);
 
 			return new List<ImageData>(images.Values);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="490" endline="520">
<![CDATA[
 
 		// This writes the VERTEXES to WAD file
 		private void WriteVertices(MapSet map, int position, IDictionary maplumps)
 		{
 			MemoryStream mem;
 			BinaryWriter writer;
 			Lump lump;
 			int insertpos;
 
 			// Create memory to write to
 			mem = new MemoryStream();
 			writer = new BinaryWriter(mem, WAD.ENCODING);
 
 			// Go for all vertices
 			foreach(Vertex v in map.Vertices)
 			{
 				// Write properties to stream
 				writer.Write((Int16)(int)Math.Round(v.Position.x));
 				writer.Write((Int16)(int)Math.Round(v.Position.y));
 			}
 			foreach(Vertex v in map.Vertices)
 			{
 				// Write properties to stream
 				writer.Write((Int16)(int)Math.Round(v.Position.x));
 				writer.Write((Int16)(int)Math.Round(v.Position.y));
 			}
 
 			// Find insert position and remove old lump
 			insertpos = MapManager.RemoveSpecificLump(wad, "VERTEXES", position, MapManager.TEMP_MAP_HEADER, maplumps);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 
 			// Create the lump from memory
 			lump = wad.Insert("VERTEXES", insertpos, (int)mem.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			mem.WriteTo(lump.Stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="353" endline="366">
<![CDATA[
 		
 		// This updates the sector when changes have been made
 		public void UpdateCache()
 		{
 			// Update if needed
 			if(updateneeded)
 			{
 				Triangulate();
 				
 				CreateSurfaces();
 
 				General.Map.CRenderer2D.Surfaces.UnlockBuffers();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.Designer.cs" startline="22" endline="87">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.splitter = new CodeImp.DoomBuilder.Controls.TransparentPanel();
 			this.tabs = new CodeImp.DoomBuilder.Controls.DockersTabsControl();
 			this.SuspendLayout();
 			// 
 			// splitter
 			// 
 			this.splitter.BackColor = System.Drawing.SystemColors.Control;
 			this.splitter.Cursor = System.Windows.Forms.Cursors.SizeWE;
 			this.splitter.Dock = System.Windows.Forms.DockStyle.Left;
 			this.splitter.Location = new System.Drawing.Point(0, 0);
 			this.splitter.Name = "splitter";
 			this.splitter.Size = new System.Drawing.Size(4, 541);
 			this.splitter.TabIndex = 1;
 			this.splitter.MouseLeave += new System.EventHandler(this.RaiseMouseContainerLeave);
 			this.splitter.MouseMove += new System.Windows.Forms.MouseEventHandler(this.splitter_MouseMove);
 			this.splitter.MouseDown += new System.Windows.Forms.MouseEventHandler(this.splitter_MouseDown);
 			this.splitter.MouseUp += new System.Windows.Forms.MouseEventHandler(this.splitter_MouseUp);
 			this.splitter.MouseEnter += new System.EventHandler(this.RaiseMouseContainerEnter);
 			// 
 			// tabs
 			// 
 			this.tabs.Alignment = System.Windows.Forms.TabAlignment.Right;
 			this.tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tabs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabs.ItemSize = new System.Drawing.Size(100, 26);
 			this.tabs.Location = new System.Drawing.Point(0, 0);
 			this.tabs.Margin = new System.Windows.Forms.Padding(0);
 			this.tabs.Multiline = true;
 			this.tabs.Name = "tabs";
 			this.tabs.Padding = new System.Drawing.Point(10, 5);
 			this.tabs.SelectedIndex = 0;
 			this.tabs.Size = new System.Drawing.Size(308, 541);
 			this.tabs.TabIndex = 0;
 			this.tabs.TabStop = false;
 			this.tabs.MouseLeave += new System.EventHandler(this.RaiseMouseContainerLeave);
 			this.tabs.Selected += new System.Windows.Forms.TabControlEventHandler(this.tabs_Selected);
 			this.tabs.Enter += new System.EventHandler(this.tabs_Enter);
 			this.tabs.MouseUp += new System.Windows.Forms.MouseEventHandler(this.tabs_MouseUp);
 			this.tabs.SelectedIndexChanged += new System.EventHandler(this.tabs_SelectedIndexChanged);
 			this.tabs.MouseEnter += new System.EventHandler(this.RaiseMouseContainerEnter);
 			// 
 			// DockersControl
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.splitter);
 			this.Controls.Add(this.tabs);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.Name = "DockersControl";
 			this.Size = new System.Drawing.Size(308, 541);
 			this.MouseLeave += new System.EventHandler(this.RaiseMouseContainerLeave);
 			this.MouseEnter += new System.EventHandler(this.RaiseMouseContainerEnter);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="794" endline="805">
<![CDATA[
 
 		// This serializes things
 		private void WriteThings(SerializerStream stream)
 		{
 			stream.wInt(numthings);
 			
 			// Go for all things
 			foreach(Thing t in things)
 			{
 				t.ReadWrite(stream);
 			}
 			foreach(Thing t in things)
 			{
 				t.ReadWrite(stream);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="489" endline="530">
<![CDATA[
 
 		// This opens the given file, returns null when failed
 		public ScriptFileDocumentTab OpenFile(string filename)
 		{
 			ScriptConfiguration foundconfig = new ScriptConfiguration();
 
 			// Find the most suitable script configuration to use
 			foreach(ScriptConfiguration cfg in scriptconfigs)
 			{
 				foreach(string ext in cfg.Extensions)
 				{
 					// Use this configuration if the extension matches
 					if(filename.EndsWith("." + ext, true, CultureInfo.InvariantCulture))
 					{
 						foundconfig = cfg;
 						break;
 					}
 				}
 				foreach(string ext in cfg.Extensions)
 				{
 					// Use this configuration if the extension matches
 					if(filename.EndsWith("." + ext, true, CultureInfo.InvariantCulture))
 					{
 						foundconfig = cfg;
 						break;
 					}
 				}
 			}
 			foreach(ScriptConfiguration cfg in scriptconfigs)
 			{
 				foreach(string ext in cfg.Extensions)
 				{
 					// Use this configuration if the extension matches
 					if(filename.EndsWith("." + ext, true, CultureInfo.InvariantCulture))
 					{
 						foundconfig = cfg;
 						break;
 					}
 				}
 			}
 
 			// Create new document
 			ScriptFileDocumentTab t = new ScriptFileDocumentTab(this, foundconfig);
 			if(t.Open(filename))
 			{
 				// Mark any errors this script may have
 				if(compilererrors != null)
 					t.MarkScriptErrors(compilererrors);
 
 				// Add to tabs
 				tabs.TabPages.Add(t);
 				tabs.SelectedTab = t;
 
 				// Done
 				UpdateToolbar(true);
 				return t;
 			}
 			else
 			{
 				// Failed
 				return null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2322" endline="2332">
<![CDATA[
 
 		private void addShortcuts(Menu m)
 		{
 			foreach(MenuItem mi in m.MenuItems)
 			{
 				if(mi.Shortcut != Shortcut.None)
 					AddIgnoredKey(mi.Shortcut);
 				if(mi.MenuItems.Count > 0)
 					addShortcuts(mi);
 			}
 			foreach(MenuItem mi in m.MenuItems)
 			{
 				if(mi.Shortcut != Shortcut.None)
 					AddIgnoredKey(mi.Shortcut);
 				if(mi.MenuItems.Count > 0)
 					addShortcuts(mi);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamWriter.cs" startline="155" endline="174">
<![CDATA[
 
 		// This adds vertices
 		private void WriteVertices(ICollection<Vertex> vertices, UniversalParser textmap)
 		{
 			// Go for all vertices
 			foreach(Vertex v in vertices)
 			{
 				// Make collection
 				UniversalCollection coll = new UniversalCollection();
 				coll.Add("x", v.Position.x);
 				coll.Add("y", v.Position.y);
 				coll.Comment = v.Index.ToString();
 
 				// Add custom fields
 				AddCustomFields(v, "vertex", coll);
 
 				// Store
 				textmap.Root.Add("vertex", coll);
 			}
 			foreach(Vertex v in vertices)
 			{
 				// Make collection
 				UniversalCollection coll = new UniversalCollection();
 				coll.Add("x", v.Position.x);
 				coll.Add("y", v.Position.y);
 				coll.Comment = v.Index.ToString();
 
 				// Add custom fields
 				AddCustomFields(v, "vertex", coll);
 
 				// Store
 				textmap.Root.Add("vertex", coll);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\PasteOptionsControl.Designer.cs" startline="22" endline="136">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.sectorheightsgroup = new System.Windows.Forms.GroupBox();
 			this.adjustheights = new System.Windows.Forms.CheckBox();
 			this.tagsgroup = new System.Windows.Forms.GroupBox();
 			this.removeactions = new System.Windows.Forms.CheckBox();
 			this.removetags = new System.Windows.Forms.RadioButton();
 			this.renumbertags = new System.Windows.Forms.RadioButton();
 			this.keeptags = new System.Windows.Forms.RadioButton();
 			this.sectorheightsgroup.SuspendLayout();
 			this.tagsgroup.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// sectorheightsgroup
 			// 
 			this.sectorheightsgroup.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.sectorheightsgroup.Controls.Add(this.adjustheights);
 			this.sectorheightsgroup.Location = new System.Drawing.Point(0, 164);
 			this.sectorheightsgroup.Name = "sectorheightsgroup";
 			this.sectorheightsgroup.Size = new System.Drawing.Size(443, 83);
 			this.sectorheightsgroup.TabIndex = 3;
 			this.sectorheightsgroup.TabStop = false;
 			this.sectorheightsgroup.Text = " Floor and Ceiling heights ";
 			// 
 			// adjustheights
 			// 
 			this.adjustheights.AutoSize = true;
 			this.adjustheights.Location = new System.Drawing.Point(30, 39);
 			this.adjustheights.Name = "adjustheights";
 			this.adjustheights.Size = new System.Drawing.Size(292, 17);
 			this.adjustheights.TabIndex = 0;
 			this.adjustheights.Text = "Adjust heights to match relatively with surrounding sector";
 			this.adjustheights.UseVisualStyleBackColor = true;
 			// 
 			// tagsgroup
 			// 
 			this.tagsgroup.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tagsgroup.Controls.Add(this.removeactions);
 			this.tagsgroup.Controls.Add(this.removetags);
 			this.tagsgroup.Controls.Add(this.renumbertags);
 			this.tagsgroup.Controls.Add(this.keeptags);
 			this.tagsgroup.Location = new System.Drawing.Point(0, 0);
 			this.tagsgroup.Name = "tagsgroup";
 			this.tagsgroup.Size = new System.Drawing.Size(443, 158);
 			this.tagsgroup.TabIndex = 2;
 			this.tagsgroup.TabStop = false;
 			this.tagsgroup.Text = " Tags and Actions ";
 			// 
 			// removeactions
 			// 
 			this.removeactions.AutoSize = true;
 			this.removeactions.Location = new System.Drawing.Point(30, 117);
 			this.removeactions.Name = "removeactions";
 			this.removeactions.Size = new System.Drawing.Size(116, 17);
 			this.removeactions.TabIndex = 3;
 			this.removeactions.Text = "Remove all actions";
 			this.removeactions.UseVisualStyleBackColor = true;
 			// 
 			// removetags
 			// 
 			this.removetags.AutoSize = true;
 			this.removetags.Location = new System.Drawing.Point(30, 81);
 			this.removetags.Name = "removetags";
 			this.removetags.Size = new System.Drawing.Size(101, 17);
 			this.removetags.TabIndex = 2;
 			this.removetags.TabStop = true;
 			this.removetags.Text = "Remove all tags";
 			this.removetags.UseVisualStyleBackColor = true;
 			// 
 			// renumbertags
 			// 
 			this.renumbertags.AutoSize = true;
 			this.renumbertags.Location = new System.Drawing.Point(30, 57);
 			this.renumbertags.Name = "renumbertags";
 			this.renumbertags.Size = new System.Drawing.Size(271, 17);
 			this.renumbertags.TabIndex = 1;
 			this.renumbertags.TabStop = true;
 			this.renumbertags.Text = "Renumber tags to resolve conflicts with existing tags";
 			this.renumbertags.UseVisualStyleBackColor = true;
 			// 
 			// keeptags
 			// 
 			this.keeptags.AutoSize = true;
 			this.keeptags.Location = new System.Drawing.Point(30, 33);
 			this.keeptags.Name = "keeptags";
 			this.keeptags.Size = new System.Drawing.Size(217, 17);
 			this.keeptags.TabIndex = 0;
 			this.keeptags.TabStop = true;
 			this.keeptags.Text = "Keep tags the same as they were copied";
 			this.keeptags.UseVisualStyleBackColor = true;
 			// 
 			// PasteOptionsControl
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.sectorheightsgroup);
 			this.Controls.Add(this.tagsgroup);
 			this.Name = "PasteOptionsControl";
 			this.Size = new System.Drawing.Size(443, 282);
 			this.sectorheightsgroup.ResumeLayout(false);
 			this.sectorheightsgroup.PerformLayout();
 			this.tagsgroup.ResumeLayout(false);
 			this.tagsgroup.PerformLayout();
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2702" endline="2726">
<![CDATA[
 		
 		// Processor event
 		private void processor_Tick(object sender, EventArgs e)
 		{
 			Vector2D deltamouse;
 			double curtime = General.Clock.GetCurrentTime();
 			double deltatime = curtime - lastupdatetime;
 			lastupdatetime = curtime;
 			
 			// In exclusive mouse mode?
 			if(mouseinput != null)
 			{
 				// Process mouse input
 				deltamouse = mouseinput.Process();
 				if((General.Map != null) && (General.Editing.Mode != null))
 				{
 					General.Plugins.OnEditMouseInput(deltamouse);
 					General.Editing.Mode.OnMouseInput(deltamouse);
 				}
 			}
 			
 			// Process signal
 			if((General.Map != null) && (General.Editing.Mode != null))
 				General.Editing.Mode.OnProcess(deltatime);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoSnapshot.cs" startline="141" endline="165">
<![CDATA[
 
 		// This loads the snapshot from harddisk into memory
 		internal void RestoreFromFile()
 		{
 			lock(this)
 			{
 				if(isdisposed) return;
 				if(!isondisk) return;
 				isondisk = false;
 
 				// Read the file data
 				MemoryStream instream = new MemoryStream(File.ReadAllBytes(filename));
 				
 				// Decompress data
 				MemoryStream outstream = new MemoryStream((int)instream.Length * 4);
 				instream.Seek(0, SeekOrigin.Begin);
 				BZip2.Decompress(instream, outstream);
 				recstream = new MemoryStream(outstream.ToArray());
 				
 				// Clean up
 				instream.Dispose();
 				File.Delete(filename);
 				filename = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\EffectBrowserForm.cs" startline="8" endline="126">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public EffectBrowserForm(int effect)
 		{
 			GeneralizedOption o;
 			ListViewItem n;
 			bool selected = false;
 			
 			// Initialize
 			InitializeComponent();
 
 			// Make array references for controls
 			options = new ComboBox[] { option0, option1, option2, option3, option4, option5, option6, option7 };
 			optionlbls = new Label[] { option0label, option1label, option2label, option3label, option4label,
 									   option5label, option6label, option7label };
 			
 			// Go for all predefined effects
 			foreach(SectorEffectInfo si in General.Map.Config.SortedSectorEffects)
 			{
 				// Create effect
 				n = effects.Items.Add(si.Index.ToString());
 				n.SubItems.Add(si.Title);
 				n.Tag = si;
 				if(si.Index == effect)
 				{
 					selected = true;
 					n.Selected = true;
 				}
 			}
 			foreach(SectorEffectInfo si in General.Map.Config.SortedSectorEffects)
 			{
 				// Create effect
 				n = effects.Items.Add(si.Index.ToString());
 				n.SubItems.Add(si.Title);
 				n.Tag = si;
 				if(si.Index == effect)
 				{
 					selected = true;
 					n.Selected = true;
 				}
 			}
 			
 			// Using generalized effects?
 			if(General.Map.Config.GeneralizedEffects)
 			{
 				// Go for all options
 				for(int i = 0; i < MAX_OPTIONS; i++)
 				{
 					// Option used in selected category?
 					if(i < General.Map.Config.GenEffectOptions.Count)
 					{
 						o = General.Map.Config.GenEffectOptions[i];
 						
 						// Setup controls
 						optionlbls[i].Text = o.Name + "
 						options[i].Items.Clear();
 						options[i].Items.AddRange(o.Bits.ToArray());
 						
 						// Show option
 						options[i].Visible = true;
 						optionlbls[i].Visible = true;
 
 						if(effects.SelectedItems.Count == 0)
 						{
 							// Go for all bits
 							foreach(GeneralizedBit ab in o.Bits)
 							{
 								// Select this setting if matches
 								if((effect & ab.Index) == ab.Index) options[i].SelectedItem = ab;
 							}
 							foreach(GeneralizedBit ab in o.Bits)
 							{
 								// Select this setting if matches
 								if((effect & ab.Index) == ab.Index) options[i].SelectedItem = ab;
 							}
 						}
 					}
 					else
 					{
 						// Hide option
 						options[i].Visible = false;
 						optionlbls[i].Visible = false;
 					}
 				}
 				for(int i = 0; i < MAX_OPTIONS; i++)
 				{
 					// Option used in selected category?
 					if(i < General.Map.Config.GenEffectOptions.Count)
 					{
 						o = General.Map.Config.GenEffectOptions[i];
 						
 						// Setup controls
 						optionlbls[i].Text = o.Name + "
 						options[i].Items.Clear();
 						options[i].Items.AddRange(o.Bits.ToArray());
 						
 						// Show option
 						options[i].Visible = true;
 						optionlbls[i].Visible = true;
 
 						if(effects.SelectedItems.Count == 0)
 						{
 							// Go for all bits
 							foreach(GeneralizedBit ab in o.Bits)
 							{
 								// Select this setting if matches
 								if((effect & ab.Index) == ab.Index) options[i].SelectedItem = ab;
 							}
 						}
 					}
 					else
 					{
 						// Hide option
 						options[i].Visible = false;
 						optionlbls[i].Visible = false;
 					}
 				}
 				
 				// Open the generalized tab when given effect is generalized
 				if(!selected) tabs.SelectedTab = tabgeneralized;
 			}
 			else
 			{
 				// Remove generalized tab
 				tabs.TabPages.Remove(tabgeneralized);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\GridSetup.cs" startline="269" endline="284">
<![CDATA[
 		
 		// This changes grid size
 		// Note
 		[BeginAction("gridinc")]
 		internal void DecreaseGrid()
 		{
 			// Not lower than 1
 			if(gridsize >= 2)
 			{
 				// Change grid
 				SetGridSize(gridsize >> 1);
 				
 				// Redraw display
 				General.MainWindow.RedrawDisplay();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ErrorsForm.cs" startline="112" endline="130">
<![CDATA[
 		
 		// Copy selection
 		private void copyselected_Click(object sender, EventArgs e)
 		{
 			StringBuilder str = new StringBuilder("");
 			if(grid.SelectedCells.Count > 0)
 			{
 				Clipboard.Clear();
 				foreach(DataGridViewCell c in grid.SelectedCells)
 				{
 					if(c.ValueType != typeof(Image))
 					{
 						if(str.Length > 0) str.Append("\r\n");
 						str.Append(c.Value.ToString());
 					}
 				}
 				foreach(DataGridViewCell c in grid.SelectedCells)
 				{
 					if(c.ValueType != typeof(Image))
 					{
 						if(str.Length > 0) str.Append("\r\n");
 						str.Append(c.Value.ToString());
 					}
 				}
 				Clipboard.SetText(str.ToString());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2636" endline="2670">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Processing
 		
 		// This is called from the background thread when images are loaded
 		// but only when first loaded or when dimensions were changed
 		internal void ImageDataLoaded(ImageData img)
 		{
 			// Image is used in the map?
 			if((img != null) && img.UsedInMap && !img.IsDisposed)
 			{
 				// Go for all setors
 				bool updated = false;
 				foreach(Sector s in General.Map.Map.Sectors)
 				{
 					// Update floor buffer if needed
 					if(s.LongFloorTexture == img.LongName)
 					{
 						s.UpdateFloorSurface();
 						updated = true;
 					}
 					
 					// Update ceiling buffer if needed
 					if(s.LongCeilTexture == img.LongName)
 					{
 						s.UpdateCeilingSurface();
 						updated = true;
 					}
 				}
 				foreach(Sector s in General.Map.Map.Sectors)
 				{
 					// Update floor buffer if needed
 					if(s.LongFloorTexture == img.LongName)
 					{
 						s.UpdateFloorSurface();
 						updated = true;
 					}
 					
 					// Update ceiling buffer if needed
 					if(s.LongCeilTexture == img.LongName)
 					{
 						s.UpdateCeilingSurface();
 						updated = true;
 					}
 				}
 				
 				// If we made updates, redraw the screen
 				if(updated) DelayedRedraw();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\TransparentPanel.cs" startline="57" endline="64">
<![CDATA[
 		}
 
 		// Disable background drawing by overriding this
 		protected override void OnPaintBackground(PaintEventArgs e)
 		{
 			if(BackColor != Color.Transparent)
 				e.Graphics.Clear(BackColor);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="389" endline="398">
<![CDATA[
 		
 		// Splitting ends
 		private void splitter_MouseUp(object sender, MouseEventArgs e)
 		{
 			splitter.BackColor = Color.Transparent;
 			tabs.Invalidate(true);
 			this.Update();
 			General.MainWindow.RedrawDisplay();
 			General.MainWindow.Update();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="434" endline="446">
<![CDATA[
 		
 		// This does an implicit save on all documents that use implicit saving
 		// Call this to save the lumps before disposing the panel!
 		public void ImplicitSave()
 		{
 			// Save all scripts
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				if(!t.ExplicitSave) t.Save();
 			}
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				if(!t.ExplicitSave) t.Save();
 			}
 			
 			UpdateToolbar(false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="362" endline="372">
<![CDATA[
 		
 		// This writes all explicitly opened files to the configuration
 		public void WriteOpenFilesToConfiguration()
 		{
 			List<string> files = new List<string>();
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				if(t.ExplicitSave) files.Add(t.Filename);
 			}
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				if(t.ExplicitSave) files.Add(t.Filename);
 			}
 			General.Map.Options.ScriptFiles = files;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1876" endline="1898">
<![CDATA[
 
 		/// <summary>This filters vertices by a rectangular area.</summary>
 		public static ICollection<Vertex> FilterByArea(ICollection<Vertex> verts, ref RectangleF area)
 		{
 			ICollection<Vertex> newverts = new List<Vertex>(verts.Count);
 
 			// Go for all verts
 			foreach(Vertex v in verts)
 			{
 				// Within rect?
 				if((v.Position.x >= area.Left) &&
 				   (v.Position.x <= area.Right) &&
 				   (v.Position.y >= area.Top) &&
 				   (v.Position.y <= area.Bottom))
 				{
 					// The vertex is in the area
 					newverts.Add(v);
 				}
 			}
 			foreach(Vertex v in verts)
 			{
 				// Within rect?
 				if((v.Position.x >= area.Left) &&
 				   (v.Position.x <= area.Right) &&
 				   (v.Position.y >= area.Top) &&
 				   (v.Position.y <= area.Bottom))
 				{
 					// The vertex is in the area
 					newverts.Add(v);
 				}
 			}
 
 			// Return result
 			return newverts;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="467" endline="498">
<![CDATA[
 
 		// This writes the VERTEXES to WAD file
 		private void WriteVertices(MapSet map, int position, IDictionary maplumps)
 		{
 			MemoryStream mem;
 			BinaryWriter writer;
 			Lump lump;
 			int insertpos;
 
 			// Create memory to write to
 			mem = new MemoryStream();
 			writer = new BinaryWriter(mem, WAD.ENCODING);
 
 			// Go for all vertices
 			foreach(Vertex v in map.Vertices)
 			{
 				// Write properties to stream
 				writer.Write((Int16)(int)Math.Round(v.Position.x));
 				writer.Write((Int16)(int)Math.Round(v.Position.y));
 			}
 			foreach(Vertex v in map.Vertices)
 			{
 				// Write properties to stream
 				writer.Write((Int16)(int)Math.Round(v.Position.x));
 				writer.Write((Int16)(int)Math.Round(v.Position.y));
 			}
 
 			// Find insert position and remove old lump
 			insertpos = MapManager.RemoveSpecificLump(wad, "VERTEXES", position, MapManager.TEMP_MAP_HEADER, maplumps);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 
 			// Create the lump from memory
 			lump = wad.Insert("VERTEXES", insertpos, (int)mem.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			mem.WriteTo(lump.Stream);
 			mem.Flush();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="863" endline="882">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Lumps
 		
 		// This returns a copy of the requested lump stream data
 		// This is copied from the temp wad file and returns null when the lump is not found
 		public MemoryStream GetLumpData(string lumpname)
 		{
 			Lump l = tempwad.FindLump(lumpname);
 			if(l != null)
 			{
 				l.Stream.Seek(0, SeekOrigin.Begin);
 				return new MemoryStream(l.Stream.ReadAllBytes());
 			}
 			else
 			{
 				return null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Compilers\Compiler.cs" startline="90" endline="128">
<![CDATA[
 		
 		// Disposer
 		public virtual void Dispose()
 		{
 			if(!isdisposed)
 			{
 				Exception deleteerror = null;
 				double starttime = General.Clock.GetCurrentTime();
 				
 				do
 				{
 					try
 					{
 						// Remove temporary directory
 						General.WriteLogLine("Removing temporary compiler files...");
 						tempdir.Delete(true);
 						deleteerror = null;
 					}
 					catch(Exception e)
 					{
 						deleteerror = e;
 					}
 
 					// Bail out when it takes too long
 					if((General.Clock.GetCurrentTime() - starttime) > 2000) break;
 				}
 				while(deleteerror != null);
 				
 				// Report error if we have one
 				if(deleteerror != null)
 				{
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to remove temporary compiler files. " + deleteerror.GetType().Name + "
 					General.WriteLogLine(deleteerror.StackTrace);
 				}
 				
 				// Disposed
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="123" endline="153">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Palette
 
 		// This loads the PLAYPAL palette
 		public override Playpal LoadPalette()
 		{
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 			
 			// Palette from wad(s)
 			Playpal palette = null;
 			foreach(WADReader wr in wads)
 			{
 				Playpal wadpalette = wr.LoadPalette();
 				if(wadpalette != null) return wadpalette;
 			}
 			foreach(WADReader wr in wads)
 			{
 				Playpal wadpalette = wr.LoadPalette();
 				if(wadpalette != null) return wadpalette;
 			}
 			
 			// Find in root directory
 			string foundfile = FindFirstFile("PLAYPAL", false);
 			if((foundfile != null) && FileExists(foundfile))
 			{
 				MemoryStream stream = LoadFile(foundfile);
 				palette = new Playpal(stream);
 				stream.Dispose();
 			}
 			
 			// Done
 			return palette;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditingManager.cs" startline="233" endline="246">
<![CDATA[
 		
 		// This returns specific editing mode info by name
 		internal EditModeInfo GetEditModeInfo(Type modetype)
 		{
 			// Find the edit mode
 			foreach(EditModeInfo emi in usedmodes)
 			{
 				// Mode matches class name?
 				if(emi.Type == modetype) return emi;
 			}
 			foreach(EditModeInfo emi in usedmodes)
 			{
 				// Mode matches class name?
 				if(emi.Type == modetype) return emi;
 			}
 			
 			// No such mode found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\PluginManager.cs" startline="209" endline="221">
<![CDATA[
 		
 		// This returns a plugin by assembly, or null when plugin cannot be found
 		public Plugin FindPluginByAssembly(Assembly assembly)
 		{
 			// Go for all plugins the find the one with matching assembly
 			foreach(Plugin p in plugins)
 			{
 				if(p.Assembly == assembly) return p;
 			}
 			foreach(Plugin p in plugins)
 			{
 				if(p.Assembly == assembly) return p;
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="619" endline="634">
<![CDATA[
 
 		// Save All clicked
 		private void buttonsaveall_Click(object sender, EventArgs e)
 		{
 			// Save all scripts
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				// Use explicit save for this script?
 				if(t.ExplicitSave)
 				{
 					if(!SaveScript(t)) break;
 				}
 			}
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				// Use explicit save for this script?
 				if(t.ExplicitSave)
 				{
 					if(!SaveScript(t)) break;
 				}
 			}
 			
 			UpdateToolbar(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1845" endline="1864">
<![CDATA[
 
 		/// <summary>This filters lines by a rectangular area.</summary>
 		public static ICollection<Linedef> FilterByArea(ICollection<Linedef> lines, ref RectangleF area)
 		{
 			ICollection<Linedef> newlines = new List<Linedef>(lines.Count);
 			
 			// Go for all lines
 			foreach(Linedef l in lines)
 			{
 				// Check the cs field bits
 				if((GetCSFieldBits(l.Start, ref area) & GetCSFieldBits(l.End, ref area)) == 0)
 				{
 					// The line could be in the area
 					newlines.Add(l);
 				}
 			}
 			foreach(Linedef l in lines)
 			{
 				// Check the cs field bits
 				if((GetCSFieldBits(l.Start, ref area) & GetCSFieldBits(l.End, ref area)) == 0)
 				{
 					// The line could be in the area
 					newlines.Add(l);
 				}
 			}
 			
 			// Return result
 			return newlines;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="447" endline="487">
<![CDATA[
 
 		// This takes an outer polygon and a set of inner polygons to start cutting on
 		private void MergeInnerPolys(EarClipPolygon p)
 		{
 			LinkedList<EarClipPolygon> todo = new LinkedList<EarClipPolygon>(p.Children);
 			LinkedListNode<EarClipVertex> start;
 			LinkedListNode<EarClipPolygon> ip;
 			LinkedListNode<EarClipPolygon> found;
 			LinkedListNode<EarClipVertex> foundstart;
 			
 			// Continue until no more inner polygons to process
 			while(todo.Count > 0)
 			{
 				// Find the inner polygon with the highest x vertex
 				found = null;
 				foundstart = null;
 				ip = todo.First;
 				while(ip != null)
 				{
 					start = FindRightMostVertex(ip.Value);
 					if((foundstart == null) || (start.Value.Position.x > foundstart.Value.Position.x))
 					{
 						// Found a better start
 						found = ip;
 						foundstart = start;
 					}
 					
 					// Next!
 					ip = ip.Next;
 				}
 				while(ip != null)
 				{
 					start = FindRightMostVertex(ip.Value);
 					if((foundstart == null) || (start.Value.Position.x > foundstart.Value.Position.x))
 					{
 						// Found a better start
 						found = ip;
 						foundstart = start;
 					}
 					
 					// Next!
 					ip = ip.Next;
 				}
 				
 				// Remove from todo list
 				todo.Remove(found);
 
 				// Get cut start and end
 				SplitOuterWithInner(foundstart, p, found.Value);
 			}
 			while(todo.Count > 0)
 			{
 				// Find the inner polygon with the highest x vertex
 				found = null;
 				foundstart = null;
 				ip = todo.First;
 				while(ip != null)
 				{
 					start = FindRightMostVertex(ip.Value);
 					if((foundstart == null) || (start.Value.Position.x > foundstart.Value.Position.x))
 					{
 						// Found a better start
 						found = ip;
 						foundstart = start;
 					}
 					
 					// Next!
 					ip = ip.Next;
 				}
 				
 				// Remove from todo list
 				todo.Remove(found);
 
 				// Get cut start and end
 				SplitOuterWithInner(foundstart, p, found.Value);
 			}
 			
 			// Remove the children, they should be merged in the polygon by now
 			p.Children.Clear();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1876" endline="1908">
<![CDATA[
 
 		// This fixes short action names to fully qualified
 		// action names on menu item tags
 		private void RenameTagsToFullActions(ToolStripItemCollection items, Plugin plugin)
 		{
 			// Go for all controls to find menu items
 			foreach(ToolStripItem item in items)
 			{
 				// Tag set for this item?
 				if((item.Tag != null) && (item.Tag is string))
 				{
 					// Get the action name
 					string actionname = item.Tag.ToString();
 
 					// Check if the tag doe not already begin with the assembly name
 					if(!(item.Tag as string).StartsWith(plugin.Name + "_", StringComparison.InvariantCultureIgnoreCase))
 					{
 						// Change the tag to a fully qualified action name
 						item.Tag = plugin.Name.ToLowerInvariant() + "_" + (item.Tag as string);
 					}
 				}
 
 				// This is a menu item?
 				if(item is ToolStripMenuItem)
 				{
 					// Get the item in proper type
 					ToolStripMenuItem menuitem = (item as ToolStripMenuItem);
 					
 					// Recursively perform operation on child menu items
 					RenameTagsToFullActions(menuitem.DropDownItems, plugin);
 				}
 			}
 			foreach(ToolStripItem item in items)
 			{
 				// Tag set for this item?
 				if((item.Tag != null) && (item.Tag is string))
 				{
 					// Get the action name
 					string actionname = item.Tag.ToString();
 
 					// Check if the tag doe not already begin with the assembly name
 					if(!(item.Tag as string).StartsWith(plugin.Name + "_", StringComparison.InvariantCultureIgnoreCase))
 					{
 						// Change the tag to a fully qualified action name
 						item.Tag = plugin.Name.ToLowerInvariant() + "_" + (item.Tag as string);
 					}
 				}
 
 				// This is a menu item?
 				if(item is ToolStripMenuItem)
 				{
 					// Get the item in proper type
 					ToolStripMenuItem menuitem = (item as ToolStripMenuItem);
 					
 					// Recursively perform operation on child menu items
 					RenameTagsToFullActions(menuitem.DropDownItems, plugin);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\ErrorLogger.cs" startline="103" endline="112">
<![CDATA[
 		
 		// This returns the list of errors
 		internal List<ErrorItem> GetErrors()
 		{
 			lock(this)
 			{
 				List<ErrorItem> copylist = new List<ErrorItem>(errors);
 				return copylist;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1972" endline="1986">
<![CDATA[
 		
 		// This saves the recent files list
 		private void SaveRecentFiles()
 		{
 			// Go for all items
 			for(int i = 0; i < MAX_RECENT_FILES; i++)
 			{
 				// Recent file set?
 				if(recentitems[i].Text != "")
 				{
 					// Save to configuration
 					General.Settings.WriteSetting("recentfiles.file" + i, recentitems[i].Tag.ToString());
 				}
 			}
 			for(int i = 0; i < MAX_RECENT_FILES; i++)
 			{
 				// Recent file set?
 				if(recentitems[i].Text != "")
 				{
 					// Save to configuration
 					General.Settings.WriteSetting("recentfiles.file" + i, recentitems[i].Tag.ToString());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1764" endline="1805">
<![CDATA[
 
 		// This opens a URL in the default browser
 		public static void OpenWebsite(string url)
 		{
 			RegistryKey key = null;
 			Process p = null;
 			string browser;
 
 			try
 			{
 				// Get the registry key where default browser is stored
 				key = Registry.ClassesRoot.OpenSubKey(@"HTTP\shell\open\command", false);
 
 				// Trim off quotes
 				browser = key.GetValue(null).ToString().ToLower().Replace("\"", "");
 
 				// String doesnt end in EXE?
 				if(!browser.EndsWith("exe"))
 				{
 					// Get rid of everything after the ".exe"
 					browser = browser.Substring(0, browser.LastIndexOf(".exe") + 4);
 				}
 			}
 			finally
 			{
 				// Clean up
 				if(key != null) key.Close();
 			}
 
 			try
 			{
 				// Fork a process
 				p = new Process();
 				p.StartInfo.FileName = browser;
 				p.StartInfo.Arguments = url;
 				p.Start();
 			}
 			catch(Exception) { }
 
 			// Clean up
 			if(p != null) p.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CopyPasteManager.cs" startline="206" endline="255">
<![CDATA[
 		
 		// This performs the copy. Returns false when copy was cancelled.
 		private bool DoCopySelection(string desc)
 		{
 			// Check if possible to copy/paste
 			if(General.Editing.Mode.Attributes.AllowCopyPaste)
 			{
 				// Let the plugins know
 				if(General.Plugins.OnCopyBegin())
 				{
 					// Ask the editing mode to prepare selection for copying.
 					// The edit mode should mark all vertices, lines and sectors
 					// that need to be copied.
 					if(General.Editing.Mode.OnCopyBegin())
 					{
 						General.MainWindow.DisplayStatus(StatusType.Action, desc);
 
 						// Copy the marked geometry
 						// This links sidedefs that are not linked to a marked sector to a virtual sector
 						MapSet copyset = General.Map.Map.CloneMarked();
 
 						// Convert flags and activations to UDMF fields, if needed
 						if(!(General.Map.FormatInterface is UniversalMapSetIO)) copyset.TranslateToUDMF();
 
 						// Write data to stream
 						MemoryStream memstream = new MemoryStream();
 						UniversalStreamWriter writer = new UniversalStreamWriter();
 						writer.RememberCustomTypes = false;
 						writer.Write(copyset, memstream, null);
 
 						// Set on clipboard
 						Clipboard.SetData(CLIPBOARD_DATA_FORMAT, memstream);
 
 						// Done
 						memstream.Dispose();
 						General.Editing.Mode.OnCopyEnd();
 						General.Plugins.OnCopyEnd();
 						return true;
 					}
 				}
 			}
 			else
 			{
 				// Copy not allowed
 				General.MessageBeep(MessageBeepType.Warning);
 			}
 			
 			// Aborted
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.cs" startline="239" endline="277">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 
 		// This selects the next texture with the same name as the selected texture
 		public void GoToNextSameTexture()
 		{
 			if(list.SelectedItems.Count > 0)
 			{
 				ListViewItem selected = list.SelectedItems[0];
 				bool foundselected = false;
 				foreach(ListViewItem n in visibleitems)
 				{
 					if((n.Text == selected.Text) && foundselected)
 					{
 						// This is the next item
 						n.Selected = true;
 						n.EnsureVisible();
 						return;
 					}
 					
 					if(n == selected)
 						foundselected = true;
 				}
 				foreach(ListViewItem n in visibleitems)
 				{
 					if((n.Text == selected.Text) && foundselected)
 					{
 						// This is the next item
 						n.Selected = true;
 						n.EnsureVisible();
 						return;
 					}
 					
 					if(n == selected)
 						foundselected = true;
 				}
 
 				// Start from the top
 				foreach(ListViewItem n in visibleitems)
 				{
 					if((n.Text == selected.Text) && foundselected)
 					{
 						// This is the next item
 						n.Selected = true;
 						n.EnsureVisible();
 						return;
 					}
 				}
 				foreach(ListViewItem n in visibleitems)
 				{
 					if((n.Text == selected.Text) && foundselected)
 					{
 						// This is the next item
 						n.Selected = true;
 						n.EnsureVisible();
 						return;
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptFileDocumentTab.cs" startline="79" endline="139">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		// This compiles the script file
 		public override void Compile()
 		{
 			string inputfile, outputfile;
 			Compiler compiler;
 			
 			// List of errors
 			List<CompilerError> errors = new List<CompilerError>();
 			
 			try
 			{
 				// Initialize compiler
 				compiler = config.Compiler.Create();
 			}
 			catch(Exception e)
 			{
 				// Fail
 				errors.Add(new CompilerError("Unable to initialize compiler. " + e.GetType().Name + "
 				return;
 			}
 			
 			// Copy the source file into the temporary directory
 			inputfile = Path.Combine(compiler.Location, Path.GetFileName(filepathname));
 			File.Copy(filepathname, inputfile);
 			
 			// Make random output filename
 			outputfile = General.MakeTempFilename(compiler.Location, "tmp");
 
 			// Run compiler
 			compiler.Parameters = config.Parameters;
 			compiler.InputFile = Path.GetFileName(inputfile);
 			compiler.OutputFile = Path.GetFileName(outputfile);
 			compiler.SourceFile = filepathname;
 			compiler.WorkingDirectory = Path.GetDirectoryName(inputfile);
 			if(compiler.Run())
 			{
 				// Fetch errors
 				foreach(CompilerError e in compiler.Errors)
 				{
 					CompilerError newerr = e;
 
 					// If the error's filename equals our temporary file,
 					// replace it with the original source filename
 					if(string.Compare(e.filename, inputfile, true) == 0)
 						newerr.filename = filepathname;
 
 					errors.Add(newerr);
 				}
 				foreach(CompilerError e in compiler.Errors)
 				{
 					CompilerError newerr = e;
 
 					// If the error's filename equals our temporary file,
 					// replace it with the original source filename
 					if(string.Compare(e.filename, inputfile, true) == 0)
 						newerr.filename = filepathname;
 
 					errors.Add(newerr);
 				}
 			}
 			
 			// Dispose compiler
 			compiler.Dispose();
 			
 			// Feed errors to panel
 			panel.ShowErrors(errors);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\ThingClassHandler.cs" startline="55" endline="87">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 
 		public override void Browse(IWin32Window parent)
 		{
 			int tid = 0;
 			
 			// Find the thing with this class name
 			foreach(ThingTypeInfo t in General.Map.Data.ThingTypes)
 			{
 				if((t.Actor != null) && (string.Compare(t.Actor.ClassName, value, true) == 0))
 				{
 					tid = t.Index;
 					break;
 				}
 			}
 			foreach(ThingTypeInfo t in General.Map.Data.ThingTypes)
 			{
 				if((t.Actor != null) && (string.Compare(t.Actor.ClassName, value, true) == 0))
 				{
 					tid = t.Index;
 					break;
 				}
 			}
 			
 			//tid = ThingBrowserForm.BrowseThing(parent, tid);
 			ThingBrowserForm f = new ThingBrowserForm(tid);
 			if(f.ShowDialog(Form.ActiveForm) == DialogResult.OK)
 			{
 				// Find the class name for this thing
 				ThingTypeInfo t = General.Map.Data.GetThingInfo(f.SelectedType);
 				if(t.Actor != null)
 					this.value = t.Actor.ClassName;
 				else
 					this.value = "";
 			}
 			
 			f.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2440" endline="2471">
<![CDATA[
 
 		/// <summary>This finds the vertex closest to the specified position.</summary>
 		public static Vertex NearestVertexSquareRange(ICollection<Vertex> selection, Vector2D pos, float maxrange)
 		{
 			RectangleF range = RectangleF.FromLTRB(pos.x - maxrange, pos.y - maxrange, pos.x + maxrange, pos.y + maxrange);
 			Vertex closest = null;
 			float distance = float.MaxValue;
 			float d;
 
 			// Go for all vertices in selection
 			foreach(Vertex v in selection)
 			{
 				// Within range?
 				if((v.Position.x >= range.Left) && (v.Position.x <= range.Right))
 				{
 					if((v.Position.y >= range.Top) && (v.Position.y <= range.Bottom))
 					{
 						// Close than previous find?
 						d = Math.Abs(v.Position.x - pos.x) + Math.Abs(v.Position.y - pos.y);
 						if(d < distance)
 						{
 							// This one is closer
 							closest = v;
 							distance = d;
 						}
 					}
 				}
 			}
 			foreach(Vertex v in selection)
 			{
 				// Within range?
 				if((v.Position.x >= range.Left) && (v.Position.x <= range.Right))
 				{
 					if((v.Position.y >= range.Top) && (v.Position.y <= range.Bottom))
 					{
 						// Close than previous find?
 						d = Math.Abs(v.Position.x - pos.x) + Math.Abs(v.Position.y - pos.y);
 						if(d < distance)
 						{
 							// This one is closer
 							closest = v;
 							distance = d;
 						}
 					}
 				}
 			}
 
 			// Return result
 			return closest;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="106" endline="119">
<![CDATA[
 
 		// This returns a list of all files optionally with subdirectories included
 		public List<string> GetAllFiles(bool subdirectories)
 		{
 			if(subdirectories)
 				return GetAllFiles();
 			else
 			{
 				List<string> files = new List<string>(entries.Length);
 				for(int i = 0; i < entries.Length; i++)
 					if(entries[i].path.Length == 0) files.Add(entries[i].filepathname);
 				for(int i = 0; i < entries.Length; i++)
 					if(entries[i].path.Length == 0) files.Add(entries[i].filepathname);
 				return files;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="242" endline="283">
<![CDATA[
 		
 		// This returns the selected value
 		public int GetResult(int original)
 		{
 			int result = 0;
 			
 			// Strip prefixes
 			string str = combobox.Text.Trim().ToLowerInvariant();
 			str = str.TrimStart('+', '-');
 			int num = original;
 
 			// Anything in the box?
 			if(combobox.Text.Trim().Length > 0)
 			{
 				// Prefixed with ++?
 				if(combobox.Text.Trim().StartsWith("++"))
 				{
 					// Add number to original
 					if(!int.TryParse(str, out num)) num = 0;
 					result = original + num;
 				}
 				// Prefixed with --?
 				else if(combobox.Text.Trim().StartsWith("--"))
 				{
 					// Subtract number from original
 					if(!int.TryParse(str, out num)) num = 0;
 					result = original - num;
 				}
 				else
 				{
 					// Return the value
 					result = typehandler.GetIntValue();
 				}
 			}
 			else
 			{
 				// Just return the original
 				result = original;
 			}
 
 			return General.Clamp(result, General.Map.FormatInterface.MinArgument, General.Map.FormatInterface.MaxArgument);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1358" endline="1387">
<![CDATA[
 
 		// This signals the background thread to update the
 		// used-in-map status on all textures and flats
 		public void UpdateUsedTextures()
 		{
 			lock(usedimages)
 			{
 				usedimages.Clear();
 
 				// Go through the map to find the used textures
 				foreach(Sidedef sd in General.Map.Map.Sidedefs)
 				{
 					// Add used textures to dictionary
 					if(sd.HighTexture.Length > 0) usedimages[sd.LongHighTexture] = 0;
 					if(sd.LowTexture.Length > 0) usedimages[sd.LongMiddleTexture] = 0;
 					if(sd.MiddleTexture.Length > 0) usedimages[sd.LongLowTexture] = 0;
 				}
 				foreach(Sidedef sd in General.Map.Map.Sidedefs)
 				{
 					// Add used textures to dictionary
 					if(sd.HighTexture.Length > 0) usedimages[sd.LongHighTexture] = 0;
 					if(sd.LowTexture.Length > 0) usedimages[sd.LongMiddleTexture] = 0;
 					if(sd.MiddleTexture.Length > 0) usedimages[sd.LongLowTexture] = 0;
 				}
 
 				// Go through the map to find the used flats
 				foreach(Sector s in General.Map.Map.Sectors)
 				{
 					// Add used flats to dictionary
 					usedimages[s.LongFloorTexture] = 0;
 					usedimages[s.LongCeilTexture] = 0;
 				}
 				foreach(Sector s in General.Map.Map.Sectors)
 				{
 					// Add used flats to dictionary
 					usedimages[s.LongFloorTexture] = 0;
 					usedimages[s.LongCeilTexture] = 0;
 				}
 				
 				// Notify the background thread that it needs to update the images
 				updatedusedtextures = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditingManager.cs" startline="247" endline="290">
<![CDATA[
 		
 		// This is called when the editing modes must update
 		internal void UpdateCurrentEditModes()
 		{
 			// Unbind editing mode switch actions
 			UnbindSwitchActions();
 			
 			// Rebuild list of used modes
 			usedmodes.Clear();
 			if(General.Map != null)
 			{
 				foreach(EditModeInfo emi in allmodes)
 				{
 					// Include the mode when it is listed and enabled
 					// Also include the mode when it is not optional
 					if( (General.Map.ConfigSettings.EditModes.ContainsKey(emi.Type.FullName) &&
 					     General.Map.ConfigSettings.EditModes[emi.Type.FullName]) || !emi.IsOptional )
 					{
 						// Add the mode to be used and bind switch action
 						usedmodes.Add(emi);
 					}
 				}
 				foreach(EditModeInfo emi in allmodes)
 				{
 					// Include the mode when it is listed and enabled
 					// Also include the mode when it is not optional
 					if( (General.Map.ConfigSettings.EditModes.ContainsKey(emi.Type.FullName) &&
 					     General.Map.ConfigSettings.EditModes[emi.Type.FullName]) || !emi.IsOptional )
 					{
 						// Add the mode to be used and bind switch action
 						usedmodes.Add(emi);
 					}
 				}
 			}
 			
 			// Bind switch action for used modes
 			BindAvailableSwitchActions();
 			
 			// Remove editing mode buttons from interface
 			General.MainWindow.RemoveEditModeButtons();
 			
 			// Go for all the editing mode groups
 			foreach(string grp in groups)
 			{
 				General.MainWindow.AddEditModeSeperator();
 				
 				// Go for all used edit modes to add buttons
 				foreach(EditModeInfo emi in usedmodes)
 				{
 					if((emi.ButtonImage != null) && (emi.ButtonDesc != null) &&
 					   (emi.Attributes.ButtonGroup == grp))
 						General.MainWindow.AddEditModeButton(emi);
 				}
 				foreach(EditModeInfo emi in usedmodes)
 				{
 					if((emi.ButtonImage != null) && (emi.ButtonDesc != null) &&
 					   (emi.Attributes.ButtonGroup == grp))
 						General.MainWindow.AddEditModeButton(emi);
 				}
 			}
 			foreach(string grp in groups)
 			{
 				General.MainWindow.AddEditModeSeperator();
 				
 				// Go for all used edit modes to add buttons
 				foreach(EditModeInfo emi in usedmodes)
 				{
 					if((emi.ButtonImage != null) && (emi.ButtonDesc != null) &&
 					   (emi.Attributes.ButtonGroup == grp))
 						General.MainWindow.AddEditModeButton(emi);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="150" endline="193">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Serialization
 		
 		// Serialize / deserialize
 		internal void ReadWrite(IReadWriteStream s)
 		{
 			if(s.IsWriting)
 			{
 				s.wInt(islandvertices.Count);
 				for(int i = 0; i < islandvertices.Count; i++) s.wInt(islandvertices[i]);
 				
 				s.wInt(vertices.Count);
 				for(int i = 0; i < vertices.Count; i++) s.wVector2D(vertices[i]);
 				
 				s.wInt(sidedefs.Count);
 				for(int i = 0; i < sidedefs.Count; i++)
 				{
 					if(sidedefs[i] != null)
 						s.wInt(sidedefs[i].SerializedIndex);
 					else
 						s.wInt(-1);
 				}
 				for(int i = 0; i < sidedefs.Count; i++)
 				{
 					if(sidedefs[i] != null)
 						s.wInt(sidedefs[i].SerializedIndex);
 					else
 						s.wInt(-1);
 				}
 			}
 			else
 			{
 				int c;
 				
 				s.rInt(out c);
 				int[] islandverticeslist = new int[c];
 				for(int i = 0; i < c; i++) s.rInt(out islandverticeslist[i]);
 				islandvertices = Array.AsReadOnly<int>(islandverticeslist);
 				
 				s.rInt(out c);
 				Vector2D[] verticeslist = new Vector2D[c];
 				for(int i = 0; i < c; i++) s.rVector2D(out verticeslist[i]);
 				vertices = Array.AsReadOnly<Vector2D>(verticeslist);
 				
 				s.rInt(out c);
 				sidedefindices = new int[c];
 				for(int i = 0; i < c; i++) s.rInt(out sidedefindices[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="977" endline="1007">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Sprites
 
 		// This loads the hard defined sprites (not all the lumps, we do that on a need-to-know basis, see LoadThingSprites)
 		private int LoadSprites()
 		{
 			ICollection<ImageData> images;
 			int counter = 0;
 			
 			// Load all defined sprites. Note that we do not use all sprites,
 			// so we don't add them for previews just yet.
 			foreach(DataReader dr in containers)
 			{
 				// Load sprites
 				images = dr.LoadSprites();
 				if(images != null)
 				{
 					// Add or replace in sprites list
 					foreach(ImageData img in images)
 					{
 						sprites[img.LongName] = img;
 						counter++;
 					}
 					foreach(ImageData img in images)
 					{
 						sprites[img.LongName] = img;
 						counter++;
 					}
 				}
 			}
 			foreach(DataReader dr in containers)
 			{
 				// Load sprites
 				images = dr.LoadSprites();
 				if(images != null)
 				{
 					// Add or replace in sprites list
 					foreach(ImageData img in images)
 					{
 						sprites[img.LongName] = img;
 						counter++;
 					}
 				}
 			}
 			
 			// Output info
 			return counter;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="400" endline="426">
<![CDATA[
 		
 		// This loads a universal fields list
 		private List<UniversalFieldInfo> LoadUniversalFields(string elementname)
 		{
 			List<UniversalFieldInfo> list = new List<UniversalFieldInfo>();
 			UniversalFieldInfo uf;
 			IDictionary dic;
 			
 			// Get fields
 			dic = cfg.ReadSetting("universalfields." + elementname, new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				try
 				{
 					// Read the field info and add to list
 					uf = new UniversalFieldInfo(elementname, de.Key.ToString(), cfg, enums);
 					list.Add(uf);
 				}
 				catch(Exception)
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Unable to read universal field definition 'universalfields." + elementname + "." + de.Key + "' from game configuration '" + this.Name + "'");
 				}
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				try
 				{
 					// Read the field info and add to list
 					uf = new UniversalFieldInfo(elementname, de.Key.ToString(), cfg, enums);
 					list.Add(uf);
 				}
 				catch(Exception)
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Unable to read universal field definition 'universalfields." + elementname + "." + de.Key + "' from game configuration '" + this.Name + "'");
 				}
 			}
 
 			// Return result
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1008" endline="1020">
<![CDATA[
 
 		internal void PlayRefLinedefStart(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			Linedef l = General.Map.Map.GetLinedefByIndex(index);
 			int vindex; ds.rInt(out vindex);
 			//LogRecordInfo("PLY
 			Vertex v = (vindex >= 0) ? General.Map.Map.GetVertexByIndex(vindex) 
 			l.SetStartVertex(v);
 			l.Marked = true;
 			if(v != null) v.Marked = true;
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1032" endline="1044">
<![CDATA[
 
 		internal void PlayRefLinedefEnd(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			Linedef l = General.Map.Map.GetLinedefByIndex(index);
 			int vindex; ds.rInt(out vindex);
 			//LogRecordInfo("PLY
 			Vertex v = (vindex >= 0) ? General.Map.Map.GetVertexByIndex(vindex) 
 			l.SetEndVertex(v);
 			l.Marked = true;
 			if(v != null) v.Marked = true;
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1056" endline="1068">
<![CDATA[
 
 		internal void PlayRefLinedefFront(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			Linedef l = General.Map.Map.GetLinedefByIndex(index);
 			int sindex; ds.rInt(out sindex);
 			//LogRecordInfo("PLY
 			Sidedef sd = (sindex >= 0) ? General.Map.Map.GetSidedefByIndex(sindex) 
 			l.AttachFront(sd);
 			l.Marked = true;
 			if(sd != null) sd.Marked = true;
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1080" endline="1092">
<![CDATA[
 
 		internal void PlayRefLinedefBack(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			Linedef l = General.Map.Map.GetLinedefByIndex(index);
 			int sindex; ds.rInt(out sindex);
 			//LogRecordInfo("PLY
 			Sidedef sd = (sindex >= 0) ? General.Map.Map.GetSidedefByIndex(sindex) 
 			l.AttachBack(sd);
 			l.Marked = true;
 			if(sd != null) sd.Marked = true;
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1173" endline="1185">
<![CDATA[
 
 		internal void PlayRefSidedefSector(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			Sidedef sd = General.Map.Map.GetSidedefByIndex(index);
 			int sindex; ds.rInt(out sindex);
 			//LogRecordInfo("PLY
 			Sector sc = (sindex >= 0) ? General.Map.Map.GetSectorByIndex(sindex) 
 			sd.SetSector(sc);
 			sd.Marked = true;
 			if(sc != null) sc.Marked = true;
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="373" endline="386">
<![CDATA[
 		
 		// This asks to save files and returns the result
 		public bool AskSaveAll()
 		{
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				if(t.ExplicitSave)
 				{
 					if(!CloseScript(t, true)) return false;
 				}
 			}
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				if(t.ExplicitSave)
 				{
 					if(!CloseScript(t, true)) return false;
 				}
 			}
 			
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\Launcher.cs" startline="342" endline="353">
<![CDATA[
 		
 		// This deletes the previous temp file and creates a new, empty temp file
 		private void CleanTempFile(MapManager manager)
 		{
 			// Remove temporary file
 			try { File.Delete(tempwad); }
 			catch(Exception) { }
 			
 			// Make new empty temp file
 			tempwad = General.MakeTempFilename(manager.TempPath, "wad");
 			File.WriteAllText(tempwad, "");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="939" endline="949">
<![CDATA[
 
 		internal void PlayAddLinedef(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			//LogRecordInfo("PLY
 			Linedef l = General.Map.Map.GetLinedefByIndex(index);
 			if(l.Front != null) l.Front.Marked = true;
 			if(l.Back != null) l.Back.Marked = true;
 			l.Dispose();
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\UniValue.cs" startline="112" endline="176">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 
 		// Serialize / deserialize
 		internal void ReadWrite(IReadWriteStream s)
 		{
 			s.rwInt(ref type);
 			switch((UniversalType)type)
 			{
 				case UniversalType.AngleRadians
 				case UniversalType.AngleDegreesFloat
 				case UniversalType.Float
 				{
 					float v = 0.0f;
 					try { v = (float)value; } catch(NullReferenceException e) { }
 					s.rwFloat(ref v);
 					value = v;
 					break;
 				}
 				
 				case UniversalType.AngleDegrees
 				case UniversalType.Color
 				case UniversalType.EnumBits
 				case UniversalType.EnumOption
 				case UniversalType.Integer
 				case UniversalType.LinedefTag
 				case UniversalType.LinedefType
 				case UniversalType.SectorEffect
 				case UniversalType.SectorTag
 				case UniversalType.ThingTag
 				{
 					int v = 0;
 					try { v = (int)value; } catch(NullReferenceException e) { }
 					s.rwInt(ref v);
 					value = v;
 					break;
 				}
 
 				case UniversalType.Boolean
 				{
 					bool v = false;
 					try { v = (bool)value; } catch(NullReferenceException e) { }
 					s.rwBool(ref v);
 					value = v;
 					break;
 				}
 				
 				case UniversalType.Flat
 				case UniversalType.String
 				case UniversalType.Texture
 				case UniversalType.EnumStrings
 				{
 					string v = (string)value;
 					s.rwString(ref v);
 					value = v;
 					break;
 				}
 				
 				default
 					General.Fail("Unknown field type to read/write!");
 					break;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingBrowserControl.cs" startline="76" endline="102">
<![CDATA[
 
 		// This sets up the control
 		public void Setup()
 		{
 			// Go for all predefined categories
 			typelist.Nodes.Clear();
 			nodes = new List<TreeNode>();
 			foreach(ThingCategory tc in General.Map.Data.ThingCategories)
 			{
 				// Create category
 				TreeNode cn = typelist.Nodes.Add(tc.Name, tc.Title);
 				if((tc.Color >= 0) && (tc.Color < thingimages.Images.Count)) cn.ImageIndex = tc.Color;
 				cn.SelectedImageIndex = cn.ImageIndex;
 				foreach(ThingTypeInfo ti in tc.Things)
 				{
 					// Create thing
 					TreeNode n = cn.Nodes.Add(ti.Title);
 					if((ti.Color >= 0) && (ti.Color < thingimages.Images.Count)) n.ImageIndex = ti.Color;
 					n.SelectedImageIndex = n.ImageIndex;
 					n.Tag = ti;
 					nodes.Add(n);
 				}
 				foreach(ThingTypeInfo ti in tc.Things)
 				{
 					// Create thing
 					TreeNode n = cn.Nodes.Add(ti.Title);
 					if((ti.Color >= 0) && (ti.Color < thingimages.Images.Count)) n.ImageIndex = ti.Color;
 					n.SelectedImageIndex = n.ImageIndex;
 					n.Tag = ti;
 					nodes.Add(n);
 				}
 			}
 			foreach(ThingCategory tc in General.Map.Data.ThingCategories)
 			{
 				// Create category
 				TreeNode cn = typelist.Nodes.Add(tc.Name, tc.Title);
 				if((tc.Color >= 0) && (tc.Color < thingimages.Images.Count)) cn.ImageIndex = tc.Color;
 				cn.SelectedImageIndex = cn.ImageIndex;
 				foreach(ThingTypeInfo ti in tc.Things)
 				{
 					// Create thing
 					TreeNode n = cn.Nodes.Add(ti.Title);
 					if((ti.Color >= 0) && (ti.Color < thingimages.Images.Count)) n.ImageIndex = ti.Color;
 					n.SelectedImageIndex = n.ImageIndex;
 					n.Tag = ti;
 					nodes.Add(n);
 				}
 			}
 
 			doupdatenode = true;
 			doupdatetextbox = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="145" endline="182">
<![CDATA[
 
 		// Called when all resource must be reloaded
 		public void ReloadResource()
 		{
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				// Rebuild vertex buffers
 				for(int i = 0; i < set.Value.buffersizes.Count; i++)
 				{
 					// Make the new buffer!
 					VertexBuffer b = new VertexBuffer(General.Map.Graphics.Device, FlatVertex.Stride * set.Value.buffersizes[i],
 													Usage.WriteOnly | Usage.Dynamic, VertexFormat.None, Pool.Default);
 
 					// Start refilling the buffer with sector geometry
 					int vertexoffset = 0;
 					DataStream bstream = b.Lock(0, FlatVertex.Stride * set.Value.buffersizes[i], LockFlags.Discard);
 					foreach(SurfaceEntry e in set.Value.entries)
 					{
 						if(e.bufferindex == i)
 						{
 							// Fill buffer
 							bstream.Seek(e.vertexoffset * FlatVertex.Stride, SeekOrigin.Begin);
 							bstream.WriteRange(e.floorvertices);
 							bstream.WriteRange(e.ceilvertices);
 						}
 					}
 					foreach(SurfaceEntry e in set.Value.entries)
 					{
 						if(e.bufferindex == i)
 						{
 							// Fill buffer
 							bstream.Seek(e.vertexoffset * FlatVertex.Stride, SeekOrigin.Begin);
 							bstream.WriteRange(e.floorvertices);
 							bstream.WriteRange(e.ceilvertices);
 						}
 					}
 
 					// Unlock buffer
 					b.Unlock();
 					bstream.Dispose();
 					
 					// Add to list
 					set.Value.buffers[i] = b;
 				}
 				for(int i = 0; i < set.Value.buffersizes.Count; i++)
 				{
 					// Make the new buffer!
 					VertexBuffer b = new VertexBuffer(General.Map.Graphics.Device, FlatVertex.Stride * set.Value.buffersizes[i],
 													Usage.WriteOnly | Usage.Dynamic, VertexFormat.None, Pool.Default);
 
 					// Start refilling the buffer with sector geometry
 					int vertexoffset = 0;
 					DataStream bstream = b.Lock(0, FlatVertex.Stride * set.Value.buffersizes[i], LockFlags.Discard);
 					foreach(SurfaceEntry e in set.Value.entries)
 					{
 						if(e.bufferindex == i)
 						{
 							// Fill buffer
 							bstream.Seek(e.vertexoffset * FlatVertex.Stride, SeekOrigin.Begin);
 							bstream.WriteRange(e.floorvertices);
 							bstream.WriteRange(e.ceilvertices);
 						}
 					}
 
 					// Unlock buffer
 					b.Unlock();
 					bstream.Dispose();
 					
 					// Add to list
 					set.Value.buffers[i] = b;
 				}
 			}
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				// Rebuild vertex buffers
 				for(int i = 0; i < set.Value.buffersizes.Count; i++)
 				{
 					// Make the new buffer!
 					VertexBuffer b = new VertexBuffer(General.Map.Graphics.Device, FlatVertex.Stride * set.Value.buffersizes[i],
 													Usage.WriteOnly | Usage.Dynamic, VertexFormat.None, Pool.Default);
 
 					// Start refilling the buffer with sector geometry
 					int vertexoffset = 0;
 					DataStream bstream = b.Lock(0, FlatVertex.Stride * set.Value.buffersizes[i], LockFlags.Discard);
 					foreach(SurfaceEntry e in set.Value.entries)
 					{
 						if(e.bufferindex == i)
 						{
 							// Fill buffer
 							bstream.Seek(e.vertexoffset * FlatVertex.Stride, SeekOrigin.Begin);
 							bstream.WriteRange(e.floorvertices);
 							bstream.WriteRange(e.ceilvertices);
 						}
 					}
 
 					// Unlock buffer
 					b.Unlock();
 					bstream.Dispose();
 					
 					// Add to list
 					set.Value.buffers[i] = b;
 				}
 			}
 			
 			resourcesunloaded = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="582" endline="616">
<![CDATA[
 
 		// This writes the SIDEDEFS to WAD file
 		private void WriteSidedefs(MapSet map, int position, IDictionary maplumps, IDictionary<Sector, int> sectorids)
 		{
 			MemoryStream mem;
 			BinaryWriter writer;
 			Lump lump;
 			int insertpos;
 
 			// Create memory to write to
 			mem = new MemoryStream();
 			writer = new BinaryWriter(mem, WAD.ENCODING);
 
 			// Go for all sidedefs
 			foreach(Sidedef sd in map.Sidedefs)
 			{
 				// Write properties to stream
 				writer.Write((Int16)sd.OffsetX);
 				writer.Write((Int16)sd.OffsetY);
 				writer.Write(Lump.MakeFixedName(sd.HighTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(sd.LowTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(sd.MiddleTexture, WAD.ENCODING));
 				writer.Write((UInt16)sectorids[sd.Sector]);
 			}
 			foreach(Sidedef sd in map.Sidedefs)
 			{
 				// Write properties to stream
 				writer.Write((Int16)sd.OffsetX);
 				writer.Write((Int16)sd.OffsetY);
 				writer.Write(Lump.MakeFixedName(sd.HighTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(sd.LowTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(sd.MiddleTexture, WAD.ENCODING));
 				writer.Write((UInt16)sectorids[sd.Sector]);
 			}
 
 			// Find insert position and remove old lump
 			insertpos = MapManager.RemoveSpecificLump(wad, "SIDEDEFS", position, MapManager.TEMP_MAP_HEADER, maplumps);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 
 			// Create the lump from memory
 			lump = wad.Insert("SIDEDEFS", insertpos, (int)mem.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			mem.WriteTo(lump.Stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1176" endline="1182">
<![CDATA[
 
 		/// <summary>This clears selected vertices.</summary>
 		public void ClearSelectedVertices()
 		{
 			sel_vertices.Clear();
 			foreach(Vertex v in vertices) v.Selected = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1183" endline="1189">
<![CDATA[
 
 		/// <summary>This clears selected things.</summary>
 		public void ClearSelectedThings()
 		{
 			sel_things.Clear();
 			foreach(Thing t in things) t.Selected = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1190" endline="1196">
<![CDATA[
 
 		/// <summary>This clears selected linedefs.</summary>
 		public void ClearSelectedLinedefs()
 		{
 			sel_linedefs.Clear();
 			foreach(Linedef l in linedefs) l.Selected = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1197" endline="1203">
<![CDATA[
 
 		/// <summary>This clears selected sectors.</summary>
 		public void ClearSelectedSectors()
 		{
 			sel_sectors.Clear();
 			foreach(Sector s in sectors) s.Selected = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="423" endline="466">
<![CDATA[
 
 		// This writes the THINGS to WAD file
 		private void WriteThings(MapSet map, int position, IDictionary maplumps)
 		{
 			MemoryStream mem;
 			BinaryWriter writer;
 			Lump lump;
 			int insertpos;
 			int flags;
 			
 			// Create memory to write to
 			mem = new MemoryStream();
 			writer = new BinaryWriter(mem, WAD.ENCODING);
 			
 			// Go for all things
 			foreach(Thing t in map.Things)
 			{
 				// Convert flags
 				flags = 0;
 				foreach(KeyValuePair<string, bool> f in t.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 				foreach(KeyValuePair<string, bool> f in t.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 
 				// Write properties to stream
 				writer.Write((Int16)t.Position.x);
 				writer.Write((Int16)t.Position.y);
 				writer.Write((Int16)t.AngleDoom);
 				writer.Write((UInt16)t.Type);
 				writer.Write((UInt16)flags);
 			}
 			foreach(Thing t in map.Things)
 			{
 				// Convert flags
 				flags = 0;
 				foreach(KeyValuePair<string, bool> f in t.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 
 				// Write properties to stream
 				writer.Write((Int16)t.Position.x);
 				writer.Write((Int16)t.Position.y);
 				writer.Write((Int16)t.AngleDoom);
 				writer.Write((UInt16)t.Type);
 				writer.Write((UInt16)flags);
 			}
 			
 			// Find insert position and remove old lump
 			insertpos = MapManager.RemoveSpecificLump(wad, "THINGS", position, MapManager.TEMP_MAP_HEADER, maplumps);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 			
 			// Create the lump from memory
 			lump = wad.Insert("THINGS", insertpos, (int)mem.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			mem.WriteTo(lump.Stream);
 			mem.Flush();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalMapSetIO.cs" startline="53" endline="97">
<![CDATA[
 		public UniversalMapSetIO(WAD wad, MapManager manager) 
 		{
 			if((manager != null) && (manager.Config != null))
 			{
 				// Make configuration
 				config = new Configuration();
 				
 				// Find a resource named UDMF.cfg
 				string[] resnames = General.ThisAssembly.GetManifestResourceNames();
 				foreach(string rn in resnames)
 				{
 					// Found it?
 					if(rn.EndsWith(UDMF_CONFIG_NAME, StringComparison.InvariantCultureIgnoreCase))
 					{
 						// Get a stream from the resource
 						Stream udmfcfg = General.ThisAssembly.GetManifestResourceStream(rn);
 						StreamReader udmfcfgreader = new StreamReader(udmfcfg, Encoding.ASCII);
 						
 						// Load configuration from stream
 						config.InputConfiguration(udmfcfgreader.ReadToEnd());
 						
 						// Now we add the linedef flags, activations and thing flags
 						// to this list, so that these don't show up in the custom
 						// fields list either. We use true as dummy value (it has no meaning)
 						
 						// Add linedef flags
 						foreach(KeyValuePair<string, string> flag in manager.Config.LinedefFlags)
 							config.WriteSetting("managedfields.linedef." + flag.Key, true);
 						foreach(KeyValuePair<string, string> flag in manager.Config.LinedefFlags)
 							config.WriteSetting("managedfields.linedef." + flag.Key, true);
 						
 						// Add linedef activations
 						foreach(LinedefActivateInfo activate in manager.Config.LinedefActivates)
 							config.WriteSetting("managedfields.linedef." + activate.Key, true);
 						foreach(LinedefActivateInfo activate in manager.Config.LinedefActivates)
 							config.WriteSetting("managedfields.linedef." + activate.Key, true);
 						
 						// Add thing flags
 						foreach(KeyValuePair<string, string> flag in manager.Config.ThingFlags)
 							config.WriteSetting("managedfields.thing." + flag.Key, true);
 						foreach(KeyValuePair<string, string> flag in manager.Config.ThingFlags)
 							config.WriteSetting("managedfields.thing." + flag.Key, true);
 						
 						// Done
 						udmfcfgreader.Dispose();
 						udmfcfg.Dispose();
 						break;
 					}
 				}
 				foreach(string rn in resnames)
 				{
 					// Found it?
 					if(rn.EndsWith(UDMF_CONFIG_NAME, StringComparison.InvariantCultureIgnoreCase))
 					{
 						// Get a stream from the resource
 						Stream udmfcfg = General.ThisAssembly.GetManifestResourceStream(rn);
 						StreamReader udmfcfgreader = new StreamReader(udmfcfg, Encoding.ASCII);
 						
 						// Load configuration from stream
 						config.InputConfiguration(udmfcfgreader.ReadToEnd());
 						
 						// Now we add the linedef flags, activations and thing flags
 						// to this list, so that these don't show up in the custom
 						// fields list either. We use true as dummy value (it has no meaning)
 						
 						// Add linedef flags
 						foreach(KeyValuePair<string, string> flag in manager.Config.LinedefFlags)
 							config.WriteSetting("managedfields.linedef." + flag.Key, true);
 						
 						// Add linedef activations
 						foreach(LinedefActivateInfo activate in manager.Config.LinedefActivates)
 							config.WriteSetting("managedfields.linedef." + activate.Key, true);
 						
 						// Add thing flags
 						foreach(KeyValuePair<string, string> flag in manager.Config.ThingFlags)
 							config.WriteSetting("managedfields.thing." + flag.Key, true);
 						
 						// Done
 						udmfcfgreader.Dispose();
 						udmfcfg.Dispose();
 						break;
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="691" endline="721">
<![CDATA[
 
 		// Thing flags
 		private void LoadThingFlags()
 		{
 			IDictionary dic;
 
 			// Get linedef flags
 			dic = cfg.ReadSetting("thingflags", new Hashtable());
 			foreach (DictionaryEntry de in dic)
 				thingflags.Add(de.Key.ToString(), de.Value.ToString());
 			foreach (DictionaryEntry de in dic)
 				thingflags.Add(de.Key.ToString(), de.Value.ToString());
 			
 			// Get translations
 			dic = cfg.ReadSetting("thingflagstranslation", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 				thingflagstranslation.Add(new FlagTranslation(de));
 			foreach(DictionaryEntry de in dic)
 				thingflagstranslation.Add(new FlagTranslation(de));
 
 			// Get thing compare flag info (for the stuck thing error checker
 			dic = cfg.ReadSetting("thingflagscompare", new Hashtable());
 			foreach (DictionaryEntry de in dic)
 			{
 				IDictionary gdic = cfg.ReadSetting("thingflagscompare." + de.Key, new Hashtable());
 
 				foreach (DictionaryEntry gde in gdic)
 				{
 					thingflagscompare.Add(new ThingFlagsCompare(cfg, de.Key.ToString(), gde.Key.ToString()));
 				}
 				foreach (DictionaryEntry gde in gdic)
 				{
 					thingflagscompare.Add(new ThingFlagsCompare(cfg, de.Key.ToString(), gde.Key.ToString()));
 				}
 			}
 			foreach (DictionaryEntry de in dic)
 			{
 				IDictionary gdic = cfg.ReadSetting("thingflagscompare." + de.Key, new Hashtable());
 
 				foreach (DictionaryEntry gde in gdic)
 				{
 					thingflagscompare.Add(new ThingFlagsCompare(cfg, de.Key.ToString(), gde.Key.ToString()));
 				}
 			}
 
 			// Sort the translation flags, because they must be compared highest first!
 			thingflagstranslation.Sort();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="934" endline="968">
<![CDATA[
 		
 		// Redraw requested
 		private void redrawtimer_Tick(object sender, EventArgs e)
 		{
 			// Disable timer (only redraw once)
 			redrawtimer.Enabled = false;
 
 			// Resume control layouts
 			//if(displayresized) General.LockWindowUpdate(IntPtr.Zero);
 
 			// Map opened?
 			if(General.Map != null)
 			{
 				// Display was resized?
 				if(displayresized)
 				{
 					// Reset graphics to match changes
 					General.Map.Graphics.Reset();
 				}
 
 				// This is a dirty trick to give the display a new mousemove event with correct arguments
 				if(mouseinside)
 				{
 					Point mousepos = Cursor.Position;
 					Cursor.Position = new Point(mousepos.X + 1, mousepos.Y + 1);
 					Cursor.Position = mousepos;
 				}
 				
 				// Redraw now
 				RedrawDisplay();
 			}
 
 			// Display resize is done
 			displayresized = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2249" endline="2257">
<![CDATA[
 		
 		// Errors and Warnings
 		[BeginAction("showerrors")]
 		internal void ShowErrors()
 		{
 			ErrorsForm errform = new ErrorsForm();
 			errform.ShowDialog(this);
 			errform.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\LinedefEditForm.cs" startline="538" endline="554">
<![CDATA[
 
 		// Custom fields on front sides
 		private void customfrontbutton_Click(object sender, EventArgs e)
 		{
 			// Make collection of front sides
 			List<MapElement> sides = new List<MapElement>(lines.Count);
 			foreach(Linedef l in lines) if(l.Front != null) sides.Add(l.Front);
 
 			// Make undo
 			string undodesc = "sidedef";
 			if(sides.Count > 1) undodesc = sides.Count + " sidedefs";
 			General.Map.UndoRedo.CreateUndo("Edit " + undodesc);
 			
 			// Edit these
 			if(!CustomFieldsForm.ShowDialog(this, "Front side custom fields", "sidedef", sides, General.Map.Config.SidedefFields))
 				General.Map.UndoRedo.WithdrawUndo();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\LinedefEditForm.cs" startline="555" endline="571">
<![CDATA[
 
 		// Custom fields on back sides
 		private void custombackbutton_Click(object sender, EventArgs e)
 		{
 			// Make collection of back sides
 			List<MapElement> sides = new List<MapElement>(lines.Count);
 			foreach(Linedef l in lines) if(l.Back != null) sides.Add(l.Back);
 
 			// Make undo
 			string undodesc = "sidedef";
 			if(sides.Count > 1) undodesc = sides.Count + " sidedefs";
 			General.Map.UndoRedo.CreateUndo("Edit " + undodesc);
 			
 			// Edit these
 			if(!CustomFieldsForm.ShowDialog(this, "Back side custom fields", "sidedef", sides, General.Map.Config.SidedefFields))
 				General.Map.UndoRedo.WithdrawUndo();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamWriter.cs" startline="245" endline="269">
<![CDATA[
 
 		// This adds sectors
 		private void WriteSectors(ICollection<Sector> sectors, UniversalParser textmap)
 		{
 			// Go for all sectors
 			foreach(Sector s in sectors)
 			{
 				// Make collection
 				UniversalCollection coll = new UniversalCollection();
 				coll.Add("heightfloor", s.FloorHeight);
 				coll.Add("heightceiling", s.CeilHeight);
 				coll.Add("texturefloor", s.FloorTexture);
 				coll.Add("textureceiling", s.CeilTexture);
 				coll.Add("lightlevel", s.Brightness);
 				if(s.Effect != 0) coll.Add("special", s.Effect);
 				if(s.Tag != 0) coll.Add("id", s.Tag);
 				coll.Comment = s.Index.ToString();
 
 				// Add custom fields
 				AddCustomFields(s, "sector", coll);
 
 				// Store
 				textmap.Root.Add("sector", coll);
 			}
 			foreach(Sector s in sectors)
 			{
 				// Make collection
 				UniversalCollection coll = new UniversalCollection();
 				coll.Add("heightfloor", s.FloorHeight);
 				coll.Add("heightceiling", s.CeilHeight);
 				coll.Add("texturefloor", s.FloorTexture);
 				coll.Add("textureceiling", s.CeilTexture);
 				coll.Add("lightlevel", s.Brightness);
 				if(s.Effect != 0) coll.Add("special", s.Effect);
 				if(s.Tag != 0) coll.Add("id", s.Tag);
 				coll.Comment = s.Index.ToString();
 
 				// Add custom fields
 				AddCustomFields(s, "sector", coll);
 
 				// Store
 				textmap.Root.Add("sector", coll);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualCamera.cs" startline="101" endline="139">
<![CDATA[
 
 		// This applies the position and angle from the 3D Camera Thing
 		// Returns false when it couldn't find a 3D Camera Thing
 		public virtual bool PositionAtThing()
 		{
 			Thing modething = null;
 			Vector3D delta;
 			
 			// Find a 3D Mode thing
 			foreach(Thing t in General.Map.Map.Things)
 				if(t.Type == General.Map.Config.Start3DModeThingType) modething = t;
 			foreach(Thing t in General.Map.Map.Things)
 				if(t.Type == General.Map.Config.Start3DModeThingType) modething = t;
 
 			// Found one?
 			if(modething != null)
 			{
 				modething.DetermineSector();
 				float z = modething.Position.z;
 				if(modething.Sector != null)
 					z = modething.Position.z + (float)modething.Sector.FloorHeight;
 				
 				// Position camera here
 				Vector3D wantedposition = new Vector3D(modething.Position.x, modething.Position.y, z + THING_Z_OFFSET);
 				delta = position - wantedposition;
 				if(delta.GetLength() > 1.0f) position = wantedposition;
 				
 				// Change angle
 				float wantedanglexy = modething.Angle + Angle2D.PI;
 				if(anglexy != wantedanglexy)
 				{
 					anglexy = wantedanglexy;
 					anglez = Angle2D.PI;
 				}
 				return true;
 			}
 			else
 			{
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="617" endline="652">
<![CDATA[
 
 		// This writes the SECTORS to WAD file
 		private void WriteSectors(MapSet map, int position, IDictionary maplumps)
 		{
 			MemoryStream mem;
 			BinaryWriter writer;
 			Lump lump;
 			int insertpos;
 
 			// Create memory to write to
 			mem = new MemoryStream();
 			writer = new BinaryWriter(mem, WAD.ENCODING);
 
 			// Go for all sectors
 			foreach(Sector s in map.Sectors)
 			{
 				// Write properties to stream
 				writer.Write((Int16)s.FloorHeight);
 				writer.Write((Int16)s.CeilHeight);
 				writer.Write(Lump.MakeFixedName(s.FloorTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(s.CeilTexture, WAD.ENCODING));
 				writer.Write((Int16)s.Brightness);
 				writer.Write((UInt16)s.Effect);
 				writer.Write((UInt16)s.Tag);
 			}
 			foreach(Sector s in map.Sectors)
 			{
 				// Write properties to stream
 				writer.Write((Int16)s.FloorHeight);
 				writer.Write((Int16)s.CeilHeight);
 				writer.Write(Lump.MakeFixedName(s.FloorTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(s.CeilTexture, WAD.ENCODING));
 				writer.Write((Int16)s.Brightness);
 				writer.Write((UInt16)s.Effect);
 				writer.Write((UInt16)s.Tag);
 			}
 
 			// Find insert position and remove old lump
 			insertpos = MapManager.RemoveSpecificLump(wad, "SECTORS", position, MapManager.TEMP_MAP_HEADER, maplumps);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 
 			// Create the lump from memory
 			lump = wad.Insert("SECTORS", insertpos, (int)mem.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			mem.WriteTo(lump.Stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CopyPasteManager.cs" startline="352" endline="374">
<![CDATA[
 		
 		// This cuts the current selection
 		[BeginAction("cutselection")]
 		public void CutSelection()
 		{
 			// Copy selected geometry
 			if(DoCopySelection("Cut selected elements."))
 			{
 				// Get the delete action and check if it's bound
 				Actions.Action deleteitem = General.Actions["builder_deleteitem"];
 				if(deleteitem.BeginBound)
 				{
 					// Perform delete action
 					deleteitem.Begin();
 					deleteitem.End();
 				}
 				else
 				{
 					// Action not bound
 					General.Interface.DisplayStatus(StatusType.Warning, "Cannot remove that in this mode.");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2223" endline="2244">
<![CDATA[
 
 		/// <summary>This corrects lines that have a back sidedef but no front sidedef by flipping them. Returns the number of flips made.</summary>
 		public static int FlipBackwardLinedefs(ICollection<Linedef> lines)
 		{
 			int flipsdone = 0;
 			
 			// Examine all lines
 			foreach(Linedef l in lines)
 			{
 				// Back side but no front side?
 				if((l.Back != null) && (l.Front == null))
 				{
 					// Flip that linedef!
 					l.FlipVertices();
 					l.FlipSidedefs();
 					flipsdone++;
 				}
 			}
 			foreach(Linedef l in lines)
 			{
 				// Back side but no front side?
 				if((l.Back != null) && (l.Front == null))
 				{
 					// Flip that linedef!
 					l.FlipVertices();
 					l.FlipSidedefs();
 					flipsdone++;
 				}
 			}
 
 			// Return result
 			return flipsdone;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="590" endline="626">
<![CDATA[
 
 		// This writes the SECTORS to WAD file
 		private void WriteSectors(MapSet map, int position, IDictionary maplumps)
 		{
 			MemoryStream mem;
 			BinaryWriter writer;
 			Lump lump;
 			int insertpos;
 
 			// Create memory to write to
 			mem = new MemoryStream();
 			writer = new BinaryWriter(mem, WAD.ENCODING);
 
 			// Go for all sectors
 			foreach(Sector s in map.Sectors)
 			{
 				// Write properties to stream
 				writer.Write((Int16)s.FloorHeight);
 				writer.Write((Int16)s.CeilHeight);
 				writer.Write(Lump.MakeFixedName(s.FloorTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(s.CeilTexture, WAD.ENCODING));
 				writer.Write((Int16)s.Brightness);
 				writer.Write((UInt16)s.Effect);
 				writer.Write((UInt16)s.Tag);
 			}
 			foreach(Sector s in map.Sectors)
 			{
 				// Write properties to stream
 				writer.Write((Int16)s.FloorHeight);
 				writer.Write((Int16)s.CeilHeight);
 				writer.Write(Lump.MakeFixedName(s.FloorTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(s.CeilTexture, WAD.ENCODING));
 				writer.Write((Int16)s.Brightness);
 				writer.Write((UInt16)s.Effect);
 				writer.Write((UInt16)s.Tag);
 			}
 
 			// Find insert position and remove old lump
 			insertpos = MapManager.RemoveSpecificLump(wad, "SECTORS", position, MapManager.TEMP_MAP_HEADER, maplumps);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 
 			// Create the lump from memory
 			lump = wad.Insert("SECTORS", insertpos, (int)mem.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			mem.WriteTo(lump.Stream);
 			mem.Flush();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="232" endline="261">
<![CDATA[
 		
 		// This removes a docker
 		public bool Remove(Docker d)
 		{
 			foreach(TabPage page in tabs.TabPages)
 			{
 				if((page.Tag as Docker) == d)
 				{
 					// Go for all controls to remove events
 					Queue<Control> todo = new Queue<Control>();
 					todo.Enqueue(d.Control);
 					while(todo.Count > 0)
 					{
 						Control c = todo.Dequeue();
 						c.MouseEnter -= RaiseMouseContainerEnter;
 						c.MouseLeave -= RaiseMouseContainerLeave;
 						foreach(Control cc in c.Controls)
 							todo.Enqueue(cc);
 						foreach(Control cc in c.Controls)
 							todo.Enqueue(cc);
 					}
 					while(todo.Count > 0)
 					{
 						Control c = todo.Dequeue();
 						c.MouseEnter -= RaiseMouseContainerEnter;
 						c.MouseLeave -= RaiseMouseContainerLeave;
 						foreach(Control cc in c.Controls)
 							todo.Enqueue(cc);
 					}
 					
 					// Take down that page
 					if(page == tabs.SelectedTab) SelectPrevious();
 					page.Controls.Clear();
 					tabs.TabPages.Remove(page);
 					return true;
 				}
 			}
 			foreach(TabPage page in tabs.TabPages)
 			{
 				if((page.Tag as Docker) == d)
 				{
 					// Go for all controls to remove events
 					Queue<Control> todo = new Queue<Control>();
 					todo.Enqueue(d.Control);
 					while(todo.Count > 0)
 					{
 						Control c = todo.Dequeue();
 						c.MouseEnter -= RaiseMouseContainerEnter;
 						c.MouseLeave -= RaiseMouseContainerLeave;
 						foreach(Control cc in c.Controls)
 							todo.Enqueue(cc);
 					}
 					
 					// Take down that page
 					if(page == tabs.SelectedTab) SelectPrevious();
 					page.Controls.Clear();
 					tabs.TabPages.Remove(page);
 					return true;
 				}
 			}
 			
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="423" endline="471">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Controls Panel
 		
 		// This updates the used keys info
 		private void UpdateKeyUsedActions()
 		{
 			List<string> usedactions = new List<string>();
 			
 			// Anything selected?
 			if(listactions.SelectedItems.Count > 0)
 			{
 				// Get info
 				int thiskey = (int)listactions.SelectedItems[0].SubItems[1].Tag;
 				if(thiskey != 0)
 				{
 					// Find actions with same key
 					foreach(ListViewItem item in listactions.Items)
 					{
 						// Don't count the selected action
 						if(item != listactions.SelectedItems[0])
 						{
 							Actions.Action a = General.Actions[item.Name];
 							int akey = (int)item.SubItems[1].Tag;
 
 							// Check if the key combination matches
 							if((thiskey & a.ShortcutMask) == (akey & a.ShortcutMask))
 								usedactions.Add(a.Title + "  (" + General.Actions.Categories[a.Category] + ")");
 						}
 					}
 					foreach(ListViewItem item in listactions.Items)
 					{
 						// Don't count the selected action
 						if(item != listactions.SelectedItems[0])
 						{
 							Actions.Action a = General.Actions[item.Name];
 							int akey = (int)item.SubItems[1].Tag;
 
 							// Check if the key combination matches
 							if((thiskey & a.ShortcutMask) == (akey & a.ShortcutMask))
 								usedactions.Add(a.Title + "  (" + General.Actions.Categories[a.Category] + ")");
 						}
 					}
 				}
 			}
 			
 			// Update info
 			if(usedactions.Count == 0)
 			{
 				keyusedlabel.Visible = false;
 				keyusedlist.Visible = false;
 				keyusedlist.Items.Clear();
 			}
 			else
 			{
 				keyusedlist.Items.Clear();
 				foreach(string a in usedactions) keyusedlist.Items.Add(a);
 				keyusedlabel.Visible = true;
 				keyusedlist.Visible = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="915" endline="927">
<![CDATA[
 		
 		// This deserializes things
 		private void ReadThings(DeserializerStream stream)
 		{
 			int c; stream.rInt(out c);
 
 			// Go for all things
 			for(int i = 0; i < c; i++)
 			{
 				Thing t = CreateThing();
 				t.ReadWrite(stream);
 			}
 			for(int i = 0; i < c; i++)
 			{
 				Thing t = CreateThing();
 				t.ReadWrite(stream);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="183" endline="208">
<![CDATA[
 		
 		// This resets all buffers and requires all sectors to get new entries
 		public void Reset()
 		{
 			// Clear all items
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					entry.numvertices = -1;
 					entry.bufferindex = -1;
 				}
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					entry.numvertices = -1;
 					entry.bufferindex = -1;
 				}
 				
 				foreach(SurfaceEntry entry in set.Value.holes)
 				{
 					entry.numvertices = -1;
 					entry.bufferindex = -1;
 				}
 				foreach(SurfaceEntry entry in set.Value.holes)
 				{
 					entry.numvertices = -1;
 					entry.bufferindex = -1;
 				}
 
 				foreach(VertexBuffer vb in set.Value.buffers)
 					vb.Dispose();
 				foreach(VertexBuffer vb in set.Value.buffers)
 					vb.Dispose();
 			}
 			foreach(KeyValuePair<int, SurfaceBufferSet> set in sets)
 			{
 				foreach(SurfaceEntry entry in set.Value.entries)
 				{
 					entry.numvertices = -1;
 					entry.bufferindex = -1;
 				}
 				
 				foreach(SurfaceEntry entry in set.Value.holes)
 				{
 					entry.numvertices = -1;
 					entry.bufferindex = -1;
 				}
 
 				foreach(VertexBuffer vb in set.Value.buffers)
 					vb.Dispose();
 			}
 
 			// New dictionary
 			sets = new Dictionary<int, SurfaceBufferSet>();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CopyPasteManager.cs" startline="93" endline="137">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		// This makes a prefab of the selection. Returns null when cancelled.
 		internal MemoryStream MakePrefab()
 		{
 			// Let the plugins know
 			if(General.Plugins.OnCopyBegin())
 			{
 				// Ask the editing mode to prepare selection for copying.
 				// The edit mode should mark all vertices, lines and sectors
 				// that need to be copied.
 				if(General.Editing.Mode.OnCopyBegin())
 				{
 					// Copy the marked geometry
 					// This links sidedefs that are not linked to a marked sector to a virtual sector
 					MapSet copyset = General.Map.Map.CloneMarked();
 					
 					// Convert flags and activations to UDMF fields, if needed
 					if(!(General.Map.FormatInterface is UniversalMapSetIO)) copyset.TranslateToUDMF();
 
 					// Write data to stream
 					MemoryStream memstream = new MemoryStream();
 					UniversalStreamWriter writer = new UniversalStreamWriter();
 					writer.RememberCustomTypes = false;
 					writer.Write(copyset, memstream, null);
 
 					// Compress the stream
 					MemoryStream compressed = new MemoryStream((int)memstream.Length);
 					memstream.Seek(0, SeekOrigin.Begin);
 					BZip2.Compress(memstream, compressed, 900000);
 
 					// Done
 					memstream.Dispose();
 					General.Editing.Mode.OnCopyEnd();
 					General.Plugins.OnCopyEnd();
 					return compressed;
 				}
 			}
 
 			// Aborted
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="554" endline="589">
<![CDATA[
 
 		// This writes the SIDEDEFS to WAD file
 		private void WriteSidedefs(MapSet map, int position, IDictionary maplumps, IDictionary<Sector, int> sectorids)
 		{
 			MemoryStream mem;
 			BinaryWriter writer;
 			Lump lump;
 			int insertpos;
 
 			// Create memory to write to
 			mem = new MemoryStream();
 			writer = new BinaryWriter(mem, WAD.ENCODING);
 
 			// Go for all sidedefs
 			foreach(Sidedef sd in map.Sidedefs)
 			{
 				// Write properties to stream
 				writer.Write((Int16)sd.OffsetX);
 				writer.Write((Int16)sd.OffsetY);
 				writer.Write(Lump.MakeFixedName(sd.HighTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(sd.LowTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(sd.MiddleTexture, WAD.ENCODING));
 				writer.Write((UInt16)sectorids[sd.Sector]);
 			}
 			foreach(Sidedef sd in map.Sidedefs)
 			{
 				// Write properties to stream
 				writer.Write((Int16)sd.OffsetX);
 				writer.Write((Int16)sd.OffsetY);
 				writer.Write(Lump.MakeFixedName(sd.HighTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(sd.LowTexture, WAD.ENCODING));
 				writer.Write(Lump.MakeFixedName(sd.MiddleTexture, WAD.ENCODING));
 				writer.Write((UInt16)sectorids[sd.Sector]);
 			}
 
 			// Find insert position and remove old lump
 			insertpos = MapManager.RemoveSpecificLump(wad, "SIDEDEFS", position, MapManager.TEMP_MAP_HEADER, maplumps);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 
 			// Create the lump from memory
 			lump = wad.Insert("SIDEDEFS", insertpos, (int)mem.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			mem.WriteTo(lump.Stream);
 			mem.Flush();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="908" endline="960">
<![CDATA[
 		
 		// This creates empty lumps for those required
 		private void CreateRequiredLumps(WAD target, string mapname)
 		{
 			int headerindex, insertindex, targetindex;
 			string lumpname;
 			bool lumprequired;
 			
 			// Find the map header in target
 			headerindex = target.FindLumpIndex(mapname);
 			if(headerindex == -1)
 			{
 				// If this header doesnt exists in the target
 				// then insert at the end of the target
 				headerindex = target.Lumps.Count;
 			}
 
 			// Begin inserting at target header index
 			insertindex = headerindex;
 
 			// Go for all the map lump names
 			foreach(DictionaryEntry ml in config.MapLumpNames)
 			{
 				// Read lump settings from map config
 				lumprequired = config.ReadSetting("maplumpnames." + ml.Key + ".required", false);
 
 				// Check if this lump is required
 				if(lumprequired)
 				{
 					// Get the lump name
 					lumpname = ml.Key.ToString();
 					if(lumpname == CONFIG_MAP_HEADER) lumpname = mapname;
 
 					// Check if the lump is missing at the target
 					targetindex = FindSpecificLump(target, lumpname, headerindex, mapname, config.MapLumpNames);
 					if(targetindex == -1)
 					{
 						// Determine target index
 						insertindex++;
 						if(insertindex > target.Lumps.Count) insertindex = target.Lumps.Count;
 
 						// Create new, emtpy lump
 						General.WriteLogLine(lumpname + " is required! Created empty lump.");
 						target.Insert(lumpname, insertindex, 0);
 					}
 					else
 					{
 						// Move insert index
 						insertindex = targetindex;
 					}
 				}
 			}
 			foreach(DictionaryEntry ml in config.MapLumpNames)
 			{
 				// Read lump settings from map config
 				lumprequired = config.ReadSetting("maplumpnames." + ml.Key + ".required", false);
 
 				// Check if this lump is required
 				if(lumprequired)
 				{
 					// Get the lump name
 					lumpname = ml.Key.ToString();
 					if(lumpname == CONFIG_MAP_HEADER) lumpname = mapname;
 
 					// Check if the lump is missing at the target
 					targetindex = FindSpecificLump(target, lumpname, headerindex, mapname, config.MapLumpNames);
 					if(targetindex == -1)
 					{
 						// Determine target index
 						insertindex++;
 						if(insertindex > target.Lumps.Count) insertindex = target.Lumps.Count;
 
 						// Create new, emtpy lump
 						General.WriteLogLine(lumpname + " is required! Created empty lump.");
 						target.Insert(lumpname, insertindex, 0);
 					}
 					else
 					{
 						// Move insert index
 						insertindex = targetindex;
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\GameConfiguration.cs" startline="427" endline="460">
<![CDATA[
 		
 		// Things and thing categories
 		private void LoadThingCategories()
 		{
 			IDictionary dic;
 			ThingCategory thingcat;
 			
 			// Get thing categories
 			dic = cfg.ReadSetting("thingtypes", new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				if(de.Value is IDictionary)
 				{
 					// Make a category
 					thingcat = new ThingCategory(cfg, de.Key.ToString(), enums);
 
 					// Add all things in category to the big list
 					foreach(ThingTypeInfo t in thingcat.Things)
 					{
 						if(!things.ContainsKey(t.Index))
 						{
 							things.Add(t.Index, t);
 						}
 						else
 						{
 							General.ErrorLogger.Add(ErrorType.Warning, "Thing number " + t.Index + " is defined more than once (as '" + things[t.Index].Title + "' and '" + t.Title + "') in game configuration '" + this.Name + "'");
 						}
 					}
 					foreach(ThingTypeInfo t in thingcat.Things)
 					{
 						if(!things.ContainsKey(t.Index))
 						{
 							things.Add(t.Index, t);
 						}
 						else
 						{
 							General.ErrorLogger.Add(ErrorType.Warning, "Thing number " + t.Index + " is defined more than once (as '" + things[t.Index].Title + "' and '" + t.Title + "') in game configuration '" + this.Name + "'");
 						}
 					}
 
 					// Add category to list
 					thingcategories.Add(thingcat);
 				}
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				if(de.Value is IDictionary)
 				{
 					// Make a category
 					thingcat = new ThingCategory(cfg, de.Key.ToString(), enums);
 
 					// Add all things in category to the big list
 					foreach(ThingTypeInfo t in thingcat.Things)
 					{
 						if(!things.ContainsKey(t.Index))
 						{
 							things.Add(t.Index, t);
 						}
 						else
 						{
 							General.ErrorLogger.Add(ErrorType.Warning, "Thing number " + t.Index + " is defined more than once (as '" + things[t.Index].Title + "' and '" + t.Title + "') in game configuration '" + this.Name + "'");
 						}
 					}
 
 					// Add category to list
 					thingcategories.Add(thingcat);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="601" endline="661">
<![CDATA[
 
 
 		// This joins a sector with the given lines and sides. Returns null when operation could not be completed.
 		public static Sector JoinSector(List<LinedefSide> alllines, Sidedef original)
 		{
 			SidedefSettings sourceside = new SidedefSettings();
 			
 			// Take settings fro mthe original side
 			TakeSidedefSettings(ref sourceside, original);
 
 			// Use defaults where no settings could be found
 			TakeSidedefDefaults(ref sourceside);
 
 			// Go for all sides to make sidedefs
 			foreach(LinedefSide ls in alllines)
 			{
 				if(ls.Front)
 				{
 					// Create sidedef if needed
 					if(ls.Line.Front == null)
 					{
 						Sidedef sd = General.Map.Map.CreateSidedef(ls.Line, true, original.Sector);
 						if(sd == null) return null;
 						ApplyDefaultsToSidedef(ls.Line.Front, sourceside);
 						ls.Line.ApplySidedFlags();
 						
 						// We must remove the (now useless) middle texture on the other side
 						if(ls.Line.Back != null) ls.Line.Back.RemoveUnneededTextures(true, true);
 					}
 					// Added 23-9-08, can we do this or will it break things?
 					else
 					{
 						// Link to the new sector
 						ls.Line.Front.SetSector(original.Sector);
 					}
 				}
 				else
 				{
 					// Create sidedef if needed
 					if(ls.Line.Back == null)
 					{
 						Sidedef sd = General.Map.Map.CreateSidedef(ls.Line, false, original.Sector);
 						if(sd == null) return null;
 						ApplyDefaultsToSidedef(ls.Line.Back, sourceside);
 						ls.Line.ApplySidedFlags();
 
 						// We must remove the (now useless) middle texture on the other side
 						if(ls.Line.Front != null) ls.Line.Front.RemoveUnneededTextures(true, true);
 					}
 					// Added 23-9-08, can we do this or will it break things?
 					else
 					{
 						// Link to the new sector
 						ls.Line.Back.SetSector(original.Sector);
 					}
 				}
 			}
 			foreach(LinedefSide ls in alllines)
 			{
 				if(ls.Front)
 				{
 					// Create sidedef if needed
 					if(ls.Line.Front == null)
 					{
 						Sidedef sd = General.Map.Map.CreateSidedef(ls.Line, true, original.Sector);
 						if(sd == null) return null;
 						ApplyDefaultsToSidedef(ls.Line.Front, sourceside);
 						ls.Line.ApplySidedFlags();
 						
 						// We must remove the (now useless) middle texture on the other side
 						if(ls.Line.Back != null) ls.Line.Back.RemoveUnneededTextures(true, true);
 					}
 					// Added 23-9-08, can we do this or will it break things?
 					else
 					{
 						// Link to the new sector
 						ls.Line.Front.SetSector(original.Sector);
 					}
 				}
 				else
 				{
 					// Create sidedef if needed
 					if(ls.Line.Back == null)
 					{
 						Sidedef sd = General.Map.Map.CreateSidedef(ls.Line, false, original.Sector);
 						if(sd == null) return null;
 						ApplyDefaultsToSidedef(ls.Line.Back, sourceside);
 						ls.Line.ApplySidedFlags();
 
 						// We must remove the (now useless) middle texture on the other side
 						if(ls.Line.Front != null) ls.Line.Front.RemoveUnneededTextures(true, true);
 					}
 					// Added 23-9-08, can we do this or will it break things?
 					else
 					{
 						// Link to the new sector
 						ls.Line.Back.SetSector(original.Sector);
 					}
 				}
 			}
 
 			// Return the new sector
 			return original.Sector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualCamera.cs" startline="140" endline="167">
<![CDATA[
 		
 		// This applies the camera position and angle to the 3D Camera Thing
 		// Returns false when it couldn't find a 3D Camera Thing
 		public virtual bool ApplyToThing()
 		{
 			Thing modething = null;
 			
 			// Find a 3D Mode thing
 			foreach(Thing t in General.Map.Map.Things)
 				if(t.Type == General.Map.Config.Start3DModeThingType) modething = t;
 			foreach(Thing t in General.Map.Map.Things)
 				if(t.Type == General.Map.Config.Start3DModeThingType) modething = t;
 
 			// Found one?
 			if(modething != null)
 			{
 				int z = 0;
 				if(sector != null)
 					z = (int)position.z - sector.FloorHeight;
 
 				// Position the thing to match camera
 				modething.Move((int)position.x, (int)position.y, z - THING_Z_OFFSET);
 				modething.Rotate(anglexy - Angle2D.PI);
 				return true;
 			}
 			else
 			{
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="757" endline="793">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Serialization
 
 		// This serializes the MapSet
 		internal MemoryStream Serialize()
 		{
 			MemoryStream stream = new MemoryStream(20000000);	// Yes that is about 20 MB.
 			SerializerStream serializer = new SerializerStream(stream);
 			
 			// Index the sidedefs
 			int sidedefindex = 0;
 			foreach(Sidedef sd in sidedefs)
 				sd.SerializedIndex = sidedefindex++;
 			foreach(Sidedef sd in sidedefs)
 				sd.SerializedIndex = sidedefindex++;
 
 			serializer.Begin();
 
 			// Write private data
 			serializer.wInt(lastsectorindex);
 			serializer.wInt(indexholes.Count);
 			foreach(int i in indexholes) serializer.wInt(i);
 
 			// Write map data
 			WriteVertices(serializer);
 			WriteSectors(serializer);
 			WriteLinedefs(serializer);
 			WriteSidedefs(serializer);
 			WriteThings(serializer);
 
 			serializer.End();
 
 			// Reallocate to keep only the used memory
 			stream.Capacity = (int)stream.Length;
 			
 			return stream;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1963" endline="1990">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Geometry Tools
 
 		/// <summary>This removes any virtual sectors in the map and returns the number of sectors removed.</summary>
 		public int RemoveVirtualSectors()
 		{
 			int count = 0;
 			int index = 0;
 			
 			// Go for all sectors
 			while(index < numsectors)
 			{
 				// Remove when virtual
 				if(sectors[index].Fields.ContainsKey(VIRTUAL_SECTOR_FIELD))
 				{
 					sectors[index].Dispose();
 					count++;
 				}
 				else
 				{
 					index++;
 				}
 			}
 			while(index < numsectors)
 			{
 				// Remove when virtual
 				if(sectors[index].Fields.ContainsKey(VIRTUAL_SECTOR_FIELD))
 				{
 					sectors[index].Dispose();
 					count++;
 				}
 				else
 				{
 					index++;
 				}
 			}
 			
 			return count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\Plugin.cs" startline="133" endline="157">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 		
 		// This creates a stream to read a resource or returns null when not found
 		public Stream GetResourceStream(string resourcename)
 		{
 			string[] resnames;
 			
 			// Find a resource
 			resnames = asm.GetManifestResourceNames();
 			foreach(string rn in resnames)
 			{
 				// Found it?
 				if(rn.EndsWith(resourcename, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					return asm.GetManifestResourceStream(rn);
 				}
 			}
 			foreach(string rn in resnames)
 			{
 				// Found it?
 				if(rn.EndsWith(resourcename, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					return asm.GetManifestResourceStream(rn);
 				}
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1020" endline="1040">
<![CDATA[
 
 		/// <summary>
 		/// This updates the cache of all elements where needed. It is not recommended to use this version, please use Update() instead.
 		/// </summary>
 		public void Update(bool dolines, bool dosectors)
 		{
 			// Update all linedefs
 			if(dolines) foreach(Linedef l in linedefs) l.UpdateCache();
 			
 			// Update all sectors
 			if(dosectors)
 			{
 				foreach(Sector s in sectors) s.Triangulate();
 				
 				General.Map.CRenderer2D.Surfaces.AllocateBuffers();
 				
 				foreach(Sector s in sectors) s.CreateSurfaces();
 				
 				General.Map.CRenderer2D.Surfaces.UnlockBuffers();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="285" endline="325">
<![CDATA[
 
 		// This translates UDMF fields back into the normal flags
 		internal void TranslateFromUDMF()
 		{
 			// Make copy of the flags
 			Dictionary<string, bool> oldfields = new Dictionary<string, bool>(flags);
 
 			// Make the flags
 			flags.Clear();
 			foreach(KeyValuePair<string, string> f in General.Map.Config.ThingFlags)
 			{
 				// Flag must be numeric
 				int flagbit = 0;
 				if(int.TryParse(f.Key, out flagbit))
 				{
 					foreach(FlagTranslation ft in General.Map.Config.ThingFlagsTranslation)
 					{
 						if(ft.Flag == flagbit)
 						{
 							// Only set this flag when the fields match
 							bool fieldsmatch = true;
 							for(int i = 0; i < ft.Fields.Count; i++)
 							{
 								if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 								{
 									fieldsmatch = false;
 									break;
 								}
 							}
 							for(int i = 0; i < ft.Fields.Count; i++)
 							{
 								if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 								{
 									fieldsmatch = false;
 									break;
 								}
 							}
 
 							// Field match? Then add the flag.
 							if(fieldsmatch)
 							{
 								flags.Add(f.Key, true);
 								break;
 							}
 						}
 					}
 					foreach(FlagTranslation ft in General.Map.Config.ThingFlagsTranslation)
 					{
 						if(ft.Flag == flagbit)
 						{
 							// Only set this flag when the fields match
 							bool fieldsmatch = true;
 							for(int i = 0; i < ft.Fields.Count; i++)
 							{
 								if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 								{
 									fieldsmatch = false;
 									break;
 								}
 							}
 
 							// Field match? Then add the flag.
 							if(fieldsmatch)
 							{
 								flags.Add(f.Key, true);
 								break;
 							}
 						}
 					}
 				}
 			}
 			foreach(KeyValuePair<string, string> f in General.Map.Config.ThingFlags)
 			{
 				// Flag must be numeric
 				int flagbit = 0;
 				if(int.TryParse(f.Key, out flagbit))
 				{
 					foreach(FlagTranslation ft in General.Map.Config.ThingFlagsTranslation)
 					{
 						if(ft.Flag == flagbit)
 						{
 							// Only set this flag when the fields match
 							bool fieldsmatch = true;
 							for(int i = 0; i < ft.Fields.Count; i++)
 							{
 								if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 								{
 									fieldsmatch = false;
 									break;
 								}
 							}
 
 							// Field match? Then add the flag.
 							if(fieldsmatch)
 							{
 								flags.Add(f.Key, true);
 								break;
 							}
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="232" endline="276">
<![CDATA[
 
 		// Edit resource
 		private void editresource_Click(object sender, EventArgs e)
 		{
 			ResourceOptionsForm resoptions;
 			Rectangle startposition;
 			ListViewItem selecteditem;
 			DataLocation rl;
 
 			// Anything selected?
 			if(resourceitems.SelectedItems.Count > 0)
 			{
 				// Get selected item
 				selecteditem = resourceitems.SelectedItems[0];
 
 				// Open resource options dialog
 				resoptions = new ResourceOptionsForm((DataLocation)selecteditem.Tag, "Resource Options");
 				resoptions.StartPosition = FormStartPosition.Manual;
 				startposition = new Rectangle(dialogoffset.X, dialogoffset.Y, 1, 1);
 				startposition = this.RectangleToScreen(startposition);
 				Screen screen = Screen.FromPoint(startposition.Location);
 				if(startposition.X + resoptions.Size.Width > screen.WorkingArea.Right)
 					startposition.X = screen.WorkingArea.Right - resoptions.Size.Width;
 				if(startposition.Y + resoptions.Size.Height > screen.WorkingArea.Bottom)
 					startposition.Y = screen.WorkingArea.Bottom - resoptions.Size.Height;
 				resoptions.Location = startposition.Location;
 				if(resoptions.ShowDialog(this) == DialogResult.OK)
 				{
 					// Start editing list
 					resourceitems.BeginUpdate();
 
 					// Update item
 					rl = resoptions.ResourceLocation;
 					selecteditem.Text = rl.location;
 					selecteditem.Tag = rl;
 					selecteditem.ImageIndex = GetIconIndex(rl.type, false);
 					
 					// Done
 					resourceitems.EndUpdate();
 					
 					// Raise content changed event
 					if(OnContentChanged != null) OnContentChanged();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="269" endline="330">
<![CDATA[
 
 		// Background thread
 		private void BackgroundThread()
 		{
 			while(true)
 			{
 				if(dobackgroundwork)
 				{
 					// First set dobackgroundwork to false before performing the work so
 					// that it can be set to true again when another pass is needed
 					dobackgroundwork = false;
 
 					int undolevel = 0;
 					UndoSnapshot us;
 					while(true)
 					{
 						// Get the next snapshot or leave
 						lock(undos)
 						{
 							if(undolevel < undos.Count)
 								us = undos[undolevel];
 							else
 								break;
 						}
 
 						// Write to file or load from file, if needed
 						if(us.StoreOnDisk && !us.IsOnDisk)
 							us.WriteToFile();
 						else if(!us.StoreOnDisk && us.IsOnDisk)
 							us.RestoreFromFile();
 
 						// Next
 						undolevel++;
 					}
 					while(true)
 					{
 						// Get the next snapshot or leave
 						lock(undos)
 						{
 							if(undolevel < undos.Count)
 								us = undos[undolevel];
 							else
 								break;
 						}
 
 						// Write to file or load from file, if needed
 						if(us.StoreOnDisk && !us.IsOnDisk)
 							us.WriteToFile();
 						else if(!us.StoreOnDisk && us.IsOnDisk)
 							us.RestoreFromFile();
 
 						// Next
 						undolevel++;
 					}
 
 					int redolevel = 0;
 					while(true)
 					{
 						// Get the next snapshot or leave
 						lock(redos)
 						{
 							if(redolevel < redos.Count)
 								us = redos[redolevel];
 							else
 								break;
 						}
 
 						// Write to file or load from file, if needed
 						if(us.StoreOnDisk && !us.IsOnDisk)
 							us.WriteToFile();
 						else if(!us.StoreOnDisk && us.IsOnDisk)
 							us.RestoreFromFile();
 
 						// Next
 						redolevel++;
 					}
 					while(true)
 					{
 						// Get the next snapshot or leave
 						lock(redos)
 						{
 							if(redolevel < redos.Count)
 								us = redos[redolevel];
 							else
 								break;
 						}
 
 						// Write to file or load from file, if needed
 						if(us.StoreOnDisk && !us.IsOnDisk)
 							us.WriteToFile();
 						else if(!us.StoreOnDisk && us.IsOnDisk)
 							us.RestoreFromFile();
 
 						// Next
 						redolevel++;
 					}
 				}
 
 				try { Thread.Sleep(30); }
 				catch(ThreadInterruptedException) { break; }
 			}
 			while(true)
 			{
 				if(dobackgroundwork)
 				{
 					// First set dobackgroundwork to false before performing the work so
 					// that it can be set to true again when another pass is needed
 					dobackgroundwork = false;
 
 					int undolevel = 0;
 					UndoSnapshot us;
 					while(true)
 					{
 						// Get the next snapshot or leave
 						lock(undos)
 						{
 							if(undolevel < undos.Count)
 								us = undos[undolevel];
 							else
 								break;
 						}
 
 						// Write to file or load from file, if needed
 						if(us.StoreOnDisk && !us.IsOnDisk)
 							us.WriteToFile();
 						else if(!us.StoreOnDisk && us.IsOnDisk)
 							us.RestoreFromFile();
 
 						// Next
 						undolevel++;
 					}
 
 					int redolevel = 0;
 					while(true)
 					{
 						// Get the next snapshot or leave
 						lock(redos)
 						{
 							if(redolevel < redos.Count)
 								us = redos[redolevel];
 							else
 								break;
 						}
 
 						// Write to file or load from file, if needed
 						if(us.StoreOnDisk && !us.IsOnDisk)
 							us.WriteToFile();
 						else if(!us.StoreOnDisk && us.IsOnDisk)
 							us.RestoreFromFile();
 
 						// Next
 						redolevel++;
 					}
 				}
 
 				try { Thread.Sleep(30); }
 				catch(ThreadInterruptedException) { break; }
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="447" endline="488">
<![CDATA[
 		
 		// This updates the toolbar for the current status
 		private void UpdateToolbar(bool focuseditor)
 		{
 			int numscriptsopen = tabs.TabPages.Count;
 			int explicitsavescripts = 0;
 			ScriptDocumentTab t = null;
 			
 			// Any explicit save scripts?
 			foreach(ScriptDocumentTab dt in tabs.TabPages)
 				if(dt.ExplicitSave) explicitsavescripts++;
 			foreach(ScriptDocumentTab dt in tabs.TabPages)
 				if(dt.ExplicitSave) explicitsavescripts++;
 			
 			// Get current script, if any are open
 			if(numscriptsopen > 0)
 				t = (tabs.SelectedTab as ScriptDocumentTab);
 			
 			// Enable/disable buttons
 			buttonsave.Enabled = (t != null) && t.ExplicitSave;
 			buttonsaveall.Enabled = (explicitsavescripts > 0);
 			buttoncompile.Enabled = (t != null) && (t.Config.Compiler != null);
 			buttonkeywordhelp.Enabled = (t != null) && !string.IsNullOrEmpty(t.Config.KeywordHelp);
 			buttonscriptconfig.Enabled = (t != null) && t.IsReconfigurable;
 			buttonundo.Enabled = (t != null);
 			buttonredo.Enabled = (t != null);
 			buttoncopy.Enabled = (t != null);
 			buttoncut.Enabled = (t != null);
 			buttonpaste.Enabled = (t != null);
 			buttonclose.Enabled = (t != null) && t.IsClosable;
 			
 			if(t != null)
 			{
 				// Check the according script config in menu
 				foreach(ToolStripMenuItem item in buttonscriptconfig.DropDownItems)
 				{
 					ScriptConfiguration config = (item.Tag as ScriptConfiguration);
 					item.Checked = (config == t.Config);
 				}
 				foreach(ToolStripMenuItem item in buttonscriptconfig.DropDownItems)
 				{
 					ScriptConfiguration config = (item.Tag as ScriptConfiguration);
 					item.Checked = (config == t.Config);
 				}
 				
 				// Focus to script editor
 				if(focuseditor) ForceFocus();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="295" endline="364">
<![CDATA[
 
 		// This recursively traces a path
 		// Returns the resulting TracePath when the search is complete
 		// or returns null when no path found.
 		private SidedefsTracePath DoTracePath(SidedefsTracePath history, Vertex fromhere, Vertex findme, Sector sector, Dictionary<Sidedef, bool> sides)
 		{
 			SidedefsTracePath nextpath;
 			SidedefsTracePath result;
 			Vertex nextvertex;
 			List<Sidedef> allsides;
 			
 			// Found the vertex we are tracing to?
 			if(fromhere == findme) return history;
 
 			// On the first run, findme is null (otherwise the trace would end
 			// immeditely when it starts) so set findme here on the first run.
 			if(findme == null) findme = fromhere;
 
 			// Make a list of sides referring to the same sector
 			allsides = new List<Sidedef>(fromhere.Linedefs.Count * 2);
 			foreach(Linedef l in fromhere.Linedefs)
 			{
 				// Should we go along the front or back side?
 				// This is very important for clockwise polygon orientation!
 				if(l.Start == fromhere)
 				{
 					// Front side of line connected to sector?
 					if((l.Front != null) && (l.Front.Sector == sector))
 					{
 						// Visit here when not visited yet
 						if(sides.ContainsKey(l.Front) && !sides[l.Front]) allsides.Add(l.Front);
 					}
 				}
 				else
 				{
 					// Back side of line connected to sector?
 					if((l.Back != null) && (l.Back.Sector == sector))
 					{
 						// Visit here when not visited yet
 						if(sides.ContainsKey(l.Back) && !sides[l.Back]) allsides.Add(l.Back);
 					}
 				}
 			}
 			foreach(Linedef l in fromhere.Linedefs)
 			{
 				// Should we go along the front or back side?
 				// This is very important for clockwise polygon orientation!
 				if(l.Start == fromhere)
 				{
 					// Front side of line connected to sector?
 					if((l.Front != null) && (l.Front.Sector == sector))
 					{
 						// Visit here when not visited yet
 						if(sides.ContainsKey(l.Front) && !sides[l.Front]) allsides.Add(l.Front);
 					}
 				}
 				else
 				{
 					// Back side of line connected to sector?
 					if((l.Back != null) && (l.Back.Sector == sector))
 					{
 						// Visit here when not visited yet
 						if(sides.ContainsKey(l.Back) && !sides[l.Back]) allsides.Add(l.Back);
 					}
 				}
 			}
 
 			// Previous line available?
 			if(history.Count > 0)
 			{
 				// This is done to ensure the tracing works along vertices that are shared by
 				// more than 2 lines/sides of the same sector. We must continue tracing along
 				// the first next smallest delta angle! This sorts the smallest delta angle to
 				// the top of the list.
 				SidedefAngleSorter sorter = new SidedefAngleSorter(history[history.Count - 1], fromhere);
 				allsides.Sort(sorter);
 			}
 			
 			// Go for all lines connected to this vertex
 			foreach(Sidedef s in allsides)
 			{
 				// Mark sidedef as visited and move to next vertex
 				sides[s] = true;
 				nextpath = new SidedefsTracePath(history, s);
 				if(s.Line.Start == fromhere) nextvertex = s.Line.End; else nextvertex = s.Line.Start;
 				
 				result = DoTracePath(nextpath, nextvertex, findme, sector, sides);
 				if(result != null) return result;
 			}
 			foreach(Sidedef s in allsides)
 			{
 				// Mark sidedef as visited and move to next vertex
 				sides[s] = true;
 				nextpath = new SidedefsTracePath(history, s);
 				if(s.Line.Start == fromhere) nextvertex = s.Line.End; else nextvertex = s.Line.Start;
 				
 				result = DoTracePath(nextpath, nextvertex, findme, sector, sides);
 				if(result != null) return result;
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="319" endline="354">
<![CDATA[
 
 		// Field clicked
 		private void filterfield_Check(object sender, EventArgs e)
 		{
 			// Get the checkbox
 			CheckBox box = (sender as CheckBox);
 			
 			// Not setting up?
 			if(!settingup)
 			{
 				// Anything selected?
 				if(listfilters.SelectedItems.Count > 0)
 				{
 					// Get selected filter
 					ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 					
 					// New state is required?
 					if(box.CheckState == CheckState.Checked)
 					{
 						f.ForbiddenFields.Remove(box.Tag.ToString());
 						if(!f.RequiredFields.Contains(box.Tag.ToString())) f.RequiredFields.Add(box.Tag.ToString());
 					}
 					// New state is forbidden?
 					else if(box.CheckState == CheckState.Unchecked)
 					{
 						f.RequiredFields.Remove(box.Tag.ToString());
 						if(!f.ForbiddenFields.Contains(box.Tag.ToString())) f.ForbiddenFields.Add(box.Tag.ToString());
 					}
 					else
 					{
 						f.ForbiddenFields.Remove(box.Tag.ToString());
 						f.RequiredFields.Remove(box.Tag.ToString());
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="391" endline="420">
<![CDATA[
 		
 		// This translates the flags and activations into UDMF fields
 		internal void TranslateToUDMF()
 		{
 			// First make a single integer with all bits from activation and flags
 			int bits = activate;
 			int flagbit = 0;
 			foreach(KeyValuePair<string, bool> f in flags)
 				if(int.TryParse(f.Key, out flagbit) && f.Value) bits |= flagbit;
 			foreach(KeyValuePair<string, bool> f in flags)
 				if(int.TryParse(f.Key, out flagbit) && f.Value) bits |= flagbit;
 			
 			// Now make the new flags
 			flags.Clear();
 			foreach(FlagTranslation f in General.Map.Config.LinedefFlagsTranslation)
 			{
 				// Flag found in bits?
 				if((bits & f.Flag) == f.Flag)
 				{
 					// Add fields and remove bits
 					bits &= ~f.Flag;
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = f.FieldValues[i];
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = f.FieldValues[i];
 				}
 				else
 				{
 					// Add fields with inverted value
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = !f.FieldValues[i];
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = !f.FieldValues[i];
 				}
 			}
 			foreach(FlagTranslation f in General.Map.Config.LinedefFlagsTranslation)
 			{
 				// Flag found in bits?
 				if((bits & f.Flag) == f.Flag)
 				{
 					// Add fields and remove bits
 					bits &= ~f.Flag;
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = f.FieldValues[i];
 				}
 				else
 				{
 					// Add fields with inverted value
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = !f.FieldValues[i];
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="1414" endline="1468">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Flat Floodfill
 
 		// This performs flat floodfill over sector floors or ceilings that match with the same flat
 		// NOTE
 		// When resetsectormarks is set to true, all sectors will first be marked false (not aligned).
 		// Setting resetsectormarks to false is usefull to fill only within a specific selection
 		// (set the marked property to true for the sectors outside the selection)
 		public static void FloodfillFlats(Sector start, bool fillceilings, long originalflat, ImageData fillflat, bool resetsectormarks)
 		{
 			Stack<Sector> todo = new Stack<Sector>(50);
 
 			// Mark all sectors false (they will be marked true when the flat is modified)
 			if(resetsectormarks) General.Map.Map.ClearMarkedSectors(false);
 			
 			// Begin with first sector
 			if(((start.LongFloorTexture == originalflat) && !fillceilings) ||
 			   ((start.LongCeilTexture == originalflat) && fillceilings))
 			{
 				todo.Push(start);
 			}
 
 			// Continue until nothing more to align
 			while(todo.Count > 0)
 			{
 				// Get the sector to do
 				Sector s = todo.Pop();
 				
 				// Apply new flat
 				if(fillceilings)
 					s.SetCeilTexture(fillflat.Name);
 				else
 					s.SetFloorTexture(fillflat.Name);
 				s.Marked = true;
 				
 				// Go for all sidedefs to add neighbouring sectors
 				foreach(Sidedef sd in s.Sidedefs)
 				{
 					// Sector on the other side of the line that we haven't checked yet?
 					if((sd.Other != null) && !sd.Other.Sector.Marked)
 					{
 						Sector os = sd.Other.Sector;
 						
 						// Check if texture matches
 						if(((os.LongFloorTexture == originalflat) && !fillceilings) ||
 						   ((os.LongCeilTexture == originalflat) && fillceilings))
 						{
 							todo.Push(os);
 						}
 					}
 				}
 				foreach(Sidedef sd in s.Sidedefs)
 				{
 					// Sector on the other side of the line that we haven't checked yet?
 					if((sd.Other != null) && !sd.Other.Sector.Marked)
 					{
 						Sector os = sd.Other.Sector;
 						
 						// Check if texture matches
 						if(((os.LongFloorTexture == originalflat) && !fillceilings) ||
 						   ((os.LongCeilTexture == originalflat) && fillceilings))
 						{
 							todo.Push(os);
 						}
 					}
 				}
 			}
 			while(todo.Count > 0)
 			{
 				// Get the sector to do
 				Sector s = todo.Pop();
 				
 				// Apply new flat
 				if(fillceilings)
 					s.SetCeilTexture(fillflat.Name);
 				else
 					s.SetFloorTexture(fillflat.Name);
 				s.Marked = true;
 				
 				// Go for all sidedefs to add neighbouring sectors
 				foreach(Sidedef sd in s.Sidedefs)
 				{
 					// Sector on the other side of the line that we haven't checked yet?
 					if((sd.Other != null) && !sd.Other.Sector.Marked)
 					{
 						Sector os = sd.Other.Sector;
 						
 						// Check if texture matches
 						if(((os.LongFloorTexture == originalflat) && !fillceilings) ||
 						   ((os.LongCeilTexture == originalflat) && fillceilings))
 						{
 							todo.Push(os);
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamWriter.cs" startline="54" endline="101">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public UniversalStreamWriter()
 		{
 			// Make configurations
 			config = new Configuration();
 			
 			// Find a resource named UDMF.cfg
 			string[] resnames = General.ThisAssembly.GetManifestResourceNames();
 			foreach(string rn in resnames)
 			{
 				// Found it?
 				if(rn.EndsWith(UDMF_CONFIG_NAME, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					Stream udmfcfg = General.ThisAssembly.GetManifestResourceStream(rn);
 					StreamReader udmfcfgreader = new StreamReader(udmfcfg, Encoding.ASCII);
 
 					// Load configuration from stream
 					config.InputConfiguration(udmfcfgreader.ReadToEnd());
 
 					// Now we add the linedef flags, activations and thing flags
 					// to this list, so that these don't show up in the custom
 					// fields list either. We use true as dummy value (it has no meaning)
 
 					// Add linedef flags
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.LinedefFlags)
 						config.WriteSetting("managedfields.linedef." + flag.Key, true);
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.LinedefFlags)
 						config.WriteSetting("managedfields.linedef." + flag.Key, true);
 
 					// Add linedef activations
 					foreach(LinedefActivateInfo activate in General.Map.Config.LinedefActivates)
 						config.WriteSetting("managedfields.linedef." + activate.Key, true);
 					foreach(LinedefActivateInfo activate in General.Map.Config.LinedefActivates)
 						config.WriteSetting("managedfields.linedef." + activate.Key, true);
 
 					// Add thing flags
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 						config.WriteSetting("managedfields.thing." + flag.Key, true);
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 						config.WriteSetting("managedfields.thing." + flag.Key, true);
 
 					// Done
 					udmfcfgreader.Dispose();
 					udmfcfg.Dispose();
 					break;
 				}
 			}
 			foreach(string rn in resnames)
 			{
 				// Found it?
 				if(rn.EndsWith(UDMF_CONFIG_NAME, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					Stream udmfcfg = General.ThisAssembly.GetManifestResourceStream(rn);
 					StreamReader udmfcfgreader = new StreamReader(udmfcfg, Encoding.ASCII);
 
 					// Load configuration from stream
 					config.InputConfiguration(udmfcfgreader.ReadToEnd());
 
 					// Now we add the linedef flags, activations and thing flags
 					// to this list, so that these don't show up in the custom
 					// fields list either. We use true as dummy value (it has no meaning)
 
 					// Add linedef flags
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.LinedefFlags)
 						config.WriteSetting("managedfields.linedef." + flag.Key, true);
 
 					// Add linedef activations
 					foreach(LinedefActivateInfo activate in General.Map.Config.LinedefActivates)
 						config.WriteSetting("managedfields.linedef." + activate.Key, true);
 
 					// Add thing flags
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 						config.WriteSetting("managedfields.thing." + flag.Key, true);
 
 					// Done
 					udmfcfgreader.Dispose();
 					udmfcfg.Dispose();
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipPolygon.cs" startline="116" endline="173">
<![CDATA[
 		
 		// Point inside the polygon?
 		// See
 		public bool Intersect(Vector2D p)
 		{
 			Vector2D v1 = base.Last.Value.Position;
 			Vector2D v2;
 			LinkedListNode<EarClipVertex> n = base.First;
 			uint c = 0;
 			
 			// Go for all vertices
 			while(n != null)
 			{
 				// Get next vertex
 				v2 = n.Value.Position;
 
 				// Determine min/max values
 				float miny = Math.Min(v1.y, v2.y);
 				float maxy = Math.Max(v1.y, v2.y);
 				float maxx = Math.Max(v1.x, v2.x);
 
 				// Check for intersection
 				if((p.y > miny) && (p.y <= maxy))
 				{
 					if(p.x <= maxx)
 					{
 						if(v1.y != v2.y)
 						{
 							float xint = (p.y - v1.y) * (v2.x - v1.x) / (v2.y - v1.y) + v1.x;
 							if((v1.x == v2.x) || (p.x <= xint)) c++;
 						}
 					}
 				}
 				
 				// Move to next
 				v1 = v2;
 				n = n.Next;
 			}
 			while(n != null)
 			{
 				// Get next vertex
 				v2 = n.Value.Position;
 
 				// Determine min/max values
 				float miny = Math.Min(v1.y, v2.y);
 				float maxy = Math.Max(v1.y, v2.y);
 				float maxx = Math.Max(v1.x, v2.x);
 
 				// Check for intersection
 				if((p.y > miny) && (p.y <= maxy))
 				{
 					if(p.x <= maxx)
 					{
 						if(v1.y != v2.y)
 						{
 							float xint = (p.y - v1.y) * (v2.x - v1.x) / (v2.y - v1.y) + v1.x;
 							if((v1.x == v2.x) || (p.x <= xint)) c++;
 						}
 					}
 				}
 				
 				// Move to next
 				v1 = v2;
 				n = n.Next;
 			}
 
 			// Inside this polygon?
 			if((c & 0x00000001UL) != 0)
 			{
 				// Check if not inside the children
 				foreach(EarClipPolygon child in children)
 				{
 					// Inside this child? Then it is not inside this polygon.
 					if(child.Intersect(p)) return false;
 				}
 				foreach(EarClipPolygon child in children)
 				{
 					// Inside this child? Then it is not inside this polygon.
 					if(child.Intersect(p)) return false;
 				}
 
 				// Inside polygon!
 				return true;
 			}
 			else
 			{
 				// Not inside the polygon
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1601" endline="1658">
<![CDATA[
 
 		/// <summary>
 		/// This marks all selected geometry, including sidedefs from sectors.
 		/// When sidedefsfromsectors is true, then the sidedefs are marked according to the
 		/// marked sectors. Otherwise the sidedefs are marked according to the marked linedefs.
 		/// </summary>
 		public void MarkAllSelectedGeometry(bool mark, bool linedefsfromvertices, bool verticesfromlinedefs, bool sectorsfromlinedefs, bool sidedefsfromsectors)
 		{
 			General.Map.Map.ClearAllMarks(!mark);
 
 			// Direct vertices
 			General.Map.Map.MarkSelectedVertices(true, mark);
 
 			// Direct linedefs
 			General.Map.Map.MarkSelectedLinedefs(true, mark);
 
 			// Linedefs from vertices
 			// We do this before "vertices from lines" because otherwise we get lines marked that we didn't select
 			if(linedefsfromvertices)
 			{
 				ICollection<Linedef> lines = General.Map.Map.LinedefsFromMarkedVertices(!mark, mark, !mark);
 				foreach(Linedef l in lines) l.Marked = mark;
 			}
 			
 			// Vertices from linedefs
 			if(verticesfromlinedefs)
 			{
 				ICollection<Vertex> verts = General.Map.Map.GetVerticesFromLinesMarks(mark);
 				foreach(Vertex v in verts) v.Marked = mark;
 			}
 			
 			// Mark sectors from linedefs (note
 			// sectors, because this clears the sector marks!)
 			if(sectorsfromlinedefs)
 			{
 				General.Map.Map.ClearMarkedSectors(mark);
 				foreach(Linedef l in General.Map.Map.Linedefs)
 				{
 					if(!l.Selected)
 					{
 						if(l.Front != null) l.Front.Sector.Marked = !mark;
 						if(l.Back != null) l.Back.Sector.Marked = !mark;
 					}
 				}
 				foreach(Linedef l in General.Map.Map.Linedefs)
 				{
 					if(!l.Selected)
 					{
 						if(l.Front != null) l.Front.Sector.Marked = !mark;
 						if(l.Back != null) l.Back.Sector.Marked = !mark;
 					}
 				}
 			}
 			
 			// Direct sectors
 			General.Map.Map.MarkSelectedSectors(true, mark);
 
 			// Direct things
 			General.Map.Map.MarkSelectedThings(true, mark);
 
 			// Sidedefs from linedefs or sectors
 			if(sidedefsfromsectors)
 				General.Map.Map.MarkSidedefsFromSectors(true, mark);
 			else
 				General.Map.Map.MarkSidedefsFromLinedefs(true, mark);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PreviewManager.cs" startline="113" endline="189">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Private Methods
 		
 		// This makes a preview for the given image and updates the image settings
 		private void MakeImagePreview(ImageData img)
 		{
 			int previewwidth, previewheight;
 			int imagewidth, imageheight;
 			Bitmap preview;
 			Graphics g;
 			
 			lock(img)
 			{
 				// Load image if needed
 				if(!img.IsImageLoaded) img.LoadImage();
 				if(!img.LoadFailed)
 				{
 					imagewidth = img.Width;
 					imageheight = img.Height;
 				}
 				else
 				{
 					imagewidth = img.GetBitmap().Size.Width;
 					imageheight = img.GetBitmap().Size.Height;
 				}
 				
 				// Determine preview size
 				float scalex = (img.Width > maxpreviewwidth) ? ((float)maxpreviewwidth / (float)imagewidth) 
 				float scaley = (img.Height > maxpreviewheight) ? ((float)maxpreviewheight / (float)imageheight) 
 				float scale = Math.Min(scalex, scaley);
 				previewwidth = (int)((float)imagewidth * scale);
 				previewheight = (int)((float)imageheight * scale);
 				if(previewwidth < 1) previewwidth = 1;
 				if(previewheight < 1) previewheight = 1;
 
 				// Make new image
 				preview = new Bitmap(previewwidth, previewheight, IMAGE_FORMAT);
 				g = Graphics.FromImage(preview);
 				g.PageUnit = GraphicsUnit.Pixel;
 				g.CompositingQuality = CompositingQuality.HighQuality;
 				g.InterpolationMode = InterpolationMode.HighQualityBicubic;
 				g.SmoothingMode = SmoothingMode.HighQuality;
 				g.PixelOffsetMode = PixelOffsetMode.None;
 				g.Clear(Color.Transparent);
 				
 				// Draw image onto atlas
 				Rectangle atlasrect = new Rectangle(0, 0, previewwidth, previewheight);
 				RectangleF imgrect = General.MakeZoomedRect(new Size(imagewidth, imageheight), atlasrect);
 				if(imgrect.Width < 1.0f)
 				{
 					imgrect.X -= 0.5f - imgrect.Width * 0.5f;
 					imgrect.Width = 1.0f;
 				}
 				if(imgrect.Height < 1.0f)
 				{
 					imgrect.Y -= 0.5f - imgrect.Height * 0.5f;
 					imgrect.Height = 1.0f;
 				}
 				g.DrawImage(img.GetBitmap(), imgrect);
 				g.Dispose();
 				
 				// Unload image if no longer needed
 				if(!img.IsReferenced) img.UnloadImage();
 				
 				lock(images)
 				{
 					// Set numbers
 					img.PreviewIndex = images.Count;
 					img.PreviewState = ImageLoadState.Ready;
 					
 					// Add to previews list
 					images.Add(preview);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersTabsControl.cs" startline="286" endline="298">
<![CDATA[
 		
 		// Tabs don't process keys
 		protected override void OnKeyDown(KeyEventArgs ke)
 		{
 			if(this.Parent is DockersControl)
 			{
 				// Only absorb the key press when no focused on an input control, otherwise
 				// the input controls may not receive certain keys such as delete and arrow keys
 				DockersControl docker = (this.Parent as DockersControl);
 				if(!docker.IsFocused)
 					ke.Handled = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersTabsControl.cs" startline="299" endline="311">
<![CDATA[
 		
 		// Tabs don't process keys
 		protected override void OnKeyUp(KeyEventArgs e)
 		{
 			if(this.Parent is DockersControl)
 			{
 				// Only absorb the key press when no focused on an input control, otherwise
 				// the input controls may not receive certain keys such as delete and arrow keys
 				DockersControl docker = (this.Parent as DockersControl);
 				if(!docker.IsFocused)
 					e.Handled = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ErrorsForm.cs" startline="53" endline="77">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This sets up the list
 		private void FillList()
 		{
 			// Fill the list with the items we don't have yet
 			General.ErrorLogger.HasChanged = false;
 			List<ErrorItem> errors = General.ErrorLogger.GetErrors();
 			int startindex = grid.Rows.Count;
 			for(int i = startindex; i < errors.Count; i++)
 			{
 				ErrorItem e = errors[i];
 				Image icon = (e.type == ErrorType.Error) ? Properties.Resources.ErrorLarge 
 				int index = grid.Rows.Add();
 				DataGridViewRow row = grid.Rows[index];
 				row.Cells[0].Value = icon;
 				row.Cells[0].Style.Alignment = DataGridViewContentAlignment.TopCenter;
 				row.Cells[0].Style.Padding = new Padding(0, 5, 0, 0);
 				row.Cells[1].Value = e.message;
 				row.Cells[1].Style.WrapMode = DataGridViewTriState.True;
 			}
 			for(int i = startindex; i < errors.Count; i++)
 			{
 				ErrorItem e = errors[i];
 				Image icon = (e.type == ErrorType.Error) ? Properties.Resources.ErrorLarge 
 				int index = grid.Rows.Add();
 				DataGridViewRow row = grid.Rows[index];
 				row.Cells[0].Value = icon;
 				row.Cells[0].Style.Alignment = DataGridViewContentAlignment.TopCenter;
 				row.Cells[0].Style.Padding = new Padding(0, 5, 0, 0);
 				row.Cells[1].Value = e.message;
 				row.Cells[1].Style.WrapMode = DataGridViewTriState.True;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1580" endline="1600">
<![CDATA[
 
 		/// <summary>
 		/// Returns a collection of vertices that match a marked state on the linedefs.
 		/// </summary>
 		public ICollection<Vertex> GetVerticesFromSectorsMarks(bool mark)
 		{
 			List<Vertex> list = new List<Vertex>(numvertices >> 1);
 			foreach(Vertex v in vertices)
 			{
 				foreach(Linedef l in v.Linedefs)
 				{
 					if(((l.Front != null) && (l.Front.Sector.Marked == mark)) ||
 						((l.Back != null) && (l.Back.Sector.Marked == mark)))
 					{
 						list.Add(v);
 						break;
 					}
 				}
 				foreach(Linedef l in v.Linedefs)
 				{
 					if(((l.Front != null) && (l.Front.Sector.Marked == mark)) ||
 						((l.Back != null) && (l.Back.Sector.Marked == mark)))
 					{
 						list.Add(v);
 						break;
 					}
 				}
 			}
 			foreach(Vertex v in vertices)
 			{
 				foreach(Linedef l in v.Linedefs)
 				{
 					if(((l.Front != null) && (l.Front.Sector.Marked == mark)) ||
 						((l.Back != null) && (l.Back.Sector.Marked == mark)))
 					{
 						list.Add(v);
 						break;
 					}
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1249" endline="1273">
<![CDATA[
 
 		/// <summary>Returns a collection of sidedefs that match a selected linedefs state.</summary>
 		public ICollection<Sidedef> GetSidedefsFromSelectedLinedefs(bool selected)
 		{
 			if(selected)
 			{
 				List<Sidedef> list = new List<Sidedef>(sel_linedefs.Count);
 				foreach(Linedef ld in sel_linedefs)
 				{
 					if(ld.Front != null) list.Add(ld.Front);
 					if(ld.Back != null) list.Add(ld.Back);
 				}
 				foreach(Linedef ld in sel_linedefs)
 				{
 					if(ld.Front != null) list.Add(ld.Front);
 					if(ld.Back != null) list.Add(ld.Back);
 				}
 				return list;
 			}
 			else
 			{
 				List<Sidedef> list = new List<Sidedef>(numlinedefs - sel_linedefs.Count);
 				foreach(Linedef ld in linedefs)
 				{
 					if(!ld.Selected && (ld.Front != null)) list.Add(ld.Front);
 					if(!ld.Selected && (ld.Back != null)) list.Add(ld.Back);
 				}
 				foreach(Linedef ld in linedefs)
 				{
 					if(!ld.Selected && (ld.Front != null)) list.Add(ld.Front);
 					if(!ld.Selected && (ld.Back != null)) list.Add(ld.Back);
 				}
 				return list;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="438" endline="489">
<![CDATA[
 
 		// This writes the THINGS to WAD file
 		private void WriteThings(MapSet map, int position, IDictionary maplumps)
 		{
 			MemoryStream mem;
 			BinaryWriter writer;
 			Lump lump;
 			int insertpos;
 			int flags;
 			
 			// Create memory to write to
 			mem = new MemoryStream();
 			writer = new BinaryWriter(mem, WAD.ENCODING);
 			
 			// Go for all things
 			foreach(Thing t in map.Things)
 			{
 				// Convert flags
 				flags = 0;
 				foreach(KeyValuePair<string, bool> f in t.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 				foreach(KeyValuePair<string, bool> f in t.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 
 				// Write properties to stream
 				// Write properties to stream
 				writer.Write((UInt16)t.Tag);
 				writer.Write((Int16)t.Position.x);
 				writer.Write((Int16)t.Position.y);
 				writer.Write((Int16)t.Position.z);
 				writer.Write((Int16)t.AngleDoom);
 				writer.Write((UInt16)t.Type);
 				writer.Write((UInt16)flags);
 				writer.Write((Byte)t.Action);
 				writer.Write((Byte)t.Args[0]);
 				writer.Write((Byte)t.Args[1]);
 				writer.Write((Byte)t.Args[2]);
 				writer.Write((Byte)t.Args[3]);
 				writer.Write((Byte)t.Args[4]);
 			}
 			foreach(Thing t in map.Things)
 			{
 				// Convert flags
 				flags = 0;
 				foreach(KeyValuePair<string, bool> f in t.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 
 				// Write properties to stream
 				// Write properties to stream
 				writer.Write((UInt16)t.Tag);
 				writer.Write((Int16)t.Position.x);
 				writer.Write((Int16)t.Position.y);
 				writer.Write((Int16)t.Position.z);
 				writer.Write((Int16)t.AngleDoom);
 				writer.Write((UInt16)t.Type);
 				writer.Write((UInt16)flags);
 				writer.Write((Byte)t.Action);
 				writer.Write((Byte)t.Args[0]);
 				writer.Write((Byte)t.Args[1]);
 				writer.Write((Byte)t.Args[2]);
 				writer.Write((Byte)t.Args[3]);
 				writer.Write((Byte)t.Args[4]);
 			}
 			
 			// Find insert position and remove old lump
 			insertpos = MapManager.RemoveSpecificLump(wad, "THINGS", position, MapManager.TEMP_MAP_HEADER, maplumps);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 			
 			// Create the lump from memory
 			lump = wad.Insert("THINGS", insertpos, (int)mem.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			mem.WriteTo(lump.Stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="154" endline="239">
<![CDATA[
 		
 		// This sets up the fields and values from a UniFields object
 		// When first is true, the values are applied unconditionally
 		// When first is false, the values in the grid are erased when
 		// they differ from the given values (for multiselection)
 		public void SetValues(UniFields fromfields, bool first)
 		{
 			// Go for all the fields
 			foreach(KeyValuePair<string, UniValue> f in fromfields)
 			{
 				// Go for all rows
 				bool foundrow = false;
 				foreach(DataGridViewRow row in fieldslist.Rows)
 				{
 					// Row is a field?
 					if(row is FieldsEditorRow)
 					{
 						FieldsEditorRow frow = row as FieldsEditorRow;
 						
 						// Row name matches with field
 						if(frow.Name == f.Key)
 						{
 							// First time?
 							if(first)
 							{
 								// Set type when row is not fixed
 								if(!frow.IsFixed) frow.ChangeType(f.Value.Type);
 
 								// Apply value of field to row
 								frow.Define(f.Value.Value);
 							}
 							else
 							{
 								// Check if the value is different
 								if(!frow.TypeHandler.GetValue().Equals(f.Value.Value))
 								{
 									// Clear the value in the row
 									frow.Define(f.Value.Value);
 									frow.Clear();
 								}
 							}
 							
 							// Done
 							foundrow = true;
 							break;
 						}
 					}
 				}
 				foreach(DataGridViewRow row in fieldslist.Rows)
 				{
 					// Row is a field?
 					if(row is FieldsEditorRow)
 					{
 						FieldsEditorRow frow = row as FieldsEditorRow;
 						
 						// Row name matches with field
 						if(frow.Name == f.Key)
 						{
 							// First time?
 							if(first)
 							{
 								// Set type when row is not fixed
 								if(!frow.IsFixed) frow.ChangeType(f.Value.Type);
 
 								// Apply value of field to row
 								frow.Define(f.Value.Value);
 							}
 							else
 							{
 								// Check if the value is different
 								if(!frow.TypeHandler.GetValue().Equals(f.Value.Value))
 								{
 									// Clear the value in the row
 									frow.Define(f.Value.Value);
 									frow.Clear();
 								}
 							}
 							
 							// Done
 							foundrow = true;
 							break;
 						}
 					}
 				}
 				
 				// Row not found?
 				if(!foundrow)
 				{
 					// Make new row
 					FieldsEditorRow frow = new FieldsEditorRow(fieldslist, f.Key, f.Value.Type, f.Value.Value);
 					fieldslist.Rows.Insert(fieldslist.Rows.Count - 1, frow);
 					
 					// When not the first, clear the field
 					// because the others did not define this one
 					if(!first) frow.Clear();
 				}
 			}
 			foreach(KeyValuePair<string, UniValue> f in fromfields)
 			{
 				// Go for all rows
 				bool foundrow = false;
 				foreach(DataGridViewRow row in fieldslist.Rows)
 				{
 					// Row is a field?
 					if(row is FieldsEditorRow)
 					{
 						FieldsEditorRow frow = row as FieldsEditorRow;
 						
 						// Row name matches with field
 						if(frow.Name == f.Key)
 						{
 							// First time?
 							if(first)
 							{
 								// Set type when row is not fixed
 								if(!frow.IsFixed) frow.ChangeType(f.Value.Type);
 
 								// Apply value of field to row
 								frow.Define(f.Value.Value);
 							}
 							else
 							{
 								// Check if the value is different
 								if(!frow.TypeHandler.GetValue().Equals(f.Value.Value))
 								{
 									// Clear the value in the row
 									frow.Define(f.Value.Value);
 									frow.Clear();
 								}
 							}
 							
 							// Done
 							foundrow = true;
 							break;
 						}
 					}
 				}
 				
 				// Row not found?
 				if(!foundrow)
 				{
 					// Make new row
 					FieldsEditorRow frow = new FieldsEditorRow(fieldslist, f.Key, f.Value.Type, f.Value.Value);
 					fieldslist.Rows.Insert(fieldslist.Rows.Count - 1, frow);
 					
 					// When not the first, clear the field
 					// because the others did not define this one
 					if(!first) frow.Clear();
 				}
 			}
 			
 			// Now check for rows that the givens fields do NOT have
 			foreach(DataGridViewRow row in fieldslist.Rows)
 			{
 				// Row is a field?
 				if(row is FieldsEditorRow)
 				{
 					FieldsEditorRow frow = row as FieldsEditorRow;
 
 					// Is this row defined previously?
 					if(frow.IsDefined)
 					{
 						// Check if this row can not be found in the fields at all
 						if(!fromfields.ContainsKey(frow.Name))
 						{
 							// It is not defined in these fields, clear the value
 							frow.Clear();
 						}
 					}
 				}
 			}
 			foreach(DataGridViewRow row in fieldslist.Rows)
 			{
 				// Row is a field?
 				if(row is FieldsEditorRow)
 				{
 					FieldsEditorRow frow = row as FieldsEditorRow;
 
 					// Is this row defined previously?
 					if(frow.IsDefined)
 					{
 						// Check if this row can not be found in the fields at all
 						if(!fromfields.ContainsKey(frow.Name))
 						{
 							// It is not defined in these fields, clear the value
 							frow.Clear();
 						}
 					}
 				}
 			}
 			
 			// Sort fields
 			Sort();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.cs" startline="124" endline="190">
<![CDATA[
 		
 		// This removes empty items and makes others uppercase
 		private void filterstimer_Tick(object sender, EventArgs e)
 		{
 			// Stop timer
 			filterstimer.Stop();
 			
 			// Update labels
 			for(int i = filters.Items.Count - 1; i >= 0; i--)
 			{
 				// Empty label?
 				if((filters.Items[i].Text == null) ||
 				   (filters.Items[i].Text.Trim().Length == 0))
 				{
 					// Remove it
 					filters.Items.RemoveAt(i);
 				}
 				else
 				{
 					// Make uppercase
 					filters.Items[i].Text = filters.Items[i].Text.ToUpperInvariant();
 				}
 			}
 			for(int i = filters.Items.Count - 1; i >= 0; i--)
 			{
 				// Empty label?
 				if((filters.Items[i].Text == null) ||
 				   (filters.Items[i].Text.Trim().Length == 0))
 				{
 					// Remove it
 					filters.Items.RemoveAt(i);
 				}
 				else
 				{
 					// Make uppercase
 					filters.Items[i].Text = filters.Items[i].Text.ToUpperInvariant();
 				}
 			}
 			
 			// Show example results if when we can
 			if(General.Map != null)
 			{
 				Cursor.Current = Cursors.AppStarting;
 				
 				// Make a set for comparing
 				List<string> filterslist = new List<string>(filters.Items.Count);
 				foreach(ListViewItem i in filters.Items) filterslist.Add(i.Text);
 				MatchingTextureSet set = new MatchingTextureSet(filterslist);
 				
 				// Determine tooltip text
 				string tooltiptext = null;
 				if(nomatchesbutton.Checked) tooltiptext = "Doubleclick to include this texture";
 				
 				// Start adding
 				matcheslist.PreventSelection = matchesbutton.Checked;
 				matcheslist.BeginAdding(true);
 				
 				// Go for all textures
 				foreach(ImageData img in General.Map.Data.Textures)
 				{
 					bool ismatch = set.IsMatch(img);
 					if((ismatch && matchesbutton.Checked) || (!ismatch && nomatchesbutton.Checked))
 						matcheslist.Add(img.Name, img, img, null, tooltiptext);
 				}
 				foreach(ImageData img in General.Map.Data.Textures)
 				{
 					bool ismatch = set.IsMatch(img);
 					if((ismatch && matchesbutton.Checked) || (!ismatch && nomatchesbutton.Checked))
 						matcheslist.Add(img.Name, img, img, null, tooltiptext);
 				}
 				
 				// If not already mixed, add flats as well
 				if(!General.Map.Config.MixTexturesFlats)
 				{
 					// Go for all flats
 					foreach(ImageData img in General.Map.Data.Flats)
 					{
 						bool ismatch = set.IsMatch(img);
 						if((ismatch && matchesbutton.Checked) || (!ismatch && nomatchesbutton.Checked))
 							matcheslist.Add(img.Name, img, img, null, tooltiptext);
 					}
 					foreach(ImageData img in General.Map.Data.Flats)
 					{
 						bool ismatch = set.IsMatch(img);
 						if((ismatch && matchesbutton.Checked) || (!ismatch && nomatchesbutton.Checked))
 							matcheslist.Add(img.Name, img, img, null, tooltiptext);
 					}
 				}
 				
 				// Done adding
 				matcheslist.EndAdding();
 				Cursor.Current = Cursors.Default;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="71" endline="147">
<![CDATA[
 		
 		// This initializes the control
 		public void Initialize()
 		{
 			ToolStripMenuItem item;
 			
 			// Make list of script configs
 			scriptconfigs = new List<ScriptConfiguration>(General.ScriptConfigs.Values);
 			scriptconfigs.Add(new ScriptConfiguration());
 			scriptconfigs.Sort();
 			
 			// Fill the list of new document types
 			foreach(ScriptConfiguration cfg in scriptconfigs)
 			{
 				// Button for new script menu
 				item = new ToolStripMenuItem(cfg.Description);
 				//item.Image = buttonnew.Image;
 				item.Tag = cfg;
 				item.Click += new EventHandler(buttonnew_Click);
 				buttonnew.DropDownItems.Add(item);
 				
 				// Button for script type menu
 				item = new ToolStripMenuItem(cfg.Description);
 				//item.Image = buttonnew.Image;
 				item.Tag = cfg;
 				item.Click += new EventHandler(buttonscriptconfig_Click);
 				buttonscriptconfig.DropDownItems.Add(item);
 			}
 			foreach(ScriptConfiguration cfg in scriptconfigs)
 			{
 				// Button for new script menu
 				item = new ToolStripMenuItem(cfg.Description);
 				//item.Image = buttonnew.Image;
 				item.Tag = cfg;
 				item.Click += new EventHandler(buttonnew_Click);
 				buttonnew.DropDownItems.Add(item);
 				
 				// Button for script type menu
 				item = new ToolStripMenuItem(cfg.Description);
 				//item.Image = buttonnew.Image;
 				item.Tag = cfg;
 				item.Click += new EventHandler(buttonscriptconfig_Click);
 				buttonscriptconfig.DropDownItems.Add(item);
 			}
 			
 			// Setup supported extensions
 			string filterall = "";
 			string filterseperate = "";
 			foreach(ScriptConfiguration cfg in scriptconfigs)
 			{
 				if(cfg.Extensions.Length > 0)
 				{
 					string exts = "*." + string.Join(";*.", cfg.Extensions);
 					if(filterseperate.Length > 0) filterseperate += "|";
 					filterseperate += cfg.Description + "|" + exts;
 					if(filterall.Length > 0) filterall += ";";
 					filterall += exts;
 				}
 			}
 			foreach(ScriptConfiguration cfg in scriptconfigs)
 			{
 				if(cfg.Extensions.Length > 0)
 				{
 					string exts = "*." + string.Join(";*.", cfg.Extensions);
 					if(filterseperate.Length > 0) filterseperate += "|";
 					filterseperate += cfg.Description + "|" + exts;
 					if(filterall.Length > 0) filterall += ";";
 					filterall += exts;
 				}
 			}
 			openfile.Filter = "Script files|" + filterall + "|" + filterseperate + "|All files|*.*";
 			
 			// Load the script lumps
 			foreach(MapLumpInfo maplumpinfo in General.Map.Config.MapLumps.Values)
 			{
 				// Is this a script lump?
 				if(maplumpinfo.script != null)
 				{
 					// Load this!
 					ScriptLumpDocumentTab t = new ScriptLumpDocumentTab(this, maplumpinfo.name, maplumpinfo.script);
 					tabs.TabPages.Add(t);
 				}
 			}
 			foreach(MapLumpInfo maplumpinfo in General.Map.Config.MapLumps.Values)
 			{
 				// Is this a script lump?
 				if(maplumpinfo.script != null)
 				{
 					// Load this!
 					ScriptLumpDocumentTab t = new ScriptLumpDocumentTab(this, maplumpinfo.name, maplumpinfo.script);
 					tabs.TabPages.Add(t);
 				}
 			}
 
 			// Load the files that were previously opened for this map
 			foreach(String filename in General.Map.Options.ScriptFiles)
 			{
 				// Does this file exist?
 				if(File.Exists(filename))
 				{
 					// Load this!
 					OpenFile(filename);
 				}
 			}
 			foreach(String filename in General.Map.Options.ScriptFiles)
 			{
 				// Does this file exist?
 				if(File.Exists(filename))
 				{
 					// Load this!
 					OpenFile(filename);
 				}
 			}
 
 			// Select the first tab
 			if(tabs.TabPages.Count > 0) tabs.SelectedIndex = 0;
 			
 			// If the map has remembered any compile errors, then show them
 			ShowErrors(General.Map.Errors);
 			
 			// Done
 			UpdateToolbar(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MapOptionsForm.cs" startline="80" endline="194">
<![CDATA[
 
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			Configuration newcfg;
 			WAD sourcewad;
 			bool conflictingname;
 			
 			// Configuration selected?
 			if(config.SelectedIndex == -1)
 			{
 				// Select a configuration!
 				MessageBox.Show(this, "Please select a game configuration to use for editing your map.", Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Warning);
 				config.Focus();
 				return;
 			}
 			
 			// Level name empty?
 			if(levelname.Text.Length == 0)
 			{
 				// Enter a level name!
 				MessageBox.Show(this, "Please enter a level name for your map.", Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Warning);
 				levelname.Focus();
 				return;
 			}
 
 			// Collect information
 			ConfigurationInfo configinfo = General.Configs[config.SelectedIndex];
 			DataLocationList locations = datalocations.GetResources();
 			
 			// When making a new map, check if we should warn the user for missing resources
 			if(newmap && (locations.Count == 0) && (configinfo.Resources.Count == 0))
 			{
 				if(MessageBox.Show(this, "You are about to make a map without selecting any resources. Textures, flats and " +
 										 "sprites may not be shown correctly or may not show up at all. Do you want to continue?", Application.ProductName,
 										 MessageBoxButtons.YesNo, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button2) == DialogResult.No)
 				{
 					return;
 				}
 			}
 
 			// Next checks are only for maps that are already opened
 			if(!newmap)
 			{
 				// Now we check if the map name the user has given does already exist in the source WAD file
 				// We have to warn the user about that, because it would create a level name conflict in the WAD
 
 				// Level name changed and the map exists in a source wad?
 				if((levelname.Text != options.CurrentName) && (General.Map != null) &&
 				   (General.Map.FilePathName != "") && File.Exists(General.Map.FilePathName))
 				{
 					// Open the source wad file to check for conflicting name
 					sourcewad = new WAD(General.Map.FilePathName, true);
 					conflictingname = (sourcewad.FindLumpIndex(levelname.Text) > -1);
 					sourcewad.Dispose();
 
 					// Names conflict?
 					if(conflictingname)
 					{
 						// Show warning!
 						if(General.ShowWarningMessage("The map name \"" + levelname.Text + "\" is already in use by another map or data lump in the source WAD file. Saving your map with this name will cause conflicting data lumps in the WAD file. Do you want to continue?", MessageBoxButtons.YesNo, MessageBoxDefaultButton.Button2) == DialogResult.No)
 						{
 							return;
 						}
 					}
 				}
 
 				// When the user changed the configuration to one that has a different read/write interface,
 				// we have to warn the user that the map may not be compatible.
 				
 				// Configuration changed?
 				if((options.ConfigFile != "") && (General.Configs[config.SelectedIndex].Filename != options.ConfigFile))
 				{
 					// Load the new cfg file
 					newcfg = General.LoadGameConfiguration(General.Configs[config.SelectedIndex].Filename);
 					if(newcfg == null) return;
 
 					// Check if the config uses a different IO interface
 					if(newcfg.ReadSetting("formatinterface", "") != General.Map.Config.FormatInterface)
 					{
 						// Warn the user about IO interface change
 						if(General.ShowWarningMessage("The game configuration you selected uses a different file format than your current map. Because your map was not designed for this format it may cause the map to work incorrectly in the game. Do you want to continue?", MessageBoxButtons.YesNo, MessageBoxDefaultButton.Button2) == DialogResult.No)
 						{
 							// Reset to old configuration
 							for(int i = 0; i < config.Items.Count; i++)
 							{
 								// Is this configuration the old config?
 								if(string.Compare(General.Configs[i].Filename, options.ConfigFile, true) == 0)
 								{
 									// Select this item
 									config.SelectedIndex = i;
 								}
 							}
 							for(int i = 0; i < config.Items.Count; i++)
 							{
 								// Is this configuration the old config?
 								if(string.Compare(General.Configs[i].Filename, options.ConfigFile, true) == 0)
 								{
 									// Select this item
 									config.SelectedIndex = i;
 								}
 							}
 							return;
 						}
 					}
 				}
 			}
 			
 			// Apply changes
 			options.ClearResources();
 			options.ConfigFile = General.Configs[config.SelectedIndex].Filename;
 			options.CurrentName = levelname.Text.Trim().ToUpper();
 			options.StrictPatches = strictpatches.Checked;
 			options.CopyResources(datalocations.GetResources());
 
 			// Reset default drawing textures
 			General.Settings.DefaultTexture = null;
 			General.Settings.DefaultFloorTexture = null;
 			General.Settings.DefaultCeilingTexture = null;
 			
 			// Hide window
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="140" endline="151">
<![CDATA[
 
 		// This returns a list of all files that are in the given path and subdirectories and have the given title
 		public List<string> GetAllFilesWithTitle(string path, string title)
 		{
 			path = CorrectPath(path).ToLowerInvariant();
 			title = title.ToLowerInvariant();
 			List<string> files = new List<string>(entries.Length);
 			for(int i = 0; i < entries.Length; i++)
 				if(entries[i].path.StartsWith(path) && (entries[i].filetitle == title))
 					files.Add(entries[i].filepathname);
 			for(int i = 0; i < entries.Length; i++)
 				if(entries[i].path.StartsWith(path) && (entries[i].filetitle == title))
 					files.Add(entries[i].filepathname);
 			return files;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="169" endline="180">
<![CDATA[
 
 		// This returns a list of all files that are in the given path and subdirectories and have the given extension
 		public List<string> GetAllFiles(string path, string extension)
 		{
 			path = CorrectPath(path).ToLowerInvariant();
 			extension = extension.ToLowerInvariant();
 			List<string> files = new List<string>(entries.Length);
 			for(int i = 0; i < entries.Length; i++)
 				if(entries[i].path.StartsWith(path) && (entries[i].extension == extension))
 					files.Add(entries[i].filepathname);
 			for(int i = 0; i < entries.Length; i++)
 				if(entries[i].path.StartsWith(path) && (entries[i].extension == extension))
 					files.Add(entries[i].filepathname);
 			return files;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="509" endline="522">
<![CDATA[
 		
 		// This returns a nodebuilder by name
 		internal static NodebuilderInfo GetNodebuilderByName(string name)
 		{
 			// Go for all nodebuilders
 			foreach(NodebuilderInfo n in nodebuilders)
 			{
 				// Name matches?
 				if(n.Name == name) return n;
 			}
 			foreach(NodebuilderInfo n in nodebuilders)
 			{
 				// Name matches?
 				if(n.Name == name) return n;
 			}
 
 			// Cannot find that nodebuilder
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="1659" endline="1690">
<![CDATA[
 
 		// This adds the matching, unmarked sidedefs from a vertex for texture alignment
 		private static void AddSidedefsForAlignment(Stack<SidedefAlignJob> stack, Vertex v, bool forward, int offsetx, long texturelongname)
 		{
 			foreach(Linedef ld in v.Linedefs)
 			{
 				Sidedef side1 = forward ? ld.Front 
 				Sidedef side2 = forward ? ld.Back 
 				if((ld.Start == v) && (side1 != null) && !side1.Marked)
 				{
 					if(SidedefTextureMatch(side1, texturelongname))
 					{
 						SidedefAlignJob nj = new SidedefAlignJob();
 						nj.forward = forward;
 						nj.offsetx = offsetx;
 						nj.sidedef = side1;
 						stack.Push(nj);
 					}
 				}
 				else if((ld.End == v) && (side2 != null) && !side2.Marked)
 				{
 					if(SidedefTextureMatch(side2, texturelongname))
 					{
 						SidedefAlignJob nj = new SidedefAlignJob();
 						nj.forward = forward;
 						nj.offsetx = offsetx;
 						nj.sidedef = side2;
 						stack.Push(nj);
 					}
 				}
 			}
 			foreach(Linedef ld in v.Linedefs)
 			{
 				Sidedef side1 = forward ? ld.Front 
 				Sidedef side2 = forward ? ld.Back 
 				if((ld.Start == v) && (side1 != null) && !side1.Marked)
 				{
 					if(SidedefTextureMatch(side1, texturelongname))
 					{
 						SidedefAlignJob nj = new SidedefAlignJob();
 						nj.forward = forward;
 						nj.offsetx = offsetx;
 						nj.sidedef = side1;
 						stack.Push(nj);
 					}
 				}
 				else if((ld.End == v) && (side2 != null) && !side2.Marked)
 				{
 					if(SidedefTextureMatch(side2, texturelongname))
 					{
 						SidedefAlignJob nj = new SidedefAlignJob();
 						nj.forward = forward;
 						nj.offsetx = offsetx;
 						nj.sidedef = side2;
 						stack.Push(nj);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1510" endline="1524">
<![CDATA[
 
 		/// <summary>
 		/// This marks the front and back sidedefs on linedefs with the matching mark.
 		/// </summary>
 		public void MarkSidedefsFromLinedefs(bool matchmark, bool setmark)
 		{
 			foreach(Linedef l in linedefs)
 			{
 				if(l.Marked == matchmark)
 				{
 					if(l.Front != null) l.Front.Marked = setmark;
 					if(l.Back != null) l.Back.Marked = setmark;
 				}
 			}
 			foreach(Linedef l in linedefs)
 			{
 				if(l.Marked == matchmark)
 				{
 					if(l.Front != null) l.Front.Marked = setmark;
 					if(l.Back != null) l.Back.Marked = setmark;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="599" endline="639">
<![CDATA[
 
 		// This will end active actions for which the pressed keys do not match
 		// Returns true when actions have been ended
 		private bool EndActiveActions()
 		{
 			bool listchanged;
 			bool actionsended = false;
 			
 			do
 			{
 				// Go for all active actions
 				listchanged = false;
 				for(int i = 0; i < activeactions.Count; i++)
 				{
 					Action a = activeactions[i];
 					
 					// Go for all pressed keys
 					bool stillactive = false;
 					foreach(int k in pressedkeys)
 					{
 						if((k == (int)Keys.ShiftKey) || (k == (int)Keys.ControlKey))
 							stillactive |= a.KeyMatches(k);
 						else
 							stillactive |= a.KeyMatches(k | modifiers);
 					}
 					foreach(int k in pressedkeys)
 					{
 						if((k == (int)Keys.ShiftKey) || (k == (int)Keys.ControlKey))
 							stillactive |= a.KeyMatches(k);
 						else
 							stillactive |= a.KeyMatches(k | modifiers);
 					}
 
 					// End the action if no longer matches any of the keys
 					if(!stillactive)
 					{
 						actionsended = true;
 						activeactions.RemoveAt(i);
 						listchanged = true;
 						a.End();
 						break;
 					}
 				}
 				for(int i = 0; i < activeactions.Count; i++)
 				{
 					Action a = activeactions[i];
 					
 					// Go for all pressed keys
 					bool stillactive = false;
 					foreach(int k in pressedkeys)
 					{
 						if((k == (int)Keys.ShiftKey) || (k == (int)Keys.ControlKey))
 							stillactive |= a.KeyMatches(k);
 						else
 							stillactive |= a.KeyMatches(k | modifiers);
 					}
 
 					// End the action if no longer matches any of the keys
 					if(!stillactive)
 					{
 						actionsended = true;
 						activeactions.RemoveAt(i);
 						listchanged = true;
 						a.End();
 						break;
 					}
 				}
 			}
 			while(listchanged);
 
 			return actionsended;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="1534" endline="1563">
<![CDATA[
 
 		// This adds the matching, unmarked sidedefs from a vertex for texture alignment
 		private static void AddSidedefsForFloodfill(Stack<SidedefFillJob> stack, Vertex v, bool forward, long texturelongname)
 		{
 			foreach(Linedef ld in v.Linedefs)
 			{
 				Sidedef side1 = forward ? ld.Front 
 				Sidedef side2 = forward ? ld.Back 
 				if((ld.Start == v) && (side1 != null) && !side1.Marked)
 				{
 					if(SidedefTextureMatch(side1, texturelongname))
 					{
 						SidedefFillJob nj = new SidedefFillJob();
 						nj.forward = forward;
 						nj.sidedef = side1;
 						stack.Push(nj);
 					}
 				}
 				else if((ld.End == v) && (side2 != null) && !side2.Marked)
 				{
 					if(SidedefTextureMatch(side2, texturelongname))
 					{
 						SidedefFillJob nj = new SidedefFillJob();
 						nj.forward = forward;
 						nj.sidedef = side2;
 						stack.Push(nj);
 					}
 				}
 			}
 			foreach(Linedef ld in v.Linedefs)
 			{
 				Sidedef side1 = forward ? ld.Front 
 				Sidedef side2 = forward ? ld.Back 
 				if((ld.Start == v) && (side1 != null) && !side1.Marked)
 				{
 					if(SidedefTextureMatch(side1, texturelongname))
 					{
 						SidedefFillJob nj = new SidedefFillJob();
 						nj.forward = forward;
 						nj.sidedef = side1;
 						stack.Push(nj);
 					}
 				}
 				else if((ld.End == v) && (side2 != null) && !side2.Marked)
 				{
 					if(SidedefTextureMatch(side2, texturelongname))
 					{
 						SidedefFillJob nj = new SidedefFillJob();
 						nj.forward = forward;
 						nj.sidedef = side2;
 						stack.Push(nj);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="240" endline="301">
<![CDATA[
 		
 		// This applies the current fields to a UniFields object
 		public void Apply(UniFields tofields)
 		{
 			tofields.BeforeFieldsChange();
 			
 			// Go for all the fields
 			UniFields tempfields = new UniFields(tofields);
 			foreach(KeyValuePair<string, UniValue> f in tempfields)
 			{
 				// Go for all rows
 				bool foundrow = false;
 				foreach(DataGridViewRow row in fieldslist.Rows)
 				{
 					// Row is a field and matches field name?
 					if((row is FieldsEditorRow) && (row.Cells[0].Value.ToString() == f.Key))
 					{
 						FieldsEditorRow frow = row as FieldsEditorRow;
 
 						// Field is defined?
 						if(frow.IsDefined)
 						{
 							foundrow = true;
 							break;
 						}
 					}
 				}
 				foreach(DataGridViewRow row in fieldslist.Rows)
 				{
 					// Row is a field and matches field name?
 					if((row is FieldsEditorRow) && (row.Cells[0].Value.ToString() == f.Key))
 					{
 						FieldsEditorRow frow = row as FieldsEditorRow;
 
 						// Field is defined?
 						if(frow.IsDefined)
 						{
 							foundrow = true;
 							break;
 						}
 					}
 				}
 
 				// No such row?
 				if(!foundrow)
 				{
 					// Remove the definition from the fields
 					tofields.Remove(f.Key);
 				}
 			}
 			foreach(KeyValuePair<string, UniValue> f in tempfields)
 			{
 				// Go for all rows
 				bool foundrow = false;
 				foreach(DataGridViewRow row in fieldslist.Rows)
 				{
 					// Row is a field and matches field name?
 					if((row is FieldsEditorRow) && (row.Cells[0].Value.ToString() == f.Key))
 					{
 						FieldsEditorRow frow = row as FieldsEditorRow;
 
 						// Field is defined?
 						if(frow.IsDefined)
 						{
 							foundrow = true;
 							break;
 						}
 					}
 				}
 
 				// No such row?
 				if(!foundrow)
 				{
 					// Remove the definition from the fields
 					tofields.Remove(f.Key);
 				}
 			}
 			
 			// Go for all rows
 			foreach(DataGridViewRow row in fieldslist.Rows)
 			{
 				// Row is a field?
 				if(row is FieldsEditorRow)
 				{
 					FieldsEditorRow frow = row as FieldsEditorRow;
 					
 					// Field is defined and not empty?
 					if(frow.IsDefined && !frow.IsEmpty)
 					{
 						// Apply field
 						object oldvalue = null;
 						if(tofields.ContainsKey(frow.Name)) oldvalue = tofields[frow.Name].Value;
 						tofields[frow.Name] = new UniValue(frow.TypeHandler.Index, frow.GetResult(oldvalue));
 
 						// Custom row?
 						if(!frow.IsFixed)
 						{
 							// Write type to map configuration
 							General.Map.Options.SetUniversalFieldType(elementname, frow.Name, frow.TypeHandler.Index);
 						}
 					}
 				}
 			}
 			foreach(DataGridViewRow row in fieldslist.Rows)
 			{
 				// Row is a field?
 				if(row is FieldsEditorRow)
 				{
 					FieldsEditorRow frow = row as FieldsEditorRow;
 					
 					// Field is defined and not empty?
 					if(frow.IsDefined && !frow.IsEmpty)
 					{
 						// Apply field
 						object oldvalue = null;
 						if(tofields.ContainsKey(frow.Name)) oldvalue = tofields[frow.Name].Value;
 						tofields[frow.Name] = new UniValue(frow.TypeHandler.Index, frow.GetResult(oldvalue));
 
 						// Custom row?
 						if(!frow.IsFixed)
 						{
 							// Write type to map configuration
 							General.Map.Options.SetUniversalFieldType(elementname, frow.Name, frow.TypeHandler.Index);
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamReader.cs" startline="48" endline="117">
<![CDATA[
 		private bool strictchecking = true;
 		
 		#endregion
 
 		#region ================== Properties
 
 		public bool SetKnownCustomTypes { get { return setknowncustomtypes; } set { setknowncustomtypes = value; } }
 		public bool StrictChecking { get { return strictchecking; } set { strictchecking = value; } }
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public UniversalStreamReader()
 		{
 			// Make configuration
 			config = new Configuration();
 			
 			// Find a resource named UDMF.cfg
 			string[] resnames = General.ThisAssembly.GetManifestResourceNames();
 			foreach(string rn in resnames)
 			{
 				// Found it?
 				if(rn.EndsWith(UDMF_CONFIG_NAME, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					Stream udmfcfg = General.ThisAssembly.GetManifestResourceStream(rn);
 					StreamReader udmfcfgreader = new StreamReader(udmfcfg, Encoding.ASCII);
 
 					// Load configuration from stream
 					config.InputConfiguration(udmfcfgreader.ReadToEnd());
 
 					// Now we add the linedef flags, activations and thing flags
 					// to this list, so that these don't show up in the custom
 					// fields list either. We use true as dummy value (it has no meaning)
 
 					// Add linedef flags
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.LinedefFlags)
 						config.WriteSetting("managedfields.linedef." + flag.Key, true);
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.LinedefFlags)
 						config.WriteSetting("managedfields.linedef." + flag.Key, true);
 
 					// Add linedef activations
 					foreach(LinedefActivateInfo activate in General.Map.Config.LinedefActivates)
 						config.WriteSetting("managedfields.linedef." + activate.Key, true);
 					foreach(LinedefActivateInfo activate in General.Map.Config.LinedefActivates)
 						config.WriteSetting("managedfields.linedef." + activate.Key, true);
 					
 					// Add linedef flag translations
 					foreach(FlagTranslation f in General.Map.Config.LinedefFlagsTranslation)
 					{
 						foreach(string fn in f.Fields)
 							config.WriteSetting("managedfields.linedef." + fn, true);
 						foreach(string fn in f.Fields)
 							config.WriteSetting("managedfields.linedef." + fn, true);
 					}
 					foreach(FlagTranslation f in General.Map.Config.LinedefFlagsTranslation)
 					{
 						foreach(string fn in f.Fields)
 							config.WriteSetting("managedfields.linedef." + fn, true);
 					}
 
 					// Add thing flags
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 						config.WriteSetting("managedfields.thing." + flag.Key, true);
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 						config.WriteSetting("managedfields.thing." + flag.Key, true);
 
 					// Add thing flag translations
 					foreach(FlagTranslation f in General.Map.Config.ThingFlagsTranslation)
 					{
 						foreach(string fn in f.Fields)
 							config.WriteSetting("managedfields.thing." + fn, true);
 						foreach(string fn in f.Fields)
 							config.WriteSetting("managedfields.thing." + fn, true);
 					}
 					foreach(FlagTranslation f in General.Map.Config.ThingFlagsTranslation)
 					{
 						foreach(string fn in f.Fields)
 							config.WriteSetting("managedfields.thing." + fn, true);
 					}
 
 					// Done
 					udmfcfgreader.Dispose();
 					udmfcfg.Dispose();
 					break;
 				}
 			}
 			foreach(string rn in resnames)
 			{
 				// Found it?
 				if(rn.EndsWith(UDMF_CONFIG_NAME, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					Stream udmfcfg = General.ThisAssembly.GetManifestResourceStream(rn);
 					StreamReader udmfcfgreader = new StreamReader(udmfcfg, Encoding.ASCII);
 
 					// Load configuration from stream
 					config.InputConfiguration(udmfcfgreader.ReadToEnd());
 
 					// Now we add the linedef flags, activations and thing flags
 					// to this list, so that these don't show up in the custom
 					// fields list either. We use true as dummy value (it has no meaning)
 
 					// Add linedef flags
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.LinedefFlags)
 						config.WriteSetting("managedfields.linedef." + flag.Key, true);
 
 					// Add linedef activations
 					foreach(LinedefActivateInfo activate in General.Map.Config.LinedefActivates)
 						config.WriteSetting("managedfields.linedef." + activate.Key, true);
 					
 					// Add linedef flag translations
 					foreach(FlagTranslation f in General.Map.Config.LinedefFlagsTranslation)
 					{
 						foreach(string fn in f.Fields)
 							config.WriteSetting("managedfields.linedef." + fn, true);
 					}
 
 					// Add thing flags
 					foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 						config.WriteSetting("managedfields.thing." + flag.Key, true);
 
 					// Add thing flag translations
 					foreach(FlagTranslation f in General.Map.Config.ThingFlagsTranslation)
 					{
 						foreach(string fn in f.Fields)
 							config.WriteSetting("managedfields.thing." + fn, true);
 					}
 
 					// Done
 					udmfcfgreader.Dispose();
 					udmfcfg.Dispose();
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="521" endline="581">
<![CDATA[
 
 		// This writes the LINEDEFS to WAD file
 		private void WriteLinedefs(MapSet map, int position, IDictionary maplumps, IDictionary<Sidedef, int> sidedefids, IDictionary<Vertex, int> vertexids)
 		{
 			MemoryStream mem;
 			BinaryWriter writer;
 			Lump lump;
 			ushort sid;
 			int insertpos;
 			int flags;
 			
 			// Create memory to write to
 			mem = new MemoryStream();
 			writer = new BinaryWriter(mem, WAD.ENCODING);
 
 			// Go for all lines
 			foreach(Linedef l in map.Linedefs)
 			{
 				// Convert flags
 				flags = 0;
 				foreach(KeyValuePair<string, bool> f in l.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 				foreach(KeyValuePair<string, bool> f in l.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 
 				// Add activates to flags
 				flags |= (l.Activate & manager.Config.LinedefActivationsFilter);
 				
 				// Write properties to stream
 				writer.Write((UInt16)vertexids[l.Start]);
 				writer.Write((UInt16)vertexids[l.End]);
 				writer.Write((UInt16)flags);
 				writer.Write((Byte)l.Action);
 				writer.Write((Byte)l.Args[0]);
 				writer.Write((Byte)l.Args[1]);
 				writer.Write((Byte)l.Args[2]);
 				writer.Write((Byte)l.Args[3]);
 				writer.Write((Byte)l.Args[4]);
 
 				// Front sidedef
 				if(l.Front == null) sid = ushort.MaxValue;
 					else sid = (UInt16)sidedefids[l.Front];
 				writer.Write(sid);
 
 				// Back sidedef
 				if(l.Back == null) sid = ushort.MaxValue;
 					else sid = (UInt16)sidedefids[l.Back];
 				writer.Write(sid);
 			}
 			foreach(Linedef l in map.Linedefs)
 			{
 				// Convert flags
 				flags = 0;
 				foreach(KeyValuePair<string, bool> f in l.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 
 				// Add activates to flags
 				flags |= (l.Activate & manager.Config.LinedefActivationsFilter);
 				
 				// Write properties to stream
 				writer.Write((UInt16)vertexids[l.Start]);
 				writer.Write((UInt16)vertexids[l.End]);
 				writer.Write((UInt16)flags);
 				writer.Write((Byte)l.Action);
 				writer.Write((Byte)l.Args[0]);
 				writer.Write((Byte)l.Args[1]);
 				writer.Write((Byte)l.Args[2]);
 				writer.Write((Byte)l.Args[3]);
 				writer.Write((Byte)l.Args[4]);
 
 				// Front sidedef
 				if(l.Front == null) sid = ushort.MaxValue;
 					else sid = (UInt16)sidedefids[l.Front];
 				writer.Write(sid);
 
 				// Back sidedef
 				if(l.Back == null) sid = ushort.MaxValue;
 					else sid = (UInt16)sidedefids[l.Back];
 				writer.Write(sid);
 			}
 
 			// Find insert position and remove old lump
 			insertpos = MapManager.RemoveSpecificLump(wad, "LINEDEFS", position, MapManager.TEMP_MAP_HEADER, maplumps);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 
 			// Create the lump from memory
 			lump = wad.Insert("LINEDEFS", insertpos, (int)mem.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			mem.WriteTo(lump.Stream);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="681" endline="690">
<![CDATA[
 
 		/// <summary>
 		/// Call this to draw the selection on the overlay layer.
 		/// Must call renderer.StartOverlay first!
 		/// </summary>
 		protected virtual void RenderMultiSelection()
 		{
 			renderer.RenderRectangle(selectionrect, SELECTION_BORDER_SIZE,
 				General.Colors.Highlight.WithAlpha(SELECTION_ALPHA), true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\PluginManager.cs" startline="240" endline="246">
<![CDATA[
 
 		public bool OnPasteBegin(PasteOptions options)
 		{
 			bool result = true;
 			foreach(Plugin p in plugins) result &= p.Plug.OnPasteBegin(options.Copy(), result);
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2266" endline="2290">
<![CDATA[
 
 		// This shows the configuration on a specific page
 		internal void ShowConfigurationPage(int pageindex)
 		{
 			// Show configuration dialog
 			ConfigForm cfgform = new ConfigForm();
 			if(pageindex > -1) cfgform.ShowTab(pageindex);
 			if(cfgform.ShowDialog(this) == DialogResult.OK)
 			{
 				// Update stuff
 				SetupInterface();
 				UpdateInterface();
 				General.Editing.UpdateCurrentEditModes();
 				General.Plugins.ProgramReconfigure();
 				
 				// Reload resources if a map is open
 				if((General.Map != null) && cfgform.ReloadResources) General.Actions.InvokeAction("builder_reloadresources");
 				
 				// Redraw display
 				RedrawDisplay();
 			}
 
 			// Done
 			cfgform.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="442" endline="483">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Shortcut Keys
 		
 		// This applies default keys if they are not already in use
 		internal void ApplyDefaultShortcutKeys()
 		{
 			// Find actions that have no key set
 			foreach(KeyValuePair<string, Action> a in actions)
 			{
 				// Key set?
 				if(a.Value.ShortcutKey == -1)
 				{
 					// Check if the default key is not already used
 					bool keyused = false;
 					foreach(KeyValuePair<string, Action> d in actions)
 					{
 						// Check if the keys are the same
 						// Note that I use the mask of the source action to check if they match any combination
 						if((d.Value.ShortcutKey & a.Value.ShortcutMask) == (a.Value.DefaultShortcutKey & a.Value.ShortcutMask))
 						{
 							// No party.
 							keyused = true;
 							break;
 						}
 					}
 					foreach(KeyValuePair<string, Action> d in actions)
 					{
 						// Check if the keys are the same
 						// Note that I use the mask of the source action to check if they match any combination
 						if((d.Value.ShortcutKey & a.Value.ShortcutMask) == (a.Value.DefaultShortcutKey & a.Value.ShortcutMask))
 						{
 							// No party.
 							keyused = true;
 							break;
 						}
 					}
 					
 					// Party?
 					if(!keyused)
 					{
 						// Apply the default key
 						a.Value.SetShortcutKey(a.Value.DefaultShortcutKey);
 					}
 					else
 					{
 						// No party.
 						a.Value.SetShortcutKey(0);
 					}
 				}
 			}
 			foreach(KeyValuePair<string, Action> a in actions)
 			{
 				// Key set?
 				if(a.Value.ShortcutKey == -1)
 				{
 					// Check if the default key is not already used
 					bool keyused = false;
 					foreach(KeyValuePair<string, Action> d in actions)
 					{
 						// Check if the keys are the same
 						// Note that I use the mask of the source action to check if they match any combination
 						if((d.Value.ShortcutKey & a.Value.ShortcutMask) == (a.Value.DefaultShortcutKey & a.Value.ShortcutMask))
 						{
 							// No party.
 							keyused = true;
 							break;
 						}
 					}
 					
 					// Party?
 					if(!keyused)
 					{
 						// Apply the default key
 						a.Value.SetShortcutKey(a.Value.DefaultShortcutKey);
 					}
 					else
 					{
 						// No party.
 						a.Value.SetShortcutKey(0);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1080" endline="1108">
<![CDATA[
 
 		// This loads a map from file
 		[BeginAction("openmap")]
 		internal static void OpenMap()
 		{
 			OpenFileDialog openfile;
 
 			// Cancel volatile mode, if any
 			General.Editing.DisengageVolatileMode();
 
 			// Open map file dialog
 			openfile = new OpenFileDialog();
 			openfile.Filter = "Doom WAD Files (*.wad)|*.wad";
 			openfile.Title = "Open Map";
 			openfile.AddExtension = false;
 			openfile.CheckFileExists = true;
 			openfile.Multiselect = false;
 			openfile.ValidateNames = true;
 			if(openfile.ShowDialog(mainwindow) == DialogResult.OK)
 			{
 				// Update main window
 				mainwindow.Update();
 
 				// Open map file
 				OpenMapFile(openfile.FileName, null);
 			}
 
 			openfile.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="484" endline="499">
<![CDATA[
 		
 		// This checks if a given action is active
 		public bool CheckActionActive(Assembly asm, string actionname)
 		{
 			if(asm == null) asm = General.ThisAssembly;
 			
 			// Find active action
 			string fullname = asm.GetName().Name.ToLowerInvariant() + "_" + actionname;
 			foreach(Action a in activeactions)
 			{
 				if(a.Name == fullname) return true;
 			}
 			foreach(Action a in activeactions)
 			{
 				if(a.Name == fullname) return true;
 			}
 			
 			// No such active action
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\MouseInput.cs" startline="102" endline="148">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		#endregion
 
 		#region ================== Processing
 
 		// This processes the input
 		public Vector2D Process()
 		{
 			MouseState ms;
 			float changex, changey;
 			
 			// Poll the device
 			try
 			{
 				Result result = mouse.Poll();
 				if(result.IsSuccess)
 				{
 					// Get the changes since previous poll
 					ms = mouse.GetCurrentState();
 
 					// Calculate changes depending on sensitivity
 					changex = (float)ms.X * General.Settings.VisualMouseSensX * (float)General.Settings.MouseSpeed * 0.01f;
 					changey = (float)ms.Y * General.Settings.VisualMouseSensY * (float)General.Settings.MouseSpeed * 0.01f;
 
 					// Return changes
 					return new Vector2D(changex, changey);
 				}
 				else
 				{
 					// Reaquire device
 					try { mouse.Acquire(); }
 					catch(Exception) { }
 					return new Vector2D();
 				}
 			}
 			catch(DirectInputException)
 			{
 				// Reaquire device
 				try { mouse.Acquire(); }
 				catch(Exception) { }
 				return new Vector2D();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="499" endline="553">
<![CDATA[
 
 		// This writes the LINEDEFS to WAD file
 		private void WriteLinedefs(MapSet map, int position, IDictionary maplumps, IDictionary<Sidedef, int> sidedefids, IDictionary<Vertex, int> vertexids)
 		{
 			MemoryStream mem;
 			BinaryWriter writer;
 			Lump lump;
 			ushort sid;
 			int insertpos;
 			int flags;
 			
 			// Create memory to write to
 			mem = new MemoryStream();
 			writer = new BinaryWriter(mem, WAD.ENCODING);
 
 			// Go for all lines
 			foreach(Linedef l in map.Linedefs)
 			{
 				// Convert flags
 				flags = 0;
 				foreach(KeyValuePair<string, bool> f in l.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 				foreach(KeyValuePair<string, bool> f in l.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 
 				// Write properties to stream
 				writer.Write((UInt16)vertexids[l.Start]);
 				writer.Write((UInt16)vertexids[l.End]);
 				writer.Write((UInt16)flags);
 				writer.Write((UInt16)l.Action);
 				writer.Write((UInt16)l.Tag);
 
 				// Front sidedef
 				if(l.Front == null) sid = ushort.MaxValue;
 					else sid = (UInt16)sidedefids[l.Front];
 				writer.Write(sid);
 
 				// Back sidedef
 				if(l.Back == null) sid = ushort.MaxValue;
 					else sid = (UInt16)sidedefids[l.Back];
 				writer.Write(sid);
 			}
 			foreach(Linedef l in map.Linedefs)
 			{
 				// Convert flags
 				flags = 0;
 				foreach(KeyValuePair<string, bool> f in l.Flags)
 				{
 					int fnum;
 					if(f.Value && int.TryParse(f.Key, out fnum)) flags |= fnum;
 				}
 
 				// Write properties to stream
 				writer.Write((UInt16)vertexids[l.Start]);
 				writer.Write((UInt16)vertexids[l.End]);
 				writer.Write((UInt16)flags);
 				writer.Write((UInt16)l.Action);
 				writer.Write((UInt16)l.Tag);
 
 				// Front sidedef
 				if(l.Front == null) sid = ushort.MaxValue;
 					else sid = (UInt16)sidedefids[l.Front];
 				writer.Write(sid);
 
 				// Back sidedef
 				if(l.Back == null) sid = ushort.MaxValue;
 					else sid = (UInt16)sidedefids[l.Back];
 				writer.Write(sid);
 			}
 
 			// Find insert position and remove old lump
 			insertpos = MapManager.RemoveSpecificLump(wad, "LINEDEFS", position, MapManager.TEMP_MAP_HEADER, maplumps);
 			if(insertpos == -1) insertpos = position + 1;
 			if(insertpos > wad.Lumps.Count) insertpos = wad.Lumps.Count;
 
 			// Create the lump from memory
 			lump = wad.Insert("LINEDEFS", insertpos, (int)mem.Length);
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			mem.WriteTo(lump.Stream);
 			mem.Flush();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="760" endline="809">
<![CDATA[
 
 		#endregion
 
 		#region ================== Textures
 
 		// This loads the textures
 		private int LoadTextures(Dictionary<long, ImageData> list)
 		{
 			ICollection<ImageData> images;
 			PatchNames pnames = new PatchNames();
 			PatchNames newpnames;
 			int counter = 0;
 			long firsttexture = 0;
 
 			// Go for all opened containers
 			foreach(DataReader dr in containers)
 			{
 				// Load PNAMES info
 				// Note that pnames is NOT set to null in the loop
 				// because if a container has no pnames, the pnames
 				// of the previous (higher) container should be used.
 				newpnames = dr.LoadPatchNames();
 				if(newpnames != null) pnames = newpnames;
 
 				// Load textures
 				images = dr.LoadTextures(pnames);
 				if(images != null)
 				{
 					// Go for all textures
 					foreach(ImageData img in images)
 					{
 						// Add or replace in textures list
 						list.Remove(img.LongName);
 						list.Add(img.LongName, img);
 						if(firsttexture == 0) firsttexture = img.LongName;
 						counter++;
 						
 						// Add to preview manager
 						previews.AddImage(img);
 					}
 					foreach(ImageData img in images)
 					{
 						// Add or replace in textures list
 						list.Remove(img.LongName);
 						list.Add(img.LongName, img);
 						if(firsttexture == 0) firsttexture = img.LongName;
 						counter++;
 						
 						// Add to preview manager
 						previews.AddImage(img);
 					}
 				}
 			}
 			foreach(DataReader dr in containers)
 			{
 				// Load PNAMES info
 				// Note that pnames is NOT set to null in the loop
 				// because if a container has no pnames, the pnames
 				// of the previous (higher) container should be used.
 				newpnames = dr.LoadPatchNames();
 				if(newpnames != null) pnames = newpnames;
 
 				// Load textures
 				images = dr.LoadTextures(pnames);
 				if(images != null)
 				{
 					// Go for all textures
 					foreach(ImageData img in images)
 					{
 						// Add or replace in textures list
 						list.Remove(img.LongName);
 						list.Add(img.LongName, img);
 						if(firsttexture == 0) firsttexture = img.LongName;
 						counter++;
 						
 						// Add to preview manager
 						previews.AddImage(img);
 					}
 				}
 			}
 			
 			// The first texture cannot be used, because in the game engine it
 			// has index 0 which means "no texture", so remove it from the list.
 			list.Remove(firsttexture);
 			
 			// Output info
 			return counter;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="87" endline="118">
<![CDATA[
 		{
 			Vector2D v1 = General.GetByIndex(polygon, polygon.Count - 1);
 			uint c = 0;
 
 			// Go for all vertices
 			foreach(Vector2D v2 in polygon)
 			{
 				// Determine min/max values
 				float miny = Math.Min(v1.y, v2.y);
 				float maxy = Math.Max(v1.y, v2.y);
 				float maxx = Math.Max(v1.x, v2.x);
 
 				// Check for intersection
 				if((point.y > miny) && (point.y <= maxy))
 				{
 					if(point.x <= maxx)
 					{
 						if(v1.y != v2.y)
 						{
 							float xint = (point.y - v1.y) * (v2.x - v1.x) / (v2.y - v1.y) + v1.x;
 							if((v1.x == v2.x) || (point.x <= xint)) c++;
 						}
 					}
 				}
 
 				// Move to next
 				v1 = v2;
 			}
 			foreach(Vector2D v2 in polygon)
 			{
 				// Determine min/max values
 				float miny = Math.Min(v1.y, v2.y);
 				float maxy = Math.Max(v1.y, v2.y);
 				float maxx = Math.Max(v1.x, v2.x);
 
 				// Check for intersection
 				if((point.y > miny) && (point.y <= maxy))
 				{
 					if(point.x <= maxx)
 					{
 						if(v1.y != v2.y)
 						{
 							float xint = (point.y - v1.y) * (v2.x - v1.x) / (v2.y - v1.y) + v1.x;
 							if((v1.x == v2.x) || (point.x <= xint)) c++;
 						}
 					}
 				}
 
 				// Move to next
 				v1 = v2;
 			}
 
 			// Inside this polygon?
 			return (c & 0x00000001UL) != 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1493" endline="1499">
<![CDATA[
 		
 		// This renders a set of linedefs
 		public void PlotLinedefSet(ICollection<Linedef> linedefs)
 		{
 			// Go for all linedefs
 			foreach(Linedef l in linedefs) PlotLinedef(l, DetermineLinedefColor(l));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1520" endline="1526">
<![CDATA[
 		
 		// This renders a set of vertices
 		public void PlotVerticesSet(ICollection<Vertex> vertices)
 		{
 			// Go for all vertices
 			foreach(Vertex v in vertices) PlotVertex(v, DetermineVertexColor(v));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="168" endline="184">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		// This launches keyword help website
 		public void LaunchKeywordHelp()
 		{
 			string helpsite = scriptconfig.KeywordHelp;
 			string currentword = GetCurrentWord();
 			if(!string.IsNullOrEmpty(currentword) && (currentword.Length > 1) && !string.IsNullOrEmpty(helpsite))
 			{
 				currentword = scriptconfig.GetKeywordCase(currentword);
 				helpsite = helpsite.Replace("%K", currentword);
 				General.OpenWebsite(helpsite);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1525" endline="1535">
<![CDATA[
 
 		/// <summary>
 		/// This marks the sidedefs that make up the sectors with the matching mark.
 		/// </summary>
 		public void MarkSidedefsFromSectors(bool matchmark, bool setmark)
 		{
 			foreach(Sidedef sd in sidedefs)
 			{
 				if(sd.Sector.Marked == matchmark) sd.Marked = setmark;
 			}
 			foreach(Sidedef sd in sidedefs)
 			{
 				if(sd.Sector.Marked == matchmark) sd.Marked = setmark;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomColormapReader.cs" startline="86" endline="129">
<![CDATA[
 
 		// This creates a Bitmap from the given data
 		// Returns null on failure
 		public Bitmap ReadAsBitmap(Stream stream)
 		{
 			BitmapData bitmapdata;
 			PixelColorBlock pixeldata;
 			PixelColor* targetdata;
 			int width, height;
 			Bitmap bmp;
 
 			// Read pixel data
 			pixeldata = ReadAsPixelData(stream, out width, out height);
 			if(pixeldata != null)
 			{
 				try
 				{
 					// Create bitmap and lock pixels
 					bmp = new Bitmap(width, height, PixelFormat.Format32bppArgb);
 					bitmapdata = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
 					targetdata = (PixelColor*)bitmapdata.Scan0.ToPointer();
 
 					// Copy the pixels
 					General.CopyMemory(targetdata, pixeldata.Pointer, (uint)(width * height * sizeof(PixelColor)));
 
 					// Done
 					bmp.UnlockBits(bitmapdata);
 				}
 				catch(Exception e)
 				{
 					// Unable to make bitmap
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to make Doom flat data. " + e.GetType().Name + "
 					return null;
 				}
 			}
 			else
 			{
 				// Failed loading picture
 				bmp = null;
 			}
 
 			// Return result
 			return bmp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomFlatReader.cs" startline="92" endline="135">
<![CDATA[
 		
 		// This creates a Bitmap from the given data
 		// Returns null on failure
 		public Bitmap ReadAsBitmap(Stream stream)
 		{
 			BitmapData bitmapdata;
 			PixelColorBlock pixeldata;
 			PixelColor* targetdata;
 			int width, height;
 			Bitmap bmp;
 
 			// Read pixel data
 			pixeldata = ReadAsPixelData(stream, out width, out height);
 			if(pixeldata != null)
 			{
 				try
 				{
 					// Create bitmap and lock pixels
 					bmp = new Bitmap(width, height, PixelFormat.Format32bppArgb);
 					bitmapdata = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
 					targetdata = (PixelColor*)bitmapdata.Scan0.ToPointer();
 
 					// Copy the pixels
 					General.CopyMemory(targetdata, pixeldata.Pointer, (uint)(width * height * sizeof(PixelColor)));
 
 					// Done
 					bmp.UnlockBits(bitmapdata);
 				}
 				catch(Exception e)
 				{
 					// Unable to make bitmap
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to make Doom flat data. " + e.GetType().Name + "
 					return null;
 				}
 			}
 			else
 			{
 				// Failed loading picture
 				bmp = null;
 			}
 
 			// Return result
 			return bmp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="209" endline="259">
<![CDATA[
 
 		// Updating sector surface geometry should go in this order;
 		// - Triangulate sectors
 		// - Call FreeSurfaces to remove entries that have changed number of vertices
 		// - Call AllocateBuffers
 		// - Call UpdateSurfaces to add/update entries
 		// - Call UnlockBuffers
 		
 		// This (re)allocates the buffers based on an analysis of the map
 		// The map must be updated (triangulated) before calling this
 		public void AllocateBuffers()
 		{
 			// Make analysis of sector geometry
 			Dictionary<int, int> sectorverts = new Dictionary<int, int>();
 			foreach(Sector s in General.Map.Map.Sectors)
 			{
 				if(s.Triangles != null)
 				{
 					int numvertices = s.Triangles.Vertices.Count;
 					while(numvertices > 0)
 					{
 						// Determine for how many vertices in this entry
 						int vertsinentry = (numvertices > MAX_VERTICES_PER_SECTOR) ? MAX_VERTICES_PER_SECTOR 
 						
 						// We count the number of sectors that have specific number of vertices
 						if(!sectorverts.ContainsKey(vertsinentry))
 							sectorverts.Add(vertsinentry, 0);
 						sectorverts[vertsinentry]++;
 
 						numvertices -= vertsinentry;
 					}
 					while(numvertices > 0)
 					{
 						// Determine for how many vertices in this entry
 						int vertsinentry = (numvertices > MAX_VERTICES_PER_SECTOR) ? MAX_VERTICES_PER_SECTOR 
 						
 						// We count the number of sectors that have specific number of vertices
 						if(!sectorverts.ContainsKey(vertsinentry))
 							sectorverts.Add(vertsinentry, 0);
 						sectorverts[vertsinentry]++;
 
 						numvertices -= vertsinentry;
 					}
 				}
 			}
 			foreach(Sector s in General.Map.Map.Sectors)
 			{
 				if(s.Triangles != null)
 				{
 					int numvertices = s.Triangles.Vertices.Count;
 					while(numvertices > 0)
 					{
 						// Determine for how many vertices in this entry
 						int vertsinentry = (numvertices > MAX_VERTICES_PER_SECTOR) ? MAX_VERTICES_PER_SECTOR 
 						
 						// We count the number of sectors that have specific number of vertices
 						if(!sectorverts.ContainsKey(vertsinentry))
 							sectorverts.Add(vertsinentry, 0);
 						sectorverts[vertsinentry]++;
 
 						numvertices -= vertsinentry;
 					}
 				}
 			}
 			
 			// Now (re)allocate the needed buffers
 			foreach(KeyValuePair<int, int> sv in sectorverts)
 			{
 				// Zero vertices can't be drawn
 				if(sv.Key > 0)
 				{
 					SurfaceBufferSet set = GetSet(sv.Key);
 					
 					// Calculte how many free entries we need
 					int neededentries = sv.Value;
 					int freeentriesneeded = neededentries - set.entries.Count;
 
 					// Allocate the space needed
 					EnsureFreeBufferSpace(set, freeentriesneeded);
 				}
 			}
 			foreach(KeyValuePair<int, int> sv in sectorverts)
 			{
 				// Zero vertices can't be drawn
 				if(sv.Key > 0)
 				{
 					SurfaceBufferSet set = GetSet(sv.Key);
 					
 					// Calculte how many free entries we need
 					int neededentries = sv.Value;
 					int freeentriesneeded = neededentries - set.entries.Count;
 
 					// Allocate the space needed
 					EnsureFreeBufferSpace(set, freeentriesneeded);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="255" endline="284">
<![CDATA[
 
 		// This translates the flags into UDMF fields
 		internal void TranslateToUDMF()
 		{
 			// First make a single integer with all flags
 			int bits = 0;
 			int flagbit = 0;
 			foreach(KeyValuePair<string, bool> f in flags)
 				if(int.TryParse(f.Key, out flagbit) && f.Value) bits |= flagbit;
 			foreach(KeyValuePair<string, bool> f in flags)
 				if(int.TryParse(f.Key, out flagbit) && f.Value) bits |= flagbit;
 
 			// Now make the new flags
 			flags.Clear();
 			foreach(FlagTranslation f in General.Map.Config.ThingFlagsTranslation)
 			{
 				// Flag found in bits?
 				if((bits & f.Flag) == f.Flag)
 				{
 					// Add fields and remove bits
 					bits &= ~f.Flag;
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = f.FieldValues[i];
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = f.FieldValues[i];
 				}
 				else
 				{
 					// Add fields with inverted value
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = !f.FieldValues[i];
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = !f.FieldValues[i];
 				}
 			}
 			foreach(FlagTranslation f in General.Map.Config.ThingFlagsTranslation)
 			{
 				// Flag found in bits?
 				if((bits & f.Flag) == f.Flag)
 				{
 					// Add fields and remove bits
 					bits &= ~f.Flag;
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = f.FieldValues[i];
 				}
 				else
 				{
 					// Add fields with inverted value
 					for(int i = 0; i < f.Fields.Count; i++)
 						flags[f.Fields[i] = !f.FieldValues[i];
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListView.cs" startline="242" endline="267">
<![CDATA[
 
 		// When items are first dragged
 		protected override void OnItemDrag(ItemDragEventArgs e)
 		{
 			// Pass on to base
 			base.OnItemDrag(e);
 
 			// Anything selected?
 			if(base.SelectedItems.Count > 0)
 			{
 				// Go for all selected items
 				for(int i = base.SelectedItems.Count - 1; i >= 0; i--)
 				{
 					// Item grayed? Then abort!
 					if(base.SelectedItems[i].ForeColor != SystemColors.WindowText)
 						return;
 				}
 				for(int i = base.SelectedItems.Count - 1; i >= 0; i--)
 				{
 					// Item grayed? Then abort!
 					if(base.SelectedItems[i].ForeColor != SystemColors.WindowText)
 						return;
 				}
 
 				// Copy selected items to the list
 				dragitems.Clear();
 				foreach(ListViewItem lvi in base.SelectedItems) dragitems.Add(lvi);
 
 				// Start drag operation
 				base.DoDragDrop(DRAG_TYPE + base.Name, DragDropEffects.Move);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1834" endline="1875">
<![CDATA[
 		
 		// This sets the shortcut keys on menu items
 		private void ApplyShortcutKeys(ToolStripItemCollection items)
 		{
 			// Go for all controls to find menu items
 			foreach(ToolStripItem item in items)
 			{
 				// This is a menu item?
 				if(item is ToolStripMenuItem)
 				{
 					// Get the item in proper type
 					ToolStripMenuItem menuitem = (item as ToolStripMenuItem);
 
 					// Tag set for this item?
 					if(menuitem.Tag is string)
 					{
 						// Action with this name available?
 						string actionname = menuitem.Tag.ToString();
 						if(General.Actions.Exists(actionname))
 						{
 							// Put the action shortcut key on the menu item
 							menuitem.ShortcutKeyDisplayString = Actions.Action.GetShortcutKeyDesc(General.Actions[actionname].ShortcutKey);
 						}
 					}
 					// Edit mode info set for this item?
 					else if(menuitem.Tag is EditModeInfo)
 					{
 						// Action with this name available?
 						EditModeInfo modeinfo = (menuitem.Tag as EditModeInfo);
 						string actionname = modeinfo.SwitchAction.GetFullActionName(modeinfo.Plugin.Assembly);
 						if(General.Actions.Exists(actionname))
 						{
 							// Put the action shortcut key on the menu item
 							menuitem.ShortcutKeyDisplayString = Actions.Action.GetShortcutKeyDesc(General.Actions[actionname].ShortcutKey);
 						}
 					}
 
 					// Recursively apply shortcut keys to child menu items as well
 					ApplyShortcutKeys(menuitem.DropDownItems);
 				}
 			}
 			foreach(ToolStripItem item in items)
 			{
 				// This is a menu item?
 				if(item is ToolStripMenuItem)
 				{
 					// Get the item in proper type
 					ToolStripMenuItem menuitem = (item as ToolStripMenuItem);
 
 					// Tag set for this item?
 					if(menuitem.Tag is string)
 					{
 						// Action with this name available?
 						string actionname = menuitem.Tag.ToString();
 						if(General.Actions.Exists(actionname))
 						{
 							// Put the action shortcut key on the menu item
 							menuitem.ShortcutKeyDisplayString = Actions.Action.GetShortcutKeyDesc(General.Actions[actionname].ShortcutKey);
 						}
 					}
 					// Edit mode info set for this item?
 					else if(menuitem.Tag is EditModeInfo)
 					{
 						// Action with this name available?
 						EditModeInfo modeinfo = (menuitem.Tag as EditModeInfo);
 						string actionname = modeinfo.SwitchAction.GetFullActionName(modeinfo.Plugin.Assembly);
 						if(General.Actions.Exists(actionname))
 						{
 							// Put the action shortcut key on the menu item
 							menuitem.ShortcutKeyDisplayString = Actions.Action.GetShortcutKeyDesc(General.Actions[actionname].ShortcutKey);
 						}
 					}
 
 					// Recursively apply shortcut keys to child menu items as well
 					ApplyShortcutKeys(menuitem.DropDownItems);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypesManager.cs" startline="172" endline="183">
<![CDATA[
 
 		// This returns the attribute with the give name
 		public TypeHandlerAttribute GetNamedAttribute(string name)
 		{
 			foreach(KeyValuePair<int, TypeHandlerAttribute> ta in handlertypes)
 			{
 				if(ta.Value.Name == name) return ta.Value;
 			}
 			foreach(KeyValuePair<int, TypeHandlerAttribute> ta in handlertypes)
 			{
 				if(ta.Value.Name == name) return ta.Value;
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="258" endline="310">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Flats
 		
 		// This loads the textures
 		public override ICollection<ImageData> LoadFlats()
 		{
 			Dictionary<long, ImageData> images = new Dictionary<long, ImageData>();
 			ICollection<ImageData> collection;
 			List<ImageData> imgset = new List<ImageData>();
 			
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 			
 			// Load from wad files
 			// Note the backward order, because the last wad's images have priority
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				collection = wads[i].LoadFlats();
 				AddImagesToList(images, collection);
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				collection = wads[i].LoadFlats();
 				AddImagesToList(images, collection);
 			}
 			
 			// Should we load the images in this directory as flats?
 			if(rootflats)
 			{
 				collection = LoadDirectoryImages("", ImageDataFormat.DOOMFLAT, false);
 				AddImagesToList(images, collection);
 			}
 			
 			// Add images from flats directory
 			collection = LoadDirectoryImages(FLATS_DIR, ImageDataFormat.DOOMFLAT, true);
 			AddImagesToList(images, collection);
 
 			// Add images to the container-specific texture set
 			foreach(ImageData img in images.Values)
 				textureset.AddFlat(img);
 			foreach(ImageData img in images.Values)
 				textureset.AddFlat(img);
 
 			// Load TEXTURES lump file
 			imgset.Clear();
 			string[] alltexturefiles = GetAllFilesWithTitle("", "TEXTURES", false);
 			foreach(string texturesfile in alltexturefiles)
 			{
 				MemoryStream filedata = LoadFile(texturesfile);
 				WADReader.LoadHighresFlats(filedata, texturesfile, ref imgset, null, images);
 				filedata.Dispose();
 			}
 			foreach(string texturesfile in alltexturefiles)
 			{
 				MemoryStream filedata = LoadFile(texturesfile);
 				WADReader.LoadHighresFlats(filedata, texturesfile, ref imgset, null, images);
 				filedata.Dispose();
 			}
 
 			// Add images from TEXTURES lump file
 			AddImagesToList(images, imgset);
 			
 			return new List<ImageData>(images.Values);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="386" endline="410">
<![CDATA[
 
 		// This finds the right-most vertex to start tracing with
 		private Vertex FindRightMostVertex(Dictionary<Sidedef, bool> sides, Dictionary<Vertex, Vertex> ignores)
 		{
 			Vertex found = null;
 			
 			// Go for all sides to find the right-most side
 			foreach(KeyValuePair<Sidedef, bool> sd in sides)
 			{
 				// First found?
 				if((found == null) && !ignores.ContainsKey(sd.Key.Line.Start)) found = sd.Key.Line.Start;
 				if((found == null) && !ignores.ContainsKey(sd.Key.Line.End)) found = sd.Key.Line.End;
 				
 				// Compare?
 				if(found != null)
 				{
 					// Check if more to the right than the previous found
 					if((sd.Key.Line.Start.Position.x > found.Position.x) && !ignores.ContainsKey(sd.Key.Line.Start)) found = sd.Key.Line.Start;
 					if((sd.Key.Line.End.Position.x > found.Position.x) && !ignores.ContainsKey(sd.Key.Line.End)) found = sd.Key.Line.End;
 				}
 			}
 			foreach(KeyValuePair<Sidedef, bool> sd in sides)
 			{
 				// First found?
 				if((found == null) && !ignores.ContainsKey(sd.Key.Line.Start)) found = sd.Key.Line.Start;
 				if((found == null) && !ignores.ContainsKey(sd.Key.Line.End)) found = sd.Key.Line.End;
 				
 				// Compare?
 				if(found != null)
 				{
 					// Check if more to the right than the previous found
 					if((sd.Key.Line.Start.Position.x > found.Position.x) && !ignores.ContainsKey(sd.Key.Line.Start)) found = sd.Key.Line.Start;
 					if((sd.Key.Line.End.Position.x > found.Position.x) && !ignores.ContainsKey(sd.Key.Line.End)) found = sd.Key.Line.End;
 				}
 			}
 			
 			// Return result
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamReader.cs" startline="407" endline="435">
<![CDATA[
 
 		// This reads custom fields from a collection and adds them to a map element
 		private void ReadCustomFields(UniversalCollection collection, MapElement element, string elementname)
 		{
 			element.Fields.BeforeFieldsChange();
 			
 			// Go for all the elements in the collection
 			foreach(UniversalEntry e in collection)
 			{
 				// Check if not a managed field
 				if(!config.SettingExists("managedfields." + elementname + "." + e.Key))
 				{
 					int type = (int)UniversalType.Integer;
 
 					// Determine default type
 					if(e.Value.GetType() == typeof(int)) type = (int)UniversalType.Integer;
 					else if(e.Value.GetType() == typeof(float)) type = (int)UniversalType.Float;
 					else if(e.Value.GetType() == typeof(bool)) type = (int)UniversalType.Boolean;
 					else if(e.Value.GetType() == typeof(string)) type = (int)UniversalType.String;
 
 					// Try to find the type from configuration
 					if(setknowncustomtypes)
 						type = General.Map.Options.GetUniversalFieldType(elementname, e.Key, type);
 
 					// Make custom field
 					element.Fields[e.Key] = new UniValue(type, e.Value);
 				}
 			}
 			foreach(UniversalEntry e in collection)
 			{
 				// Check if not a managed field
 				if(!config.SettingExists("managedfields." + elementname + "." + e.Key))
 				{
 					int type = (int)UniversalType.Integer;
 
 					// Determine default type
 					if(e.Value.GetType() == typeof(int)) type = (int)UniversalType.Integer;
 					else if(e.Value.GetType() == typeof(float)) type = (int)UniversalType.Float;
 					else if(e.Value.GetType() == typeof(bool)) type = (int)UniversalType.Boolean;
 					else if(e.Value.GetType() == typeof(string)) type = (int)UniversalType.String;
 
 					// Try to find the type from configuration
 					if(setknowncustomtypes)
 						type = General.Map.Options.GetUniversalFieldType(elementname, e.Key, type);
 
 					// Make custom field
 					element.Fields[e.Key] = new UniValue(type, e.Value);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="105" endline="115">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Management
 		
 		// This suspends use of this resource
 		public override void Suspend()
 		{
 			foreach(WADReader wr in wads) wr.Suspend();
 			base.Suspend();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="116" endline="122">
<![CDATA[
 		
 		// This resumes use of this resource
 		public override void Resume()
 		{
 			foreach(WADReader wr in wads) wr.Resume();
 			base.Resume();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\PluginManager.cs" startline="233" endline="239">
<![CDATA[
 
 		public bool OnCopyBegin()
 		{
 			bool result = true;
 			foreach(Plugin p in plugins) result &= p.Plug.OnCopyBegin(result);
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\PluginManager.cs" startline="247" endline="253">
<![CDATA[
 
 		public bool OnUndoBegin()
 		{
 			bool result = true;
 			foreach(Plugin p in plugins) result &= p.Plug.OnUndoBegin(result);
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\PluginManager.cs" startline="254" endline="260">
<![CDATA[
 
 		public bool OnRedoBegin()
 		{
 			bool result = true;
 			foreach(Plugin p in plugins) result &= p.Plug.OnRedoBegin(result);
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\BitFlagsForm.cs" startline="165" endline="176">
<![CDATA[
 
 		// This shows the dialog
 		// Returns the flags or the same flags when cancelled
 		public static int ShowDialog(IWin32Window owner, EnumList flags, int value)
 		{
 			int result = value;
 			BitFlagsForm f = new BitFlagsForm();
 			f.Setup(flags, value);
 			if(f.ShowDialog(owner) == DialogResult.OK) result = f.Value;
 			f.Dispose();
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlagsForm.cs" startline="68" endline="79">
<![CDATA[
 
 		// This shows the dialog
 		// Returns the flags or the same flags when cancelled
 		public static string ShowDialog(IWin32Window owner, string value, IDictionary<string, string> inflags)
 		{
 			string result = value;
 			FlagsForm f = new FlagsForm();
 			f.Setup(value, inflags);
 			if (f.ShowDialog(owner) == DialogResult.OK) result = f.Value;
 			f.Dispose();
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PreviewManager.cs" startline="228" endline="250">
<![CDATA[
 
 		// Background loading
 		// Return true when we have more work to do, so that the
 		// thread will not wait too long before calling again
 		internal bool BackgroundLoad()
 		{
 			// Get next item
 			ImageData image = null;
 			lock(imageque)
 			{
 				// Fetch next image to process
 				if(imageque.Count > 0) image = imageque.Dequeue();
 			}
 
 			// Any image to process?
 			if(image != null)
 			{
 				// Make image preview?
 				if(!image.IsPreviewLoaded) MakeImagePreview(image);
 			}
 
 			return (image != null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1204" endline="1218">
<![CDATA[
 
 		/// <summary>Returns a collection of vertices that match a selected state.</summary>
 		public ICollection<Vertex> GetSelectedVertices(bool selected)
 		{
 			if(selected)
 			{
 				return new List<Vertex>(sel_vertices);
 			}
 			else
 			{
 				List<Vertex> list = new List<Vertex>(numvertices - sel_vertices.Count);
 				foreach(Vertex v in vertices) if(!v.Selected) list.Add(v);
 				return list;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1219" endline="1233">
<![CDATA[
 
 		/// <summary>Returns a collection of things that match a selected state.</summary>
 		public ICollection<Thing> GetSelectedThings(bool selected)
 		{
 			if(selected)
 			{
 				return new List<Thing>(sel_things);
 			}
 			else
 			{
 				List<Thing> list = new List<Thing>(numthings - sel_things.Count);
 				foreach(Thing t in things) if(!t.Selected) list.Add(t);
 				return list;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1234" endline="1248">
<![CDATA[
 
 		/// <summary>Returns a collection of linedefs that match a selected state.</summary>
 		public ICollection<Linedef> GetSelectedLinedefs(bool selected)
 		{
 			if(selected)
 			{
 				return new List<Linedef>(sel_linedefs);
 			}
 			else
 			{
 				List<Linedef> list = new List<Linedef>(numlinedefs - sel_linedefs.Count);
 				foreach(Linedef l in linedefs) if(!l.Selected) list.Add(l);
 				return list;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1274" endline="1288">
<![CDATA[
 
 		/// <summary>Returns a collection of sectors that match a selected state.</summary>
 		public ICollection<Sector> GetSelectedSectors(bool selected)
 		{
 			if(selected)
 			{
 				return new List<Sector>(sel_sectors);
 			}
 			else
 			{
 				List<Sector> list = new List<Sector>(numsectors - sel_sectors.Count);
 				foreach(Sector s in sectors) if(!s.Selected) list.Add(s);
 				return list;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="152" endline="168">
<![CDATA[
 
 		// This returns a list of all files that are in the given path (optionally in subdirectories) and have the given title
 		public List<string> GetAllFilesWithTitle(string path, string title, bool subdirectories)
 		{
 			if(subdirectories)
 				return GetAllFilesWithTitle(path, title);
 			else
 			{
 				path = CorrectPath(path).ToLowerInvariant();
 				title = title.ToLowerInvariant();
 				List<string> files = new List<string>(entries.Length);
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].path == path) && (entries[i].filetitle == title))
 						files.Add(entries[i].filepathname);
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].path == path) && (entries[i].filetitle == title))
 						files.Add(entries[i].filepathname);
 				return files;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="181" endline="197">
<![CDATA[
 
 		// This returns a list of all files that are in the given path (optionally in subdirectories) and have the given extension
 		public List<string> GetAllFiles(string path, string extension, bool subdirectories)
 		{
 			if(subdirectories)
 				return GetAllFiles(path, extension);
 			else
 			{
 				path = CorrectPath(path).ToLowerInvariant();
 				extension = extension.ToLowerInvariant();
 				List<string> files = new List<string>(entries.Length);
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].path == path) && (entries[i].extension == extension))
 						files.Add(entries[i].filepathname);
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].path == path) && (entries[i].extension == extension))
 						files.Add(entries[i].filepathname);
 				return files;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualGeometry.cs" startline="160" endline="166">
<![CDATA[
 		
 		// This compares for sorting by sector
 		public int CompareTo(VisualGeometry other)
 		{
 			// Compare sectors
 			return this.sector.Sector.FixedIndex - other.sector.Sector.FixedIndex;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="1753" endline="1778">
<![CDATA[
 		
 		/// <summary>
 		/// This removes all actions on the marked geometry.
 		/// </summary>
 		public static void RemoveMarkedActions()
 		{
 			// Remove actions from things
 			foreach(Thing t in General.Map.Map.Things)
 			{
 				if(t.Marked)
 				{
 					t.Action = 0;
 					for(int i = 0; i < Thing.NUM_ARGS; i++) t.Args[i] = 0;
 				}
 			}
 			foreach(Thing t in General.Map.Map.Things)
 			{
 				if(t.Marked)
 				{
 					t.Action = 0;
 					for(int i = 0; i < Thing.NUM_ARGS; i++) t.Args[i] = 0;
 				}
 			}
 			
 			// Remove actions from linedefs
 			foreach(Linedef l in General.Map.Map.Linedefs)
 			{
 				if(l.Marked)
 				{
 					l.Action = 0;
 					for(int i = 0; i < Linedef.NUM_ARGS; i++) l.Args[i] = 0;
 				}
 			}
 			foreach(Linedef l in General.Map.Map.Linedefs)
 			{
 				if(l.Marked)
 				{
 					l.Action = 0;
 					for(int i = 0; i < Linedef.NUM_ARGS; i++) l.Args[i] = 0;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Compilers\Compiler.cs" startline="160" endline="212">
<![CDATA[
 		
 		// This creates a compiler by interface name
 		internal static Compiler Create(CompilerInfo info)
 		{
 			Compiler result;
 			
 			// Make list of assemblies to search in
 			List<Assembly> asms = General.Plugins.GetPluginAssemblies();
 			asms.Add(General.ThisAssembly);
 			
 			// Constructor arguments
 			object[] args = new object[1];
 			args[0] = info;
 			
 			try
 			{
 				// Go for all assemblies
 				foreach(Assembly a in asms)
 				{
 					Type[] types;
 					
 					// Find the class
 					if(a == General.ThisAssembly)
 						types = a.GetTypes();
 					else
 						types = a.GetExportedTypes();
 					
 					foreach(Type t in types)
 					{
 						if(t.IsSubclassOf(typeof(Compiler)) && (t.Name == info.ProgramInterface))
 						{
 							// Create instance
 							result = (Compiler)a.CreateInstance(t.FullName, false, BindingFlags.Default,
 												null, args, CultureInfo.CurrentCulture, new object[0]);
 							return result;
 						}
 					}
 					foreach(Type t in types)
 					{
 						if(t.IsSubclassOf(typeof(Compiler)) && (t.Name == info.ProgramInterface))
 						{
 							// Create instance
 							result = (Compiler)a.CreateInstance(t.FullName, false, BindingFlags.Default,
 												null, args, CultureInfo.CurrentCulture, new object[0]);
 							return result;
 						}
 					}
 				}
 				foreach(Assembly a in asms)
 				{
 					Type[] types;
 					
 					// Find the class
 					if(a == General.ThisAssembly)
 						types = a.GetTypes();
 					else
 						types = a.GetExportedTypes();
 					
 					foreach(Type t in types)
 					{
 						if(t.IsSubclassOf(typeof(Compiler)) && (t.Name == info.ProgramInterface))
 						{
 							// Create instance
 							result = (Compiler)a.CreateInstance(t.FullName, false, BindingFlags.Default,
 												null, args, CultureInfo.CurrentCulture, new object[0]);
 							return result;
 						}
 					}
 				}
 			}
 			// Catch errors
 			catch(TargetInvocationException e)
 			{
 				// Throw the actual exception
 				Debug.WriteLine(DateTime.Now.ToShortDateString() + " " + DateTime.Now.ToShortTimeString());
 				Debug.WriteLine(e.InnerException.Source + " throws " + e.InnerException.GetType().Name + "
 				Debug.WriteLine(e.InnerException.Message);
 				Debug.WriteLine(e.InnerException.StackTrace);
 				throw e.InnerException;
 			}
 
 			// No such compiler
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2541" endline="2554">
<![CDATA[
 
 		// This shows the dialog to edit vertices
 		public DialogResult ShowEditVertices(ICollection<Vertex> vertices)
 		{
 			DialogResult result;
 
 			// Show sector edit dialog
 			VertexEditForm f = new VertexEditForm();
 			f.Setup(vertices);
 			result = f.ShowDialog(this);
 			f.Dispose();
 
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2555" endline="2568">
<![CDATA[
 		
 		// This shows the dialog to edit lines
 		public DialogResult ShowEditLinedefs(ICollection<Linedef> lines)
 		{
 			DialogResult result;
 
 			// Show line edit dialog
 			LinedefEditForm f = new LinedefEditForm();
 			f.Setup(lines);
 			result = f.ShowDialog(this);
 			f.Dispose();
 
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2569" endline="2582">
<![CDATA[
 
 		// This shows the dialog to edit sectors
 		public DialogResult ShowEditSectors(ICollection<Sector> sectors)
 		{
 			DialogResult result;
 
 			// Show sector edit dialog
 			SectorEditForm f = new SectorEditForm();
 			f.Setup(sectors);
 			result = f.ShowDialog(this);
 			f.Dispose();
 
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2583" endline="2596">
<![CDATA[
 
 		// This shows the dialog to edit things
 		public DialogResult ShowEditThings(ICollection<Thing> things)
 		{
 			DialogResult result;
 
 			// Show thing edit dialog
 			ThingEditForm f = new ThingEditForm();
 			f.Setup(things);
 			result = f.ShowDialog(this);
 			f.Dispose();
 			
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="488" endline="504">
<![CDATA[
 
 		// This finds the right-most vertex in an inner polygon to use for cut startpoint.
 		private LinkedListNode<EarClipVertex> FindRightMostVertex(EarClipPolygon p)
 		{
 			LinkedListNode<EarClipVertex> found = p.First;
 			LinkedListNode<EarClipVertex> v = found.Next;
 			
 			// Go for all vertices to find the on with the biggest x value
 			while(v != null)
 			{
 				if(v.Value.Position.x > found.Value.Position.x) found = v;
 				v = v.Next;
 			}
 			while(v != null)
 			{
 				if(v.Value.Position.x > found.Value.Position.x) found = v;
 				v = v.Next;
 			}
 
 			// Return result
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamWriter.cs" startline="219" endline="244">
<![CDATA[
 
 		// This adds sidedefs
 		private void WriteSidedefs(ICollection<Sidedef> sidedefs, UniversalParser textmap, IDictionary<Sector, int> sectorids)
 		{
 			// Go for all sidedefs
 			foreach(Sidedef s in sidedefs)
 			{
 				int sectorid = (s.Sector != null) ? sectorids[s.Sector] 
 
 				// Make collection
 				UniversalCollection coll = new UniversalCollection();
 				if(s.OffsetX != 0) coll.Add("offsetx", s.OffsetX);
 				if(s.OffsetY != 0) coll.Add("offsety", s.OffsetY);
 				if(s.LongHighTexture != MapSet.EmptyLongName) coll.Add("texturetop", s.HighTexture);
 				if(s.LongLowTexture != MapSet.EmptyLongName) coll.Add("texturebottom", s.LowTexture);
 				if(s.LongMiddleTexture != MapSet.EmptyLongName) coll.Add("texturemiddle", s.MiddleTexture);
 				coll.Add("sector", sectorids[s.Sector]);
 				coll.Comment = s.Index.ToString();
 				
 				// Add custom fields
 				AddCustomFields(s, "sidedef", coll);
 
 				// Store
 				textmap.Root.Add("sidedef", coll);
 			}
 			foreach(Sidedef s in sidedefs)
 			{
 				int sectorid = (s.Sector != null) ? sectorids[s.Sector] 
 
 				// Make collection
 				UniversalCollection coll = new UniversalCollection();
 				if(s.OffsetX != 0) coll.Add("offsetx", s.OffsetX);
 				if(s.OffsetY != 0) coll.Add("offsety", s.OffsetY);
 				if(s.LongHighTexture != MapSet.EmptyLongName) coll.Add("texturetop", s.HighTexture);
 				if(s.LongLowTexture != MapSet.EmptyLongName) coll.Add("texturebottom", s.LowTexture);
 				if(s.LongMiddleTexture != MapSet.EmptyLongName) coll.Add("texturemiddle", s.MiddleTexture);
 				coll.Add("sector", sectorids[s.Sector]);
 				coll.Comment = s.Index.ToString();
 				
 				// Add custom fields
 				AddCustomFields(s, "sidedef", coll);
 
 				// Store
 				textmap.Root.Add("sidedef", coll);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="233" endline="295">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Private Methods
 		
 		// This merges two structures
 		private static IDictionary Combine(IDictionary d1, IDictionary d2, bool sorted)
 		{
 			// Create new dictionary
 			IDictionary result;
 			if(sorted) result = new ListDictionary(); else result = new Hashtable();
 			
 			// Copy all items from d1 to result
 			IDictionaryEnumerator d1e = d1.GetEnumerator();
 			while(d1e.MoveNext()) result.Add(d1e.Key, d1e.Value);
 			
 			// Go for all items in d2
 			IDictionaryEnumerator d2e = d2.GetEnumerator();
 			while(d2e.MoveNext())
 			{
 				// Check if this is another Hashtable
 				if(d2e.Value is IDictionary)
 				{
 					// Check if already in result
 					if(result.Contains(d2e.Key) && (result[d2e.Key] is IDictionary))
 					{
 						// Modify result
 						result[d2e.Key] = Combine((IDictionary)result[d2e.Key], (IDictionary)d2e.Value, sorted);
 					}
 					else
 					{
 						// Copy from d2
 						if(sorted)
 						{
 							// Sorted combine
 							result[d2e.Key] = Combine(new ListDictionary(), (IDictionary)d2e.Value, sorted);
 						}
 						else
 						{
 							// Unsorted combine
 							result[d2e.Key] = Combine(new Hashtable(), (IDictionary)d2e.Value, sorted);
 						}
 					}
 				}
 				else
 				{
 					// Check if also in d1
 					if(result.Contains(d2e.Key))
 					{
 						// Modify result
 						result[d2e.Key] = d2e.Value;
 					}
 					else
 					{
 						// Copy
 						result.Add(d2e.Key, d2e.Value);
 					}
 				}
 			}
 			while(d2e.MoveNext())
 			{
 				// Check if this is another Hashtable
 				if(d2e.Value is IDictionary)
 				{
 					// Check if already in result
 					if(result.Contains(d2e.Key) && (result[d2e.Key] is IDictionary))
 					{
 						// Modify result
 						result[d2e.Key] = Combine((IDictionary)result[d2e.Key], (IDictionary)d2e.Value, sorted);
 					}
 					else
 					{
 						// Copy from d2
 						if(sorted)
 						{
 							// Sorted combine
 							result[d2e.Key] = Combine(new ListDictionary(), (IDictionary)d2e.Value, sorted);
 						}
 						else
 						{
 							// Unsorted combine
 							result[d2e.Key] = Combine(new Hashtable(), (IDictionary)d2e.Value, sorted);
 						}
 					}
 				}
 				else
 				{
 					// Check if also in d1
 					if(result.Contains(d2e.Key))
 					{
 						// Modify result
 						result[d2e.Key] = d2e.Value;
 					}
 					else
 					{
 						// Copy
 						result.Add(d2e.Key, d2e.Value);
 					}
 				}
 			}
 			
 			// Return result
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="1717" endline="1738">
<![CDATA[
 		
 		/// <summary>
 		/// This renumbers all tags on the marked geometry.
 		/// </summary>
 		public static void RenumberMarkedTags()
 		{
 			Dictionary<int, int> tagsmap = new Dictionary<int, int>();
 			
 			// Collect the tag numbers used in the marked geometry
 			General.Map.Map.ForAllTags(CollectTagNumbersHandler, true, tagsmap);
 			
 			// Get new tags that are unique within unmarked geometry
 			List<int> newtags = General.Map.Map.GetMultipleNewTags(tagsmap.Count, false);
 			
 			// Map the old tags with the new tags
 			int index = 0;
 			List<int> oldkeys = new List<int>(tagsmap.Keys);
 			foreach(int ot in oldkeys) tagsmap[ot] = newtags[index++];
 			
 			// Now renumber the old tags with the new ones
 			General.Map.Map.ForAllTags(RenumberTagsHandler, true, tagsmap);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamWriter.cs" startline="113" endline="154">
<![CDATA[
 
 		// This writes the structures to a stream
 		// NOTE
 		// NOTE
 		// If there are missing sidedefs, their reference will be removed from the linedefs.
 		public void Write(ICollection<Vertex> vertices, ICollection<Linedef> linedefs,
 						  ICollection<Sidedef> sidedefs, ICollection<Sector> sectors,
 						  ICollection<Thing> things, Stream stream, string writenamespace)
 		{
 			UniversalParser textmap = new UniversalParser();
 
 			// Begin with fields that must be at the top
 			if(writenamespace != null) textmap.Root.Add("namespace", writenamespace);
 
 			Dictionary<Vertex, int> vertexids = new Dictionary<Vertex, int>();
 			Dictionary<Sidedef, int> sidedefids = new Dictionary<Sidedef, int>();
 			Dictionary<Sector, int> sectorids = new Dictionary<Sector, int>();
 
 			// Index the elements in the data structures
 			foreach(Vertex v in vertices) vertexids.Add(v, vertexids.Count);
 			foreach(Sidedef sd in sidedefs) sidedefids.Add(sd, sidedefids.Count);
 			foreach(Sector s in sectors) sectorids.Add(s, sectorids.Count);
 
 			// If we write the custom field types again, then forget
 			// all previous field types (this gets rid of unused field types)
 			if(remembercustomtypes) General.Map.Options.ForgetUniversalFieldTypes();
 
 			// Write the data structures to textmap
 			WriteVertices(vertices, textmap);
 			WriteLinedefs(linedefs, textmap, sidedefids, vertexids);
 			WriteSidedefs(sidedefs, textmap, sectorids);
 			WriteSectors(sectors, textmap);
 			WriteThings(things, textmap);
 
 			// Get the textmap as string
 			string textmapstr = textmap.OutputConfiguration();
 
 			// Write to stream
 			StreamWriter writer = new StreamWriter(stream, Encoding.ASCII);
 			writer.Write(textmapstr);
 			writer.Flush();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="154" endline="227">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Textures
 
 		// This loads the textures
 		public override ICollection<ImageData> LoadTextures(PatchNames pnames)
 		{
 			Dictionary<long, ImageData> images = new Dictionary<long, ImageData>();
 			ICollection<ImageData> collection;
 			List<ImageData> imgset = new List<ImageData>();
 			
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 			
 			// Load from wad files (NOTE
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				collection = wads[i].LoadTextures(pnames);
 				AddImagesToList(images, collection);
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				collection = wads[i].LoadTextures(pnames);
 				AddImagesToList(images, collection);
 			}
 			
 			// Should we load the images in this directory as textures?
 			if(roottextures)
 			{
 				collection = LoadDirectoryImages("", ImageDataFormat.DOOMPICTURE, false);
 				AddImagesToList(images, collection);
 			}
 			
 			// Add images from texture directory
 			collection = LoadDirectoryImages(TEXTURES_DIR, ImageDataFormat.DOOMPICTURE, true);
 			AddImagesToList(images, collection);
 			
 			// Load TEXTURE1 lump file
 			imgset.Clear();
 			string texture1file = FindFirstFile("TEXTURE1", false);
 			if((texture1file != null) && FileExists(texture1file))
 			{
 				MemoryStream filedata = LoadFile(texture1file);
 				WADReader.LoadTextureSet("TEXTURE1", filedata, ref imgset, pnames);
 				filedata.Dispose();
 			}
 
 			// Load TEXTURE2 lump file
 			string texture2file = FindFirstFile("TEXTURE2", false);
 			if((texture2file != null) && FileExists(texture2file))
 			{
 				MemoryStream filedata = LoadFile(texture2file);
 				WADReader.LoadTextureSet("TEXTURE2", filedata, ref imgset, pnames);
 				filedata.Dispose();
 			}
 			
 			// Add images from TEXTURE1 and TEXTURE2 lump files
 			AddImagesToList(images, imgset);
 			
 			// Load TEXTURES lump file
 			imgset.Clear();
 			string[] alltexturefiles = GetAllFilesWithTitle("", "TEXTURES", false);
 			foreach(string texturesfile in alltexturefiles)
 			{
 				MemoryStream filedata = LoadFile(texturesfile);
 				WADReader.LoadHighresTextures(filedata, texturesfile, ref imgset, images, null);
 				filedata.Dispose();
 			}
 			foreach(string texturesfile in alltexturefiles)
 			{
 				MemoryStream filedata = LoadFile(texturesfile);
 				WADReader.LoadHighresTextures(filedata, texturesfile, ref imgset, images, null);
 				filedata.Dispose();
 			}
 			
 			// Add images from TEXTURES lump file
 			AddImagesToList(images, imgset);
 			
 			// Add images to the container-specific texture set
 			foreach(ImageData img in images.Values)
 				textureset.AddTexture(img);
 			foreach(ImageData img in images.Values)
 				textureset.AddTexture(img);
 			
 			return new List<ImageData>(images.Values);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PreviewManager.cs" startline="213" endline="227">
<![CDATA[
 
 		// This returns a copy of the preview
 		internal Bitmap GetPreviewCopy(int previewindex)
 		{
 			Bitmap image;
 
 			// Get the preview we need
 			lock(images) { image = images[previewindex]; }
 
 			// Make a copy
 			lock(image)
 			{
 				return new Bitmap(image);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="803" endline="820">
<![CDATA[
 
 		// This checks if a given ear is a valid (no intersections from reflex vertices)
 		private bool CheckValidEar(EarClipVertex[] t, LinkedList<EarClipVertex> reflexes)
 		{
 			// Go for all reflex vertices
 			foreach(EarClipVertex rv in reflexes)
 			{
 				// Not one of the triangle corners?
 				if((rv.Position != t[0].Position) && (rv.Position != t[1].Position) && (rv.Position != t[2].Position))
 				{
 					// Return false on intersection
 					if(PointInsideTriangle(t, rv.MainListNode)) return false;
 				}
 			}
 			foreach(EarClipVertex rv in reflexes)
 			{
 				// Not one of the triangle corners?
 				if((rv.Position != t[0].Position) && (rv.Position != t[1].Position) && (rv.Position != t[2].Position))
 				{
 					// Return false on intersection
 					if(PointInsideTriangle(t, rv.MainListNode)) return false;
 				}
 			}
 
 			// Valid ear!
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="502" endline="548">
<![CDATA[
 		
 		// This stops background loading
 		private void StopBackgroundLoader()
 		{
 			ImageData img;
 			
 			General.WriteLogLine("Stopping background resource loading...");
 			if(backgroundloader != null)
 			{
 				// Stop the thread and wait for it to end
 				backgroundloader.Interrupt();
 				backgroundloader.Join();
 
 				// Reset load states on all images in the list
 				while(imageque.Count > 0)
 				{
 					img = imageque.Dequeue();
 					
 					switch(img.ImageState)
 					{
 						case ImageLoadState.Loading
 							img.ImageState = ImageLoadState.None;
 							break;
 
 						case ImageLoadState.Unloading
 							img.ImageState = ImageLoadState.Ready;
 							break;
 					}
 
 					switch(img.PreviewState)
 					{
 						case ImageLoadState.Loading
 							img.PreviewState = ImageLoadState.None;
 							break;
 
 						case ImageLoadState.Unloading
 							img.PreviewState = ImageLoadState.Ready;
 							break;
 					}
 				}
 				while(imageque.Count > 0)
 				{
 					img = imageque.Dequeue();
 					
 					switch(img.ImageState)
 					{
 						case ImageLoadState.Loading
 							img.ImageState = ImageLoadState.None;
 							break;
 
 						case ImageLoadState.Unloading
 							img.ImageState = ImageLoadState.Ready;
 							break;
 					}
 
 					switch(img.PreviewState)
 					{
 						case ImageLoadState.Loading
 							img.PreviewState = ImageLoadState.None;
 							break;
 
 						case ImageLoadState.Unloading
 							img.PreviewState = ImageLoadState.Ready;
 							break;
 					}
 				}
 				
 				// Done
 				notifiedbusy = false;
 				backgroundloader = null;
 				General.SendMessage(General.MainWindow.Handle, (int)MainForm.ThreadMessages.UpdateStatus, 0, 0);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2245" endline="2310">
<![CDATA[
 
 		/// <summary>This splits the given lines with the given vertices. All affected lines
 		/// will be added to changedlines. Returns false when the operation failed.</summary>
 		public static bool SplitLinesByVertices(ICollection<Linedef> lines, ICollection<Vertex> verts, float splitdist, ICollection<Linedef> changedlines)
 		{
 			float splitdist2 = splitdist * splitdist;
 			bool splitted;
 
 			do
 			{
 				// No split yet
 				splitted = false;
 				
 				// Go for all the lines
 				foreach(Linedef l in lines)
 				{
 					// Go for all the vertices
 					foreach(Vertex v in verts)
 					{
 						// Check if v is close enough to l for splitting
 						if(l.DistanceToSq(v.Position, true) <= splitdist2)
 						{
 							// Line is not already referencing v?
 							Vector2D deltastart = l.Start.Position - v.Position;
 							Vector2D deltaend = l.End.Position - v.Position;
 							if(((Math.Abs(deltastart.x) > 0.001f) ||
 							    (Math.Abs(deltastart.y) > 0.001f)) &&
 							   ((Math.Abs(deltaend.x) > 0.001f) ||
 							    (Math.Abs(deltaend.y) > 0.001f)))
 							{
 								// Split line l with vertex v
 								Linedef nl = l.Split(v);
 								if(nl == null) return false;
 
 								// Add the new line to the list
 								lines.Add(nl);
 
 								// Both lines must be updated because their new length
 								// is relevant for next iterations!
 								l.UpdateCache();
 								nl.UpdateCache();
 
 								// Add both lines to changedlines
 								if(changedlines != null)
 								{
 									changedlines.Add(l);
 									changedlines.Add(nl);
 								}
 
 								// Count the split
 								splitted = true;
 								break;
 							}
 						}
 					}
 					foreach(Vertex v in verts)
 					{
 						// Check if v is close enough to l for splitting
 						if(l.DistanceToSq(v.Position, true) <= splitdist2)
 						{
 							// Line is not already referencing v?
 							Vector2D deltastart = l.Start.Position - v.Position;
 							Vector2D deltaend = l.End.Position - v.Position;
 							if(((Math.Abs(deltastart.x) > 0.001f) ||
 							    (Math.Abs(deltastart.y) > 0.001f)) &&
 							   ((Math.Abs(deltaend.x) > 0.001f) ||
 							    (Math.Abs(deltaend.y) > 0.001f)))
 							{
 								// Split line l with vertex v
 								Linedef nl = l.Split(v);
 								if(nl == null) return false;
 
 								// Add the new line to the list
 								lines.Add(nl);
 
 								// Both lines must be updated because their new length
 								// is relevant for next iterations!
 								l.UpdateCache();
 								nl.UpdateCache();
 
 								// Add both lines to changedlines
 								if(changedlines != null)
 								{
 									changedlines.Add(l);
 									changedlines.Add(nl);
 								}
 
 								// Count the split
 								splitted = true;
 								break;
 							}
 						}
 					}
 
 					// Will have to restart when splitted
 					// TODO
 					// we don't have to restart when splitted?
 					if(splitted) break;
 				}
 				foreach(Linedef l in lines)
 				{
 					// Go for all the vertices
 					foreach(Vertex v in verts)
 					{
 						// Check if v is close enough to l for splitting
 						if(l.DistanceToSq(v.Position, true) <= splitdist2)
 						{
 							// Line is not already referencing v?
 							Vector2D deltastart = l.Start.Position - v.Position;
 							Vector2D deltaend = l.End.Position - v.Position;
 							if(((Math.Abs(deltastart.x) > 0.001f) ||
 							    (Math.Abs(deltastart.y) > 0.001f)) &&
 							   ((Math.Abs(deltaend.x) > 0.001f) ||
 							    (Math.Abs(deltaend.y) > 0.001f)))
 							{
 								// Split line l with vertex v
 								Linedef nl = l.Split(v);
 								if(nl == null) return false;
 
 								// Add the new line to the list
 								lines.Add(nl);
 
 								// Both lines must be updated because their new length
 								// is relevant for next iterations!
 								l.UpdateCache();
 								nl.UpdateCache();
 
 								// Add both lines to changedlines
 								if(changedlines != null)
 								{
 									changedlines.Add(l);
 									changedlines.Add(nl);
 								}
 
 								// Count the split
 								splitted = true;
 								break;
 							}
 						}
 					}
 
 					// Will have to restart when splitted
 					// TODO
 					// we don't have to restart when splitted?
 					if(splitted) break;
 				}
 			}
 			while(splitted);
 			
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="699" endline="708">
<![CDATA[
 
 		// This handles DLL linking errors
 		private static System.Reflection.Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args)
 		{
 			// Check if SlimDX failed loading
 			if(args.Name.Contains("SlimDX")) AskDownloadDirectX();
 
 			// Return null
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataLocationList.cs" startline="74" endline="86">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 
 		// This merges two lists together
 		public static DataLocationList Combined(DataLocationList a, DataLocationList b)
 		{
 			DataLocationList result = new DataLocationList();
 			result.AddRange(a);
 			result.AddRange(b);
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\GridSetup.cs" startline="250" endline="268">
<![CDATA[
 
 		#endregion
 
 		#region ================== Actions
 
 		// This shows the grid setup dialog
 		internal void ShowGridSetup()
 		{
 			// Show preferences dialog
 			GridSetupForm gridform = new GridSetupForm();
 			if(gridform.ShowDialog(General.MainWindow) == DialogResult.OK)
 			{
 				// Redraw display
 				General.MainWindow.RedrawDisplay();
 			}
 
 			// Done
 			gridform.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\Launcher.cs" startline="68" endline="85">
<![CDATA[
 
 		// Disposer
 		public void Dispose()
 		{
 			// Not yet disposed?
 			if(!isdisposed)
 			{
 				// Unbind actions
 				General.Actions.UnbindMethods(this);
 				
 				// Remove temporary file
 				try { File.Delete(tempwad); }
 				catch(Exception) { }
 				
 				// Done
 				isdisposed = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1671" endline="1690">
<![CDATA[
 
 		// This checks one of the edit mode items (and unchecks all others)
 		internal void CheckEditModeButton(string modeclassname)
 		{
 			// Go for all items
 			foreach(ToolStripItem i in editmodeitems)
 			{
 				// Check what type it is
 				if(i is ToolStripMenuItem)
 				{
 					// Check if mode type matches with given name
 					(i as ToolStripMenuItem).Checked = ((i.Tag as EditModeInfo).Type.Name == modeclassname);
 				}
 				else if(i is ToolStripButton)
 				{
 					// Check if mode type matches with given name
 					(i as ToolStripButton).Checked = ((i.Tag as EditModeInfo).Type.Name == modeclassname);
 				}
 			}
 			foreach(ToolStripItem i in editmodeitems)
 			{
 				// Check what type it is
 				if(i is ToolStripMenuItem)
 				{
 					// Check if mode type matches with given name
 					(i as ToolStripMenuItem).Checked = ((i.Tag as EditModeInfo).Type.Name == modeclassname);
 				}
 				else if(i is ToolStripButton)
 				{
 					// Check if mode type matches with given name
 					(i as ToolStripButton).Checked = ((i.Tag as EditModeInfo).Type.Name == modeclassname);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2291" endline="2323">
<![CDATA[
 
 		// Preferences action
 		[BeginAction("preferences")]
 		internal void ShowPreferences()
 		{
 			// Show preferences dialog
 			PreferencesForm prefform = new PreferencesForm();
 			if(prefform.ShowDialog(this) == DialogResult.OK)
 			{
 				// Update stuff
 				SetupInterface();
 				UpdateInterface();
 				ApplyShortcutKeys();
 				General.Colors.CreateCorrectionTable();
 				General.Plugins.ProgramReconfigure();
 				
 				// Map opened?
 				if(General.Map != null)
 				{
 					// Reload resources!
 					if(General.Map.ScriptEditor != null) General.Map.ScriptEditor.Editor.RefreshSettings();
 					General.Map.Graphics.SetupSettings();
 					General.Map.UpdateConfiguration();
 					if(prefform.ReloadResources) General.Actions.InvokeAction("builder_reloadresources");
 				}
 				
 				// Redraw display
 				RedrawDisplay();
 			}
 
 			// Done
 			prefform.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2392" endline="2415">
<![CDATA[
 
 		/// <summary>This finds the vertex closest to the specified position.</summary>
 		public static Vertex NearestVertex(ICollection<Vertex> selection, Vector2D pos)
 		{
 			Vertex closest = null;
 			float distance = float.MaxValue;
 			float d;
 			
 			// Go for all vertices in selection
 			foreach(Vertex v in selection)
 			{
 				// Calculate distance and check if closer than previous find
 				d = v.DistanceToSq(pos);
 				if(d < distance)
 				{
 					// This one is closer
 					closest = v;
 					distance = d;
 				}
 			}
 			foreach(Vertex v in selection)
 			{
 				// Calculate distance and check if closer than previous find
 				d = v.DistanceToSq(pos);
 				if(d < distance)
 				{
 					// This one is closer
 					closest = v;
 					distance = d;
 				}
 			}
 
 			// Return result
 			return closest;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2416" endline="2439">
<![CDATA[
 
 		/// <summary>This finds the thing closest to the specified position.</summary>
 		public static Thing NearestThing(ICollection<Thing> selection, Vector2D pos)
 		{
 			Thing closest = null;
 			float distance = float.MaxValue;
 			float d;
 
 			// Go for all things in selection
 			foreach(Thing t in selection)
 			{
 				// Calculate distance and check if closer than previous find
 				d = t.DistanceToSq(pos);
 				if(d < distance)
 				{
 					// This one is closer
 					closest = t;
 					distance = d;
 				}
 			}
 			foreach(Thing t in selection)
 			{
 				// Calculate distance and check if closer than previous find
 				d = t.DistanceToSq(pos);
 				if(d < distance)
 				{
 					// This one is closer
 					closest = t;
 					distance = d;
 				}
 			}
 
 			// Return result
 			return closest;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2344" endline="2366">
<![CDATA[
 
 		/// <summary>This finds the line closest to the specified position.</summary>
 		public static Linedef NearestLinedef(ICollection<Linedef> selection, Vector2D pos)
 		{
 			Linedef closest = null;
 			float distance = float.MaxValue;
 
 			// Go for all linedefs in selection
 			foreach(Linedef l in selection)
 			{
 				// Calculate distance and check if closer than previous find
 				float d = l.SafeDistanceToSq(pos, true);
 				if(d < distance)
 				{
 					// This one is closer
 					closest = l;
 					distance = d;
 				}
 			}
 			foreach(Linedef l in selection)
 			{
 				// Calculate distance and check if closer than previous find
 				float d = l.SafeDistanceToSq(pos, true);
 				if(d < distance)
 				{
 					// This one is closer
 					closest = l;
 					distance = d;
 				}
 			}
 
 			// Return result
 			return closest;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PreviewManager.cs" startline="262" endline="279">
<![CDATA[
 
 
 		#if DEBUG
 		internal void DumpAtlases()
 		{
 			lock(images)
 			{
 				int index = 0;
 				foreach(Bitmap a in images)
 				{
 					lock(a)
 					{
 						string file = Path.Combine(General.AppPath, "atlas" + index++ + ".png");
 						a.Save(file, ImageFormat.Png);
 					}
 				}
 				foreach(Bitmap a in images)
 				{
 					lock(a)
 					{
 						string file = Path.Combine(General.AppPath, "atlas" + index++ + ".png");
 						a.Save(file, ImageFormat.Png);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomPictureReader.cs" startline="107" endline="150">
<![CDATA[
 		
 		// This creates a Bitmap from the given data
 		// Returns null on failure
 		public Bitmap ReadAsBitmap(Stream stream, out int offsetx, out int offsety)
 		{
 			BitmapData bitmapdata;
 			PixelColorBlock pixeldata;
 			PixelColor* targetdata;
 			int width, height;
 			Bitmap bmp;
 
 			// Read pixel data
 			pixeldata = ReadAsPixelData(stream, out width, out height, out offsetx, out offsety);
 			if(pixeldata != null)
 			{
 				// Create bitmap and lock pixels
 				try
 				{
 					bmp = new Bitmap(width, height, PixelFormat.Format32bppArgb);
 					bitmapdata = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
 					targetdata = (PixelColor*)bitmapdata.Scan0.ToPointer();
 
 					// Copy the pixels
 					General.CopyMemory(targetdata, pixeldata.Pointer, (uint)(width * height * sizeof(PixelColor)));
 
 					// Done
 					bmp.UnlockBits(bitmapdata);
 				}
 				catch(Exception e)
 				{
 					// Unable to make bitmap
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to make Doom picture data. " + e.GetType().Name + "
 					return null;
 				}
 			}
 			else
 			{
 				// Failed loading picture
 				bmp = null;
 			}
 
 			// Return result
 			return bmp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2704" endline="2734">
<![CDATA[
 
 		/// <summary>This makes a list of unstable lines from the given vertices.
 		/// A line is unstable when one vertex is selected and the other isn't.</summary>
 		public static ICollection<Linedef> UnstableLinedefsFromVertices(ICollection<Vertex> verts)
 		{
 			Dictionary<Linedef, Linedef> lines = new Dictionary<Linedef, Linedef>();
 
 			// Go for all vertices
 			foreach(Vertex v in verts)
 			{
 				// Go for all lines
 				foreach(Linedef l in v.Linedefs)
 				{
 					// If the line exists in the list
 					if(lines.ContainsKey(l))
 					{
 						// Remove it
 						lines.Remove(l);
 					}
 					// Otherwise add it
 					else
 					{
 						// Add the line
 						lines.Add(l, l);
 					}
 				}
 				foreach(Linedef l in v.Linedefs)
 				{
 					// If the line exists in the list
 					if(lines.ContainsKey(l))
 					{
 						// Remove it
 						lines.Remove(l);
 					}
 					// Otherwise add it
 					else
 					{
 						// Add the line
 						lines.Add(l, l);
 					}
 				}
 			}
 			foreach(Vertex v in verts)
 			{
 				// Go for all lines
 				foreach(Linedef l in v.Linedefs)
 				{
 					// If the line exists in the list
 					if(lines.ContainsKey(l))
 					{
 						// Remove it
 						lines.Remove(l);
 					}
 					// Otherwise add it
 					else
 					{
 						// Add the line
 						lines.Add(l, l);
 					}
 				}
 			}
 			
 			// Return result
 			return new List<Linedef>(lines.Values);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypesManager.cs" startline="163" endline="171">
<![CDATA[
 		
 		// This returns all custom attributes
 		public TypeHandlerAttribute[] GetCustomUseAttributes()
 		{
 			List<TypeHandlerAttribute> attribs = new List<TypeHandlerAttribute>();
 			foreach(KeyValuePair<int, TypeHandlerAttribute> ta in handlertypes)
 				if(ta.Value.IsCustomUsable) attribs.Add(ta.Value);
 			foreach(KeyValuePair<int, TypeHandlerAttribute> ta in handlertypes)
 				if(ta.Value.IsCustomUsable) attribs.Add(ta.Value);
 			return attribs.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="448" endline="472">
<![CDATA[
 		
 		// This returns a preview image
 		public virtual Image GetPreview()
 		{
 			lock(this)
 			{
 				// Preview ready?
 				if(previewstate == ImageLoadState.Ready)
 				{
 					// Make a copy
 					return General.Map.Data.Previews.GetPreviewCopy(previewindex);
 				}
 				// Loading failed?
 				else if(loadfailed)
 				{
 					// Return error bitmap
 					return Properties.Resources.Failed;
 				}
 				else
 				{
 					// Return loading bitmap
 					return Properties.Resources.Hourglass;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\DecorateParser.cs" startline="225" endline="238">
<![CDATA[
 
 		/// <summary>
 		/// This returns a supported actor by DoomEdNum. Returns null when no supported actor with the specified name can be found. Please note that this operation is of O(n) complexity!
 		/// </summary>
 		public ActorStructure GetActorByDoomEdNum(int doomednum)
 		{
 			ICollection<ActorStructure> collection = actors.Values;
 			foreach(ActorStructure a in collection)
 			{
 				if(a.DoomEdNum == doomednum)
 					return a;
 			}
 			foreach(ActorStructure a in collection)
 			{
 				if(a.DoomEdNum == doomednum)
 					return a;
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="144" endline="174">
<![CDATA[
 
 		// This fills a ranges list
 		private void FindRanges(List<LumpRange> ranges, IDictionary rangeinfos, string rangename)
 		{
 			foreach(DictionaryEntry r in rangeinfos)
 			{
 				// Read start and end
 				string rangestart = General.Map.Config.ReadSetting(rangename + "." + r.Key + ".start", "");
 				string rangeend = General.Map.Config.ReadSetting(rangename + "." + r.Key + ".end", "");
 				if((rangestart.Length > 0) && (rangeend.Length > 0))
 				{
 					// Find ranges
 					int startindex = file.FindLumpIndex(rangestart);
 					while(startindex > -1)
 					{
 						LumpRange range = new LumpRange();
 						range.start = startindex;
 						range.end = file.FindLumpIndex(rangeend, startindex);
 						if(range.end > -1)
 						{
 							ranges.Add(range);
 							startindex = file.FindLumpIndex(rangestart, range.end);
 						}
 						else
 						{
 							startindex = -1;
 						}
 					}
 					while(startindex > -1)
 					{
 						LumpRange range = new LumpRange();
 						range.start = startindex;
 						range.end = file.FindLumpIndex(rangeend, startindex);
 						if(range.end > -1)
 						{
 							ranges.Add(range);
 							startindex = file.FindLumpIndex(rangestart, range.end);
 						}
 						else
 						{
 							startindex = -1;
 						}
 					}
 				}
 			}
 			foreach(DictionaryEntry r in rangeinfos)
 			{
 				// Read start and end
 				string rangestart = General.Map.Config.ReadSetting(rangename + "." + r.Key + ".start", "");
 				string rangeend = General.Map.Config.ReadSetting(rangename + "." + r.Key + ".end", "");
 				if((rangestart.Length > 0) && (rangeend.Length > 0))
 				{
 					// Find ranges
 					int startindex = file.FindLumpIndex(rangestart);
 					while(startindex > -1)
 					{
 						LumpRange range = new LumpRange();
 						range.start = startindex;
 						range.end = file.FindLumpIndex(rangeend, startindex);
 						if(range.end > -1)
 						{
 							ranges.Add(range);
 							startindex = file.FindLumpIndex(rangestart, range.end);
 						}
 						else
 						{
 							startindex = -1;
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1244" endline="1297">
<![CDATA[
 		
 		// When a key is pressed
 		private void MainForm_KeyDown(object sender, KeyEventArgs e)
 		{
 			int mod = 0;
 			
 			// Keep key modifiers
 			alt = e.Alt;
 			shift = e.Shift;
 			ctrl = e.Control;
 			if(alt) mod |= (int)Keys.Alt;
 			if(shift) mod |= (int)Keys.Shift;
 			if(ctrl) mod |= (int)Keys.Control;
 			
 			// Don't process any keys when they are meant for other input controls
 			if((ActiveControl == null) || (ActiveControl == display))
 			{
 				// Invoke any actions associated with this key
 				General.Actions.UpdateModifiers(mod);
 				e.Handled = General.Actions.KeyPressed((int)e.KeyData);
 				
 				// Invoke on editing mode
 				if((General.Map != null) && (General.Editing.Mode != null))
 				{
 					General.Plugins.OnEditKeyDown(e);
 					General.Editing.Mode.OnKeyDown(e);
 				}
 
 				// Handled
 				if(e.Handled)
 					e.SuppressKeyPress = true;
 			}
 			
 			// F1 pressed?
 			if((e.KeyCode == Keys.F1) && (e.Modifiers == Keys.None))
 			{
 				// No action bound to F1?
 				Actions.Action[] f1actions = General.Actions.GetActionsByKey((int)e.KeyData);
 				if(f1actions.Length == 0)
 				{
 					// If we don't have any map open, show the Main Window help
 					// otherwise, give the help request to the editing mode so it
 					// can open the appropriate help file.
 					if((General.Map == null) || (General.Editing.Mode == null))
 					{
 						General.ShowHelp("introduction.html");
 					}
 					else
 					{
 						General.Editing.Mode.OnHelp();
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="112" endline="187">
<![CDATA[
 
 		#endregion
 
 		#region ================== Actions
 
 		// This loads all actions from an assembly
 		internal void LoadActions(Assembly asm)
 		{
 			Stream actionsdata;
 			StreamReader actionsreader;
 			Configuration cfg;
 			string cat, name, title, desc, shortname;
 			bool amouse, akeys, ascroll, debugonly, noshift, repeat;
 			string[] resnames;
 			AssemblyName asmname = asm.GetName();
 
 			// Find a resource named Actions.cfg
 			resnames = asm.GetManifestResourceNames();
 			foreach(string rn in resnames)
 			{
 				// Found one?
 				if(rn.EndsWith(ACTIONS_RESOURCE, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					actionsdata = asm.GetManifestResourceStream(rn);
 					actionsreader = new StreamReader(actionsdata, Encoding.ASCII);
 
 					// Load configuration from stream
 					cfg = new Configuration();
 					cfg.InputConfiguration(actionsreader.ReadToEnd());
 					if(cfg.ErrorResult)
 					{
 						string errordesc = "Error in Actions configuration on line " + cfg.ErrorLine + "
 						General.CancelAutoMapLoad();
 						General.ErrorLogger.Add(ErrorType.Error, "Unable to read Actions configuration from assembly " + Path.GetFileName(asm.Location));
 						General.WriteLogLine(errordesc);
 						General.ShowErrorMessage("Unable to read Actions configuration from assembly " + Path.GetFileName(asm.Location) + "!\n" + errordesc, MessageBoxButtons.OK);
 					}
 					else
 					{
 						// Read the categories structure
 						IDictionary cats = cfg.ReadSetting("categories", new Hashtable());
 						foreach(DictionaryEntry c in cats)
 						{
 							// Make the category if not already added
 							if(!categories.ContainsKey(c.Key.ToString()))
 								categories.Add(c.Key.ToString(), c.Value.ToString());
 						}
 						foreach(DictionaryEntry c in cats)
 						{
 							// Make the category if not already added
 							if(!categories.ContainsKey(c.Key.ToString()))
 								categories.Add(c.Key.ToString(), c.Value.ToString());
 						}
 
 						// Go for all objects in the configuration
 						foreach(DictionaryEntry a in cfg.Root)
 						{
 							// Get action properties
 							shortname = a.Key.ToString();
 							name = asmname.Name.ToLowerInvariant() + "_" + shortname;
 							debugonly = cfg.ReadSetting(a.Key + ".debugonly", false);
 
 							// Not the categories structure?
 							if(shortname.ToLowerInvariant() != "categories")
 							{
 								// Check if action should be included
 								if(General.DebugBuild || !debugonly)
 								{
 									// Create an action
 									CreateAction(cfg, name, shortname);
 								}
 							}
 						}
 						foreach(DictionaryEntry a in cfg.Root)
 						{
 							// Get action properties
 							shortname = a.Key.ToString();
 							name = asmname.Name.ToLowerInvariant() + "_" + shortname;
 							debugonly = cfg.ReadSetting(a.Key + ".debugonly", false);
 
 							// Not the categories structure?
 							if(shortname.ToLowerInvariant() != "categories")
 							{
 								// Check if action should be included
 								if(General.DebugBuild || !debugonly)
 								{
 									// Create an action
 									CreateAction(cfg, name, shortname);
 								}
 							}
 						}
 					}
 					
 					// Done with the resource
 					actionsreader.Dispose();
 					actionsdata.Dispose();
 				}
 			}
 			foreach(string rn in resnames)
 			{
 				// Found one?
 				if(rn.EndsWith(ACTIONS_RESOURCE, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					actionsdata = asm.GetManifestResourceStream(rn);
 					actionsreader = new StreamReader(actionsdata, Encoding.ASCII);
 
 					// Load configuration from stream
 					cfg = new Configuration();
 					cfg.InputConfiguration(actionsreader.ReadToEnd());
 					if(cfg.ErrorResult)
 					{
 						string errordesc = "Error in Actions configuration on line " + cfg.ErrorLine + "
 						General.CancelAutoMapLoad();
 						General.ErrorLogger.Add(ErrorType.Error, "Unable to read Actions configuration from assembly " + Path.GetFileName(asm.Location));
 						General.WriteLogLine(errordesc);
 						General.ShowErrorMessage("Unable to read Actions configuration from assembly " + Path.GetFileName(asm.Location) + "!\n" + errordesc, MessageBoxButtons.OK);
 					}
 					else
 					{
 						// Read the categories structure
 						IDictionary cats = cfg.ReadSetting("categories", new Hashtable());
 						foreach(DictionaryEntry c in cats)
 						{
 							// Make the category if not already added
 							if(!categories.ContainsKey(c.Key.ToString()))
 								categories.Add(c.Key.ToString(), c.Value.ToString());
 						}
 
 						// Go for all objects in the configuration
 						foreach(DictionaryEntry a in cfg.Root)
 						{
 							// Get action properties
 							shortname = a.Key.ToString();
 							name = asmname.Name.ToLowerInvariant() + "_" + shortname;
 							debugonly = cfg.ReadSetting(a.Key + ".debugonly", false);
 
 							// Not the categories structure?
 							if(shortname.ToLowerInvariant() != "categories")
 							{
 								// Check if action should be included
 								if(General.DebugBuild || !debugonly)
 								{
 									// Create an action
 									CreateAction(cfg, name, shortname);
 								}
 							}
 						}
 					}
 					
 					// Done with the resource
 					actionsreader.Dispose();
 					actionsdata.Dispose();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="745" endline="826">
<![CDATA[
 		
 		// Key released
 		private void scriptedit_KeyUp(object sender, KeyEventArgs e)
 		{
 			bool showcalltip = false;
 			int highlightstart = 0;
 			int highlightend = 0;
 			
 			// Enter pressed?
 			if((e.KeyCode == Keys.Enter) && (e.Modifiers == Keys.None))
 			{
 				// Do we want auto-indent?
 				if(General.Settings.ScriptAutoIndent)
 				{
 					// Get the current line index and check if its not the first line
 					int curline = scriptedit.LineFromPosition(scriptedit.CurrentPos);
 					if(curline > 0)
 					{
 						// Apply identation of the previous line to this line
 						int ident = scriptedit.GetLineIndentation(curline - 1);
 						int tabs = ident ;// / scriptedit.Indent;
 						if(scriptedit.GetLineIndentation(curline) == 0)
 						{
 							scriptedit.SetLineIndentation(curline, ident);
 							scriptedit.SetSel(scriptedit.SelectionStart + tabs, scriptedit.SelectionStart + tabs);
 						}
 					}
 				}
 			}
 			
 			UpdatePositionInfo();
 			
 			// Call tip shown
 			if(scriptedit.IsCallTipActive)
 			{
 				// Should we hide the call tip?
 				if(curfunctionname.Length == 0)
 				{
 					// Hide the call tip
 					scriptedit.CallTipCancel();
 				}
 				else
 				{
 					// Update the call tip
 					showcalltip = true;
 				}
 			}
 			// No call tip
 			else
 			{
 				// Should we show a call tip?
 				showcalltip = (curfunctionname.Length > 0) && !scriptedit.IsAutoCActive;
 			}
 			
 			// Show or update call tip
 			if(showcalltip)
 			{
 				string functiondef = scriptconfig.GetFunctionDefinition(curfunctionname);
 				if(functiondef != null)
 				{
 					// Determine the range to highlight
 					int argsopenpos = functiondef.IndexOf(scriptconfig.FunctionOpen);
 					int argsclosepos = functiondef.LastIndexOf(scriptconfig.FunctionClose);
 					if((argsopenpos > -1) && (argsclosepos > -1))
 					{
 						string argsstr = functiondef.Substring(argsopenpos + 1, argsclosepos - argsopenpos - 1);
 						string[] args = argsstr.Split(scriptconfig.ArgumentDelimiter[0]);
 						if((curargumentindex >= 0) && (curargumentindex < args.Length))
 						{
 							int argoffset = 0;
 							for(int i = 0; i < curargumentindex; i++) argoffset += args[i].Length + 1;
 							highlightstart = argsopenpos + argoffset + 1;
 							highlightend = highlightstart + args[curargumentindex].Length;
 						}
 					}
 					
 					// Show tip
 					scriptedit.CallTipShow(curfunctionstartpos, functiondef);
 					scriptedit.CallTipSetHlt(highlightstart, highlightend);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\LinedefEditForm.cs" startline="8" endline="115">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		private bool preventchanges = false;
 		
 		// Constructor
 		public LinedefEditForm()
 		{
 			// Initialize
 			InitializeComponent();
 			
 			// Fill flags list
 			foreach(KeyValuePair<string, string> lf in General.Map.Config.LinedefFlags)
 				flags.Add(lf.Value, lf.Key);
 			foreach(KeyValuePair<string, string> lf in General.Map.Config.LinedefFlags)
 				flags.Add(lf.Value, lf.Key);
 
 			// Fill actions list
 			action.GeneralizedCategories = General.Map.Config.GenActionCategories;
 			action.AddInfo(General.Map.Config.SortedLinedefActions.ToArray());
 
 			// Fill activations list
 			activation.Items.AddRange(General.Map.Config.LinedefActivates.ToArray());
 			foreach(LinedefActivateInfo ai in General.Map.Config.LinedefActivates) udmfactivates.Add(ai.Title, ai);
 			
 			// Fill universal fields list
 			fieldslist.ListFixedFields(General.Map.Config.LinedefFields);
 			
 			// Initialize image selectors
 			fronthigh.Initialize();
 			frontmid.Initialize();
 			frontlow.Initialize();
 			backhigh.Initialize();
 			backmid.Initialize();
 			backlow.Initialize();
 
 			// Initialize custom fields editor
 			fieldslist.Setup("linedef");
 			
 			// Mixed activations? (UDMF)
 			if(General.Map.FormatInterface.HasMixedActivations)
 				udmfpanel.Visible = true;
 			else if(General.Map.FormatInterface.HasPresetActivations)
 				hexenpanel.Visible = true;
 			
 			// Action arguments?
 			if(General.Map.FormatInterface.HasActionArgs)
 				argspanel.Visible = true;
 			
 			// Custom fields?
 			if(!General.Map.FormatInterface.HasCustomFields)
 				tabs.TabPages.Remove(tabcustom);
 			customfrontbutton.Visible = General.Map.FormatInterface.HasCustomFields;
 			custombackbutton.Visible = General.Map.FormatInterface.HasCustomFields;
 			
 			// Arrange panels
 			if(General.Map.FormatInterface.HasPresetActivations)
 			{
 				actiongroup.Height = hexenpanel.Bottom + action.Top + (actiongroup.Width - actiongroup.ClientRectangle.Width);
 				this.Height = heightpanel1.Height;
 			}
 			else if(!General.Map.FormatInterface.HasMixedActivations &&
 				    !General.Map.FormatInterface.HasActionArgs &&
 				    !General.Map.FormatInterface.HasPresetActivations)
 			{
 				actiongroup.Height = action.Bottom + action.Top + (actiongroup.Width - actiongroup.ClientRectangle.Width);
 				this.Height = heightpanel2.Height;
 			}
 			
 			// Tag?
 			if(General.Map.FormatInterface.HasLinedefTag)
 			{
 				// Match position after the action group
 				idgroup.Top = actiongroup.Bottom + actiongroup.Margin.Bottom + idgroup.Margin.Top;
 			}
 			else
 			{
 				idgroup.Visible = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2122" endline="2154">
<![CDATA[
 
 		/// <summary>This removes looped linedefs (linedefs which reference the same vertex for
 		/// start and end) and returns the number of linedefs removed.</summary>
 		public static int RemoveLoopedLinedefs(ICollection<Linedef> lines)
 		{
 			int linesremoved = 0;
 			bool removedline;
 
 			do
 			{
 				// Nothing removed yet
 				removedline = false;
 
 				// Go for all the lines
 				foreach(Linedef l in lines)
 				{
 					// Check if referencing the same vertex twice
 					if(l.Start == l.End)
 					{
 						// Remove this line
 						while(lines.Remove(l));
 						l.Dispose();
 						linesremoved++;
 						removedline = true;
 						break;
 					}
 				}
 				foreach(Linedef l in lines)
 				{
 					// Check if referencing the same vertex twice
 					if(l.Start == l.End)
 					{
 						// Remove this line
 						while(lines.Remove(l));
 						l.Dispose();
 						linesremoved++;
 						removedline = true;
 						break;
 					}
 				}
 			}
 			while(removedline);
 
 			// Return result
 			return linesremoved;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2367" endline="2391">
<![CDATA[
 
 		/// <summary>This finds the line closest to the specified position.</summary>
 		public static Linedef NearestLinedefRange(ICollection<Linedef> selection, Vector2D pos, float maxrange)
 		{
 			Linedef closest = null;
 			float distance = float.MaxValue;
 			float maxrangesq = maxrange * maxrange;
 			float d;
 
 			// Go for all linedefs in selection
 			foreach(Linedef l in selection)
 			{
 				// Calculate distance and check if closer than previous find
 				d = l.SafeDistanceToSq(pos, true);
 				if((d <= maxrangesq) && (d < distance))
 				{
 					// This one is closer
 					closest = l;
 					distance = d;
 				}
 			}
 			foreach(Linedef l in selection)
 			{
 				// Calculate distance and check if closer than previous find
 				d = l.SafeDistanceToSq(pos, true);
 				if((d <= maxrangesq) && (d < distance))
 				{
 					// This one is closer
 					closest = l;
 					distance = d;
 				}
 			}
 			
 			// Return result
 			return closest;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2155" endline="2222">
<![CDATA[
 
 		/// <summary>This joins nearby vertices from two collections. This does NOT join vertices
 		/// within the same collection, only if they exist in both collections.
 		/// The vertex from the second collection is moved to match the first vertex.
 		/// When keepsecond is true, the vertex in the second collection is kept,
 		/// otherwise the vertex in the first collection is kept.
 		/// Returns the number of joins made.</summary>
 		public static int JoinVertices(ICollection<Vertex> set1, ICollection<Vertex> set2, bool keepsecond, float joindist)
 		{
 			float joindist2 = joindist * joindist;
 			int joinsdone = 0;
 			bool joined;
 
 			do
 			{
 				// No joins yet
 				joined = false;
 
 				// Go for all vertices in the first set
 				foreach(Vertex v1 in set1)
 				{
 					// Go for all vertices in the second set
 					foreach(Vertex v2 in set2)
 					{
 						// Check if vertices are close enough
 						if(v1.DistanceToSq(v2.Position) <= joindist2)
 						{
 							// Check if not the same vertex
 							if(v1 != v2)
 							{
 								// Move the second vertex to match the first
 								v2.Move(v1.Position);
 								
 								// Check which one to keep
 								if(keepsecond)
 								{
 									// Join the first into the second
 									// Second is kept, first is removed
 									v1.Join(v2);
 									set1.Remove(v1);
 									set2.Remove(v1);
 								}
 								else
 								{
 									// Join the second into the first
 									// First is kept, second is removed
 									v2.Join(v1);
 									set1.Remove(v2);
 									set2.Remove(v2);
 								}
 								
 								// Count the join
 								joinsdone++;
 								joined = true;
 								break;
 							}
 						}
 					}
 					foreach(Vertex v2 in set2)
 					{
 						// Check if vertices are close enough
 						if(v1.DistanceToSq(v2.Position) <= joindist2)
 						{
 							// Check if not the same vertex
 							if(v1 != v2)
 							{
 								// Move the second vertex to match the first
 								v2.Move(v1.Position);
 								
 								// Check which one to keep
 								if(keepsecond)
 								{
 									// Join the first into the second
 									// Second is kept, first is removed
 									v1.Join(v2);
 									set1.Remove(v1);
 									set2.Remove(v1);
 								}
 								else
 								{
 									// Join the second into the first
 									// First is kept, second is removed
 									v2.Join(v1);
 									set1.Remove(v2);
 									set2.Remove(v2);
 								}
 								
 								// Count the join
 								joinsdone++;
 								joined = true;
 								break;
 							}
 						}
 					}
 
 					// Will have to restart when joined
 					if(joined) break;
 				}
 				foreach(Vertex v1 in set1)
 				{
 					// Go for all vertices in the second set
 					foreach(Vertex v2 in set2)
 					{
 						// Check if vertices are close enough
 						if(v1.DistanceToSq(v2.Position) <= joindist2)
 						{
 							// Check if not the same vertex
 							if(v1 != v2)
 							{
 								// Move the second vertex to match the first
 								v2.Move(v1.Position);
 								
 								// Check which one to keep
 								if(keepsecond)
 								{
 									// Join the first into the second
 									// Second is kept, first is removed
 									v1.Join(v2);
 									set1.Remove(v1);
 									set2.Remove(v1);
 								}
 								else
 								{
 									// Join the second into the first
 									// First is kept, second is removed
 									v2.Join(v1);
 									set1.Remove(v2);
 									set2.Remove(v2);
 								}
 								
 								// Count the join
 								joinsdone++;
 								joined = true;
 								break;
 							}
 						}
 					}
 
 					// Will have to restart when joined
 					if(joined) break;
 				}
 			}
 			while(joined);
 
 			// Return result
 			return joinsdone;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="1425" endline="1442">
<![CDATA[
 		public bool SaveConfiguration(string filename, string newline, bool whitespace)
 		{
 			// Kill the file if it exists
 			if(File.Exists(filename) == true) File.Delete(filename);
 			
 			// Open file stream for writing
 			FileStream fstream = File.OpenWrite(filename);
 			
 			// Create output structure and write to file
 			string data = OutputConfiguration(newline, whitespace);
 			byte[] baData= Encoding.UTF8.GetBytes(data);
 			fstream.Write(baData, 0, baData.Length);
 			fstream.Flush();
 			fstream.Close();
 			
 			// Return true when done, false when errors occurred
 			return !cpErrorResult;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="198" endline="217">
<![CDATA[
 
 		// This finds the first file that has the specified name, regardless of file extension
 		public string GetFirstFile(string title, bool subdirectories)
 		{
 			title = title.ToLowerInvariant();
 			if(subdirectories)
 			{
 				for(int i = 0; i < entries.Length; i++)
 					if(entries[i].filetitle == title)
 						return entries[i].filepathname;
 				for(int i = 0; i < entries.Length; i++)
 					if(entries[i].filetitle == title)
 						return entries[i].filepathname;
 			}
 			else
 			{
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].filetitle == title) && (entries[i].path.Length == 0))
 						return entries[i].filepathname;
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].filetitle == title) && (entries[i].path.Length == 0))
 						return entries[i].filepathname;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="118" endline="163">
<![CDATA[
 
 		// This reads the THINGS from WAD file
 		private void ReadThings(MapSet map, int firstindex)
 		{
 			MemoryStream mem;
 			BinaryReader reader;
 			int num, i, x, y, type, flags, angle;
 			Dictionary<string, bool> stringflags;
 			Thing t;
 			
 			// Get the lump from wad file
 			Lump lump = wad.FindLump("THINGS", firstindex);
 			if(lump == null) throw new Exception("Could not find required lump THINGS!");
 			
 			// Prepare to read the items
 			mem = new MemoryStream(lump.Stream.ReadAllBytes());
 			num = (int)lump.Stream.Length / 10;
 			reader = new BinaryReader(mem);
 			
 			// Read items from the lump
 			map.SetCapacity(0, 0, 0, 0, map.Things.Count + num);
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				x = reader.ReadInt16();
 				y = reader.ReadInt16();
 				angle = reader.ReadInt16();
 				type = reader.ReadUInt16();
 				flags = reader.ReadUInt16();
 				
 				// Make string flags
 				stringflags = new Dictionary<string, bool>();
 				foreach(KeyValuePair<string, string> f in manager.Config.ThingFlags)
 				{
 					int fnum;
 					if(int.TryParse(f.Key, out fnum)) stringflags[f.Key] = ((flags & fnum) == fnum);
 				}
 				foreach(KeyValuePair<string, string> f in manager.Config.ThingFlags)
 				{
 					int fnum;
 					if(int.TryParse(f.Key, out fnum)) stringflags[f.Key] = ((flags & fnum) == fnum);
 				}
 				
 				// Create new item
 				t = map.CreateThing();
 				t.Update(type, x, y, 0, angle, stringflags, 0, 0, new int[Thing.NUM_ARGS]);
 			}
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				x = reader.ReadInt16();
 				y = reader.ReadInt16();
 				angle = reader.ReadInt16();
 				type = reader.ReadUInt16();
 				flags = reader.ReadUInt16();
 				
 				// Make string flags
 				stringflags = new Dictionary<string, bool>();
 				foreach(KeyValuePair<string, string> f in manager.Config.ThingFlags)
 				{
 					int fnum;
 					if(int.TryParse(f.Key, out fnum)) stringflags[f.Key] = ((flags & fnum) == fnum);
 				}
 				
 				// Create new item
 				t = map.CreateThing();
 				t.Update(type, x, y, 0, angle, stringflags, 0, 0, new int[Thing.NUM_ARGS]);
 			}
 
 			// Done
 			mem.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1819" endline="1844">
<![CDATA[
 
 		/// <summary>This creates an area from linedefs.</summary>
 		public static RectangleF CreateArea(ICollection<Linedef> lines)
 		{
 			float l = float.MaxValue;
 			float t = float.MaxValue;
 			float r = float.MinValue;
 			float b = float.MinValue;
 
 			// Go for all linedefs
 			foreach(Linedef ld in lines)
 			{
 				// Adjust boundaries by vertices
 				if(ld.Start.Position.x < l) l = ld.Start.Position.x;
 				if(ld.Start.Position.x > r) r = ld.Start.Position.x;
 				if(ld.Start.Position.y < t) t = ld.Start.Position.y;
 				if(ld.Start.Position.y > b) b = ld.Start.Position.y;
 				if(ld.End.Position.x < l) l = ld.End.Position.x;
 				if(ld.End.Position.x > r) r = ld.End.Position.x;
 				if(ld.End.Position.y < t) t = ld.End.Position.y;
 				if(ld.End.Position.y > b) b = ld.End.Position.y;
 			}
 			foreach(Linedef ld in lines)
 			{
 				// Adjust boundaries by vertices
 				if(ld.Start.Position.x < l) l = ld.Start.Position.x;
 				if(ld.Start.Position.x > r) r = ld.Start.Position.x;
 				if(ld.Start.Position.y < t) t = ld.Start.Position.y;
 				if(ld.Start.Position.y > b) b = ld.Start.Position.y;
 				if(ld.End.Position.x < l) l = ld.End.Position.x;
 				if(ld.End.Position.x > r) r = ld.End.Position.x;
 				if(ld.End.Position.y < t) t = ld.End.Position.y;
 				if(ld.End.Position.y > b) b = ld.End.Position.y;
 			}
 
 			// Return a rect
 			return new RectangleF(l, t, r - l, b - t);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipPolygon.cs" startline="99" endline="115">
<![CDATA[
 		
 		// This creates a bounding box from the outer polygon
 		public RectangleF CreateBBox()
 		{
 			float left = float.MaxValue;
 			float right = float.MinValue;
 			float top = float.MaxValue;
 			float bottom = float.MinValue;
 			foreach(EarClipVertex v in this)
 			{
 				if(v.Position.x < left) left = v.Position.x;
 				if(v.Position.x > right) right = v.Position.x;
 				if(v.Position.y < top) top = v.Position.y;
 				if(v.Position.y > bottom) bottom = v.Position.y;
 			}
 			foreach(EarClipVertex v in this)
 			{
 				if(v.Position.x < left) left = v.Position.x;
 				if(v.Position.x > right) right = v.Position.x;
 				if(v.Position.y < top) top = v.Position.y;
 				if(v.Position.y > bottom) bottom = v.Position.y;
 			}
 			return new RectangleF(left, top, right - left, bottom - top);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PatchNames.cs" startline="58" endline="78">
<![CDATA[
 
 		// Constructor
 		public PatchNames(Stream stream)
 		{
 			BinaryReader reader = new BinaryReader(stream);
 			uint length;
 			
 			// Read length of array
 			stream.Seek(0, SeekOrigin.Begin);
 			length = reader.ReadUInt32();
 			
 			// Create array
 			pnames = new string[length];
 
 			// Read all patch names
 			for(uint i = 0; i < length; i++)
 			{
 				byte[] bytes = reader.ReadBytes(8);
 				pnames[i] = Lump.MakeNormalName(bytes, WAD.ENCODING).ToUpperInvariant();
 			}
 			for(uint i = 0; i < length; i++)
 			{
 				byte[] bytes = reader.ReadBytes(8);
 				pnames[i] = Lump.MakeNormalName(bytes, WAD.ENCODING).ToUpperInvariant();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\Plugin.cs" startline="158" endline="175">
<![CDATA[
 		
 		// This finds all class types that inherits from the given type
 		public Type[] FindClasses(Type t)
 		{
 			List<Type> found = new List<Type>();
 			Type[] types;
 			
 			// Get all exported types
 			types = asm.GetExportedTypes();
 			foreach(Type it in types)
 			{
 				// Compare types
 				if(t.IsAssignableFrom(it)) found.Add(it);
 			}
 			foreach(Type it in types)
 			{
 				// Compare types
 				if(t.IsAssignableFrom(it)) found.Add(it);
 			}
 
 			// Return list
 			return found.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1536" endline="1555">
<![CDATA[
 
 		/// <summary>
 		/// Returns a collection of vertices that match a marked state on the linedefs.
 		/// </summary>
 		public ICollection<Vertex> GetVerticesFromLinesMarks(bool mark)
 		{
 			List<Vertex> list = new List<Vertex>(numvertices >> 1);
 			foreach(Vertex v in vertices)
 			{
 				foreach(Linedef l in v.Linedefs)
 				{
 					if(l.Marked == mark)
 					{
 						list.Add(v);
 						break;
 					}
 				}
 				foreach(Linedef l in v.Linedefs)
 				{
 					if(l.Marked == mark)
 					{
 						list.Add(v);
 						break;
 					}
 				}
 			}
 			foreach(Vertex v in vertices)
 			{
 				foreach(Linedef l in v.Linedefs)
 				{
 					if(l.Marked == mark)
 					{
 						list.Add(v);
 						break;
 					}
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1556" endline="1579">
<![CDATA[
 
 		/// <summary>
 		/// Returns a collection of vertices that match a marked state on the linedefs.
 		/// The difference with GetVerticesFromLinesMarks is that in this method
 		/// ALL linedefs of a vertex must match the specified marked state.
 		/// </summary>
 		public ICollection<Vertex> GetVerticesFromAllLinesMarks(bool mark)
 		{
 			List<Vertex> list = new List<Vertex>(numvertices >> 1);
 			foreach(Vertex v in vertices)
 			{
 				bool qualified = true;
 				foreach(Linedef l in v.Linedefs)
 				{
 					if(l.Marked != mark)
 					{
 						qualified = false;
 						break;
 					}
 				}
 				foreach(Linedef l in v.Linedefs)
 				{
 					if(l.Marked != mark)
 					{
 						qualified = false;
 						break;
 					}
 				}
 				if(qualified) list.Add(v);
 			}
 			foreach(Vertex v in vertices)
 			{
 				bool qualified = true;
 				foreach(Linedef l in v.Linedefs)
 				{
 					if(l.Marked != mark)
 					{
 						qualified = false;
 						break;
 					}
 				}
 				if(qualified) list.Add(v);
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DShader.cs" startline="95" endline="149">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This loads an effect
 		protected Effect LoadEffect(string fxfile)
 		{
 			Effect fx;
 			string errors;
 			Stream fxdata;
 			
 			// Return null when not using shaders
 			if(!manager.Enabled) return null;
 			
 			// Load the resource
 			fxdata = General.ThisAssembly.GetManifestResourceStream("CodeImp.DoomBuilder.Resources." + fxfile);
 			fxdata.Seek(0, SeekOrigin.Begin);
 			
 			try
 			{
 				// Compile effect
 				fx = Effect.FromStream(General.Map.Graphics.Device, fxdata, null, null, null, ShaderFlags.None, null, out errors);
 				if(!string.IsNullOrEmpty(errors))
 				{
 					throw new Exception("Errors in effect file " + fxfile + "
 				}
 			}
 			catch(Exception)
 			{
 				// Compiling failed, try with debug information
 				try
 				{
 					// Compile effect
 					fx = Effect.FromStream(General.Map.Graphics.Device, fxdata, null, null, null, ShaderFlags.Debug, null, out errors);
 					if(!string.IsNullOrEmpty(errors))
 					{
 						throw new Exception("Errors in effect file " + fxfile + "
 					}
 				}
 				catch(Exception e)
 				{
 					// No debug information, just crash
 					throw new Exception(e.GetType().Name + " while loading effect " + fxfile + "
 				}
 			}
 			
 			fxdata.Dispose();
 			
 			// Set the technique to use
 			fx.Technique = manager.ShaderTechnique;
 
 			// Return result
 			return fx;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CopyPasteManager.cs" startline="458" endline="521">
<![CDATA[
 		
 		// This pastes a prefab from file
 		[BeginAction("insertprefabfile")]
 		public void InsertPrefabFile()
 		{
 			// Check if possible to copy/paste
 			if(General.Editing.Mode.Attributes.AllowCopyPaste)
 			{
 				PasteOptions options = General.Settings.PasteOptions.Copy();
 
 				// Cancel volatile mode
 				General.Editing.DisengageVolatileMode();
 
 				// Let the plugins know
 				if(General.Plugins.OnPasteBegin(options))
 				{
 					// Ask the editing mode to prepare selection for pasting.
 					if(General.Editing.Mode.OnPasteBegin(options))
 					{
 						Cursor oldcursor = Cursor.Current;
 
 						OpenFileDialog openfile = new OpenFileDialog();
 						openfile.Filter = "Doom Builder Prefabs (*.dbprefab)|*.dbprefab";
 						openfile.Title = "Open Prefab";
 						openfile.AddExtension = false;
 						openfile.CheckFileExists = true;
 						openfile.Multiselect = false;
 						openfile.ValidateNames = true;
 						if(openfile.ShowDialog(General.MainWindow) == DialogResult.OK)
 						{
 							FileStream stream = null;
 
 							try
 							{
 								Cursor.Current = Cursors.WaitCursor;
 								stream = File.OpenRead(openfile.FileName);
 							}
 							catch(Exception e)
 							{
 								Cursor.Current = oldcursor;
 								General.ErrorLogger.Add(ErrorType.Error, e.GetType().Name + " while reading prefab from file
 								General.WriteLogLine(e.StackTrace);
 								General.ShowErrorMessage("Error while reading prefab from file! See log file for error details.", MessageBoxButtons.OK);
 							}
 
 							if(stream != null)
 							{
 								PastePrefab(stream, options);
 								lastprefabfile = openfile.FileName;
 							}
 							General.MainWindow.UpdateInterface();
 							stream.Dispose();
 						}
 
 						Cursor.Current = oldcursor;
 					}
 				}
 			}
 			else
 			{
 				// Insert not allowed
 				General.MessageBeep(MessageBeepType.Warning);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\SpriteImage.cs" startline="61" endline="138">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			Stream lumpdata;
 			MemoryStream mem;
 			IImageReader reader;
 			byte[] membytes;
 
 			// Leave when already loaded
 			if(this.IsImageLoaded) return;
 
 			lock(this)
 			{
 				// Get the lump data stream
 				lumpdata = General.Map.Data.GetSpriteData(Name);
 				if(lumpdata != null)
 				{
 					// Copy lump data to memory
 					lumpdata.Seek(0, SeekOrigin.Begin);
 					membytes = new byte[(int)lumpdata.Length];
 					lumpdata.Read(membytes, 0, (int)lumpdata.Length);
 					mem = new MemoryStream(membytes);
 					mem.Seek(0, SeekOrigin.Begin);
 					
 					// Get a reader for the data
 					reader = ImageDataFormat.GetImageReader(mem, ImageDataFormat.DOOMPICTURE, General.Map.Data.Palette);
 					if(reader is UnknownImageReader)
 					{
 						// Data is in an unknown format!
 						General.ErrorLogger.Add(ErrorType.Error, "Sprite lump '" + Name + "' data format could not be read. Does this lump contain valid picture data at all?");
 						bitmap = null;
 					}
 					else
 					{
 						// Read data as bitmap
 						mem.Seek(0, SeekOrigin.Begin);
 						if(bitmap != null) bitmap.Dispose();
 						bitmap = reader.ReadAsBitmap(mem, out offsetx, out offsety);
 					}
 					
 					// Done
 					mem.Dispose();
 
 					if(bitmap != null)
 					{
 						// Get width and height from image
 						width = bitmap.Size.Width;
 						height = bitmap.Size.Height;
 						scale.x = 1.0f;
 						scale.y = 1.0f;
 						
 						// Make offset corrections if the offset was not given
 						if((offsetx == int.MinValue) || (offsety == int.MinValue))
 						{
 							offsetx = (int)((width * scale.x) * 0.5f);
 							offsety = (int)(height * scale.y);
 						}
 					}
 					else
 					{
 						loadfailed = true;
 					}
 				}
 				else
 				{
 					// Missing a patch lump!
 					General.ErrorLogger.Add(ErrorType.Error, "Missing sprite lump '" + Name + "'. Forgot to include required resources?");
 				}
 
 				// Pass on to base
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="712" endline="828">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Nodebuild
 
 		// This builds the nodes in the temproary file with the given configuration name
 		private bool BuildNodes(string nodebuildername, bool failaswarning)
 		{
 			NodebuilderInfo nodebuilder;
 			string tempfile1, tempfile2, sourcefile;
 			bool lumpscomplete = false;
 			WAD buildwad;
 
 			// Find the nodebuilder
 			nodebuilder = General.GetNodebuilderByName(nodebuildername);
 			if(nodebuilder == null)
 			{
 				// Problem! Can't find that nodebuilder!
 				General.ShowWarningMessage("Unable to build the nodes
 				return false;
 			}
 			else
 			{
 				// Create the compiler interface that will run the nodebuilder
 				// This automatically creates a temporary directory for us
 				Compiler compiler = nodebuilder.CreateCompiler();
 				
 				// Make temporary filename
 				tempfile1 = General.MakeTempFilename(compiler.Location);
 
 				// Make the temporary WAD file
 				General.WriteLogLine("Creating temporary build file
 				#if DEBUG
 					buildwad = new WAD(tempfile1);
 				#else
 					try { buildwad = new WAD(tempfile1); }
 					catch(Exception e)
 					{
 						General.ShowErrorMessage("Error while creating a temporary wad file
 						return false;
 					}
 				#endif
 				
 				// Determine source file
 				if(filepathname.Length > 0)
 					sourcefile = filepathname;
 				else
 					sourcefile = tempwad.Filename;
 
 				// Copy lumps to buildwad
 				General.WriteLogLine("Copying map lumps to temporary build file...");
 				CopyLumpsByType(tempwad, TEMP_MAP_HEADER, buildwad, BUILD_MAP_HEADER, true, false, false, true);
 				
 				// Close buildwad
 				buildwad.Dispose();
 				
 				// Does the nodebuilder require an output file?
 				if(nodebuilder.HasSpecialOutputFile)
 				{
 					// Make a temporary output file for the nodebuilder
 					tempfile2 = General.MakeTempFilename(compiler.Location);
 					General.WriteLogLine("Temporary output file
 				}
 				else
 				{
 					// Output file is same as input file
 					tempfile2 = tempfile1;
 				}
 				
 				// Run the nodebuilder
 				compiler.Parameters = nodebuilder.Parameters;
 				compiler.InputFile = Path.GetFileName(tempfile1);
 				compiler.OutputFile = Path.GetFileName(tempfile2);
 				compiler.SourceFile = sourcefile;
 				compiler.WorkingDirectory = Path.GetDirectoryName(tempfile1);
 				if(compiler.Run())
 				{
 					// Open the output file
 					try { buildwad = new WAD(tempfile2); }
 					catch(Exception e)
 					{
 						General.WriteLogLine(e.GetType().Name + " while reading build wad file
 						buildwad = null;
 					}
 					
 					if(buildwad != null)
 					{
 						// Output lumps complete?
 						lumpscomplete = VerifyNodebuilderLumps(buildwad, BUILD_MAP_HEADER);
 					}
 					
 					if(lumpscomplete)
 					{
 						// Copy nodebuilder lumps to temp file
 						General.WriteLogLine("Copying nodebuilder lumps to temporary file...");
 						CopyLumpsByType(buildwad, BUILD_MAP_HEADER, tempwad, TEMP_MAP_HEADER, false, false, true, false);
 					}
 					else
 					{
 						// Nodebuilder did not build the lumps!
 						if(failaswarning)
 							General.ShowWarningMessage("Unable to build the nodes
 						else
 							General.ShowErrorMessage("Unable to build the nodes
 					}
 					
 					// Done with the build wad
 					if(buildwad != null) buildwad.Dispose();
 				}
 				
 				// Clean up
 				compiler.Dispose();
 				
 				// Return result
 				return lumpscomplete;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="110" endline="122">
<![CDATA[
 		
 		// This applies last sort order
 		private void Sort()
 		{
 			// Sort
 			int sortcolumn = General.Settings.ReadSetting("customfieldssortcolumn", 0);
 			int sortorder = General.Settings.ReadSetting("customfieldssortorder", (int)ListSortDirection.Ascending);
 
 			if(sortorder == (int)SortOrder.Ascending)
 				fieldslist.Sort(fieldslist.Columns[sortcolumn], ListSortDirection.Ascending);
 			else if(sortorder == (int)SortOrder.Descending)
 				fieldslist.Sort(fieldslist.Columns[sortcolumn], ListSortDirection.Descending);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1779" endline="1800">
<![CDATA[
 
 		/// <summary>This increases and existing area with the given vertices.</summary>
 		public static RectangleF IncreaseArea(RectangleF area, ICollection<Vector2D> verts)
 		{
 			float l = area.Left;
 			float t = area.Top;
 			float r = area.Right;
 			float b = area.Bottom;
 			
 			// Go for all vertices
 			foreach(Vector2D v in verts)
 			{
 				// Adjust boundaries by vertices
 				if(v.x < l) l = v.x;
 				if(v.x > r) r = v.x;
 				if(v.y < t) t = v.y;
 				if(v.y > b) b = v.y;
 			}
 			foreach(Vector2D v in verts)
 			{
 				// Adjust boundaries by vertices
 				if(v.x < l) l = v.x;
 				if(v.x > r) r = v.x;
 				if(v.y < t) t = v.y;
 				if(v.y > b) b = v.y;
 			}
 			
 			// Return a rect
 			return new RectangleF(l, t, r - l, b - t);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamReader.cs" startline="436" endline="484">
<![CDATA[
 
 		// This validates and returns an entry
 		private T GetCollectionEntry<T>(UniversalCollection c, string entryname, bool required, T defaultvalue, string where)
 		{
 			T result = default(T);
 			bool found = false;
 
 			// Find the entry
 			foreach(UniversalEntry e in c)
 			{
 				// Check if matches
 				if(e.Key == entryname)
 				{
 					// Let's be kind and cast any int to a float if needed
 					if((typeof(T) == typeof(float)) &&
 					   (e.Value.GetType() == typeof(int)))
 					{
 						// Make it a float
 						object fvalue = (float)(int)e.Value;
 						result = (T)fvalue;
 					}
 					else
 					{
 						// Verify type
 						e.ValidateType(typeof(T));
 
 						// Found it!
 						result = (T)e.Value;
 					}
 
 					// Done
 					found = true;
 				}
 			}
 			foreach(UniversalEntry e in c)
 			{
 				// Check if matches
 				if(e.Key == entryname)
 				{
 					// Let's be kind and cast any int to a float if needed
 					if((typeof(T) == typeof(float)) &&
 					   (e.Value.GetType() == typeof(int)))
 					{
 						// Make it a float
 						object fvalue = (float)(int)e.Value;
 						result = (T)fvalue;
 					}
 					else
 					{
 						// Verify type
 						e.ValidateType(typeof(T));
 
 						// Found it!
 						result = (T)e.Value;
 					}
 
 					// Done
 					found = true;
 				}
 			}
 
 			// Not found?
 			if(!found)
 			{
 				// Report error when entry is required!
 				if(required)
 					General.ErrorLogger.Add(ErrorType.Error, "Error while reading UDMF map data
 
 				// Make default entry
 				result = defaultvalue;
 			}
 
 			// Return result
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.cs" startline="93" endline="100">
<![CDATA[
 		
 		// Add texture
 		private void addfilter_Click(object sender, EventArgs e)
 		{
 			ListViewItem i = new ListViewItem("");
 			filters.Items.Add(i);
 			i.BeginEdit();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamReader.cs" startline="370" endline="406">
<![CDATA[
 
 		// This reads the vertices
 		private Dictionary<int, Vertex> ReadVertices(MapSet map, UniversalParser textmap)
 		{
 			Dictionary<int, Vertex> link;
 
 			// Get list of entries
 			List<UniversalCollection> collections = GetNamedCollections(textmap.Root, "vertex");
 
 			// Create lookup table
 			link = new Dictionary<int, Vertex>(collections.Count);
 
 			// Go for all collections
 			map.SetCapacity(map.Vertices.Count + collections.Count, 0, 0, 0, 0);
 			for(int i = 0; i < collections.Count; i++)
 			{
 				// Read fields
 				UniversalCollection c = collections[i];
 				string where = "vertex " + i;
 				float x = GetCollectionEntry<float>(c, "x", true, 0.0f, where);
 				float y = GetCollectionEntry<float>(c, "y", true, 0.0f, where);
 
 				// Create new item
 				Vertex v = map.CreateVertex(new Vector2D(x, y));
 				if(v != null)
 				{
 					// Custom fields
 					ReadCustomFields(c, v, "vertex");
 
 					// Add it to the lookup table
 					link.Add(i, v);
 				}
 			}
 			for(int i = 0; i < collections.Count; i++)
 			{
 				// Read fields
 				UniversalCollection c = collections[i];
 				string where = "vertex " + i;
 				float x = GetCollectionEntry<float>(c, "x", true, 0.0f, where);
 				float y = GetCollectionEntry<float>(c, "y", true, 0.0f, where);
 
 				// Create new item
 				Vertex v = map.CreateVertex(new Vector2D(x, y));
 				if(v != null)
 				{
 					// Custom fields
 					ReadCustomFields(c, v, "vertex");
 
 					// Add it to the lookup table
 					link.Add(i, v);
 				}
 			}
 
 			// Return lookup table
 			return link;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="164" endline="207">
<![CDATA[
 
 		// This reads the VERTICES from WAD file
 		// Returns a lookup table with indices
 		private Dictionary<int, Vertex> ReadVertices(MapSet map, int firstindex)
 		{
 			MemoryStream mem;
 			Dictionary<int, Vertex> link;
 			BinaryReader reader;
 			int num, i, x, y;
 			Vertex v;
 			
 			// Get the lump from wad file
 			Lump lump = wad.FindLump("VERTEXES", firstindex);
 			if(lump == null) throw new Exception("Could not find required lump VERTEXES!");
 
 			// Prepare to read the items
 			mem = new MemoryStream(lump.Stream.ReadAllBytes());
 			num = (int)lump.Stream.Length / 4;
 			reader = new BinaryReader(mem);
 
 			// Create lookup table
 			link = new Dictionary<int, Vertex>(num);
 
 			// Read items from the lump
 			map.SetCapacity(map.Vertices.Count + num, 0, 0, 0, 0);
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				x = reader.ReadInt16();
 				y = reader.ReadInt16();
 
 				// Create new item
 				v = map.CreateVertex(new Vector2D((float)x, (float)y));
 				
 				// Add it to the lookup table
 				link.Add(i, v);
 			}
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				x = reader.ReadInt16();
 				y = reader.ReadInt16();
 
 				// Create new item
 				v = map.CreateVertex(new Vector2D((float)x, (float)y));
 				
 				// Add it to the lookup table
 				link.Add(i, v);
 			}
 
 			// Done
 			mem.Dispose();
 
 			// Return lookup table
 			return link;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="174" endline="217">
<![CDATA[
 
 		// This reads the VERTICES from WAD file
 		// Returns a lookup table with indices
 		private Dictionary<int, Vertex> ReadVertices(MapSet map, int firstindex)
 		{
 			MemoryStream mem;
 			Dictionary<int, Vertex> link;
 			BinaryReader reader;
 			int num, i, x, y;
 			Vertex v;
 			
 			// Get the lump from wad file
 			Lump lump = wad.FindLump("VERTEXES", firstindex);
 			if(lump == null) throw new Exception("Could not find required lump VERTEXES!");
 
 			// Prepare to read the items
 			mem = new MemoryStream(lump.Stream.ReadAllBytes());
 			num = (int)lump.Stream.Length / 4;
 			reader = new BinaryReader(mem);
 
 			// Create lookup table
 			link = new Dictionary<int, Vertex>(num);
 
 			// Read items from the lump
 			map.SetCapacity(map.Vertices.Count + num, 0, 0, 0, 0);
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				x = reader.ReadInt16();
 				y = reader.ReadInt16();
 
 				// Create new item
 				v = map.CreateVertex(new Vector2D((float)x, (float)y));
 				
 				// Add it to the lookup table
 				link.Add(i, v);
 			}
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				x = reader.ReadInt16();
 				y = reader.ReadInt16();
 
 				// Create new item
 				v = map.CreateVertex(new Vector2D((float)x, (float)y));
 				
 				// Add it to the lookup table
 				link.Add(i, v);
 			}
 
 			// Done
 			mem.Dispose();
 
 			// Return lookup table
 			return link;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="455" endline="478">
<![CDATA[
 
 		// This resumes data resources
 		internal void Resume()
 		{
 			// Go for all containers
 			foreach(DataReader d in containers)
 			{
 				try
 				{
 					// Resume
 					General.WriteLogLine("Resumed data resource '" + d.Location.location + "'");
 					d.Resume();
 				}
 				catch(Exception e)
 				{
 					// Unable to load resource
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to load resources from location \"" + d.Location.location + "\". Please make sure the location is accessible and not in use by another program. The resources will now be loaded with this location excluded. You may reload the resources to try again.\n" + e.GetType().Name + " when resuming data reader
 					General.WriteLogLine(e.StackTrace);
 				}
 			}
 			foreach(DataReader d in containers)
 			{
 				try
 				{
 					// Resume
 					General.WriteLogLine("Resumed data resource '" + d.Location.location + "'");
 					d.Resume();
 				}
 				catch(Exception e)
 				{
 					// Unable to load resource
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to load resources from location \"" + d.Location.location + "\". Please make sure the location is accessible and not in use by another program. The resources will now be loaded with this location excluded. You may reload the resources to try again.\n" + e.GetType().Name + " when resuming data reader
 					General.WriteLogLine(e.StackTrace);
 				}
 			}
 			
 			// Start background loading
 			StartBackgroundLoader();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="915" endline="933">
<![CDATA[
 
 		// This event is called when a repaint is needed
 		private void display_Paint(object sender, PaintEventArgs e)
 		{
 			if(General.Map != null)
 			{
 				if(General.Editing.Mode != null)
 				{
 					if(!displayresized) General.Editing.Mode.OnPresentDisplay();
 				}
 				else
 				{
 					if(General.Colors != null)
 						e.Graphics.Clear(Color.FromArgb(General.Colors.Background.ToInt()));
 					else
 						e.Graphics.Clear(SystemColors.AppWorkspace);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="228" endline="250">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Configurations
 
 		// This returns the game configuration info by filename
 		internal static ConfigurationInfo GetConfigurationInfo(string filename)
 		{
 			// Go for all config infos
 			foreach(ConfigurationInfo ci in configs)
 			{
 				// Check if filename matches
 				if(string.Compare(Path.GetFileNameWithoutExtension(ci.Filename),
 								  Path.GetFileNameWithoutExtension(filename), true) == 0)
 				{
 					// Return this info
 					return ci;
 				}
 			}
 			foreach(ConfigurationInfo ci in configs)
 			{
 				// Check if filename matches
 				if(string.Compare(Path.GetFileNameWithoutExtension(ci.Filename),
 								  Path.GetFileNameWithoutExtension(filename), true) == 0)
 				{
 					// Return this info
 					return ci;
 				}
 			}
 
 			// None found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="421" endline="492">
<![CDATA[
 		
 		// This translates UDMF fields back into the normal flags and activations
 		internal void TranslateFromUDMF()
 		{
 			// Make copy of the flags
 			Dictionary<string, bool> oldfields = new Dictionary<string, bool>(flags);
 
 			// Make the flags
 			flags.Clear();
 			foreach(KeyValuePair<string, string> f in General.Map.Config.LinedefFlags)
 			{
 				// Flag must be numeric
 				int flagbit = 0;
 				if(int.TryParse(f.Key, out flagbit))
 				{
 					foreach(FlagTranslation ft in General.Map.Config.LinedefFlagsTranslation)
 					{
 						if(ft.Flag == flagbit)
 						{
 							// Only set this flag when the fields match
 							bool fieldsmatch = true;
 							for(int i = 0; i < ft.Fields.Count; i++)
 							{
 								if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 								{
 									fieldsmatch = false;
 									break;
 								}
 							}
 							for(int i = 0; i < ft.Fields.Count; i++)
 							{
 								if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 								{
 									fieldsmatch = false;
 									break;
 								}
 							}
 							
 							// Field match? Then add the flag.
 							if(fieldsmatch)
 							{
 								flags.Add(f.Key, true);
 								break;
 							}
 						}
 					}
 					foreach(FlagTranslation ft in General.Map.Config.LinedefFlagsTranslation)
 					{
 						if(ft.Flag == flagbit)
 						{
 							// Only set this flag when the fields match
 							bool fieldsmatch = true;
 							for(int i = 0; i < ft.Fields.Count; i++)
 							{
 								if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 								{
 									fieldsmatch = false;
 									break;
 								}
 							}
 							
 							// Field match? Then add the flag.
 							if(fieldsmatch)
 							{
 								flags.Add(f.Key, true);
 								break;
 							}
 						}
 					}
 				}
 			}
 			foreach(KeyValuePair<string, string> f in General.Map.Config.LinedefFlags)
 			{
 				// Flag must be numeric
 				int flagbit = 0;
 				if(int.TryParse(f.Key, out flagbit))
 				{
 					foreach(FlagTranslation ft in General.Map.Config.LinedefFlagsTranslation)
 					{
 						if(ft.Flag == flagbit)
 						{
 							// Only set this flag when the fields match
 							bool fieldsmatch = true;
 							for(int i = 0; i < ft.Fields.Count; i++)
 							{
 								if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 								{
 									fieldsmatch = false;
 									break;
 								}
 							}
 							
 							// Field match? Then add the flag.
 							if(fieldsmatch)
 							{
 								flags.Add(f.Key, true);
 								break;
 							}
 						}
 					}
 				}
 			}
 			
 			// Make the activation
 			foreach(LinedefActivateInfo a in General.Map.Config.LinedefActivates)
 			{
 				bool foundactivation = false;
 				foreach(FlagTranslation ft in General.Map.Config.LinedefFlagsTranslation)
 				{
 					if(ft.Flag == a.Index)
 					{
 						// Only set this activation when the fields match
 						bool fieldsmatch = true;
 						for(int i = 0; i < ft.Fields.Count; i++)
 						{
 							if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 							{
 								fieldsmatch = false;
 								break;
 							}
 						}
 						for(int i = 0; i < ft.Fields.Count; i++)
 						{
 							if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 							{
 								fieldsmatch = false;
 								break;
 							}
 						}
 
 						// Field match? Then add the flag.
 						if(fieldsmatch)
 						{
 							activate = a.Index;
 							foundactivation = true;
 							break;
 						}
 					}
 				}
 				foreach(FlagTranslation ft in General.Map.Config.LinedefFlagsTranslation)
 				{
 					if(ft.Flag == a.Index)
 					{
 						// Only set this activation when the fields match
 						bool fieldsmatch = true;
 						for(int i = 0; i < ft.Fields.Count; i++)
 						{
 							if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 							{
 								fieldsmatch = false;
 								break;
 							}
 						}
 
 						// Field match? Then add the flag.
 						if(fieldsmatch)
 						{
 							activate = a.Index;
 							foundactivation = true;
 							break;
 						}
 					}
 				}
 				if(foundactivation) break;
 			}
 			foreach(LinedefActivateInfo a in General.Map.Config.LinedefActivates)
 			{
 				bool foundactivation = false;
 				foreach(FlagTranslation ft in General.Map.Config.LinedefFlagsTranslation)
 				{
 					if(ft.Flag == a.Index)
 					{
 						// Only set this activation when the fields match
 						bool fieldsmatch = true;
 						for(int i = 0; i < ft.Fields.Count; i++)
 						{
 							if(!oldfields.ContainsKey(ft.Fields[i]) || (oldfields[ft.Fields[i] != ft.FieldValues[i]))
 							{
 								fieldsmatch = false;
 								break;
 							}
 						}
 
 						// Field match? Then add the flag.
 						if(fieldsmatch)
 						{
 							activate = a.Index;
 							foundactivation = true;
 							break;
 						}
 					}
 				}
 				if(foundactivation) break;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="260" endline="354">
<![CDATA[
 
 		// This finds the outer lines of the sector as a polygon
 		// Returns null when no valid outer polygon can be found
 		private static EarClipPolygon FindOuterLines(Linedef line, bool front, List<LinedefSide> alllines)
 		{
 			Linedef scanline = line;
 			bool scanfront = front;
 
 			do
 			{
 				// Find closest path
 				List<LinedefSide> pathlines = FindClosestPath(scanline, scanfront, true);
 				if(pathlines != null)
 				{
 					// Make polygon
 					LinedefTracePath tracepath = new LinedefTracePath(pathlines);
 					EarClipPolygon poly = tracepath.MakePolygon(true);
 
 					// Check if the front of the line is inside the polygon
 					if(poly.Intersect(line.GetSidePoint(front)))
 					{
 						// Outer lines found!
 						alllines.AddRange(pathlines);
 						return poly;
 					}
 					else
 					{
 						// Inner lines found. This is not what we need, we want the outer lines.
 						// Find the right-most vertex to start a scan from there towards the outer lines.
 						Vertex foundv = null;
 						foreach(LinedefSide ls in pathlines)
 						{
 							if((foundv == null) || (ls.Line.Start.Position.x > foundv.Position.x))
 								foundv = ls.Line.Start;
 							
 							if((foundv == null) || (ls.Line.End.Position.x > foundv.Position.x))
 								foundv = ls.Line.End;
 						}
 						foreach(LinedefSide ls in pathlines)
 						{
 							if((foundv == null) || (ls.Line.Start.Position.x > foundv.Position.x))
 								foundv = ls.Line.Start;
 							
 							if((foundv == null) || (ls.Line.End.Position.x > foundv.Position.x))
 								foundv = ls.Line.End;
 						}
 
 						// If foundv is null then something is horribly wrong with the
 						// path we received from FindClosestPath!
 						if(foundv == null) throw new Exception("FAIL!");
 						
 						// From the right-most vertex trace outward to the right to
 						// find the next closest linedef, this is based on the idea that
 						// all sectors are closed.
 						Vector2D lineoffset = new Vector2D(100.0f, 0.0f);
 						Line2D testline = new Line2D(foundv.Position, foundv.Position + lineoffset);
 						scanline = null;
 						float foundu = float.MaxValue;
 						foreach(Linedef ld in General.Map.Map.Linedefs)
 						{
 							// Line to the right of start point?
 							if((ld.Start.Position.x > foundv.Position.x) ||
 							   (ld.End.Position.x > foundv.Position.x))
 							{
 								// Line intersecting the y axis?
 								if( !((ld.Start.Position.y > foundv.Position.y) &&
 									  (ld.End.Position.y > foundv.Position.y)) &&
 								    !((ld.Start.Position.y < foundv.Position.y) &&
 									  (ld.End.Position.y < foundv.Position.y)))
 								{
 									// Check if this linedef intersects our test line at a closer range
 									float thisu;
 									ld.Line.GetIntersection(testline, out thisu);
 									if((thisu > 0.00001f) && (thisu < foundu) && !float.IsNaN(thisu))
 									{
 										scanline = ld;
 										foundu = thisu;
 									}
 								}
 							}
 						}
 						foreach(Linedef ld in General.Map.Map.Linedefs)
 						{
 							// Line to the right of start point?
 							if((ld.Start.Position.x > foundv.Position.x) ||
 							   (ld.End.Position.x > foundv.Position.x))
 							{
 								// Line intersecting the y axis?
 								if( !((ld.Start.Position.y > foundv.Position.y) &&
 									  (ld.End.Position.y > foundv.Position.y)) &&
 								    !((ld.Start.Position.y < foundv.Position.y) &&
 									  (ld.End.Position.y < foundv.Position.y)))
 								{
 									// Check if this linedef intersects our test line at a closer range
 									float thisu;
 									ld.Line.GetIntersection(testline, out thisu);
 									if((thisu > 0.00001f) && (thisu < foundu) && !float.IsNaN(thisu))
 									{
 										scanline = ld;
 										foundu = thisu;
 									}
 								}
 							}
 						}
 
 						// Did we meet another line?
 						if(scanline != null)
 						{
 							// Determine on which side we should start the next pathfind
 							scanfront = (scanline.SideOfLine(foundv.Position) < 0.0f);
 						}
 						else
 						{
 							// Appearently we reached the end of the map, no sector possible here
 							return null;
 						}
 					}
 				}
 				else
 				{
 					// Can't find a path
 					return null;
 				}
 			}
 			while(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3Reader.cs" startline="365" endline="376">
<![CDATA[
 
 		// This creates a temp file for the speciied file and return the absolute path to the temp file
 		// NOTE
 		protected override string CreateTempFile(string filename)
 		{
 			// Just copy the file
 			string tempfile = General.MakeTempFilename(General.Map.TempPath, "wad");
 			MemoryStream filedata = LoadFile(filename);
 			File.WriteAllBytes(tempfile, filedata.ToArray());
 			filedata.Dispose();
 			return tempfile;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2472" endline="2503">
<![CDATA[
 
 		/// <summary>This finds the thing closest to the specified position.</summary>
 		public static Thing NearestThingSquareRange(ICollection<Thing> selection, Vector2D pos, float maxrange)
 		{
 			RectangleF range = RectangleF.FromLTRB(pos.x - maxrange, pos.y - maxrange, pos.x + maxrange, pos.y + maxrange);
 			Thing closest = null;
 			float distance = float.MaxValue;
 			float d;
 
 			// Go for all vertices in selection
 			foreach(Thing t in selection)
 			{
 				// Within range?
 				if((t.Position.x >= (range.Left - t.Size)) && (t.Position.x <= (range.Right + t.Size)))
 				{
 					if((t.Position.y >= (range.Top - t.Size)) && (t.Position.y <= (range.Bottom + t.Size)))
 					{
 						// Close than previous find?
 						d = Math.Abs(t.Position.x - pos.x) + Math.Abs(t.Position.y - pos.y);
 						if(d < distance)
 						{
 							// This one is closer
 							closest = t;
 							distance = d;
 						}
 					}
 				}
 			}
 			foreach(Thing t in selection)
 			{
 				// Within range?
 				if((t.Position.x >= (range.Left - t.Size)) && (t.Position.x <= (range.Right + t.Size)))
 				{
 					if((t.Position.y >= (range.Top - t.Size)) && (t.Position.y <= (range.Bottom + t.Size)))
 					{
 						// Close than previous find?
 						d = Math.Abs(t.Position.x - pos.x) + Math.Abs(t.Position.y - pos.y);
 						if(d < distance)
 						{
 							// This one is closer
 							closest = t;
 							distance = d;
 						}
 					}
 				}
 			}
 
 			// Return result
 			return closest;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="873" endline="914">
<![CDATA[
 
 		#endregion
 
 		#region ================== Deserialization
 
 		// This serializes the MapSet
 		private void Deserialize(MemoryStream stream)
 		{
 			stream.Seek(0, SeekOrigin.Begin);
 			DeserializerStream deserializer = new DeserializerStream(stream);
 
 			deserializer.Begin();
 
 			// Read private data
 			int c;
 			deserializer.rInt(out lastsectorindex);
 			deserializer.rInt(out c);
 			indexholes = new List<int>(c);
 			for(int i = 0; i < c; i++)
 			{
 				int index; deserializer.rInt(out index);
 				indexholes.Add(index);
 			}
 			for(int i = 0; i < c; i++)
 			{
 				int index; deserializer.rInt(out index);
 				indexholes.Add(index);
 			}
 
 			// Read map data
 			Vertex[] verticesarray = ReadVertices(deserializer);
 			Sector[] sectorsarray = ReadSectors(deserializer);
 			Linedef[] linedefsarray = ReadLinedefs(deserializer, verticesarray);
 			ReadSidedefs(deserializer, linedefsarray, sectorsarray);
 			ReadThings(deserializer);
 
 			deserializer.End();
 
 			// Make table of sidedef indices
 			sidedefindices = new Sidedef[numsidedefs];
 			foreach(Sidedef sd in sidedefs)
 				sidedefindices[sd.SerializedIndex] = sd;
 			foreach(Sidedef sd in sidedefs)
 				sidedefindices[sd.SerializedIndex] = sd;
 				
 			// Call PostDeserialize
 			foreach(Sector s in sectors)
 				s.PostDeserialize(this);
 			foreach(Sector s in sectors)
 				s.PostDeserialize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1349" endline="1397">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Toolbar
 		
 		// This updates the skills list
 		private void UpdateSkills()
 		{
 			// Clear list
 			buttontest.DropDownItems.Clear();
 			
 			// Map loaded?
 			if(General.Map != null)
 			{
 				// Make the new skills list
 				skills = new ToolStripItem[(General.Map.Config.Skills.Count * 2) + 1];
 				int addindex = 0;
 				
 				// Positive skills are with monsters
 				for(int i = 0; i < General.Map.Config.Skills.Count; i++)
 				{
 					ToolStripMenuItem menuitem = new ToolStripMenuItem(General.Map.Config.Skills[i].ToString());
 					menuitem.Image = Properties.Resources.Monster2;
 					menuitem.Click += new EventHandler(TestSkill_Click);
 					menuitem.Tag = General.Map.Config.Skills[i].Index;
 					menuitem.Checked = (General.Settings.TestMonsters && (General.Map.ConfigSettings.TestSkill == General.Map.Config.Skills[i].Index));
 					skills[addindex++] = menuitem;
 				}
 				for(int i = 0; i < General.Map.Config.Skills.Count; i++)
 				{
 					ToolStripMenuItem menuitem = new ToolStripMenuItem(General.Map.Config.Skills[i].ToString());
 					menuitem.Image = Properties.Resources.Monster2;
 					menuitem.Click += new EventHandler(TestSkill_Click);
 					menuitem.Tag = General.Map.Config.Skills[i].Index;
 					menuitem.Checked = (General.Settings.TestMonsters && (General.Map.ConfigSettings.TestSkill == General.Map.Config.Skills[i].Index));
 					skills[addindex++] = menuitem;
 				}
 
 				// Add seperator
 				skills[addindex] = new ToolStripSeparator();
 				skills[addindex].Padding = new Padding(0, 3, 0, 3);
 				addindex++;
 
 				// Negative skills are without monsters
 				for(int i = 0; i < General.Map.Config.Skills.Count; i++)
 				{
 					ToolStripMenuItem menuitem = new ToolStripMenuItem(General.Map.Config.Skills[i].ToString());
 					menuitem.Image = Properties.Resources.Monster3;
 					menuitem.Click += new EventHandler(TestSkill_Click);
 					menuitem.Tag = -General.Map.Config.Skills[i].Index;
 					menuitem.Checked = (!General.Settings.TestMonsters && (General.Map.ConfigSettings.TestSkill == General.Map.Config.Skills[i].Index));
 					skills[addindex++] = menuitem;
 				}
 				for(int i = 0; i < General.Map.Config.Skills.Count; i++)
 				{
 					ToolStripMenuItem menuitem = new ToolStripMenuItem(General.Map.Config.Skills[i].ToString());
 					menuitem.Image = Properties.Resources.Monster3;
 					menuitem.Click += new EventHandler(TestSkill_Click);
 					menuitem.Tag = -General.Map.Config.Skills[i].Index;
 					menuitem.Checked = (!General.Settings.TestMonsters && (General.Map.ConfigSettings.TestSkill == General.Map.Config.Skills[i].Index));
 					skills[addindex++] = menuitem;
 				}
 				
 				// Add to list
 				buttontest.DropDownItems.AddRange(skills);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="311" endline="348">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Sprites
 
 		// This loads the textures
 		public override ICollection<ImageData> LoadSprites()
 		{
 			Dictionary<long, ImageData> images = new Dictionary<long, ImageData>();
 			ICollection<ImageData> collection;
 			List<ImageData> imgset = new List<ImageData>();
 			
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 			
 			// Load from wad files
 			// Note the backward order, because the last wad's images have priority
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				collection = wads[i].LoadSprites();
 				AddImagesToList(images, collection);
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				collection = wads[i].LoadSprites();
 				AddImagesToList(images, collection);
 			}
 			
 			// Load TEXTURES lump file
 			imgset.Clear();
 			string[] alltexturefiles = GetAllFilesWithTitle("", "TEXTURES", false);
 			foreach(string texturesfile in alltexturefiles)
 			{
 				MemoryStream filedata = LoadFile(texturesfile);
 				WADReader.LoadHighresSprites(filedata, texturesfile, ref imgset, null, null);
 				filedata.Dispose();
 			}
 			foreach(string texturesfile in alltexturefiles)
 			{
 				MemoryStream filedata = LoadFile(texturesfile);
 				WADReader.LoadHighresSprites(filedata, texturesfile, ref imgset, null, null);
 				filedata.Dispose();
 			}
 			
 			// Add images from TEXTURES lump file
 			AddImagesToList(images, imgset);
 			
 			return new List<ImageData>(images.Values);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="214" endline="294">
<![CDATA[
 		
 		
 		#endregion
 		
 		#region ================== Tracing
 
 		// This traces sector lines to create a polygon tree
 		private List<EarClipPolygon> DoTrace(Sector s)
 		{
 			Dictionary<Sidedef, bool> todosides = new Dictionary<Sidedef, bool>(s.Sidedefs.Count);
 			Dictionary<Vertex, Vertex> ignores = new Dictionary<Vertex,Vertex>();
 			List<EarClipPolygon> root = new List<EarClipPolygon>();
 			SidedefsTracePath path;
 			EarClipPolygon newpoly;
 			Vertex start;
 			
 			// Fill the dictionary
 			// The bool value is used to indicate lines which has been visited in the trace
 			foreach(Sidedef sd in s.Sidedefs) todosides.Add(sd, false);
 			
 			// First remove all sides that refer to the same sector on both sides of the line
 			RemoveDoubleSidedefReferences(todosides, s.Sidedefs);
 
 			// Continue until all sidedefs have been processed
 			while(todosides.Count > 0)
 			{
 				// Reset all visited indicators
 				foreach(Sidedef sd in s.Sidedefs) if(todosides.ContainsKey(sd)) todosides[sd] = false;
 				
 				// Find the right-most vertex to start a trace with.
 				// This guarantees that we start out with an outer polygon and we just
 				// have to check if it is inside a previously found polygon.
 				start = FindRightMostVertex(todosides, ignores);
 
 				// No more possible start vertex found?
 				// Then leave with what we have up till now.
 				if(start == null) break;
 				
 				// Trace to find a polygon
 				path = DoTracePath(new SidedefsTracePath(), start, null, s, todosides);
 
 				// If tracing is not possible (sector not closed?)
 				// then add the start to the ignore list and try again later
 				if(path == null)
 				{
 					// Ignore vertex as start
 					ignores.Add(start, start);
 				}
 				else
 				{
 					// Remove the sides found in the path
 					foreach(Sidedef sd in path) todosides.Remove(sd);
 
 					// Create the polygon
 					newpoly = path.MakePolygon();
 					
 					// Determine where this polygon goes in our tree
 					foreach(EarClipPolygon p in root)
 					{
 						// Insert if it belongs as a child
 						if(p.InsertChild(newpoly))
 						{
 							// Done
 							newpoly = null;
 							break;
 						}
 					}
 					foreach(EarClipPolygon p in root)
 					{
 						// Insert if it belongs as a child
 						if(p.InsertChild(newpoly))
 						{
 							// Done
 							newpoly = null;
 							break;
 						}
 					}
 
 					// Still not inserted in our tree?
 					if(newpoly != null)
 					{
 						// Then add it at root level as outer polygon
 						newpoly.Inner = false;
 						root.Add(newpoly);
 					}
 				}
 			}
 			while(todosides.Count > 0)
 			{
 				// Reset all visited indicators
 				foreach(Sidedef sd in s.Sidedefs) if(todosides.ContainsKey(sd)) todosides[sd] = false;
 				
 				// Find the right-most vertex to start a trace with.
 				// This guarantees that we start out with an outer polygon and we just
 				// have to check if it is inside a previously found polygon.
 				start = FindRightMostVertex(todosides, ignores);
 
 				// No more possible start vertex found?
 				// Then leave with what we have up till now.
 				if(start == null) break;
 				
 				// Trace to find a polygon
 				path = DoTracePath(new SidedefsTracePath(), start, null, s, todosides);
 
 				// If tracing is not possible (sector not closed?)
 				// then add the start to the ignore list and try again later
 				if(path == null)
 				{
 					// Ignore vertex as start
 					ignores.Add(start, start);
 				}
 				else
 				{
 					// Remove the sides found in the path
 					foreach(Sidedef sd in path) todosides.Remove(sd);
 
 					// Create the polygon
 					newpoly = path.MakePolygon();
 					
 					// Determine where this polygon goes in our tree
 					foreach(EarClipPolygon p in root)
 					{
 						// Insert if it belongs as a child
 						if(p.InsertChild(newpoly))
 						{
 							// Done
 							newpoly = null;
 							break;
 						}
 					}
 
 					// Still not inserted in our tree?
 					if(newpoly != null)
 					{
 						// Then add it at root level as outer polygon
 						newpoly.Inner = false;
 						root.Add(newpoly);
 					}
 				}
 			}
 
 			// Return result
 			return root;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="1310" endline="1438">
<![CDATA[
 		
 		// This compiles a script lump and returns any errors that may have occurred
 		// Returns true when our code worked properly (even when the compiler returned errors)
 		internal bool CompileLump(string lumpname, bool clearerrors)
 		{
 			string inputfile, outputfile, sourcefile;
 			Compiler compiler;
 			byte[] filedata;
 			string reallumpname = lumpname;
 			
 			// Find the lump
 			if(lumpname == CONFIG_MAP_HEADER) reallumpname = TEMP_MAP_HEADER;
 			Lump lump = tempwad.FindLump(reallumpname);
 			if(lump == null) throw new Exception("No such lump in temporary wad file '" + reallumpname + "'.");
 			
 			// Determine source file
 			if(filepathname.Length > 0)
 				sourcefile = filepathname;
 			else
 				sourcefile = tempwad.Filename;
 			
 			// New list of errors
 			if(clearerrors) errors.Clear();
 			
 			// Determine the script configuration to use
 			ScriptConfiguration scriptconfig = config.MapLumps[lumpname].script;
 			if(scriptconfig.Compiler != null)
 			{
 				try
 				{
 					// Initialize compiler
 					compiler = scriptconfig.Compiler.Create();
 				}
 				catch(Exception e)
 				{
 					// Fail
 					errors.Add(new CompilerError("Unable to initialize compiler. " + e.GetType().Name + "
 					return false;
 				}
 
 				try
 				{
 					// Write lump data to temp script file in compiler's temp directory
 					inputfile = General.MakeTempFilename(compiler.Location, "tmp");
 					lump.Stream.Seek(0, SeekOrigin.Begin);
 					BinaryReader reader = new BinaryReader(lump.Stream);
 					File.WriteAllBytes(inputfile, reader.ReadBytes((int)lump.Stream.Length));
 				}
 				catch(Exception e)
 				{
 					// Fail
 					compiler.Dispose();
 					errors.Add(new CompilerError("Unable to write script to working file. " + e.GetType().Name + "
 					return false;
 				}
 				
 				// Make random output filename
 				outputfile = General.MakeTempFilename(compiler.Location, "tmp");
 				
 				// Run compiler
 				compiler.Parameters = scriptconfig.Parameters;
 				compiler.InputFile = Path.GetFileName(inputfile);
 				compiler.OutputFile = Path.GetFileName(outputfile);
 				compiler.SourceFile = sourcefile;
 				compiler.WorkingDirectory = Path.GetDirectoryName(inputfile);
 				if(compiler.Run())
 				{
 					// Process errors
 					foreach(CompilerError e in compiler.Errors)
 					{
 						CompilerError newerror = e;
 
 						// If the error's filename equals our temporary file,
 						// use the lump name instead and prefix it with ?
 						if(string.Compare(e.filename, inputfile, true) == 0)
 							newerror.filename = "?" + reallumpname;
 
 						errors.Add(newerror);
 					}
 					foreach(CompilerError e in compiler.Errors)
 					{
 						CompilerError newerror = e;
 
 						// If the error's filename equals our temporary file,
 						// use the lump name instead and prefix it with ?
 						if(string.Compare(e.filename, inputfile, true) == 0)
 							newerror.filename = "?" + reallumpname;
 
 						errors.Add(newerror);
 					}
 
 					// No errors?
 					if(compiler.Errors.Length == 0)
 					{
 						// Output file exists?
 						if(File.Exists(outputfile))
 						{
 							// Copy output file data into a lump?
 							if(!string.IsNullOrEmpty(scriptconfig.ResultLump))
 							{
 								// Do that now then
 								try
 								{
 									filedata = File.ReadAllBytes(outputfile);
 								}
 								catch(Exception e)
 								{
 									// Fail
 									compiler.Dispose();
 									errors.Add(new CompilerError("Unable to read compiler output file. " + e.GetType().Name + "
 									return false;
 								}
 
 								// Store data
 								MemoryStream stream = new MemoryStream(filedata);
 								SetLumpData(scriptconfig.ResultLump, stream);
 							}
 						}
 					}
 
 					// Clean up
 					compiler.Dispose();
 					
 					// Done
 					return true;
 				}
 				else
 				{
 					// Fail
 					compiler.Dispose();
 					errors = null;
 					return false;
 				}
 			}
 			else
 			{
 				// No compiler to run for this script type
 				return true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1619" endline="1670">
<![CDATA[
 		
 		// This enables or disables all editing mode items and toolbar buttons
 		private void UpdateToolbar()
 		{
 			preventupdateseperators = true;
 			
 			// Show/hide items based on preferences
 			buttonnewmap.Visible = General.Settings.ToolbarFile;
 			buttonopenmap.Visible = General.Settings.ToolbarFile;
 			buttonsavemap.Visible = General.Settings.ToolbarFile;
 			buttonscripteditor.Visible = General.Settings.ToolbarScript;
 			buttonundo.Visible = General.Settings.ToolbarUndo;
 			buttonredo.Visible = General.Settings.ToolbarUndo;
 			buttoncut.Visible = General.Settings.ToolbarCopy;
 			buttoncopy.Visible = General.Settings.ToolbarCopy;
 			buttonpaste.Visible = General.Settings.ToolbarCopy;
 			buttoninsertprefabfile.Visible = General.Settings.ToolbarPrefabs;
 			buttoninsertpreviousprefab.Visible = General.Settings.ToolbarPrefabs;
 			buttonthingsfilter.Visible = General.Settings.ToolbarFilter;
 			thingfilters.Visible = General.Settings.ToolbarFilter;
 			buttonviewbrightness.Visible = General.Settings.ToolbarViewModes;
 			buttonviewceilings.Visible = General.Settings.ToolbarViewModes;
 			buttonviewfloors.Visible = General.Settings.ToolbarViewModes;
 			buttonviewnormal.Visible = General.Settings.ToolbarViewModes;
 			buttonsnaptogrid.Visible = General.Settings.ToolbarGeometry;
 			buttonautomerge.Visible = General.Settings.ToolbarGeometry;
 			buttontest.Visible = General.Settings.ToolbarTesting;
 
 			// Enable/disable all edit mode items
 			foreach(ToolStripItem i in editmodeitems) i.Enabled = (General.Map != null);
 
 			// Update plugin buttons
 			foreach(PluginToolbarButton p in pluginbuttons)
 			{
 				switch(p.section)
 				{
 					case ToolbarSection.File
 					case ToolbarSection.Script
 					case ToolbarSection.UndoRedo
 					case ToolbarSection.CopyPaste
 					case ToolbarSection.Prefabs
 					case ToolbarSection.Things
 					case ToolbarSection.Views
 					case ToolbarSection.Geometry
 					case ToolbarSection.Testing
 				}
 			}
 			foreach(PluginToolbarButton p in pluginbuttons)
 			{
 				switch(p.section)
 				{
 					case ToolbarSection.File
 					case ToolbarSection.Script
 					case ToolbarSection.UndoRedo
 					case ToolbarSection.CopyPaste
 					case ToolbarSection.Prefabs
 					case ToolbarSection.Things
 					case ToolbarSection.Views
 					case ToolbarSection.Geometry
 					case ToolbarSection.Testing
 				}
 			}
 
 			preventupdateseperators = false;
 
 			UpdateSeparators();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\OpenMapOptionsForm.cs" startline="221" endline="314">
<![CDATA[
 
 		// Configuration is selected
 		private void config_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			List<ListViewItem> mapnames;
 			ConfigurationInfo ci;
 			Configuration cfg;
 			IDictionary maplumpnames;
 			int scanindex, checkoffset;
 			int lumpsfound, lumpsrequired = 0;
 			string lumpname, selectedname = "";
 
 			// Anything selected?
 			if(config.SelectedIndex > -1)
 			{
 				// Keep selected name, if any
 				if(mapslist.SelectedItems.Count > 0)
 					selectedname = mapslist.SelectedItems[0].Text;
 
 				// Make an array for the map names
 				mapnames = new List<ListViewItem>();
 
 				// Get selected configuration info
 				ci = (ConfigurationInfo)config.SelectedItem;
 				
 				// Load this configuration
 				cfg = General.LoadGameConfiguration(ci.Filename);
 
 				// Get the map lump names
 				maplumpnames = cfg.ReadSetting("maplumpnames", new Hashtable());
 
 				// Count how many required lumps we have to find
 				foreach(DictionaryEntry ml in maplumpnames)
 				{
 					// Ignore the map header (it will not be found because the name is different)
 					if(ml.Key.ToString() != MapManager.CONFIG_MAP_HEADER)
 					{
 						// Read lump setting and count it
 						if(cfg.ReadSetting("maplumpnames." + ml.Key + ".required", false)) lumpsrequired++;
 					}
 				}
 				foreach(DictionaryEntry ml in maplumpnames)
 				{
 					// Ignore the map header (it will not be found because the name is different)
 					if(ml.Key.ToString() != MapManager.CONFIG_MAP_HEADER)
 					{
 						// Read lump setting and count it
 						if(cfg.ReadSetting("maplumpnames." + ml.Key + ".required", false)) lumpsrequired++;
 					}
 				}
 
 				// Go for all the lumps in the wad
 				for(scanindex = 0; scanindex < (wadfile.Lumps.Count - 1); scanindex++)
 				{
 					// Make sure this lump is not part of the map
 					if(!maplumpnames.Contains(wadfile.Lumps[scanindex].Name))
 					{
 						// Reset check
 						lumpsfound = 0;
 						checkoffset = 1;
 
 						// Continue while still within bounds and lumps are still recognized
 						while(((scanindex + checkoffset) < wadfile.Lumps.Count) &&
 							  maplumpnames.Contains(wadfile.Lumps[scanindex + checkoffset].Name))
 						{
 							// Count the lump when it is marked as required
 							lumpname = wadfile.Lumps[scanindex + checkoffset].Name;
 							if(cfg.ReadSetting("maplumpnames." + lumpname + ".required", false)) lumpsfound++;
 
 							// Check the next lump
 							checkoffset++;
 						}
 						while(((scanindex + checkoffset) < wadfile.Lumps.Count) &&
 							  maplumpnames.Contains(wadfile.Lumps[scanindex + checkoffset].Name))
 						{
 							// Count the lump when it is marked as required
 							lumpname = wadfile.Lumps[scanindex + checkoffset].Name;
 							if(cfg.ReadSetting("maplumpnames." + lumpname + ".required", false)) lumpsfound++;
 
 							// Check the next lump
 							checkoffset++;
 						}
 
 						// Map found? Then add it to the list
 						if(lumpsfound >= lumpsrequired)
 							mapnames.Add(new ListViewItem(wadfile.Lumps[scanindex].Name));
 					}
 				}
 				for(scanindex = 0; scanindex < (wadfile.Lumps.Count - 1); scanindex++)
 				{
 					// Make sure this lump is not part of the map
 					if(!maplumpnames.Contains(wadfile.Lumps[scanindex].Name))
 					{
 						// Reset check
 						lumpsfound = 0;
 						checkoffset = 1;
 
 						// Continue while still within bounds and lumps are still recognized
 						while(((scanindex + checkoffset) < wadfile.Lumps.Count) &&
 							  maplumpnames.Contains(wadfile.Lumps[scanindex + checkoffset].Name))
 						{
 							// Count the lump when it is marked as required
 							lumpname = wadfile.Lumps[scanindex + checkoffset].Name;
 							if(cfg.ReadSetting("maplumpnames." + lumpname + ".required", false)) lumpsfound++;
 
 							// Check the next lump
 							checkoffset++;
 						}
 
 						// Map found? Then add it to the list
 						if(lumpsfound >= lumpsrequired)
 							mapnames.Add(new ListViewItem(wadfile.Lumps[scanindex].Name));
 					}
 				}
 
 				// Clear the list and add the new map names
 				mapslist.BeginUpdate();
 				mapslist.Items.Clear();
 				mapslist.Items.AddRange(mapnames.ToArray());
 				mapslist.Sort();
 
 				// Go for all items in the list
 				foreach(ListViewItem item in mapslist.Items)
 				{
 					// Was this item previously selected?
 					if(item.Text == selectedname)
 					{
 						// Select it again
 						item.Selected = true;
 						break;
 					}
 				}
 				foreach(ListViewItem item in mapslist.Items)
 				{
 					// Was this item previously selected?
 					if(item.Text == selectedname)
 					{
 						// Select it again
 						item.Selected = true;
 						break;
 					}
 				}
 				if((mapslist.SelectedItems.Count == 0) && (mapslist.Items.Count > 0)) mapslist.Items[0].Selected = true;
 				mapslist.EndUpdate();
 
 				// Show configuration resources
 				datalocations.FixedResourceLocationList(ci.Resources);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="304" endline="425">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Visibility Culling
 		
 		// This preforms visibility culling
 		protected void DoCulling()
 		{
 			Dictionary<Linedef, Linedef> visiblelines = new Dictionary<Linedef, Linedef>(200);
 			Vector2D campos2d = (Vector2D)General.Map.VisualCamera.Position;
 			float viewdist = General.Settings.ViewDistance;
 			
 			// Make collections
 			visiblesectors = new Dictionary<Sector, VisualSector>(visiblesectors.Count);
 			visiblegeometry = new List<VisualGeometry>(visiblegeometry.Capacity);
 			visiblethings = new List<VisualThing>(visiblethings.Capacity);
 
 			// Get the blocks within view range
 			visibleblocks = blockmap.GetFrustumRange(renderer.Frustum2D);
 			
 			// Fill collections with geometry and things
 			foreach(VisualBlockEntry block in visibleblocks)
 			{
 				if(processgeometry)
 				{
 					// Lines
 					foreach(Linedef ld in block.Lines)
 					{
 						// Line not already processed?
 						if(!visiblelines.ContainsKey(ld))
 						{
 							// Add line if not added yet
 							visiblelines.Add(ld, ld);
 
 							// Which side of the line is the camera on?
 							if(ld.SideOfLine(campos2d) < 0)
 							{
 								// Do front of line
 								if(ld.Front != null) ProcessSidedefCulling(ld.Front);
 							}
 							else
 							{
 								// Do back of line
 								if(ld.Back != null) ProcessSidedefCulling(ld.Back);
 							}
 						}
 					}
 					foreach(Linedef ld in block.Lines)
 					{
 						// Line not already processed?
 						if(!visiblelines.ContainsKey(ld))
 						{
 							// Add line if not added yet
 							visiblelines.Add(ld, ld);
 
 							// Which side of the line is the camera on?
 							if(ld.SideOfLine(campos2d) < 0)
 							{
 								// Do front of line
 								if(ld.Front != null) ProcessSidedefCulling(ld.Front);
 							}
 							else
 							{
 								// Do back of line
 								if(ld.Back != null) ProcessSidedefCulling(ld.Back);
 							}
 						}
 					}
 				}
 
 				if(processthings)
 				{
 					// Things
 					foreach(Thing t in block.Things)
 					{
 						VisualThing vt;
 
 						// Not filtered out?
 						if(General.Map.ThingsFilter.IsThingVisible(t))
 						{
 							if(allthings.ContainsKey(t))
 							{
 								vt = allthings[t];
 							}
 							else
 							{
 								// Create new visual thing
 								vt = CreateVisualThing(t);
 								allthings.Add(t, vt);
 							}
 
 							if(vt != null)
 							{
 								visiblethings.Add(vt);
 							}
 						}
 					}
 					foreach(Thing t in block.Things)
 					{
 						VisualThing vt;
 
 						// Not filtered out?
 						if(General.Map.ThingsFilter.IsThingVisible(t))
 						{
 							if(allthings.ContainsKey(t))
 							{
 								vt = allthings[t];
 							}
 							else
 							{
 								// Create new visual thing
 								vt = CreateVisualThing(t);
 								allthings.Add(t, vt);
 							}
 
 							if(vt != null)
 							{
 								visiblethings.Add(vt);
 							}
 						}
 					}
 				}
 			}
 			foreach(VisualBlockEntry block in visibleblocks)
 			{
 				if(processgeometry)
 				{
 					// Lines
 					foreach(Linedef ld in block.Lines)
 					{
 						// Line not already processed?
 						if(!visiblelines.ContainsKey(ld))
 						{
 							// Add line if not added yet
 							visiblelines.Add(ld, ld);
 
 							// Which side of the line is the camera on?
 							if(ld.SideOfLine(campos2d) < 0)
 							{
 								// Do front of line
 								if(ld.Front != null) ProcessSidedefCulling(ld.Front);
 							}
 							else
 							{
 								// Do back of line
 								if(ld.Back != null) ProcessSidedefCulling(ld.Back);
 							}
 						}
 					}
 				}
 
 				if(processthings)
 				{
 					// Things
 					foreach(Thing t in block.Things)
 					{
 						VisualThing vt;
 
 						// Not filtered out?
 						if(General.Map.ThingsFilter.IsThingVisible(t))
 						{
 							if(allthings.ContainsKey(t))
 							{
 								vt = allthings[t];
 							}
 							else
 							{
 								// Create new visual thing
 								vt = CreateVisualThing(t);
 								allthings.Add(t, vt);
 							}
 
 							if(vt != null)
 							{
 								visiblethings.Add(vt);
 							}
 						}
 					}
 				}
 			}
 
 			if(processgeometry)
 			{
 				// Find camera sector
 				Linedef nld = MapSet.NearestLinedef(visiblelines.Values, campos2d);
 				if(nld != null)
 				{
 					General.Map.VisualCamera.Sector = GetCameraSectorFromLinedef(nld);
 				}
 				else
 				{
 					// Exceptional case
 					// This could happen in the middle of an extremely large sector and in this case
 					// the above code will not have found any sectors/sidedefs for rendering.
 					// Here we handle this special case with brute-force. Let's find the sector
 					// the camera is in by searching the entire map and render that sector only.
 					nld = General.Map.Map.NearestLinedef(campos2d);
 					if(nld != null)
 					{
 						General.Map.VisualCamera.Sector = GetCameraSectorFromLinedef(nld);
 						if(General.Map.VisualCamera.Sector != null)
 						{
 							foreach(Sidedef sd in General.Map.VisualCamera.Sector.Sidedefs)
 							{
 								float side = sd.Line.SideOfLine(campos2d);
 								if(((side < 0) && sd.IsFront) ||
 								   ((side > 0) && !sd.IsFront))
 									ProcessSidedefCulling(sd);
 							}
 							foreach(Sidedef sd in General.Map.VisualCamera.Sector.Sidedefs)
 							{
 								float side = sd.Line.SideOfLine(campos2d);
 								if(((side < 0) && sd.IsFront) ||
 								   ((side > 0) && !sd.IsFront))
 									ProcessSidedefCulling(sd);
 							}
 						}
 						else
 						{
 							// Too far away from the map to see anything
 							General.Map.VisualCamera.Sector = null;
 						}
 					}
 					else
 					{
 						// Map is empty
 						General.Map.VisualCamera.Sector = null;
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="287" endline="303">
<![CDATA[
 
 		// Static method to browse for texture
 		// Returns null when cancelled.
 		public static string Browse(IWin32Window parent, string select)
 		{
 			TextureBrowserForm browser = new TextureBrowserForm(select);
 			if(browser.ShowDialog(parent) == DialogResult.OK)
 			{
 				// Return result
 				return browser.SelectedName;
 			}
 			else
 			{
 				// Cancelled
 				return select;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="286" endline="302">
<![CDATA[
 
 		// Static method to browse for flats
 		// Returns null when cancelled.
 		public static string Browse(IWin32Window parent, string select)
 		{
 			FlatBrowserForm browser = new FlatBrowserForm(select);
 			if(browser.ShowDialog(parent) == DialogResult.OK)
 			{
 				// Return result
 				return browser.SelectedName;
 			}
 			else
 			{
 				// Cancelled
 				return select;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\Playpal.cs" startline="67" endline="86">
<![CDATA[
 
 		// Constructor
 		public Playpal(Stream stream)
 		{
 			BinaryReader reader = new BinaryReader(stream);
 			
 			// Create array
 			colors = new PixelColor[256];
 
 			// Read all palette entries
 			stream.Seek(0, SeekOrigin.Begin);
 			for(int i = 0; i < 256; i++)
 			{
 				// Read colors
 				colors[i].r = reader.ReadByte();
 				colors[i].g = reader.ReadByte();
 				colors[i].b = reader.ReadByte();
 				colors[i].a = 255;
 			}
 			for(int i = 0; i < 256; i++)
 			{
 				// Read colors
 				colors[i].r = reader.ReadByte();
 				colors[i].g = reader.ReadByte();
 				colors[i].b = reader.ReadByte();
 				colors[i].a = 255;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.Designer.cs" startline="22" endline="155">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(TextureBrowserForm));
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.texturesets = new System.Windows.Forms.ListView();
 			this.namecolumn = new System.Windows.Forms.ColumnHeader();
 			this.countcolumn = new System.Windows.Forms.ColumnHeader();
 			this.smallimages = new System.Windows.Forms.ImageList(this.components);
 			this.browser = new CodeImp.DoomBuilder.Controls.ImageBrowserControl();
 			this.SuspendLayout();
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(781, 596);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(100, 25);
 			this.cancel.TabIndex = 3;
 			this.cancel.TabStop = false;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(675, 596);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(100, 25);
 			this.apply.TabIndex = 2;
 			this.apply.TabStop = false;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// texturesets
 			// 
 			this.texturesets.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)));
 			this.texturesets.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.namecolumn,
             this.countcolumn});
 			this.texturesets.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.texturesets.FullRowSelect = true;
 			this.texturesets.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
 			this.texturesets.HideSelection = false;
 			this.texturesets.Location = new System.Drawing.Point(12, 9);
 			this.texturesets.MultiSelect = false;
 			this.texturesets.Name = "texturesets";
 			this.texturesets.Size = new System.Drawing.Size(200, 576);
 			this.texturesets.SmallImageList = this.smallimages;
 			this.texturesets.TabIndex = 0;
 			this.texturesets.TabStop = false;
 			this.texturesets.UseCompatibleStateImageBehavior = false;
 			this.texturesets.View = System.Windows.Forms.View.Details;
 			this.texturesets.SelectedIndexChanged += new System.EventHandler(this.texturesets_SelectedIndexChanged);
 			// 
 			// namecolumn
 			// 
 			this.namecolumn.Text = "Name";
 			this.namecolumn.Width = 109;
 			// 
 			// countcolumn
 			// 
 			this.countcolumn.Text = "Count";
 			this.countcolumn.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
 			this.countcolumn.Width = 51;
 			// 
 			// smallimages
 			// 
 			this.smallimages.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("smallimages.ImageStream")));
 			this.smallimages.TransparentColor = System.Drawing.Color.Transparent;
 			this.smallimages.Images.SetKeyName(0, "KnownTextureSet2.ico");
 			this.smallimages.Images.SetKeyName(1, "AllTextureSet2.ico");
 			this.smallimages.Images.SetKeyName(2, "FileTextureSet.ico");
 			this.smallimages.Images.SetKeyName(3, "FolderTextureSet.ico");
 			this.smallimages.Images.SetKeyName(4, "PK3TextureSet.ico");
 			// 
 			// browser
 			// 
 			this.browser.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.browser.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.browser.HideInputBox = false;
 			this.browser.LabelText = "Select or enter a texture name
 			this.browser.Location = new System.Drawing.Point(218, 9);
 			this.browser.Name = "browser";
 			this.browser.PreventSelection = false;
 			this.browser.Size = new System.Drawing.Size(663, 610);
 			this.browser.TabIndex = 1;
 			this.browser.TabStop = false;
 			this.browser.SelectedItemDoubleClicked += new CodeImp.DoomBuilder.Controls.ImageBrowserControl.SelectedItemDoubleClickDelegate(this.browser_SelectedItemDoubleClicked);
 			this.browser.SelectedItemChanged += new CodeImp.DoomBuilder.Controls.ImageBrowserControl.SelectedItemChangedDelegate(this.browser_SelectedItemChanged);
 			// 
 			// TextureBrowserForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(893, 631);
 			this.Controls.Add(this.texturesets);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.browser);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.KeyPreview = true;
 			this.MinimizeBox = false;
 			this.Name = "TextureBrowserForm";
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
 			this.Text = "Browse Textures";
 			this.Load += new System.EventHandler(this.TextureBrowserForm_Load);
 			this.Shown += new System.EventHandler(this.TextureBrowserForm_Shown);
 			this.Activated += new System.EventHandler(this.TextureBrowserForm_Activated);
 			this.Move += new System.EventHandler(this.TextureBrowserForm_Move);
 			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.TextureBrowserForm_FormClosing);
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.TextureBrowserForm_HelpRequested);
 			this.ResizeEnd += new System.EventHandler(this.TextureBrowserForm_ResizeEnd);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.Designer.cs" startline="22" endline="154">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FlatBrowserForm));
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.texturesets = new System.Windows.Forms.ListView();
 			this.namecolumn = new System.Windows.Forms.ColumnHeader();
 			this.countcolumn = new System.Windows.Forms.ColumnHeader();
 			this.smallimages = new System.Windows.Forms.ImageList(this.components);
 			this.browser = new CodeImp.DoomBuilder.Controls.ImageBrowserControl();
 			this.SuspendLayout();
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(781, 596);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(100, 25);
 			this.cancel.TabIndex = 3;
 			this.cancel.TabStop = false;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(675, 596);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(100, 25);
 			this.apply.TabIndex = 2;
 			this.apply.TabStop = false;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// texturesets
 			// 
 			this.texturesets.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)));
 			this.texturesets.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.namecolumn,
             this.countcolumn});
 			this.texturesets.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.texturesets.FullRowSelect = true;
 			this.texturesets.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
 			this.texturesets.HideSelection = false;
 			this.texturesets.Location = new System.Drawing.Point(12, 9);
 			this.texturesets.MultiSelect = false;
 			this.texturesets.Name = "texturesets";
 			this.texturesets.Size = new System.Drawing.Size(200, 576);
 			this.texturesets.SmallImageList = this.smallimages;
 			this.texturesets.TabIndex = 0;
 			this.texturesets.TabStop = false;
 			this.texturesets.UseCompatibleStateImageBehavior = false;
 			this.texturesets.View = System.Windows.Forms.View.Details;
 			this.texturesets.SelectedIndexChanged += new System.EventHandler(this.texturesets_SelectedIndexChanged);
 			// 
 			// namecolumn
 			// 
 			this.namecolumn.Text = "Name";
 			this.namecolumn.Width = 152;
 			// 
 			// countcolumn
 			// 
 			this.countcolumn.Text = "Count";
 			this.countcolumn.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
 			this.countcolumn.Width = 42;
 			// 
 			// smallimages
 			// 
 			this.smallimages.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("smallimages.ImageStream")));
 			this.smallimages.TransparentColor = System.Drawing.Color.Transparent;
 			this.smallimages.Images.SetKeyName(0, "KnownTextureSet2.ico");
 			this.smallimages.Images.SetKeyName(1, "AllTextureSet2.ico");
 			this.smallimages.Images.SetKeyName(2, "FileTextureSet.ico");
 			this.smallimages.Images.SetKeyName(3, "FolderTextureSet.ico");
 			this.smallimages.Images.SetKeyName(4, "PK3TextureSet.ico");
 			// 
 			// browser
 			// 
 			this.browser.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.browser.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.browser.HideInputBox = false;
 			this.browser.LabelText = "Select or enter a flat name
 			this.browser.Location = new System.Drawing.Point(218, 9);
 			this.browser.Name = "browser";
 			this.browser.PreventSelection = false;
 			this.browser.Size = new System.Drawing.Size(663, 610);
 			this.browser.TabIndex = 1;
 			this.browser.TabStop = false;
 			this.browser.SelectedItemDoubleClicked += new CodeImp.DoomBuilder.Controls.ImageBrowserControl.SelectedItemDoubleClickDelegate(this.browser_SelectedItemDoubleClicked);
 			this.browser.SelectedItemChanged += new CodeImp.DoomBuilder.Controls.ImageBrowserControl.SelectedItemChangedDelegate(this.browser_SelectedItemChanged);
 			// 
 			// FlatBrowserForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(893, 631);
 			this.Controls.Add(this.texturesets);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.browser);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.MinimizeBox = false;
 			this.Name = "FlatBrowserForm";
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
 			this.Text = "Browse Flats";
 			this.Load += new System.EventHandler(this.FlatBrowserForm_Load);
 			this.Shown += new System.EventHandler(this.FlatBrowserForm_Shown);
 			this.Activated += new System.EventHandler(this.FlatBrowserForm_Activated);
 			this.Move += new System.EventHandler(this.FlatBrowserForm_Move);
 			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.FlatBrowserForm_FormClosing);
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.FlatBrowserForm_HelpRequested);
 			this.ResizeEnd += new System.EventHandler(this.FlatBrowserForm_ResizeEnd);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\AboutForm.Designer.cs" startline="22" endline="170">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.Label label1;
 			System.Windows.Forms.PictureBox pictureBox1;
 			this.close = new System.Windows.Forms.Button();
 			this.builderlink = new System.Windows.Forms.LinkLabel();
 			this.version = new System.Windows.Forms.Label();
 			this.copyversion = new System.Windows.Forms.Button();
 			this.pictureBox2 = new System.Windows.Forms.PictureBox();
 			this.codeimplink = new System.Windows.Forms.LinkLabel();
 			label1 = new System.Windows.Forms.Label();
 			pictureBox1 = new System.Windows.Forms.PictureBox();
 			((System.ComponentModel.ISupportInitialize)(pictureBox1)).BeginInit();
 			((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).BeginInit();
 			this.SuspendLayout();
 			// 
 			// label1
 			// 
 			label1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			label1.FlatStyle = System.Windows.Forms.FlatStyle.System;
 			label1.Location = new System.Drawing.Point(15, 161);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(349, 50);
 			label1.TabIndex = 2;
 			label1.Text = "Doom Builder is designed and programmed by Pascal vd Heiden.\r\nSeveral game config" +
 				"urations were written by various members of the Doom community. See the website " +
 				"for a complete list of credits.";
 			// 
 			// pictureBox1
 			// 
 			pictureBox1.Image = global
 			pictureBox1.Location = new System.Drawing.Point(10, 12);
 			pictureBox1.Name = "pictureBox1";
 			pictureBox1.Size = new System.Drawing.Size(226, 80);
 			pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
 			pictureBox1.TabIndex = 0;
 			pictureBox1.TabStop = false;
 			// 
 			// close
 			// 
 			this.close.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.close.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.close.Location = new System.Drawing.Point(265, 243);
 			this.close.Name = "close";
 			this.close.Size = new System.Drawing.Size(116, 25);
 			this.close.TabIndex = 5;
 			this.close.Text = "Close";
 			this.close.UseVisualStyleBackColor = true;
 			// 
 			// builderlink
 			// 
 			this.builderlink.ActiveLinkColor = System.Drawing.Color.Firebrick;
 			this.builderlink.AutoSize = true;
 			this.builderlink.LinkBehavior = System.Windows.Forms.LinkBehavior.NeverUnderline;
 			this.builderlink.LinkColor = System.Drawing.Color.Firebrick;
 			this.builderlink.Location = new System.Drawing.Point(12, 219);
 			this.builderlink.Name = "builderlink";
 			this.builderlink.Size = new System.Drawing.Size(121, 14);
 			this.builderlink.TabIndex = 3;
 			this.builderlink.TabStop = true;
 			this.builderlink.Text = "www.doombuilder.com";
 			this.builderlink.VisitedLinkColor = System.Drawing.Color.Firebrick;
 			this.builderlink.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.builderlink_LinkClicked);
 			// 
 			// version
 			// 
 			this.version.AutoSize = true;
 			this.version.FlatStyle = System.Windows.Forms.FlatStyle.System;
 			this.version.Location = new System.Drawing.Point(15, 118);
 			this.version.Name = "version";
 			this.version.Size = new System.Drawing.Size(138, 14);
 			this.version.TabIndex = 0;
 			this.version.Text = "Doom Builder some version";
 			// 
 			// copyversion
 			// 
 			this.copyversion.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
 			this.copyversion.Location = new System.Drawing.Point(265, 113);
 			this.copyversion.Name = "copyversion";
 			this.copyversion.Size = new System.Drawing.Size(116, 25);
 			this.copyversion.TabIndex = 1;
 			this.copyversion.Text = "Copy Version";
 			this.copyversion.UseVisualStyleBackColor = true;
 			this.copyversion.Click += new System.EventHandler(this.copyversion_Click);
 			// 
 			// pictureBox2
 			// 
 			this.pictureBox2.Image = global
 			this.pictureBox2.Location = new System.Drawing.Point(293, 12);
 			this.pictureBox2.Name = "pictureBox2";
 			this.pictureBox2.Size = new System.Drawing.Size(88, 80);
 			this.pictureBox2.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
 			this.pictureBox2.TabIndex = 10;
 			this.pictureBox2.TabStop = false;
 			// 
 			// codeimplink
 			// 
 			this.codeimplink.ActiveLinkColor = System.Drawing.Color.Firebrick;
 			this.codeimplink.AutoSize = true;
 			this.codeimplink.LinkBehavior = System.Windows.Forms.LinkBehavior.NeverUnderline;
 			this.codeimplink.LinkColor = System.Drawing.Color.Firebrick;
 			this.codeimplink.Location = new System.Drawing.Point(12, 239);
 			this.codeimplink.Name = "codeimplink";
 			this.codeimplink.Size = new System.Drawing.Size(103, 14);
 			this.codeimplink.TabIndex = 4;
 			this.codeimplink.TabStop = true;
 			this.codeimplink.Text = "www.codeimp.com";
 			this.codeimplink.VisitedLinkColor = System.Drawing.Color.Firebrick;
 			this.codeimplink.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.codeimplink_LinkClicked);
 			// 
 			// AboutForm
 			// 
 			this.AcceptButton = this.close;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.close;
 			this.ClientSize = new System.Drawing.Size(393, 280);
 			this.Controls.Add(this.codeimplink);
 			this.Controls.Add(this.pictureBox2);
 			this.Controls.Add(this.copyversion);
 			this.Controls.Add(this.version);
 			this.Controls.Add(this.builderlink);
 			this.Controls.Add(this.close);
 			this.Controls.Add(label1);
 			this.Controls.Add(pictureBox1);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "AboutForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "About Doom Builder";
 			((System.ComponentModel.ISupportInitialize)(pictureBox1)).EndInit();
 			((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).EndInit();
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ActionBrowserForm.cs" startline="8" endline="154">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public ActionBrowserForm(int action)
 		{
 			TreeNode cn, n;
 			GeneralizedCategory sc;
 			int actionbits;
 			
 			// Initialize
 			InitializeComponent();
 
 			// Make array references for controls
 			options = new ComboBox[] { option0, option1, option2, option3, option4, option5, option6, option7 };
 			optionlbls = new Label[] { option0label, option1label, option2label, option3label, option4label,
 									   option5label, option6label, option7label };
 			
 			// Show prefixes panel only for doom type maps
 			if(General.Map.FormatInterface.HasBuiltInActivations)
 			{
 				prefixespanel.Visible = false;
 				actions.Height += actions.Top - prefixespanel.Top;
 				actions.Top = prefixespanel.Top;
 			}
 			
 			// Go for all predefined categories
 			foreach(LinedefActionCategory ac in General.Map.Config.ActionCategories)
 			{
 				// Empty category names will not be created
 				// (those actions will go in the root of the tree)
 				if(ac.Title.Length > 0)
 				{
 					// Create category
 					cn = actions.Nodes.Add(ac.Title);
 					foreach(LinedefActionInfo ai in ac.Actions)
 					{
 						// Create action
 						n = cn.Nodes.Add(ai.Title);
 						n.Tag = ai;
 
 						// This is the given action?
 						if(ai.Index == action)
 						{
 							// Select this and expand the category
 							cn.Expand();
 							actions.SelectedNode = n;
 							n.EnsureVisible();
 						}
 					}
 					foreach(LinedefActionInfo ai in ac.Actions)
 					{
 						// Create action
 						n = cn.Nodes.Add(ai.Title);
 						n.Tag = ai;
 
 						// This is the given action?
 						if(ai.Index == action)
 						{
 							// Select this and expand the category
 							cn.Expand();
 							actions.SelectedNode = n;
 							n.EnsureVisible();
 						}
 					}
 				}
 				else
 				{
 					// Put actions in the tree root
 					foreach(LinedefActionInfo ai in ac.Actions)
 					{
 						// Create action
 						n = actions.Nodes.Add(ai.Title);
 						n.Tag = ai;
 					}
 					foreach(LinedefActionInfo ai in ac.Actions)
 					{
 						// Create action
 						n = actions.Nodes.Add(ai.Title);
 						n.Tag = ai;
 					}
 				}
 			}
 			foreach(LinedefActionCategory ac in General.Map.Config.ActionCategories)
 			{
 				// Empty category names will not be created
 				// (those actions will go in the root of the tree)
 				if(ac.Title.Length > 0)
 				{
 					// Create category
 					cn = actions.Nodes.Add(ac.Title);
 					foreach(LinedefActionInfo ai in ac.Actions)
 					{
 						// Create action
 						n = cn.Nodes.Add(ai.Title);
 						n.Tag = ai;
 
 						// This is the given action?
 						if(ai.Index == action)
 						{
 							// Select this and expand the category
 							cn.Expand();
 							actions.SelectedNode = n;
 							n.EnsureVisible();
 						}
 					}
 				}
 				else
 				{
 					// Put actions in the tree root
 					foreach(LinedefActionInfo ai in ac.Actions)
 					{
 						// Create action
 						n = actions.Nodes.Add(ai.Title);
 						n.Tag = ai;
 					}
 				}
 			}
 
 			// Using generalized actions?
 			if(General.Map.Config.GeneralizedActions)
 			{
 				// Add for all generalized categories to the combobox
 				category.Items.AddRange(General.Map.Config.GenActionCategories.ToArray());
 
 				// Given action is generalized?
 				if(GameConfiguration.IsGeneralized(action, General.Map.Config.GenActionCategories))
 				{
 					// Open the generalized tab
 					tabs.SelectedTab = tabgeneralized;
 
 					// Select category
 					foreach(GeneralizedCategory ac in category.Items)
 						if((action >= ac.Offset) && (action < (ac.Offset + ac.Length))) category.SelectedItem = ac;
 					foreach(GeneralizedCategory ac in category.Items)
 						if((action >= ac.Offset) && (action < (ac.Offset + ac.Length))) category.SelectedItem = ac;
 
 					// Anything selected?
 					if(category.SelectedIndex > -1)
 					{
 						// Go for all options in selected category
 						sc = category.SelectedItem as GeneralizedCategory;
 						actionbits = action - sc.Offset;
 						for(int i = 0; i < MAX_OPTIONS; i++)
 						{
 							// Option used?
 							if(i < sc.Options.Count)
 							{
 								// Go for all bits
 								foreach(GeneralizedBit ab in sc.Options[i].Bits)
 								{
 									// Select this setting if matches
 									if((actionbits & ab.Index) == ab.Index) options[i].SelectedItem = ab;
 								}
 								foreach(GeneralizedBit ab in sc.Options[i].Bits)
 								{
 									// Select this setting if matches
 									if((actionbits & ab.Index) == ab.Index) options[i].SelectedItem = ab;
 								}
 							}
 						}
 						for(int i = 0; i < MAX_OPTIONS; i++)
 						{
 							// Option used?
 							if(i < sc.Options.Count)
 							{
 								// Go for all bits
 								foreach(GeneralizedBit ab in sc.Options[i].Bits)
 								{
 									// Select this setting if matches
 									if((actionbits & ab.Index) == ab.Index) options[i].SelectedItem = ab;
 								}
 							}
 						}
 					}
 				}
 			}
 			else
 			{
 				// Remove generalized tab
 				tabs.TabPages.Remove(tabgeneralized);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="98" endline="105">
<![CDATA[
 		
 		// This returns a list of all files (filepathname)
 		public List<string> GetAllFiles()
 		{
 			List<string> files = new List<string>(entries.Length);
 			for(int i = 0; i < entries.Length; i++) files.Add(entries[i].filepathname);
 			return files;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\BinaryHeap.cs" startline="227" endline="244">
<![CDATA[
 		
 		// Implemented to display the list
 		// This is an O(n) operation, where n is Count
 		public override string ToString()
 		{
 			StringBuilder str = new StringBuilder(heap.Count * 5);
 
 			// Go for all items
 			for(int i = 0; i < heap.Count; i++)
 			{
 				// Append item to string
 				if(i > 0) str.Append(", ");
 				str.Append(heap[i]);
 			}
 			for(int i = 0; i < heap.Count; i++)
 			{
 				// Append item to string
 				if(i > 0) str.Append(", ");
 				str.Append(heap[i]);
 			}
 
 			// Return the string
 			return str.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Compilers\AccCompiler.cs" startline="67" endline="176">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		// This runs the compiler
 		public override bool Run()
 		{
 			ProcessStartInfo processinfo;
 			Process process;
 			TimeSpan deltatime;
 			int line = 0;
 			string sourcedir = Path.GetDirectoryName(sourcefile);
 			
 			// Create parameters
 			string args = this.parameters;
 			args = args.Replace("%FI", inputfile);
 			args = args.Replace("%FO", outputfile);
 			args = args.Replace("%FS", sourcefile);
 			args = args.Replace("%PT", this.tempdir.FullName);
 			args = args.Replace("%PS", sourcedir);
 			
 			// Setup process info
 			processinfo = new ProcessStartInfo();
 			processinfo.Arguments = args;
 			processinfo.FileName = Path.Combine(this.tempdir.FullName, info.ProgramFile);
 			processinfo.CreateNoWindow = false;
 			processinfo.ErrorDialog = false;
 			processinfo.UseShellExecute = true;
 			processinfo.WindowStyle = ProcessWindowStyle.Hidden;
 			processinfo.WorkingDirectory = this.workingdir;
 			
 			// Output info
 			General.WriteLogLine("Running compiler...");
 			General.WriteLogLine("Program
 			General.WriteLogLine("Arguments
 			
 			try
 			{
 				// Start the compiler
 				process = Process.Start(processinfo);
 			}
 			catch(Exception e)
 			{
 				// Unable to start the compiler
 				General.ShowErrorMessage("Unable to start the compiler (" + info.Name + "). " + e.GetType().Name + "
 				return false;
 			}
 			
 			// Wait for compiler to complete
 			process.WaitForExit();
 			deltatime = TimeSpan.FromTicks(process.ExitTime.Ticks - process.StartTime.Ticks);
 			General.WriteLogLine("Compiler process has finished.");
 			General.WriteLogLine("Compile time
 			
 			// Now find the error file
 			string errfile = Path.Combine(this.workingdir, ACS_ERROR_FILE);
 			if(File.Exists(errfile))
 			{
 				try
 				{
 					// Regex to find error lines
 					Regex errlinematcher = new Regex("
 					
 					// Read all lines
 					string[] errlines = File.ReadAllLines(errfile);
 					while(line < errlines.Length)
 					{
 						// Check line
 						string linestr = errlines[line];
 						Match match = errlinematcher.Match(linestr);
 						if(match.Success && (match.Index > 0))
 						{
 							CompilerError err = new CompilerError();
 							
 							// The match without spaces and semicolon is the line number
 							string linenr = match.Value.Replace("
 							if(!int.TryParse(linenr, out err.linenumber))
 								err.linenumber = CompilerError.NO_LINE_NUMBER;
 							else
 								err.linenumber--;
 							
 							// Everything before the match is the filename
 							err.filename = linestr.Substring(0, match.Index);
 							if(!Path.IsPathRooted(err.filename))
 							{
 								// Add working directory to filename
 								err.filename = Path.Combine(processinfo.WorkingDirectory, err.filename);
 							}
 							
 							// Everything after the match is the description
 							err.description = linestr.Substring(match.Index + match.Length).Trim();
 							
 							// Report the error
 							ReportError(err);
 						}
 						
 						// Next line
 						line++;
 					}
 					while(line < errlines.Length)
 					{
 						// Check line
 						string linestr = errlines[line];
 						Match match = errlinematcher.Match(linestr);
 						if(match.Success && (match.Index > 0))
 						{
 							CompilerError err = new CompilerError();
 							
 							// The match without spaces and semicolon is the line number
 							string linenr = match.Value.Replace("
 							if(!int.TryParse(linenr, out err.linenumber))
 								err.linenumber = CompilerError.NO_LINE_NUMBER;
 							else
 								err.linenumber--;
 							
 							// Everything before the match is the filename
 							err.filename = linestr.Substring(0, match.Index);
 							if(!Path.IsPathRooted(err.filename))
 							{
 								// Add working directory to filename
 								err.filename = Path.Combine(processinfo.WorkingDirectory, err.filename);
 							}
 							
 							// Everything after the match is the description
 							err.description = linestr.Substring(match.Index + match.Length).Trim();
 							
 							// Report the error
 							ReportError(err);
 						}
 						
 						// Next line
 						line++;
 					}
 				}
 				catch(Exception e)
 				{
 					// Error reading errors (ironic, isn't it)
 					ReportError(new CompilerError("Failed to retrieve compiler error report. " + e.GetType().Name + "
 				}
 			}
 			
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="226" endline="329">
<![CDATA[
 		
 		// This requests loading the image
 		protected virtual void LocalLoadImage()
 		{
 			BitmapData bmpdata = null;
 			
 			lock(this)
 			{
 				// Bitmap loaded successfully?
 				if(bitmap != null)
 				{
 					// Bitmap has incorrect format?
 					if(bitmap.PixelFormat != PixelFormat.Format32bppArgb)
 					{
 						if(dynamictexture)
 							throw new Exception("Dynamic images must be in 32 bits ARGB format.");
 						
 						//General.ErrorLogger.Add(ErrorType.Warning, "Image '" + name + "' does not have A8R8G8B8 pixel format. Conversion was needed.");
 						Bitmap oldbitmap = bitmap;
 						try
 						{
 							// Convert to desired pixel format
 							bitmap = new Bitmap(oldbitmap.Size.Width, oldbitmap.Size.Height, PixelFormat.Format32bppArgb);
 							Graphics g = Graphics.FromImage(bitmap);
 							g.PageUnit = GraphicsUnit.Pixel;
 							g.CompositingQuality = CompositingQuality.HighQuality;
 							g.InterpolationMode = InterpolationMode.NearestNeighbor;
 							g.SmoothingMode = SmoothingMode.None;
 							g.PixelOffsetMode = PixelOffsetMode.None;
 							g.Clear(Color.Transparent);
 							g.DrawImage(oldbitmap, 0, 0, oldbitmap.Size.Width, oldbitmap.Size.Height);
 							g.Dispose();
 							oldbitmap.Dispose();
 						}
 						catch(Exception e)
 						{
 							bitmap = oldbitmap;
 							General.ErrorLogger.Add(ErrorType.Warning, "Cannot lock image '" + name + "' for pixel format conversion. The image may not be displayed correctly.\n" + e.GetType().Name + "
 						}
 					}
 					
 					// This applies brightness correction on the image
 					if(usecolorcorrection)
 					{
 						try
 						{
 							// Try locking the bitmap
 							bmpdata = bitmap.LockBits(new Rectangle(0, 0, bitmap.Size.Width, bitmap.Size.Height), ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb);
 						}
 						catch(Exception e)
 						{
 							General.ErrorLogger.Add(ErrorType.Warning, "Cannot lock image '" + name + "' for color correction. The image may not be displayed correctly.\n" + e.GetType().Name + "
 						}
 
 						// Bitmap locked?
 						if(bmpdata != null)
 						{
 							// Apply color correction
 							PixelColor* pixels = (PixelColor*)(bmpdata.Scan0.ToPointer());
 							General.Colors.ApplColorCorrection(pixels, bmpdata.Width * bmpdata.Height);
 							bitmap.UnlockBits(bmpdata);
 						}
 					}
 				}
 				else
 				{
 					// Loading failed
 					// We still mark the image as ready so that it will
 					// not try loading again until Reload Resources is used
 					loadfailed = true;
 					bitmap = new Bitmap(Properties.Resources.Failed);
 				}
 
 				if(bitmap != null)
 				{
 					width = bitmap.Size.Width;
 					height = bitmap.Size.Height;
 
 					if(dynamictexture)
 					{
 						if((width != General.NextPowerOf2(width)) || (height != General.NextPowerOf2(height)))
 							throw new Exception("Dynamic images must have a size in powers of 2.");
 					}
 
 					// Do we still have to set a scale?
 					if((scale.x == 0.0f) && (scale.y == 0.0f))
 					{
 						if((General.Map != null) && (General.Map.Config != null))
 						{
 							scale.x = General.Map.Config.DefaultTextureScale;
 							scale.y = General.Map.Config.DefaultTextureScale;
 						}
 						else
 						{
 							scale.x = 1.0f;
 							scale.y = 1.0f;
 						}
 					}
 				}
 				
 				// Image is ready
 				imagestate = ImageLoadState.Ready;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptFindReplaceForm.Designer.cs" startline="22" endline="161">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.label1 = new System.Windows.Forms.Label();
 			this.findtext = new System.Windows.Forms.TextBox();
 			this.casesensitive = new System.Windows.Forms.CheckBox();
 			this.wordonly = new System.Windows.Forms.CheckBox();
 			this.replacetext = new System.Windows.Forms.TextBox();
 			this.label2 = new System.Windows.Forms.Label();
 			this.findnextbutton = new System.Windows.Forms.Button();
 			this.replaceallbutton = new System.Windows.Forms.Button();
 			this.closebutton = new System.Windows.Forms.Button();
 			this.replacebutton = new System.Windows.Forms.Button();
 			this.SuspendLayout();
 			// 
 			// label1
 			// 
 			this.label1.AutoSize = true;
 			this.label1.Location = new System.Drawing.Point(29, 23);
 			this.label1.Name = "label1";
 			this.label1.Size = new System.Drawing.Size(58, 14);
 			this.label1.TabIndex = 0;
 			this.label1.Text = "Find what
 			// 
 			// findtext
 			// 
 			this.findtext.Location = new System.Drawing.Point(93, 20);
 			this.findtext.Name = "findtext";
 			this.findtext.Size = new System.Drawing.Size(152, 20);
 			this.findtext.TabIndex = 0;
 			// 
 			// casesensitive
 			// 
 			this.casesensitive.AutoSize = true;
 			this.casesensitive.Location = new System.Drawing.Point(93, 84);
 			this.casesensitive.Name = "casesensitive";
 			this.casesensitive.Size = new System.Drawing.Size(97, 18);
 			this.casesensitive.TabIndex = 2;
 			this.casesensitive.Text = "Case sensitive";
 			this.casesensitive.UseVisualStyleBackColor = true;
 			// 
 			// wordonly
 			// 
 			this.wordonly.AutoSize = true;
 			this.wordonly.Location = new System.Drawing.Point(93, 108);
 			this.wordonly.Name = "wordonly";
 			this.wordonly.Size = new System.Drawing.Size(108, 18);
 			this.wordonly.TabIndex = 3;
 			this.wordonly.Text = "Whole word only";
 			this.wordonly.UseVisualStyleBackColor = true;
 			// 
 			// replacetext
 			// 
 			this.replacetext.Location = new System.Drawing.Point(93, 51);
 			this.replacetext.Name = "replacetext";
 			this.replacetext.Size = new System.Drawing.Size(152, 20);
 			this.replacetext.TabIndex = 1;
 			// 
 			// label2
 			// 
 			this.label2.AutoSize = true;
 			this.label2.Location = new System.Drawing.Point(14, 54);
 			this.label2.Name = "label2";
 			this.label2.Size = new System.Drawing.Size(73, 14);
 			this.label2.TabIndex = 6;
 			this.label2.Text = "Replace with
 			// 
 			// findnextbutton
 			// 
 			this.findnextbutton.Location = new System.Drawing.Point(277, 18);
 			this.findnextbutton.Name = "findnextbutton";
 			this.findnextbutton.Size = new System.Drawing.Size(98, 25);
 			this.findnextbutton.TabIndex = 4;
 			this.findnextbutton.Text = "Find Next";
 			this.findnextbutton.UseVisualStyleBackColor = true;
 			this.findnextbutton.Click += new System.EventHandler(this.findnextbutton_Click);
 			// 
 			// replaceallbutton
 			// 
 			this.replaceallbutton.Location = new System.Drawing.Point(277, 80);
 			this.replaceallbutton.Name = "replaceallbutton";
 			this.replaceallbutton.Size = new System.Drawing.Size(98, 25);
 			this.replaceallbutton.TabIndex = 6;
 			this.replaceallbutton.Text = "Replace All";
 			this.replaceallbutton.UseVisualStyleBackColor = true;
 			this.replaceallbutton.Click += new System.EventHandler(this.replaceallbutton_Click);
 			// 
 			// closebutton
 			// 
 			this.closebutton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.closebutton.Location = new System.Drawing.Point(277, 127);
 			this.closebutton.Name = "closebutton";
 			this.closebutton.Size = new System.Drawing.Size(98, 25);
 			this.closebutton.TabIndex = 7;
 			this.closebutton.Text = "Close";
 			this.closebutton.UseVisualStyleBackColor = true;
 			this.closebutton.Click += new System.EventHandler(this.closebutton_Click);
 			// 
 			// replacebutton
 			// 
 			this.replacebutton.Location = new System.Drawing.Point(277, 49);
 			this.replacebutton.Name = "replacebutton";
 			this.replacebutton.Size = new System.Drawing.Size(98, 25);
 			this.replacebutton.TabIndex = 5;
 			this.replacebutton.Text = "Replace";
 			this.replacebutton.UseVisualStyleBackColor = true;
 			this.replacebutton.Click += new System.EventHandler(this.replacebutton_Click);
 			// 
 			// ScriptFindReplaceForm
 			// 
 			this.AcceptButton = this.findnextbutton;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.closebutton;
 			this.ClientSize = new System.Drawing.Size(387, 163);
 			this.Controls.Add(this.replacebutton);
 			this.Controls.Add(this.closebutton);
 			this.Controls.Add(this.replaceallbutton);
 			this.Controls.Add(this.findnextbutton);
 			this.Controls.Add(this.label2);
 			this.Controls.Add(this.replacetext);
 			this.Controls.Add(this.wordonly);
 			this.Controls.Add(this.casesensitive);
 			this.Controls.Add(this.findtext);
 			this.Controls.Add(this.label1);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
 			this.Name = "ScriptFindReplaceForm";
 			this.Text = "Find and Replace";
 			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.ScriptFindReplaceForm_FormClosing);
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="612" endline="631">
<![CDATA[
 		
 		// This applies single/double sided flags
 		public void ApplySidedFlags()
 		{
 			// Doublesided?
 			if((front != null) && (back != null))
 			{
 				// Apply or remove flags for doublesided line
 				SetFlag(General.Map.Config.SingleSidedFlag, false);
 				SetFlag(General.Map.Config.DoubleSidedFlag, true);
 			}
 			else
 			{
 				// Apply or remove flags for singlesided line
 				SetFlag(General.Map.Config.SingleSidedFlag, true);
 				SetFlag(General.Map.Config.DoubleSidedFlag, false);
 			}
 			
 			General.Map.IsChanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\SectorInfoPanel.cs" startline="42" endline="74">
<![CDATA[
 
 		// This shows the info
 		public void ShowInfo(Sector s)
 		{
 			string effectinfo = "";
 			
 			int sheight = s.CeilHeight - s.FloorHeight;
 
 			// Lookup effect description in config
 			if(General.Map.Config.SectorEffects.ContainsKey(s.Effect))
 				effectinfo = General.Map.Config.SectorEffects[s.Effect].ToString();
 			else if(s.Effect == 0)
 				effectinfo = s.Effect.ToString() + " - Normal";
 			else
 				effectinfo = s.Effect.ToString() + " - Unknown";
 
 			// Sector info
 			sectorinfo.Text = " Sector " + s.Index + " ";
 			effect.Text = effectinfo;
 			ceiling.Text = s.CeilHeight.ToString();
 			floor.Text = s.FloorHeight.ToString();
 			tag.Text = s.Tag.ToString();
 			height.Text = sheight.ToString();
 			brightness.Text = s.Brightness.ToString();
 			floorname.Text = s.FloorTexture;
 			ceilingname.Text = s.CeilTexture;
 			General.DisplayZoomedImage(floortex, General.Map.Data.GetFlatImage(s.FloorTexture).GetPreview());
 			General.DisplayZoomedImage(ceilingtex, General.Map.Data.GetFlatImage(s.CeilTexture).GetPreview());
 
 			// Show the whole thing
 			this.Show();
 			this.Update();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="521" endline="580">
<![CDATA[
 
 		// This renders all thing cages
 		private void RenderThingCages()
 		{
 			int currentshaderpass = shaderpass;
 			int highshaderpass = shaderpass + 2;
 
 			// Set renderstates
 			graphics.Device.SetRenderState(RenderState.AlphaBlendEnable, true);
 			graphics.Device.SetRenderState(RenderState.AlphaTestEnable, false);
 			graphics.Device.SetRenderState(RenderState.ZWriteEnable, false);
 			graphics.Device.SetRenderState(RenderState.SourceBlend, Blend.SourceAlpha);
 			graphics.Device.SetRenderState(RenderState.DestinationBlend, Blend.InverseSourceAlpha);
 			graphics.Device.SetStreamSource(0, thingcage, 0, WorldVertex.Stride);
 			graphics.Device.SetTexture(0, General.Map.Data.ThingBox.Texture);
 			graphics.Shaders.World3D.Texture1 = General.Map.Data.ThingBox.Texture;
 
 			graphics.Shaders.World3D.BeginPass(shaderpass);
 			foreach(VisualThing t in thingsbydistance)
 			{
 				// Determine the shader pass we want to use for this object
 				int wantedshaderpass = (((t == highlighted) && showhighlight) || (t.Selected && showselection)) ? highshaderpass 
 
 				// Switch shader pass?
 				if(currentshaderpass != wantedshaderpass)
 				{
 					graphics.Shaders.World3D.EndPass();
 					graphics.Shaders.World3D.BeginPass(wantedshaderpass);
 					currentshaderpass = wantedshaderpass;
 				}
 
 				// Setup matrix
 				world = Matrix.Multiply(t.CageScales, t.Position);
 				ApplyMatrices3D();
 
 				// Setup color
 				if(currentshaderpass == highshaderpass)
 				{
 					Color4 highcolor = CalculateHighlightColor((t == highlighted) && showhighlight, t.Selected && showselection);
 					graphics.Shaders.World3D.SetHighlightColor(highcolor.ToArgb());
 					highcolor.Alpha = 1.0f;
 					graphics.Shaders.World3D.SetModulateColor(highcolor.ToArgb());
 					graphics.Device.SetRenderState(RenderState.TextureFactor, highcolor.ToArgb());
 				}
 				else
 				{
 					graphics.Shaders.World3D.SetModulateColor(t.CageColor);
 					graphics.Device.SetRenderState(RenderState.TextureFactor, t.CageColor);
 				}
 
 				// Render!
 				graphics.Shaders.World3D.ApplySettings();
 				graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, 0, 12);
 			}
 			foreach(VisualThing t in thingsbydistance)
 			{
 				// Determine the shader pass we want to use for this object
 				int wantedshaderpass = (((t == highlighted) && showhighlight) || (t.Selected && showselection)) ? highshaderpass 
 
 				// Switch shader pass?
 				if(currentshaderpass != wantedshaderpass)
 				{
 					graphics.Shaders.World3D.EndPass();
 					graphics.Shaders.World3D.BeginPass(wantedshaderpass);
 					currentshaderpass = wantedshaderpass;
 				}
 
 				// Setup matrix
 				world = Matrix.Multiply(t.CageScales, t.Position);
 				ApplyMatrices3D();
 
 				// Setup color
 				if(currentshaderpass == highshaderpass)
 				{
 					Color4 highcolor = CalculateHighlightColor((t == highlighted) && showhighlight, t.Selected && showselection);
 					graphics.Shaders.World3D.SetHighlightColor(highcolor.ToArgb());
 					highcolor.Alpha = 1.0f;
 					graphics.Shaders.World3D.SetModulateColor(highcolor.ToArgb());
 					graphics.Device.SetRenderState(RenderState.TextureFactor, highcolor.ToArgb());
 				}
 				else
 				{
 					graphics.Shaders.World3D.SetModulateColor(t.CageColor);
 					graphics.Device.SetRenderState(RenderState.TextureFactor, t.CageColor);
 				}
 
 				// Render!
 				graphics.Shaders.World3D.ApplySettings();
 				graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, 0, 12);
 			}
 
 			// Done
 			graphics.Shaders.World3D.EndPass();
 			graphics.Shaders.World3D.SetModulateColor(-1);
 			graphics.Device.SetRenderState(RenderState.TextureFactor, -1);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingEditForm.cs" startline="93" endline="177">
<![CDATA[
 
 		// This sets up the form to edit the given things
 		public void Setup(ICollection<Thing> things)
 		{
 			Thing ft;
 
 			preventchanges = true;
 
 			// Keep this list
 			this.things = things;
 			if(things.Count > 1) this.Text = "Edit Things (" + things.Count + ")";
 			
 			////////////////////////////////////////////////////////////////////////
 			// Set all options to the first thing properties
 			////////////////////////////////////////////////////////////////////////
 
 			ft = General.GetByIndex(things, 0);
 			
 			// Set type
 			thingtype.SelectType(ft.Type);
 			
 			// Flags
 			foreach(CheckBox c in flags.Checkboxes)
 				if(ft.Flags.ContainsKey(c.Tag.ToString())) c.Checked = ft.Flags[c.Tag.ToString()];
 			foreach(CheckBox c in flags.Checkboxes)
 				if(ft.Flags.ContainsKey(c.Tag.ToString())) c.Checked = ft.Flags[c.Tag.ToString()];
 			
 			// Coordination
 			angle.Text = ft.AngleDoom.ToString();
 			height.Text = ((int)ft.Position.z).ToString();
 			
 			// Action/tags
 			action.Value = ft.Action;
 			tag.Text = ft.Tag.ToString();
 			arg0.SetValue(ft.Args[0]);
 			arg1.SetValue(ft.Args[1]);
 			arg2.SetValue(ft.Args[2]);
 			arg3.SetValue(ft.Args[3]);
 			arg4.SetValue(ft.Args[4]);
 
 			// Custom fields
 			fieldslist.SetValues(ft.Fields, true);
 
 			////////////////////////////////////////////////////////////////////////
 			// Now go for all lines and change the options when a setting is different
 			////////////////////////////////////////////////////////////////////////
 			
 			// Go for all things
 			foreach(Thing t in things)
 			{
 				// Type does not match?
 				if((thingtype.GetSelectedInfo() != null) &&
 				   (thingtype.GetSelectedInfo().Index != t.Type))
 					thingtype.ClearSelectedType();
 				
 				// Flags
 				foreach(CheckBox c in flags.Checkboxes)
 				{
 					if(t.Flags.ContainsKey(c.Tag.ToString()))
 					{
 						if(t.Flags[c.Tag.ToString()] != c.Checked)
 						{
 							c.ThreeState = true;
 							c.CheckState = CheckState.Indeterminate;
 						}
 					}
 				}
 				foreach(CheckBox c in flags.Checkboxes)
 				{
 					if(t.Flags.ContainsKey(c.Tag.ToString()))
 					{
 						if(t.Flags[c.Tag.ToString()] != c.Checked)
 						{
 							c.ThreeState = true;
 							c.CheckState = CheckState.Indeterminate;
 						}
 					}
 				}
 				
 				// Coordination
 				if(t.AngleDoom.ToString() != angle.Text) angle.Text = "";
 				if(((int)t.Position.z).ToString() != height.Text) height.Text = "";
 
 				// Action/tags
 				if(t.Action != action.Value) action.Empty = true;
 				if(t.Tag.ToString() != tag.Text) tag.Text = "";
 				if(t.Args[0] != arg0.GetResult(-1)) arg0.ClearValue();
 				if(t.Args[1] != arg1.GetResult(-1)) arg1.ClearValue();
 				if(t.Args[2] != arg2.GetResult(-1)) arg2.ClearValue();
 				if(t.Args[3] != arg3.GetResult(-1)) arg3.ClearValue();
 				if(t.Args[4] != arg4.GetResult(-1)) arg4.ClearValue();
 
 				// Custom fields
 				fieldslist.SetValues(t.Fields, false);
 			}
 			foreach(Thing t in things)
 			{
 				// Type does not match?
 				if((thingtype.GetSelectedInfo() != null) &&
 				   (thingtype.GetSelectedInfo().Index != t.Type))
 					thingtype.ClearSelectedType();
 				
 				// Flags
 				foreach(CheckBox c in flags.Checkboxes)
 				{
 					if(t.Flags.ContainsKey(c.Tag.ToString()))
 					{
 						if(t.Flags[c.Tag.ToString()] != c.Checked)
 						{
 							c.ThreeState = true;
 							c.CheckState = CheckState.Indeterminate;
 						}
 					}
 				}
 				
 				// Coordination
 				if(t.AngleDoom.ToString() != angle.Text) angle.Text = "";
 				if(((int)t.Position.z).ToString() != height.Text) height.Text = "";
 
 				// Action/tags
 				if(t.Action != action.Value) action.Empty = true;
 				if(t.Tag.ToString() != tag.Text) tag.Text = "";
 				if(t.Args[0] != arg0.GetResult(-1)) arg0.ClearValue();
 				if(t.Args[1] != arg1.GetResult(-1)) arg1.ClearValue();
 				if(t.Args[2] != arg2.GetResult(-1)) arg2.ClearValue();
 				if(t.Args[3] != arg3.GetResult(-1)) arg3.ClearValue();
 				if(t.Args[4] != arg4.GetResult(-1)) arg4.ClearValue();
 
 				// Custom fields
 				fieldslist.SetValues(t.Fields, false);
 			}
 
 			preventchanges = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="170" endline="264">
<![CDATA[
 		
 		// Item selected
 		private void listfilters_SelectedIndexChanged(object sender, EventArgs e)
 		{
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Get selected filter
 				ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 
 				// Enable settings
 				settingup = true;
 				deletefilter.Enabled = true;
 				filtergroup.Enabled = true;
 				
 				// Show name
 				filtername.Text = f.Name;
 				
 				// Properties
 				foreach(object c in filtercategory.Items)
 				{
 					ThingCategory tc = (c as ThingCategory);
 					if((tc != null) && (tc.Name == f.CategoryName)) filtercategory.SelectedItem = tc;
 				}
 				foreach(object c in filtercategory.Items)
 				{
 					ThingCategory tc = (c as ThingCategory);
 					if((tc != null) && (tc.Name == f.CategoryName)) filtercategory.SelectedItem = tc;
 				}
 				if(filtercategory.SelectedIndex == -1) filtercategory.SelectedIndex = 0;
 				
 				if(f.ThingType > -1)
 					filtertype.Value = f.ThingType;
 				else
 					filtertype.Empty = true;
 				
 				if(f.ThingAngle > -1)
 					filterangle.Text = f.ThingAngle.ToString();
 				else
 					filterangle.Text = "";
 					
 				if(f.ThingZHeight > int.MinValue)
 					filterzheight.Text = f.ThingZHeight.ToString();
 				else
 					filterzheight.Text = "";
 				
 				// Action
 				if(f.ThingAction > -1)
 					filteraction.Value = f.ThingAction;
 				else
 					filteraction.Empty = true;
 				
 				if(f.ThingArgs[0] > -1) arg0.SetValue(f.ThingArgs[0]); else arg0.ClearValue();
 				if(f.ThingArgs[1] > -1) arg1.SetValue(f.ThingArgs[1]); else arg1.ClearValue();
 				if(f.ThingArgs[2] > -1) arg2.SetValue(f.ThingArgs[2]); else arg2.ClearValue();
 				if(f.ThingArgs[3] > -1) arg3.SetValue(f.ThingArgs[3]); else arg3.ClearValue();
 				if(f.ThingArgs[4] > -1) arg4.SetValue(f.ThingArgs[4]); else arg4.ClearValue();
 				
 				if(f.ThingTag > -1)
 					filtertag.Text = f.ThingTag.ToString();
 				else
 					filtertag.Text = "";
 				
 				// Flags
 				foreach(CheckBox b in filterfields.Checkboxes)
 				{
 					// Field name forbidden?
 					if(f.ForbiddenFields.Contains(b.Tag.ToString()))
 					{
 						b.CheckState = CheckState.Unchecked;
 					}
 					// Field name required?
 					else if(f.RequiredFields.Contains(b.Tag.ToString()))
 					{
 						b.CheckState = CheckState.Checked;
 					}
 					else
 					{
 						b.CheckState = CheckState.Indeterminate;
 					}
 				}
 				foreach(CheckBox b in filterfields.Checkboxes)
 				{
 					// Field name forbidden?
 					if(f.ForbiddenFields.Contains(b.Tag.ToString()))
 					{
 						b.CheckState = CheckState.Unchecked;
 					}
 					// Field name required?
 					else if(f.RequiredFields.Contains(b.Tag.ToString()))
 					{
 						b.CheckState = CheckState.Checked;
 					}
 					else
 					{
 						b.CheckState = CheckState.Indeterminate;
 					}
 				}
 				
 				// Custom fields
 				fieldslist.ClearFields();
 				fieldslist.Setup("thing");
 				fieldslist.SetValues(f.ThingCustomFields, true);
 				
 				// Done
 				settingup = false;
 			}
 			else
 			{
 				// Disable filter settings
 				deletefilter.Enabled = false;
 				filtergroup.Enabled = false;
 				filtername.Text = "";
 				filtercategory.SelectedIndex = -1;
 				foreach(CheckBox c in filterfields.Checkboxes) c.CheckState = CheckState.Indeterminate;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="415" endline="425">
<![CDATA[
 		
 		// This returns true when any of the implicit-save scripts are changed
 		public bool CheckImplicitChanges()
 		{
 			bool changes = false;
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				if(!t.ExplicitSave && t.IsChanged) changes = true;
 			}
 			foreach(ScriptDocumentTab t in tabs.TabPages)
 			{
 				if(!t.ExplicitSave && t.IsChanged) changes = true;
 			}
 			return changes;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CopyPasteManager.cs" startline="375" endline="393">
<![CDATA[
 		
 		// This pastes what is on the clipboard and marks the new geometry
 		[BeginAction("pasteselectionspecial")]
 		public void PasteSelectionSpecial()
 		{
 			// Check if possible to copy/paste
 			if(General.Editing.Mode.Attributes.AllowCopyPaste)
 			{
 				PasteOptionsForm form = new PasteOptionsForm();
 				DialogResult result = form.ShowDialog(General.MainWindow);
 				if(result == DialogResult.OK) DoPasteSelection(form.Options);
 				form.Dispose();
 			}
 			else
 			{
 				// Paste not allowed
 				General.MessageBeep(MessageBeepType.Warning);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Compilers\NodesCompiler.cs" startline="71" endline="121">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This runs the compiler with a file as input.
 		public override bool Run()
 		{
 			ProcessStartInfo processinfo;
 			Process process;
 			TimeSpan deltatime;
 			
 			// Create parameters
 			string args = this.parameters;
 			args = args.Replace("%FI", inputfile);
 			args = args.Replace("%FO", outputfile);
 			
 			// Setup process info
 			processinfo = new ProcessStartInfo();
 			processinfo.Arguments = args;
 			processinfo.FileName = Path.Combine(this.tempdir.FullName, info.ProgramFile);
 			processinfo.CreateNoWindow = false;
 			processinfo.ErrorDialog = false;
 			processinfo.UseShellExecute = true;
 			processinfo.WindowStyle = ProcessWindowStyle.Hidden;
 			processinfo.WorkingDirectory = this.workingdir;
 			
 			// Output info
 			General.WriteLogLine("Running compiler...");
 			General.WriteLogLine("Program
 			General.WriteLogLine("Arguments
 			
 			try
 			{
 				// Start the compiler
 				process = Process.Start(processinfo);
 			}
 			catch(Exception e)
 			{
 				// Unable to start the compiler
 				General.ShowErrorMessage("Unable to start the compiler (" + info.Name + "). " + e.GetType().Name + "
 				return false;
 			}
 			
 			// Wait for compiler to complete
 			process.WaitForExit();
 			deltatime = TimeSpan.FromTicks(process.ExitTime.Ticks - process.StartTime.Ticks);
 			General.WriteLogLine("Compiler process has finished.");
 			General.WriteLogLine("Compile time
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1065" endline="1074">
<![CDATA[
 
 		// Mouse moves
 		private void display_MouseMove(object sender, MouseEventArgs e)
 		{
 			if((General.Map != null) && (mouseinput == null) && (General.Editing.Mode != null))
 			{
 				General.Plugins.OnEditMouseMove(e);
 				General.Editing.Mode.OnMouseMove(e);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipPolygon.cs" startline="67" endline="77">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Methods
 
 		// This merges a polygon into this one
 		public void Add(EarClipPolygon p)
 		{
 			// Initialize
 			foreach(EarClipVertex v in p) base.AddLast(v);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\EarClipPolygon.cs" startline="78" endline="98">
<![CDATA[
 
 		// This calculates the area
 		public float CalculateArea()
 		{
 			// Multiply the x coordinate of each vertex by the y coordinate of the next vertex.
 			// Multiply the y coordinate of each vertex by the x coordinate of the next vertex.
 			// Subtract these.
 			float result = 0.0f;
 			int firstcalculated = 0;
 			LinkedListNode<EarClipVertex> n1 = base.First;
 			while(firstcalculated < 2)
 			{
 				LinkedListNode<EarClipVertex> n2 = n1.Next ?? base.First;
 				float a = n1.Value.Position.x * n2.Value.Position.y;
 				float b = n1.Value.Position.y * n2.Value.Position.x;
 				result += a - b;
 				n1 = n2;
 				if(n2 == base.First) firstcalculated++;
 			}
 			while(firstcalculated < 2)
 			{
 				LinkedListNode<EarClipVertex> n2 = n1.Next ?? base.First;
 				float a = n1.Value.Position.x * n2.Value.Position.y;
 				float b = n1.Value.Position.y * n2.Value.Position.x;
 				result += a - b;
 				n1 = n2;
 				if(n2 == base.First) firstcalculated++;
 			}
 			return Math.Abs(result / 2.0f);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1735" endline="1756">
<![CDATA[
 
 		/// <summary>This increases and existing area with the given vertices.</summary>
 		public static RectangleF IncreaseArea(RectangleF area, ICollection<Vertex> verts)
 		{
 			float l = area.Left;
 			float t = area.Top;
 			float r = area.Right;
 			float b = area.Bottom;
 			
 			// Go for all vertices
 			foreach(Vertex v in verts)
 			{
 				// Adjust boundaries by vertices
 				if(v.Position.x < l) l = v.Position.x;
 				if(v.Position.x > r) r = v.Position.x;
 				if(v.Position.y < t) t = v.Position.y;
 				if(v.Position.y > b) b = v.Position.y;
 			}
 			foreach(Vertex v in verts)
 			{
 				// Adjust boundaries by vertices
 				if(v.Position.x < l) l = v.Position.x;
 				if(v.Position.x > r) r = v.Position.x;
 				if(v.Position.y < t) t = v.Position.y;
 				if(v.Position.y > b) b = v.Position.y;
 			}
 			
 			// Return a rect
 			return new RectangleF(l, t, r - l, b - t);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1757" endline="1778">
<![CDATA[
 
 		/// <summary>This increases and existing area with the given things.</summary>
 		public static RectangleF IncreaseArea(RectangleF area, ICollection<Thing> things)
 		{
 			float l = area.Left;
 			float t = area.Top;
 			float r = area.Right;
 			float b = area.Bottom;
 			
 			// Go for all vertices
 			foreach(Thing th in things)
 			{
 				// Adjust boundaries by vertices
 				if(th.Position.x < l) l = th.Position.x;
 				if(th.Position.x > r) r = th.Position.x;
 				if(th.Position.y < t) t = th.Position.y;
 				if(th.Position.y > b) b = th.Position.y;
 			}
 			foreach(Thing th in things)
 			{
 				// Adjust boundaries by vertices
 				if(th.Position.x < l) l = th.Position.x;
 				if(th.Position.x > r) r = th.Position.x;
 				if(th.Position.y < t) t = th.Position.y;
 				if(th.Position.y > b) b = th.Position.y;
 			}
 			
 			// Return a rect
 			return new RectangleF(l, t, r - l, b - t);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CopyPasteManager.cs" startline="401" endline="457">
<![CDATA[
 
 		// This creates a new prefab from selection
 		[BeginAction("createprefab")]
 		public void CreatePrefab()
 		{
 			// Check if possible to copy/paste
 			if(General.Editing.Mode.Attributes.AllowCopyPaste)
 			{
 				Cursor oldcursor = Cursor.Current;
 				Cursor.Current = Cursors.WaitCursor;
 				
 				MemoryStream data = MakePrefab();
 				if(data != null)
 				{
 					Cursor.Current = oldcursor;
 					
 					SaveFileDialog savefile = new SaveFileDialog();
 					savefile.Filter = "Doom Builder Prefabs (*.dbprefab)|*.dbprefab";
 					savefile.Title = "Save Prefab As";
 					savefile.AddExtension = true;
 					savefile.CheckPathExists = true;
 					savefile.OverwritePrompt = true;
 					savefile.ValidateNames = true;
 					if(savefile.ShowDialog(General.MainWindow) == DialogResult.OK)
 					{
 						try
 						{
 							Cursor.Current = Cursors.WaitCursor;
 							if(File.Exists(savefile.FileName)) File.Delete(savefile.FileName);
 							File.WriteAllBytes(savefile.FileName, data.ToArray());
 						}
 						catch(Exception e)
 						{
 							Cursor.Current = oldcursor;
 							General.ErrorLogger.Add(ErrorType.Error, e.GetType().Name + " while writing prefab to file
 							General.WriteLogLine(e.StackTrace);
 							General.ShowErrorMessage("Error while writing prefab to file! See log file for error details.", MessageBoxButtons.OK);
 						}
 					}
 					data.Dispose();
 				}
 				else
 				{
 					// Can't make a prefab right now
 					General.MessageBeep(MessageBeepType.Warning);
 				}
 				
 				// Done
 				General.MainWindow.UpdateInterface();
 				Cursor.Current = oldcursor;
 			}
 			else
 			{
 				// Create prefab not allowed
 				General.MessageBeep(MessageBeepType.Warning);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\TextFont.cs" startline="77" endline="146">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public bool IsDisposed { get { return isdisposed; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal TextFont()
 		{
 			Configuration cfg;
 			Stream fontdata;
 			StreamReader fontreader;
 			string[] resnames;
 			
 			// Initialize
 			characters = new FontCharacter[256];
 
 			// Make chars configuration
 			cfg = new Configuration();
 			
 			// Find a resource named Font.cfg
 			resnames = General.ThisAssembly.GetManifestResourceNames();
 			foreach(string rn in resnames)
 			{
 				// Found it?
 				if(rn.EndsWith(FONT_RESOURCE, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					fontdata = General.ThisAssembly.GetManifestResourceStream(rn);
 					fontreader = new StreamReader(fontdata, Encoding.ASCII);
 
 					// Load configuration from stream
 					cfg.InputConfiguration(fontreader.ReadToEnd());
 
 					// Done
 					fontreader.Dispose();
 					fontdata.Dispose();
 					break;
 				}
 			}
 			foreach(string rn in resnames)
 			{
 				// Found it?
 				if(rn.EndsWith(FONT_RESOURCE, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					fontdata = General.ThisAssembly.GetManifestResourceStream(rn);
 					fontreader = new StreamReader(fontdata, Encoding.ASCII);
 
 					// Load configuration from stream
 					cfg.InputConfiguration(fontreader.ReadToEnd());
 
 					// Done
 					fontreader.Dispose();
 					fontdata.Dispose();
 					break;
 				}
 			}
 			
 			// Get the charset from configuration
 			IDictionary cfgchars = cfg.ReadSetting("chars", new Hashtable());
 
 			// Go for all defined chars
 			foreach(DictionaryEntry item in cfgchars)
 			{
 				// Get the character Hashtable
 				IDictionary chr = (IDictionary)item.Value;
 				int i = Convert.ToInt32(item.Key);
 
 				// This is ancient code of mine.
 				// The charater sizes were based on 800x600 resolution.
 				characters[i].width = (float)(int)chr["width"] / 40f;
 				characters[i].height = (float)(int)chr["height"] / 30f;
 				characters[i].u1 = (float)chr["u1"];
 				characters[i].v1 = (float)chr["v1"];
 				characters[i].u2 = (float)chr["u2"];
 				characters[i].v2 = (float)chr["v2"];
 			}
 			foreach(DictionaryEntry item in cfgchars)
 			{
 				// Get the character Hashtable
 				IDictionary chr = (IDictionary)item.Value;
 				int i = Convert.ToInt32(item.Key);
 
 				// This is ancient code of mine.
 				// The charater sizes were based on 800x600 resolution.
 				characters[i].width = (float)(int)chr["width"] / 40f;
 				characters[i].height = (float)(int)chr["height"] / 30f;
 				characters[i].u1 = (float)chr["u1"];
 				characters[i].v1 = (float)chr["v1"];
 				characters[i].u2 = (float)chr["u2"];
 				characters[i].v2 = (float)chr["v2"];
 			}
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamReader.cs" startline="485" endline="496">
<![CDATA[
 
 		// This makes a list of all collections with the given name
 		private List<UniversalCollection> GetNamedCollections(UniversalCollection collection, string entryname)
 		{
 			List<UniversalCollection> list = new List<UniversalCollection>();
 
 			// Make list
 			foreach(UniversalEntry e in collection)
 				if((e.Value is UniversalCollection) && (e.Key == entryname)) list.Add(e.Value as UniversalCollection);
 			foreach(UniversalEntry e in collection)
 				if((e.Value is UniversalCollection) && (e.Key == entryname)) list.Add(e.Value as UniversalCollection);
 
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="418" endline="451">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Methods
 		
 		// This loads the images in this directory
 		private ICollection<ImageData> LoadDirectoryImages(string path, int imagetype, bool includesubdirs)
 		{
 			List<ImageData> images = new List<ImageData>();
 			string[] files;
 			string name;
 			
 			// Go for all files
 			files = GetAllFiles(path, includesubdirs);
 			foreach(string f in files)
 			{
 				// Make the texture name from filename without extension
 				name = Path.GetFileNameWithoutExtension(f).ToUpperInvariant();
 				if(name.Length > 8) name = name.Substring(0, 8);
 				if(name.Length > 0)
 				{
 					// Add image to list
 					images.Add(CreateImage(name, f, imagetype));
 				}
 				else
 				{
 					// Can't load image without name
 					General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed texture from \"" + path + "\". Please consider giving names to your resources.");
 				}
 			}
 			foreach(string f in files)
 			{
 				// Make the texture name from filename without extension
 				name = Path.GetFileNameWithoutExtension(f).ToUpperInvariant();
 				if(name.Length > 8) name = name.Substring(0, 8);
 				if(name.Length > 0)
 				{
 					// Add image to list
 					images.Add(CreateImage(name, f, imagetype));
 				}
 				else
 				{
 					// Can't load image without name
 					General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed texture from \"" + path + "\". Please consider giving names to your resources.");
 				}
 			}
 			
 			// Return result
 			return images;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Compilers\Compiler.cs" startline="129" endline="145">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 
 		// This copies all compiler files to a given destination
 		private void CopyRequiredFiles()
 		{
 			// Copy files
 			foreach(string f in info.Files)
 			{
 				string sourcefile = Path.Combine(info.Path, f);
 				string targetfile = Path.Combine(tempdir.FullName, f);
 				if(!File.Exists(sourcefile)) General.ErrorLogger.Add(ErrorType.Error, "The file '" + f + "' required by the '" + info.Name + "' compiler is missing. According to the compiler configuration in '" + info.FileName + "', the was expected to be found in the following path
 				File.Copy(sourcefile, targetfile, true);
 			}
 			foreach(string f in info.Files)
 			{
 				string sourcefile = Path.Combine(info.Path, f);
 				string targetfile = Path.Combine(tempdir.FullName, f);
 				if(!File.Exists(sourcefile)) General.ErrorLogger.Add(ErrorType.Error, "The file '" + f + "' required by the '" + info.Name + "' compiler is missing. According to the compiler configuration in '" + info.FileName + "', the was expected to be found in the following path
 				File.Copy(sourcefile, targetfile, true);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DirectoryReader.cs" startline="69" endline="105">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Textures
 
 		// This finds and returns a patch stream
 		public override Stream GetPatchData(string pname)
 		{
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find in any of the wad files
 			// Note the backward order, because the last wad's images have priority
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetPatchData(pname);
 				if(data != null) return data;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetPatchData(pname);
 				if(data != null) return data;
 			}
 			
 			try
 			{
 				// Find in patches directory
 				string path = Path.Combine(PATCHES_DIR, Path.GetDirectoryName(pname));
 				string filename = FindFirstFile(path, Path.GetFileName(pname), true);
 				if((filename != null) && FileExists(filename))
 				{
 					return LoadFile(filename);
 				}
 			}
 			catch(Exception e)
 			{
 				General.ErrorLogger.Add(ErrorType.Error, e.GetType().Name + " while loading patch '" + pname + "' from directory
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DirectoryReader.cs" startline="106" endline="138">
<![CDATA[
 
 		// This finds and returns a textue stream
 		public override Stream GetTextureData(string pname)
 		{
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find in any of the wad files
 			// Note the backward order, because the last wad's images have priority
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetTextureData(pname);
 				if(data != null) return data;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetTextureData(pname);
 				if(data != null) return data;
 			}
 			
 			try
 			{
 				// Find in patches directory
 				string path = Path.Combine(TEXTURES_DIR, Path.GetDirectoryName(pname));
 				string filename = FindFirstFile(path, Path.GetFileName(pname), true);
 				if((filename != null) && FileExists(filename))
 				{
 					return LoadFile(filename);
 				}
 			}
 			catch(Exception e)
 			{
 				General.ErrorLogger.Add(ErrorType.Error, e.GetType().Name + " while loading texture '" + pname + "' from directory
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DirectoryReader.cs" startline="139" endline="171">
<![CDATA[
 
 		// This finds and returns a colormap stream
 		public override Stream GetColormapData(string pname)
 		{
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find in any of the wad files
 			// Note the backward order, because the last wad's images have priority
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetColormapData(pname);
 				if(data != null) return data;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetColormapData(pname);
 				if(data != null) return data;
 			}
 
 			try
 			{
 				// Find in patches directory
 				string path = Path.Combine(COLORMAPS_DIR, Path.GetDirectoryName(pname));
 				string filename = FindFirstFile(path, Path.GetFileName(pname), true);
 				if((filename != null) && FileExists(filename))
 				{
 					return LoadFile(filename);
 				}
 			}
 			catch(Exception e)
 			{
 				General.ErrorLogger.Add(ErrorType.Error, e.GetType().Name + " while loading colormap '" + pname + "' from directory
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DirectoryReader.cs" startline="172" endline="207">
<![CDATA[
 
 		#endregion
 
 		#region ================== Sprites
 
 		// This finds and returns a sprite stream
 		public override Stream GetSpriteData(string pname)
 		{
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find in any of the wad files
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream sprite = wads[i].GetSpriteData(pname);
 				if(sprite != null) return sprite;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream sprite = wads[i].GetSpriteData(pname);
 				if(sprite != null) return sprite;
 			}
 			
 			try
 			{
 				// Find in sprites directory
 				string path = Path.Combine(SPRITES_DIR, Path.GetDirectoryName(pname));
 				string filename = FindFirstFile(path, Path.GetFileName(pname), true);
 				if((filename != null) && FileExists(filename))
 				{
 					return LoadFile(filename);
 				}
 			}
 			catch(Exception e)
 			{
 				General.ErrorLogger.Add(ErrorType.Error, e.GetType().Name + " while loading sprite '" + pname + "' from directory
 			}
 			
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ZDTextParser.cs" startline="127" endline="188">
<![CDATA[
 		
 		// This skips whitespace on the stream, placing the read
 		// position right before the first non-whitespace character
 		// Returns false when the end of the stream is reached
 		protected internal bool SkipWhitespace(bool skipnewline)
 		{
 			int offset = skipnewline ? 0 
 			char c;
 			
 			do
 			{
 				if(datastream.Position == datastream.Length) return false;
 				c = (char)datareader.ReadByte();
 
 				// Check if this is comment
 				if(c == '/')
 				{
 					if(datastream.Position == datastream.Length) return false;
 					char c2 = (char)datareader.ReadByte();
 					if(c2 == '/')
 					{
 						// Check if not a special comment with a token
 						if(datastream.Position == datastream.Length) return false;
 						char c3 = (char)datareader.ReadByte();
 						if(c3 != '$')
 						{
 							// Skip entire line
 							char c4 = ' ';
 							while((c4 != '\n') && (datastream.Position < datastream.Length)) { c4 = (char)datareader.ReadByte(); }
 							c = c4;
 						}
 						else
 						{
 							// Not a comment
 							c = c3;
 						}
 					}
 					else if(c2 == '*')
 					{
 						// Skip until */
 						char c4, c3 = '\0';
 						do
 						{
 							c4 = c3;
 							c3 = (char)datareader.ReadByte();
 						}
 						while((c4 != '*') || (c3 != '/'));
 						c = ' ';
 					}
 					else
 					{
 						// Not a comment, rewind from reading c2
 						datastream.Seek(-1, SeekOrigin.Current);
 					}
 				}
 			}
 			while(whitespace.IndexOf(c, offset) > -1);
 			
 			// Go one character back so we can read this non-whitespace character again
 			datastream.Seek(-1, SeekOrigin.Current);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="295" endline="347">
<![CDATA[
 		
 		// This zooms and scrolls to fit the map in the window
 		[BeginAction("centerinscreen", BaseAction = true)]
 		public void CenterInScreen()
 		{
 			float left = float.MaxValue;
 			float top = float.MaxValue;
 			float right = float.MinValue;
 			float bottom = float.MinValue;
 			bool anything = false;
 			
 			// Go for all vertices
 			foreach(Vertex v in General.Map.Map.Vertices)
 			{
 				// Vertex used?
 				if(v.Linedefs.Count > 0)
 				{
 					// Adjust boundaries by vertices
 					if(v.Position.x < left) left = v.Position.x;
 					if(v.Position.x > right) right = v.Position.x;
 					if(v.Position.y < top) top = v.Position.y;
 					if(v.Position.y > bottom) bottom = v.Position.y;
 					anything = true;
 				}
 			}
 			foreach(Vertex v in General.Map.Map.Vertices)
 			{
 				// Vertex used?
 				if(v.Linedefs.Count > 0)
 				{
 					// Adjust boundaries by vertices
 					if(v.Position.x < left) left = v.Position.x;
 					if(v.Position.x > right) right = v.Position.x;
 					if(v.Position.y < top) top = v.Position.y;
 					if(v.Position.y > bottom) bottom = v.Position.y;
 					anything = true;
 				}
 			}
 
 			// Not already found something to center in view?
 			if(!anything)
 			{
 				// Go for all things
 				foreach(Thing t in General.Map.Map.Things)
 				{
 					// Adjust boundaries by vertices
 					if(t.Position.x < left) left = t.Position.x;
 					if(t.Position.x > right) right = t.Position.x;
 					if(t.Position.y < top) top = t.Position.y;
 					if(t.Position.y > bottom) bottom = t.Position.y;
 					anything = true;
 				}
 				foreach(Thing t in General.Map.Map.Things)
 				{
 					// Adjust boundaries by vertices
 					if(t.Position.x < left) left = t.Position.x;
 					if(t.Position.x > right) right = t.Position.x;
 					if(t.Position.y < top) top = t.Position.y;
 					if(t.Position.y > bottom) bottom = t.Position.y;
 					anything = true;
 				}
 			}
 			
 			// Anything found to center in view?
 			if(anything)
 			{
 				RectangleF area = new RectangleF(left, top, (right - left), (bottom - top));
 				CenterOnArea(area, CENTER_VIEW_PADDING);
 			}
 			else
 			{
 				// Default view
 				SetDefaultZoom();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Plugins\PluginManager.cs" startline="101" endline="208">
<![CDATA[
 		
 		
 		// This loads all plugins
 		public void LoadAllPlugins()
 		{
 			List<string> filenames;
 			Type[] editclasses;
 			EditModeAttribute[] emattrs;
 			EditModeInfo editmodeinfo;
 			Configuration cfg;
 			IDictionary loadorderfiles = new ListDictionary();
 			Plugin p;
 			
 			try
 			{
 				// Load the load order cfg
 				cfg = new Configuration(Path.Combine(General.PluginsPath, "Loadorder.cfg"), true);
 				
 				// Check for erors
 				if(cfg.ErrorResult)
 				{
 					// Error in configuration
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to read the load order configuration file \"Loadorder.cfg\". " +
 											"Error in file \"" + cfg.ErrorFile + "\" near line " + cfg.ErrorLine + "
 				}
 				else
 				{
 					loadorderfiles = cfg.ReadSetting("loadorder", new ListDictionary());
 				}
 			}
 			catch(Exception e)
 			{
 				// Unable to load configuration
 				General.ErrorLogger.Add(ErrorType.Error, "Unable to read the load order configuration file \"Loadorder.cfg\". " + e.GetType().Name + "
 				General.WriteLogLine(e.StackTrace);
 			}
 			
 			// Find all .dll files
 			filenames = new List<string>(Directory.GetFiles(General.PluginsPath, "*.dll", SearchOption.TopDirectoryOnly));
 			
 			// Load the ones in order as specified by the load order cfg
 			foreach(DictionaryEntry de in loadorderfiles)
 			{
 				string loadfilename = de.Key.ToString();
 				
 				// Find the file in the list
 				int filenameindex = -1;
 				for(int i = 0; i < filenames.Count; i++)
 					if(string.Compare(Path.GetFileName(filenames[i]), loadfilename, true) == 0)
 						filenameindex = i;
 				for(int i = 0; i < filenames.Count; i++)
 					if(string.Compare(Path.GetFileName(filenames[i]), loadfilename, true) == 0)
 						filenameindex = i;
 				
 				if(filenameindex > -1)
 				{
 					// Load plugin from this file
 					try
 					{
 						p = new Plugin(filenames[filenameindex]);
 					}
 					catch(InvalidProgramException)
 					{
 						p = null;
 					}
 					
 					// Continue if no errors
 					if((p != null) && (!p.IsDisposed))
 					{
 						// Add to plugins
 						this.plugins.Add(p);
 						
 						// Load actions
 						General.Actions.LoadActions(p.Assembly);
 						
 						// Plugin is now initialized
 						p.Plug.OnInitialize();
 					}
 					
 					// Remove the plugin from list
 					filenames.RemoveAt(filenameindex);
 				}
 			}
 			foreach(DictionaryEntry de in loadorderfiles)
 			{
 				string loadfilename = de.Key.ToString();
 				
 				// Find the file in the list
 				int filenameindex = -1;
 				for(int i = 0; i < filenames.Count; i++)
 					if(string.Compare(Path.GetFileName(filenames[i]), loadfilename, true) == 0)
 						filenameindex = i;
 				
 				if(filenameindex > -1)
 				{
 					// Load plugin from this file
 					try
 					{
 						p = new Plugin(filenames[filenameindex]);
 					}
 					catch(InvalidProgramException)
 					{
 						p = null;
 					}
 					
 					// Continue if no errors
 					if((p != null) && (!p.IsDisposed))
 					{
 						// Add to plugins
 						this.plugins.Add(p);
 						
 						// Load actions
 						General.Actions.LoadActions(p.Assembly);
 						
 						// Plugin is now initialized
 						p.Plug.OnInitialize();
 					}
 					
 					// Remove the plugin from list
 					filenames.RemoveAt(filenameindex);
 				}
 			}
 			
 			// Now load the remaining files
 			foreach(string fn in filenames)
 			{
 				// Load plugin from this file
 				try
 				{
 					p = new Plugin(fn);
 				}
 				catch(InvalidProgramException)
 				{
 					p = null;
 				}
 				
 				// Continue if no errors
 				if((p != null) && (!p.IsDisposed))
 				{
 					// Add to plugins
 					this.plugins.Add(p);
 					
 					// Load actions
 					General.Actions.LoadActions(p.Assembly);
 					
 					// Plugin is now initialized
 					p.Plug.OnInitialize();
 				}
 			}
 			foreach(string fn in filenames)
 			{
 				// Load plugin from this file
 				try
 				{
 					p = new Plugin(fn);
 				}
 				catch(InvalidProgramException)
 				{
 					p = null;
 				}
 				
 				// Continue if no errors
 				if((p != null) && (!p.IsDisposed))
 				{
 					// Add to plugins
 					this.plugins.Add(p);
 					
 					// Load actions
 					General.Actions.LoadActions(p.Assembly);
 					
 					// Plugin is now initialized
 					p.Plug.OnInitialize();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="992" endline="1074">
<![CDATA[
 		
 		// This copies specific map lumps from one WAD to another
 		private void CopyLumpsByType(WAD source, string sourcemapname,
 									 WAD target, string targetmapname,
 									 bool copyrequired, bool copyblindcopy,
 									 bool copynodebuild, bool copyscript)
 		{
 			bool lumprequired, lumpblindcopy, lumpnodebuild;
 			string lumpscript, srclumpname, tgtlumpname;
 			int srcheaderindex, tgtheaderindex, targetindex, sourceindex, lumpindex;
 			Lump lump, newlump;
 			
 			// Find the map header in target
 			tgtheaderindex = target.FindLumpIndex(targetmapname);
 			if(tgtheaderindex == -1)
 			{
 				// If this header doesnt exists in the target
 				// then insert at the end of the target
 				tgtheaderindex = target.Lumps.Count;
 			}
 
 			// Begin inserting at target header index
 			targetindex = tgtheaderindex;
 			
 			// Find the map header in source
 			srcheaderindex = source.FindLumpIndex(sourcemapname);
 			if(srcheaderindex > -1)
 			{
 				// Copy the map header from source to target
 				//newlump = target.Insert(targetmapname, tgtindex++, source.Lumps[srcindex].Length);
 				//source.Lumps[srcindex].CopyTo(newlump);
 				
 				// Go for all the map lump names
 				foreach(DictionaryEntry ml in config.MapLumpNames)
 				{
 					// Read lump settings from map config
 					lumprequired = config.ReadSetting("maplumpnames." + ml.Key + ".required", false);
 					lumpblindcopy = config.ReadSetting("maplumpnames." + ml.Key + ".blindcopy", false);
 					lumpnodebuild = config.ReadSetting("maplumpnames." + ml.Key + ".nodebuild", false);
 					lumpscript = config.ReadSetting("maplumpnames." + ml.Key + ".script", "");
 
 					// Check if this lump should be copied
 					if((lumprequired && copyrequired) || (lumpblindcopy && copyblindcopy) ||
 					   (lumpnodebuild && copynodebuild) || ((lumpscript.Length != 0) && copyscript))
 					{
 						// Get the lump name
 						srclumpname = ml.Key.ToString();
 						tgtlumpname = ml.Key.ToString();
 						if(srclumpname == CONFIG_MAP_HEADER) srclumpname = sourcemapname;
 						if(tgtlumpname == CONFIG_MAP_HEADER) tgtlumpname = targetmapname;
 						
 						// Find the lump in the source
 						sourceindex = FindSpecificLump(source, srclumpname, srcheaderindex, sourcemapname, config.MapLumpNames);
 						if(sourceindex > -1)
 						{
 							// Remove lump at target
 							lumpindex = RemoveSpecificLump(target, tgtlumpname, tgtheaderindex, targetmapname, config.MapLumpNames);
 
 							// Determine target index
 							// When original lump was found and removed then insert at that position
 							// otherwise insert after last insertion position
 							if(lumpindex > -1) targetindex = lumpindex; else targetindex++;
 							if(targetindex > target.Lumps.Count) targetindex = target.Lumps.Count;
 							
 							// Copy the lump to the target
 							//General.WriteLogLine(srclumpname + " copying as " + tgtlumpname);
 							lump = source.Lumps[sourceindex];
 							newlump = target.Insert(tgtlumpname, targetindex, lump.Length);
 							lump.CopyTo(newlump);
 						}
 						else
 						{
 							// We don't want to bother the user with this. There are a lot of lumps in
 							// the game configs that are trivial and don't need to be found.
 							if(lumprequired)
 							{
 								General.ErrorLogger.Add(ErrorType.Warning, ml.Key.ToString() + " (required lump) should be read but was not found in the WAD file.");
 							}
 						}
 					}
 				}
 				foreach(DictionaryEntry ml in config.MapLumpNames)
 				{
 					// Read lump settings from map config
 					lumprequired = config.ReadSetting("maplumpnames." + ml.Key + ".required", false);
 					lumpblindcopy = config.ReadSetting("maplumpnames." + ml.Key + ".blindcopy", false);
 					lumpnodebuild = config.ReadSetting("maplumpnames." + ml.Key + ".nodebuild", false);
 					lumpscript = config.ReadSetting("maplumpnames." + ml.Key + ".script", "");
 
 					// Check if this lump should be copied
 					if((lumprequired && copyrequired) || (lumpblindcopy && copyblindcopy) ||
 					   (lumpnodebuild && copynodebuild) || ((lumpscript.Length != 0) && copyscript))
 					{
 						// Get the lump name
 						srclumpname = ml.Key.ToString();
 						tgtlumpname = ml.Key.ToString();
 						if(srclumpname == CONFIG_MAP_HEADER) srclumpname = sourcemapname;
 						if(tgtlumpname == CONFIG_MAP_HEADER) tgtlumpname = targetmapname;
 						
 						// Find the lump in the source
 						sourceindex = FindSpecificLump(source, srclumpname, srcheaderindex, sourcemapname, config.MapLumpNames);
 						if(sourceindex > -1)
 						{
 							// Remove lump at target
 							lumpindex = RemoveSpecificLump(target, tgtlumpname, tgtheaderindex, targetmapname, config.MapLumpNames);
 
 							// Determine target index
 							// When original lump was found and removed then insert at that position
 							// otherwise insert after last insertion position
 							if(lumpindex > -1) targetindex = lumpindex; else targetindex++;
 							if(targetindex > target.Lumps.Count) targetindex = target.Lumps.Count;
 							
 							// Copy the lump to the target
 							//General.WriteLogLine(srclumpname + " copying as " + tgtlumpname);
 							lump = source.Lumps[sourceindex];
 							newlump = target.Insert(tgtlumpname, targetindex, lump.Length);
 							lump.CopyTo(newlump);
 						}
 						else
 						{
 							// We don't want to bother the user with this. There are a lot of lumps in
 							// the game configs that are trivial and don't need to be found.
 							if(lumprequired)
 							{
 								General.ErrorLogger.Add(ErrorType.Warning, ml.Key.ToString() + " (required lump) should be read but was not found in the WAD file.");
 							}
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\TypesManager.cs" startline="46" endline="85">
<![CDATA[
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public bool IsDisposed { get { return isdisposed; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public TypesManager()
 		{
 			// Initialize
 			handlertypes = new Dictionary<int, TypeHandlerAttribute>();
 
 			// Go for all types in this assembly
 			Type[] types = General.ThisAssembly.GetTypes();
 			foreach(Type tp in types)
 			{
 				// Check if this type is a class
 				if(tp.IsClass && !tp.IsAbstract && !tp.IsArray)
 				{
 					// Check if class has an TypeHandler attribute
 					if(Attribute.IsDefined(tp, typeof(TypeHandlerAttribute), false))
 					{
 						// Add the type to the list
 						object[] attribs = tp.GetCustomAttributes(typeof(TypeHandlerAttribute), false);
 						TypeHandlerAttribute attr = (attribs[0] as TypeHandlerAttribute);
 						attr.Type = tp;
 						handlertypes.Add(attr.Index, attr);
 					}
 				}
 			}
 			foreach(Type tp in types)
 			{
 				// Check if this type is a class
 				if(tp.IsClass && !tp.IsAbstract && !tp.IsArray)
 				{
 					// Check if class has an TypeHandler attribute
 					if(Attribute.IsDefined(tp, typeof(TypeHandlerAttribute), false))
 					{
 						// Add the type to the list
 						object[] attribs = tp.GetCustomAttributes(typeof(TypeHandlerAttribute), false);
 						TypeHandlerAttribute attr = (attribs[0] as TypeHandlerAttribute);
 						attr.Type = tp;
 						handlertypes.Add(attr.Index, attr);
 					}
 				}
 			}
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ButtonsNumericTextboxDesigner.cs" startline="45" endline="72">
<![CDATA[
 			{
 				IList snaplines = base.SnapLines;
 
 				ButtonsNumericTextbox control = base.Control as ButtonsNumericTextbox;
 				if(control == null) { return snaplines; }
 
 				IDesigner designer = TypeDescriptor.CreateDesigner(control.Textbox, typeof(IDesigner));
 				if(designer == null) { return snaplines; }
 				designer.Initialize(control.Textbox);
 
 				using(designer)
 				{
 					ControlDesigner boxdesigner = designer as ControlDesigner;
 					if(boxdesigner == null) { return snaplines; }
 					
 					// Add the baseline and right snap lines from the textbox
 					foreach(SnapLine line in boxdesigner.SnapLines)
 					{
 						if(line.SnapLineType == SnapLineType.Baseline)
 							snaplines.Add(new SnapLine(line.SnapLineType, line.Offset + control.Textbox.Top, line.Filter, line.Priority));
 						
 						if(line.SnapLineType == SnapLineType.Right)
 							snaplines.Add(new SnapLine(line.SnapLineType, line.Offset + control.Textbox.Left, line.Filter, line.Priority));
 					}
 					foreach(SnapLine line in boxdesigner.SnapLines)
 					{
 						if(line.SnapLineType == SnapLineType.Baseline)
 							snaplines.Add(new SnapLine(line.SnapLineType, line.Offset + control.Textbox.Top, line.Filter, line.Priority));
 						
 						if(line.SnapLineType == SnapLineType.Right)
 							snaplines.Add(new SnapLine(line.SnapLineType, line.Offset + control.Textbox.Left, line.Filter, line.Priority));
 					}
 				}
 
 				return snaplines;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamWriter.cs" startline="270" endline="303">
<![CDATA[
 
 		// This adds things
 		private void WriteThings(ICollection<Thing> things, UniversalParser textmap)
 		{
 			// Go for all things
 			foreach(Thing t in things)
 			{
 				// Make collection
 				UniversalCollection coll = new UniversalCollection();
 				if(t.Tag != 0) coll.Add("id", t.Tag);
 				coll.Add("x", t.Position.x);
 				coll.Add("y", t.Position.y);
 				if(t.Position.z != 0.0f) coll.Add("height", (float)t.Position.z);
 				coll.Add("angle", t.AngleDoom);
 				coll.Add("type", t.Type);
 				if(t.Action != 0) coll.Add("special", t.Action);
 				if(t.Args[0] != 0) coll.Add("arg0", t.Args[0]);
 				if(t.Args[1] != 0) coll.Add("arg1", t.Args[1]);
 				if(t.Args[2] != 0) coll.Add("arg2", t.Args[2]);
 				if(t.Args[3] != 0) coll.Add("arg3", t.Args[3]);
 				if(t.Args[4] != 0) coll.Add("arg4", t.Args[4]);
 				coll.Comment = t.Index.ToString();
 
 				// Flags
 				foreach(KeyValuePair<string, bool> flag in t.Flags)
 					if(flag.Value) coll.Add(flag.Key, flag.Value);
 				foreach(KeyValuePair<string, bool> flag in t.Flags)
 					if(flag.Value) coll.Add(flag.Key, flag.Value);
 
 				// Add custom fields
 				AddCustomFields(t, "thing", coll);
 
 				// Store
 				textmap.Root.Add("thing", coll);
 			}
 			foreach(Thing t in things)
 			{
 				// Make collection
 				UniversalCollection coll = new UniversalCollection();
 				if(t.Tag != 0) coll.Add("id", t.Tag);
 				coll.Add("x", t.Position.x);
 				coll.Add("y", t.Position.y);
 				if(t.Position.z != 0.0f) coll.Add("height", (float)t.Position.z);
 				coll.Add("angle", t.AngleDoom);
 				coll.Add("type", t.Type);
 				if(t.Action != 0) coll.Add("special", t.Action);
 				if(t.Args[0] != 0) coll.Add("arg0", t.Args[0]);
 				if(t.Args[1] != 0) coll.Add("arg1", t.Args[1]);
 				if(t.Args[2] != 0) coll.Add("arg2", t.Args[2]);
 				if(t.Args[3] != 0) coll.Add("arg3", t.Args[3]);
 				if(t.Args[4] != 0) coll.Add("arg4", t.Args[4]);
 				coll.Comment = t.Index.ToString();
 
 				// Flags
 				foreach(KeyValuePair<string, bool> flag in t.Flags)
 					if(flag.Value) coll.Add(flag.Key, flag.Value);
 
 				// Add custom fields
 				AddCustomFields(t, "thing", coll);
 
 				// Store
 				textmap.Root.Add("thing", coll);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptFileDocumentTab.cs" startline="146" endline="168">
<![CDATA[
 		
 		// This saves the document (used for both explicit and implicit)
 		// Return true when successfully saved
 		public override bool Save()
 		{
 			try
 			{
 				// Write the file
 				File.WriteAllBytes(filepathname, editor.GetText());
 			}
 			catch(Exception e)
 			{
 				// Failed
 				General.ErrorLogger.Add(ErrorType.Error, "Cannot open file '" + filepathname + "' for writing. Make sure the path exists and that the file is not in use by another application.");
 				General.WriteLogLine(e.GetType().Name + "
 				General.ShowErrorMessage("Unable to open file \"" + filepathname + "\" for writing. Make sure the path exists and that the file is not in use by another application.", MessageBoxButtons.OK);
 				return false;
 			}
 			
 			// Done
 			editor.IsChanged = false;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CopyPasteManager.cs" startline="163" endline="205">
<![CDATA[
 		
 		// This pastes a prefab. Returns false when paste was cancelled.
 		internal void PastePrefab(Stream filedata, PasteOptions options)
 		{
 			// Create undo
 			General.MainWindow.DisplayStatus(StatusType.Action, "Inserted prefab.");
 			General.Map.UndoRedo.CreateUndo("Insert prefab");
 			
 			// Decompress stream
 			MemoryStream decompressed = new MemoryStream((int)filedata.Length * 3);
 			filedata.Seek(0, SeekOrigin.Begin);
 			BZip2.Decompress(filedata, decompressed);
 			MemoryStream memstream = new MemoryStream(decompressed.ToArray());
 			decompressed.Dispose();
 			
 			// Mark all current geometry
 			General.Map.Map.ClearAllMarks(true);
 			
 			// Read data stream
 			UniversalStreamReader reader = new UniversalStreamReader();
 			reader.StrictChecking = false;
 			General.Map.Map.BeginAddRemove();
 			reader.Read(General.Map.Map, memstream);
 			General.Map.Map.EndAddRemove();
 			
 			// The new geometry is not marked, so invert the marks to get it marked
 			General.Map.Map.InvertAllMarks();
 			
 			// Convert UDMF fields back to flags and activations, if needed
 			if(!(General.Map.FormatInterface is UniversalMapSetIO)) General.Map.Map.TranslateFromUDMF();
 
 			// Modify tags and actions if preferred
 			if(options.ChangeTags == PasteOptions.TAGS_REMOVE) Tools.RemoveMarkedTags();
 			if(options.ChangeTags == PasteOptions.TAGS_RENUMBER) Tools.RenumberMarkedTags();
 			if(options.RemoveActions) Tools.RemoveMarkedActions();
 			
 			// Done
 			memstream.Dispose();
 			General.Map.Map.UpdateConfiguration();
 			General.Map.ThingsFilter.Update();
 			General.Editing.Mode.OnPasteEnd(options);
 			General.Plugins.OnPasteEnd(options);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\EnumOptionHandler.cs" startline="151" endline="172">
<![CDATA[
 		
 		public override int GetIntValue()
 		{
 			if(this.value != null)
 			{
 				// Parse the value to integer
 				int result;
 				if(int.TryParse(this.value.Value, NumberStyles.Integer,
 								CultureInfo.InvariantCulture, out result))
 				{
 					return result;
 				}
 				else
 				{
 					return 0;
 				}
 			}
 			else
 			{
 				return 0;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Types\EnumStringsHandler.cs" startline="133" endline="154">
<![CDATA[
 
 		public override int GetIntValue()
 		{
 			if(this.value != null)
 			{
 				// Parse the value to integer
 				int result;
 				if(int.TryParse(this.value.Value, NumberStyles.Integer,
 								CultureInfo.InvariantCulture, out result))
 				{
 					return result;
 				}
 				else
 				{
 					return 0;
 				}
 			}
 			else
 			{
 				return 0;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="661" endline="684">
<![CDATA[
 
 		// This updates the used-in-map status on all textures and flats
 		private void BackgroundUpdateUsedTextures()
 		{
 			lock(usedimages)
 			{
 				// Set used on all textures
 				foreach(KeyValuePair<long, ImageData> i in textures)
 				{
 					i.Value.SetUsedInMap(usedimages.ContainsKey(i.Key));
 					if(i.Value.IsImageLoaded != i.Value.IsReferenced) ProcessImage(i.Value);
 				}
 				foreach(KeyValuePair<long, ImageData> i in textures)
 				{
 					i.Value.SetUsedInMap(usedimages.ContainsKey(i.Key));
 					if(i.Value.IsImageLoaded != i.Value.IsReferenced) ProcessImage(i.Value);
 				}
 
 				// Set used on all flats
 				foreach(KeyValuePair<long, ImageData> i in flats)
 				{
 					i.Value.SetUsedInMap(usedimages.ContainsKey(i.Key));
 					if(i.Value.IsImageLoaded != i.Value.IsReferenced) ProcessImage(i.Value);
 				}
 				foreach(KeyValuePair<long, ImageData> i in flats)
 				{
 					i.Value.SetUsedInMap(usedimages.ContainsKey(i.Key));
 					if(i.Value.IsImageLoaded != i.Value.IsReferenced) ProcessImage(i.Value);
 				}
 				
 				// Done
 				updatedusedtextures = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="726" endline="860">
<![CDATA[
 		
 		public void PerformRedo(int levels)
 		{
 			UndoSnapshot r = null;
 			Cursor oldcursor = Cursor.Current;
 			Cursor.Current = Cursors.WaitCursor;
 			int levelsundone = 0;
 			
 			// Anything to redo?
 			if((redos.Count > 0) || ((snapshot != null) && isundosnapshot))
 			{
 				// Let the plugins know
 				if(General.Plugins.OnRedoBegin())
 				{
 					// Call RedoBegin event
 					if(General.Editing.Mode.OnRedoBegin())
 					{
 						// Cancel volatile mode, if any
 						// This returns false when mode was not volatile
 						if(!General.Editing.CancelVolatileMode())
 						{
 							geometrychanged = false;
 							populationchanged = false;
 							General.Map.Map.ClearAllMarks(false);
 							General.Map.Map.BeginAddRemove();
 							
 							// Go for all levels to redo
 							for(int lvl = 0; lvl < levels; lvl++)
 							{
 								FinishRecording();
 								
 								if(isundosnapshot)
 								{
 									// This snapshot was started by PerformUndo, which means
 									// it can directly be used to redo to previous undo
 									if(snapshot != null)
 										r = snapshot;
 								}
 								else
 								{
 									if(snapshot != null)
 									{
 										// This snapshot was made by a previous call to this
 										// function and should go on the undo list
 										lock(undos)
 										{
 											// The current top of the stack can now be written to disk
 											// because it is no longer the next immediate undo level
 											if(undos.Count > 0) undos[0].StoreOnDisk = true;
 
 											// Put it on the stack
 											undos.Insert(0, snapshot);
 											LimitUndoRedoLevel(undos);
 										}
 									}
 								}
 								
 								// No immediate snapshot to redo? Then get the next one from the stack
 								if(r == null)
 								{
 									lock(redos)
 									{
 										if(redos.Count > 0)
 										{
 											// Get redo snapshot
 											r = redos[0];
 											redos.RemoveAt(0);
 											
 											// Make the current top of the stack load into memory
 											// because it just became the next immediate undo level
 											if(redos.Count > 0) redos[0].StoreOnDisk = false;
 										}
 										else
 										{
 											// Nothing more to redo
 											r = null;
 											break;
 										}
 									}
 								}
 
 								General.WriteLogLine("Performing redo \"" + r.Description + "\", Ticket ID " + r.TicketID + "...");
 
 								if(levels == 1)
 									General.Interface.DisplayStatus(StatusType.Action, r.Description + " redone.");
 
 								StartRecording(r.Description);
 								isundosnapshot = false;
 								
 								// Reset grouping
 								lastgroupplugin = null;
 
 								// Play back the stream in reverse
 								MemoryStream data = r.GetStream();
 								PlaybackStream(data);
 								data.Dispose();
 								
 								// Done with this snapshot
 								r = null;
 								levelsundone++;
 							}
 							for(int lvl = 0; lvl < levels; lvl++)
 							{
 								FinishRecording();
 								
 								if(isundosnapshot)
 								{
 									// This snapshot was started by PerformUndo, which means
 									// it can directly be used to redo to previous undo
 									if(snapshot != null)
 										r = snapshot;
 								}
 								else
 								{
 									if(snapshot != null)
 									{
 										// This snapshot was made by a previous call to this
 										// function and should go on the undo list
 										lock(undos)
 										{
 											// The current top of the stack can now be written to disk
 											// because it is no longer the next immediate undo level
 											if(undos.Count > 0) undos[0].StoreOnDisk = true;
 
 											// Put it on the stack
 											undos.Insert(0, snapshot);
 											LimitUndoRedoLevel(undos);
 										}
 									}
 								}
 								
 								// No immediate snapshot to redo? Then get the next one from the stack
 								if(r == null)
 								{
 									lock(redos)
 									{
 										if(redos.Count > 0)
 										{
 											// Get redo snapshot
 											r = redos[0];
 											redos.RemoveAt(0);
 											
 											// Make the current top of the stack load into memory
 											// because it just became the next immediate undo level
 											if(redos.Count > 0) redos[0].StoreOnDisk = false;
 										}
 										else
 										{
 											// Nothing more to redo
 											r = null;
 											break;
 										}
 									}
 								}
 
 								General.WriteLogLine("Performing redo \"" + r.Description + "\", Ticket ID " + r.TicketID + "...");
 
 								if(levels == 1)
 									General.Interface.DisplayStatus(StatusType.Action, r.Description + " redone.");
 
 								StartRecording(r.Description);
 								isundosnapshot = false;
 								
 								// Reset grouping
 								lastgroupplugin = null;
 
 								// Play back the stream in reverse
 								MemoryStream data = r.GetStream();
 								PlaybackStream(data);
 								data.Dispose();
 								
 								// Done with this snapshot
 								r = null;
 								levelsundone++;
 							}
 							
 							General.Map.Map.EndAddRemove();
 							
 							if(levels > 1)
 								General.Interface.DisplayStatus(StatusType.Action, "Redone " + levelsundone + " changes.");
 							
 							// Remove selection
 							General.Map.Map.ClearAllSelected();
 
 							// Update map
 							General.Map.Map.Update();
 							foreach(Thing t in General.Map.Map.Things) if(t.Marked) t.UpdateConfiguration();
 							General.Map.ThingsFilter.Update();
 							General.Map.Data.UpdateUsedTextures();
 							General.MainWindow.RefreshInfo();
 							General.MainWindow.RedrawDisplay();
 							
 							// Map changed!
 							General.Map.IsChanged = true;
 							
 							// Done
 							General.Editing.Mode.OnRedoEnd();
 							General.Plugins.OnRedoEnd();
 
 							// Update interface
 							dobackgroundwork = true;
 							General.MainWindow.UpdateInterface();
 						}
 					}
 				}
 			}
 			
 			Cursor.Current = oldcursor;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="584" endline="718">
<![CDATA[
 		private void PerformUndo(int levels, bool showmessage)
 		{
 			UndoSnapshot u = null;
 			Cursor oldcursor = Cursor.Current;
 			Cursor.Current = Cursors.WaitCursor;
 			int levelsundone = 0;
 			
 			// Anything to undo?
 			if((undos.Count > 0) || ((snapshot != null) && !isundosnapshot))
 			{
 				// Let the plugins know
 				if(General.Plugins.OnUndoBegin())
 				{
 					// Call UndoBegin event
 					if(General.Editing.Mode.OnUndoBegin())
 					{
 						// Cancel volatile mode, if any
 						// This returns false when mode was not volatile
 						if(!General.Editing.CancelVolatileMode())
 						{
 							geometrychanged = false;
 							populationchanged = false;
 							General.Map.Map.ClearAllMarks(false);
 							General.Map.Map.BeginAddRemove();
 							
 							// Go for all levels to undo
 							for(int lvl = 0; lvl < levels; lvl++)
 							{
 								FinishRecording();
 								
 								if(isundosnapshot)
 								{
 									if(snapshot != null)
 									{
 										// This snapshot was made by a previous call to this
 										// function and should go on the redo list
 										lock(redos)
 										{
 											// The current top of the stack can now be written to disk
 											// because it is no longer the next immediate redo level
 											if(redos.Count > 0) redos[0].StoreOnDisk = true;
 											
 											// Put it on the stack
 											redos.Insert(0, snapshot);
 											LimitUndoRedoLevel(redos);
 										}
 									}
 								}
 								else
 								{
 									// The snapshot can be undone immediately and it will
 									// be recorded for the redo list
 									if(snapshot != null)
 										u = snapshot;
 								}
 								
 								// No immediate snapshot to undo? Then get the next one from the stack
 								if(u == null)
 								{
 									lock(undos)
 									{
 										if(undos.Count > 0)
 										{
 											// Get undo snapshot
 											u = undos[0];
 											undos.RemoveAt(0);
 											
 											// Make the current top of the stack load into memory
 											// because it just became the next immediate undo level
 											if(undos.Count > 0) undos[0].StoreOnDisk = false;
 										}
 										else
 										{
 											// Nothing more to undo
 											u = null;
 											break;
 										}
 									}
 								}
 								
 								General.WriteLogLine("Performing undo \"" + u.Description + "\", Ticket ID " + u.TicketID + "...");
 								
 								if((levels == 1) && showmessage)
 									General.Interface.DisplayStatus(StatusType.Action, u.Description + " undone.");
 								
 								// Make a snapshot for redo
 								StartRecording(u.Description);
 								isundosnapshot = true;
 								
 								// Reset grouping
 								lastgroupplugin = null;
 
 								// Play back the stream in reverse
 								MemoryStream data = u.GetStream();
 								PlaybackStream(data);
 								data.Dispose();
 								
 								// Done with this snapshot
 								u = null;
 								levelsundone++;
 							}
 							for(int lvl = 0; lvl < levels; lvl++)
 							{
 								FinishRecording();
 								
 								if(isundosnapshot)
 								{
 									if(snapshot != null)
 									{
 										// This snapshot was made by a previous call to this
 										// function and should go on the redo list
 										lock(redos)
 										{
 											// The current top of the stack can now be written to disk
 											// because it is no longer the next immediate redo level
 											if(redos.Count > 0) redos[0].StoreOnDisk = true;
 											
 											// Put it on the stack
 											redos.Insert(0, snapshot);
 											LimitUndoRedoLevel(redos);
 										}
 									}
 								}
 								else
 								{
 									// The snapshot can be undone immediately and it will
 									// be recorded for the redo list
 									if(snapshot != null)
 										u = snapshot;
 								}
 								
 								// No immediate snapshot to undo? Then get the next one from the stack
 								if(u == null)
 								{
 									lock(undos)
 									{
 										if(undos.Count > 0)
 										{
 											// Get undo snapshot
 											u = undos[0];
 											undos.RemoveAt(0);
 											
 											// Make the current top of the stack load into memory
 											// because it just became the next immediate undo level
 											if(undos.Count > 0) undos[0].StoreOnDisk = false;
 										}
 										else
 										{
 											// Nothing more to undo
 											u = null;
 											break;
 										}
 									}
 								}
 								
 								General.WriteLogLine("Performing undo \"" + u.Description + "\", Ticket ID " + u.TicketID + "...");
 								
 								if((levels == 1) && showmessage)
 									General.Interface.DisplayStatus(StatusType.Action, u.Description + " undone.");
 								
 								// Make a snapshot for redo
 								StartRecording(u.Description);
 								isundosnapshot = true;
 								
 								// Reset grouping
 								lastgroupplugin = null;
 
 								// Play back the stream in reverse
 								MemoryStream data = u.GetStream();
 								PlaybackStream(data);
 								data.Dispose();
 								
 								// Done with this snapshot
 								u = null;
 								levelsundone++;
 							}
 							
 							General.Map.Map.EndAddRemove();
 							
 							if((levels > 1) && showmessage)
 								General.Interface.DisplayStatus(StatusType.Action, "Undone " + levelsundone + " changes.");
 							
 							// Remove selection
 							General.Map.Map.ClearAllSelected();
 							
 							// Update map
 							General.Map.Map.Update();
 							foreach(Thing t in General.Map.Map.Things) if(t.Marked) t.UpdateConfiguration();
 							General.Map.ThingsFilter.Update();
 							General.Map.Data.UpdateUsedTextures();
 							General.MainWindow.RefreshInfo();
 							General.MainWindow.RedrawDisplay();
 							
 							// Map changed!
 							General.Map.IsChanged = true;
 							
 							// Done
 							General.Editing.Mode.OnUndoEnd();
 							General.Plugins.OnUndoEnd();
 
 							// Update interface
 							dobackgroundwork = true;
 							General.MainWindow.UpdateInterface();
 						}
 					}
 				}
 			}
 			
 			Cursor.Current = oldcursor;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ThingsFilter.cs" startline="278" endline="381">
<![CDATA[
 		
 		/// <summary>
 		/// This updates the list of things.
 		/// </summary>
 		public virtual void Update()
 		{
 			AdjustForMapFormat();
 			
 			// Make new list
 			visiblethings = new List<Thing>(General.Map.Map.Things.Count);
 			hiddenthings = new List<Thing>(General.Map.Map.Things.Count);
 			thingsvisiblestate = new Dictionary<Thing, bool>(General.Map.Map.Things.Count);
 			foreach(Thing t in General.Map.Map.Things)
 			{
 				bool qualifies = true;
 
 				// Get thing info
 				ThingTypeInfo ti = General.Map.Data.GetThingInfo(t.Type);
 				
 				// Check against simple properties
 				qualifies &= (thingtype == -1) || (t.Type == thingtype);
 				qualifies &= (thingangle == -1) || (Angle2D.RealToDoom(t.Angle) == thingangle);
 				qualifies &= (thingzheight == int.MinValue) || ((int)(t.Position.z) == thingzheight);
 				qualifies &= (thingaction == -1) || (t.Action == thingaction);
 				qualifies &= (thingtag == -1) || (t.Tag == thingtag);
 				for(int i = 0; i < Thing.NUM_ARGS; i++)
 					qualifies &= (thingargs[i] == -1) || (t.Args[i] == thingargs[i]);
 				for(int i = 0; i < Thing.NUM_ARGS; i++)
 					qualifies &= (thingargs[i] == -1) || (t.Args[i] == thingargs[i]);
 				
 				// Still qualifies?
 				if(qualifies)
 				{
 					// Check thing category
 					if(ti.Category == null)
 						qualifies = (categoryname.Length == 0);
 					else
 						qualifies = ((ti.Category.Name == categoryname) || (categoryname.Length == 0));
 				}
 				
 				// Still qualifies?
 				if(qualifies)
 				{
 					// Go for all required fields
 					foreach(string s in requiredfields)
 					{
 						if(t.Flags.ContainsKey(s))
 						{
 							if(t.Flags[s] == false)
 							{
 								qualifies = false;
 								break;
 							}
 						}
 						else
 						{
 							qualifies = false;
 							break;
 						}
 					}
 					foreach(string s in requiredfields)
 					{
 						if(t.Flags.ContainsKey(s))
 						{
 							if(t.Flags[s] == false)
 							{
 								qualifies = false;
 								break;
 							}
 						}
 						else
 						{
 							qualifies = false;
 							break;
 						}
 					}
 				}
 
 				// Still qualifies?
 				if(qualifies)
 				{
 					// Go for all forbidden fields
 					foreach(string s in forbiddenfields)
 					{
 						if(t.Flags.ContainsKey(s))
 						{
 							if(t.Flags[s] == true)
 							{
 								qualifies = false;
 								break;
 							}
 						}
 					}
 					foreach(string s in forbiddenfields)
 					{
 						if(t.Flags.ContainsKey(s))
 						{
 							if(t.Flags[s] == true)
 							{
 								qualifies = false;
 								break;
 							}
 						}
 					}
 				}
 				
 				// Still qualifies?
 				if(qualifies)
 				{
 					// Go for all required custom fields
 					foreach(KeyValuePair<string, UniValue> kv in customfields)
 					{
 						if(t.Fields.ContainsKey(kv.Key))
 						{
 							if(!((t.Fields[kv.Key].Type == kv.Value.Type) && (t.Fields[kv.Key].Value.Equals(kv.Value.Value))))
 							{
 								qualifies = false;
 								break;
 							}
 						}
 						else
 						{
 							qualifies = false;
 							break;
 						}
 					}
 					foreach(KeyValuePair<string, UniValue> kv in customfields)
 					{
 						if(t.Fields.ContainsKey(kv.Key))
 						{
 							if(!((t.Fields[kv.Key].Type == kv.Value.Type) && (t.Fields[kv.Key].Value.Equals(kv.Value.Value))))
 							{
 								qualifies = false;
 								break;
 							}
 						}
 						else
 						{
 							qualifies = false;
 							break;
 						}
 					}
 				}
 				
 				// Put the thing in the lists
 				if(qualifies) visiblethings.Add(t); else hiddenthings.Add(t);
 				thingsvisiblestate.Add(t, qualifies);
 			}
 			foreach(Thing t in General.Map.Map.Things)
 			{
 				bool qualifies = true;
 
 				// Get thing info
 				ThingTypeInfo ti = General.Map.Data.GetThingInfo(t.Type);
 				
 				// Check against simple properties
 				qualifies &= (thingtype == -1) || (t.Type == thingtype);
 				qualifies &= (thingangle == -1) || (Angle2D.RealToDoom(t.Angle) == thingangle);
 				qualifies &= (thingzheight == int.MinValue) || ((int)(t.Position.z) == thingzheight);
 				qualifies &= (thingaction == -1) || (t.Action == thingaction);
 				qualifies &= (thingtag == -1) || (t.Tag == thingtag);
 				for(int i = 0; i < Thing.NUM_ARGS; i++)
 					qualifies &= (thingargs[i] == -1) || (t.Args[i] == thingargs[i]);
 				
 				// Still qualifies?
 				if(qualifies)
 				{
 					// Check thing category
 					if(ti.Category == null)
 						qualifies = (categoryname.Length == 0);
 					else
 						qualifies = ((ti.Category.Name == categoryname) || (categoryname.Length == 0));
 				}
 				
 				// Still qualifies?
 				if(qualifies)
 				{
 					// Go for all required fields
 					foreach(string s in requiredfields)
 					{
 						if(t.Flags.ContainsKey(s))
 						{
 							if(t.Flags[s] == false)
 							{
 								qualifies = false;
 								break;
 							}
 						}
 						else
 						{
 							qualifies = false;
 							break;
 						}
 					}
 				}
 
 				// Still qualifies?
 				if(qualifies)
 				{
 					// Go for all forbidden fields
 					foreach(string s in forbiddenfields)
 					{
 						if(t.Flags.ContainsKey(s))
 						{
 							if(t.Flags[s] == true)
 							{
 								qualifies = false;
 								break;
 							}
 						}
 					}
 				}
 				
 				// Still qualifies?
 				if(qualifies)
 				{
 					// Go for all required custom fields
 					foreach(KeyValuePair<string, UniValue> kv in customfields)
 					{
 						if(t.Fields.ContainsKey(kv.Key))
 						{
 							if(!((t.Fields[kv.Key].Type == kv.Value.Type) && (t.Fields[kv.Key].Value.Equals(kv.Value.Value))))
 							{
 								qualifies = false;
 								break;
 							}
 						}
 						else
 						{
 							qualifies = false;
 							break;
 						}
 					}
 				}
 				
 				// Put the thing in the lists
 				if(qualifies) visiblethings.Add(t); else hiddenthings.Add(t);
 				thingsvisiblestate.Add(t, qualifies);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1160" endline="1204">
<![CDATA[
 
 		#endregion
 
 		#region ================== Overlay
 
 		// This renders geometry
 		// The geometry must be a triangle list
 		public void RenderGeometry(FlatVertex[] vertices, ImageData texture, bool transformcoords)
 		{
 			Texture t = null;
 
 			if(vertices.Length > 0)
 			{
 				if(texture != null)
 				{
 					// Make sure the texture is loaded
 					if(!texture.IsImageLoaded) texture.LoadImage();
 					if(texture.Texture == null) texture.CreateTexture();
 					t = texture.Texture;
 				}
 				else
 				{
 					t = General.Map.Data.WhiteTexture.Texture;
 				}
 
 				// Set renderstates for rendering
 				graphics.Device.SetRenderState(RenderState.CullMode, Cull.None);
 				graphics.Device.SetRenderState(RenderState.ZEnable, false);
 				graphics.Device.SetRenderState(RenderState.AlphaBlendEnable, false);
 				graphics.Device.SetRenderState(RenderState.AlphaTestEnable, false);
 				graphics.Device.SetRenderState(RenderState.TextureFactor, -1);
 				graphics.Device.SetRenderState(RenderState.FogEnable, false);
 				graphics.Shaders.Display2D.Texture1 = t;
 				graphics.Device.SetTexture(0, t);
 				SetWorldTransformation(transformcoords);
 				graphics.Shaders.Display2D.SetSettings(1f, 1f, 0f, 1f, General.Settings.ClassicBilinear);
 				
 				// Draw
 				graphics.Shaders.Display2D.Begin();
 				graphics.Shaders.Display2D.BeginPass(1);
 				graphics.Device.DrawUserPrimitives<FlatVertex>(PrimitiveType.TriangleList, 0, vertices.Length / 3, vertices);
 				graphics.Shaders.Display2D.EndPass();
 				graphics.Shaders.Display2D.End();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\SidedefsTracePath.cs" startline="85" endline="106">
<![CDATA[
 		
 		// This makes a polygon from the path
 		public EarClipPolygon MakePolygon()
 		{
 			EarClipPolygon p = new EarClipPolygon();
 			
 			// Any sides at all?
 			if(base.Count > 0)
 			{
 				// Add all sides
 				for(int i = 0; i < base.Count; i++)
 				{
 					// On front or back?
 					if(base[i].IsFront)
 						p.AddLast(new EarClipVertex(base[i].Line.End.Position, base[i]));
 					else
 						p.AddLast(new EarClipVertex(base[i].Line.Start.Position, base[i]));
 				}
 				for(int i = 0; i < base.Count; i++)
 				{
 					// On front or back?
 					if(base[i].IsFront)
 						p.AddLast(new EarClipVertex(base[i].Line.End.Position, base[i]));
 					else
 						p.AddLast(new EarClipVertex(base[i].Line.Start.Position, base[i]));
 				}
 			}
 			
 			return p;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1302" endline="1337">
<![CDATA[
 
 		// This renders a filled rectangle with given color
 		public void RenderRectangleFilled(RectangleF rect, PixelColor c, bool transformrect)
 		{
 			// Calculate positions
 			Vector2D lt = new Vector2D(rect.Left, rect.Top);
 			Vector2D rb = new Vector2D(rect.Right, rect.Bottom);
 			if(transformrect)
 			{
 				lt = lt.GetTransformed(translatex, translatey, scale, -scale);
 				rb = rb.GetTransformed(translatex, translatey, scale, -scale);
 			}
 
 			// Make quad
 			FlatQuad quad = new FlatQuad(PrimitiveType.TriangleStrip, lt.x, lt.y, rb.x, rb.y);
 			quad.SetColors(c.ToInt());
 			
 			// Set renderstates for rendering
 			graphics.Device.SetRenderState(RenderState.CullMode, Cull.None);
 			graphics.Device.SetRenderState(RenderState.ZEnable, false);
 			graphics.Device.SetRenderState(RenderState.AlphaBlendEnable, false);
 			graphics.Device.SetRenderState(RenderState.AlphaTestEnable, false);
 			graphics.Device.SetRenderState(RenderState.TextureFactor, -1);
 			graphics.Device.SetRenderState(RenderState.FogEnable, false);
 			SetWorldTransformation(false);
 			graphics.Device.SetTexture(0, General.Map.Data.WhiteTexture.Texture);
 			graphics.Shaders.Display2D.Texture1 = General.Map.Data.WhiteTexture.Texture;
 			graphics.Shaders.Display2D.SetSettings(1f, 1f, 0f, 1f, General.Settings.ClassicBilinear);
 
 			// Draw
 			graphics.Shaders.Display2D.Begin();
 			graphics.Shaders.Display2D.BeginPass(1);
 			quad.Render(graphics);
 			graphics.Shaders.Display2D.EndPass();
 			graphics.Shaders.Display2D.End();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ImageBrowserControl.Designer.cs" startline="23" endline="154">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			this.splitter = new System.Windows.Forms.SplitContainer();
 			this.list = new CodeImp.DoomBuilder.Controls.OptimizedListView();
 			this.texturesize = new System.Windows.Forms.Label();
 			this.texturesizelabel = new System.Windows.Forms.Label();
 			this.objectname = new System.Windows.Forms.TextBox();
 			this.label = new System.Windows.Forms.Label();
 			this.refreshtimer = new System.Windows.Forms.Timer(this.components);
 			this.texturesizetimer = new System.Windows.Forms.Timer(this.components);
 			this.splitter.Panel1.SuspendLayout();
 			this.splitter.Panel2.SuspendLayout();
 			this.splitter.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// splitter
 			// 
 			this.splitter.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.splitter.FixedPanel = System.Windows.Forms.FixedPanel.Panel2;
 			this.splitter.IsSplitterFixed = true;
 			this.splitter.Location = new System.Drawing.Point(0, 0);
 			this.splitter.Name = "splitter";
 			this.splitter.Orientation = System.Windows.Forms.Orientation.Horizontal;
 			// 
 			// splitter.Panel1
 			// 
 			this.splitter.Panel1.Controls.Add(this.list);
 			// 
 			// splitter.Panel2
 			// 
 			this.splitter.Panel2.Controls.Add(this.texturesize);
 			this.splitter.Panel2.Controls.Add(this.texturesizelabel);
 			this.splitter.Panel2.Controls.Add(this.objectname);
 			this.splitter.Panel2.Controls.Add(this.label);
 			this.splitter.Size = new System.Drawing.Size(518, 346);
 			this.splitter.SplitterDistance = 312;
 			this.splitter.TabIndex = 0;
 			this.splitter.TabStop = false;
 			// 
 			// list
 			// 
 			this.list.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.list.HideSelection = false;
 			this.list.Location = new System.Drawing.Point(0, 0);
 			this.list.MultiSelect = false;
 			this.list.Name = "list";
 			this.list.OwnerDraw = true;
 			this.list.ShowItemToolTips = true;
 			this.list.Size = new System.Drawing.Size(518, 312);
 			this.list.TabIndex = 1;
 			this.list.TabStop = false;
 			this.list.TileSize = new System.Drawing.Size(90, 90);
 			this.list.UseCompatibleStateImageBehavior = false;
 			this.list.View = System.Windows.Forms.View.Tile;
 			this.list.DrawItem += new System.Windows.Forms.DrawListViewItemEventHandler(this.list_DrawItem);
 			this.list.DoubleClick += new System.EventHandler(this.list_DoubleClick);
 			this.list.ItemSelectionChanged += new System.Windows.Forms.ListViewItemSelectionChangedEventHandler(this.list_ItemSelectionChanged);
 			this.list.KeyDown += new System.Windows.Forms.KeyEventHandler(this.list_KeyDown);
 			// 
 			// texturesize
 			// 
 			this.texturesize.Location = new System.Drawing.Point(368, 13);
 			this.texturesize.Name = "texturesize";
 			this.texturesize.Size = new System.Drawing.Size(271, 14);
 			this.texturesize.TabIndex = 2;
 			this.texturesize.Text = "1024 x 1024";
 			this.texturesize.Visible = false;
 			// 
 			// texturesizelabel
 			// 
 			this.texturesizelabel.AutoSize = true;
 			this.texturesizelabel.Location = new System.Drawing.Point(331, 13);
 			this.texturesizelabel.Name = "texturesizelabel";
 			this.texturesizelabel.Size = new System.Drawing.Size(31, 14);
 			this.texturesizelabel.TabIndex = 1;
 			this.texturesizelabel.Text = "Size
 			this.texturesizelabel.Visible = false;
 			// 
 			// objectname
 			// 
 			this.objectname.CharacterCasing = System.Windows.Forms.CharacterCasing.Upper;
 			this.objectname.Location = new System.Drawing.Point(145, 10);
 			this.objectname.Name = "objectname";
 			this.objectname.Size = new System.Drawing.Size(122, 20);
 			this.objectname.TabIndex = 0;
 			this.objectname.TabStop = false;
 			this.objectname.TextChanged += new System.EventHandler(this.objectname_TextChanged);
 			this.objectname.KeyDown += new System.Windows.Forms.KeyEventHandler(this.objectname_KeyDown);
 			// 
 			// label
 			// 
 			this.label.AutoSize = true;
 			this.label.Location = new System.Drawing.Point(1, 13);
 			this.label.Name = "label";
 			this.label.Size = new System.Drawing.Size(138, 14);
 			this.label.TabIndex = 0;
 			this.label.Text = "Select or type object name
 			// 
 			// refreshtimer
 			// 
 			this.refreshtimer.Interval = 500;
 			this.refreshtimer.Tick += new System.EventHandler(this.refreshtimer_Tick);
 			// 
 			// texturesizetimer
 			// 
 			this.texturesizetimer.Interval = 3;
 			this.texturesizetimer.Tick += new System.EventHandler(this.texturesizetimer_Tick);
 			// 
 			// ImageBrowserControl
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.splitter);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.Name = "ImageBrowserControl";
 			this.Size = new System.Drawing.Size(518, 346);
 			this.Resize += new System.EventHandler(this.ImageBrowserControl_Resize);
 			this.splitter.Panel1.ResumeLayout(false);
 			this.splitter.Panel2.ResumeLayout(false);
 			this.splitter.Panel2.PerformLayout();
 			this.splitter.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\SectorEditForm.cs" startline="173" endline="231">
<![CDATA[
 
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			string undodesc = "sector";
 			
 			// Verify the tag
 			if((tag.GetResult(0) < General.Map.FormatInterface.MinTag) || (tag.GetResult(0) > General.Map.FormatInterface.MaxTag))
 			{
 				General.ShowWarningMessage("Sector tag must be between " + General.Map.FormatInterface.MinTag + " and " + General.Map.FormatInterface.MaxTag + ".", MessageBoxButtons.OK);
 				return;
 			}
 
 			// Verify the effect
 			if((effect.Value < General.Map.FormatInterface.MinEffect) || (effect.Value > General.Map.FormatInterface.MaxEffect))
 			{
 				General.ShowWarningMessage("Sector effect must be between " + General.Map.FormatInterface.MinEffect + " and " + General.Map.FormatInterface.MaxEffect + ".", MessageBoxButtons.OK);
 				return;
 			}
 
 			// Verify the brightness
 			if((brightness.GetResult(0) < General.Map.FormatInterface.MinBrightness) || (brightness.GetResult(0) > General.Map.FormatInterface.MaxBrightness))
 			{
 				General.ShowWarningMessage("Sector brightness must be between " + General.Map.FormatInterface.MinBrightness + " and " + General.Map.FormatInterface.MaxBrightness + ".", MessageBoxButtons.OK);
 				return;
 			}
 			
 			// Make undo
 			if(sectors.Count > 1) undodesc = sectors.Count + " sectors";
 			General.Map.UndoRedo.CreateUndo("Edit " + undodesc);
 
 			// Go for all sectors
 			foreach(Sector s in sectors)
 			{
 				// Effects
 				if(!effect.Empty) s.Effect = effect.Value;
 				s.Brightness = General.Clamp(brightness.GetResult(s.Brightness), General.Map.FormatInterface.MinBrightness, General.Map.FormatInterface.MaxBrightness);
 
 				// Floor/Ceiling
 				s.FloorHeight = floorheight.GetResult(s.FloorHeight);
 				s.CeilHeight = ceilingheight.GetResult(s.CeilHeight);
 				s.SetFloorTexture(floortex.GetResult(s.FloorTexture));
 				s.SetCeilTexture(ceilingtex.GetResult(s.CeilTexture));
 
 				// Action
 				s.Tag = General.Clamp(tag.GetResult(s.Tag), General.Map.FormatInterface.MinTag, General.Map.FormatInterface.MaxTag);
 
 				// Custom fields
 				fieldslist.Apply(s.Fields);
 			}
 			foreach(Sector s in sectors)
 			{
 				// Effects
 				if(!effect.Empty) s.Effect = effect.Value;
 				s.Brightness = General.Clamp(brightness.GetResult(s.Brightness), General.Map.FormatInterface.MinBrightness, General.Map.FormatInterface.MaxBrightness);
 
 				// Floor/Ceiling
 				s.FloorHeight = floorheight.GetResult(s.FloorHeight);
 				s.CeilHeight = ceilingheight.GetResult(s.CeilHeight);
 				s.SetFloorTexture(floortex.GetResult(s.FloorTexture));
 				s.SetCeilTexture(ceilingtex.GetResult(s.CeilTexture));
 
 				// Action
 				s.Tag = General.Clamp(tag.GetResult(s.Tag), General.Map.FormatInterface.MinTag, General.Map.FormatInterface.MaxTag);
 
 				// Custom fields
 				fieldslist.Apply(s.Fields);
 			}
 			
 			// Update the used textures
 			General.Map.Data.UpdateUsedTextures();
 			
 			// Done
 			General.Map.IsChanged = true;
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="1564" endline="1658">
<![CDATA[
 
 		#endregion
 
 		#region ================== Texture Alignment
 
 		// This performs texture alignment along all walls that match with the same texture
 		// NOTE
 		// When resetsidemarks is set to true, all sidedefs will first be marked false (not aligned).
 		// Setting resetsidemarks to false is usefull to align only within a specific selection
 		// (set the marked property to true for the sidedefs outside the selection)
 		public static void AutoAlignTextures(Sidedef start, ImageData texture, bool alignx, bool aligny, bool resetsidemarks)
 		{
 			Stack<SidedefAlignJob> todo = new Stack<SidedefAlignJob>(50);
 			float scalex = (General.Map.Config.ScaledTextureOffsets && !texture.WorldPanning) ? texture.Scale.x 
 			float scaley = (General.Map.Config.ScaledTextureOffsets && !texture.WorldPanning) ? texture.Scale.y 
 			
 			// Mark all sidedefs false (they will be marked true when the texture is aligned)
 			if(resetsidemarks) General.Map.Map.ClearMarkedSidedefs(false);
 			
 			// Begin with first sidedef
 			SidedefAlignJob first = new SidedefAlignJob();
 			first.sidedef = start;
 			first.offsetx = start.OffsetX;
 
 			first.forward = true;
 			todo.Push(first);
 			
 			// Continue until nothing more to align
 			while(todo.Count > 0)
 			{
 				// Get the align job to do
 				SidedefAlignJob j = todo.Pop();
 				
 				if(j.forward)
 				{
 					Vertex v;
 					int forwardoffset;
 					int backwardoffset;
 					
 					// Apply alignment
 					if (alignx) j.sidedef.OffsetX = j.offsetx;
 					if (aligny) j.sidedef.OffsetY = (int)Math.Round((start.Sector.CeilHeight - j.sidedef.Sector.CeilHeight) / scaley) + start.OffsetY;
 					forwardoffset = j.offsetx + (int)Math.Round(j.sidedef.Line.Length / scalex);
 					backwardoffset = j.offsetx;
 					
 					j.sidedef.Marked = true;
 					
 					// Wrap the value within the width of the texture (to prevent ridiculous values)
 					// NOTE
 					if (texture.IsImageLoaded)
 					{
 						if (alignx) j.sidedef.OffsetX %= texture.Width;
 						if (aligny) j.sidedef.OffsetY %= texture.Height;
 					}
 					
 					// Add sidedefs forward (connected to the right vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.End 
 					AddSidedefsForAlignment(todo, v, true, forwardoffset, texture.LongName);
 
 					// Add sidedefs backward (connected to the left vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.Start 
 					AddSidedefsForAlignment(todo, v, false, backwardoffset, texture.LongName);
 				}
 				else
 				{
 					Vertex v;
 					int forwardoffset;
 					int backwardoffset;
 
 					// Apply alignment
 					if (alignx) j.sidedef.OffsetX = j.offsetx - (int)Math.Round(j.sidedef.Line.Length / scalex);
 					if (aligny) j.sidedef.OffsetY = (int)Math.Round((start.Sector.CeilHeight - j.sidedef.Sector.CeilHeight) / scaley) + start.OffsetY;
 					forwardoffset = j.offsetx;
 					backwardoffset = j.offsetx - (int)Math.Round(j.sidedef.Line.Length / scalex);
 					
 					j.sidedef.Marked = true;
 
 					// Wrap the value within the width of the texture (to prevent ridiculous values)
 					// NOTE
 					if(texture.IsImageLoaded)
 					{
 						if(alignx) j.sidedef.OffsetX %= texture.Width;
 						if(aligny) j.sidedef.OffsetY %= texture.Height;
 					}
 
 					// Add sidedefs backward (connected to the left vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.Start 
 					AddSidedefsForAlignment(todo, v, false, backwardoffset, texture.LongName);
 
 					// Add sidedefs forward (connected to the right vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.End 
 					AddSidedefsForAlignment(todo, v, true, forwardoffset, texture.LongName);
 				}
 			}
 			while(todo.Count > 0)
 			{
 				// Get the align job to do
 				SidedefAlignJob j = todo.Pop();
 				
 				if(j.forward)
 				{
 					Vertex v;
 					int forwardoffset;
 					int backwardoffset;
 					
 					// Apply alignment
 					if (alignx) j.sidedef.OffsetX = j.offsetx;
 					if (aligny) j.sidedef.OffsetY = (int)Math.Round((start.Sector.CeilHeight - j.sidedef.Sector.CeilHeight) / scaley) + start.OffsetY;
 					forwardoffset = j.offsetx + (int)Math.Round(j.sidedef.Line.Length / scalex);
 					backwardoffset = j.offsetx;
 					
 					j.sidedef.Marked = true;
 					
 					// Wrap the value within the width of the texture (to prevent ridiculous values)
 					// NOTE
 					if (texture.IsImageLoaded)
 					{
 						if (alignx) j.sidedef.OffsetX %= texture.Width;
 						if (aligny) j.sidedef.OffsetY %= texture.Height;
 					}
 					
 					// Add sidedefs forward (connected to the right vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.End 
 					AddSidedefsForAlignment(todo, v, true, forwardoffset, texture.LongName);
 
 					// Add sidedefs backward (connected to the left vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.Start 
 					AddSidedefsForAlignment(todo, v, false, backwardoffset, texture.LongName);
 				}
 				else
 				{
 					Vertex v;
 					int forwardoffset;
 					int backwardoffset;
 
 					// Apply alignment
 					if (alignx) j.sidedef.OffsetX = j.offsetx - (int)Math.Round(j.sidedef.Line.Length / scalex);
 					if (aligny) j.sidedef.OffsetY = (int)Math.Round((start.Sector.CeilHeight - j.sidedef.Sector.CeilHeight) / scaley) + start.OffsetY;
 					forwardoffset = j.offsetx;
 					backwardoffset = j.offsetx - (int)Math.Round(j.sidedef.Line.Length / scalex);
 					
 					j.sidedef.Marked = true;
 
 					// Wrap the value within the width of the texture (to prevent ridiculous values)
 					// NOTE
 					if(texture.IsImageLoaded)
 					{
 						if(alignx) j.sidedef.OffsetX %= texture.Width;
 						if(aligny) j.sidedef.OffsetY %= texture.Height;
 					}
 
 					// Add sidedefs backward (connected to the left vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.Start 
 					AddSidedefsForAlignment(todo, v, false, backwardoffset, texture.LongName);
 
 					// Add sidedefs forward (connected to the right vertex)
 					v = j.sidedef.IsFront ? j.sidedef.Line.End 
 					AddSidedefsForAlignment(todo, v, true, forwardoffset, texture.LongName);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\UndoManager.cs" startline="1127" endline="1141">
<![CDATA[
 
 		internal void PlayRemSidedef(DeserializerStream ds)
 		{
 			int index; ds.rInt(out index);
 			int dindex; ds.rInt(out dindex);
 			bool front; ds.rBool(out front);
 			int sindex; ds.rInt(out sindex);
 			//LogRecordInfo("PLY
 			Linedef l = General.Map.Map.GetLinedefByIndex(dindex);
 			Sector s = General.Map.Map.GetSectorByIndex(sindex);
 			Sidedef sd = General.Map.Map.CreateSidedef(index, l, front, s);
 			sd.ReadWrite(ds);
 			sd.Marked = true;
 			geometrychanged = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="680" endline="756">
<![CDATA[
 
 		/// <summary>
 		/// This disposes orphaned resources and resources on changed geometry.
 		/// This usually happens when geometry is changed by undo, redo, cut or paste actions
 		/// and uses the marks to check what needs to be reloaded.
 		/// </summary>
 		protected virtual void ResourcesReloadedPartial()
 		{
 			Dictionary<Sector, VisualSector> newsectors = new Dictionary<Sector,VisualSector>(allsectors.Count);
 			
 			// Neighbour sectors must be updated as well
 			foreach(Sector s in General.Map.Map.Sectors)
 			{
 				if(s.Marked)
 				{
 					foreach(Sidedef sd in s.Sidedefs)
 						if(sd.Other != null) sd.Other.Marked = true;
 					foreach(Sidedef sd in s.Sidedefs)
 						if(sd.Other != null) sd.Other.Marked = true;
 				}
 			}
 			foreach(Sector s in General.Map.Map.Sectors)
 			{
 				if(s.Marked)
 				{
 					foreach(Sidedef sd in s.Sidedefs)
 						if(sd.Other != null) sd.Other.Marked = true;
 				}
 			}
 			
 			// Go for all sidedefs to mark sectors that need updating
 			foreach(Sidedef sd in General.Map.Map.Sidedefs)
 				if(sd.Marked) sd.Sector.Marked = true;
 			foreach(Sidedef sd in General.Map.Map.Sidedefs)
 				if(sd.Marked) sd.Sector.Marked = true;
 			
 			// Go for all vertices to mark linedefs that need updating
 			foreach(Vertex v in General.Map.Map.Vertices)
 			{
 				if(v.Marked)
 				{
 					foreach(Linedef ld in v.Linedefs)
 						ld.Marked = true;
 					foreach(Linedef ld in v.Linedefs)
 						ld.Marked = true;
 				}
 			}
 			foreach(Vertex v in General.Map.Map.Vertices)
 			{
 				if(v.Marked)
 				{
 					foreach(Linedef ld in v.Linedefs)
 						ld.Marked = true;
 				}
 			}
 			
 			// Go for all linedefs to mark sectors that need updating
 			foreach(Linedef ld in General.Map.Map.Linedefs)
 			{
 				if(ld.Marked)
 				{
 					if(ld.Front != null) ld.Front.Sector.Marked = true;
 					if(ld.Back != null) ld.Back.Sector.Marked = true;
 				}
 			}
 			foreach(Linedef ld in General.Map.Map.Linedefs)
 			{
 				if(ld.Marked)
 				{
 					if(ld.Front != null) ld.Front.Sector.Marked = true;
 					if(ld.Back != null) ld.Back.Sector.Marked = true;
 				}
 			}
 			
 			// Dispose if source was disposed or marked
 			foreach(KeyValuePair<Sector, VisualSector> vs in allsectors)
 			{
 				if(vs.Value != null)
 				{
 					if(vs.Key.IsDisposed || vs.Key.Marked)
 						vs.Value.Dispose();
 					else
 						newsectors.Add(vs.Key, vs.Value);
 				}
 			}
 			foreach(KeyValuePair<Sector, VisualSector> vs in allsectors)
 			{
 				if(vs.Value != null)
 				{
 					if(vs.Key.IsDisposed || vs.Key.Marked)
 						vs.Value.Dispose();
 					else
 						newsectors.Add(vs.Key, vs.Value);
 				}
 			}
 			
 			// Things depend on the sector they are in and because we can't
 			// easily determine which ones changed, we dispose all things
 			foreach(KeyValuePair<Thing, VisualThing> vt in allthings)
 				if(vt.Value != null) vt.Value.Dispose();
 			foreach(KeyValuePair<Thing, VisualThing> vt in allthings)
 				if(vt.Value != null) vt.Value.Dispose();
 			
 			// Apply new lists
 			allsectors = newsectors;
 			allthings = new Dictionary<Thing, VisualThing>(allthings.Count);
 			
 			// Clear visibility collections
 			visiblesectors.Clear();
 			visibleblocks.Clear();
 			visiblegeometry.Clear();
 			visiblethings.Clear();
 			
 			// Make new blockmap
 			FillBlockMap();
 			
 			// Visibility culling (this re-creates the needed resources)
 			DoCulling();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1179" endline="1280">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Things
 		
 		// This loads the things from Decorate
 		private int LoadDecorateThings()
 		{
 			int counter = 0;
 			
 			// Create new parser
 			decorate = new DecorateParser();
 			decorate.OnInclude = LoadDecorateFromLocation;
 			
 			// Only load these when the game configuration supports the use of decorate
 			if(!string.IsNullOrEmpty(General.Map.Config.DecorateGames))
 			{
 				// Go for all opened containers
 				foreach(DataReader dr in containers)
 				{
 					// Load Decorate info cumulatively (the last Decorate is added to the previous)
 					// I'm not sure if this is the right thing to do though.
 					currentreader = dr;
 					List<Stream> decostreams = dr.GetDecorateData("DECORATE");
 					foreach(Stream decodata in decostreams)
 					{
 						// Parse the data
 						decodata.Seek(0, SeekOrigin.Begin);
 						decorate.Parse(decodata, "DECORATE");
 						
 						// Check for errors
 						if(decorate.HasError)
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "Unable to parse DECORATE data from location " +
 								dr.Location.location + ". " + decorate.ErrorDescription + " on line " + decorate.ErrorLine +
 								" in '" + decorate.ErrorSource + "'");
 							break;
 						}
 					}
 					foreach(Stream decodata in decostreams)
 					{
 						// Parse the data
 						decodata.Seek(0, SeekOrigin.Begin);
 						decorate.Parse(decodata, "DECORATE");
 						
 						// Check for errors
 						if(decorate.HasError)
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "Unable to parse DECORATE data from location " +
 								dr.Location.location + ". " + decorate.ErrorDescription + " on line " + decorate.ErrorLine +
 								" in '" + decorate.ErrorSource + "'");
 							break;
 						}
 					}
 				}
 				foreach(DataReader dr in containers)
 				{
 					// Load Decorate info cumulatively (the last Decorate is added to the previous)
 					// I'm not sure if this is the right thing to do though.
 					currentreader = dr;
 					List<Stream> decostreams = dr.GetDecorateData("DECORATE");
 					foreach(Stream decodata in decostreams)
 					{
 						// Parse the data
 						decodata.Seek(0, SeekOrigin.Begin);
 						decorate.Parse(decodata, "DECORATE");
 						
 						// Check for errors
 						if(decorate.HasError)
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "Unable to parse DECORATE data from location " +
 								dr.Location.location + ". " + decorate.ErrorDescription + " on line " + decorate.ErrorLine +
 								" in '" + decorate.ErrorSource + "'");
 							break;
 						}
 					}
 				}
 				
 				currentreader = null;
 				
 				if(!decorate.HasError)
 				{
 					// Go for all actors in the decorate to make things or update things
 					foreach(ActorStructure actor in decorate.Actors)
 					{
 						// Check if we want to add this actor
 						if(actor.DoomEdNum > 0)
 						{
 							string catname = actor.GetPropertyAllValues("$category").ToLowerInvariant();
 							if(string.IsNullOrEmpty(catname.Trim())) catname = "decorate";
 							
 							// Check if we can find this thing in our existing collection
 							if(thingtypes.ContainsKey(actor.DoomEdNum))
 							{
 								// Update the thing
 								thingtypes[actor.DoomEdNum].ModifyByDecorateActor(actor);
 							}
 							else
 							{
 								// Find the category to put the actor in
 								// First search by Title, then search by Name
 								ThingCategory cat = null;
 								foreach(ThingCategory c in thingcategories)
 								{
 									if(c.Title.ToLowerInvariant() == catname) cat = c;
 								}
 								foreach(ThingCategory c in thingcategories)
 								{
 									if(c.Title.ToLowerInvariant() == catname) cat = c;
 								}
 								if(cat == null)
 								{
 									foreach(ThingCategory c in thingcategories)
 									{
 										if(c.Name.ToLowerInvariant() == catname) cat = c;
 									}
 									foreach(ThingCategory c in thingcategories)
 									{
 										if(c.Name.ToLowerInvariant() == catname) cat = c;
 									}
 								}
 								
 								// Make the category if needed
 								if(cat == null)
 								{
 									string catfullname = actor.GetPropertyAllValues("$category");
 									if(string.IsNullOrEmpty(catfullname.Trim())) catfullname = "Decorate";
 									cat = new ThingCategory(catname, catfullname);
 									thingcategories.Add(cat);
 								}
 								
 								// Add new thing
 								ThingTypeInfo t = new ThingTypeInfo(cat, actor);
 								cat.AddThing(t);
 								thingtypes.Add(t.Index, t);
 							}
 							
 							// Count
 							counter++;
 						}
 					}
 					foreach(ActorStructure actor in decorate.Actors)
 					{
 						// Check if we want to add this actor
 						if(actor.DoomEdNum > 0)
 						{
 							string catname = actor.GetPropertyAllValues("$category").ToLowerInvariant();
 							if(string.IsNullOrEmpty(catname.Trim())) catname = "decorate";
 							
 							// Check if we can find this thing in our existing collection
 							if(thingtypes.ContainsKey(actor.DoomEdNum))
 							{
 								// Update the thing
 								thingtypes[actor.DoomEdNum].ModifyByDecorateActor(actor);
 							}
 							else
 							{
 								// Find the category to put the actor in
 								// First search by Title, then search by Name
 								ThingCategory cat = null;
 								foreach(ThingCategory c in thingcategories)
 								{
 									if(c.Title.ToLowerInvariant() == catname) cat = c;
 								}
 								if(cat == null)
 								{
 									foreach(ThingCategory c in thingcategories)
 									{
 										if(c.Name.ToLowerInvariant() == catname) cat = c;
 									}
 								}
 								
 								// Make the category if needed
 								if(cat == null)
 								{
 									string catfullname = actor.GetPropertyAllValues("$category");
 									if(string.IsNullOrEmpty(catfullname.Trim())) catfullname = "Decorate";
 									cat = new ThingCategory(catname, catfullname);
 									thingcategories.Add(cat);
 								}
 								
 								// Add new thing
 								ThingTypeInfo t = new ThingTypeInfo(cat, actor);
 								cat.AddThing(t);
 								thingtypes.Add(t.Index, t);
 							}
 							
 							// Count
 							counter++;
 						}
 					}
 				}
 			}
 			
 			// Output info
 			return counter;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="119" endline="173">
<![CDATA[
 
 		// This reads the THINGS from WAD file
 		private void ReadThings(MapSet map, int firstindex)
 		{
 			MemoryStream mem;
 			BinaryReader reader;
 			int num, i, tag, z, action, x, y, type, flags, angle;
 			int[] args = new int[Thing.NUM_ARGS];
 			Dictionary<string, bool> stringflags;
 			Thing t;
 			
 			// Get the lump from wad file
 			Lump lump = wad.FindLump("THINGS", firstindex);
 			if(lump == null) throw new Exception("Could not find required lump THINGS!");
 			
 			// Prepare to read the items
 			mem = new MemoryStream(lump.Stream.ReadAllBytes());
 			num = (int)lump.Stream.Length / 20;
 			reader = new BinaryReader(mem);
 			
 			// Read items from the lump
 			map.SetCapacity(0, 0, 0, 0, map.Things.Count + num);
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				tag = reader.ReadUInt16();
 				x = reader.ReadInt16();
 				y = reader.ReadInt16();
 				z = reader.ReadInt16();
 				angle = reader.ReadInt16();
 				type = reader.ReadUInt16();
 				flags = reader.ReadUInt16();
 				action = reader.ReadByte();
 				args[0] = reader.ReadByte();
 				args[1] = reader.ReadByte();
 				args[2] = reader.ReadByte();
 				args[3] = reader.ReadByte();
 				args[4] = reader.ReadByte();
 
 				// Make string flags
 				stringflags = new Dictionary<string, bool>();
 				foreach(KeyValuePair<string, string> f in manager.Config.ThingFlags)
 				{
 					int fnum;
 					if(int.TryParse(f.Key, out fnum)) stringflags[f.Key] = ((flags & fnum) == fnum);
 				}
 				foreach(KeyValuePair<string, string> f in manager.Config.ThingFlags)
 				{
 					int fnum;
 					if(int.TryParse(f.Key, out fnum)) stringflags[f.Key] = ((flags & fnum) == fnum);
 				}
 				
 				// Create new item
 				t = map.CreateThing();
 				t.Update(type, x, y, z, angle, stringflags, tag, action, args);
 			}
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				tag = reader.ReadUInt16();
 				x = reader.ReadInt16();
 				y = reader.ReadInt16();
 				z = reader.ReadInt16();
 				angle = reader.ReadInt16();
 				type = reader.ReadUInt16();
 				flags = reader.ReadUInt16();
 				action = reader.ReadByte();
 				args[0] = reader.ReadByte();
 				args[1] = reader.ReadByte();
 				args[2] = reader.ReadByte();
 				args[3] = reader.ReadByte();
 				args[4] = reader.ReadByte();
 
 				// Make string flags
 				stringflags = new Dictionary<string, bool>();
 				foreach(KeyValuePair<string, string> f in manager.Config.ThingFlags)
 				{
 					int fnum;
 					if(int.TryParse(f.Key, out fnum)) stringflags[f.Key] = ((flags & fnum) == fnum);
 				}
 				
 				// Create new item
 				t = map.CreateThing();
 				t.Update(type, x, y, z, angle, stringflags, tag, action, args);
 			}
 
 			// Done
 			mem.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamReader.cs" startline="118" endline="158">
<![CDATA[
 
 		#endregion
 
 		#region ================== Reading
 
 		// This reads from a stream
 		public MapSet Read(MapSet map, Stream stream)
 		{
 			StreamReader reader = new StreamReader(stream, Encoding.ASCII);
 			Dictionary<int, Vertex> vertexlink;
 			Dictionary<int, Sector> sectorlink;
 			UniversalParser textmap = new UniversalParser();
 			textmap.StrictChecking = strictchecking;
 			
 			try
 			{
 				// Read UDMF from stream
 				textmap.InputConfiguration(reader.ReadToEnd());
 
 				// Check for errors
 				if(textmap.ErrorResult != 0)
 				{
 					// Show parse error
 					General.ShowErrorMessage("Error on line " + textmap.ErrorLine + " while parsing UDMF map data
 				}
 				else
 				{
 					// Read the map
 					vertexlink = ReadVertices(map, textmap);
 					sectorlink = ReadSectors(map, textmap);
 					ReadLinedefs(map, textmap, vertexlink, sectorlink);
 					ReadThings(map, textmap);
 				}
 			}
 			catch(Exception e)
 			{
 				General.ShowErrorMessage("Unexpected error reading UDMF map data. " + e.GetType().Name + "
 			}
 
 			return map;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2681" endline="2703">
<![CDATA[
 		
 		/// <summary>This makes a list of lines related to marked vertices.
 		/// A line is unstable when one vertex is marked and the other isn't.</summary>
 		public ICollection<Linedef> LinedefsFromMarkedVertices(bool includeunselected, bool includestable, bool includeunstable)
 		{
 			List<Linedef> list = new List<Linedef>((numlinedefs / 2) + 1);
 			
 			// Go for all lines
 			foreach(Linedef l in linedefs)
 			{
 				// Check if this is to be included
 				if((includestable && (l.Start.Marked && l.End.Marked)) ||
 				   (includeunstable && (l.Start.Marked ^ l.End.Marked)) ||
 				   (includeunselected && (!l.Start.Marked && !l.End.Marked)))
 				{
 					// Add to list
 					list.Add(l);
 				}
 			}
 			foreach(Linedef l in linedefs)
 			{
 				// Check if this is to be included
 				if((includestable && (l.Start.Marked && l.End.Marked)) ||
 				   (includeunstable && (l.Start.Marked ^ l.End.Marked)) ||
 				   (includeunselected && (!l.Start.Marked && !l.End.Marked)))
 				{
 					// Add to list
 					list.Add(l);
 				}
 			}
 
 			// Return result
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\SimpleTextureImage.cs" startline="60" endline="129">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			IImageReader reader;
 			MemoryStream mem;
 			Stream patchdata;
 			byte[] membytes;
 
 			// Checks
 			if(this.IsImageLoaded) return;
 
 			lock(this)
 			{
 				// Get the patch data stream
 				if(bitmap != null) bitmap.Dispose(); bitmap = null;
 				patchdata = General.Map.Data.GetTextureData(lumpname);
 				if(patchdata != null)
 				{
 					// Copy patch data to memory
 					patchdata.Seek(0, SeekOrigin.Begin);
 					membytes = new byte[(int)patchdata.Length];
 					patchdata.Read(membytes, 0, (int)patchdata.Length);
 					mem = new MemoryStream(membytes);
 					mem.Seek(0, SeekOrigin.Begin);
 
 					// Get a reader for the data
 					reader = ImageDataFormat.GetImageReader(mem, ImageDataFormat.DOOMPICTURE, General.Map.Data.Palette);
 					if(!(reader is UnknownImageReader))
 					{
 						// Load the image
 						mem.Seek(0, SeekOrigin.Begin);
 						try { bitmap = reader.ReadAsBitmap(mem); }
 						catch(InvalidDataException)
 						{
 							// Data cannot be read!
 							bitmap = null;
 						}
 					}
 
 					// Not loaded?
 					if(bitmap == null)
 					{
 						General.ErrorLogger.Add(ErrorType.Error, "Image lump '" + lumpname + "' data format could not be read, while loading texture '" + this.Name + "'. Does this lump contain valid picture data at all?");
 						loadfailed = true;
 					}
 					else
 					{
 						// Get width and height from image
 						width = bitmap.Size.Width;
 						height = bitmap.Size.Height;
 					}
 
 					// Done
 					mem.Dispose();
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Error, "Image lump '" + lumpname + "' could not be found, while loading texture '" + this.Name + "'. Did you forget to include required resources?");
 					loadfailed = true;
 				}
 				
 				// Pass on to base
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1048" endline="1065">
<![CDATA[
 		
 		// This returns a specific patch stream
 		internal Stream GetSpriteData(string pname)
 		{
 			if(!string.IsNullOrEmpty(pname))
 			{
 				// Go for all opened containers
 				for(int i = containers.Count - 1; i >= 0; i--)
 				{
 					// This contain provides this patch?
 					Stream spritedata = containers[i].GetSpriteData(pname);
 					if(spritedata != null) return spritedata;
 				}
 				for(int i = containers.Count - 1; i >= 0; i--)
 				{
 					// This contain provides this patch?
 					Stream spritedata = containers[i].GetSpriteData(pname);
 					if(spritedata != null) return spritedata;
 				}
 			}
 			
 			// No such patch found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1713" endline="1734">
<![CDATA[
 
 		/// <summary>This creates an area from vertices.</summary>
 		public static RectangleF CreateArea(ICollection<Vertex> verts)
 		{
 			float l = float.MaxValue;
 			float t = float.MaxValue;
 			float r = float.MinValue;
 			float b = float.MinValue;
 
 			// Go for all vertices
 			foreach(Vertex v in verts)
 			{
 				// Adjust boundaries by vertices
 				if(v.Position.x < l) l = v.Position.x;
 				if(v.Position.x > r) r = v.Position.x;
 				if(v.Position.y < t) t = v.Position.y;
 				if(v.Position.y > b) b = v.Position.y;
 			}
 			foreach(Vertex v in verts)
 			{
 				// Adjust boundaries by vertices
 				if(v.Position.x < l) l = v.Position.x;
 				if(v.Position.x > r) r = v.Position.x;
 				if(v.Position.y < t) t = v.Position.y;
 				if(v.Position.y > b) b = v.Position.y;
 			}
 
 			// Return a rect
 			return new RectangleF(l, t, r - l, b - t);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="175" endline="200">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Palette
 
 		// This loads the PLAYPAL palette
 		public override Playpal LoadPalette()
 		{
 			Lump lump;
 			
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 			
 			// Look for a lump named PLAYPAL
 			lump = file.FindLump("PLAYPAL");
 			if(lump != null)
 			{
 				// Read the PLAYPAL from stream
 				return new Playpal(lump.Stream);
 			}
 			else
 			{
 				// No palette
 				return null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="508" endline="529">
<![CDATA[
 
 		// This returns the patch names from the PNAMES lump
 		public override PatchNames LoadPatchNames()
 		{
 			Lump lump;
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Look for a lump named PNAMES
 			lump = file.FindLump("PNAMES");
 			if(lump != null)
 			{
 				// Read the PNAMES from stream
 				return new PatchNames(lump.Stream);
 			}
 			else
 			{
 				// No palette
 				return null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="322" endline="372">
<![CDATA[
 
 		// This unbinds all methods marked with this attribute
 		private void UnbindMethods(object obj, Type type)
 		{
 			MethodInfo[] methods;
 			ActionAttribute[] attrs;
 			ActionDelegate del;
 			string actionname;
 
 			if(obj == null)
 				General.WriteLogLine("Unbinding static action methods for class " + type.Name + "...");
 			else
 				General.WriteLogLine("Unbinding action methods for " + type.Name + " object...");
 
 			// Go for all methods on obj
 			methods = type.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
 			foreach(MethodInfo m in methods)
 			{
 				// Check if the method has this attribute
 				attrs = (ActionAttribute[])m.GetCustomAttributes(typeof(BeginActionAttribute), true);
 
 				// Go for all attributes
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Unbind method from action
 					actions[actionname].UnbindBegin(del);
 				}
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Unbind method from action
 					actions[actionname].UnbindBegin(del);
 				}
 				
 				// Check if the method has this attribute
 				attrs = (ActionAttribute[])m.GetCustomAttributes(typeof(EndActionAttribute), true);
 
 				// Go for all attributes
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Unbind method from action
 					actions[actionname].UnbindEnd(del);
 				}
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Unbind method from action
 					actions[actionname].UnbindEnd(del);
 				}
 			}
 			foreach(MethodInfo m in methods)
 			{
 				// Check if the method has this attribute
 				attrs = (ActionAttribute[])m.GetCustomAttributes(typeof(BeginActionAttribute), true);
 
 				// Go for all attributes
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Unbind method from action
 					actions[actionname].UnbindBegin(del);
 				}
 				
 				// Check if the method has this attribute
 				attrs = (ActionAttribute[])m.GetCustomAttributes(typeof(EndActionAttribute), true);
 
 				// Go for all attributes
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Unbind method from action
 					actions[actionname].UnbindEnd(del);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2568" endline="2590">
<![CDATA[
 
 		/// <summary>This returns the next unused tag number within the marked geometry.</summary>
 		public List<int> GetMultipleNewTags(int count, bool marked)
 		{
 			List<int> newtags = new List<int>(count);
 			if(count > 0)
 			{
 				Dictionary<int, bool> usedtags = new Dictionary<int, bool>();
 				ForAllTags(NewTagHandler, marked, usedtags);
 
 				// Find unused tags and add them
 				for(int i = 1; i <= General.Map.FormatInterface.MaxTag; i++)
 				{
 					if(!usedtags.ContainsKey(i))
 					{
 						newtags.Add(i);
 						if(newtags.Count == count) break;
 					}
 				}
 				for(int i = 1; i <= General.Map.FormatInterface.MaxTag; i++)
 				{
 					if(!usedtags.ContainsKey(i))
 					{
 						newtags.Add(i);
 						if(newtags.Count == count) break;
 					}
 				}
 			}
 			
 			return newtags;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1594" endline="1618">
<![CDATA[
 		
 		// This updates the seperators
 		// Hides redundant seperators and shows single seperators
 		private void UpdateToolStripSeparators(ToolStripItemCollection items, bool defaultvisible)
 		{
 			ToolStripItem pvi = null;
 			foreach(ToolStripItem i in items)
 			{
 				bool separatorvisible = false;
 				
 				// This is a seperator?
 				if(i is ToolStripSeparator)
 				{
 					// Make visible when previous item was not a seperator
 					separatorvisible = !(pvi is ToolStripSeparator) && (pvi != null);
 					i.Visible = separatorvisible;
 				}
 				
 				// Keep as previous visible item
 				if(i.Visible || separatorvisible || (defaultvisible && !(i is ToolStripSeparator))) pvi = i;
 			}
 			foreach(ToolStripItem i in items)
 			{
 				bool separatorvisible = false;
 				
 				// This is a seperator?
 				if(i is ToolStripSeparator)
 				{
 					// Make visible when previous item was not a seperator
 					separatorvisible = !(pvi is ToolStripSeparator) && (pvi != null);
 					i.Visible = separatorvisible;
 				}
 				
 				// Keep as previous visible item
 				if(i.Visible || separatorvisible || (defaultvisible && !(i is ToolStripSeparator))) pvi = i;
 			}
 			
 			// Hide last item if it is a seperator
 			if(pvi is ToolStripSeparator) pvi.Visible = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\TransparentPanel.cs" startline="43" endline="56">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 		
 		// Override this property
 		protected override CreateParams CreateParams
 		{
 			get
 			{
 				CreateParams cp = base.CreateParams;
 				cp.ExStyle |= 0x20;
 				return cp;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2311" endline="2343">
<![CDATA[
 
 		/// <summary>This finds the side closest to the specified position.</summary>
 		public static Sidedef NearestSidedef(ICollection<Sidedef> selection, Vector2D pos)
 		{
 			Sidedef closest = null;
 			float distance = float.MaxValue;
 			
 			// Go for all sidedefs in selection
 			foreach(Sidedef sd in selection)
 			{
 				// Calculate distance and check if closer than previous find
 				float d = sd.Line.SafeDistanceToSq(pos, true);
 				if(d == distance)
 				{
 					// Same distance, so only pick the one that is on the right side of the line
 					float side = sd.Line.SideOfLine(pos);
 					if(((side <= 0.0f) && sd.IsFront) || ((side > 0.0f) && !sd.IsFront))
 					{
 						closest = sd;
 						distance = d;
 					}
 				}
 				else if(d < distance)
 				{
 					// This one is closer
 					closest = sd;
 					distance = d;
 				}
 			}
 			foreach(Sidedef sd in selection)
 			{
 				// Calculate distance and check if closer than previous find
 				float d = sd.Line.SafeDistanceToSq(pos, true);
 				if(d == distance)
 				{
 					// Same distance, so only pick the one that is on the right side of the line
 					float side = sd.Line.SideOfLine(pos);
 					if(((side <= 0.0f) && sd.IsFront) || ((side > 0.0f) && !sd.IsFront))
 					{
 						closest = sd;
 						distance = d;
 					}
 				}
 				else if(d < distance)
 				{
 					// This one is closer
 					closest = sd;
 					distance = d;
 				}
 			}
 			
 			// Return result
 			return closest;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1991" endline="2015">
<![CDATA[
 
 		/// <summary>This removes unused sectors and returns the number of removed sectors.</summary>
 		public int RemoveUnusedSectors(bool reportwarnings)
 		{
 			int count = 0;
 			int index = numsectors - 1;
 			
 			// Go for all sectors
 			while(index >= 0)
 			{
 				// Remove when unused
 				if(sectors[index].Sidedefs.Count == 0)
 				{
 					if(reportwarnings)
 						General.ErrorLogger.Add(ErrorType.Warning, "Sector " + index + " was unused and has been removed.");
 
 					sectors[index].Dispose();
 					count++;
 				}
 
 				index--;
 			}
 			while(index >= 0)
 			{
 				// Remove when unused
 				if(sectors[index].Sidedefs.Count == 0)
 				{
 					if(reportwarnings)
 						General.ErrorLogger.Add(ErrorType.Warning, "Sector " + index + " was unused and has been removed.");
 
 					sectors[index].Dispose();
 					count++;
 				}
 
 				index--;
 			}
 			
 			return count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="393" endline="445">
<![CDATA[
 
 		// This loads all script configurations
 		private static void LoadAllScriptConfigurations()
 		{
 			Configuration cfg;
 			string[] filenames;
 			
 			// Display status
 			mainwindow.DisplayStatus(StatusType.Busy, "Loading script configurations...");
 			
 			// Make collection
 			scriptconfigs = new Dictionary<string, ScriptConfiguration>();
 			
 			// Go for all cfg files in the scripts directory
 			filenames = Directory.GetFiles(scriptspath, "*.cfg", SearchOption.TopDirectoryOnly);
 			foreach(string filepath in filenames)
 			{
 				try
 				{
 					// Try loading the configuration
 					cfg = new Configuration(filepath, true);
 					
 					// Check for erors
 					if(cfg.ErrorResult)
 					{
 						// Error in configuration
 						errorlogger.Add(ErrorType.Error, "Unable to load the script configuration file \"" + Path.GetFileName(filepath) + "\". " +
 														"Error in file \"" + cfg.ErrorFile + "\" near line " + cfg.ErrorLine + "
 					}
 					else
 					{
 						try
 						{
 							// Make script configuration
 							ScriptConfiguration scfg = new ScriptConfiguration(cfg);
 							string filename = Path.GetFileName(filepath);
 							scriptconfigs.Add(filename.ToLowerInvariant(), scfg);
 						}
 						catch(Exception e)
 						{
 							// Unable to load configuration
 							errorlogger.Add(ErrorType.Error, "Unable to load the script configuration \"" + Path.GetFileName(filepath) + "\". Error
 						}
 					}
 				}
 				catch(Exception e)
 				{
 					// Unable to load configuration
 					errorlogger.Add(ErrorType.Error, "Unable to load the script configuration file \"" + Path.GetFileName(filepath) + "\". Error
 					General.WriteLogLine(e.StackTrace);
 				}
 			}
 			foreach(string filepath in filenames)
 			{
 				try
 				{
 					// Try loading the configuration
 					cfg = new Configuration(filepath, true);
 					
 					// Check for erors
 					if(cfg.ErrorResult)
 					{
 						// Error in configuration
 						errorlogger.Add(ErrorType.Error, "Unable to load the script configuration file \"" + Path.GetFileName(filepath) + "\". " +
 														"Error in file \"" + cfg.ErrorFile + "\" near line " + cfg.ErrorLine + "
 					}
 					else
 					{
 						try
 						{
 							// Make script configuration
 							ScriptConfiguration scfg = new ScriptConfiguration(cfg);
 							string filename = Path.GetFileName(filepath);
 							scriptconfigs.Add(filename.ToLowerInvariant(), scfg);
 						}
 						catch(Exception e)
 						{
 							// Unable to load configuration
 							errorlogger.Add(ErrorType.Error, "Unable to load the script configuration \"" + Path.GetFileName(filepath) + "\". Error
 						}
 					}
 				}
 				catch(Exception e)
 				{
 					// Unable to load configuration
 					errorlogger.Add(ErrorType.Error, "Unable to load the script configuration file \"" + Path.GetFileName(filepath) + "\". Error
 					General.WriteLogLine(e.StackTrace);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CopyPasteManager.cs" startline="522" endline="587">
<![CDATA[
 		
 		// This pastes the previously inserted prefab
 		[BeginAction("insertpreviousprefab")]
 		public void InsertPreviousPrefab()
 		{
 			// Check if possible to copy/paste
 			if(General.Editing.Mode.Attributes.AllowCopyPaste)
 			{
 				PasteOptions options = General.Settings.PasteOptions.Copy();
 
 				// Is there a previously inserted prefab?
 				if(IsPreviousPrefabAvailable)
 				{
 					// Does the file still exist?
 					if(File.Exists(lastprefabfile))
 					{
 						// Cancel volatile mode
 						General.Editing.DisengageVolatileMode();
 
 						// Let the plugins know
 						if(General.Plugins.OnPasteBegin(options))
 						{
 							// Ask the editing mode to prepare selection for pasting.
 							if(General.Editing.Mode.OnPasteBegin(options))
 							{
 								Cursor oldcursor = Cursor.Current;
 								FileStream stream = null;
 
 								try
 								{
 									Cursor.Current = Cursors.WaitCursor;
 									stream = File.OpenRead(lastprefabfile);
 								}
 								catch(Exception e)
 								{
 									Cursor.Current = oldcursor;
 									General.ErrorLogger.Add(ErrorType.Error, e.GetType().Name + " while reading prefab from file
 									General.WriteLogLine(e.StackTrace);
 									General.ShowErrorMessage("Error while reading prefab from file! See log file for error details.", MessageBoxButtons.OK);
 								}
 
 								if(stream != null) PastePrefab(stream, options);
 								stream.Dispose();
 								General.MainWindow.UpdateInterface();
 								Cursor.Current = oldcursor;
 							}
 						}
 					}
 					else
 					{
 						General.MessageBeep(MessageBeepType.Warning);
 						lastprefabfile = null;
 						General.MainWindow.UpdateInterface();
 					}
 				}
 				else
 				{
 					General.MessageBeep(MessageBeepType.Warning);
 				}
 			}
 			else
 			{
 				// Insert not allowed
 				General.MessageBeep(MessageBeepType.Warning);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\CopyPasteManager.cs" startline="256" endline="340">
<![CDATA[
 		
 		// This performs the paste. Returns false when paste was cancelled.
 		private bool DoPasteSelection(PasteOptions options)
 		{
 			// Check if possible to copy/paste
 			if(General.Editing.Mode.Attributes.AllowCopyPaste)
 			{
 				// Anything to paste?
 				if(Clipboard.ContainsData(CLIPBOARD_DATA_FORMAT))
 				{
 					// Cancel volatile mode
 					General.Editing.DisengageVolatileMode();
 					
 					// Let the plugins know
 					if(General.Plugins.OnPasteBegin(options))
 					{
 						// Ask the editing mode to prepare selection for pasting.
 						if(General.Editing.Mode.OnPasteBegin(options.Copy()))
 						{
 							// Create undo
 							General.MainWindow.DisplayStatus(StatusType.Action, "Pasted selected elements.");
 							General.Map.UndoRedo.CreateUndo("Paste");
 							
 							// Read from clipboard
 							Stream memstream = (Stream)Clipboard.GetData(CLIPBOARD_DATA_FORMAT);
 							memstream.Seek(0, SeekOrigin.Begin);
 
 							// Mark all current geometry
 							General.Map.Map.ClearAllMarks(true);
 
 							// Read data stream
 							UniversalStreamReader reader = new UniversalStreamReader();
 							reader.StrictChecking = false;
 							General.Map.Map.BeginAddRemove();
 							reader.Read(General.Map.Map, memstream);
 							General.Map.Map.EndAddRemove();
 							
 							// The new geometry is not marked, so invert the marks to get it marked
 							General.Map.Map.InvertAllMarks();
 
 							// Convert UDMF fields back to flags and activations, if needed
 							if(!(General.Map.FormatInterface is UniversalMapSetIO)) General.Map.Map.TranslateFromUDMF();
 							
 							// Modify tags and actions if preferred
 							if(options.ChangeTags == PasteOptions.TAGS_REMOVE) Tools.RemoveMarkedTags();
 							if(options.ChangeTags == PasteOptions.TAGS_RENUMBER) Tools.RenumberMarkedTags();
 							if(options.RemoveActions) Tools.RemoveMarkedActions();
 
 							// Clean up
 							memstream.Dispose();
 
 							// Check if anything was pasted
 							int totalpasted = General.Map.Map.GetMarkedThings(true).Count;
 							totalpasted += General.Map.Map.GetMarkedVertices(true).Count;
 							totalpasted += General.Map.Map.GetMarkedLinedefs(true).Count;
 							totalpasted += General.Map.Map.GetMarkedSidedefs(true).Count;
 							totalpasted += General.Map.Map.GetMarkedSectors(true).Count;
 							if(totalpasted > 0)
 							{
 								General.Map.Map.UpdateConfiguration();
 								General.Map.ThingsFilter.Update();
 								General.Editing.Mode.OnPasteEnd(options.Copy());
 								General.Plugins.OnPasteEnd(options);
 							}
 							return true;
 						}
 					}
 					
 					// Aborted
 					return false;
 				}
 				else
 				{
 					// Nothing usefull on the clipboard
 					General.MessageBeep(MessageBeepType.Warning);
 					return false;
 				}
 			}
 			else
 			{
 				// Paste not allowed
 				General.MessageBeep(MessageBeepType.Warning);
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="413" endline="468">
<![CDATA[
 
 		// Auto map loading that must be done when the window is first shown after loading
 		// but also before the window is shown when the -delaywindow parameter is given
 		internal void PerformAutoMapLoading()
 		{
 			// Check if the command line arguments tell us to load something
 			if(General.AutoLoadFile != null)
 			{
 				bool showdialog = false;
 				MapOptions options = new MapOptions();
 				Configuration mapsettings;
 				
 				// Any of the options already given?
 				if(General.AutoLoadMap != null)
 				{
 					// Try to find existing options in the settings file
 					string dbsfile = General.AutoLoadFile.Substring(0, General.AutoLoadFile.Length - 4) + ".dbs";
 					if(File.Exists(dbsfile))
 						try { mapsettings = new Configuration(dbsfile, true); }
 						catch(Exception) { mapsettings = new Configuration(true); }
 					else
 						mapsettings = new Configuration(true);
 
 					// Set map name and other options
 					options = new MapOptions(mapsettings, General.AutoLoadMap);
 
 					// Set resource data locations
 					options.CopyResources(General.AutoLoadResources);
 
 					// Set strict patches
 					options.StrictPatches = General.AutoLoadStrictPatches;
 					
 					// Set configuration file (constructor already does this, but we want this info from the cmd args if possible)
 					options.ConfigFile = General.AutoLoadConfig;
 					if(options.ConfigFile == null) options.ConfigFile = mapsettings.ReadSetting("gameconfig", "");
 					if(options.ConfigFile.Trim().Length == 0) showdialog = true;
 				}
 				else
 				{
 					// No options given
 					showdialog = true;
 				}
 
 				// Show open map dialog?
 				if(showdialog)
 				{
 					// Show open dialog
 					General.OpenMapFile(General.AutoLoadFile, options);
 				}
 				else
 				{
 					// Open with options
 					General.OpenMapFileWithOptions(General.AutoLoadFile, options);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ZDTextParser.cs" startline="296" endline="322">
<![CDATA[
 		
 		// This reports an error
 		protected internal void ReportError(string message)
 		{
 			long position = datastream.Position;
 			long readpos = 0;
 			int linenumber = 1;
 			
 			// Find the line on which we found this error
 			datastream.Seek(0, SeekOrigin.Begin);
 			StreamReader textreader = new StreamReader(datastream, Encoding.ASCII);
 			while(readpos < position)
 			{
 				string line = textreader.ReadLine();
 				if(line == null) break;
 				readpos += line.Length + 2;
 				linenumber++;
 			}
 			while(readpos < position)
 			{
 				string line = textreader.ReadLine();
 				if(line == null) break;
 				readpos += line.Length + 2;
 				linenumber++;
 			}
 			
 			// Return to original position
 			datastream.Seek(position, SeekOrigin.Begin);
 			
 			// Set error information
 			errordesc = message;
 			errorline = linenumber;
 			errorsource = sourcename;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="411" endline="428">
<![CDATA[
 
 
 		// This returns the word at the given position
 		public string GetWordAt(int position)
 		{
 			int wordstart = scriptedit.WordStartPosition(position, true);
 			int wordend = scriptedit.WordEndPosition(position, true);
 
 			// Decode the text
 			byte[] scripttextdata = scriptedit.GetText(scriptedit.TextSize);
 			Encoding encoder = Encoding.GetEncoding(scriptedit.CodePage);
 			string scripttext = encoder.GetString(scripttextdata);
 
 			if(wordstart < wordend)
 				return scripttext.Substring(wordstart, wordend - wordstart);
 			else
 				return "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2544" endline="2567">
<![CDATA[
 
 		/// <summary>This returns the next unused tag number.</summary>
 		public List<int> GetMultipleNewTags(int count)
 		{
 			List<int> newtags = new List<int>(count);
 			if(count > 0)
 			{
 				Dictionary<int, bool> usedtags = new Dictionary<int, bool>();
 				ForAllTags(NewTagHandler, false, usedtags);
 				ForAllTags(NewTagHandler, true, usedtags);
 				
 				// Find unused tags and add them
 				for(int i = 1; i <= General.Map.FormatInterface.MaxTag; i++)
 				{
 					if(!usedtags.ContainsKey(i))
 					{
 						newtags.Add(i);
 						if(newtags.Count == count) break;
 					}
 				}
 				for(int i = 1; i <= General.Map.FormatInterface.MaxTag; i++)
 				{
 					if(!usedtags.ContainsKey(i))
 					{
 						newtags.Add(i);
 						if(newtags.Count == count) break;
 					}
 				}
 			}
 			
 			return newtags;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="331" endline="349">
<![CDATA[
 
 		/// <summary>
 		/// This returns the height of the upper wall part. Returns 0 when no upper part exists.
 		/// </summary>
 		public int GetHighHeight()
 		{
 			Sidedef other = this.Other;
 			if(other != null)
 			{
 				int top = this.sector.CeilHeight;
 				int bottom = other.sector.CeilHeight;
 				int height = top - bottom;
 				return (height > 0) ? height 
 			}
 			else
 			{
 				return 0;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="372" endline="390">
<![CDATA[
 
 		/// <summary>
 		/// This returns the height of the lower wall part. Returns 0 when no lower part exists.
 		/// </summary>
 		public int GetLowHeight()
 		{
 			Sidedef other = this.Other;
 			if(other != null)
 			{
 				int top = other.sector.FloorHeight;
 				int bottom = this.sector.FloorHeight;
 				int height = top - bottom;
 				return (height > 0) ? height 
 			}
 			else
 			{
 				return 0;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\CheckboxArrayControl.cs" startline="73" endline="117">
<![CDATA[
 
 		// This positions the checkboxes
 		public void PositionCheckboxes()
 		{
 			int boxheight = 0;
 			int columnlength;
 			int columnwidth;
 			int row = 0;
 			int col = 0;
 			
 			// Checks
 			if(columns < 1) return;
 			if(checkboxes.Count < 1) return;
 			
 			// Calculate column width
 			columnwidth = this.ClientSize.Width / columns;
 			
 			// Check what the biggest checkbox height is
 			foreach(CheckBox c in checkboxes) if(c.Height > boxheight) boxheight = c.Height;
 
 			// Check what the preferred column length is
 			columnlength = 1 + (int)Math.Floor((float)(this.ClientSize.Height - boxheight) / (float)(boxheight + SPACING_Y));
 			
 			// When not all items fit with the preferred column length
 			// we have to extend the column length to make it fit
 			if((int)Math.Ceiling((float)checkboxes.Count / (float)columnlength) > columns)
 			{
 				// Make a column length which works for all items
 				columnlength = (int)Math.Ceiling((float)checkboxes.Count / (float)columns);
 			}
 
 			// Go for all items
 			foreach(CheckBox c in checkboxes)
 			{
 				// Position checkbox
 				c.Location = new Point(col * columnwidth, row * boxheight + (row - 1) * SPACING_Y + SPACING_Y);
 
 				// Next position
 				if(++row == columnlength)
 				{
 					row = 0;
 					col++;
 				}
 			}
 			foreach(CheckBox c in checkboxes)
 			{
 				// Position checkbox
 				c.Location = new Point(col * columnwidth, row * boxheight + (row - 1) * SPACING_Y + SPACING_Y);
 
 				// Next position
 				if(++row == columnlength)
 				{
 					row = 0;
 					col++;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sector.cs" startline="421" endline="444">
<![CDATA[
 		
 		// This creates a bounding box rectangle
 		// This requires the sector triangulation to be up-to-date!
 		private RectangleF CreateBBox()
 		{
 			// Setup
 			float left = float.MaxValue;
 			float top = float.MaxValue;
 			float right = float.MinValue;
 			float bottom = float.MinValue;
 			
 			// Go for vertices
 			foreach(Vector2D v in triangles.Vertices)
 			{
 				// Update rect
 				if(v.x < left) left = v.x;
 				if(v.y < top) top = v.y;
 				if(v.x > right) right = v.x;
 				if(v.y > bottom) bottom = v.y;
 			}
 			foreach(Vector2D v in triangles.Vertices)
 			{
 				// Update rect
 				if(v.x < left) left = v.x;
 				if(v.y < top) top = v.y;
 				if(v.x > right) right = v.x;
 				if(v.y > bottom) bottom = v.y;
 			}
 			
 			// Return rectangle
 			return new RectangleF(left, top, right - left, bottom - top);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptFindReplaceForm.cs" startline="82" endline="94">
<![CDATA[
 
 		#endregion
 
 		#region ================== Events
 
 		// Form is closing
 		private void ScriptFindReplaceForm_FormClosing(object sender, FormClosingEventArgs e)
 		{
 			if(!appclose)
 			{
 				General.Map.ScriptEditor.Editor.CloseFindReplace(true);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="154" endline="259">
<![CDATA[
 
 		// This finds the inner lines of the sector and adds them to the sector polygon
 		private static void FindInnerLines(EarClipPolygon p, List<LinedefSide> alllines)
 		{
 			Vertex foundv;
 			bool vvalid, findmore;
 			Linedef foundline;
 			float foundangle = 0f;
 			bool foundlinefront;
 			RectangleF bbox = p.CreateBBox();
 			
 			do
 			{
 				findmore = false;
 
 				// Go for all vertices to find the right-most vertex inside the polygon
 				foundv = null;
 				foreach(Vertex v in General.Map.Map.Vertices)
 				{
 					// Inside the polygon bounding box?
 					if((v.Position.x >= bbox.Left) && (v.Position.x <= bbox.Right) &&
 					   (v.Position.y >= bbox.Top) && (v.Position.y <= bbox.Bottom))
 					{
 						// More to the right?
 						if((foundv == null) || (v.Position.x >= foundv.Position.x))
 						{
 							// Vertex is inside the polygon?
 							if(p.Intersect(v.Position))
 							{
 								// Vertex has lines attached?
 								if(v.Linedefs.Count > 0)
 								{
 									// Go for all lines to see if the vertex is not of the polygon itsself
 									vvalid = true;
 									foreach(LinedefSide ls in alllines)
 									{
 										if((ls.Line.Start == v) || (ls.Line.End == v))
 										{
 											vvalid = false;
 											break;
 										}
 									}
 									foreach(LinedefSide ls in alllines)
 									{
 										if((ls.Line.Start == v) || (ls.Line.End == v))
 										{
 											vvalid = false;
 											break;
 										}
 									}
 
 									// Valid vertex?
 									if(vvalid) foundv = v;
 								}
 							}
 						}
 					}
 				}
 				foreach(Vertex v in General.Map.Map.Vertices)
 				{
 					// Inside the polygon bounding box?
 					if((v.Position.x >= bbox.Left) && (v.Position.x <= bbox.Right) &&
 					   (v.Position.y >= bbox.Top) && (v.Position.y <= bbox.Bottom))
 					{
 						// More to the right?
 						if((foundv == null) || (v.Position.x >= foundv.Position.x))
 						{
 							// Vertex is inside the polygon?
 							if(p.Intersect(v.Position))
 							{
 								// Vertex has lines attached?
 								if(v.Linedefs.Count > 0)
 								{
 									// Go for all lines to see if the vertex is not of the polygon itsself
 									vvalid = true;
 									foreach(LinedefSide ls in alllines)
 									{
 										if((ls.Line.Start == v) || (ls.Line.End == v))
 										{
 											vvalid = false;
 											break;
 										}
 									}
 
 									// Valid vertex?
 									if(vvalid) foundv = v;
 								}
 							}
 						}
 					}
 				}
 
 				// Found a vertex inside the polygon?
 				if(foundv != null)
 				{
 					// Find the attached linedef with the smallest angle to the right
 					float targetangle = Angle2D.PIHALF;
 					foundline = null;
 					foreach(Linedef l in foundv.Linedefs)
 					{
 						// We need an angle unrelated to line direction, so correct for that
 						float lineangle = l.Angle;
 						if(l.End == foundv) lineangle += Angle2D.PI;
 
 						// Better result?
 						float deltaangle = Angle2D.Difference(targetangle, lineangle);
 						if((foundline == null) || (deltaangle < foundangle))
 						{
 							foundline = l;
 							foundangle = deltaangle;
 						}
 					}
 					foreach(Linedef l in foundv.Linedefs)
 					{
 						// We need an angle unrelated to line direction, so correct for that
 						float lineangle = l.Angle;
 						if(l.End == foundv) lineangle += Angle2D.PI;
 
 						// Better result?
 						float deltaangle = Angle2D.Difference(targetangle, lineangle);
 						if((foundline == null) || (deltaangle < foundangle))
 						{
 							foundline = l;
 							foundangle = deltaangle;
 						}
 					}
 
 					// We already know that each linedef will go from this vertex
 					// to the left, because this is the right-most vertex in this area.
 					// If the line would go to the right, that means the other vertex of
 					// that line must lie outside this area and the mapper made an error.
 					// Should I check for this error and fail to create a sector in
 					// that case or ignore it and create a malformed sector (possibly
 					// breaking another sector also)?
 
 					// Find the side at which to start pathfinding
 					Vector2D testpos = new Vector2D(100.0f, 0.0f);
 					foundlinefront = (foundline.SideOfLine(foundv.Position + testpos) < 0.0f);
 
 					// Find inner path
 					List<LinedefSide> innerlines = FindClosestPath(foundline, foundlinefront, true);
 					if(innerlines != null)
 					{
 						// Make polygon
 						LinedefTracePath tracepath = new LinedefTracePath(innerlines);
 						EarClipPolygon innerpoly = tracepath.MakePolygon(true);
 
 						// Check if the front of the line is outside the polygon
 						if(!innerpoly.Intersect(foundline.GetSidePoint(foundlinefront)))
 						{
 							// Valid hole found!
 							alllines.AddRange(innerlines);
 							p.InsertChild(innerpoly);
 							findmore = true;
 						}
 					}
 				}
 			}
 			// Continue until no more holes found
 			while(findmore);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamWriter.cs" startline="175" endline="218">
<![CDATA[
 
 		// This adds linedefs
 		private void WriteLinedefs(ICollection<Linedef> linedefs, UniversalParser textmap, IDictionary<Sidedef, int> sidedefids, IDictionary<Vertex, int> vertexids)
 		{
 			// Go for all linedefs
 			foreach(Linedef l in linedefs)
 			{
 				// Make collection
 				UniversalCollection coll = new UniversalCollection();
 				if(l.Tag != 0) coll.Add("id", l.Tag);
 				coll.Add("v1", vertexids[l.Start]);
 				coll.Add("v2", vertexids[l.End]);
 				coll.Comment = l.Index.ToString();
 				
 				// Sidedef references
 				if((l.Front != null) && sidedefids.ContainsKey(l.Front))
 					coll.Add("sidefront", sidedefids[l.Front]);
 				else
 					coll.Add("sidefront", -1);
 				
 				if((l.Back != null) && sidedefids.ContainsKey(l.Back))
 					coll.Add("sideback", sidedefids[l.Back]);
 				else
 					coll.Add("sideback", -1);
 				
 				// Special
 				if(l.Action != 0) coll.Add("special", l.Action);
 				if(l.Args[0] != 0) coll.Add("arg0", l.Args[0]);
 				if(l.Args[1] != 0) coll.Add("arg1", l.Args[1]);
 				if(l.Args[2] != 0) coll.Add("arg2", l.Args[2]);
 				if(l.Args[3] != 0) coll.Add("arg3", l.Args[3]);
 				if(l.Args[4] != 0) coll.Add("arg4", l.Args[4]);
 
 				// Flags
 				foreach(KeyValuePair<string, bool> flag in l.Flags)
 					if(flag.Value) coll.Add(flag.Key, flag.Value);
 				foreach(KeyValuePair<string, bool> flag in l.Flags)
 					if(flag.Value) coll.Add(flag.Key, flag.Value);
 
 				// Add custom fields
 				AddCustomFields(l, "linedef", coll);
 
 				// Store
 				textmap.Root.Add("linedef", coll);
 			}
 			foreach(Linedef l in linedefs)
 			{
 				// Make collection
 				UniversalCollection coll = new UniversalCollection();
 				if(l.Tag != 0) coll.Add("id", l.Tag);
 				coll.Add("v1", vertexids[l.Start]);
 				coll.Add("v2", vertexids[l.End]);
 				coll.Comment = l.Index.ToString();
 				
 				// Sidedef references
 				if((l.Front != null) && sidedefids.ContainsKey(l.Front))
 					coll.Add("sidefront", sidedefids[l.Front]);
 				else
 					coll.Add("sidefront", -1);
 				
 				if((l.Back != null) && sidedefids.ContainsKey(l.Back))
 					coll.Add("sideback", sidedefids[l.Back]);
 				else
 					coll.Add("sideback", -1);
 				
 				// Special
 				if(l.Action != 0) coll.Add("special", l.Action);
 				if(l.Args[0] != 0) coll.Add("arg0", l.Args[0]);
 				if(l.Args[1] != 0) coll.Add("arg1", l.Args[1]);
 				if(l.Args[2] != 0) coll.Add("arg2", l.Args[2]);
 				if(l.Args[3] != 0) coll.Add("arg3", l.Args[3]);
 				if(l.Args[4] != 0) coll.Add("arg4", l.Args[4]);
 
 				// Flags
 				foreach(KeyValuePair<string, bool> flag in l.Flags)
 					if(flag.Value) coll.Add(flag.Key, flag.Value);
 
 				// Add custom fields
 				AddCustomFields(l, "linedef", coll);
 
 				// Store
 				textmap.Root.Add("linedef", coll);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="328" endline="397">
<![CDATA[
 		
 		/// <summary>
 		/// This makes a deep copy and returns the new MapSet.
 		/// </summary>
 		public MapSet Clone()
 		{
 			Linedef nl;
 			Sidedef nd;
 			
 			// Create the map set
 			MapSet newset = new MapSet();
 			newset.BeginAddRemove();
 			newset.SetCapacity(numvertices, numlinedefs, numsidedefs, numsectors, numthings);
 			
 			// Go for all vertices
 			foreach(Vertex v in vertices)
 			{
 				// Make new vertex
 				v.Clone = newset.CreateVertex(v.Position);
 				v.CopyPropertiesTo(v.Clone);
 			}
 			foreach(Vertex v in vertices)
 			{
 				// Make new vertex
 				v.Clone = newset.CreateVertex(v.Position);
 				v.CopyPropertiesTo(v.Clone);
 			}
 
 			// Go for all sectors
 			foreach(Sector s in sectors)
 			{
 				// Make new sector
 				s.Clone = newset.CreateSector();
 				s.CopyPropertiesTo(s.Clone);
 			}
 			foreach(Sector s in sectors)
 			{
 				// Make new sector
 				s.Clone = newset.CreateSector();
 				s.CopyPropertiesTo(s.Clone);
 			}
 
 			// Go for all linedefs
 			foreach(Linedef l in linedefs)
 			{
 				// Make new linedef
 				nl = newset.CreateLinedef(l.Start.Clone, l.End.Clone);
 				l.CopyPropertiesTo(nl);
 
 				// Linedef has a front side?
 				if(l.Front != null)
 				{
 					// Make new sidedef
 					nd = newset.CreateSidedef(nl, true, l.Front.Sector.Clone);
 					l.Front.CopyPropertiesTo(nd);
 				}
 
 				// Linedef has a back side?
 				if(l.Back != null)
 				{
 					// Make new sidedef
 					nd = newset.CreateSidedef(nl, false, l.Back.Sector.Clone);
 					l.Back.CopyPropertiesTo(nd);
 				}
 			}
 			foreach(Linedef l in linedefs)
 			{
 				// Make new linedef
 				nl = newset.CreateLinedef(l.Start.Clone, l.End.Clone);
 				l.CopyPropertiesTo(nl);
 
 				// Linedef has a front side?
 				if(l.Front != null)
 				{
 					// Make new sidedef
 					nd = newset.CreateSidedef(nl, true, l.Front.Sector.Clone);
 					l.Front.CopyPropertiesTo(nd);
 				}
 
 				// Linedef has a back side?
 				if(l.Back != null)
 				{
 					// Make new sidedef
 					nd = newset.CreateSidedef(nl, false, l.Back.Sector.Clone);
 					l.Back.CopyPropertiesTo(nd);
 				}
 			}
 			
 			// Go for all things
 			foreach(Thing t in things)
 			{
 				// Make new thing
 				Thing nt = newset.CreateThing();
 				t.CopyPropertiesTo(nt);
 			}
 			foreach(Thing t in things)
 			{
 				// Make new thing
 				Thing nt = newset.CreateThing();
 				t.CopyPropertiesTo(nt);
 			}
 			
 			// Remove clone references
 			foreach(Vertex v in vertices) v.Clone = null;
 			foreach(Sector s in sectors) s.Clone = null;
 			
 			// Return the new set
 			newset.EndAddRemove();
 			return newset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\UnknownImage.cs" startline="69" endline="78">
<![CDATA[
 
 		// This returns a preview image
 		public override Image GetPreview()
 		{
 			lock(this)
 			{
 				// Make a copy
 				return new Bitmap(loadbitmap);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="208" endline="258">
<![CDATA[
 
 		// This reads the SECTORS from WAD file
 		// Returns a lookup table with indices
 		private Dictionary<int, Sector> ReadSectors(MapSet map, int firstindex)
 		{
 			MemoryStream mem;
 			Dictionary<int, Sector> link;
 			BinaryReader reader;
 			int num, i, hfloor, hceil, bright, special, tag;
 			string tfloor, tceil;
 			Sector s;
 
 			// Get the lump from wad file
 			Lump lump = wad.FindLump("SECTORS", firstindex);
 			if(lump == null) throw new Exception("Could not find required lump SECTORS!");
 
 			// Prepare to read the items
 			mem = new MemoryStream(lump.Stream.ReadAllBytes());
 			num = (int)lump.Stream.Length / 26;
 			reader = new BinaryReader(mem);
 
 			// Create lookup table
 			link = new Dictionary<int, Sector>(num);
 
 			// Read items from the lump
 			map.SetCapacity(0, 0, 0, map.Sectors.Count + num, 0);
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				hfloor = reader.ReadInt16();
 				hceil = reader.ReadInt16();
 				tfloor = Lump.MakeNormalName(reader.ReadBytes(8), WAD.ENCODING);
 				tceil = Lump.MakeNormalName(reader.ReadBytes(8), WAD.ENCODING);
 				bright = reader.ReadInt16();
 				special = reader.ReadUInt16();
 				tag = reader.ReadUInt16();
 				
 				// Create new item
 				s = map.CreateSector();
 				s.Update(hfloor, hceil, tfloor, tceil, special, tag, bright);
 
 				// Add it to the lookup table
 				link.Add(i, s);
 			}
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				hfloor = reader.ReadInt16();
 				hceil = reader.ReadInt16();
 				tfloor = Lump.MakeNormalName(reader.ReadBytes(8), WAD.ENCODING);
 				tceil = Lump.MakeNormalName(reader.ReadBytes(8), WAD.ENCODING);
 				bright = reader.ReadInt16();
 				special = reader.ReadUInt16();
 				tag = reader.ReadUInt16();
 				
 				// Create new item
 				s = map.CreateSector();
 				s.Update(hfloor, hceil, tfloor, tceil, special, tag, bright);
 
 				// Add it to the lookup table
 				link.Add(i, s);
 			}
 
 			// Done
 			mem.Dispose();
 
 			// Return lookup table
 			return link;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="218" endline="268">
<![CDATA[
 
 		// This reads the SECTORS from WAD file
 		// Returns a lookup table with indices
 		private Dictionary<int, Sector> ReadSectors(MapSet map, int firstindex)
 		{
 			MemoryStream mem;
 			Dictionary<int, Sector> link;
 			BinaryReader reader;
 			int num, i, hfloor, hceil, bright, special, tag;
 			string tfloor, tceil;
 			Sector s;
 
 			// Get the lump from wad file
 			Lump lump = wad.FindLump("SECTORS", firstindex);
 			if(lump == null) throw new Exception("Could not find required lump SECTORS!");
 
 			// Prepare to read the items
 			mem = new MemoryStream(lump.Stream.ReadAllBytes());
 			num = (int)lump.Stream.Length / 26;
 			reader = new BinaryReader(mem);
 
 			// Create lookup table
 			link = new Dictionary<int, Sector>(num);
 
 			// Read items from the lump
 			map.SetCapacity(0, 0, 0, map.Sectors.Count + num, 0);
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				hfloor = reader.ReadInt16();
 				hceil = reader.ReadInt16();
 				tfloor = Lump.MakeNormalName(reader.ReadBytes(8), WAD.ENCODING);
 				tceil = Lump.MakeNormalName(reader.ReadBytes(8), WAD.ENCODING);
 				bright = reader.ReadInt16();
 				special = reader.ReadUInt16();
 				tag = reader.ReadUInt16();
 				
 				// Create new item
 				s = map.CreateSector();
 				s.Update(hfloor, hceil, tfloor, tceil, special, tag, bright);
 
 				// Add it to the lookup table
 				link.Add(i, s);
 			}
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				hfloor = reader.ReadInt16();
 				hceil = reader.ReadInt16();
 				tfloor = Lump.MakeNormalName(reader.ReadBytes(8), WAD.ENCODING);
 				tceil = Lump.MakeNormalName(reader.ReadBytes(8), WAD.ENCODING);
 				bright = reader.ReadInt16();
 				special = reader.ReadUInt16();
 				tag = reader.ReadUInt16();
 				
 				// Create new item
 				s = map.CreateSector();
 				s.Update(hfloor, hceil, tfloor, tceil, special, tag, bright);
 
 				// Add it to the lookup table
 				link.Add(i, s);
 			}
 
 			// Done
 			mem.Dispose();
 
 			// Return lookup table
 			return link;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\PatchStructure.cs" startline="60" endline="157">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal PatchStructure(TexturesParser parser)
 		{
 			string tokenstr;
 			
 			// Initialize
 			alpha = 1.0f;
 			
 			// There should be 3 tokens separated by 2 commas now
 			// Name, Width, Height
 
 			// First token is the class name
 			parser.SkipWhitespace(true);
 			name = parser.StripTokenQuotes(parser.ReadToken());
 			if(string.IsNullOrEmpty(name))
 			{
 				parser.ReportError("Expected patch name");
 				return;
 			}
 
 			// Now we should find a comma
 			parser.SkipWhitespace(true);
 			tokenstr = parser.ReadToken();
 			if(tokenstr != ",")
 			{
 				parser.ReportError("Expected a comma");
 				return;
 			}
 
 			// Next is the patch width
 			parser.SkipWhitespace(true);
 			tokenstr = parser.ReadToken();
 			if(string.IsNullOrEmpty(tokenstr) || !int.TryParse(tokenstr, NumberStyles.Integer, CultureInfo.InvariantCulture, out offsetx))
 			{
 				parser.ReportError("Expected offset in pixels");
 				return;
 			}
 
 			// Now we should find a comma again
 			parser.SkipWhitespace(true);
 			tokenstr = parser.ReadToken();
 			if(tokenstr != ",")
 			{
 				parser.ReportError("Expected a comma");
 				return;
 			}
 
 			// Next is the patch height
 			parser.SkipWhitespace(true);
 			tokenstr = parser.ReadToken();
 			if(string.IsNullOrEmpty(tokenstr) || !int.TryParse(tokenstr, NumberStyles.Integer, CultureInfo.InvariantCulture, out offsety))
 			{
 				parser.ReportError("Expected offset in pixels");
 				return;
 			}
 
 			// Next token is the beginning of the texture scope.
 			// If not, then the patch info ends here.
 			parser.SkipWhitespace(true);
 			tokenstr = parser.ReadToken();
 			if(tokenstr != "{")
 			{
 				// Rewind so this structure can be read again
 				parser.DataStream.Seek(-tokenstr.Length - 1, SeekOrigin.Current);
 				return;
 			}
 
 			// Now parse the contents of texture structure
 			while(parser.SkipWhitespace(true))
 			{
 				string token = parser.ReadToken();
 				token = token.ToLowerInvariant();
 				if(token == "flipx")
 				{
 					flipx = true;
 				}
 				else if(token == "flipy")
 				{
 					flipy = true;
 				}
 				else if(token == "alpha")
 				{
 					if(!ReadTokenFloat(parser, token, out alpha)) return;
 					alpha = General.Clamp(alpha, 0.0f, 1.0f);
 				}
 				else if(token == "}")
 				{
 					// Patch scope ends here,
 					// break out of this parse loop
 					break;
 				}
 			}
 			while(parser.SkipWhitespace(true))
 			{
 				string token = parser.ReadToken();
 				token = token.ToLowerInvariant();
 				if(token == "flipx")
 				{
 					flipx = true;
 				}
 				else if(token == "flipy")
 				{
 					flipy = true;
 				}
 				else if(token == "alpha")
 				{
 					if(!ReadTokenFloat(parser, token, out alpha)) return;
 					alpha = General.Clamp(alpha, 0.0f, 1.0f);
 				}
 				else if(token == "}")
 				{
 					// Patch scope ends here,
 					// break out of this parse loop
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2016" endline="2121">
<![CDATA[
 
 		/// <summary>This joins overlapping lines together. Returns false when the operation failed.</summary>
 		public static bool JoinOverlappingLines(ICollection<Linedef> lines)
 		{
 			bool joined;
 			
 			do
 			{
 				// No joins yet
 				joined = false;
 
 				// Go for all the lines
 				foreach(Linedef l1 in lines)
 				{
 					// Check if these vertices have lines that overlap
 					foreach(Linedef l2 in l1.Start.Linedefs)
 					{
 						// Sharing vertices?
 						if((l1.End == l2.End) ||
 						   (l1.End == l2.Start))
 						{
 							// Not the same line?
 							if(l1 != l2)
 							{
 								bool oppositedirection = (l1.End == l2.Start);
 								bool l2marked = l2.Marked;
 								
 								// Merge these two linedefs
 								while(lines.Remove(l2)) ;
 								if(!l2.Join(l1)) return false;
 								
 								// If l2 was marked as new geometry, we have to make sure
 								// that l1's FrontInterior is correct for the drawing procedure
 								if(l2marked)
 								{
 									l1.FrontInterior = l2.FrontInterior ^ oppositedirection;
 								}
 								// If l1 is marked as new geometry, we may need to flip it to preserve
 								// orientation of the original geometry, and update its FrontInterior
 								else if(l1.Marked)
 								{
 									if(oppositedirection)
 									{
 										l1.FlipVertices();		// This also flips FrontInterior
 										l1.FlipSidedefs();
 									}
 								}
 								
 								joined = true;
 								break;
 							}
 						}
 					}
 					foreach(Linedef l2 in l1.Start.Linedefs)
 					{
 						// Sharing vertices?
 						if((l1.End == l2.End) ||
 						   (l1.End == l2.Start))
 						{
 							// Not the same line?
 							if(l1 != l2)
 							{
 								bool oppositedirection = (l1.End == l2.Start);
 								bool l2marked = l2.Marked;
 								
 								// Merge these two linedefs
 								while(lines.Remove(l2)) ;
 								if(!l2.Join(l1)) return false;
 								
 								// If l2 was marked as new geometry, we have to make sure
 								// that l1's FrontInterior is correct for the drawing procedure
 								if(l2marked)
 								{
 									l1.FrontInterior = l2.FrontInterior ^ oppositedirection;
 								}
 								// If l1 is marked as new geometry, we may need to flip it to preserve
 								// orientation of the original geometry, and update its FrontInterior
 								else if(l1.Marked)
 								{
 									if(oppositedirection)
 									{
 										l1.FlipVertices();		// This also flips FrontInterior
 										l1.FlipSidedefs();
 									}
 								}
 								
 								joined = true;
 								break;
 							}
 						}
 					}
 					
 					// Will have to restart when joined
 					if(joined) break;
 					
 					// Check if these vertices have lines that overlap
 					foreach(Linedef l2 in l1.End.Linedefs)
 					{
 						// Sharing vertices?
 						if((l1.Start == l2.End) ||
 						   (l1.Start == l2.Start))
 						{
 							// Not the same line?
 							if(l1 != l2)
 							{
 								bool oppositedirection = (l1.Start == l2.End);
 								bool l2marked = l2.Marked;
 								
 								// Merge these two linedefs
 								while(lines.Remove(l2)) ;
 								if(!l2.Join(l1)) return false;
 
 								// If l2 was marked as new geometry, we have to make sure
 								// that l1's FrontInterior is correct for the drawing procedure
 								if(l2marked)
 								{
 									l1.FrontInterior = l2.FrontInterior ^ oppositedirection;
 								}
 								// If l1 is marked as new geometry, we may need to flip it to preserve
 								// orientation of the original geometry, and update its FrontInterior
 								else if(l1.Marked)
 								{
 									if(oppositedirection)
 									{
 										l1.FlipVertices();		// This also flips FrontInterior
 										l1.FlipSidedefs();
 									}
 								}
 
 								joined = true;
 								break;
 							}
 						}
 					}
 					foreach(Linedef l2 in l1.End.Linedefs)
 					{
 						// Sharing vertices?
 						if((l1.Start == l2.End) ||
 						   (l1.Start == l2.Start))
 						{
 							// Not the same line?
 							if(l1 != l2)
 							{
 								bool oppositedirection = (l1.Start == l2.End);
 								bool l2marked = l2.Marked;
 								
 								// Merge these two linedefs
 								while(lines.Remove(l2)) ;
 								if(!l2.Join(l1)) return false;
 
 								// If l2 was marked as new geometry, we have to make sure
 								// that l1's FrontInterior is correct for the drawing procedure
 								if(l2marked)
 								{
 									l1.FrontInterior = l2.FrontInterior ^ oppositedirection;
 								}
 								// If l1 is marked as new geometry, we may need to flip it to preserve
 								// orientation of the original geometry, and update its FrontInterior
 								else if(l1.Marked)
 								{
 									if(oppositedirection)
 									{
 										l1.FlipVertices();		// This also flips FrontInterior
 										l1.FlipSidedefs();
 									}
 								}
 
 								joined = true;
 								break;
 							}
 						}
 					}
 					
 					// Will have to restart when joined
 					if(joined) break;
 				}
 				foreach(Linedef l1 in lines)
 				{
 					// Check if these vertices have lines that overlap
 					foreach(Linedef l2 in l1.Start.Linedefs)
 					{
 						// Sharing vertices?
 						if((l1.End == l2.End) ||
 						   (l1.End == l2.Start))
 						{
 							// Not the same line?
 							if(l1 != l2)
 							{
 								bool oppositedirection = (l1.End == l2.Start);
 								bool l2marked = l2.Marked;
 								
 								// Merge these two linedefs
 								while(lines.Remove(l2)) ;
 								if(!l2.Join(l1)) return false;
 								
 								// If l2 was marked as new geometry, we have to make sure
 								// that l1's FrontInterior is correct for the drawing procedure
 								if(l2marked)
 								{
 									l1.FrontInterior = l2.FrontInterior ^ oppositedirection;
 								}
 								// If l1 is marked as new geometry, we may need to flip it to preserve
 								// orientation of the original geometry, and update its FrontInterior
 								else if(l1.Marked)
 								{
 									if(oppositedirection)
 									{
 										l1.FlipVertices();		// This also flips FrontInterior
 										l1.FlipSidedefs();
 									}
 								}
 								
 								joined = true;
 								break;
 							}
 						}
 					}
 					
 					// Will have to restart when joined
 					if(joined) break;
 					
 					// Check if these vertices have lines that overlap
 					foreach(Linedef l2 in l1.End.Linedefs)
 					{
 						// Sharing vertices?
 						if((l1.Start == l2.End) ||
 						   (l1.Start == l2.Start))
 						{
 							// Not the same line?
 							if(l1 != l2)
 							{
 								bool oppositedirection = (l1.Start == l2.End);
 								bool l2marked = l2.Marked;
 								
 								// Merge these two linedefs
 								while(lines.Remove(l2)) ;
 								if(!l2.Join(l1)) return false;
 
 								// If l2 was marked as new geometry, we have to make sure
 								// that l1's FrontInterior is correct for the drawing procedure
 								if(l2marked)
 								{
 									l1.FrontInterior = l2.FrontInterior ^ oppositedirection;
 								}
 								// If l1 is marked as new geometry, we may need to flip it to preserve
 								// orientation of the original geometry, and update its FrontInterior
 								else if(l1.Marked)
 								{
 									if(oppositedirection)
 									{
 										l1.FlipVertices();		// This also flips FrontInterior
 										l1.FlipSidedefs();
 									}
 								}
 
 								joined = true;
 								break;
 							}
 						}
 					}
 					
 					// Will have to restart when joined
 					if(joined) break;
 				}
 			}
 			while(joined);
 
 			// Return result
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="213" endline="267">
<![CDATA[
 		
 		// Replace all
 		public void ReplaceAll(FindReplaceOptions options)
 		{
 			int replacements = 0;
 			findoptions = options;
 			if(!string.IsNullOrEmpty(findoptions.FindText) && (options.ReplaceWith != null) && (ActiveTab != null))
 			{
 				int firstfindpos = -1;
 				int lastpos = -1;
 				bool firstreplace = true;
 				bool wrappedaround = false;
 				int selectionstart = Math.Min(ActiveTab.SelectionStart, ActiveTab.SelectionEnd);
 				
 				// Continue finding and replacing until nothing more found
 				while(ActiveTab.FindNext(findoptions))
 				{
 					int curpos = Math.Min(ActiveTab.SelectionStart, ActiveTab.SelectionEnd);
 					if(curpos <= lastpos)
 						wrappedaround = true;
 					
 					if(firstreplace)
 					{
 						// Remember where we started replacing
 						firstfindpos = curpos;
 					}
 					else if(wrappedaround)
 					{
 						// Make sure we don't go past our start point, or we could be in an endless loop
 						if(curpos >= firstfindpos)
 							break;
 					}
 					
 					Replace(findoptions);
 					replacements++;
 					firstreplace = false;
 
 					lastpos = curpos;
 				}
 				while(ActiveTab.FindNext(findoptions))
 				{
 					int curpos = Math.Min(ActiveTab.SelectionStart, ActiveTab.SelectionEnd);
 					if(curpos <= lastpos)
 						wrappedaround = true;
 					
 					if(firstreplace)
 					{
 						// Remember where we started replacing
 						firstfindpos = curpos;
 					}
 					else if(wrappedaround)
 					{
 						// Make sure we don't go past our start point, or we could be in an endless loop
 						if(curpos >= firstfindpos)
 							break;
 					}
 					
 					Replace(findoptions);
 					replacements++;
 					firstreplace = false;
 
 					lastpos = curpos;
 				}
 
 				// Restore selection
 				ActiveTab.SelectionStart = selectionstart;
 				ActiveTab.SelectionEnd = selectionstart;
 				
 				// Show result
 				if(replacements == 0)
 					General.MainWindow.DisplayStatus(StatusType.Warning, "Can't find any occurence of \"" + findoptions.FindText + "\".");
 				else
 					General.MainWindow.DisplayStatus(StatusType.Info, "Replaced " + replacements + " occurences of \"" + findoptions.FindText + "\" with \"" + findoptions.ReplaceWith + "\".");
 			}
 			else
 			{
 				General.MessageBeep(MessageBeepType.Default);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="381" endline="417">
<![CDATA[
 
 		#endregion
 
 		#region ================== Decorate
 
 		// This finds and returns a sprite stream
 		public override List<Stream> GetDecorateData(string pname)
 		{
 			List<Stream> streams = new List<Stream>();
 			string[] allfilenames;
 			
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 			
 			// Find in root directory
 			string filename = Path.GetFileName(pname);
 			string pathname = Path.GetDirectoryName(pname);
 			
 			if(filename.IndexOf('.') > -1)
 			{
 				allfilenames = new string[1];
 				allfilenames[0] = Path.Combine(pathname, filename);
 			}
 			else
 				allfilenames = GetAllFilesWithTitle(pathname, filename, false);
 
 			foreach(string foundfile in allfilenames)
 			{
 				streams.Add(LoadFile(foundfile));
 			}
 			foreach(string foundfile in allfilenames)
 			{
 				streams.Add(LoadFile(foundfile));
 			}
 			
 			// Find in any of the wad files
 			for(int i = wads.Count - 1; i >= 0; i--)
 				streams.AddRange(wads[i].GetDecorateData(pname));
 			for(int i = wads.Count - 1; i >= 0; i--)
 				streams.AddRange(wads[i].GetDecorateData(pname));
 			
 			return streams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2781" endline="2880">
<![CDATA[
 		
 		// This performs sidedefs compression
 		// Note
 		internal void CompressSidedefs()
 		{
 			Dictionary<uint, List<Sidedef>> storedsides = new Dictionary<uint, List<Sidedef>>(numsidedefs);
 			int originalsidescount = numsidedefs;
 			double starttime = General.Clock.GetCurrentTime();
 
 			BeginAddRemove();
 			
 			int sn = 0;
 			while(sn < numsidedefs)
 			{
 				Sidedef stored = null;
 				Sidedef snsd = sidedefs[sn];
 
 				// Check if checksum is stored
 				bool samesidedef = false;
 				uint checksum = snsd.GetChecksum();
 				bool checksumstored = storedsides.ContainsKey(checksum);
 				if(checksumstored)
 				{
 					List<Sidedef> othersides = storedsides[checksum];
 					foreach(Sidedef os in othersides)
 					{
 						// They must be in the same sector
 						if (snsd.Sector == os.Sector)
 						{
 							// Check if sidedefs are really the same
 							stored = os;
 							MemoryStream sidemem = new MemoryStream(1024);
 							SerializerStream sidedata = new SerializerStream(sidemem);
 							MemoryStream othermem = new MemoryStream(1024);
 							SerializerStream otherdata = new SerializerStream(othermem);
 							snsd.ReadWrite(sidedata);
 							os.ReadWrite(otherdata);
 							if (sidemem.Length == othermem.Length)
 							{
 								samesidedef = true;
 								sidemem.Seek(0, SeekOrigin.Begin);
 								othermem.Seek(0, SeekOrigin.Begin);
 								for (int i = 0; i < sidemem.Length; i++)
 								{
 									if (sidemem.ReadByte() != othermem.ReadByte())
 									{
 										samesidedef = false;
 										break;
 									}
 								}
 								for (int i = 0; i < sidemem.Length; i++)
 								{
 									if (sidemem.ReadByte() != othermem.ReadByte())
 									{
 										samesidedef = false;
 										break;
 									}
 								}
 							}
 
 							if (samesidedef) break;
 						}
 					}
 					foreach(Sidedef os in othersides)
 					{
 						// They must be in the same sector
 						if (snsd.Sector == os.Sector)
 						{
 							// Check if sidedefs are really the same
 							stored = os;
 							MemoryStream sidemem = new MemoryStream(1024);
 							SerializerStream sidedata = new SerializerStream(sidemem);
 							MemoryStream othermem = new MemoryStream(1024);
 							SerializerStream otherdata = new SerializerStream(othermem);
 							snsd.ReadWrite(sidedata);
 							os.ReadWrite(otherdata);
 							if (sidemem.Length == othermem.Length)
 							{
 								samesidedef = true;
 								sidemem.Seek(0, SeekOrigin.Begin);
 								othermem.Seek(0, SeekOrigin.Begin);
 								for (int i = 0; i < sidemem.Length; i++)
 								{
 									if (sidemem.ReadByte() != othermem.ReadByte())
 									{
 										samesidedef = false;
 										break;
 									}
 								}
 							}
 
 							if (samesidedef) break;
 						}
 					}
 				}
 
 				// Same sidedef?
 				if(samesidedef)
 				{
 					// Replace with stored sidedef
 					bool isfront = snsd.IsFront;
 					Linedef ld = snsd.Line;
 					snsd.Line.DetachSidedefP(snsd);
 					if(isfront)
 						ld.AttachFront(stored);
 					else
 						ld.AttachBack(stored);
 					
 					// Remove the sidedef
 					snsd.SetSector(null);
 					RemoveSidedef(sn);
 				}
 				else
 				{
 					// Store this new one
 					if(checksumstored)
 					{
 						storedsides[checksum].Add(snsd);
 					}
 					else
 					{
 						List<Sidedef> newlist = new List<Sidedef>(4);
 						newlist.Add(snsd);
 						storedsides.Add(checksum, newlist);
 					}
 					
 					// Next
 					sn++;
 				}
 			}
 			while(sn < numsidedefs)
 			{
 				Sidedef stored = null;
 				Sidedef snsd = sidedefs[sn];
 
 				// Check if checksum is stored
 				bool samesidedef = false;
 				uint checksum = snsd.GetChecksum();
 				bool checksumstored = storedsides.ContainsKey(checksum);
 				if(checksumstored)
 				{
 					List<Sidedef> othersides = storedsides[checksum];
 					foreach(Sidedef os in othersides)
 					{
 						// They must be in the same sector
 						if (snsd.Sector == os.Sector)
 						{
 							// Check if sidedefs are really the same
 							stored = os;
 							MemoryStream sidemem = new MemoryStream(1024);
 							SerializerStream sidedata = new SerializerStream(sidemem);
 							MemoryStream othermem = new MemoryStream(1024);
 							SerializerStream otherdata = new SerializerStream(othermem);
 							snsd.ReadWrite(sidedata);
 							os.ReadWrite(otherdata);
 							if (sidemem.Length == othermem.Length)
 							{
 								samesidedef = true;
 								sidemem.Seek(0, SeekOrigin.Begin);
 								othermem.Seek(0, SeekOrigin.Begin);
 								for (int i = 0; i < sidemem.Length; i++)
 								{
 									if (sidemem.ReadByte() != othermem.ReadByte())
 									{
 										samesidedef = false;
 										break;
 									}
 								}
 							}
 
 							if (samesidedef) break;
 						}
 					}
 				}
 
 				// Same sidedef?
 				if(samesidedef)
 				{
 					// Replace with stored sidedef
 					bool isfront = snsd.IsFront;
 					Linedef ld = snsd.Line;
 					snsd.Line.DetachSidedefP(snsd);
 					if(isfront)
 						ld.AttachFront(stored);
 					else
 						ld.AttachBack(stored);
 					
 					// Remove the sidedef
 					snsd.SetSector(null);
 					RemoveSidedef(sn);
 				}
 				else
 				{
 					// Store this new one
 					if(checksumstored)
 					{
 						storedsides[checksum].Add(snsd);
 					}
 					else
 					{
 						List<Sidedef> newlist = new List<Sidedef>(4);
 						newlist.Add(snsd);
 						storedsides.Add(checksum, newlist);
 					}
 					
 					// Next
 					sn++;
 				}
 			}
 
 			EndAddRemove();
 
 			// Output info
 			double endtime = General.Clock.GetCurrentTime();
 			double deltatimesec = (endtime - starttime) / 1000.0d;
 			float ratio = 100.0f - (((float)numsidedefs / (float)originalsidescount) * 100.0f);
 			General.WriteLogLine("Sidedefs compressed
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.cs" startline="463" endline="477">
<![CDATA[
 
 		private void arg_Validated(object sender, EventArgs e)
 		{
 			// Anything selected?
 			if(listfilters.SelectedItems.Count > 0)
 			{
 				// Get selected filter
 				ThingsFilter f = listfilters.SelectedItems[0].Tag as ThingsFilter;
 				
 				int index;
 				int.TryParse((sender as Control).Tag.ToString(), out index);
 				ArgumentBox filterarg = (sender as ArgumentBox);
 				f.ThingArgs[index] = filterarg.GetResult(-1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="1347" endline="1419">
<![CDATA[
 		public bool DeleteSetting(string setting, string pathseperator)
 		{
 			IDictionary cs = null;
 			
 			// Split the path in an array
 			string[] keys = setting.Split(pathseperator.ToCharArray());
 			string finalkey = keys[keys.Length - 1];
 			
 			// Get the root item
 			object item = root;
 			
 			// Go for each path item
 			for(int i = 0; i < (keys.Length - 1); i++)
 			{
 				// Check if the key is valid
 				if(ValidateKey(null, keys[i].Trim(), "", -1) == true)
 				{
 					// Cast to ConfigStruct
 					cs = (IDictionary)item;
 					
 					// Check if the requested item exists
 					if(cs.Contains(keys[i]) == true)
 					{
 						// Check if the requested item is a ConfigStruct
 						if(cs[keys[i] is IDictionary)
 						{
 							// Set the item to the next item
 							item = cs[keys[i];
 						}
 						else
 						{
 							// Cant proceed with path
 							return false;
 						}
 					}
 					else
 					{
 						// Key not found
 						// Create it now
 						IDictionary ncs;
 						if(root is ListDictionary) ncs = new ListDictionary(); else ncs = new Hashtable();
 						cs.Add(keys[i], ncs);
 						
 						// Set the item to the next item
 						item = cs[keys[i];
 					}
 				}
 				else
 				{
 					// Invalid key in path
 					return false;
 				}
 			}
 			for(int i = 0; i < (keys.Length - 1); i++)
 			{
 				// Check if the key is valid
 				if(ValidateKey(null, keys[i].Trim(), "", -1) == true)
 				{
 					// Cast to ConfigStruct
 					cs = (IDictionary)item;
 					
 					// Check if the requested item exists
 					if(cs.Contains(keys[i]) == true)
 					{
 						// Check if the requested item is a ConfigStruct
 						if(cs[keys[i] is IDictionary)
 						{
 							// Set the item to the next item
 							item = cs[keys[i];
 						}
 						else
 						{
 							// Cant proceed with path
 							return false;
 						}
 					}
 					else
 					{
 						// Key not found
 						// Create it now
 						IDictionary ncs;
 						if(root is ListDictionary) ncs = new ListDictionary(); else ncs = new Hashtable();
 						cs.Add(keys[i], ncs);
 						
 						// Set the item to the next item
 						item = cs[keys[i];
 					}
 				}
 				else
 				{
 					// Invalid key in path
 					return false;
 				}
 			}
 			
 			// Cast to ConfigStruct
 			cs = (IDictionary)item;
 			
 			// Arrived at our destination
 			// Delete the key if the key exists
 			if(cs.Contains(finalkey) == true)
 			{
 				// Key exists, delete it
 				cs.Remove(finalkey);
 				
 				// Return success
 				return true;
 			}
 			else
 			{
 				// Key not found, return fail
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="399" endline="504">
<![CDATA[
 		
 		// This adds or updates sector geometry into a buffer.
 		// Modiies the list of SurfaceEntries with the new surface entry for the stored geometry.
 		public void UpdateSurfaces(SurfaceEntryCollection entries, SurfaceUpdate update)
 		{
 			// Free entries when number of vertices has changed
 			if((entries.Count > 0) && (entries.totalvertices != update.numvertices))
 			{
 				FreeSurfaces(entries);
 				entries.Clear();
 			}
 			
 			if((entries.Count == 0) && (update.numvertices > 0))
 			{
 				#if DEBUG
 				if((update.floorvertices == null) || (update.ceilvertices == null))
 					General.Fail("We need both floor and ceiling vertices when the number of vertices changes!");
 				#endif
 				
 				// If we have no entries yet, we have to make them now
 				int vertsremaining = update.numvertices;
 				while(vertsremaining > 0)
 				{
 					// Determine for how many vertices in this entry
 					int vertsinentry = (vertsremaining > MAX_VERTICES_PER_SECTOR) ? MAX_VERTICES_PER_SECTOR 
 
 					// Lookup the set that holds entries for this number of vertices
 					SurfaceBufferSet set = GetSet(vertsinentry);
 
 					// Make sure we can get a new entry in this set
 					EnsureFreeBufferSpace(set, 1);
 
 					// Get a new entry in this set
 					SurfaceEntry e = set.holes[set.holes.Count - 1];
 					set.holes.RemoveAt(set.holes.Count - 1);
 					set.entries.Add(e);
 					
 					// Fill the entry data
 					e.floorvertices = new FlatVertex[vertsinentry];
 					e.ceilvertices = new FlatVertex[vertsinentry];
 					Array.Copy(update.floorvertices, update.numvertices - vertsremaining, e.floorvertices, 0, vertsinentry);
 					Array.Copy(update.ceilvertices, update.numvertices - vertsremaining, e.ceilvertices, 0, vertsinentry);
 					e.floortexture = update.floortexture;
 					e.ceiltexture = update.ceiltexture;
 					
 					entries.Add(e);
 					vertsremaining -= vertsinentry;
 				}
 				while(vertsremaining > 0)
 				{
 					// Determine for how many vertices in this entry
 					int vertsinentry = (vertsremaining > MAX_VERTICES_PER_SECTOR) ? MAX_VERTICES_PER_SECTOR 
 
 					// Lookup the set that holds entries for this number of vertices
 					SurfaceBufferSet set = GetSet(vertsinentry);
 
 					// Make sure we can get a new entry in this set
 					EnsureFreeBufferSpace(set, 1);
 
 					// Get a new entry in this set
 					SurfaceEntry e = set.holes[set.holes.Count - 1];
 					set.holes.RemoveAt(set.holes.Count - 1);
 					set.entries.Add(e);
 					
 					// Fill the entry data
 					e.floorvertices = new FlatVertex[vertsinentry];
 					e.ceilvertices = new FlatVertex[vertsinentry];
 					Array.Copy(update.floorvertices, update.numvertices - vertsremaining, e.floorvertices, 0, vertsinentry);
 					Array.Copy(update.ceilvertices, update.numvertices - vertsremaining, e.ceilvertices, 0, vertsinentry);
 					e.floortexture = update.floortexture;
 					e.ceiltexture = update.ceiltexture;
 					
 					entries.Add(e);
 					vertsremaining -= vertsinentry;
 				}
 			}
 			else
 			{
 				// We re-use the same entries, just copy over the updated data
 				int vertsremaining = update.numvertices;
 				foreach(SurfaceEntry e in entries)
 				{
 					if(update.floorvertices != null)
 					{
 						Array.Copy(update.floorvertices, update.numvertices - vertsremaining, e.floorvertices, 0, e.numvertices);
 						e.floortexture = update.floortexture;
 					}
 
 					if(update.ceilvertices != null)
 					{
 						Array.Copy(update.ceilvertices, update.numvertices - vertsremaining, e.ceilvertices, 0, e.numvertices);
 						e.ceiltexture = update.ceiltexture;
 					}
 
 					vertsremaining -= e.numvertices;
 				}
 				foreach(SurfaceEntry e in entries)
 				{
 					if(update.floorvertices != null)
 					{
 						Array.Copy(update.floorvertices, update.numvertices - vertsremaining, e.floorvertices, 0, e.numvertices);
 						e.floortexture = update.floortexture;
 					}
 
 					if(update.ceilvertices != null)
 					{
 						Array.Copy(update.ceilvertices, update.numvertices - vertsremaining, e.ceilvertices, 0, e.numvertices);
 						e.ceiltexture = update.ceiltexture;
 					}
 
 					vertsremaining -= e.numvertices;
 				}
 			}
 
 			entries.totalvertices = update.numvertices;
 			
 			// Time to update or create the buffers
 			foreach(SurfaceEntry e in entries)
 			{
 				SurfaceBufferSet set = GetSet(e.numvertices);
 
 				// Update bounding box
 				e.UpdateBBox();
 				
 				if(!resourcesunloaded)
 				{
 					// Lock the buffer
 					DataStream bstream;
 					VertexBuffer vb = set.buffers[e.bufferindex];
 					if(vb.Tag == null)
 					{
 						// Note
 						// but we don't have much of a choice since we want to update our data and not destroy other data
 						bstream = vb.Lock(0, set.buffersizes[e.bufferindex] * FlatVertex.Stride, LockFlags.None);
 						vb.Tag = bstream;
 						lockedbuffers.Add(vb);
 					}
 					else
 					{
 						bstream = (DataStream)vb.Tag;
 					}
 
 					// Write the vertices to buffer
 					bstream.Seek(e.vertexoffset * FlatVertex.Stride, SeekOrigin.Begin);
 					bstream.WriteRange(e.floorvertices);
 					bstream.WriteRange(e.ceilvertices);
 				}
 			}
 			foreach(SurfaceEntry e in entries)
 			{
 				SurfaceBufferSet set = GetSet(e.numvertices);
 
 				// Update bounding box
 				e.UpdateBBox();
 				
 				if(!resourcesunloaded)
 				{
 					// Lock the buffer
 					DataStream bstream;
 					VertexBuffer vb = set.buffers[e.bufferindex];
 					if(vb.Tag == null)
 					{
 						// Note
 						// but we don't have much of a choice since we want to update our data and not destroy other data
 						bstream = vb.Lock(0, set.buffersizes[e.bufferindex] * FlatVertex.Stride, LockFlags.None);
 						vb.Tag = bstream;
 						lockedbuffers.Add(vb);
 					}
 					else
 					{
 						bstream = (DataStream)vb.Tag;
 					}
 
 					// Write the vertices to buffer
 					bstream.Seek(e.vertexoffset * FlatVertex.Stride, SeekOrigin.Begin);
 					bstream.WriteRange(e.floorvertices);
 					bstream.WriteRange(e.ceilvertices);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.cs" startline="205" endline="231">
<![CDATA[
 
 		// Add a resource
 		private void addresource_Click(object sender, EventArgs e)
 		{
 			ResourceOptionsForm resoptions;
 			Rectangle startposition;
 			
 			// Open resource options dialog
 			resoptions = new ResourceOptionsForm(new DataLocation(), "Add Resource");
 			resoptions.StartPosition = FormStartPosition.Manual;
 			startposition = new Rectangle(dialogoffset.X, dialogoffset.Y, 1, 1);
 			startposition = this.RectangleToScreen(startposition);
 			Screen screen = Screen.FromPoint(startposition.Location);
 			if(startposition.X + resoptions.Size.Width > screen.WorkingArea.Right)
 				startposition.X = screen.WorkingArea.Right - resoptions.Size.Width;
 			if(startposition.Y + resoptions.Size.Height > screen.WorkingArea.Bottom)
 				startposition.Y = screen.WorkingArea.Bottom - resoptions.Size.Height;
 			resoptions.Location = startposition.Location;
 			if(resoptions.ShowDialog(this) == DialogResult.OK)
 			{
 				// Add resource
 				AddItem(resoptions.ResourceLocation);
 			}
 
 			// Raise content changed event
 			if(OnContentChanged != null) OnContentChanged();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="505" endline="645">
<![CDATA[
 		
 		// This finds the cut coordinates and splits the other poly with inner vertices
 		private void SplitOuterWithInner(LinkedListNode<EarClipVertex> start, EarClipPolygon p, EarClipPolygon inner)
 		{
 			LinkedListNode<EarClipVertex> v1, v2;
 			LinkedListNode<EarClipVertex> insertbefore = null;
 			float u, ul, bonus, foundu = float.MaxValue;
 			Vector2D foundpos = new Vector2D();
 			EarClipVertex split;
 			
 			// Create a line from start that goes beyond the right most vertex of p
 			LinkedListNode<EarClipVertex> pr = FindRightMostVertex(p);
 			float startx = start.Value.Position.x;
 			float endx = pr.Value.Position.x + 10.0f;
 			Line2D starttoright = new Line2D(start.Value.Position, new Vector2D(endx, start.Value.Position.y));
 			
 			// Calculate a small bonus (0.1 mappixel)
 			bonus = starttoright.GetNearestOnLine(new Vector2D(start.Value.Position.x + 0.1f, start.Value.Position.y));
 			
 			// Go for all lines in the outer polygon
 			v1 = p.Last;
 			v2 = p.First;
 			while(v2 != null)
 			{
 				// Check if the line goes between startx and endx
 				if(((v1.Value.Position.x > startx) ||
 				    (v2.Value.Position.x > startx)) &&
 				   ((v1.Value.Position.x < endx) ||
 				    (v2.Value.Position.x < endx)))
 				{
 					// Find intersection
 					Line2D pl = new Line2D(v1.Value.Position, v2.Value.Position);
 					pl.GetIntersection(starttoright, out u, out ul);
 					if(float.IsNaN(u))
 					{
 						// We have found a line that is perfectly horizontal
 						// (parallel to the cut scan line) Check if the line
 						// is overlapping the cut scan line.
 						if(v1.Value.Position.y == start.Value.Position.y)
 						{
 							// This is an exceptional situation which causes a bit of a problem, because
 							// this could be a previously made cut, which overlaps another line from the
 							// same cut and we have to determine which of the two we will join with. If we
 							// pick the wrong one, the polygon is no longer valid and triangulation will fail.
 							
 							// Calculate distance of each vertex in units
 							u = starttoright.GetNearestOnLine(v1.Value.Position);
 							ul = starttoright.GetNearestOnLine(v2.Value.Position);
 							
 							// Rule out vertices before the scan line
 							if(u < 0.0f) u = float.MaxValue;
 							if(ul < 0.0f) ul = float.MaxValue;
 							
 							float insert_u = Math.Min(u, ul);
 							Vector2D inserpos = starttoright.GetCoordinatesAt(insert_u);
 							
 							// Check in which direction the line goes.
 							if(v1.Value.Position.x > v2.Value.Position.x)
 							{
 								// The line goes from right to left (towards our start point)
 								// so we must always insert our cut after this line.
 								
 								// If the next line goes up, we consider this a better candidate than
 								// a horizontal line that goes from left to right (the other cut line)
 								// so we give it a small bonus.
 								LinkedListNode<EarClipVertex> v3 = v2.Next ?? v2.List.First;
 								if(v3.Value.Position.y < v2.Value.Position.y)
 									insert_u -= bonus;
 								
 								// Remember this when it is a closer match
 								if(insert_u <= foundu)
 								{
 									insertbefore = v2.Next ?? v2.List.First;
 									foundu = insert_u;
 									foundpos = inserpos;
 								}
 							}
 							else
 							{
 								// The line goes from left to right (away from our start point)
 								// so we must always insert our cut before this line.
 								
 								// If the previous line goes down, we consider this a better candidate than
 								// a horizontal line that goes from right to left (the other cut line)
 								// so we give it a small bonus.
 								LinkedListNode<EarClipVertex> v3 = v1.Previous ?? v1.List.Last;
 								if(v3.Value.Position.y > v1.Value.Position.y)
 									insert_u -= bonus;
 								
 								// Remember this when it is a closer match
 								if(insert_u <= foundu)
 								{
 									insertbefore = v2;
 									foundu = insert_u;
 									foundpos = inserpos;
 								}
 							}
 						}
 					}
 					// Found a closer match?
 					else if((ul >= 0.0f) && (ul <= 1.0f) && (u > 0.0f) && (u <= foundu))
 					{
 						// Found a closer intersection
 						insertbefore = v2;
 						foundu = u;
 						foundpos = starttoright.GetCoordinatesAt(u);
 					}
 				}
 				
 				// Next
 				v1 = v2;
 				v2 = v2.Next;
 			}
 			while(v2 != null)
 			{
 				// Check if the line goes between startx and endx
 				if(((v1.Value.Position.x > startx) ||
 				    (v2.Value.Position.x > startx)) &&
 				   ((v1.Value.Position.x < endx) ||
 				    (v2.Value.Position.x < endx)))
 				{
 					// Find intersection
 					Line2D pl = new Line2D(v1.Value.Position, v2.Value.Position);
 					pl.GetIntersection(starttoright, out u, out ul);
 					if(float.IsNaN(u))
 					{
 						// We have found a line that is perfectly horizontal
 						// (parallel to the cut scan line) Check if the line
 						// is overlapping the cut scan line.
 						if(v1.Value.Position.y == start.Value.Position.y)
 						{
 							// This is an exceptional situation which causes a bit of a problem, because
 							// this could be a previously made cut, which overlaps another line from the
 							// same cut and we have to determine which of the two we will join with. If we
 							// pick the wrong one, the polygon is no longer valid and triangulation will fail.
 							
 							// Calculate distance of each vertex in units
 							u = starttoright.GetNearestOnLine(v1.Value.Position);
 							ul = starttoright.GetNearestOnLine(v2.Value.Position);
 							
 							// Rule out vertices before the scan line
 							if(u < 0.0f) u = float.MaxValue;
 							if(ul < 0.0f) ul = float.MaxValue;
 							
 							float insert_u = Math.Min(u, ul);
 							Vector2D inserpos = starttoright.GetCoordinatesAt(insert_u);
 							
 							// Check in which direction the line goes.
 							if(v1.Value.Position.x > v2.Value.Position.x)
 							{
 								// The line goes from right to left (towards our start point)
 								// so we must always insert our cut after this line.
 								
 								// If the next line goes up, we consider this a better candidate than
 								// a horizontal line that goes from left to right (the other cut line)
 								// so we give it a small bonus.
 								LinkedListNode<EarClipVertex> v3 = v2.Next ?? v2.List.First;
 								if(v3.Value.Position.y < v2.Value.Position.y)
 									insert_u -= bonus;
 								
 								// Remember this when it is a closer match
 								if(insert_u <= foundu)
 								{
 									insertbefore = v2.Next ?? v2.List.First;
 									foundu = insert_u;
 									foundpos = inserpos;
 								}
 							}
 							else
 							{
 								// The line goes from left to right (away from our start point)
 								// so we must always insert our cut before this line.
 								
 								// If the previous line goes down, we consider this a better candidate than
 								// a horizontal line that goes from right to left (the other cut line)
 								// so we give it a small bonus.
 								LinkedListNode<EarClipVertex> v3 = v1.Previous ?? v1.List.Last;
 								if(v3.Value.Position.y > v1.Value.Position.y)
 									insert_u -= bonus;
 								
 								// Remember this when it is a closer match
 								if(insert_u <= foundu)
 								{
 									insertbefore = v2;
 									foundu = insert_u;
 									foundpos = inserpos;
 								}
 							}
 						}
 					}
 					// Found a closer match?
 					else if((ul >= 0.0f) && (ul <= 1.0f) && (u > 0.0f) && (u <= foundu))
 					{
 						// Found a closer intersection
 						insertbefore = v2;
 						foundu = u;
 						foundpos = starttoright.GetCoordinatesAt(u);
 					}
 				}
 				
 				// Next
 				v1 = v2;
 				v2 = v2.Next;
 			}
 			
 			// Found anything?
 			if(insertbefore != null)
 			{
 				Sidedef sd = (insertbefore.Previous == null) ? insertbefore.List.Last.Value.Sidedef 
 				
 				// Find the position where we have to split the outer polygon
 				split = new EarClipVertex(foundpos, null);
 				
 				// Insert manual split vertices
 				p.AddBefore(insertbefore, new EarClipVertex(split, sd));
 				
 				// Start inserting from the start (do I make sense this time?)
 				v1 = start;
 				do
 				{
 					// Insert inner polygon vertex
 					p.AddBefore(insertbefore, new EarClipVertex(v1.Value));
 					if(v1.Next != null) v1 = v1.Next; else v1 = v1.List.First;
 				}
 				while(v1 != start);
 				
 				// Insert manual split vertices
 				p.AddBefore(insertbefore, new EarClipVertex(start.Value, sd));
 				if(split.Position != insertbefore.Value.Position)
 					p.AddBefore(insertbefore, new EarClipVertex(split, sd));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2221" endline="2237">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Prefabs Menu
 
 		// This sets up the prefabs menu
 		private void UpdatePrefabsMenu()
 		{
 			// Enable/disable items
 			itemcreateprefab.Enabled = (General.Map != null) && (General.Editing.Mode != null) && General.Editing.Mode.Attributes.AllowCopyPaste;
 			iteminsertprefabfile.Enabled = (General.Map != null) && (General.Editing.Mode != null) && General.Editing.Mode.Attributes.AllowCopyPaste;
 			iteminsertpreviousprefab.Enabled = (General.Map != null) && (General.Editing.Mode != null) && General.Map.CopyPaste.IsPreviousPrefabAvailable && General.Editing.Mode.Attributes.AllowCopyPaste;
 			
 			// Toolbar icons
 			buttoninsertprefabfile.Enabled = iteminsertprefabfile.Enabled;
 			buttoninsertpreviousprefab.Enabled = iteminsertpreviousprefab.Enabled;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2504" endline="2514">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Tools
 
 		/// <summary>This snaps all vertices to the map format accuracy. Call this to ensure the vertices are at valid coordinates.</summary>
 		public void SnapAllToAccuracy()
 		{
 			foreach(Vertex v in vertices) v.SnapToAccuracy();
 			foreach(Thing t in things) t.SnapToAccuracy();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2881" endline="2887">
<![CDATA[
 
 		// This converts flags and activations to UDMF fields
 		internal void TranslateToUDMF()
 		{
 			foreach(Linedef l in linedefs) l.TranslateToUDMF();
 			foreach(Thing t in things) t.TranslateToUDMF();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="1271" endline="1342">
<![CDATA[
 		public bool WriteSetting(string setting, object settingvalue, string pathseperator)
 		{
 			IDictionary cs = null;
 			
 			// Split the path in an array
 			string[] keys = setting.Split(pathseperator.ToCharArray());
 			string finalkey = keys[keys.Length - 1];
 			
 			// Get the root item
 			object item = root;
 			
 			// Go for each path item
 			for(int i = 0; i < (keys.Length - 1); i++)
 			{
 				// Check if the key is valid
 				if(ValidateKey(null, keys[i].Trim(), "", -1) == true)
 				{
 					// Cast to ConfigStruct
 					cs = (IDictionary)item;
 					
 					// Check if the requested item exists
 					if(cs.Contains(keys[i]) == true)
 					{
 						// Check if the requested item is a ConfigStruct
 						if(cs[keys[i] is IDictionary)
 						{
 							// Set the item to the next item
 							item = cs[keys[i];
 						}
 						else
 						{
 							// Cant proceed with path
 							return false;
 						}
 					}
 					else
 					{
 						// Key not found
 						// Create it now
 						IDictionary ncs;
 						if(root is ListDictionary) ncs = new ListDictionary(); else ncs = new Hashtable();
 						cs.Add(keys[i], ncs);
 						
 						// Set the item to the next item
 						item = cs[keys[i];
 					}
 				}
 				else
 				{
 					// Invalid key in path
 					return false;
 				}
 			}
 			for(int i = 0; i < (keys.Length - 1); i++)
 			{
 				// Check if the key is valid
 				if(ValidateKey(null, keys[i].Trim(), "", -1) == true)
 				{
 					// Cast to ConfigStruct
 					cs = (IDictionary)item;
 					
 					// Check if the requested item exists
 					if(cs.Contains(keys[i]) == true)
 					{
 						// Check if the requested item is a ConfigStruct
 						if(cs[keys[i] is IDictionary)
 						{
 							// Set the item to the next item
 							item = cs[keys[i];
 						}
 						else
 						{
 							// Cant proceed with path
 							return false;
 						}
 					}
 					else
 					{
 						// Key not found
 						// Create it now
 						IDictionary ncs;
 						if(root is ListDictionary) ncs = new ListDictionary(); else ncs = new Hashtable();
 						cs.Add(keys[i], ncs);
 						
 						// Set the item to the next item
 						item = cs[keys[i];
 					}
 				}
 				else
 				{
 					// Invalid key in path
 					return false;
 				}
 			}
 			
 			// Cast to ConfigStruct
 			cs = (IDictionary)item;
 			
 			// Check if the key already exists
 			if(cs.Contains(finalkey) == true)
 			{
 				// Update the value
 				cs[finalkey] = settingvalue;
 			}
 			else
 			{
 				// Create the key/value pair
 				cs.Add(finalkey, settingvalue);
 			}
 			
 			// Return success
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalParser.cs" startline="789" endline="813">
<![CDATA[
 		
 		
 		// This will load a configuration from file
 		public bool LoadConfiguration(string filename)
 		{
 			// Check if the file is missing
 			if(File.Exists(filename) == false)
 			{
 				throw(new FileNotFoundException("File not found \"" + filename + "\"", filename));
 			}
 			else
 			{
 				// Load the file contents
 				FileStream fstream = File.OpenRead(filename);
 				byte[] fbuffer = new byte[fstream.Length];
 				fstream.Read(fbuffer, 0, fbuffer.Length);
 				fstream.Close();
 				
 				// Convert byte array to string
 				string data = Encoding.ASCII.GetString(fbuffer);
 				
 				// Load the configuration from this data
 				return InputConfiguration(data);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="398" endline="512">
<![CDATA[
 
 		// This makes a deep copy of the marked geometry and binds missing sectors to a virtual sector
 		internal MapSet CloneMarked()
 		{
 			Sector virtualsector = null;
 			
 			// Create the map set
 			MapSet newset = new MapSet();
 			newset.BeginAddRemove();
 
 			// Get marked geometry
 			ICollection<Vertex> mvertices = GetMarkedVertices(true);
 			ICollection<Linedef> mlinedefs = GetMarkedLinedefs(true);
 			ICollection<Sector> msectors = GetMarkedSectors(true);
 			ICollection<Thing> mthings = GetMarkedThings(true);
 			newset.SetCapacity(mvertices.Count, mlinedefs.Count, numsidedefs, msectors.Count, mthings.Count);
 			
 			// Go for all vertices
 			foreach(Vertex v in mvertices)
 			{
 				// Make new vertex
 				v.Clone = newset.CreateVertex(v.Position);
 				v.CopyPropertiesTo(v.Clone);
 			}
 			foreach(Vertex v in mvertices)
 			{
 				// Make new vertex
 				v.Clone = newset.CreateVertex(v.Position);
 				v.CopyPropertiesTo(v.Clone);
 			}
 
 			// Go for all sectors
 			foreach(Sector s in msectors)
 			{
 				// Make new sector
 				s.Clone = newset.CreateSector();
 				s.CopyPropertiesTo(s.Clone);
 			}
 			foreach(Sector s in msectors)
 			{
 				// Make new sector
 				s.Clone = newset.CreateSector();
 				s.CopyPropertiesTo(s.Clone);
 			}
 
 			// Go for all linedefs
 			foreach(Linedef l in mlinedefs)
 			{
 				// Make new linedef
 				Linedef nl = newset.CreateLinedef(l.Start.Clone, l.End.Clone);
 				l.CopyPropertiesTo(nl);
 
 				// Linedef has a front side?
 				if(l.Front != null)
 				{
 					Sidedef nd;
 					
 					// Sector on front side marked?
 					if(l.Front.Sector.Marked)
 					{
 						// Make new sidedef
 						nd = newset.CreateSidedef(nl, true, l.Front.Sector.Clone);
 					}
 					else
 					{
 						// Make virtual sector if needed
 						if(virtualsector == null)
 						{
 							virtualsector = newset.CreateSector();
 							l.Front.Sector.CopyPropertiesTo(virtualsector);
 							virtualsector.Fields.BeforeFieldsChange();
 							virtualsector.Fields[VIRTUAL_SECTOR_FIELD] = new UniValue(virtualsectorvalue);
 						}
 						
 						// Make new sidedef that links to the virtual sector
 						nd = newset.CreateSidedef(nl, true, virtualsector);
 					}
 					
 					l.Front.CopyPropertiesTo(nd);
 				}
 
 				// Linedef has a back side?
 				if(l.Back != null)
 				{
 					Sidedef nd;
 
 					// Sector on front side marked?
 					if(l.Back.Sector.Marked)
 					{
 						// Make new sidedef
 						nd = newset.CreateSidedef(nl, false, l.Back.Sector.Clone);
 					}
 					else
 					{
 						// Make virtual sector if needed
 						if(virtualsector == null)
 						{
 							virtualsector = newset.CreateSector();
 							l.Back.Sector.CopyPropertiesTo(virtualsector);
 							virtualsector.Fields.BeforeFieldsChange();
 							virtualsector.Fields[VIRTUAL_SECTOR_FIELD] = new UniValue(virtualsectorvalue);
 						}
 
 						// Make new sidedef that links to the virtual sector
 						nd = newset.CreateSidedef(nl, false, virtualsector);
 					}
 					
 					l.Back.CopyPropertiesTo(nd);
 				}
 			}
 			foreach(Linedef l in mlinedefs)
 			{
 				// Make new linedef
 				Linedef nl = newset.CreateLinedef(l.Start.Clone, l.End.Clone);
 				l.CopyPropertiesTo(nl);
 
 				// Linedef has a front side?
 				if(l.Front != null)
 				{
 					Sidedef nd;
 					
 					// Sector on front side marked?
 					if(l.Front.Sector.Marked)
 					{
 						// Make new sidedef
 						nd = newset.CreateSidedef(nl, true, l.Front.Sector.Clone);
 					}
 					else
 					{
 						// Make virtual sector if needed
 						if(virtualsector == null)
 						{
 							virtualsector = newset.CreateSector();
 							l.Front.Sector.CopyPropertiesTo(virtualsector);
 							virtualsector.Fields.BeforeFieldsChange();
 							virtualsector.Fields[VIRTUAL_SECTOR_FIELD] = new UniValue(virtualsectorvalue);
 						}
 						
 						// Make new sidedef that links to the virtual sector
 						nd = newset.CreateSidedef(nl, true, virtualsector);
 					}
 					
 					l.Front.CopyPropertiesTo(nd);
 				}
 
 				// Linedef has a back side?
 				if(l.Back != null)
 				{
 					Sidedef nd;
 
 					// Sector on front side marked?
 					if(l.Back.Sector.Marked)
 					{
 						// Make new sidedef
 						nd = newset.CreateSidedef(nl, false, l.Back.Sector.Clone);
 					}
 					else
 					{
 						// Make virtual sector if needed
 						if(virtualsector == null)
 						{
 							virtualsector = newset.CreateSector();
 							l.Back.Sector.CopyPropertiesTo(virtualsector);
 							virtualsector.Fields.BeforeFieldsChange();
 							virtualsector.Fields[VIRTUAL_SECTOR_FIELD] = new UniValue(virtualsectorvalue);
 						}
 
 						// Make new sidedef that links to the virtual sector
 						nd = newset.CreateSidedef(nl, false, virtualsector);
 					}
 					
 					l.Back.CopyPropertiesTo(nd);
 				}
 			}
 
 			// Go for all things
 			foreach(Thing t in mthings)
 			{
 				// Make new thing
 				Thing nt = newset.CreateThing();
 				t.CopyPropertiesTo(nt);
 			}
 			foreach(Thing t in mthings)
 			{
 				// Make new thing
 				Thing nt = newset.CreateThing();
 				t.CopyPropertiesTo(nt);
 			}
 
 			// Remove clone references
 			foreach(Vertex v in vertices) v.Clone = null;
 			foreach(Sector s in sectors) s.Clone = null;
 
 			// Return the new set
 			newset.EndAddRemove();
 			return newset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="330" endline="392">
<![CDATA[
 
 		// This loads all nodebuilder configurations
 		private static void LoadAllNodebuilderConfigurations()
 		{
 			Configuration cfg;
 			IDictionary builderslist;
 			string[] filenames;
 			
 			// Display status
 			mainwindow.DisplayStatus(StatusType.Busy, "Loading nodebuilder configurations...");
 
 			// Make array
 			nodebuilders = new List<NodebuilderInfo>();
 
 			// Go for all cfg files in the compilers directory
 			filenames = Directory.GetFiles(compilerspath, "*.cfg", SearchOption.AllDirectories);
 			foreach(string filepath in filenames)
 			{
 				try
 				{
 					// Try loading the configuration
 					cfg = new Configuration(filepath, true);
 
 					// Check for erors
 					if(cfg.ErrorResult)
 					{
 						// Error in configuration
 						errorlogger.Add(ErrorType.Error, "Unable to load the compiler configuration file \"" + Path.GetFileName(filepath) + "\". " +
 										                 "Error in file \"" + cfg.ErrorFile + "\" near line " + cfg.ErrorLine + "
 					}
 					else
 					{
 						// Get structures
 						builderslist = cfg.ReadSetting("nodebuilders", new Hashtable());
 						foreach(DictionaryEntry de in builderslist)
 						{
 							// Check if this is a structure
 							if(de.Value is IDictionary)
 							{
 								try
 								{
 									// Make nodebuilder info
 									nodebuilders.Add(new NodebuilderInfo(Path.GetFileName(filepath), de.Key.ToString(), cfg));
 								}
 								catch(Exception e)
 								{
 									// Unable to load configuration
 									errorlogger.Add(ErrorType.Error, "Unable to load the nodebuilder configuration '" + de.Key.ToString() + "' from \"" + Path.GetFileName(filepath) + "\". Error
 								}
 							}
 						}
 						foreach(DictionaryEntry de in builderslist)
 						{
 							// Check if this is a structure
 							if(de.Value is IDictionary)
 							{
 								try
 								{
 									// Make nodebuilder info
 									nodebuilders.Add(new NodebuilderInfo(Path.GetFileName(filepath), de.Key.ToString(), cfg));
 								}
 								catch(Exception e)
 								{
 									// Unable to load configuration
 									errorlogger.Add(ErrorType.Error, "Unable to load the nodebuilder configuration '" + de.Key.ToString() + "' from \"" + Path.GetFileName(filepath) + "\". Error
 								}
 							}
 						}
 					}
 				}
 				catch(Exception)
 				{
 					// Unable to load configuration
 					errorlogger.Add(ErrorType.Error, "Unable to load the compiler configuration file \"" + Path.GetFileName(filepath) + "\".");
 				}
 			}
 			foreach(string filepath in filenames)
 			{
 				try
 				{
 					// Try loading the configuration
 					cfg = new Configuration(filepath, true);
 
 					// Check for erors
 					if(cfg.ErrorResult)
 					{
 						// Error in configuration
 						errorlogger.Add(ErrorType.Error, "Unable to load the compiler configuration file \"" + Path.GetFileName(filepath) + "\". " +
 										                 "Error in file \"" + cfg.ErrorFile + "\" near line " + cfg.ErrorLine + "
 					}
 					else
 					{
 						// Get structures
 						builderslist = cfg.ReadSetting("nodebuilders", new Hashtable());
 						foreach(DictionaryEntry de in builderslist)
 						{
 							// Check if this is a structure
 							if(de.Value is IDictionary)
 							{
 								try
 								{
 									// Make nodebuilder info
 									nodebuilders.Add(new NodebuilderInfo(Path.GetFileName(filepath), de.Key.ToString(), cfg));
 								}
 								catch(Exception e)
 								{
 									// Unable to load configuration
 									errorlogger.Add(ErrorType.Error, "Unable to load the nodebuilder configuration '" + de.Key.ToString() + "' from \"" + Path.GetFileName(filepath) + "\". Error
 								}
 							}
 						}
 					}
 				}
 				catch(Exception)
 				{
 					// Unable to load configuration
 					errorlogger.Add(ErrorType.Error, "Unable to load the compiler configuration file \"" + Path.GetFileName(filepath) + "\".");
 				}
 			}
 
 			// Sort the list
 			nodebuilders.Sort();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceManager.cs" startline="260" endline="398">
<![CDATA[
 
 		// This ensures there is enough space for a given number of free entries (also adds new bufers if needed)
 		private void EnsureFreeBufferSpace(SurfaceBufferSet set, int freeentries)
 		{
 			DataStream bstream = null;
 			VertexBuffer vb = null;
 			
 			// Check if we have to add entries
 			int addentries = freeentries - set.holes.Count;
 
 			// Begin resizing buffers starting with the last in this set
 			int bufferindex = set.buffers.Count - 1;
 
 			// Calculate the maximum number of entries we can put in a new buffer
 			// Note that verticesperentry is the number of vertices multiplied by 2, because
 			// we have to store both the floor and ceiling
 			int verticesperentry = set.numvertices * 2;
 			int maxentriesperbuffer = MAX_VERTICES_PER_BUFFER / verticesperentry;
 
 			// Make a new bufer when the last one is full
 			if((bufferindex > -1) && (set.buffersizes[bufferindex] >= (maxentriesperbuffer * verticesperentry)))
 				bufferindex = -1;
 			
 			while(addentries > 0)
 			{
 				// Create a new buffer?
 				if((bufferindex == -1) || (bufferindex > (set.buffers.Count - 1)))
 				{
 					// Determine the number of entries we will be making this buffer for
 					int bufferentries = (addentries > maxentriesperbuffer) ? maxentriesperbuffer 
 
 					// Calculate the number of vertices that will be
 					int buffernumvertices = bufferentries * verticesperentry;
 
 					if(!resourcesunloaded)
 					{
 						// Make the new buffer!
 						vb = new VertexBuffer(General.Map.Graphics.Device, FlatVertex.Stride * buffernumvertices,
 												Usage.WriteOnly | Usage.Dynamic, VertexFormat.None, Pool.Default);
 
 						// Add it.
 						set.buffers.Add(vb);
 					}
 					else
 					{
 						// We can't make a vertexbuffer right now
 						set.buffers.Add(null);
 					}
 					
 					// Also add available entries as holes, because they are not used yet.
 					set.buffersizes.Add(buffernumvertices);
 					for(int i = 0; i < bufferentries; i++)
 						set.holes.Add(new SurfaceEntry(set.numvertices, set.buffers.Count - 1, i * verticesperentry));
 					for(int i = 0; i < bufferentries; i++)
 						set.holes.Add(new SurfaceEntry(set.numvertices, set.buffers.Count - 1, i * verticesperentry));
 
 					// Done
 					addentries -= bufferentries;
 				}
 				// Reallocate a buffer
 				else
 				{
 					// Trash the old buffer
 					if(set.buffers[bufferindex].Tag != null)
 					{
 						bstream = (DataStream)set.buffers[bufferindex].Tag;
 						set.buffers[bufferindex].Unlock();
 						bstream.Dispose();
 						set.buffers[bufferindex].Tag = null;
 					}
 
 					if((set.buffers[bufferindex] != null) && !resourcesunloaded)
 						set.buffers[bufferindex].Dispose();
 
 					// Get the entries that are in this buffer only
 					List<SurfaceEntry> theseentries = new List<SurfaceEntry>();
 					foreach(SurfaceEntry e in set.entries)
 					{
 						if(e.bufferindex == bufferindex)
 							theseentries.Add(e);
 					}
 					foreach(SurfaceEntry e in set.entries)
 					{
 						if(e.bufferindex == bufferindex)
 							theseentries.Add(e);
 					}
 
 					// Determine the number of entries we will be making this buffer for
 					int bufferentries = ((theseentries.Count + addentries) > maxentriesperbuffer) ? maxentriesperbuffer 
 
 					// Calculate the number of vertices that will be
 					int buffernumvertices = bufferentries * verticesperentry;
 
 					if(!resourcesunloaded)
 					{
 						// Make the new buffer and lock it
 						vb = new VertexBuffer(General.Map.Graphics.Device, FlatVertex.Stride * buffernumvertices,
 												Usage.WriteOnly | Usage.Dynamic, VertexFormat.None, Pool.Default);
 						bstream = vb.Lock(0, FlatVertex.Stride * theseentries.Count * verticesperentry, LockFlags.Discard);
 					}
 					
 					// Start refilling the buffer with sector geometry
 					int vertexoffset = 0;
 					foreach(SurfaceEntry e in theseentries)
 					{
 						if(!resourcesunloaded)
 						{
 							// Fill buffer
 							bstream.WriteRange(e.floorvertices);
 							bstream.WriteRange(e.ceilvertices);
 						}
 
 						// Set the new location in the buffer
 						e.vertexoffset = vertexoffset;
 
 						// Move on
 						vertexoffset += verticesperentry;
 					}
 					foreach(SurfaceEntry e in theseentries)
 					{
 						if(!resourcesunloaded)
 						{
 							// Fill buffer
 							bstream.WriteRange(e.floorvertices);
 							bstream.WriteRange(e.ceilvertices);
 						}
 
 						// Set the new location in the buffer
 						e.vertexoffset = vertexoffset;
 
 						// Move on
 						vertexoffset += verticesperentry;
 					}
 
 					if(!resourcesunloaded)
 					{
 						// Unlock buffer
 						vb.Unlock();
 						bstream.Dispose();
 						set.buffers[bufferindex] = vb;
 					}
 					else
 					{
 						// No vertex buffer at this time, sorry
 						set.buffers[bufferindex] = null;
 					}
 
 					// Set the new buffer and add available entries as holes, because they are not used yet.
 					set.buffersizes[bufferindex] = buffernumvertices;
 					set.holes.Clear();
 					for(int i = 0; i < bufferentries - theseentries.Count; i++)
 						set.holes.Add(new SurfaceEntry(set.numvertices, bufferindex, i * verticesperentry + vertexoffset));
 					for(int i = 0; i < bufferentries - theseentries.Count; i++)
 						set.holes.Add(new SurfaceEntry(set.numvertices, bufferindex, i * verticesperentry + vertexoffset));
 
 					// Done
 					addentries -= bufferentries;
 				}
 
 				// Always continue in next (new) buffer
 				bufferindex = set.buffers.Count;
 			}
 			while(addentries > 0)
 			{
 				// Create a new buffer?
 				if((bufferindex == -1) || (bufferindex > (set.buffers.Count - 1)))
 				{
 					// Determine the number of entries we will be making this buffer for
 					int bufferentries = (addentries > maxentriesperbuffer) ? maxentriesperbuffer 
 
 					// Calculate the number of vertices that will be
 					int buffernumvertices = bufferentries * verticesperentry;
 
 					if(!resourcesunloaded)
 					{
 						// Make the new buffer!
 						vb = new VertexBuffer(General.Map.Graphics.Device, FlatVertex.Stride * buffernumvertices,
 												Usage.WriteOnly | Usage.Dynamic, VertexFormat.None, Pool.Default);
 
 						// Add it.
 						set.buffers.Add(vb);
 					}
 					else
 					{
 						// We can't make a vertexbuffer right now
 						set.buffers.Add(null);
 					}
 					
 					// Also add available entries as holes, because they are not used yet.
 					set.buffersizes.Add(buffernumvertices);
 					for(int i = 0; i < bufferentries; i++)
 						set.holes.Add(new SurfaceEntry(set.numvertices, set.buffers.Count - 1, i * verticesperentry));
 
 					// Done
 					addentries -= bufferentries;
 				}
 				// Reallocate a buffer
 				else
 				{
 					// Trash the old buffer
 					if(set.buffers[bufferindex].Tag != null)
 					{
 						bstream = (DataStream)set.buffers[bufferindex].Tag;
 						set.buffers[bufferindex].Unlock();
 						bstream.Dispose();
 						set.buffers[bufferindex].Tag = null;
 					}
 
 					if((set.buffers[bufferindex] != null) && !resourcesunloaded)
 						set.buffers[bufferindex].Dispose();
 
 					// Get the entries that are in this buffer only
 					List<SurfaceEntry> theseentries = new List<SurfaceEntry>();
 					foreach(SurfaceEntry e in set.entries)
 					{
 						if(e.bufferindex == bufferindex)
 							theseentries.Add(e);
 					}
 
 					// Determine the number of entries we will be making this buffer for
 					int bufferentries = ((theseentries.Count + addentries) > maxentriesperbuffer) ? maxentriesperbuffer 
 
 					// Calculate the number of vertices that will be
 					int buffernumvertices = bufferentries * verticesperentry;
 
 					if(!resourcesunloaded)
 					{
 						// Make the new buffer and lock it
 						vb = new VertexBuffer(General.Map.Graphics.Device, FlatVertex.Stride * buffernumvertices,
 												Usage.WriteOnly | Usage.Dynamic, VertexFormat.None, Pool.Default);
 						bstream = vb.Lock(0, FlatVertex.Stride * theseentries.Count * verticesperentry, LockFlags.Discard);
 					}
 					
 					// Start refilling the buffer with sector geometry
 					int vertexoffset = 0;
 					foreach(SurfaceEntry e in theseentries)
 					{
 						if(!resourcesunloaded)
 						{
 							// Fill buffer
 							bstream.WriteRange(e.floorvertices);
 							bstream.WriteRange(e.ceilvertices);
 						}
 
 						// Set the new location in the buffer
 						e.vertexoffset = vertexoffset;
 
 						// Move on
 						vertexoffset += verticesperentry;
 					}
 
 					if(!resourcesunloaded)
 					{
 						// Unlock buffer
 						vb.Unlock();
 						bstream.Dispose();
 						set.buffers[bufferindex] = vb;
 					}
 					else
 					{
 						// No vertex buffer at this time, sorry
 						set.buffers[bufferindex] = null;
 					}
 
 					// Set the new buffer and add available entries as holes, because they are not used yet.
 					set.buffersizes[bufferindex] = buffernumvertices;
 					set.holes.Clear();
 					for(int i = 0; i < bufferentries - theseentries.Count; i++)
 						set.holes.Add(new SurfaceEntry(set.numvertices, bufferindex, i * verticesperentry + vertexoffset));
 
 					// Done
 					addentries -= bufferentries;
 				}
 
 				// Always continue in next (new) buffer
 				bufferindex = set.buffers.Count;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="481" endline="617">
<![CDATA[
 
 		// Done editing cell contents
 		private void fieldslist_CellEndEdit(object sender, DataGridViewCellEventArgs e)
 		{
 			FieldsEditorRow frow = null;
 			DataGridViewRow row = null;
 			
 			// Get the row
 			row = fieldslist.Rows[e.RowIndex];
 			if(row is FieldsEditorRow) frow = row as FieldsEditorRow;
 			
 			// Renaming a field?
 			if(e.ColumnIndex == 0)
 			{
 				// Row is a new row?
 				if(frow == null)
 				{
 					// Name given?
 					if((row.Cells[0].Value != null) && (row.Cells[0].Value.ToString() != FIELD_PREFIX_SUGGESTION))
 					{
 						// Make a valid UDMF field name
 						string validname = UniValue.ValidateName(row.Cells[0].Value.ToString());
 						if(validname.Length > 0)
 						{
 							// Check if no other row already has this name
 							foreach(DataGridViewRow r in fieldslist.Rows)
 							{
 								// Name matches and not the same row?
 								if((r.Index != row.Index) && (r.Cells.Count > 0) && (r.Cells[0].Value != null) &&
 								   (r.Cells[0].Value.ToString().ToLowerInvariant() == validname))
 								{
 									// Cannot have two rows with same name
 									validname = "";
 									General.ShowWarningMessage("Fields must have unique names!", MessageBoxButtons.OK);
 									break;
 								}
 							}
 							foreach(DataGridViewRow r in fieldslist.Rows)
 							{
 								// Name matches and not the same row?
 								if((r.Index != row.Index) && (r.Cells.Count > 0) && (r.Cells[0].Value != null) &&
 								   (r.Cells[0].Value.ToString().ToLowerInvariant() == validname))
 								{
 									// Cannot have two rows with same name
 									validname = "";
 									General.ShowWarningMessage("Fields must have unique names!", MessageBoxButtons.OK);
 									break;
 								}
 							}
 
 							// Still valid?
 							if(validname.Length > 0)
 							{
 								// Try to find the type in the map options
 								int type = General.Map.Options.GetUniversalFieldType(elementname, validname, 0);
 
 								// Make new row
 								frow = new FieldsEditorRow(fieldslist, validname, type, null);
 								frow.Visible = false;
 								fieldslist.Rows.Insert(e.RowIndex + 1, frow);
 								
 								if(OnFieldInserted != null)
 									OnFieldInserted(validname);
 							}
 						}
 					}
 
 					// Mark the row for delete
 					row.ReadOnly = true;
 					deleterowstimer.Start();
 				}
 				else
 				{
 					// Name given?
 					if(row.Cells[0].Value != null)
 					{
 						// Make a valid UDMF field name
 						string validname = UniValue.ValidateName(row.Cells[0].Value.ToString());
 						if(validname.Length > 0)
 						{
 							// Check if no other row already has this name
 							foreach(DataGridViewRow r in fieldslist.Rows)
 							{
 								// Name matches and not the same row?
 								if((r.Index != row.Index) && (r.Cells.Count > 0) && (r.Cells[0].Value != null) &&
 								   (r.Cells[0].Value.ToString().ToLowerInvariant() == validname))
 								{
 									// Cannot have two rows with same name
 									validname = "";
 									row.Cells[0].Value = lasteditfieldname;
 									General.ShowWarningMessage("Fields must have unique names!", MessageBoxButtons.OK);
 									break;
 								}
 							}
 							foreach(DataGridViewRow r in fieldslist.Rows)
 							{
 								// Name matches and not the same row?
 								if((r.Index != row.Index) && (r.Cells.Count > 0) && (r.Cells[0].Value != null) &&
 								   (r.Cells[0].Value.ToString().ToLowerInvariant() == validname))
 								{
 									// Cannot have two rows with same name
 									validname = "";
 									row.Cells[0].Value = lasteditfieldname;
 									General.ShowWarningMessage("Fields must have unique names!", MessageBoxButtons.OK);
 									break;
 								}
 							}
 
 							// Still valid?
 							if(validname.Length > 0)
 							{
 								// Try to find the type in the map options
 								int type = General.Map.Options.GetUniversalFieldType(elementname, validname, -1);
 
 								// Rename row and change type
 								row.Cells[0].Value = validname;
 								if(type != -1) frow.ChangeType(type);
 
 								if(OnFieldNameChanged != null)
 									OnFieldNameChanged(lasteditfieldname, validname);
 
 								if(OnFieldTypeChanged != null)
 									OnFieldTypeChanged(validname);
 							}
 							else
 							{
 								// Keep old name
 								row.Cells[0].Value = lasteditfieldname;
 							}
 						}
 						else
 						{
 							// Keep old name
 							row.Cells[0].Value = lasteditfieldname;
 						}
 					}
 					else
 					{
 						// Keep old name
 						row.Cells[0].Value = lasteditfieldname;
 					}
 				}
 			}
 			// Changing field type?
 			if((e.ColumnIndex == 1) && (frow != null))
 			{
 				if(OnFieldTypeChanged != null)
 					OnFieldTypeChanged(frow.Name);
 			}
 			// Changing field value?
 			if((e.ColumnIndex == 2) && (frow != null))
 			{
 				// Apply changes
 				ApplyValue(frow, row.Cells[2].Value);
 			}
 			
 			// Updated
 			if(frow != null) frow.CellChanged();
 			
 			// Update button
 			UpdateBrowseButton();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="8" endline="183">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public FlatBrowserForm(string selecttexture)
 		{
 			Cursor.Current = Cursors.WaitCursor;
 			ListViewItem item;
 			bool foundselecttexture = false;
 			long longname = Lump.MakeLongName(selecttexture ?? "");
 			
 			// Initialize
 			InitializeComponent();
 			browser.ApplySettings();
 			
 			// Update the used textures
 			General.Map.Data.UpdateUsedTextures();
 
 			// Resize columns to maximize available width
 			countcolumn.Width = COLUMN_WIDTH_COUNT;
 			namecolumn.Width = texturesets.ClientRectangle.Width - SystemInformation.VerticalScrollBarWidth - countcolumn.Width - 2;
 
 			// Fill texture sets list with normal texture sets
 			foreach(IFilledTextureSet ts in General.Map.Data.TextureSets)
 			{
 				item = texturesets.Items.Add(ts.Name);
 				item.Tag = ts;
 				item.ImageIndex = 0;
 				item.UseItemStyleForSubItems = false;
 				item.SubItems.Add(ts.Textures.Count.ToString(), item.ForeColor,
 						item.BackColor, new Font(item.Font, FontStyle.Regular));
 			}
 			foreach(IFilledTextureSet ts in General.Map.Data.TextureSets)
 			{
 				item = texturesets.Items.Add(ts.Name);
 				item.Tag = ts;
 				item.ImageIndex = 0;
 				item.UseItemStyleForSubItems = false;
 				item.SubItems.Add(ts.Textures.Count.ToString(), item.ForeColor,
 						item.BackColor, new Font(item.Font, FontStyle.Regular));
 			}
 			
 			// Add container-specific texture sets
 			foreach(ResourceTextureSet ts in General.Map.Data.ResourceTextureSets)
 			{
 				item = texturesets.Items.Add(ts.Name);
 				item.Tag = ts;
 				item.ImageIndex = 2 + ts.Location.type;
 				item.UseItemStyleForSubItems = false;
 				item.SubItems.Add(ts.Textures.Count.ToString(), item.ForeColor,
 						item.BackColor, new Font(item.Font, FontStyle.Regular));
 			}
 			foreach(ResourceTextureSet ts in General.Map.Data.ResourceTextureSets)
 			{
 				item = texturesets.Items.Add(ts.Name);
 				item.Tag = ts;
 				item.ImageIndex = 2 + ts.Location.type;
 				item.UseItemStyleForSubItems = false;
 				item.SubItems.Add(ts.Textures.Count.ToString(), item.ForeColor,
 						item.BackColor, new Font(item.Font, FontStyle.Regular));
 			}
 
 			// Add All textures set
 			item = texturesets.Items.Add(General.Map.Data.AllTextureSet.Name);
 			item.Tag = General.Map.Data.AllTextureSet;
 			item.ImageIndex = 1;
 			item.UseItemStyleForSubItems = false;
 			item.SubItems.Add(General.Map.Data.AllTextureSet.Textures.Count.ToString(),
 				item.ForeColor, item.BackColor, new Font(item.Font, FontStyle.Regular));
 
 			// Select the last one that was selected
 			string selectname = General.Settings.ReadSetting("browserwindow.textureset", "");
 			foreach(ListViewItem i in texturesets.Items)
 			{
 				if(i.Text == selectname)
 				{
 					IFilledTextureSet set = (i.Tag as IFilledTextureSet);
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 					break;
 				}
 			}
 			foreach(ListViewItem i in texturesets.Items)
 			{
 				if(i.Text == selectname)
 				{
 					IFilledTextureSet set = (i.Tag as IFilledTextureSet);
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 					break;
 				}
 			}
 
 			// If the selected texture was not found in the last-selected set, try finding it in the other sets
 			if(!foundselecttexture)
 			{
 				foreach(ListViewItem i in texturesets.Items)
 				{
 					IFilledTextureSet set = (i.Tag as IFilledTextureSet);
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 				}
 				foreach(ListViewItem i in texturesets.Items)
 				{
 					IFilledTextureSet set = (i.Tag as IFilledTextureSet);
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 				}
 			}
 
 			// Texture still now found? Then just select the last used set
 			if(!foundselecttexture)
 			{
 				foreach(ListViewItem i in texturesets.Items)
 				{
 					if(i.Text == selectname)
 					{
 						i.Selected = true;
 						foundselecttexture = true;
 						break;
 					}
 				}
 				foreach(ListViewItem i in texturesets.Items)
 				{
 					if(i.Text == selectname)
 					{
 						i.Selected = true;
 						foundselecttexture = true;
 						break;
 					}
 				}
 			}
 
 			// WARNING
 			// When you leave this line out, the list becomes very slow.
 			// Also, this does not change the item selected previously.
 			texturesets.Items[0].Selected = true;
 
 			// Texture to select when list is filled
 			selecttextureonfill = selecttexture;
 
 			// Make groups
 			usedgroup = browser.AddGroup("Used Textures");
 			availgroup = browser.AddGroup("Available Textures");
 			
 			// Keep last position and size
 			lastposition = this.Location;
 			lastsize = this.Size;
 			
 			// Position window from configuration settings
 			this.SuspendLayout();
 			/*
 			this.Location = new Point(General.Settings.ReadSetting("browserwindow.positionx", this.Location.X),
 									  General.Settings.ReadSetting("browserwindow.positiony", this.Location.Y));
 			*/
 			this.Size = new Size(General.Settings.ReadSetting("browserwindow.sizewidth", this.Size.Width),
 								 General.Settings.ReadSetting("browserwindow.sizeheight", this.Size.Height));
 			this.WindowState = (FormWindowState)General.Settings.ReadSetting("browserwindow.windowstate", (int)FormWindowState.Normal);
 			if(this.WindowState == FormWindowState.Normal) this.StartPosition = FormStartPosition.CenterParent;
 			this.ResumeLayout(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="8" endline="184">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public TextureBrowserForm(string selecttexture)
 		{
 			Cursor.Current = Cursors.WaitCursor;
 			ListViewItem item;
 			bool foundselecttexture = false;
 			long longname = Lump.MakeLongName(selecttexture ?? "");
 			
 			// Initialize
 			InitializeComponent();
 			browser.ApplySettings();
 			
 			// Update the used textures
 			General.Map.Data.UpdateUsedTextures();
 			
 			// Resize columns to maximize available width
 			countcolumn.Width = COLUMN_WIDTH_COUNT;
 			namecolumn.Width = texturesets.ClientRectangle.Width - SystemInformation.VerticalScrollBarWidth - countcolumn.Width - 2;
 			
 			// Fill texture sets list with normal texture sets
 			foreach(IFilledTextureSet ts in General.Map.Data.TextureSets)
 			{
 				item = texturesets.Items.Add(ts.Name);
 				item.Tag = ts;
 				item.ImageIndex = 0;
 				item.UseItemStyleForSubItems = false;
 				item.SubItems.Add(ts.Textures.Count.ToString(), item.ForeColor,
 						item.BackColor, new Font(item.Font, FontStyle.Regular));
 			}
 			foreach(IFilledTextureSet ts in General.Map.Data.TextureSets)
 			{
 				item = texturesets.Items.Add(ts.Name);
 				item.Tag = ts;
 				item.ImageIndex = 0;
 				item.UseItemStyleForSubItems = false;
 				item.SubItems.Add(ts.Textures.Count.ToString(), item.ForeColor,
 						item.BackColor, new Font(item.Font, FontStyle.Regular));
 			}
 
 			// Add container-specific texture sets
 			foreach(ResourceTextureSet ts in General.Map.Data.ResourceTextureSets)
 			{
 				item = texturesets.Items.Add(ts.Name);
 				item.Tag = ts;
 				item.ImageIndex = 2 + ts.Location.type;
 				item.UseItemStyleForSubItems = false;
 				item.SubItems.Add(ts.Textures.Count.ToString(), item.ForeColor,
 						item.BackColor, new Font(item.Font, FontStyle.Regular));
 			}
 			foreach(ResourceTextureSet ts in General.Map.Data.ResourceTextureSets)
 			{
 				item = texturesets.Items.Add(ts.Name);
 				item.Tag = ts;
 				item.ImageIndex = 2 + ts.Location.type;
 				item.UseItemStyleForSubItems = false;
 				item.SubItems.Add(ts.Textures.Count.ToString(), item.ForeColor,
 						item.BackColor, new Font(item.Font, FontStyle.Regular));
 			}
 			
 			// Add All textures set
 			item = texturesets.Items.Add(General.Map.Data.AllTextureSet.Name);
 			item.Tag = General.Map.Data.AllTextureSet;
 			item.ImageIndex = 1;
 			item.UseItemStyleForSubItems = false;
 			item.SubItems.Add(General.Map.Data.AllTextureSet.Textures.Count.ToString(),
 				item.ForeColor, item.BackColor, new Font(item.Font, FontStyle.Regular));
 			
 			// Select the last one that was selected
 			string selectname = General.Settings.ReadSetting("browserwindow.textureset", "");
 			foreach(ListViewItem i in texturesets.Items)
 			{
 				if(i.Text == selectname)
 				{
 					IFilledTextureSet set = (i.Tag as IFilledTextureSet);
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 					break;
 				}
 			}
 			foreach(ListViewItem i in texturesets.Items)
 			{
 				if(i.Text == selectname)
 				{
 					IFilledTextureSet set = (i.Tag as IFilledTextureSet);
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 					break;
 				}
 			}
 			
 			// If the selected texture was not found in the last-selected set, try finding it in the other sets
 			if(!foundselecttexture)
 			{
 				foreach(ListViewItem i in texturesets.Items)
 				{
 					IFilledTextureSet set = (i.Tag as IFilledTextureSet);
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 					if(foundselecttexture) break;
 				}
 				foreach(ListViewItem i in texturesets.Items)
 				{
 					IFilledTextureSet set = (i.Tag as IFilledTextureSet);
 					foreach(ImageData img in set.Textures)
 					{
 						if(img.LongName == longname)
 						{
 							i.Selected = true;
 							foundselecttexture = true;
 							break;
 						}
 					}
 					if(foundselecttexture) break;
 				}
 			}
 			
 			// Texture still now found? Then just select the last used set
 			if(!foundselecttexture)
 			{
 				foreach(ListViewItem i in texturesets.Items)
 				{
 					if(i.Text == selectname)
 					{
 						i.Selected = true;
 						foundselecttexture = true;
 						break;
 					}
 				}
 				foreach(ListViewItem i in texturesets.Items)
 				{
 					if(i.Text == selectname)
 					{
 						i.Selected = true;
 						foundselecttexture = true;
 						break;
 					}
 				}
 			}
 
 			// WARNING
 			// When you leave this line out, the list becomes very slow.
 			// Also, this does not change the item selected previously.
 			texturesets.Items[0].Selected = true;
 
 			// Texture to select when list is filled
 			selecttextureonfill = selecttexture;
 			
 			// Make groups
 			usedgroup = browser.AddGroup("Used Textures");
 			availgroup = browser.AddGroup("Available Textures");
 			
 			// Keep last position and size
 			lastposition = this.Location;
 			lastsize = this.Size;
 			
 			// Position window from configuration settings
 			this.SuspendLayout();
 			/*
 			this.Location = new Point(General.Settings.ReadSetting("browserwindow.positionx", this.Location.X),
 									  General.Settings.ReadSetting("browserwindow.positiony", this.Location.Y));
 			*/
 			this.Size = new Size(General.Settings.ReadSetting("browserwindow.sizewidth", this.Size.Width),
 								 General.Settings.ReadSetting("browserwindow.sizeheight", this.Size.Height));
 			this.WindowState = (FormWindowState)General.Settings.ReadSetting("browserwindow.windowstate", (int)FormWindowState.Normal);
 			if(this.WindowState == FormWindowState.Normal) this.StartPosition = FormStartPosition.CenterParent;
 			this.ResumeLayout(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingEditForm.cs" startline="280" endline="356">
<![CDATA[
 
 		// Apply clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			List<string> defaultflags = new List<string>();
 			string undodesc = "thing";
 
 			// Verify the tag
 			if(General.Map.FormatInterface.HasThingTag && ((tag.GetResult(0) < General.Map.FormatInterface.MinTag) || (tag.GetResult(0) > General.Map.FormatInterface.MaxTag)))
 			{
 				General.ShowWarningMessage("Thing tag must be between " + General.Map.FormatInterface.MinTag + " and " + General.Map.FormatInterface.MaxTag + ".", MessageBoxButtons.OK);
 				return;
 			}
 
 			// Verify the type
 			if(((thingtype.GetResult(0) < General.Map.FormatInterface.MinThingType) || (thingtype.GetResult(0) > General.Map.FormatInterface.MaxThingType)))
 			{
 				General.ShowWarningMessage("Thing type must be between " + General.Map.FormatInterface.MinThingType + " and " + General.Map.FormatInterface.MaxThingType + ".", MessageBoxButtons.OK);
 				return;
 			}
 
 			// Verify the action
 			if(General.Map.FormatInterface.HasThingAction && ((action.Value < General.Map.FormatInterface.MinAction) || (action.Value > General.Map.FormatInterface.MaxAction)))
 			{
 				General.ShowWarningMessage("Thing action must be between " + General.Map.FormatInterface.MinAction + " and " + General.Map.FormatInterface.MaxAction + ".", MessageBoxButtons.OK);
 				return;
 			}
 
 			// Make undo
 			if(things.Count > 1) undodesc = things.Count + " things";
 			General.Map.UndoRedo.CreateUndo("Edit " + undodesc);
 			
 			// Go for all the things
 			foreach(Thing t in things)
 			{
 				// Thing type index
 				t.Type = General.Clamp(thingtype.GetResult(t.Type), General.Map.FormatInterface.MinThingType, General.Map.FormatInterface.MaxThingType);
 				
 				// Coordination
 				t.Rotate(angle.GetResult(t.AngleDoom));
 				t.Move(t.Position.x, t.Position.y, (float)height.GetResult((int)t.Position.z));
 				
 				// Apply all flags
 				foreach(CheckBox c in flags.Checkboxes)
 				{
 					if(c.CheckState == CheckState.Checked) t.SetFlag(c.Tag.ToString(), true);
 					else if(c.CheckState == CheckState.Unchecked) t.SetFlag(c.Tag.ToString(), false);
 				}
 				foreach(CheckBox c in flags.Checkboxes)
 				{
 					if(c.CheckState == CheckState.Checked) t.SetFlag(c.Tag.ToString(), true);
 					else if(c.CheckState == CheckState.Unchecked) t.SetFlag(c.Tag.ToString(), false);
 				}
 
 				// Action/tags
 				t.Tag = tag.GetResult(t.Tag);
 				if(!action.Empty) t.Action = action.Value;
 				t.Args[0] = arg0.GetResult(t.Args[0]);
 				t.Args[1] = arg1.GetResult(t.Args[1]);
 				t.Args[2] = arg2.GetResult(t.Args[2]);
 				t.Args[3] = arg3.GetResult(t.Args[3]);
 				t.Args[4] = arg4.GetResult(t.Args[4]);
 				
 				// Custom fields
 				fieldslist.Apply(t.Fields);
 				
 				// Update settings
 				t.UpdateConfiguration();
 			}
 			foreach(Thing t in things)
 			{
 				// Thing type index
 				t.Type = General.Clamp(thingtype.GetResult(t.Type), General.Map.FormatInterface.MinThingType, General.Map.FormatInterface.MaxThingType);
 				
 				// Coordination
 				t.Rotate(angle.GetResult(t.AngleDoom));
 				t.Move(t.Position.x, t.Position.y, (float)height.GetResult((int)t.Position.z));
 				
 				// Apply all flags
 				foreach(CheckBox c in flags.Checkboxes)
 				{
 					if(c.CheckState == CheckState.Checked) t.SetFlag(c.Tag.ToString(), true);
 					else if(c.CheckState == CheckState.Unchecked) t.SetFlag(c.Tag.ToString(), false);
 				}
 
 				// Action/tags
 				t.Tag = tag.GetResult(t.Tag);
 				if(!action.Empty) t.Action = action.Value;
 				t.Args[0] = arg0.GetResult(t.Args[0]);
 				t.Args[1] = arg1.GetResult(t.Args[1]);
 				t.Args[2] = arg2.GetResult(t.Args[2]);
 				t.Args[3] = arg3.GetResult(t.Args[3]);
 				t.Args[4] = arg4.GetResult(t.Args[4]);
 				
 				// Custom fields
 				fieldslist.Apply(t.Fields);
 				
 				// Update settings
 				t.UpdateConfiguration();
 			}
 
 			// Set as defaults
 			foreach(CheckBox c in flags.Checkboxes)
 				if(c.CheckState == CheckState.Checked) defaultflags.Add(c.Tag.ToString());
 			foreach(CheckBox c in flags.Checkboxes)
 				if(c.CheckState == CheckState.Checked) defaultflags.Add(c.Tag.ToString());
 			General.Settings.DefaultThingType = thingtype.GetResult(General.Settings.DefaultThingType);
 			General.Settings.DefaultThingAngle = Angle2D.DegToRad((float)angle.GetResult((int)Angle2D.RadToDeg(General.Settings.DefaultThingAngle) - 90) + 90);
 			General.Settings.SetDefaultThingFlags(defaultflags);
 			
 			// Done
 			General.Map.IsChanged = true;
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\TextFont.cs" startline="242" endline="262">
<![CDATA[
 
 		// This calculates the size of a text string at a given scale
 		public SizeF GetTextSize(string text, float scale)
 		{
 			// Size items
 			float sizex = 0, sizey = 0;
 
 			// Get the ASCII bytes for the text
 			byte[] btext = Encoding.ASCII.GetBytes(text);
 
 			// Go for all chars in text to calculate final text size
 			foreach(byte b in btext)
 			{
 				// Add to the final size
 				sizex += characters[b].width * scale;
 				sizey = characters[b].height * scale;
 			}
 			foreach(byte b in btext)
 			{
 				// Add to the final size
 				sizex += characters[b].width * scale;
 				sizey = characters[b].height * scale;
 			}
 
 			// Return size
 			return new SizeF(sizex, sizey);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\AngleForm.cs" startline="94" endline="105">
<![CDATA[
 		
 		// This shows the dialog
 		// Returns the flags or the same flags when cancelled
 		public static int ShowDialog(IWin32Window owner, int value)
 		{
 			int result = value;
 			AngleForm f = new AngleForm();
 			f.Setup(value);
 			if(f.ShowDialog(owner) == DialogResult.OK) result = f.Value;
 			f.Dispose();
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="743" endline="759">
<![CDATA[
 
 		// This returns a specific colormap stream
 		internal Stream GetColormapData(string pname)
 		{
 			Stream colormap;
 
 			// Go for all opened containers
 			for(int i = containers.Count - 1; i >= 0; i--)
 			{
 				// This contain provides this flat?
 				colormap = containers[i].GetColormapData(pname);
 				if(colormap != null) return colormap;
 			}
 			for(int i = containers.Count - 1; i >= 0; i--)
 			{
 				// This contain provides this flat?
 				colormap = containers[i].GetColormapData(pname);
 				if(colormap != null) return colormap;
 			}
 
 			// No such patch found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="810" endline="826">
<![CDATA[
 		
 		// This returns a specific patch stream
 		internal Stream GetPatchData(string pname)
 		{
 			Stream patch;
 
 			// Go for all opened containers
 			for(int i = containers.Count - 1; i >= 0; i--)
 			{
 				// This contain provides this patch?
 				patch = containers[i].GetPatchData(pname);
 				if(patch != null) return patch;
 			}
 			for(int i = containers.Count - 1; i >= 0; i--)
 			{
 				// This contain provides this patch?
 				patch = containers[i].GetPatchData(pname);
 				if(patch != null) return patch;
 			}
 
 			// No such patch found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="827" endline="843">
<![CDATA[
 
 		// This returns a specific texture stream
 		internal Stream GetTextureData(string pname)
 		{
 			Stream patch;
 
 			// Go for all opened containers
 			for(int i = containers.Count - 1; i >= 0; i--)
 			{
 				// This contain provides this patch?
 				patch = containers[i].GetTextureData(pname);
 				if(patch != null) return patch;
 			}
 			for(int i = containers.Count - 1; i >= 0; i--)
 			{
 				// This contain provides this patch?
 				patch = containers[i].GetTextureData(pname);
 				if(patch != null) return patch;
 			}
 
 			// No such patch found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="916" endline="932">
<![CDATA[
 
 		// This returns a specific flat stream
 		internal Stream GetFlatData(string pname)
 		{
 			Stream flat;
 
 			// Go for all opened containers
 			for(int i = containers.Count - 1; i >= 0; i--)
 			{
 				// This contain provides this flat?
 				flat = containers[i].GetFlatData(pname);
 				if(flat != null) return flat;
 			}
 			for(int i = containers.Count - 1; i >= 0; i--)
 			{
 				// This contain provides this flat?
 				flat = containers[i].GetFlatData(pname);
 				if(flat != null) return flat;
 			}
 
 			// No such patch found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditMode.cs" startline="57" endline="99">
<![CDATA[
 		protected bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public bool IsDisposed { get { return isdisposed; } }
 
 		public EditModeAttribute Attributes { get { return attributes; } }
 		
 		// Unless overriden, this returns the name of this mode
 		// for checking the appropriate button on the toolbar.
 		public virtual string EditModeButtonName { get { return GetType().Name; } }
 
 		// Override this to provide a highlighted object, if applicable
 		public virtual object HighlightedObject { get { return null; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		/// <summary>
 		/// Provides basic user input interface functionality for a Doom Builder editing mode.
 		/// </summary>
 		public EditMode()
 		{
 			// Fetch attributes
 			object[] attrs = this.GetType().GetCustomAttributes(true);
 			foreach(object a in attrs)
 			{
 				if(a is EditModeAttribute)
 				{
 					attributes = (EditModeAttribute)a;
 					break;
 				}
 			}
 			foreach(object a in attrs)
 			{
 				if(a is EditModeAttribute)
 				{
 					attributes = (EditModeAttribute)a;
 					break;
 				}
 			}
 
 			// No attributes found?
 			if(attributes == null) throw new Exception("Editing mode \"" + this.GetType().Name + "\" is missing EditMode attributes!");
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ActionSelectorControl.cs" startline="99" endline="177">
<![CDATA[
 
 		// This draws an item in the combobox
 		private void list_DrawItem(object sender, DrawItemEventArgs e)
 		{
 			INumberedTitle item;
 			Brush displaybrush = SystemBrushes.WindowText;
 			Brush backbrush = SystemBrushes.Window;
 			string displayname = "";
 			int intnumber = 0;
 			
 			// Only when running
 			if(!this.DesignMode)
 			{
 				// Unknow item?
 				if(e.Index < 0)
 				{
 					// Grayed
 					displaybrush = new SolidBrush(SystemColors.GrayText);
 					backbrush = new SolidBrush(SystemColors.Window);
 
 					// Try getting integral number
 					int.TryParse(number.Text, out intnumber);
 
 					// Check what to display
 					if(number.Text.Length == 0)
 						displayname = "";
 					else if(intnumber == 0)
 						displayname = "None";
 					else if((generalizedcategories != null) && GameConfiguration.IsGeneralized(intnumber, generalizedcategories))
 						displayname = "Generalized (" + General.Map.Config.GetGeneralizedActionCategory(intnumber) + ")";
 					else
 						displayname = "Unknown";
 				}
 				// In the display part of the combobox?
 				else if((e.State & DrawItemState.ComboBoxEdit) != 0)
 				{
 					// Show without number
 					item = (INumberedTitle)list.Items[e.Index];
 					displayname = item.Title.Trim();
 
 					// Determine colors to use
 					if(item.Index == 0)
 					{
 						// Grayed
 						displaybrush = new SolidBrush(SystemColors.GrayText);
 						backbrush = new SolidBrush(SystemColors.Window);
 					}
 					else
 					{
 						// Normal color
 						displaybrush = new SolidBrush(list.ForeColor);
 						backbrush = new SolidBrush(SystemColors.Window);
 					}
 				}
 				else
 				{
 					// Use number and description
 					item = (INumberedTitle)list.Items[e.Index];
 					displayname = item.Index + NUMBER_SEPERATOR + item.Title;
 
 					// Determine colors to use
 					if((e.State & DrawItemState.Focus) != 0)
 					{
 						displaybrush = new SolidBrush(SystemColors.HighlightText);
 						backbrush = new SolidBrush(SystemColors.Highlight);
 					}
 					else
 					{
 						displaybrush = new SolidBrush(list.ForeColor);
 						backbrush = new SolidBrush(SystemColors.Window);
 					}
 				}
 				
 			}
 
 			// Draw item
 			e.Graphics.FillRectangle(backbrush, e.Bounds);
 			e.Graphics.DrawString(displayname, list.Font, displaybrush, e.Bounds.X, e.Bounds.Y);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ZDTextParser.cs" startline="189" endline="270">
<![CDATA[
 		
 		// This reads a token (all sequential non-whitespace characters or a single character)
 		// Returns null when the end of the stream has been reached
 		protected internal string ReadToken()
 		{
 			string token = "";
 			bool quotedstring = false;
 			
 			// Return null when the end of the stream has been reached
 			if(datastream.Position == datastream.Length) return null;
 			
 			// Start reading
 			char c = (char)datareader.ReadByte();
 			while(!IsWhitespace(c) || quotedstring || IsSpecialToken(c))
 			{
 				// Special token?
 				if(!quotedstring && IsSpecialToken(c))
 				{
 					// Not reading a token yet?
 					if(token.Length == 0)
 					{
 						// This is our whole token
 						token += c;
 						break;
 					}
 					else
 					{
 						// This is a new token and shouldn't be read now
 						// Go one character back so we can read this token again
 						datastream.Seek(-1, SeekOrigin.Current);
 						break;
 					}
 				}
 				else
 				{
 					// Quote?
 					if(c == '"')
 					{
 						// Quote to end the string?
 						if(quotedstring) quotedstring = false;
 						
 						// First character is a quote?
 						if(token.Length == 0) quotedstring = true;
 						
 						token += c;
 					}
 					// Potential comment?
 					else if((c == '/') && !quotedstring)
 					{
 						// Check the next byte
 						if(datastream.Position == datastream.Length) return token;
 						char c2 = (char)datareader.ReadByte();
 						if((c2 == '/') || (c2 == '*'))
 						{
 							// This is a comment start, so the token ends here
 							// Go two characters back so we can read this comment again
 							datastream.Seek(-2, SeekOrigin.Current);
 							break;
 						}
 						else
 						{
 							// Not a comment
 							// Go one character back so we can read this char again
 							datastream.Seek(-1, SeekOrigin.Current);
 							token += c;
 						}
 					}
 					else
 					{
 						token += c;
 					}
 				}
 				
 				// Next character
 				if(datastream.Position < datastream.Length)
 					c = (char)datareader.Read();
 				else
 					break;
 			}
 			while(!IsWhitespace(c) || quotedstring || IsSpecialToken(c))
 			{
 				// Special token?
 				if(!quotedstring && IsSpecialToken(c))
 				{
 					// Not reading a token yet?
 					if(token.Length == 0)
 					{
 						// This is our whole token
 						token += c;
 						break;
 					}
 					else
 					{
 						// This is a new token and shouldn't be read now
 						// Go one character back so we can read this token again
 						datastream.Seek(-1, SeekOrigin.Current);
 						break;
 					}
 				}
 				else
 				{
 					// Quote?
 					if(c == '"')
 					{
 						// Quote to end the string?
 						if(quotedstring) quotedstring = false;
 						
 						// First character is a quote?
 						if(token.Length == 0) quotedstring = true;
 						
 						token += c;
 					}
 					// Potential comment?
 					else if((c == '/') && !quotedstring)
 					{
 						// Check the next byte
 						if(datastream.Position == datastream.Length) return token;
 						char c2 = (char)datareader.ReadByte();
 						if((c2 == '/') || (c2 == '*'))
 						{
 							// This is a comment start, so the token ends here
 							// Go two characters back so we can read this comment again
 							datastream.Seek(-2, SeekOrigin.Current);
 							break;
 						}
 						else
 						{
 							// Not a comment
 							// Go one character back so we can read this char again
 							datastream.Seek(-1, SeekOrigin.Current);
 							token += c;
 						}
 					}
 					else
 					{
 						token += c;
 					}
 				}
 				
 				// Next character
 				if(datastream.Position < datastream.Length)
 					c = (char)datareader.Read();
 				else
 					break;
 			}
 			
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ProgramConfiguration.cs" startline="457" endline="594">
<![CDATA[
 		
 		// This attempts to find the default drawing settings
 		public void FindDefaultDrawSettings()
 		{
 			bool foundone;
 			
 			// Only possible when a map is loaded
 			if(General.Map == null) return;
 			
 			// Default texture missing?
 			if((defaulttexture == null) || defaulttexture.StartsWith("-"))
 			{
 				// Find default texture from map
 				foundone = false;
 				foreach(Sidedef sd in General.Map.Map.Sidedefs)
 				{
 					if(!sd.MiddleTexture.StartsWith("-"))
 					{
 						defaulttexture = sd.MiddleTexture;
 						if(General.Map.Data.GetTextureExists(defaulttexture))
 						{
 							foundone = true;
 							break;
 						}
 					}
 				}
 				foreach(Sidedef sd in General.Map.Map.Sidedefs)
 				{
 					if(!sd.MiddleTexture.StartsWith("-"))
 					{
 						defaulttexture = sd.MiddleTexture;
 						if(General.Map.Data.GetTextureExists(defaulttexture))
 						{
 							foundone = true;
 							break;
 						}
 					}
 				}
 				
 				// Not found yet?
 				if(!foundone)
 				{
 					// Pick the first STARTAN from the list.
 					// I love the STARTAN texture as default for some reason.
 					foreach(string s in General.Map.Data.TextureNames)
 					{
 						if(s.StartsWith("STARTAN"))
 						{
 							foundone = true;
 							defaulttexture = s;
 							break;
 						}
 					}
 					foreach(string s in General.Map.Data.TextureNames)
 					{
 						if(s.StartsWith("STARTAN"))
 						{
 							foundone = true;
 							defaulttexture = s;
 							break;
 						}
 					}
 					
 					// Otherwise just pick the first
 					if(!foundone)
 					{
 						if(General.Map.Data.TextureNames.Count > 1)
 							defaulttexture = General.Map.Data.TextureNames[1];
 					}
 				}
 			}
 
 			// Default floor missing?
 			if((defaultfloortexture == null) || (defaultfloortexture.Length == 0))
 			{
 				// Find default texture from map
 				foundone = false;
 				if(General.Map.Map.Sectors.Count > 0)
 				{
 					// Find one that is known
 					foreach(Sector s in General.Map.Map.Sectors)
 					{
 						defaultfloortexture = s.FloorTexture;
 						if(General.Map.Data.GetFlatExists(defaultfloortexture))
 						{
 							foundone = true;
 							break;
 						}
 					}
 					foreach(Sector s in General.Map.Map.Sectors)
 					{
 						defaultfloortexture = s.FloorTexture;
 						if(General.Map.Data.GetFlatExists(defaultfloortexture))
 						{
 							foundone = true;
 							break;
 						}
 					}
 				}
 				
 				// Pick the first FLOOR from the list.
 				if(!foundone)
 				{
 					foreach(string s in General.Map.Data.FlatNames)
 					{
 						if(s.StartsWith("FLOOR"))
 						{
 							foundone = true;
 							defaultfloortexture = s;
 							break;
 						}
 					}
 					foreach(string s in General.Map.Data.FlatNames)
 					{
 						if(s.StartsWith("FLOOR"))
 						{
 							foundone = true;
 							defaultfloortexture = s;
 							break;
 						}
 					}
 				}
 				
 				// Otherwise just pick the first
 				if(!foundone)
 				{
 					if(General.Map.Data.FlatNames.Count > 0)
 						defaultfloortexture = General.Map.Data.FlatNames[0];
 				}
 			}
 			
 			// Default ceiling missing?
 			if((defaultceiltexture == null) || (defaultceiltexture.Length == 0))
 			{
 				// Find default texture from map
 				foundone = false;
 				if(General.Map.Map.Sectors.Count > 0)
 				{
 					// Find one that is known
 					foreach(Sector s in General.Map.Map.Sectors)
 					{
 						defaultceiltexture = s.CeilTexture;
 						if(General.Map.Data.GetFlatExists(defaultceiltexture))
 						{
 							foundone = true;
 							break;
 						}
 					}
 					foreach(Sector s in General.Map.Map.Sectors)
 					{
 						defaultceiltexture = s.CeilTexture;
 						if(General.Map.Data.GetFlatExists(defaultceiltexture))
 						{
 							foundone = true;
 							break;
 						}
 					}
 				}
 				
 				// Pick the first CEIL from the list.
 				if(!foundone)
 				{
 					foreach(string s in General.Map.Data.FlatNames)
 					{
 						if(s.StartsWith("CEIL"))
 						{
 							foundone = true;
 							defaultceiltexture = s;
 							break;
 						}
 					}
 					foreach(string s in General.Map.Data.FlatNames)
 					{
 						if(s.StartsWith("CEIL"))
 						{
 							foundone = true;
 							defaultceiltexture = s;
 							break;
 						}
 					}
 				}
 				
 				// Otherwise just pick the first
 				if(!foundone)
 				{
 					if(General.Map.Data.FlatNames.Count > 1)
 						defaultceiltexture = General.Map.Data.FlatNames[1];
 				}
 			}
 
 			// Texture names may not be null
 			if((defaulttexture == null) || (defaulttexture == "")) defaulttexture = "-";
 			if((defaultfloortexture == null) || (defaultfloortexture == "")) defaultfloortexture = "-";
 			if((defaultceiltexture == null) || (defaultceiltexture == "")) defaultceiltexture = "-";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2888" endline="2895">
<![CDATA[
 
 		// This converts UDMF fields back into flags and activations
 		// NOTE
 		internal void TranslateFromUDMF()
 		{
 			foreach(Linedef l in linedefs) if(l.Marked) l.TranslateFromUDMF();
 			foreach(Thing t in things) if(t.Marked) t.TranslateFromUDMF();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="239" endline="259">
<![CDATA[
 
 		// This finds the first file that has the specified name, regardless of file extension, and is in the given path
 		public string GetFirstFile(string path, string title, bool subdirectories)
 		{
 			title = title.ToLowerInvariant();
 			path = CorrectPath(path).ToLowerInvariant();
 			if(subdirectories)
 			{
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].filetitle == title) && entries[i].path.StartsWith(path))
 						return entries[i].filepathname;
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].filetitle == title) && entries[i].path.StartsWith(path))
 						return entries[i].filepathname;
 			}
 			else
 			{
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].filetitle == title) && (entries[i].path == path))
 						return entries[i].filepathname;
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].filetitle == title) && (entries[i].path == path))
 						return entries[i].filepathname;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DirectoryFilesList.cs" startline="218" endline="238">
<![CDATA[
 
 		// This finds the first file that has the specified name and extension
 		public string GetFirstFile(string title, bool subdirectories, string extension)
 		{
 			title = title.ToLowerInvariant();
 			extension = extension.ToLowerInvariant();
 			if(subdirectories)
 			{
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].filetitle == title) && (entries[i].extension == extension))
 						return entries[i].filepathname;
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].filetitle == title) && (entries[i].extension == extension))
 						return entries[i].filepathname;
 			}
 			else
 			{
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].filetitle == title) && (entries[i].path.Length == 0) && (entries[i].extension == extension))
 						return entries[i].filepathname;
 				for(int i = 0; i < entries.Length; i++)
 					if((entries[i].filetitle == title) && (entries[i].path.Length == 0) && (entries[i].extension == extension))
 						return entries[i].filepathname;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="740" endline="751">
<![CDATA[
 
 		#endregion
 
 		// Help
 		private void PreferencesForm_HelpRequested(object sender, HelpEventArgs hlpevent)
 		{
 			if(!actionkey.Focused)
 			{
 				General.ShowHelp("w_preferences.html");
 				hlpevent.Handled = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="700" endline="707">
<![CDATA[
 		
 		// This returns the closest coordinates ON the line
 		public Vector2D NearestOnLine(Vector2D pos)
 		{
 			float u = Line2D.GetNearestOnLine(start.Position, end.Position, pos);
 			if(u < 0f) u = 0f; else if(u > 1f) u = 1f;
 			return Line2D.GetCoordinatesAt(start.Position, end.Position, u);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="70" endline="83">
<![CDATA[
 		
 		// Call this to initialize this class
 		protected virtual void Initialize()
 		{
 			// Load all WAD files in the root as WAD resources
 			string[] wadfiles = GetFilesWithExt("", "wad", false);
 			wads = new List<WADReader>(wadfiles.Length);
 			foreach(string w in wadfiles)
 			{
 				string tempfile = CreateTempFile(w);
 				DataLocation wdl = new DataLocation(DataLocation.RESOURCE_WAD, tempfile, false, false, true);
 				wads.Add(new WADReader(wdl));
 			}
 			foreach(string w in wadfiles)
 			{
 				string tempfile = CreateTempFile(w);
 				DataLocation wdl = new DataLocation(DataLocation.RESOURCE_WAD, tempfile, false, false, true);
 				wads.Add(new WADReader(wdl));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1041" endline="1049">
<![CDATA[
 		
 		/// <summary>
 		/// This updates the cache of all elements that is required after a configuration or settings change.
 		/// </summary>
 		public void UpdateConfiguration()
 		{
 			// Update all things
 			foreach(Thing t in things) t.UpdateConfiguration();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="364" endline="406">
<![CDATA[
 		
 		// This finds a lump by name, returns -1 when not found
 		public int FindLumpIndex(string name, int start, int end)
 		{
 			byte[] fixedname;
 			long longname = Lump.MakeLongName(name);
 			
 			// Fix end when it exceeds length
 			if(end > (lumps.Count - 1)) end = lumps.Count - 1;
 
 			// Make sure name is in uppercase
 			name = name.ToUpperInvariant();
 
 			// Make fixed name
 			fixedname = Lump.MakeFixedName(name, ENCODING);
 
 			// Loop through the lumps
 			for(int i = start; i <= end; i++)
 			{
 				/*
 				// Check if first byte matches
 				if(lumps[i].FixedName[0] == fixedname[0])
 				{
 					// Check if the lump name matches
 					if(lumps[i].Name.StartsWith(name, false, CultureInfo.InvariantCulture))
 					{
 						// Found the lump!
 						return i;
 					}
 				}
 				*/
 				
 				// Check if the lump name matches
 				if(lumps[i].LongName == longname)
 				{
 					// Found the lump!
 					return i;
 				}
 			}
 			for(int i = start; i <= end; i++)
 			{
 				/*
 				// Check if first byte matches
 				if(lumps[i].FixedName[0] == fixedname[0])
 				{
 					// Check if the lump name matches
 					if(lumps[i].Name.StartsWith(name, false, CultureInfo.InvariantCulture))
 					{
 						// Found the lump!
 						return i;
 					}
 				}
 				*/
 				
 				// Check if the lump name matches
 				if(lumps[i].LongName == longname)
 				{
 					// Found the lump!
 					return i;
 				}
 			}
 
 			// Nothing found
 			return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="708" endline="729">
<![CDATA[
 
 		// This returns the shortest distance from given coordinates to line
 		public float SafeDistanceToSq(Vector2D p, bool bounded)
 		{
 			Vector2D v1 = start.Position;
 			Vector2D v2 = end.Position;
 
 			// Calculate intersection offset
 			float u = ((p.x - v1.x) * (v2.x - v1.x) + (p.y - v1.y) * (v2.y - v1.y)) * lengthsqinv;
 
 			// Limit intersection offset to the line
 			if(bounded) if(u < lengthinv) u = lengthinv; else if(u > (1f - lengthinv)) u = 1f - lengthinv;
 
 			// Calculate intersection point
 			Vector2D i = v1 + u * (v2 - v1);
 
 			// Return distance between intersection and point
 			// which is the shortest distance to the line
 			float ldx = p.x - i.x;
 			float ldy = p.y - i.y;
 			return ldx * ldx + ldy * ldy;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\SurfaceEntry.cs" startline="85" endline="103">
<![CDATA[
 
 		// This calculates the bounding box from the vertices
 		public void UpdateBBox()
 		{
 			float left = float.MaxValue;
 			float right = float.MinValue;
 			float top = float.MaxValue;
 			float bottom = float.MinValue;
 			
 			for(int i = 0; i < floorvertices.Length; i++)
 			{
 				if(floorvertices[i].x < left) left = floorvertices[i].x;
 				if(floorvertices[i].x > right) right = floorvertices[i].x;
 				if(floorvertices[i].y < top) top = floorvertices[i].y;
 				if(floorvertices[i].y > bottom) bottom = floorvertices[i].y;
 			}
 			for(int i = 0; i < floorvertices.Length; i++)
 			{
 				if(floorvertices[i].x < left) left = floorvertices[i].x;
 				if(floorvertices[i].x > right) right = floorvertices[i].x;
 				if(floorvertices[i].y < top) top = floorvertices[i].y;
 				if(floorvertices[i].y > bottom) bottom = floorvertices[i].y;
 			}
 
 			bbox = new RectangleF(left, top, right - left, bottom - top);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2597" endline="2672">
<![CDATA[
 
 		/// <summary>This calls a function for all tag fields in the marked or unmarked geometry. The obj parameter can be anything you wish to pass on to your TagHandler function.</summary>
 		public void ForAllTags<T>(TagHandler<T> handler, bool marked, T obj)
 		{
 			// Remove tags from sectors
 			foreach(Sector s in sectors)
 				if(s.Marked == marked)
 				{
 					int tag = s.Tag;
 					handler(s, false, UniversalType.SectorTag, ref tag, obj);
 					if(tag != s.Tag) s.Tag = tag;
 				}
 			foreach(Sector s in sectors)
 				if(s.Marked == marked)
 				{
 					int tag = s.Tag;
 					handler(s, false, UniversalType.SectorTag, ref tag, obj);
 					if(tag != s.Tag) s.Tag = tag;
 				}
 			
 			// Remove tags from things
 			if(General.Map.FormatInterface.HasThingTag)
 			{
 				foreach(Thing t in things)
 					if(t.Marked == marked)
 					{
 						int tag = t.Tag;
 						handler(t, false, UniversalType.ThingTag, ref tag, obj);
 						if(tag != t.Tag) t.Tag = tag;
 					}
 				foreach(Thing t in things)
 					if(t.Marked == marked)
 					{
 						int tag = t.Tag;
 						handler(t, false, UniversalType.ThingTag, ref tag, obj);
 						if(tag != t.Tag) t.Tag = tag;
 					}
 			}
 
 			// Remove tags from thing actions
 			if(General.Map.FormatInterface.HasThingAction &&
 			   General.Map.FormatInterface.HasActionArgs)
 			{
 				foreach(Thing t in things)
 				{
 					if(t.Marked == marked)
 					{
 						LinedefActionInfo info = General.Map.Config.GetLinedefActionInfo(t.Action);
 						for(int i = 0; i < Thing.NUM_ARGS; i++)
 							if(info.Args[i].Used && CheckIsTagType(info.Args[i].Type))
 							{
 								int tag = t.Args[i];
 								handler(t, true, (UniversalType)(info.Args[i].Type), ref tag, obj);
 								if(tag != t.Args[i]) t.Args[i] = tag;
 							}
 						for(int i = 0; i < Thing.NUM_ARGS; i++)
 							if(info.Args[i].Used && CheckIsTagType(info.Args[i].Type))
 							{
 								int tag = t.Args[i];
 								handler(t, true, (UniversalType)(info.Args[i].Type), ref tag, obj);
 								if(tag != t.Args[i]) t.Args[i] = tag;
 							}
 					}
 				}
 				foreach(Thing t in things)
 				{
 					if(t.Marked == marked)
 					{
 						LinedefActionInfo info = General.Map.Config.GetLinedefActionInfo(t.Action);
 						for(int i = 0; i < Thing.NUM_ARGS; i++)
 							if(info.Args[i].Used && CheckIsTagType(info.Args[i].Type))
 							{
 								int tag = t.Args[i];
 								handler(t, true, (UniversalType)(info.Args[i].Type), ref tag, obj);
 								if(tag != t.Args[i]) t.Args[i] = tag;
 							}
 					}
 				}
 			}
 
 			// Remove tags from linedefs
 			if(General.Map.FormatInterface.HasLinedefTag)
 			{
 				foreach(Linedef l in linedefs)
 					if(l.Marked == marked)
 					{
 						int tag = l.Tag;
 						handler(l, false, UniversalType.LinedefTag, ref tag, obj);
 						if(tag != l.Tag) l.Tag = tag;
 					}
 				foreach(Linedef l in linedefs)
 					if(l.Marked == marked)
 					{
 						int tag = l.Tag;
 						handler(l, false, UniversalType.LinedefTag, ref tag, obj);
 						if(tag != l.Tag) l.Tag = tag;
 					}
 			}
 
 			// Remove tags from linedef actions
 			if(General.Map.FormatInterface.HasActionArgs)
 			{
 				foreach(Linedef l in linedefs)
 				{
 					if(l.Marked == marked)
 					{
 						LinedefActionInfo info = General.Map.Config.GetLinedefActionInfo(l.Action);
 						for(int i = 0; i < Linedef.NUM_ARGS; i++)
 							if(info.Args[i].Used && CheckIsTagType(info.Args[i].Type))
 							{
 								int tag = l.Args[i];
 								handler(l, true, (UniversalType)(info.Args[i].Type), ref tag, obj);
 								if(tag != l.Args[i]) l.Args[i] = tag;
 							}
 						for(int i = 0; i < Linedef.NUM_ARGS; i++)
 							if(info.Args[i].Used && CheckIsTagType(info.Args[i].Type))
 							{
 								int tag = l.Args[i];
 								handler(l, true, (UniversalType)(info.Args[i].Type), ref tag, obj);
 								if(tag != l.Args[i]) l.Args[i] = tag;
 							}
 					}
 				}
 				foreach(Linedef l in linedefs)
 				{
 					if(l.Marked == marked)
 					{
 						LinedefActionInfo info = General.Map.Config.GetLinedefActionInfo(l.Action);
 						for(int i = 0; i < Linedef.NUM_ARGS; i++)
 							if(info.Args[i].Used && CheckIsTagType(info.Args[i].Type))
 							{
 								int tag = l.Args[i];
 								handler(l, true, (UniversalType)(info.Args[i].Type), ref tag, obj);
 								if(tag != l.Args[i]) l.Args[i] = tag;
 							}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="352" endline="404">
<![CDATA[
 		private object ReadAnySetting(IDictionary dic, string file, int line, string setting, object defaultsetting, string pathseperator)
 		{
 			IDictionary cs = null;
 			
 			// Split the path in an array
 			string[] keys = setting.Split(pathseperator.ToCharArray());
 			
 			// Get the root item
 			object item = dic;
 			
 			// Go for each item
 			for(int i = 0; i < keys.Length; i++)
 			{
 				// Check if the current item is of ConfigStruct type
 				if(item is IDictionary)
 				{
 					// Check if the key is valid
 					if(ValidateKey(null, keys[i].Trim(), file, line) == true)
 					{
 						// Cast to ConfigStruct
 						cs = (IDictionary)item;
 						
 						// Check if the requested item exists
 						if(cs.Contains(keys[i]) == true)
 						{
 							// Set the item to the next item
 							item = cs[keys[i];
 						}
 						else
 						{
 							// Key not found
 							// return default setting
 							return defaultsetting;
 						}
 					}
 					else
 					{
 						// Invalid key in path
 						// return default setting
 						return defaultsetting;
 					}
 				}
 				else
 				{
 					// Unable to go any further
 					// return default setting
 					return defaultsetting;
 				}
 			}
 			for(int i = 0; i < keys.Length; i++)
 			{
 				// Check if the current item is of ConfigStruct type
 				if(item is IDictionary)
 				{
 					// Check if the key is valid
 					if(ValidateKey(null, keys[i].Trim(), file, line) == true)
 					{
 						// Cast to ConfigStruct
 						cs = (IDictionary)item;
 						
 						// Check if the requested item exists
 						if(cs.Contains(keys[i]) == true)
 						{
 							// Set the item to the next item
 							item = cs[keys[i];
 						}
 						else
 						{
 							// Key not found
 							// return default setting
 							return defaultsetting;
 						}
 					}
 					else
 					{
 						// Invalid key in path
 						// return default setting
 						return defaultsetting;
 					}
 				}
 				else
 				{
 					// Unable to go any further
 					// return default setting
 					return defaultsetting;
 				}
 			}
 			
 			// Return the item
 			return item;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="393" endline="405">
<![CDATA[
 		
 		// This enabled automatic panning, if preferred
 		protected void EnableAutoPanning()
 		{
 			if(General.Settings.AutoScrollSpeed > 0)
 			{
 				if(!autopanenabled)
 				{
 					autopanenabled = true;
 					General.MainWindow.EnableProcessing();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="232" endline="262">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== General
 
 		// Editing mode changed!
 		internal void EditModeChanged()
 		{
 			// Check appropriate button on interface
 			// And show the mode name
 			if(General.Editing.Mode != null)
 			{
 				General.MainWindow.CheckEditModeButton(General.Editing.Mode.EditModeButtonName);
 				General.MainWindow.DisplayModeName(General.Editing.Mode.Attributes.DisplayName);
 			}
 			else
 			{
 				General.MainWindow.CheckEditModeButton("");
 				General.MainWindow.DisplayModeName("");
 			}
 
 			// View mode only matters in classic editing modes
 			for(int i = 0; i < Renderer2D.NUM_VIEW_MODES; i++)
 			{
 				viewmodesitems[i].Enabled = (General.Editing.Mode is ClassicMode);
 				viewmodesbuttons[i].Enabled = (General.Editing.Mode is ClassicMode);
 			}
 			for(int i = 0; i < Renderer2D.NUM_VIEW_MODES; i++)
 			{
 				viewmodesitems[i].Enabled = (General.Editing.Mode is ClassicMode);
 				viewmodesbuttons[i].Enabled = (General.Editing.Mode is ClassicMode);
 			}
 
 			UpdateEditMenu();
 			UpdatePrefabsMenu();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="375" endline="447">
<![CDATA[
 		
 		/// <summary>
 		/// This finds the closest path from the beginning of a line to the end of the line.
 		/// When turnatends is true, the algorithm will continue at the other side of the
 		/// line when a dead end has been reached. Returns null when no path could be found.
 		/// </summary>
 		public static List<LinedefSide> FindClosestPath(Linedef startline, bool startfront, Linedef endline, bool endfront, bool turnatends)
 		{
 			List<LinedefSide> path = new List<LinedefSide>();
 			Dictionary<Linedef, int> tracecount = new Dictionary<Linedef, int>();
 			Linedef nextline = startline;
 			bool nextfront = startfront;
 
 			do
 			{
 				// Add line to path
 				path.Add(new LinedefSide(nextline, nextfront));
 				if(!tracecount.ContainsKey(nextline)) tracecount.Add(nextline, 1); else tracecount[nextline]++;
 
 				// Determine next vertex to use
 				Vertex v = nextfront ? nextline.End 
 
 				// Get list of linedefs and sort by angle
 				List<Linedef> lines = new List<Linedef>(v.Linedefs);
 				LinedefAngleSorter sorter = new LinedefAngleSorter(nextline, nextfront, v);
 				lines.Sort(sorter);
 
 				// Source line is the only one?
 				if(lines.Count == 1)
 				{
 					// Are we allowed to trace along this line again?
 					if(turnatends && (!tracecount.ContainsKey(nextline) || (tracecount[nextline] < 3)))
 					{
 						// Turn around and go back along the other side of the line
 						nextfront = !nextfront;
 					}
 					else
 					{
 						// No more lines, trace ends here
 						path = null;
 					}
 				}
 				else
 				{
 					// Trace along the next line
 					Linedef prevline = nextline;
 					if(lines[0] == nextline) nextline = lines[1]; else nextline = lines[0];
 
 					// Are we allowed to trace this line again?
 					if(!tracecount.ContainsKey(nextline) || (tracecount[nextline] < 3))
 					{
 						// Check if front side changes
 						if((prevline.Start == nextline.Start) ||
 						   (prevline.End == nextline.End)) nextfront = !nextfront;
 					}
 					else
 					{
 						// No more lines, trace ends here
 						path = null;
 					}
 				}
 			}
 			// Continue as long as we have not reached the start yet
 			// or we have no next line to trace
 			while((path != null) && ((nextline != endline) || (nextfront != endfront)));
 
 			// If start and front are not the same, add the end to the list also
 			if((path != null) && ((startline != endline) || (startfront != endfront)))
 				path.Add(new LinedefSide(endline, endfront));
 			
 			// Return path (null when trace failed)
 			return path;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="243" endline="403">
<![CDATA[
 
 		// This sets up the script editor with a script configuration
 		public void SetupStyles(ScriptConfiguration config)
 		{
 			Stream lexersdata;
 			StreamReader lexersreader;
 			Configuration lexercfg = new Configuration();
 			SortedList<string, string> autocompletelist;
 			string[] resnames;
 			int imageindex;
 			
 			// Make collections
 			stylelookup = new Dictionary<int, ScriptStyleType>();
 			autocompletelist = new SortedList<string, string>(StringComparer.Ordinal);
 			
 			// Keep script configuration
 			if(scriptconfig != config) scriptconfig = config;
 			
 			// Find a resource named Lexers.cfg
 			resnames = General.ThisAssembly.GetManifestResourceNames();
 			foreach(string rn in resnames)
 			{
 				// Found one?
 				if(rn.EndsWith(LEXERS_RESOURCE, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					lexersdata = General.ThisAssembly.GetManifestResourceStream(rn);
 					lexersreader = new StreamReader(lexersdata, Encoding.ASCII);
 
 					// Load configuration from stream
 					lexercfg.InputConfiguration(lexersreader.ReadToEnd());
 
 					// Done with the resource
 					lexersreader.Dispose();
 					lexersdata.Dispose();
 				}
 			}
 			foreach(string rn in resnames)
 			{
 				// Found one?
 				if(rn.EndsWith(LEXERS_RESOURCE, StringComparison.InvariantCultureIgnoreCase))
 				{
 					// Get a stream from the resource
 					lexersdata = General.ThisAssembly.GetManifestResourceStream(rn);
 					lexersreader = new StreamReader(lexersdata, Encoding.ASCII);
 
 					// Load configuration from stream
 					lexercfg.InputConfiguration(lexersreader.ReadToEnd());
 
 					// Done with the resource
 					lexersreader.Dispose();
 					lexersdata.Dispose();
 				}
 			}
 			
 			// Check if specified lexer exists and set the lexer to use
 			string lexername = "lexer" + scriptconfig.Lexer.ToString(CultureInfo.InvariantCulture);
 			if(!lexercfg.SettingExists(lexername)) throw new InvalidOperationException("Unknown lexer " + scriptconfig.Lexer + " specified in script configuration!");
 			scriptedit.Lexer = scriptconfig.Lexer;
 			
 			// Set the default style and settings
 			scriptedit.StyleSetFont(DEFAULT_STYLE, General.Settings.ScriptFontName);
 			scriptedit.StyleSetSize(DEFAULT_STYLE, General.Settings.ScriptFontSize);
 			scriptedit.StyleSetBold(DEFAULT_STYLE, General.Settings.ScriptFontBold);
 			scriptedit.StyleSetItalic(DEFAULT_STYLE, false);
 			scriptedit.StyleSetUnderline(DEFAULT_STYLE, false);
 			scriptedit.StyleSetCase(DEFAULT_STYLE, ScriptCaseVisible.Mixed);
 			scriptedit.StyleSetFore(DEFAULT_STYLE, General.Colors.PlainText.ToColorRef());
 			scriptedit.StyleSetBack(DEFAULT_STYLE, General.Colors.ScriptBackground.ToColorRef());
 			scriptedit.CaretPeriod = SystemInformation.CaretBlinkTime;
 			scriptedit.CaretFore = General.Colors.ScriptBackground.Inverse().ToColorRef();
 			scriptedit.StyleBits = 7;
 			
 			// These don't work?
 			scriptedit.TabWidth = General.Settings.ScriptTabWidth;
 			scriptedit.IsUseTabs = false;
 			scriptedit.IsTabIndents = true;
 			scriptedit.Indent = General.Settings.ScriptTabWidth;
 			scriptedit.IsBackSpaceUnIndents = true;
 			
 			// This applies the default style to all styles
 			scriptedit.StyleClearAll();
 
 			// Set the code page to use
 			scriptedit.CodePage = scriptconfig.CodePage;
 
 			// Set the default to something normal (this is used by the autocomplete list)
 			scriptedit.StyleSetFont(DEFAULT_STYLE, this.Font.Name);
 			scriptedit.StyleSetBold(DEFAULT_STYLE, this.Font.Bold);
 			scriptedit.StyleSetItalic(DEFAULT_STYLE, this.Font.Italic);
 			scriptedit.StyleSetUnderline(DEFAULT_STYLE, this.Font.Underline);
 			scriptedit.StyleSetSize(DEFAULT_STYLE, (int)Math.Round(this.Font.SizeInPoints));
 			
 			// Set style for linenumbers and margins
 			scriptedit.StyleSetBack((int)ScriptStylesCommon.LineNumber, General.Colors.ScriptBackground.ToColorRef());
 			
 			// Clear all keywords
 			for(int i = 0; i < 9; i++) scriptedit.KeyWords(i, null);
 			
 			// Now go for all elements in the lexer configuration
 			// We are looking for the numeric keys, because these are the
 			// style index to set and the value is our ScriptStyleType
 			IDictionary dic = lexercfg.ReadSetting(lexername, new Hashtable());
 			foreach(DictionaryEntry de in dic)
 			{
 				// Check if this is a numeric key
 				int stylenum = -1;
 				if(int.TryParse(de.Key.ToString(), out stylenum))
 				{
 					// Add style to lookup table
 					stylelookup.Add(stylenum, (ScriptStyleType)(int)de.Value);
 					
 					// Apply color to style
 					int colorindex = 0;
 					switch((ScriptStyleType)(int)de.Value)
 					{
 						case ScriptStyleType.PlainText
 						case ScriptStyleType.Comment
 						case ScriptStyleType.Constant
 						case ScriptStyleType.Keyword
 						case ScriptStyleType.LineNumber
 						case ScriptStyleType.Literal
 						default
 					}
 					scriptedit.StyleSetFore(stylenum, General.Colors.Colors[colorindex].ToColorRef());
 				}
 			}
 			foreach(DictionaryEntry de in dic)
 			{
 				// Check if this is a numeric key
 				int stylenum = -1;
 				if(int.TryParse(de.Key.ToString(), out stylenum))
 				{
 					// Add style to lookup table
 					stylelookup.Add(stylenum, (ScriptStyleType)(int)de.Value);
 					
 					// Apply color to style
 					int colorindex = 0;
 					switch((ScriptStyleType)(int)de.Value)
 					{
 						case ScriptStyleType.PlainText
 						case ScriptStyleType.Comment
 						case ScriptStyleType.Constant
 						case ScriptStyleType.Keyword
 						case ScriptStyleType.LineNumber
 						case ScriptStyleType.Literal
 						default
 					}
 					scriptedit.StyleSetFore(stylenum, General.Colors.Colors[colorindex].ToColorRef());
 				}
 			}
 			
 			// Create the keywords list and apply it
 			imageindex = (int)ImageIndex.ScriptKeyword;
 			int keywordsindex = lexercfg.ReadSetting(lexername + ".keywordsindex", -1);
 			if(keywordsindex > -1)
 			{
 				StringBuilder keywordslist = new StringBuilder("");
 				foreach(string k in scriptconfig.Keywords)
 				{
 					if(keywordslist.Length > 0) keywordslist.Append(" ");
 					keywordslist.Append(k);
 					autocompletelist.Add(k.ToUpperInvariant(), k + "?" + imageindex.ToString(CultureInfo.InvariantCulture));
 				}
 				foreach(string k in scriptconfig.Keywords)
 				{
 					if(keywordslist.Length > 0) keywordslist.Append(" ");
 					keywordslist.Append(k);
 					autocompletelist.Add(k.ToUpperInvariant(), k + "?" + imageindex.ToString(CultureInfo.InvariantCulture));
 				}
 				string words = keywordslist.ToString();
 				if(scriptconfig.CaseSensitive)
 					scriptedit.KeyWords(keywordsindex, words);
 				else
 					scriptedit.KeyWords(keywordsindex, words.ToLowerInvariant());
 			}
 
 			// Create the constants list and apply it
 			imageindex = (int)ImageIndex.ScriptConstant;
 			int constantsindex = lexercfg.ReadSetting(lexername + ".constantsindex", -1);
 			if(constantsindex > -1)
 			{
 				StringBuilder constantslist = new StringBuilder("");
 				foreach(string c in scriptconfig.Constants)
 				{
 					if(constantslist.Length > 0) constantslist.Append(" ");
 					constantslist.Append(c);
 					autocompletelist.Add(c.ToUpperInvariant(), c + "?" + imageindex.ToString(CultureInfo.InvariantCulture));
 				}
 				foreach(string c in scriptconfig.Constants)
 				{
 					if(constantslist.Length > 0) constantslist.Append(" ");
 					constantslist.Append(c);
 					autocompletelist.Add(c.ToUpperInvariant(), c + "?" + imageindex.ToString(CultureInfo.InvariantCulture));
 				}
 				string words = constantslist.ToString();
 				if(scriptconfig.CaseSensitive)
 					scriptedit.KeyWords(constantsindex, words);
 				else
 					scriptedit.KeyWords(constantsindex, words.ToLowerInvariant());
 			}
 			
 			// Sort the autocomplete list
 			List<string> autocompleteplainlist = new List<string>(autocompletelist.Values);
 			autocompletestring = string.Join(" ", autocompleteplainlist.ToArray());
 			
 			// Show/hide the functions bar
 			functionbar.Visible = (scriptconfig.FunctionRegEx.Length > 0);
 
 			// Rearrange the layout
 			scriptedit.ClearDocumentStyle();
 			scriptedit.SetText(scriptedit.GetText(scriptedit.TextSize));
 			this.PerformLayout();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="1237" endline="1301">
<![CDATA[
 		
 		// This renders a rectangle with given border size and color
 		public void RenderRectangle(RectangleF rect, float bordersize, PixelColor c, bool transformrect)
 		{
 			FlatQuad[] quads = new FlatQuad[4];
 			
 			/*
 			 * Rectangle setup
 			 * 
 			 *  --------------------------
 			 *  |___________0____________|
 			 *  |  |                  |  |
 			 *  |  |                  |  |
 			 *  |  |                  |  |
 			 *  | 2|                  |3 |
 			 *  |  |                  |  |
 			 *  |  |                  |  |
 			 *  |__|__________________|__|
 			 *  |           1            |
 			 *  --------------------------
 			 * 
 			 * Don't you just love ASCII art?
 			 */
 			
 			// Calculate positions
 			Vector2D lt = new Vector2D(rect.Left, rect.Top);
 			Vector2D rb = new Vector2D(rect.Right, rect.Bottom);
 			if(transformrect)
 			{
 				lt = lt.GetTransformed(translatex, translatey, scale, -scale);
 				rb = rb.GetTransformed(translatex, translatey, scale, -scale);
 			}
 			
 			// Make quads
 			quads[0] = new FlatQuad(PrimitiveType.TriangleStrip, lt.x, lt.y, rb.x, lt.y - bordersize);
 			quads[1] = new FlatQuad(PrimitiveType.TriangleStrip, lt.x, rb.y + bordersize, rb.x, rb.y);
 			quads[2] = new FlatQuad(PrimitiveType.TriangleStrip, lt.x, lt.y - bordersize, lt.x + bordersize, rb.y + bordersize);
 			quads[3] = new FlatQuad(PrimitiveType.TriangleStrip, rb.x - bordersize, lt.y - bordersize, rb.x, rb.y + bordersize);
 			quads[0].SetColors(c.ToInt());
 			quads[1].SetColors(c.ToInt());
 			quads[2].SetColors(c.ToInt());
 			quads[3].SetColors(c.ToInt());
 			
 			// Set renderstates for rendering
 			graphics.Device.SetRenderState(RenderState.CullMode, Cull.None);
 			graphics.Device.SetRenderState(RenderState.ZEnable, false);
 			graphics.Device.SetRenderState(RenderState.AlphaBlendEnable, false);
 			graphics.Device.SetRenderState(RenderState.AlphaTestEnable, false);
 			graphics.Device.SetRenderState(RenderState.TextureFactor, -1);
 			graphics.Device.SetRenderState(RenderState.FogEnable, false);
 			SetWorldTransformation(false);
 			graphics.Device.SetTexture(0, General.Map.Data.WhiteTexture.Texture);
 			graphics.Shaders.Display2D.Texture1 = General.Map.Data.WhiteTexture.Texture;
 			graphics.Shaders.Display2D.SetSettings(1f, 1f, 0f, 1f, General.Settings.ClassicBilinear);
 			
 			// Draw
 			graphics.Shaders.Display2D.Begin();
 			graphics.Shaders.Display2D.BeginPass(1);
 			quads[0].Render(graphics);
 			quads[1].Render(graphics);
 			quads[2].Render(graphics);
 			quads[3].Render(graphics);
 			graphics.Shaders.Display2D.EndPass();
 			graphics.Shaders.Display2D.End();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1653" endline="1674">
<![CDATA[
 
 		// This returns a unique temp filename
 		internal static string MakeTempFilename(string tempdir, string extension)
 		{
 			string filename;
 			string chars = "abcdefghijklmnopqrstuvwxyz1234567890";
 			Random rnd = new Random();
 			int i;
 
 			do
 			{
 				// Generate a filename
 				filename = "";
 				for(i = 0; i < 8; i++) filename += chars[rnd.Next(chars.Length)];
 				filename = Path.Combine(tempdir, filename + "." + extension);
 			}
 			// Continue while file is not unique
 			while(File.Exists(filename) || Directory.Exists(filename));
 
 			// Return the filename
 			return filename;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="296" endline="347">
<![CDATA[
 		
 		// This is called by all the ReadSetting overloads to perform the read
 		private bool CheckSetting(IDictionary dic, string setting, string pathseperator)
 		{
 			IDictionary cs = null;
 
 			// Split the path in an array
 			string[] keys = setting.Split(pathseperator.ToCharArray());
 
 			// Get the root item
 			object item = dic;
 
 			// Go for each item
 			for(int i = 0; i < keys.Length; i++)
 			{
 				// Check if the current item is of ConfigStruct type
 				if(item is IDictionary)
 				{
 					// Check if the key is valid
 					if(ValidateKey(null, keys[i].Trim(), "", -1) == true)
 					{
 						// Cast to ConfigStruct
 						cs = (IDictionary)item;
 						
 						// Check if the requested item exists
 						if(cs.Contains(keys[i]) == true)
 						{
 							// Set the item to the next item
 							item = cs[keys[i];
 						}
 						else
 						{
 							// Key not found
 							return false;
 						}
 					}
 					else
 					{
 						// Invalid key in path
 						return false;
 					}
 				}
 				else
 				{
 					// Unable to go any further
 					return false;
 				}
 			}
 			for(int i = 0; i < keys.Length; i++)
 			{
 				// Check if the current item is of ConfigStruct type
 				if(item is IDictionary)
 				{
 					// Check if the key is valid
 					if(ValidateKey(null, keys[i].Trim(), "", -1) == true)
 					{
 						// Cast to ConfigStruct
 						cs = (IDictionary)item;
 						
 						// Check if the requested item exists
 						if(cs.Contains(keys[i]) == true)
 						{
 							// Set the item to the next item
 							item = cs[keys[i];
 						}
 						else
 						{
 							// Key not found
 							return false;
 						}
 					}
 					else
 					{
 						// Invalid key in path
 						return false;
 					}
 				}
 				else
 				{
 					// Unable to go any further
 					return false;
 				}
 			}
 
 			// Return result
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1346" endline="1361">
<![CDATA[
 
 		/// <summary>This adds the current selection to the specified selection group.</summary>
 		public void AddSelectionToGroup(int groupmask)
 		{
 			foreach(SelectableElement e in vertices)
 				if(e.Selected) e.AddToGroup(groupmask);
 			foreach(SelectableElement e in vertices)
 				if(e.Selected) e.AddToGroup(groupmask);
 			
 			foreach(SelectableElement e in linedefs)
 				if(e.Selected) e.AddToGroup(groupmask);
 			foreach(SelectableElement e in linedefs)
 				if(e.Selected) e.AddToGroup(groupmask);
 			
 			foreach(SelectableElement e in sectors)
 				if(e.Selected) e.AddToGroup(groupmask);
 			foreach(SelectableElement e in sectors)
 				if(e.Selected) e.AddToGroup(groupmask);
 			
 			foreach(SelectableElement e in things)
 				if(e.Selected) e.AddToGroup(groupmask);
 			foreach(SelectableElement e in things)
 				if(e.Selected) e.AddToGroup(groupmask);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1446" endline="1453">
<![CDATA[
 
 		/// <summary>Returns a collection of vertices that match a marked state.</summary>
 		public List<Vertex> GetMarkedVertices(bool mark)
 		{
 			List<Vertex> list = new List<Vertex>(numvertices >> 1);
 			foreach(Vertex v in vertices) if(v.Marked == mark) list.Add(v);
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1454" endline="1461">
<![CDATA[
 
 		/// <summary>Returns a collection of things that match a marked state.</summary>
 		public List<Thing> GetMarkedThings(bool mark)
 		{
 			List<Thing> list = new List<Thing>(numthings >> 1);
 			foreach(Thing t in things) if(t.Marked == mark) list.Add(t);
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1462" endline="1469">
<![CDATA[
 
 		/// <summary>Returns a collection of linedefs that match a marked state.</summary>
 		public List<Linedef> GetMarkedLinedefs(bool mark)
 		{
 			List<Linedef> list = new List<Linedef>(numlinedefs >> 1);
 			foreach(Linedef l in linedefs) if(l.Marked == mark) list.Add(l);
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1470" endline="1477">
<![CDATA[
 
 		/// <summary>Returns a collection of sidedefs that match a marked state.</summary>
 		public List<Sidedef> GetMarkedSidedefs(bool mark)
 		{
 			List<Sidedef> list = new List<Sidedef>(numsidedefs >> 1);
 			foreach(Sidedef s in sidedefs) if(s.Marked == mark) list.Add(s);
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1478" endline="1485">
<![CDATA[
 
 		/// <summary>Returns a collection of sectors that match a marked state.</summary>
 		public List<Sector> GetMarkedSectors(bool mark)
 		{
 			List<Sector> list = new List<Sector>(numsectors >> 1);
 			foreach(Sector s in sectors) if(s.Marked == mark) list.Add(s);
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="508" endline="529">
<![CDATA[
 		
 		// This notifies a key has been pressed
 		// Returns true when the key press has been absorbed
 		internal bool KeyPressed(int key)
 		{
 			int strippedkey = key & ~((int)Keys.Alt | (int)Keys.Shift | (int)Keys.Control);
 			if((strippedkey == (int)Keys.ShiftKey) || (strippedkey == (int)Keys.ControlKey)) key = strippedkey;
 			bool repeat = pressedkeys.Contains(strippedkey);
 			
 			// Update pressed keys
 			if(!repeat) pressedkeys.Add(strippedkey);
 			
 			// Add action to active list
 			Action[] acts = GetActionsByKey(key);
 			bool absorbed = acts.Length > 0;
 			foreach(Action a in acts) if(!activeactions.Contains(a)) activeactions.Add(a);
 
 			// Invoke actions
 			absorbed |= BeginActionByKey(key, repeat);
 
 			return absorbed;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextEditForm.cs" startline="48" endline="57">
<![CDATA[
 
 		// This shows the dialog, returns the same value when cancelled
 		public static string ShowDialog(IWin32Window owner, string value)
 		{
 			TextEditForm f = new TextEditForm();
 			f.Value = value;
 			if(f.ShowDialog(owner) == DialogResult.OK) value = f.Value;
 			f.Dispose();
 			return value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1675" endline="1696">
<![CDATA[
 
 		// This returns a unique temp directory name
 		internal static string MakeTempDirname()
 		{
 			string dirname;
 			const string chars = "abcdefghijklmnopqrstuvwxyz1234567890";
 			Random rnd = new Random();
 			int i;
 
 			do
 			{
 				// Generate a filename
 				dirname = "";
 				for(i = 0; i < 8; i++) dirname += chars[rnd.Next(chars.Length)];
 				dirname = Path.Combine(temppath, dirname);
 			}
 			// Continue while file is not unique
 			while(File.Exists(dirname) || Directory.Exists(dirname));
 
 			// Return the filename
 			return dirname;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="159" endline="182">
<![CDATA[
 
 		// Mode is disengaged
 		public override void OnDisengage()
 		{
 			base.OnDisengage();
 			
 			// Dispose
 			foreach(KeyValuePair<Sector, VisualSector> vs in allsectors)
 				if(vs.Value != null) vs.Value.Dispose();
 			foreach(KeyValuePair<Sector, VisualSector> vs in allsectors)
 				if(vs.Value != null) vs.Value.Dispose();
 
 			// Dispose
 			foreach(KeyValuePair<Thing, VisualThing> vt in allthings)
 				if(vt.Value != null) vt.Value.Dispose();	
 			foreach(KeyValuePair<Thing, VisualThing> vt in allthings)
 				if(vt.Value != null) vt.Value.Dispose();	
 			
 			// Apply camera position to thing
 			General.Map.VisualCamera.ApplyToThing();
 			
 			// Do not leave the sector on the camera
 			General.Map.VisualCamera.Sector = null;
 			
 			// Stop special input mode
 			General.Interface.DisableProcessing();
 			General.Interface.StopExclusiveMouseInput();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="446" endline="508">
<![CDATA[
 
 		// This loads all compiler configurations
 		private static void LoadAllCompilerConfigurations()
 		{
 			Configuration cfg;
 			Dictionary<string, CompilerInfo> addedcompilers = new Dictionary<string,CompilerInfo>();
 			IDictionary compilerslist;
 			string[] filenames;
 
 			// Display status
 			mainwindow.DisplayStatus(StatusType.Busy, "Loading compiler configurations...");
 
 			// Make array
 			compilers = new List<CompilerInfo>();
 
 			// Go for all cfg files in the compilers directory
 			filenames = Directory.GetFiles(compilerspath, "*.cfg", SearchOption.AllDirectories);
 			foreach(string filepath in filenames)
 			{
 				try
 				{
 					// Try loading the configuration
 					cfg = new Configuration(filepath, true);
 
 					// Check for erors
 					if(cfg.ErrorResult)
 					{
 						// Error in configuration
 						errorlogger.Add(ErrorType.Error, "Unable to load the compiler configuration file \"" + Path.GetFileName(filepath) + "\". " +
 														 "Error in file \"" + cfg.ErrorFile + "\" near line " + cfg.ErrorLine + "
 					}
 					else
 					{
 						// Get structures
 						compilerslist = cfg.ReadSetting("compilers", new Hashtable());
 						foreach(DictionaryEntry de in compilerslist)
 						{
 							// Check if this is a structure
 							if(de.Value is IDictionary)
 							{
 								// Make compiler info
 								CompilerInfo info = new CompilerInfo(Path.GetFileName(filepath), de.Key.ToString(), Path.GetDirectoryName(filepath), cfg);
 								if(!addedcompilers.ContainsKey(info.Name))
 								{
 									compilers.Add(info);
 									addedcompilers.Add(info.Name, info);
 								}
 								else
 								{
 									errorlogger.Add(ErrorType.Error, "Compiler \"" + info.Name + "\" is defined more than once. The first definition in " + addedcompilers[info.Name].FileName + " will be used.");
 								}
 							}
 						}
 						foreach(DictionaryEntry de in compilerslist)
 						{
 							// Check if this is a structure
 							if(de.Value is IDictionary)
 							{
 								// Make compiler info
 								CompilerInfo info = new CompilerInfo(Path.GetFileName(filepath), de.Key.ToString(), Path.GetDirectoryName(filepath), cfg);
 								if(!addedcompilers.ContainsKey(info.Name))
 								{
 									compilers.Add(info);
 									addedcompilers.Add(info.Name, info);
 								}
 								else
 								{
 									errorlogger.Add(ErrorType.Error, "Compiler \"" + info.Name + "\" is defined more than once. The first definition in " + addedcompilers[info.Name].FileName + " will be used.");
 								}
 							}
 						}
 					}
 				}
 				catch(Exception e)
 				{
 					// Unable to load configuration
 					errorlogger.Add(ErrorType.Error, "Unable to load the compiler configuration file \"" + Path.GetFileName(filepath) + "\". " + e.GetType().Name + "
 					General.WriteLogLine(e.StackTrace);
 				}
 			}
 			foreach(string filepath in filenames)
 			{
 				try
 				{
 					// Try loading the configuration
 					cfg = new Configuration(filepath, true);
 
 					// Check for erors
 					if(cfg.ErrorResult)
 					{
 						// Error in configuration
 						errorlogger.Add(ErrorType.Error, "Unable to load the compiler configuration file \"" + Path.GetFileName(filepath) + "\". " +
 														 "Error in file \"" + cfg.ErrorFile + "\" near line " + cfg.ErrorLine + "
 					}
 					else
 					{
 						// Get structures
 						compilerslist = cfg.ReadSetting("compilers", new Hashtable());
 						foreach(DictionaryEntry de in compilerslist)
 						{
 							// Check if this is a structure
 							if(de.Value is IDictionary)
 							{
 								// Make compiler info
 								CompilerInfo info = new CompilerInfo(Path.GetFileName(filepath), de.Key.ToString(), Path.GetDirectoryName(filepath), cfg);
 								if(!addedcompilers.ContainsKey(info.Name))
 								{
 									compilers.Add(info);
 									addedcompilers.Add(info.Name, info);
 								}
 								else
 								{
 									errorlogger.Add(ErrorType.Error, "Compiler \"" + info.Name + "\" is defined more than once. The first definition in " + addedcompilers[info.Name].FileName + " will be used.");
 								}
 							}
 						}
 					}
 				}
 				catch(Exception e)
 				{
 					// Unable to load configuration
 					errorlogger.Add(ErrorType.Error, "Unable to load the compiler configuration file \"" + Path.GetFileName(filepath) + "\". " + e.GetType().Name + "
 					General.WriteLogLine(e.StackTrace);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="228" endline="257">
<![CDATA[
 		
 		// This returns the patch names from the PNAMES lump
 		// A directory resource does not support this lump, but the wads in the directory may contain this lump
 		public override PatchNames LoadPatchNames()
 		{
 			PatchNames pnames;
 			
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 			
 			// Load from wad files
 			// Note the backward order, because the last wad's images have priority
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				pnames = wads[i].LoadPatchNames();
 				if(pnames != null) return pnames;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				pnames = wads[i].LoadPatchNames();
 				if(pnames != null) return pnames;
 			}
 			
 			// If none of the wads provides patch names, let's see if we can
 			string pnamesfile = FindFirstFile("PNAMES", false);
 			if((pnamesfile != null) && FileExists(pnamesfile))
 			{
 				MemoryStream pnamesdata = LoadFile(pnamesfile);
 				pnames = new PatchNames(pnamesdata);
 				pnamesdata.Dispose();
 				return pnames;
 			}
 			
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="990" endline="1006">
<![CDATA[
 
 		// This deserializes sectors
 		private Sector[] ReadSectors(DeserializerStream stream)
 		{
 			int c; stream.rInt(out c);
 
 			Sector[] array = new Sector[c];
 
 			// Go for all sectors
 			for(int i = 0; i < c; i++)
 			{
 				array[i] = CreateSector();
 				array[i].ReadWrite(stream);
 			}
 			for(int i = 0; i < c; i++)
 			{
 				array[i] = CreateSector();
 				array[i].ReadWrite(stream);
 			}
 
 			return array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2530" endline="2543">
<![CDATA[
 
 		/// <summary>This returns the next unused tag number within the marked geometry.</summary>
 		public int GetNewTag(bool marked)
 		{
 			Dictionary<int, bool> usedtags = new Dictionary<int, bool>();
 			ForAllTags(NewTagHandler, marked, usedtags);
 
 			// Now find the first unused index
 			for(int i = 1; i <= General.Map.FormatInterface.MaxTag; i++)
 				if(!usedtags.ContainsKey(i)) return i;
 			for(int i = 1; i <= General.Map.FormatInterface.MaxTag; i++)
 				if(!usedtags.ContainsKey(i)) return i;
 
 			// All tags used!
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2750" endline="2780">
<![CDATA[
 
 		/// <summary>This finds the closest unselected linedef that is not connected to the given vertex.</summary>
 		public Linedef NearestUnselectedUnreferencedLinedef(Vector2D pos, float maxrange, Vertex v, out float distance)
 		{
 			Linedef closest = null;
 			distance = float.MaxValue;
 			float maxrangesq = maxrange * maxrange;
 			float d;
 
 			// Go for all linedefs in selection
 			foreach(Linedef l in linedefs)
 			{
 				// Calculate distance and check if closer than previous find
 				d = l.SafeDistanceToSq(pos, true);
 				if((d <= maxrangesq) && (d < distance))
 				{
 					// Check if not selected
 
 					// Check if linedef is not connected to v
 					if((l.Start != v) && (l.End != v))
 					{
 						// This one is closer
 						closest = l;
 						distance = d;
 					}
 				}
 			}
 			foreach(Linedef l in linedefs)
 			{
 				// Calculate distance and check if closer than previous find
 				d = l.SafeDistanceToSq(pos, true);
 				if((d <= maxrangesq) && (d < distance))
 				{
 					// Check if not selected
 
 					// Check if linedef is not connected to v
 					if((l.Start != v) && (l.End != v))
 					{
 						// This one is closer
 						closest = l;
 						distance = d;
 					}
 				}
 			}
 
 			// Return result
 			return closest;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="88" endline="99">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public static Triangulation Create(Sector sector)
 		{
 			Triangulation t = new Triangulation();
 			t.Triangulate(sector);
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3Reader.cs" startline="104" endline="132">
<![CDATA[
 
 		#endregion
 
 		#region ================== Textures
 
 		// This finds and returns a patch stream
 		public override Stream GetPatchData(string pname)
 		{
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find in any of the wad files
 			// Note the backward order, because the last wad's images have priority
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetPatchData(pname);
 				if(data != null) return data;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetPatchData(pname);
 				if(data != null) return data;
 			}
 
 			// Find in patches directory
 			string filename = FindFirstFile(PATCHES_DIR, pname, true);
 			if((filename != null) && FileExists(filename))
 			{
 				return LoadFile(filename);
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3Reader.cs" startline="133" endline="157">
<![CDATA[
 
 		// This finds and returns a textue stream
 		public override Stream GetTextureData(string pname)
 		{
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find in any of the wad files
 			// Note the backward order, because the last wad's images have priority
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetTextureData(pname);
 				if(data != null) return data;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetTextureData(pname);
 				if(data != null) return data;
 			}
 
 			// Find in patches directory
 			string filename = FindFirstFile(TEXTURES_DIR, pname, true);
 			if((filename != null) && FileExists(filename))
 			{
 				return LoadFile(filename);
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3Reader.cs" startline="158" endline="182">
<![CDATA[
 
 		// This finds and returns a colormap stream
 		public override Stream GetColormapData(string pname)
 		{
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find in any of the wad files
 			// Note the backward order, because the last wad's images have priority
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetColormapData(pname);
 				if(data != null) return data;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream data = wads[i].GetColormapData(pname);
 				if(data != null) return data;
 			}
 
 			// Find in patches directory
 			string filename = FindFirstFile(COLORMAPS_DIR, pname, true);
 			if((filename != null) && FileExists(filename))
 			{
 				return LoadFile(filename);
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\UniValue.cs" startline="177" endline="190">
<![CDATA[
 		
 		// This validates a UDMF field name and returns the valid part
 		public static string ValidateName(string name)
 		{
 			// Keep only valid characters
 			string fieldname = name.Trim().ToLowerInvariant();
 			string validname = "";
 			for(int c = 0; c < fieldname.Length; c++)
 			{
 				string valid_chars = (validname.Length > 0) ? NAME_CHARS 
 				if(valid_chars.IndexOf(fieldname[c]) > -1) validname += fieldname[c];
 			}
 			for(int c = 0; c < fieldname.Length; c++)
 			{
 				string valid_chars = (validname.Length > 0) ? NAME_CHARS 
 				if(valid_chars.IndexOf(fieldname[c]) > -1) validname += fieldname[c];
 			}
 			return validname;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomMapSetIO.cs" startline="259" endline="397">
<![CDATA[
 		
 		// This reads the LINEDEFS and SIDEDEFS from WAD file
 		private void ReadLinedefs(MapSet map, int firstindex,
 			Dictionary<int, Vertex> vertexlink, Dictionary<int, Sector> sectorlink)
 		{
 			MemoryStream linedefsmem, sidedefsmem;
 			BinaryReader readline, readside;
 			Lump linedefslump, sidedefslump;
 			int num, numsides, i, offsetx, offsety, v1, v2;
 			int s1, s2, flags, action, tag, sc;
 			Dictionary<string, bool> stringflags;
 			string thigh, tmid, tlow;
 			Linedef l;
 			Sidedef s;
 
 			// Get the linedefs lump from wad file
 			linedefslump = wad.FindLump("LINEDEFS", firstindex);
 			if(linedefslump == null) throw new Exception("Could not find required lump LINEDEFS!");
 
 			// Get the sidedefs lump from wad file
 			sidedefslump = wad.FindLump("SIDEDEFS", firstindex);
 			if(sidedefslump == null) throw new Exception("Could not find required lump SIDEDEFS!");
 
 			// Prepare to read the items
 			linedefsmem = new MemoryStream(linedefslump.Stream.ReadAllBytes());
 			sidedefsmem = new MemoryStream(sidedefslump.Stream.ReadAllBytes());
 			num = (int)linedefslump.Stream.Length / 14;
 			numsides = (int)sidedefslump.Stream.Length / 30;
 			readline = new BinaryReader(linedefsmem);
 			readside = new BinaryReader(sidedefsmem);
 
 			// Read items from the lump
 			map.SetCapacity(0, map.Linedefs.Count + num, map.Sidedefs.Count + numsides, 0, 0);
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				v1 = readline.ReadUInt16();
 				v2 = readline.ReadUInt16();
 				flags = readline.ReadUInt16();
 				action = readline.ReadUInt16();
 				tag = readline.ReadUInt16();
 				s1 = readline.ReadUInt16();
 				s2 = readline.ReadUInt16();
 
 				// Make string flags
 				stringflags = new Dictionary<string, bool>();
 				foreach(string f in manager.Config.SortedLinedefFlags)
 				{
 					int fnum;
 					if(int.TryParse(f, out fnum)) stringflags[f] = ((flags & fnum) == fnum);
 				}
 				foreach(string f in manager.Config.SortedLinedefFlags)
 				{
 					int fnum;
 					if(int.TryParse(f, out fnum)) stringflags[f] = ((flags & fnum) == fnum);
 				}
 
 				// Create new linedef
 				if(vertexlink.ContainsKey(v1) && vertexlink.ContainsKey(v2))
 				{
 					// Check if not zero-length
 					if(Vector2D.ManhattanDistance(vertexlink[v1].Position, vertexlink[v2].Position) > 0.0001f)
 					{
 						l = map.CreateLinedef(vertexlink[v1], vertexlink[v2]);
 						l.Update(stringflags, 0, tag, action, new int[Linedef.NUM_ARGS]);
 						l.UpdateCache();
 
 						// Line has a front side?
 						if(s1 != ushort.MaxValue)
 						{
 							// Read front sidedef
 							if((s1 * 30L) <= (sidedefsmem.Length - 30L))
 							{
 								sidedefsmem.Seek(s1 * 30, SeekOrigin.Begin);
 								offsetx = readside.ReadInt16();
 								offsety = readside.ReadInt16();
 								thigh = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tlow = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tmid = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								sc = readside.ReadUInt16();
 
 								// Create front sidedef
 								if(sectorlink.ContainsKey(sc))
 								{
 									s = map.CreateSidedef(l, true, sectorlink[sc]);
 									s.Update(offsetx, offsety, thigh, tmid, tlow);
 								}
 								else
 								{
 									General.ErrorLogger.Add(ErrorType.Warning, "Sidedef " + s1 + " references invalid sector " + sc + ". Sidedef has been removed.");
 								}
 							}
 							else
 							{
 								General.ErrorLogger.Add(ErrorType.Warning, "Linedef references invalid sidedef " + s1 + ". Sidedef has been removed.");
 							}
 						}
 
 						// Line has a back side?
 						if(s2 != ushort.MaxValue)
 						{
 							// Read back sidedef
 							if((s2 * 30L) <= (sidedefsmem.Length - 30L))
 							{
 								sidedefsmem.Seek(s2 * 30, SeekOrigin.Begin);
 								offsetx = readside.ReadInt16();
 								offsety = readside.ReadInt16();
 								thigh = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tlow = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tmid = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								sc = readside.ReadUInt16();
 
 								// Create back sidedef
 								if(sectorlink.ContainsKey(sc))
 								{
 									s = map.CreateSidedef(l, false, sectorlink[sc]);
 									s.Update(offsetx, offsety, thigh, tmid, tlow);
 								}
 								else
 								{
 									General.ErrorLogger.Add(ErrorType.Warning, "Sidedef " + s2 + " references invalid sector " + sc + ". Sidedef has been removed.");
 								}
 							}
 							else
 							{
 								General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references invalid sidedef " + s2 + ". Sidedef has been removed.");
 							}
 						}
 					}
 					else
 					{
 						General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " is zero-length. Linedef has been removed.");
 					}
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references one or more invalid vertices. Linedef has been removed.");
 				}
 			}
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				v1 = readline.ReadUInt16();
 				v2 = readline.ReadUInt16();
 				flags = readline.ReadUInt16();
 				action = readline.ReadUInt16();
 				tag = readline.ReadUInt16();
 				s1 = readline.ReadUInt16();
 				s2 = readline.ReadUInt16();
 
 				// Make string flags
 				stringflags = new Dictionary<string, bool>();
 				foreach(string f in manager.Config.SortedLinedefFlags)
 				{
 					int fnum;
 					if(int.TryParse(f, out fnum)) stringflags[f] = ((flags & fnum) == fnum);
 				}
 
 				// Create new linedef
 				if(vertexlink.ContainsKey(v1) && vertexlink.ContainsKey(v2))
 				{
 					// Check if not zero-length
 					if(Vector2D.ManhattanDistance(vertexlink[v1].Position, vertexlink[v2].Position) > 0.0001f)
 					{
 						l = map.CreateLinedef(vertexlink[v1], vertexlink[v2]);
 						l.Update(stringflags, 0, tag, action, new int[Linedef.NUM_ARGS]);
 						l.UpdateCache();
 
 						// Line has a front side?
 						if(s1 != ushort.MaxValue)
 						{
 							// Read front sidedef
 							if((s1 * 30L) <= (sidedefsmem.Length - 30L))
 							{
 								sidedefsmem.Seek(s1 * 30, SeekOrigin.Begin);
 								offsetx = readside.ReadInt16();
 								offsety = readside.ReadInt16();
 								thigh = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tlow = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tmid = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								sc = readside.ReadUInt16();
 
 								// Create front sidedef
 								if(sectorlink.ContainsKey(sc))
 								{
 									s = map.CreateSidedef(l, true, sectorlink[sc]);
 									s.Update(offsetx, offsety, thigh, tmid, tlow);
 								}
 								else
 								{
 									General.ErrorLogger.Add(ErrorType.Warning, "Sidedef " + s1 + " references invalid sector " + sc + ". Sidedef has been removed.");
 								}
 							}
 							else
 							{
 								General.ErrorLogger.Add(ErrorType.Warning, "Linedef references invalid sidedef " + s1 + ". Sidedef has been removed.");
 							}
 						}
 
 						// Line has a back side?
 						if(s2 != ushort.MaxValue)
 						{
 							// Read back sidedef
 							if((s2 * 30L) <= (sidedefsmem.Length - 30L))
 							{
 								sidedefsmem.Seek(s2 * 30, SeekOrigin.Begin);
 								offsetx = readside.ReadInt16();
 								offsety = readside.ReadInt16();
 								thigh = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tlow = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tmid = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								sc = readside.ReadUInt16();
 
 								// Create back sidedef
 								if(sectorlink.ContainsKey(sc))
 								{
 									s = map.CreateSidedef(l, false, sectorlink[sc]);
 									s.Update(offsetx, offsety, thigh, tmid, tlow);
 								}
 								else
 								{
 									General.ErrorLogger.Add(ErrorType.Warning, "Sidedef " + s2 + " references invalid sector " + sc + ". Sidedef has been removed.");
 								}
 							}
 							else
 							{
 								General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references invalid sidedef " + s2 + ". Sidedef has been removed.");
 							}
 						}
 					}
 					else
 					{
 						General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " is zero-length. Linedef has been removed.");
 					}
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references one or more invalid vertices. Linedef has been removed.");
 				}
 			}
 
 			// Done
 			linedefsmem.Dispose();
 			sidedefsmem.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1326" endline="1381">
<![CDATA[
 		internal static bool SaveMapInto()
 		{
 			SaveFileDialog savefile;
 			bool result = false;
 
 			if(map == null)
 				return false;
 
 			// Cancel volatile mode, if any
 			General.Editing.DisengageVolatileMode();
 
 			// Show save as dialog
 			savefile = new SaveFileDialog();
 			savefile.Filter = "Doom WAD Files (*.wad)|*.wad";
 			savefile.Title = "Save Map Into";
 			savefile.AddExtension = true;
 			savefile.CheckPathExists = true;
 			savefile.OverwritePrompt = false;
 			savefile.ValidateNames = true;
 			if(savefile.ShowDialog(mainwindow) == DialogResult.OK)
 			{
 				// Display status
 				mainwindow.DisplayStatus(StatusType.Busy, "Saving map file...");
 				Cursor.Current = Cursors.WaitCursor;
 
 				// Set this to false so we can see if errors are added
 				General.ErrorLogger.IsErrorAdded = false;
 				
 				// Save the map
 				General.Plugins.OnMapSaveBegin(SavePurpose.IntoFile);
 				if(map.SaveMap(savefile.FileName, SavePurpose.IntoFile))
 				{
 					// Add recent file
 					mainwindow.AddRecentFile(map.FilePathName);
 					result = true;
 				}
 				General.Plugins.OnMapSaveEnd(SavePurpose.IntoFile);
 
 				// All done
 				mainwindow.UpdateInterface();
 
 				if(errorlogger.IsErrorAdded)
 				{
 					// Show any errors if preferred
 					mainwindow.DisplayStatus(StatusType.Warning, "There were errors during saving!");
 					if(!delaymainwindow && General.Settings.ShowErrorsWindow) mainwindow.ShowErrors();
 				}
 				else
 					mainwindow.DisplayStatus(StatusType.Info, "Map saved into " + map.FileTitle + ".");
 
 				Cursor.Current = Cursors.Default;
 			}
 
 			savefile.Dispose();
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ArgumentBox.cs" startline="235" endline="241">
<![CDATA[
 
 		// This checks if the number is relative
 		public bool CheckIsRelative()
 		{
 			// Prefixed with ++ or --?
 			return (combobox.Text.Trim().StartsWith("++") || combobox.Text.Trim().StartsWith("--"));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="174" endline="264">
<![CDATA[
 
 		#endregion
 
 		#region ================== OK / Cancel
 
 		// OK clicked
 		private void apply_Click(object sender, EventArgs e)
 		{
 			// Let the plugins know
 			controller.RaiseAccept();
 			
 			// Check if we need to reload the resources
 			reloadresources |= (General.Settings.ImageBrightness != imagebrightness.Value);
 			reloadresources |= (General.Settings.PreviewImageSize != previewsize.Value);
 
 			// Apply interface
 			General.Settings.ImageBrightness = imagebrightness.Value;
 			General.Settings.SquareThings = squarethings.Checked;
 			General.Settings.DoubleSidedAlpha = 1.0f - (float)(doublesidedalpha.Value * 0.1f);
 			General.Settings.DefaultViewMode = defaultviewmode.SelectedIndex;
 			General.Settings.VisualFOV = fieldofview.Value * 10;
 			General.Settings.MouseSpeed = mousespeed.Value * 100;
 			General.Settings.MoveSpeed = movespeed.Value * 100;
 			General.Settings.ViewDistance = (float)viewdistance.Value * 200.0f;
 			General.Settings.InvertYAxis = invertyaxis.Checked;
 			General.Settings.ScriptFontBold = scriptfontbold.Checked;
 			General.Settings.ScriptFontName = scriptfontname.Text;
 			General.Settings.ScriptOnTop = scriptontop.Checked;
 			General.Settings.ScriptTabWidth = scripttabwidth.GetResult(General.Settings.ScriptTabWidth);
 			General.Settings.ScriptAutoIndent = scriptautoindent.Checked;
 			General.Settings.PreviewImageSize = previewsize.Value;
 			General.Settings.AutoScrollSpeed = autoscrollspeed.Value;
 			General.Settings.ZoomFactor = zoomfactor.Value;
 			General.Settings.AnimateVisualSelection = animatevisualselection.Checked;
 			General.Settings.DockersPosition = dockersposition.SelectedIndex;
 			General.Settings.CollapseDockers = collapsedockers.Checked;
 			General.Settings.ToolbarFile = toolbar_file.Checked;
 			General.Settings.ToolbarScript = toolbar_script.Checked;
 			General.Settings.ToolbarUndo = toolbar_undo.Checked;
 			General.Settings.ToolbarCopy = toolbar_copy.Checked;
 			General.Settings.ToolbarPrefabs = toolbar_prefabs.Checked;
 			General.Settings.ToolbarFilter = toolbar_filter.Checked;
 			General.Settings.ToolbarViewModes = toolbar_viewmodes.Checked;
 			General.Settings.ToolbarGeometry = toolbar_geometry.Checked;
 			General.Settings.ToolbarTesting = toolbar_testing.Checked;
 			General.Settings.ShowTextureSizes = showtexturesizes.Checked;
 			
 			// Script font size
 			int fontsize = 8;
 			int.TryParse(scriptfontsize.Text, out fontsize);
 			General.Settings.ScriptFontSize = fontsize;
 			
 			// Apply control keys to actions
 			foreach(ListViewItem item in listactions.Items)
 				General.Actions[item.Name].SetShortcutKey((int)item.SubItems[1].Tag);
 			foreach(ListViewItem item in listactions.Items)
 				General.Actions[item.Name].SetShortcutKey((int)item.SubItems[1].Tag);
 
 			// Apply the colors
 			// TODO
 			General.Colors.Background = colorbackcolor.Color;
 			General.Colors.Vertices = colorvertices.Color;
 			General.Colors.Linedefs = colorlinedefs.Color;
 			General.Colors.Actions = colorspeciallinedefs.Color;
 			General.Colors.Sounds = colorsoundlinedefs.Color;
 			General.Colors.Highlight = colorhighlight.Color;
 			General.Colors.Selection = colorselection.Color;
 			General.Colors.Indication = colorindication.Color;
 			General.Colors.Grid = colorgrid.Color;
 			General.Colors.Grid64 = colorgrid64.Color;
 			General.Colors.ScriptBackground = colorscriptbackground.Color;
 			General.Colors.LineNumbers = colorlinenumbers.Color;
 			General.Colors.PlainText = colorplaintext.Color;
 			General.Colors.Comments = colorcomments.Color;
 			General.Colors.Keywords = colorkeywords.Color;
 			General.Colors.Literals = colorliterals.Color;
 			General.Colors.Constants = colorconstants.Color;
 			General.Colors.CreateAssistColors();
 			General.Settings.BlackBrowsers = blackbrowsers.Checked;
 			General.Settings.ClassicBilinear = classicbilinear.Checked;
 			General.Settings.VisualBilinear = visualbilinear.Checked;
 			General.Settings.QualityDisplay = qualitydisplay.Checked;
 			
 			// Paste options
 			General.Settings.PasteOptions = pasteoptions.GetOptions();
 			
 			// Let the plugins know we're closing
 			General.Plugins.OnClosePreferences(controller);
 			
 			// Close
 			this.DialogResult = DialogResult.OK;
 			this.Close();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1067" endline="1166">
<![CDATA[
 
 		/// <summary>This converts the current selection to a different type of selection as specified.
 		/// Note that this function uses the markings to convert the selection.</summary>
 		public void ConvertSelection(SelectionType source, SelectionType target)
 		{
 			ICollection<Linedef> lines;
 			ICollection<Vertex> verts;
 			
 			ClearAllMarks(false);
 			
 			switch(target)
 			{
 				// Convert geometry selection to vertices only
 				case SelectionType.Vertices
 					if(InSelectionType(source, SelectionType.Linedefs)) MarkSelectedLinedefs(true, true);
 					if(InSelectionType(source, SelectionType.Sectors)) General.Map.Map.MarkSelectedSectors(true, true);
 					verts = General.Map.Map.GetVerticesFromLinesMarks(true);
 					foreach(Vertex v in verts) v.Selected = true;
 					verts = General.Map.Map.GetVerticesFromSectorsMarks(true);
 					foreach(Vertex v in verts) v.Selected = true;
 					General.Map.Map.ClearSelectedSectors();
 					General.Map.Map.ClearSelectedLinedefs();
 					break;
 					
 				// Convert geometry selection to linedefs only
 				case SelectionType.Linedefs
 					if(InSelectionType(source, SelectionType.Vertices)) MarkSelectedVertices(true, true);
 					if(!InSelectionType(source, SelectionType.Linedefs)) ClearSelectedLinedefs();
 					lines = General.Map.Map.LinedefsFromMarkedVertices(false, true, false);
 					foreach(Linedef l in lines) l.Selected = true;
 					if(InSelectionType(source, SelectionType.Sectors))
 					{
 						foreach(Sector s in General.Map.Map.Sectors)
 						{
 							if(s.Selected)
 							{
 								foreach(Sidedef sd in s.Sidedefs)
 									sd.Line.Selected = true;
 								foreach(Sidedef sd in s.Sidedefs)
 									sd.Line.Selected = true;
 							}
 						}
 						foreach(Sector s in General.Map.Map.Sectors)
 						{
 							if(s.Selected)
 							{
 								foreach(Sidedef sd in s.Sidedefs)
 									sd.Line.Selected = true;
 							}
 						}
 					}
 					General.Map.Map.ClearSelectedSectors();
 					General.Map.Map.ClearSelectedVertices();
 					break;
 					
 				// Convert geometry selection to sectors only
 				case SelectionType.Sectors
 					if(InSelectionType(source, SelectionType.Vertices)) MarkSelectedVertices(true, true);
 					if(!InSelectionType(source, SelectionType.Linedefs)) ClearSelectedLinedefs();
 					lines = LinedefsFromMarkedVertices(false, true, false);
 					foreach(Linedef l in lines) l.Selected = true;
 					ClearMarkedSectors(true);
 					foreach(Linedef l in linedefs)
 					{
 						if(!l.Selected)
 						{
 							if(l.Front != null) l.Front.Sector.Marked = false;
 							if(l.Back != null) l.Back.Sector.Marked = false;
 						}
 					}
 					foreach(Linedef l in linedefs)
 					{
 						if(!l.Selected)
 						{
 							if(l.Front != null) l.Front.Sector.Marked = false;
 							if(l.Back != null) l.Back.Sector.Marked = false;
 						}
 					}
 					ClearSelectedLinedefs();
 					ClearSelectedVertices();
 					if(InSelectionType(source, SelectionType.Sectors))
 					{
 						foreach(Sector s in General.Map.Map.Sectors)
 						{
 							if(s.Marked || s.Selected)
 							{
 								s.Selected = true;
 								foreach(Sidedef sd in s.Sidedefs)
 									sd.Line.Selected = true;
 								foreach(Sidedef sd in s.Sidedefs)
 									sd.Line.Selected = true;
 							}
 						}
 						foreach(Sector s in General.Map.Map.Sectors)
 						{
 							if(s.Marked || s.Selected)
 							{
 								s.Selected = true;
 								foreach(Sidedef sd in s.Sidedefs)
 									sd.Line.Selected = true;
 							}
 						}
 					}
 					else
 					{
 						foreach(Sector s in General.Map.Map.Sectors)
 						{
 							if(s.Marked)
 							{
 								s.Selected = true;
 								foreach(Sidedef sd in s.Sidedefs)
 									sd.Line.Selected = true;
 								foreach(Sidedef sd in s.Sidedefs)
 									sd.Line.Selected = true;
 							}
 							else
 							{
 								s.Selected = false;
 							}
 						}
 						foreach(Sector s in General.Map.Map.Sectors)
 						{
 							if(s.Marked)
 							{
 								s.Selected = true;
 								foreach(Sidedef sd in s.Sidedefs)
 									sd.Line.Selected = true;
 							}
 							else
 							{
 								s.Selected = false;
 							}
 						}
 					}
 					break;
 					
 				default
 					throw new ArgumentException("Unsupported selection target conversion");
 					break;
 			}
 			
 			// New selection type
 			sel_type = target;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="448" endline="600">
<![CDATA[
 
 		#endregion
 		
 		#region ================== Sector Making
 
 		// This makes the sector from the given lines and sides
 		// If nearbylines is not null, then this method will find the default
 		// properties from the nearest line in this collection when the
 		// default properties can't be found in the alllines collection.
 		// Return null when no new sector could be made.
 		public static Sector MakeSector(List<LinedefSide> alllines, List<Linedef> nearbylines)
 		{
 			Sector sourcesector = null;
 			SidedefSettings sourceside = new SidedefSettings();
 			bool foundsidedefaults = false;
 
 			if(General.Map.Map.Sectors.Count >= General.Map.FormatInterface.MaxSectors)
 				return null;
 
 			Sector newsector = General.Map.Map.CreateSector();
 			if(newsector == null) return null;
 			
 			// Check if any of the sides already has a sidedef
 			// Then we use information from that sidedef to make the others
 			foreach(LinedefSide ls in alllines)
 			{
 				if(ls.Front)
 				{
 					if(ls.Line.Front != null)
 					{
 						// Copy sidedef information if not already found
 						if(sourcesector == null) sourcesector = ls.Line.Front.Sector;
 						TakeSidedefSettings(ref sourceside, ls.Line.Front);
 						foundsidedefaults = true;
 						break;
 					}
 				}
 				else
 				{
 					if(ls.Line.Back != null)
 					{
 						// Copy sidedef information if not already found
 						if(sourcesector == null) sourcesector = ls.Line.Back.Sector;
 						TakeSidedefSettings(ref sourceside, ls.Line.Back);
 						foundsidedefaults = true;
 						break;
 					}
 				}
 			}
 			foreach(LinedefSide ls in alllines)
 			{
 				if(ls.Front)
 				{
 					if(ls.Line.Front != null)
 					{
 						// Copy sidedef information if not already found
 						if(sourcesector == null) sourcesector = ls.Line.Front.Sector;
 						TakeSidedefSettings(ref sourceside, ls.Line.Front);
 						foundsidedefaults = true;
 						break;
 					}
 				}
 				else
 				{
 					if(ls.Line.Back != null)
 					{
 						// Copy sidedef information if not already found
 						if(sourcesector == null) sourcesector = ls.Line.Back.Sector;
 						TakeSidedefSettings(ref sourceside, ls.Line.Back);
 						foundsidedefaults = true;
 						break;
 					}
 				}
 			}
 			
 			// Now do the same for the other sides
 			// Note how information is only copied when not already found
 			// so this won't override information from the sides searched above
 			foreach(LinedefSide ls in alllines)
 			{
 				if(ls.Front)
 				{
 					if(ls.Line.Back != null)
 					{
 						// Copy sidedef information if not already found
 						if(sourcesector == null) sourcesector = ls.Line.Back.Sector;
 						TakeSidedefSettings(ref sourceside, ls.Line.Back);
 						foundsidedefaults = true;
 						break;
 					}
 				}
 				else
 				{
 					if(ls.Line.Front != null)
 					{
 						// Copy sidedef information if not already found
 						if(sourcesector == null) sourcesector = ls.Line.Front.Sector;
 						TakeSidedefSettings(ref sourceside, ls.Line.Front);
 						foundsidedefaults = true;
 						break;
 					}
 				}
 			}
 			foreach(LinedefSide ls in alllines)
 			{
 				if(ls.Front)
 				{
 					if(ls.Line.Back != null)
 					{
 						// Copy sidedef information if not already found
 						if(sourcesector == null) sourcesector = ls.Line.Back.Sector;
 						TakeSidedefSettings(ref sourceside, ls.Line.Back);
 						foundsidedefaults = true;
 						break;
 					}
 				}
 				else
 				{
 					if(ls.Line.Front != null)
 					{
 						// Copy sidedef information if not already found
 						if(sourcesector == null) sourcesector = ls.Line.Front.Sector;
 						TakeSidedefSettings(ref sourceside, ls.Line.Front);
 						foundsidedefaults = true;
 						break;
 					}
 				}
 			}
 			
 			// Use default settings from neares linedef, if settings have been found yet
 			if( (nearbylines != null) && (alllines.Count > 0) && (!foundsidedefaults || (sourcesector == null)) )
 			{
 				Vector2D testpoint = alllines[0].Line.GetSidePoint(alllines[0].Front);
 				Linedef nearest = MapSet.NearestLinedef(nearbylines, testpoint);
 				if(nearest != null)
 				{
 					Sidedef defaultside;
 					float side = nearest.SideOfLine(testpoint);
 					if(side < 0.0f)
 						defaultside = nearest.Front;
 					else
 						defaultside = nearest.Back;
 
 					if(defaultside != null)
 					{
 						if(sourcesector == null) sourcesector = defaultside.Sector;
 						TakeSidedefSettings(ref sourceside, defaultside);
 					}
 				}
 			}
 			
 			// Use defaults where no settings could be found
 			TakeSidedefDefaults(ref sourceside);
 			
 			// Found a source sector?
 			if(sourcesector != null)
 			{
 				// Copy properties from source to new sector
 				sourcesector.CopyPropertiesTo(newsector);
 			}
 			else
 			{
 				// No source sector, apply default sector properties
 				ApplyDefaultsToSector(newsector);
 			}
 
 			// Go for all sides to make sidedefs
 			foreach(LinedefSide ls in alllines)
 			{
 				// We may only remove a useless middle texture when
 				// the line was previously singlesided
 				bool wassinglesided = (ls.Line.Back == null) || (ls.Line.Front == null);
 				
 				if(ls.Front)
 				{
 					// Create sidedef is needed and ensure it points to the new sector
 					if(ls.Line.Front == null) General.Map.Map.CreateSidedef(ls.Line, true, newsector);
 					if(ls.Line.Front == null) return null;
 					if(ls.Line.Front.Sector != newsector) ls.Line.Front.SetSector(newsector);
 					ApplyDefaultsToSidedef(ls.Line.Front, sourceside);
 				}
 				else
 				{
 					// Create sidedef is needed and ensure it points to the new sector
 					if(ls.Line.Back == null) General.Map.Map.CreateSidedef(ls.Line, false, newsector);
 					if(ls.Line.Back == null) return null;
 					if(ls.Line.Back.Sector != newsector) ls.Line.Back.SetSector(newsector);
 					ApplyDefaultsToSidedef(ls.Line.Back, sourceside);
 				}
 
 				// Update line
 				if(ls.Line.Front != null) ls.Line.Front.RemoveUnneededTextures(wassinglesided);
 				if(ls.Line.Back != null) ls.Line.Back.RemoveUnneededTextures(wassinglesided);
 
 				// Apply single/double sided flags if the double-sided-ness changed
 				if( (wassinglesided && ((ls.Line.Front != null) && (ls.Line.Back != null))) ||
 					(!wassinglesided && ((ls.Line.Front == null) || (ls.Line.Back == null))))
 					ls.Line.ApplySidedFlags();
 			}
 			foreach(LinedefSide ls in alllines)
 			{
 				// We may only remove a useless middle texture when
 				// the line was previously singlesided
 				bool wassinglesided = (ls.Line.Back == null) || (ls.Line.Front == null);
 				
 				if(ls.Front)
 				{
 					// Create sidedef is needed and ensure it points to the new sector
 					if(ls.Line.Front == null) General.Map.Map.CreateSidedef(ls.Line, true, newsector);
 					if(ls.Line.Front == null) return null;
 					if(ls.Line.Front.Sector != newsector) ls.Line.Front.SetSector(newsector);
 					ApplyDefaultsToSidedef(ls.Line.Front, sourceside);
 				}
 				else
 				{
 					// Create sidedef is needed and ensure it points to the new sector
 					if(ls.Line.Back == null) General.Map.Map.CreateSidedef(ls.Line, false, newsector);
 					if(ls.Line.Back == null) return null;
 					if(ls.Line.Back.Sector != newsector) ls.Line.Back.SetSector(newsector);
 					ApplyDefaultsToSidedef(ls.Line.Back, sourceside);
 				}
 
 				// Update line
 				if(ls.Line.Front != null) ls.Line.Front.RemoveUnneededTextures(wassinglesided);
 				if(ls.Line.Back != null) ls.Line.Back.RemoveUnneededTextures(wassinglesided);
 
 				// Apply single/double sided flags if the double-sided-ness changed
 				if( (wassinglesided && ((ls.Line.Front != null) && (ls.Line.Back != null))) ||
 					(!wassinglesided && ((ls.Line.Front == null) || (ls.Line.Back == null))))
 					ls.Line.ApplySidedFlags();
 			}
 
 			// Return the new sector
 			return newsector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.Designer.cs" startline="22" endline="159">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.functionbar = new System.Windows.Forms.ComboBox();
 			this.scriptedit = new CodeImp.DoomBuilder.Controls.ScintillaControl();
 			this.scriptpanel = new System.Windows.Forms.Panel();
 			this.scriptpanel.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// functionbar
 			// 
 			this.functionbar.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.functionbar.FormattingEnabled = true;
 			this.functionbar.Items.AddRange(new object[] {
             "Function1",
             "Function2",
             "Function3"});
 			this.functionbar.Location = new System.Drawing.Point(0, 0);
 			this.functionbar.Name = "functionbar";
 			this.functionbar.Size = new System.Drawing.Size(474, 21);
 			this.functionbar.TabIndex = 1;
 			this.functionbar.TabStop = false;
 			// 
 			// scriptedit
 			// 
 			this.scriptedit.AnchorPosition = 0;
 			this.scriptedit.AutoCMaximumHeight = 0;
 			this.scriptedit.AutoCMaximumWidth = 0;
 			this.scriptedit.AutoCSeparator = 0;
 			this.scriptedit.AutoCTypeSeparator = 0;
 			this.scriptedit.BackColor = System.Drawing.SystemColors.Window;
 			this.scriptedit.CaretFore = 0;
 			this.scriptedit.CaretLineBack = 0;
 			this.scriptedit.CaretPeriod = 0;
 			this.scriptedit.CaretWidth = 0;
 			this.scriptedit.CodePage = 0;
 			this.scriptedit.ControlCharSymbol = 0;
 			this.scriptedit.CurrentPos = 0;
 			this.scriptedit.CursorType = 0;
 			this.scriptedit.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.scriptedit.DocPointer = 0;
 			this.scriptedit.EdgeColour = 0;
 			this.scriptedit.EdgeColumn = 0;
 			this.scriptedit.EdgeMode = 0;
 			this.scriptedit.EndAtLastLine = 0;
 			this.scriptedit.EndOfLineMode = CodeImp.DoomBuilder.Controls.ScriptEndOfLine.CRLF;
 			this.scriptedit.EOLMode = 0;
 			this.scriptedit.ExtraAscent = 0;
 			this.scriptedit.ExtraDescent = 0;
 			this.scriptedit.HighlightGuide = 0;
 			this.scriptedit.Indent = 0;
 			this.scriptedit.IndentationGuides = 0;
 			this.scriptedit.IsAutoCGetAutoHide = false;
 			this.scriptedit.IsAutoCGetCancelAtStart = false;
 			this.scriptedit.IsAutoCGetChooseSingle = false;
 			this.scriptedit.IsAutoCGetDropRestOfWord = false;
 			this.scriptedit.IsAutoCGetIgnoreCase = false;
 			this.scriptedit.IsBackSpaceUnIndents = false;
 			this.scriptedit.IsBufferedDraw = false;
 			this.scriptedit.IsCaretLineVisible = false;
 			this.scriptedit.IsFocus = false;
 			this.scriptedit.IsHScrollBar = false;
 			this.scriptedit.IsMouseDownCaptures = false;
 			this.scriptedit.IsOvertype = false;
 			this.scriptedit.IsReadOnly = false;
 			this.scriptedit.IsTabIndents = false;
 			this.scriptedit.IsTwoPhaseDraw = false;
 			this.scriptedit.IsUndoCollection = false;
 			this.scriptedit.IsUsePalette = false;
 			this.scriptedit.IsUseTabs = false;
 			this.scriptedit.IsViewEOL = false;
 			this.scriptedit.IsVScrollBar = false;
 			this.scriptedit.LayoutCache = 0;
 			this.scriptedit.Lexer = 0;
 			this.scriptedit.Location = new System.Drawing.Point(0, 0);
 			this.scriptedit.MarginLeft = 0;
 			this.scriptedit.MarginRight = 0;
 			this.scriptedit.ModEventMask = 0;
 			this.scriptedit.MouseDwellTime = 0;
 			this.scriptedit.Name = "scriptedit";
 			this.scriptedit.PrintColourMode = 0;
 			this.scriptedit.PrintMagnification = 0;
 			this.scriptedit.PrintWrapMode = 0;
 			this.scriptedit.ScrollWidth = 0;
 			this.scriptedit.SearchFlags = 0;
 			this.scriptedit.SelectionEnd = 0;
 			this.scriptedit.SelectionMode = 0;
 			this.scriptedit.SelectionStart = 0;
 			this.scriptedit.Size = new System.Drawing.Size(470, 377);
 			this.scriptedit.Status = 0;
 			this.scriptedit.StyleBits = 0;
 			this.scriptedit.TabIndex = 0;
 			this.scriptedit.TabStop = false;
 			this.scriptedit.TabWidth = 0;
 			this.scriptedit.TargetEnd = 0;
 			this.scriptedit.TargetStart = 0;
 			this.scriptedit.ViewWhitespace = CodeImp.DoomBuilder.Controls.ScriptWhiteSpace.Invisible;
 			this.scriptedit.ViewWS = 0;
 			this.scriptedit.WrapMode = 0;
 			this.scriptedit.WrapStartIndent = 0;
 			this.scriptedit.WrapVisualFlags = 0;
 			this.scriptedit.WrapVisualFlagsLocation = 0;
 			this.scriptedit.XOffset = 0;
 			this.scriptedit.ZoomLevel = 0;
 			this.scriptedit.KeyUp += new System.Windows.Forms.KeyEventHandler(this.scriptedit_KeyUp);
 			this.scriptedit.KeyDown += new System.Windows.Forms.KeyEventHandler(this.scriptedit_KeyDown);
 			// 
 			// scriptpanel
 			// 
 			this.scriptpanel.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.scriptpanel.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.scriptpanel.Controls.Add(this.scriptedit);
 			this.scriptpanel.Location = new System.Drawing.Point(0, 27);
 			this.scriptpanel.Name = "scriptpanel";
 			this.scriptpanel.Size = new System.Drawing.Size(474, 381);
 			this.scriptpanel.TabIndex = 2;
 			// 
 			// ScriptEditorControl
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.scriptpanel);
 			this.Controls.Add(this.functionbar);
 			this.Name = "ScriptEditorControl";
 			this.Size = new System.Drawing.Size(474, 408);
 			this.scriptpanel.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\AngleControl.Designer.cs" startline="22" endline="160">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.button0 = new System.Windows.Forms.RadioButton();
 			this.button1 = new System.Windows.Forms.RadioButton();
 			this.button2 = new System.Windows.Forms.RadioButton();
 			this.button3 = new System.Windows.Forms.RadioButton();
 			this.button4 = new System.Windows.Forms.RadioButton();
 			this.button5 = new System.Windows.Forms.RadioButton();
 			this.button6 = new System.Windows.Forms.RadioButton();
 			this.button7 = new System.Windows.Forms.RadioButton();
 			this.SuspendLayout();
 			// 
 			// button0
 			// 
 			this.button0.AutoSize = true;
 			this.button0.BackColor = System.Drawing.Color.Transparent;
 			this.button0.Location = new System.Drawing.Point(62, 33);
 			this.button0.Name = "button0";
 			this.button0.Padding = new System.Windows.Forms.Padding(3);
 			this.button0.Size = new System.Drawing.Size(20, 19);
 			this.button0.TabIndex = 0;
 			this.button0.UseVisualStyleBackColor = false;
 			this.button0.CheckedChanged += new System.EventHandler(this.button_CheckedChanged);
 			// 
 			// button1
 			// 
 			this.button1.AutoSize = true;
 			this.button1.BackColor = System.Drawing.Color.Transparent;
 			this.button1.Location = new System.Drawing.Point(54, 11);
 			this.button1.Name = "button1";
 			this.button1.Padding = new System.Windows.Forms.Padding(3);
 			this.button1.Size = new System.Drawing.Size(20, 19);
 			this.button1.TabIndex = 1;
 			this.button1.UseVisualStyleBackColor = false;
 			this.button1.CheckedChanged += new System.EventHandler(this.button_CheckedChanged);
 			// 
 			// button2
 			// 
 			this.button2.AutoSize = true;
 			this.button2.BackColor = System.Drawing.Color.Transparent;
 			this.button2.Location = new System.Drawing.Point(33, 3);
 			this.button2.Name = "button2";
 			this.button2.Padding = new System.Windows.Forms.Padding(3);
 			this.button2.Size = new System.Drawing.Size(20, 19);
 			this.button2.TabIndex = 2;
 			this.button2.UseVisualStyleBackColor = false;
 			this.button2.CheckedChanged += new System.EventHandler(this.button_CheckedChanged);
 			// 
 			// button3
 			// 
 			this.button3.AutoSize = true;
 			this.button3.BackColor = System.Drawing.Color.Transparent;
 			this.button3.Location = new System.Drawing.Point(11, 11);
 			this.button3.Name = "button3";
 			this.button3.Padding = new System.Windows.Forms.Padding(3);
 			this.button3.Size = new System.Drawing.Size(20, 19);
 			this.button3.TabIndex = 3;
 			this.button3.UseVisualStyleBackColor = false;
 			this.button3.CheckedChanged += new System.EventHandler(this.button_CheckedChanged);
 			// 
 			// button4
 			// 
 			this.button4.AutoSize = true;
 			this.button4.BackColor = System.Drawing.Color.Transparent;
 			this.button4.Location = new System.Drawing.Point(3, 33);
 			this.button4.Name = "button4";
 			this.button4.Padding = new System.Windows.Forms.Padding(3);
 			this.button4.Size = new System.Drawing.Size(20, 19);
 			this.button4.TabIndex = 4;
 			this.button4.UseVisualStyleBackColor = false;
 			this.button4.CheckedChanged += new System.EventHandler(this.button_CheckedChanged);
 			// 
 			// button5
 			// 
 			this.button5.AutoSize = true;
 			this.button5.BackColor = System.Drawing.Color.Transparent;
 			this.button5.Location = new System.Drawing.Point(11, 55);
 			this.button5.Name = "button5";
 			this.button5.Padding = new System.Windows.Forms.Padding(3);
 			this.button5.Size = new System.Drawing.Size(20, 19);
 			this.button5.TabIndex = 5;
 			this.button5.UseVisualStyleBackColor = false;
 			this.button5.CheckedChanged += new System.EventHandler(this.button_CheckedChanged);
 			// 
 			// button6
 			// 
 			this.button6.AutoSize = true;
 			this.button6.BackColor = System.Drawing.Color.Transparent;
 			this.button6.Location = new System.Drawing.Point(33, 63);
 			this.button6.Name = "button6";
 			this.button6.Padding = new System.Windows.Forms.Padding(3);
 			this.button6.Size = new System.Drawing.Size(20, 19);
 			this.button6.TabIndex = 6;
 			this.button6.UseVisualStyleBackColor = false;
 			this.button6.CheckedChanged += new System.EventHandler(this.button_CheckedChanged);
 			// 
 			// button7
 			// 
 			this.button7.AutoSize = true;
 			this.button7.BackColor = System.Drawing.Color.Transparent;
 			this.button7.Location = new System.Drawing.Point(54, 55);
 			this.button7.Name = "button7";
 			this.button7.Padding = new System.Windows.Forms.Padding(3);
 			this.button7.Size = new System.Drawing.Size(20, 19);
 			this.button7.TabIndex = 7;
 			this.button7.UseVisualStyleBackColor = false;
 			this.button7.CheckedChanged += new System.EventHandler(this.button_CheckedChanged);
 			// 
 			// AngleControl
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.BackColor = System.Drawing.SystemColors.Control;
 			this.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.Controls.Add(this.button7);
 			this.Controls.Add(this.button6);
 			this.Controls.Add(this.button5);
 			this.Controls.Add(this.button4);
 			this.Controls.Add(this.button3);
 			this.Controls.Add(this.button2);
 			this.Controls.Add(this.button1);
 			this.Controls.Add(this.button0);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.Name = "AngleControl";
 			this.Size = new System.Drawing.Size(84, 84);
 			this.Paint += new System.Windows.Forms.PaintEventHandler(this.AngleControl_Paint);
 			this.Layout += new System.Windows.Forms.LayoutEventHandler(this.AngleControl_Layout);
 			this.Resize += new System.EventHandler(this.AngleControl_Resize);
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ErrorsForm.Designer.cs" startline="22" endline="172">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
 			this.copyselected = new System.Windows.Forms.Button();
 			this.clearlist = new System.Windows.Forms.Button();
 			this.close = new System.Windows.Forms.Button();
 			this.checkerrors = new System.Windows.Forms.Timer(this.components);
 			this.checkshow = new System.Windows.Forms.CheckBox();
 			this.grid = new System.Windows.Forms.DataGridView();
 			this.iconcolumn = new System.Windows.Forms.DataGridViewImageColumn();
 			this.textcolumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
 			((System.ComponentModel.ISupportInitialize)(this.grid)).BeginInit();
 			this.SuspendLayout();
 			// 
 			// copyselected
 			// 
 			this.copyselected.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.copyselected.Location = new System.Drawing.Point(12, 416);
 			this.copyselected.Name = "copyselected";
 			this.copyselected.Size = new System.Drawing.Size(122, 25);
 			this.copyselected.TabIndex = 1;
 			this.copyselected.Text = "Copy Selection";
 			this.copyselected.UseVisualStyleBackColor = true;
 			this.copyselected.Click += new System.EventHandler(this.copyselected_Click);
 			// 
 			// clearlist
 			// 
 			this.clearlist.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.clearlist.Location = new System.Drawing.Point(150, 416);
 			this.clearlist.Name = "clearlist";
 			this.clearlist.Size = new System.Drawing.Size(122, 25);
 			this.clearlist.TabIndex = 2;
 			this.clearlist.Text = "Clear";
 			this.clearlist.UseVisualStyleBackColor = true;
 			this.clearlist.Click += new System.EventHandler(this.clearlist_Click);
 			// 
 			// close
 			// 
 			this.close.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.close.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.close.Location = new System.Drawing.Point(622, 416);
 			this.close.Name = "close";
 			this.close.Size = new System.Drawing.Size(122, 25);
 			this.close.TabIndex = 4;
 			this.close.Text = "Close";
 			this.close.UseVisualStyleBackColor = true;
 			this.close.Click += new System.EventHandler(this.close_Click);
 			// 
 			// checkerrors
 			// 
 			this.checkerrors.Interval = 1000;
 			this.checkerrors.Tick += new System.EventHandler(this.checkerrors_Tick);
 			// 
 			// checkshow
 			// 
 			this.checkshow.AutoSize = true;
 			this.checkshow.Location = new System.Drawing.Point(301, 420);
 			this.checkshow.Name = "checkshow";
 			this.checkshow.Size = new System.Drawing.Size(213, 18);
 			this.checkshow.TabIndex = 3;
 			this.checkshow.Text = "Show this window when errors occur";
 			this.checkshow.UseVisualStyleBackColor = true;
 			// 
 			// grid
 			// 
 			this.grid.AllowUserToAddRows = false;
 			this.grid.AllowUserToDeleteRows = false;
 			this.grid.AllowUserToResizeColumns = false;
 			this.grid.AllowUserToResizeRows = false;
 			this.grid.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.grid.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
 			this.grid.AutoSizeRowsMode = System.Windows.Forms.DataGridViewAutoSizeRowsMode.AllCells;
 			this.grid.BackgroundColor = System.Drawing.SystemColors.Window;
 			this.grid.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.grid.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.None;
 			this.grid.ClipboardCopyMode = System.Windows.Forms.DataGridViewClipboardCopyMode.EnableWithoutHeaderText;
 			this.grid.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
 			this.grid.ColumnHeadersVisible = false;
 			this.grid.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
             this.iconcolumn,
             this.textcolumn});
 			this.grid.EditMode = System.Windows.Forms.DataGridViewEditMode.EditProgrammatically;
 			this.grid.Location = new System.Drawing.Point(12, 12);
 			this.grid.Name = "grid";
 			this.grid.ReadOnly = true;
 			this.grid.RowHeadersVisible = false;
 			dataGridViewCellStyle1.Alignment = System.Windows.Forms.DataGridViewContentAlignment.TopLeft;
 			dataGridViewCellStyle1.Padding = new System.Windows.Forms.Padding(2, 4, 2, 5);
 			this.grid.RowsDefaultCellStyle = dataGridViewCellStyle1;
 			this.grid.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
 			this.grid.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
 			this.grid.ShowCellErrors = false;
 			this.grid.ShowCellToolTips = false;
 			this.grid.ShowEditingIcon = false;
 			this.grid.ShowRowErrors = false;
 			this.grid.Size = new System.Drawing.Size(732, 395);
 			this.grid.StandardTab = true;
 			this.grid.TabIndex = 5;
 			// 
 			// iconcolumn
 			// 
 			this.iconcolumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.None;
 			this.iconcolumn.HeaderText = "Icon";
 			this.iconcolumn.MinimumWidth = 20;
 			this.iconcolumn.Name = "iconcolumn";
 			this.iconcolumn.ReadOnly = true;
 			this.iconcolumn.Resizable = System.Windows.Forms.DataGridViewTriState.False;
 			this.iconcolumn.Width = 24;
 			// 
 			// textcolumn
 			// 
 			this.textcolumn.HeaderText = "Text";
 			this.textcolumn.Name = "textcolumn";
 			this.textcolumn.ReadOnly = true;
 			// 
 			// ErrorsForm
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.close;
 			this.ClientSize = new System.Drawing.Size(756, 453);
 			this.Controls.Add(this.checkshow);
 			this.Controls.Add(this.close);
 			this.Controls.Add(this.clearlist);
 			this.Controls.Add(this.copyselected);
 			this.Controls.Add(this.grid);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "ErrorsForm";
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
 			this.Text = "Errors and Warnings";
 			this.Shown += new System.EventHandler(this.ErrorsForm_Shown);
 			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.ErrorsForm_FormClosing);
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.ErrorsForm_HelpRequested);
 			((System.ComponentModel.ISupportInitialize)(this.grid)).EndInit();
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\HighResImage.cs" startline="70" endline="195">
<![CDATA[
 		
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			IImageReader reader;
 			MemoryStream mem;
 			byte[] membytes;
 			Graphics g = null;
 			
 			// Checks
 			if(this.IsImageLoaded) return;
 			if((width == 0) || (height == 0)) return;
 			
 			lock(this)
 			{
 				// Create texture bitmap
 				try
 				{
 					if(bitmap != null) bitmap.Dispose();
 					bitmap = new Bitmap(width, height, PixelFormat.Format32bppArgb);
 					BitmapData bitmapdata = bitmap.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
 					PixelColor* pixels = (PixelColor*)bitmapdata.Scan0.ToPointer();
 					General.ZeroMemory(new IntPtr(pixels), width * height * sizeof(PixelColor));
 					bitmap.UnlockBits(bitmapdata);
 					g = Graphics.FromImage(bitmap);
 				}
 				catch(Exception e)
 				{
 					// Unable to make bitmap
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to load texture image '" + this.Name + "'. " + e.GetType().Name + "
 					loadfailed = true;
 				}
 
 				if(!loadfailed)
 				{
 					// Go for all patches
 					foreach(TexturePatch p in patches)
 					{
 						// Get the patch data stream
 						Stream patchdata = General.Map.Data.GetPatchData(p.lumpname);
 						if(patchdata != null)
 						{
 							// Copy patch data to memory
 							patchdata.Seek(0, SeekOrigin.Begin);
 							membytes = new byte[(int)patchdata.Length];
 							patchdata.Read(membytes, 0, (int)patchdata.Length);
 							mem = new MemoryStream(membytes);
 							mem.Seek(0, SeekOrigin.Begin);
 
 							// Get a reader for the data
 							reader = ImageDataFormat.GetImageReader(mem, ImageDataFormat.DOOMPICTURE, General.Map.Data.Palette);
 							if(reader is UnknownImageReader)
 							{
 								// Data is in an unknown format!
 								General.ErrorLogger.Add(ErrorType.Error, "Patch lump '" + p.lumpname + "' data format could not be read, while loading texture '" + this.Name + "'");
 								loadfailed = true;
 							}
 							else
 							{
 								// Get the patch
 								mem.Seek(0, SeekOrigin.Begin);
 								Bitmap patchbmp = null;
 								try { patchbmp = reader.ReadAsBitmap(mem); }
 								catch(InvalidDataException)
 								{
 									// Data cannot be read!
 									General.ErrorLogger.Add(ErrorType.Error, "Patch lump '" + p.lumpname + "' data format could not be read, while loading texture '" + this.Name + "'");
 									loadfailed = true;
 								}
 								if(patchbmp != null)
 								{
 									// Adjust patch alpha
 									if(p.alpha < 1.0f)
 									{
 										BitmapData bmpdata = null;
 										try
 										{
 											bmpdata = patchbmp.LockBits(new Rectangle(0, 0, patchbmp.Size.Width, patchbmp.Size.Height), ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb);
 										}
 										catch(Exception e)
 										{
 											General.ErrorLogger.Add(ErrorType.Error, "Cannot lock image '" + p.lumpname + "' for alpha adjustment. " + e.GetType().Name + "
 										}
 
 										if(bmpdata != null)
 										{
 											PixelColor* pixels = (PixelColor*)(bmpdata.Scan0.ToPointer());
 											int numpixels = bmpdata.Width * bmpdata.Height;
 											for(PixelColor* cp = pixels + numpixels - 1; cp >= pixels; cp--)
 											{
 												cp->a = (byte)((((float)cp->a * PixelColor.BYTE_TO_FLOAT) * p.alpha) * 255.0f);
 											}
 											for(PixelColor* cp = pixels + numpixels - 1; cp >= pixels; cp--)
 											{
 												cp->a = (byte)((((float)cp->a * PixelColor.BYTE_TO_FLOAT) * p.alpha) * 255.0f);
 											}
 											patchbmp.UnlockBits(bmpdata);
 										}
 									}
 									
 									// Draw the patch on the texture image
 									Rectangle tgtrect = new Rectangle(p.x, p.y, patchbmp.Size.Width, patchbmp.Size.Height);
 									g.DrawImageUnscaledAndClipped(patchbmp, tgtrect);
 									patchbmp.Dispose();
 								}
 							}
 
 							// Done
 							mem.Dispose();
 						}
 						else
 						{
 							// Missing a patch lump!
 							General.ErrorLogger.Add(ErrorType.Error, "Missing patch lump '" + p.lumpname + "' while loading texture '" + this.Name + "'");
 							loadfailed = true;
 						}
 					}
 					foreach(TexturePatch p in patches)
 					{
 						// Get the patch data stream
 						Stream patchdata = General.Map.Data.GetPatchData(p.lumpname);
 						if(patchdata != null)
 						{
 							// Copy patch data to memory
 							patchdata.Seek(0, SeekOrigin.Begin);
 							membytes = new byte[(int)patchdata.Length];
 							patchdata.Read(membytes, 0, (int)patchdata.Length);
 							mem = new MemoryStream(membytes);
 							mem.Seek(0, SeekOrigin.Begin);
 
 							// Get a reader for the data
 							reader = ImageDataFormat.GetImageReader(mem, ImageDataFormat.DOOMPICTURE, General.Map.Data.Palette);
 							if(reader is UnknownImageReader)
 							{
 								// Data is in an unknown format!
 								General.ErrorLogger.Add(ErrorType.Error, "Patch lump '" + p.lumpname + "' data format could not be read, while loading texture '" + this.Name + "'");
 								loadfailed = true;
 							}
 							else
 							{
 								// Get the patch
 								mem.Seek(0, SeekOrigin.Begin);
 								Bitmap patchbmp = null;
 								try { patchbmp = reader.ReadAsBitmap(mem); }
 								catch(InvalidDataException)
 								{
 									// Data cannot be read!
 									General.ErrorLogger.Add(ErrorType.Error, "Patch lump '" + p.lumpname + "' data format could not be read, while loading texture '" + this.Name + "'");
 									loadfailed = true;
 								}
 								if(patchbmp != null)
 								{
 									// Adjust patch alpha
 									if(p.alpha < 1.0f)
 									{
 										BitmapData bmpdata = null;
 										try
 										{
 											bmpdata = patchbmp.LockBits(new Rectangle(0, 0, patchbmp.Size.Width, patchbmp.Size.Height), ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb);
 										}
 										catch(Exception e)
 										{
 											General.ErrorLogger.Add(ErrorType.Error, "Cannot lock image '" + p.lumpname + "' for alpha adjustment. " + e.GetType().Name + "
 										}
 
 										if(bmpdata != null)
 										{
 											PixelColor* pixels = (PixelColor*)(bmpdata.Scan0.ToPointer());
 											int numpixels = bmpdata.Width * bmpdata.Height;
 											for(PixelColor* cp = pixels + numpixels - 1; cp >= pixels; cp--)
 											{
 												cp->a = (byte)((((float)cp->a * PixelColor.BYTE_TO_FLOAT) * p.alpha) * 255.0f);
 											}
 											patchbmp.UnlockBits(bmpdata);
 										}
 									}
 									
 									// Draw the patch on the texture image
 									Rectangle tgtrect = new Rectangle(p.x, p.y, patchbmp.Size.Width, patchbmp.Size.Height);
 									g.DrawImageUnscaledAndClipped(patchbmp, tgtrect);
 									patchbmp.Dispose();
 								}
 							}
 
 							// Done
 							mem.Dispose();
 						}
 						else
 						{
 							// Missing a patch lump!
 							General.ErrorLogger.Add(ErrorType.Error, "Missing patch lump '" + p.lumpname + "' while loading texture '" + this.Name + "'");
 							loadfailed = true;
 						}
 					}
 				}
 				
 				// Dispose bitmap if load failed
 				if(loadfailed && (bitmap != null))
 				{
 					bitmap.Dispose();
 					bitmap = null;
 				}
 
 				// Pass on to base
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualMode.cs" startline="477" endline="648">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Object Picking
 
 		// This picks an object from the scene
 		public VisualPickResult PickObject(Vector3D from, Vector3D to)
 		{
 			VisualPickResult result = new VisualPickResult();
 			Line2D ray2d = new Line2D(from, to);
 			Vector3D delta = to - from;
 			
 			// Setup no result
 			result.picked = null;
 			result.hitpos = new Vector3D();
 			result.u_ray = 1.0f;
 			
 			// Find all blocks we are intersecting
 			List<VisualBlockEntry> blocks = blockmap.GetLineBlocks(from, to);
 			
 			// Make collections
 			Dictionary<Linedef, Linedef> lines = new Dictionary<Linedef, Linedef>(blocks.Count * 10);
 			Dictionary<Sector, VisualSector> sectors = new Dictionary<Sector, VisualSector>(blocks.Count * 10);
 			List<IVisualPickable> pickables = new List<IVisualPickable>(blocks.Count * 10);
 			
 			// Add geometry from the camera sector
 			if((General.Map.VisualCamera.Sector != null) && allsectors.ContainsKey(General.Map.VisualCamera.Sector))
 			{
 				VisualSector vs = allsectors[General.Map.VisualCamera.Sector];
 				sectors.Add(General.Map.VisualCamera.Sector, vs);
 				foreach(VisualGeometry g in vs.FixedGeometry) pickables.Add(g);
 			}
 			
 			// Go for all lines to see which ones we intersect
 			// We will collect geometry from the sectors and sidedefs
 			foreach(VisualBlockEntry b in blocks)
 			{
 				foreach(Linedef ld in b.Lines)
 				{
 					// Make sure we don't test a line twice
 					if(!lines.ContainsKey(ld))
 					{
 						lines.Add(ld, ld);
 						
 						// Intersecting?
 						float u;
 						if(ld.Line.GetIntersection(ray2d, out u))
 						{
 							// Check on which side we are
 							float side = ld.SideOfLine(ray2d.v1);
 							
 							// Calculate intersection point
 							Vector3D intersect = from + delta * u;
 							
 							// We must add the sectors of both sides of the line
 							// If we wouldn't, then aiming at a sector that is just within range
 							// could result in an incorrect hit (because the far line of the
 							// sector may not be included in this loop)
 							if(ld.Front != null)
 							{
 								// Find the visualsector
 								if(allsectors.ContainsKey(ld.Front.Sector))
 								{
 									VisualSector vs = allsectors[ld.Front.Sector];
 									
 									// Add sector if not already added
 									if(!sectors.ContainsKey(ld.Front.Sector))
 									{
 										sectors.Add(ld.Front.Sector, vs);
 										foreach(VisualGeometry g in vs.FixedGeometry)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 												pickables.Add(g);
 										}
 										foreach(VisualGeometry g in vs.FixedGeometry)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 												pickables.Add(g);
 										}
 									}
 									
 									// Add sidedef if on the front side
 									if(side < 0.0f)
 									{
 										List<VisualGeometry> sidedefgeo = vs.GetSidedefGeometry(ld.Front);
 										foreach(VisualGeometry g in sidedefgeo)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 											{
 												g.SetPickResults(intersect, u);
 												pickables.Add(g);
 											}
 										}
 										foreach(VisualGeometry g in sidedefgeo)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 											{
 												g.SetPickResults(intersect, u);
 												pickables.Add(g);
 											}
 										}
 									}
 								}
 							}
 							
 							// Add back side also
 							if(ld.Back != null)
 							{
 								// Find the visualsector
 								if(allsectors.ContainsKey(ld.Back.Sector))
 								{
 									VisualSector vs = allsectors[ld.Back.Sector];
 
 									// Add sector if not already added
 									if(!sectors.ContainsKey(ld.Back.Sector))
 									{
 										sectors.Add(ld.Back.Sector, vs);
 										foreach(VisualGeometry g in vs.FixedGeometry)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 												pickables.Add(g);
 										}
 										foreach(VisualGeometry g in vs.FixedGeometry)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 												pickables.Add(g);
 										}
 									}
 
 									// Add sidedef if on the front side
 									if(side > 0.0f)
 									{
 										List<VisualGeometry> sidedefgeo = vs.GetSidedefGeometry(ld.Back);
 										foreach(VisualGeometry g in sidedefgeo)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 											{
 												g.SetPickResults(intersect, u);
 												pickables.Add(g);
 											}
 										}
 										foreach(VisualGeometry g in sidedefgeo)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 											{
 												g.SetPickResults(intersect, u);
 												pickables.Add(g);
 											}
 										}
 									}
 								}
 							}
 						}
 					}
 				}
 				foreach(Linedef ld in b.Lines)
 				{
 					// Make sure we don't test a line twice
 					if(!lines.ContainsKey(ld))
 					{
 						lines.Add(ld, ld);
 						
 						// Intersecting?
 						float u;
 						if(ld.Line.GetIntersection(ray2d, out u))
 						{
 							// Check on which side we are
 							float side = ld.SideOfLine(ray2d.v1);
 							
 							// Calculate intersection point
 							Vector3D intersect = from + delta * u;
 							
 							// We must add the sectors of both sides of the line
 							// If we wouldn't, then aiming at a sector that is just within range
 							// could result in an incorrect hit (because the far line of the
 							// sector may not be included in this loop)
 							if(ld.Front != null)
 							{
 								// Find the visualsector
 								if(allsectors.ContainsKey(ld.Front.Sector))
 								{
 									VisualSector vs = allsectors[ld.Front.Sector];
 									
 									// Add sector if not already added
 									if(!sectors.ContainsKey(ld.Front.Sector))
 									{
 										sectors.Add(ld.Front.Sector, vs);
 										foreach(VisualGeometry g in vs.FixedGeometry)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 												pickables.Add(g);
 										}
 									}
 									
 									// Add sidedef if on the front side
 									if(side < 0.0f)
 									{
 										List<VisualGeometry> sidedefgeo = vs.GetSidedefGeometry(ld.Front);
 										foreach(VisualGeometry g in sidedefgeo)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 											{
 												g.SetPickResults(intersect, u);
 												pickables.Add(g);
 											}
 										}
 									}
 								}
 							}
 							
 							// Add back side also
 							if(ld.Back != null)
 							{
 								// Find the visualsector
 								if(allsectors.ContainsKey(ld.Back.Sector))
 								{
 									VisualSector vs = allsectors[ld.Back.Sector];
 
 									// Add sector if not already added
 									if(!sectors.ContainsKey(ld.Back.Sector))
 									{
 										sectors.Add(ld.Back.Sector, vs);
 										foreach(VisualGeometry g in vs.FixedGeometry)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 												pickables.Add(g);
 										}
 									}
 
 									// Add sidedef if on the front side
 									if(side > 0.0f)
 									{
 										List<VisualGeometry> sidedefgeo = vs.GetSidedefGeometry(ld.Back);
 										foreach(VisualGeometry g in sidedefgeo)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 											{
 												g.SetPickResults(intersect, u);
 												pickables.Add(g);
 											}
 										}
 									}
 								}
 							}
 						}
 					}
 				}
 			}
 			foreach(VisualBlockEntry b in blocks)
 			{
 				foreach(Linedef ld in b.Lines)
 				{
 					// Make sure we don't test a line twice
 					if(!lines.ContainsKey(ld))
 					{
 						lines.Add(ld, ld);
 						
 						// Intersecting?
 						float u;
 						if(ld.Line.GetIntersection(ray2d, out u))
 						{
 							// Check on which side we are
 							float side = ld.SideOfLine(ray2d.v1);
 							
 							// Calculate intersection point
 							Vector3D intersect = from + delta * u;
 							
 							// We must add the sectors of both sides of the line
 							// If we wouldn't, then aiming at a sector that is just within range
 							// could result in an incorrect hit (because the far line of the
 							// sector may not be included in this loop)
 							if(ld.Front != null)
 							{
 								// Find the visualsector
 								if(allsectors.ContainsKey(ld.Front.Sector))
 								{
 									VisualSector vs = allsectors[ld.Front.Sector];
 									
 									// Add sector if not already added
 									if(!sectors.ContainsKey(ld.Front.Sector))
 									{
 										sectors.Add(ld.Front.Sector, vs);
 										foreach(VisualGeometry g in vs.FixedGeometry)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 												pickables.Add(g);
 										}
 									}
 									
 									// Add sidedef if on the front side
 									if(side < 0.0f)
 									{
 										List<VisualGeometry> sidedefgeo = vs.GetSidedefGeometry(ld.Front);
 										foreach(VisualGeometry g in sidedefgeo)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 											{
 												g.SetPickResults(intersect, u);
 												pickables.Add(g);
 											}
 										}
 									}
 								}
 							}
 							
 							// Add back side also
 							if(ld.Back != null)
 							{
 								// Find the visualsector
 								if(allsectors.ContainsKey(ld.Back.Sector))
 								{
 									VisualSector vs = allsectors[ld.Back.Sector];
 
 									// Add sector if not already added
 									if(!sectors.ContainsKey(ld.Back.Sector))
 									{
 										sectors.Add(ld.Back.Sector, vs);
 										foreach(VisualGeometry g in vs.FixedGeometry)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 												pickables.Add(g);
 										}
 									}
 
 									// Add sidedef if on the front side
 									if(side > 0.0f)
 									{
 										List<VisualGeometry> sidedefgeo = vs.GetSidedefGeometry(ld.Back);
 										foreach(VisualGeometry g in sidedefgeo)
 										{
 											// Must have content
 											if(g.Triangles > 0)
 											{
 												g.SetPickResults(intersect, u);
 												pickables.Add(g);
 											}
 										}
 									}
 								}
 							}
 						}
 					}
 				}
 			}
 			
 			// Add all the visible things
 			foreach(VisualThing vt in visiblethings)
 				pickables.Add(vt);
 			foreach(VisualThing vt in visiblethings)
 				pickables.Add(vt);
 			
 			// Now we have a list of potential geometry that lies along the trace line.
 			// We still don't know what geometry actually hits, but we ruled out that which doesn't get even close.
 			// This is still too much for accurate intersection testing, so we do a fast reject pass first.
 			Vector3D direction = to - from;
 			direction = direction.GetNormal();
 			List<IVisualPickable> potentialpicks = new List<IVisualPickable>(pickables.Count);
 			foreach(IVisualPickable p in pickables)
 			{
 				if(p.PickFastReject(from, to, direction)) potentialpicks.Add(p);
 			}
 			foreach(IVisualPickable p in pickables)
 			{
 				if(p.PickFastReject(from, to, direction)) potentialpicks.Add(p);
 			}
 			
 			// Now we do an accurate intersection test for all resulting geometry
 			// We keep only the closest hit!
 			foreach(IVisualPickable p in potentialpicks)
 			{
 				float u = result.u_ray;
 				if(p.PickAccurate(from, to, direction, ref u))
 				{
 					// Closer than previous find?
 					if((u > 0.0f) && (u < result.u_ray))
 					{
 						result.u_ray = u;
 						result.picked = p;
 					}
 				}
 			}
 			foreach(IVisualPickable p in potentialpicks)
 			{
 				float u = result.u_ray;
 				if(p.PickAccurate(from, to, direction, ref u))
 				{
 					// Closer than previous find?
 					if((u > 0.0f) && (u < result.u_ray))
 					{
 						result.u_ray = u;
 						result.picked = p;
 					}
 				}
 			}
 			
 			// Setup final result
 			result.hitpos = from + to * result.u_ray;
 			
 			// Done
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MapOptionsForm.Designer.cs" startline="22" endline="210">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.Label label3;
 			System.Windows.Forms.Label label2;
 			System.Windows.Forms.Label label1;
 			System.Windows.Forms.GroupBox panelsettings;
 			System.Windows.Forms.Label label4;
 			this.levelname = new System.Windows.Forms.TextBox();
 			this.config = new System.Windows.Forms.ComboBox();
 			this.apply = new System.Windows.Forms.Button();
 			this.cancel = new System.Windows.Forms.Button();
 			this.panelres = new System.Windows.Forms.GroupBox();
 			this.strictpatches = new System.Windows.Forms.CheckBox();
 			this.datalocations = new CodeImp.DoomBuilder.Controls.ResourceListEditor();
 			label3 = new System.Windows.Forms.Label();
 			label2 = new System.Windows.Forms.Label();
 			label1 = new System.Windows.Forms.Label();
 			panelsettings = new System.Windows.Forms.GroupBox();
 			label4 = new System.Windows.Forms.Label();
 			panelsettings.SuspendLayout();
 			this.panelres.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// label3
 			// 
 			label3.AutoSize = true;
 			label3.Location = new System.Drawing.Point(239, 76);
 			label3.Name = "label3";
 			label3.Size = new System.Drawing.Size(90, 14);
 			label3.TabIndex = 9;
 			label3.Text = "example
 			// 
 			// label2
 			// 
 			label2.AutoSize = true;
 			label2.Location = new System.Drawing.Point(58, 76);
 			label2.Name = "label2";
 			label2.Size = new System.Drawing.Size(65, 14);
 			label2.TabIndex = 7;
 			label2.Text = "Level name
 			// 
 			// label1
 			// 
 			label1.AutoSize = true;
 			label1.Location = new System.Drawing.Point(18, 34);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(105, 14);
 			label1.TabIndex = 5;
 			label1.Text = "Game Configuration
 			// 
 			// panelsettings
 			// 
 			panelsettings.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			panelsettings.Controls.Add(label3);
 			panelsettings.Controls.Add(this.levelname);
 			panelsettings.Controls.Add(label2);
 			panelsettings.Controls.Add(this.config);
 			panelsettings.Controls.Add(label1);
 			panelsettings.Location = new System.Drawing.Point(12, 12);
 			panelsettings.Name = "panelsettings";
 			panelsettings.Size = new System.Drawing.Size(397, 118);
 			panelsettings.TabIndex = 0;
 			panelsettings.TabStop = false;
 			panelsettings.Text = " Settings ";
 			// 
 			// levelname
 			// 
 			this.levelname.CharacterCasing = System.Windows.Forms.CharacterCasing.Upper;
 			this.levelname.Location = new System.Drawing.Point(129, 73);
 			this.levelname.Name = "levelname";
 			this.levelname.Size = new System.Drawing.Size(94, 20);
 			this.levelname.TabIndex = 1;
 			this.levelname.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.levelname_KeyPress);
 			// 
 			// config
 			// 
 			this.config.DropDownHeight = 206;
 			this.config.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.config.FormattingEnabled = true;
 			this.config.IntegralHeight = false;
 			this.config.Location = new System.Drawing.Point(129, 31);
 			this.config.Name = "config";
 			this.config.Size = new System.Drawing.Size(213, 22);
 			this.config.TabIndex = 0;
 			this.config.SelectedIndexChanged += new System.EventHandler(this.config_SelectedIndexChanged);
 			// 
 			// label4
 			// 
 			label4.AutoSize = true;
 			label4.Location = new System.Drawing.Point(15, 190);
 			label4.Name = "label4";
 			label4.Size = new System.Drawing.Size(312, 28);
 			label4.TabIndex = 17;
 			label4.Text = "Drag items to change order (lower items override higher items).\r\nGrayed items are" +
 				" loaded according to the game configuration.";
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(179, 392);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 2;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(297, 392);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 3;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// panelres
 			// 
 			this.panelres.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.panelres.Controls.Add(this.strictpatches);
 			this.panelres.Controls.Add(this.datalocations);
 			this.panelres.Controls.Add(label4);
 			this.panelres.Location = new System.Drawing.Point(12, 141);
 			this.panelres.Name = "panelres";
 			this.panelres.Size = new System.Drawing.Size(397, 230);
 			this.panelres.TabIndex = 1;
 			this.panelres.TabStop = false;
 			this.panelres.Text = " Resources ";
 			// 
 			// strictpatches
 			// 
 			this.strictpatches.AutoSize = true;
 			this.strictpatches.Location = new System.Drawing.Point(15, 27);
 			this.strictpatches.Name = "strictpatches";
 			this.strictpatches.Size = new System.Drawing.Size(352, 18);
 			this.strictpatches.TabIndex = 20;
 			this.strictpatches.Text = "Strictly load patches between P_START and P_END only for this file";
 			this.strictpatches.UseVisualStyleBackColor = true;
 			// 
 			// datalocations
 			// 
 			this.datalocations.DialogOffset = new System.Drawing.Point(40, 20);
 			this.datalocations.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.datalocations.Location = new System.Drawing.Point(15, 57);
 			this.datalocations.Name = "datalocations";
 			this.datalocations.Size = new System.Drawing.Size(368, 130);
 			this.datalocations.TabIndex = 0;
 			// 
 			// MapOptionsForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(421, 429);
 			this.Controls.Add(this.panelres);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(panelsettings);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "MapOptionsForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Map Options";
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.MapOptionsForm_HelpRequested);
 			panelsettings.ResumeLayout(false);
 			panelsettings.PerformLayout();
 			this.panelres.ResumeLayout(false);
 			this.panelres.PerformLayout();
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapOptions.cs" startline="104" endline="149">
<![CDATA[
 
 		// Constructor to load from Doom Builder Map Settings Configuration
 		internal MapOptions(Configuration cfg, string mapname)
 		{
 			IDictionary mapinfo, resinfo;
 			DataLocation res;
 			
 			// Initialize
 			this.previousname = "";
 			this.currentname = mapname;
 			this.strictpatches = General.Int2Bool(cfg.ReadSetting("strictpatches", 0));
 			this.configfile = cfg.ReadSetting("gameconfig", "");
 			this.resources = new DataLocationList();
 			this.mapconfig = new Configuration(true);
 			this.scriptfiles = new List<string>();
 			
 			// Read map configuration
 			this.mapconfig.Root = cfg.ReadSetting("maps." + mapname, new Hashtable());
 
 			// Resources
 			IDictionary reslist = this.mapconfig.ReadSetting("resources", new Hashtable());
 			foreach(DictionaryEntry mp in reslist)
 			{
 				// Item is a structure?
 				if(mp.Value is IDictionary)
 				{
 					// Create resource
 					resinfo = (IDictionary)mp.Value;
 					res = new DataLocation();
 					
 					// Copy information from Configuration to ResourceLocation
 					if(resinfo.Contains("type") && (resinfo["type"] is int)) res.type = (int)resinfo["type"];
 					if(resinfo.Contains("location") && (resinfo["location"] is string)) res.location = (string)resinfo["location"];
 					if(resinfo.Contains("textures") && (resinfo["textures"] is bool)) res.option1 = (bool)resinfo["textures"];
 					if(resinfo.Contains("flats") && (resinfo["flats"] is bool)) res.option2 = (bool)resinfo["flats"];
 
 					// Add resource
 					AddResource(res);
 				}
 			}
 			foreach(DictionaryEntry mp in reslist)
 			{
 				// Item is a structure?
 				if(mp.Value is IDictionary)
 				{
 					// Create resource
 					resinfo = (IDictionary)mp.Value;
 					res = new DataLocation();
 					
 					// Copy information from Configuration to ResourceLocation
 					if(resinfo.Contains("type") && (resinfo["type"] is int)) res.type = (int)resinfo["type"];
 					if(resinfo.Contains("location") && (resinfo["location"] is string)) res.location = (string)resinfo["location"];
 					if(resinfo.Contains("textures") && (resinfo["textures"] is bool)) res.option1 = (bool)resinfo["textures"];
 					if(resinfo.Contains("flats") && (resinfo["flats"] is bool)) res.option2 = (bool)resinfo["flats"];
 
 					// Add resource
 					AddResource(res);
 				}
 			}
 
 			// Scripts
 			IDictionary scplist = this.mapconfig.ReadSetting("scripts", new Hashtable());
 			foreach(DictionaryEntry mp in scplist)
 				scriptfiles.Add(mp.Value.ToString());
 			foreach(DictionaryEntry mp in scplist)
 				scriptfiles.Add(mp.Value.ToString());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\TextureImage.cs" startline="69" endline="164">
<![CDATA[
 		
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			IImageReader reader;
 			BitmapData bitmapdata = null;
 			MemoryStream mem;
 			PixelColor* pixels = (PixelColor*)0;
 			Stream patchdata;
 			byte[] membytes;
 			
 			// Checks
 			if(this.IsImageLoaded) return;
 			if((width == 0) || (height == 0)) return;
 			
 			lock(this)
 			{
 				// Create texture bitmap
 				try
 				{
 					if(bitmap != null) bitmap.Dispose();
 					bitmap = new Bitmap(width, height, PixelFormat.Format32bppArgb);
 					bitmapdata = bitmap.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
 					pixels = (PixelColor*)bitmapdata.Scan0.ToPointer();
 					General.ZeroMemory(new IntPtr(pixels), width * height * sizeof(PixelColor));
 				}
 				catch(Exception e)
 				{
 					// Unable to make bitmap
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to load texture image '" + this.Name + "'. " + e.GetType().Name + "
 					loadfailed = true;
 				}
 
 				if(!loadfailed)
 				{
 					// Go for all patches
 					foreach(TexturePatch p in patches)
 					{
 						// Get the patch data stream
 						patchdata = General.Map.Data.GetPatchData(p.lumpname);
 						if(patchdata != null)
 						{
 							// Copy patch data to memory
 							patchdata.Seek(0, SeekOrigin.Begin);
 							membytes = new byte[(int)patchdata.Length];
 							patchdata.Read(membytes, 0, (int)patchdata.Length);
 							mem = new MemoryStream(membytes);
 							mem.Seek(0, SeekOrigin.Begin);
 
 							// Get a reader for the data
 							reader = ImageDataFormat.GetImageReader(mem, ImageDataFormat.DOOMPICTURE, General.Map.Data.Palette);
 							if(reader is UnknownImageReader)
 							{
 								// Data is in an unknown format!
 								General.ErrorLogger.Add(ErrorType.Error, "Patch lump '" + p.lumpname + "' data format could not be read, while loading texture '" + this.Name + "'. Does this lump contain valid picture data at all?");
 								loadfailed = true;
 							}
 							else
 							{
 								// Draw the patch
 								mem.Seek(0, SeekOrigin.Begin);
 								try { reader.DrawToPixelData(mem, pixels, width, height, p.x, p.y); }
 								catch(InvalidDataException)
 								{
 									// Data cannot be read!
 									General.ErrorLogger.Add(ErrorType.Error, "Patch lump '" + p.lumpname + "' data format could not be read, while loading texture '" + this.Name + "'. Does this lump contain valid picture data at all?");
 									loadfailed = true;
 								}
 							}
 
 							// Done
 							mem.Dispose();
 						}
 						else
 						{
 							// Missing a patch lump!
 							General.ErrorLogger.Add(ErrorType.Error, "Missing patch lump '" + p.lumpname + "' while loading texture '" + this.Name + "'. Did you forget to include required resources?");
 							loadfailed = true;
 						}
 					}
 					foreach(TexturePatch p in patches)
 					{
 						// Get the patch data stream
 						patchdata = General.Map.Data.GetPatchData(p.lumpname);
 						if(patchdata != null)
 						{
 							// Copy patch data to memory
 							patchdata.Seek(0, SeekOrigin.Begin);
 							membytes = new byte[(int)patchdata.Length];
 							patchdata.Read(membytes, 0, (int)patchdata.Length);
 							mem = new MemoryStream(membytes);
 							mem.Seek(0, SeekOrigin.Begin);
 
 							// Get a reader for the data
 							reader = ImageDataFormat.GetImageReader(mem, ImageDataFormat.DOOMPICTURE, General.Map.Data.Palette);
 							if(reader is UnknownImageReader)
 							{
 								// Data is in an unknown format!
 								General.ErrorLogger.Add(ErrorType.Error, "Patch lump '" + p.lumpname + "' data format could not be read, while loading texture '" + this.Name + "'. Does this lump contain valid picture data at all?");
 								loadfailed = true;
 							}
 							else
 							{
 								// Draw the patch
 								mem.Seek(0, SeekOrigin.Begin);
 								try { reader.DrawToPixelData(mem, pixels, width, height, p.x, p.y); }
 								catch(InvalidDataException)
 								{
 									// Data cannot be read!
 									General.ErrorLogger.Add(ErrorType.Error, "Patch lump '" + p.lumpname + "' data format could not be read, while loading texture '" + this.Name + "'. Does this lump contain valid picture data at all?");
 									loadfailed = true;
 								}
 							}
 
 							// Done
 							mem.Dispose();
 						}
 						else
 						{
 							// Missing a patch lump!
 							General.ErrorLogger.Add(ErrorType.Error, "Missing patch lump '" + p.lumpname + "' while loading texture '" + this.Name + "'. Did you forget to include required resources?");
 							loadfailed = true;
 						}
 					}
 
 					// Done
 					bitmap.UnlockBits(bitmapdata);
 				}
 				
 				// Dispose bitmap if load failed
 				if(loadfailed && (bitmap != null))
 				{
 					bitmap.Dispose();
 					bitmap = null;
 				}
 
 				// Pass on to base
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\ProjectedFrustum2D.cs" startline="129" endline="152">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This checks if a specified circle is intersecting the frustum
 		// NOTE
 		public bool IntersectCircle(Vector2D circlecenter, float circleradius)
 		{
 			// Go for all frustum lines
 			for(int i = 0; i < lines.Length; i++)
 			{
 				// Check on which side the circle center lies
 				if(lines[i].GetSideOfLine(circlecenter) < 0)
 				{
 					// Center is outside the frustum
 					// If the circle is not overlapping, it is not intersecting.
 					if(lines[i].GetDistanceToLineSq(circlecenter, false) > (circleradius * circleradius)) return false;
 				}
 			}
 			for(int i = 0; i < lines.Length; i++)
 			{
 				// Check on which side the circle center lies
 				if(lines[i].GetSideOfLine(circlecenter) < 0)
 				{
 					// Center is outside the frustum
 					// If the circle is not overlapping, it is not intersecting.
 					if(lines[i].GetDistanceToLineSq(circlecenter, false) > (circleradius * circleradius)) return false;
 				}
 			}
 
 			// Intersecting!
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\TexturesParser.cs" startline="74" endline="193">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Parsing
 
 		// This parses the given stream
 		// Returns false on errors
 		public override bool Parse(Stream stream, string sourcefilename)
 		{
 			base.Parse(stream, sourcefilename);
 			
 			// Continue until at the end of the stream
 			while(SkipWhitespace(true))
 			{
 				// Read a token
 				string objdeclaration = ReadToken();
 				if(objdeclaration != null)
 				{
 					objdeclaration = objdeclaration.ToLowerInvariant();
 					if(objdeclaration == "texture")
 					{
 						// Read texture structure
 						TextureStructure tx = new TextureStructure(this, "texture");
 						if(this.HasError) break;
 
 						// if a limit for the texture name length is set make sure that it's not exceeded
 						if ((General.Map.Config.MaxTextureNamelength > 0) && (tx.Name.Length > General.Map.Config.MaxTextureNamelength))
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "Texture name \"" + tx.Name + "\" too long. Texture names must have a length of " + General.Map.Config.MaxTextureNamelength.ToString() + " characters or less");
 						}
 						else
 						{
 							// Add the texture
 							textures[tx.Name] = tx;
 							flats[tx.Name] = tx;
 						}
 					}
 					else if(objdeclaration == "sprite")
 					{
 						// Read sprite structure
 						TextureStructure tx = new TextureStructure(this, "sprite");
 						if(this.HasError) break;
 
 						// if a limit for the sprite name length is set make sure that it's not exceeded
 						if ((General.Map.Config.MaxTextureNamelength > 0) && (tx.Name.Length > General.Map.Config.MaxTextureNamelength))
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "Sprite name \"" + tx.Name + "\" too long. Sprite names must have a length of " +  General.Map.Config.MaxTextureNamelength.ToString() + " characters or less");
 						}
 						else
 						{
 							// Add the sprite
 							sprites[tx.Name] = tx;
 						}
 					}
 					else if(objdeclaration == "walltexture")
 					{
 						// Read walltexture structure
 						TextureStructure tx = new TextureStructure(this, "walltexture");
 						if(this.HasError) break;
 
 						// if a limit for the walltexture name length is set make sure that it's not exceeded
 						if((General.Map.Config.MaxTextureNamelength > 0) && (tx.Name.Length > General.Map.Config.MaxTextureNamelength))
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "WallTexture name \"" + tx.Name + "\" too long. WallTexture names must have a length of " + General.Map.Config.MaxTextureNamelength.ToString() + " characters or less");
 						}
 						else
 						{
 							// Add the walltexture
 							if(!textures.ContainsKey(tx.Name) || (textures[tx.Name].TypeName != "texture"))
 								textures[tx.Name] = tx;
 						}
 					}
 					else if(objdeclaration == "flat")
 					{
 						// Read flat structure
 						TextureStructure tx = new TextureStructure(this, "flat");
 						if(this.HasError) break;
 
 						// if a limit for the flat name length is set make sure that it's not exceeded
 						if((General.Map.Config.MaxTextureNamelength > 0) && (tx.Name.Length > General.Map.Config.MaxTextureNamelength))
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "Flat name \"" + tx.Name + "\" too long. Flat names must have a length of " + General.Map.Config.MaxTextureNamelength.ToString() + " characters or less");
 						}
 						else
 						{
 							// Add the flat
 							if(!flats.ContainsKey(tx.Name) || (flats[tx.Name].TypeName != "texture"))
 								flats[tx.Name] = tx;
 						}
 					}
 					else
 					{
 						// Unknown structure!
 						// Best we can do now is just find the first { and then
 						// follow the scopes until the matching } is found
 						string token2;
 						do
 						{
 							if(!SkipWhitespace(true)) break;
 							token2 = ReadToken();
 							if(token2 == null) break;
 						}
 						while(token2 != "{");
 						int scopelevel = 1;
 						do
 						{
 							if(!SkipWhitespace(true)) break;
 							token2 = ReadToken();
 							if(token2 == null) break;
 							if(token2 == "{") scopelevel++;
 							if(token2 == "}") scopelevel--;
 						}
 						while(scopelevel > 0);
 					}
 				}
 			}
 			while(SkipWhitespace(true))
 			{
 				// Read a token
 				string objdeclaration = ReadToken();
 				if(objdeclaration != null)
 				{
 					objdeclaration = objdeclaration.ToLowerInvariant();
 					if(objdeclaration == "texture")
 					{
 						// Read texture structure
 						TextureStructure tx = new TextureStructure(this, "texture");
 						if(this.HasError) break;
 
 						// if a limit for the texture name length is set make sure that it's not exceeded
 						if ((General.Map.Config.MaxTextureNamelength > 0) && (tx.Name.Length > General.Map.Config.MaxTextureNamelength))
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "Texture name \"" + tx.Name + "\" too long. Texture names must have a length of " + General.Map.Config.MaxTextureNamelength.ToString() + " characters or less");
 						}
 						else
 						{
 							// Add the texture
 							textures[tx.Name] = tx;
 							flats[tx.Name] = tx;
 						}
 					}
 					else if(objdeclaration == "sprite")
 					{
 						// Read sprite structure
 						TextureStructure tx = new TextureStructure(this, "sprite");
 						if(this.HasError) break;
 
 						// if a limit for the sprite name length is set make sure that it's not exceeded
 						if ((General.Map.Config.MaxTextureNamelength > 0) && (tx.Name.Length > General.Map.Config.MaxTextureNamelength))
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "Sprite name \"" + tx.Name + "\" too long. Sprite names must have a length of " +  General.Map.Config.MaxTextureNamelength.ToString() + " characters or less");
 						}
 						else
 						{
 							// Add the sprite
 							sprites[tx.Name] = tx;
 						}
 					}
 					else if(objdeclaration == "walltexture")
 					{
 						// Read walltexture structure
 						TextureStructure tx = new TextureStructure(this, "walltexture");
 						if(this.HasError) break;
 
 						// if a limit for the walltexture name length is set make sure that it's not exceeded
 						if((General.Map.Config.MaxTextureNamelength > 0) && (tx.Name.Length > General.Map.Config.MaxTextureNamelength))
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "WallTexture name \"" + tx.Name + "\" too long. WallTexture names must have a length of " + General.Map.Config.MaxTextureNamelength.ToString() + " characters or less");
 						}
 						else
 						{
 							// Add the walltexture
 							if(!textures.ContainsKey(tx.Name) || (textures[tx.Name].TypeName != "texture"))
 								textures[tx.Name] = tx;
 						}
 					}
 					else if(objdeclaration == "flat")
 					{
 						// Read flat structure
 						TextureStructure tx = new TextureStructure(this, "flat");
 						if(this.HasError) break;
 
 						// if a limit for the flat name length is set make sure that it's not exceeded
 						if((General.Map.Config.MaxTextureNamelength > 0) && (tx.Name.Length > General.Map.Config.MaxTextureNamelength))
 						{
 							General.ErrorLogger.Add(ErrorType.Error, "Flat name \"" + tx.Name + "\" too long. Flat names must have a length of " + General.Map.Config.MaxTextureNamelength.ToString() + " characters or less");
 						}
 						else
 						{
 							// Add the flat
 							if(!flats.ContainsKey(tx.Name) || (flats[tx.Name].TypeName != "texture"))
 								flats[tx.Name] = tx;
 						}
 					}
 					else
 					{
 						// Unknown structure!
 						// Best we can do now is just find the first { and then
 						// follow the scopes until the matching } is found
 						string token2;
 						do
 						{
 							if(!SkipWhitespace(true)) break;
 							token2 = ReadToken();
 							if(token2 == null) break;
 						}
 						while(token2 != "{");
 						int scopelevel = 1;
 						do
 						{
 							if(!SkipWhitespace(true)) break;
 							token2 = ReadToken();
 							if(token2 == null) break;
 							if(token2 == "{") scopelevel++;
 							if(token2 == "}") scopelevel--;
 						}
 						while(scopelevel > 0);
 					}
 				}
 			}
 			
 			// Return true when no errors occurred
 			return (ErrorDescription == null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.Designer.cs" startline="22" endline="175">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle24 = new System.Windows.Forms.DataGridViewCellStyle();
 			System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle21 = new System.Windows.Forms.DataGridViewCellStyle();
 			System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle22 = new System.Windows.Forms.DataGridViewCellStyle();
 			System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle23 = new System.Windows.Forms.DataGridViewCellStyle();
 			this.fieldslist = new System.Windows.Forms.DataGridView();
 			this.fieldname = new System.Windows.Forms.DataGridViewTextBoxColumn();
 			this.fieldtype = new System.Windows.Forms.DataGridViewComboBoxColumn();
 			this.fieldvalue = new System.Windows.Forms.DataGridViewTextBoxColumn();
 			this.deleterowstimer = new System.Windows.Forms.Timer(this.components);
 			this.browsebutton = new System.Windows.Forms.Button();
 			this.enumscombo = new System.Windows.Forms.ComboBox();
 			((System.ComponentModel.ISupportInitialize)(this.fieldslist)).BeginInit();
 			this.SuspendLayout();
 			// 
 			// fieldslist
 			// 
 			this.fieldslist.AllowUserToResizeColumns = false;
 			this.fieldslist.AllowUserToResizeRows = false;
 			this.fieldslist.BackgroundColor = System.Drawing.SystemColors.Window;
 			this.fieldslist.BorderStyle = System.Windows.Forms.BorderStyle.None;
 			this.fieldslist.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.None;
 			this.fieldslist.ClipboardCopyMode = System.Windows.Forms.DataGridViewClipboardCopyMode.Disable;
 			this.fieldslist.ColumnHeadersBorderStyle = System.Windows.Forms.DataGridViewHeaderBorderStyle.Single;
 			this.fieldslist.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
 			this.fieldslist.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
             this.fieldname,
             this.fieldtype,
             this.fieldvalue});
 			dataGridViewCellStyle24.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
 			dataGridViewCellStyle24.BackColor = System.Drawing.SystemColors.Window;
 			dataGridViewCellStyle24.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			dataGridViewCellStyle24.ForeColor = System.Drawing.SystemColors.WindowText;
 			dataGridViewCellStyle24.SelectionBackColor = System.Drawing.SystemColors.Highlight;
 			dataGridViewCellStyle24.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
 			dataGridViewCellStyle24.WrapMode = System.Windows.Forms.DataGridViewTriState.False;
 			this.fieldslist.DefaultCellStyle = dataGridViewCellStyle24;
 			this.fieldslist.EditMode = System.Windows.Forms.DataGridViewEditMode.EditProgrammatically;
 			this.fieldslist.Location = new System.Drawing.Point(0, 0);
 			this.fieldslist.MultiSelect = false;
 			this.fieldslist.Name = "fieldslist";
 			this.fieldslist.RowHeadersVisible = false;
 			this.fieldslist.RowTemplate.DefaultCellStyle.BackColor = System.Drawing.SystemColors.Window;
 			this.fieldslist.RowTemplate.DefaultCellStyle.ForeColor = System.Drawing.SystemColors.WindowText;
 			this.fieldslist.RowTemplate.DefaultCellStyle.SelectionBackColor = System.Drawing.SystemColors.Highlight;
 			this.fieldslist.RowTemplate.DefaultCellStyle.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
 			this.fieldslist.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
 			this.fieldslist.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
 			this.fieldslist.Size = new System.Drawing.Size(444, 263);
 			this.fieldslist.TabIndex = 1;
 			this.fieldslist.Scroll += new System.Windows.Forms.ScrollEventHandler(this.fieldslist_Scroll);
 			this.fieldslist.UserDeletingRow += new System.Windows.Forms.DataGridViewRowCancelEventHandler(this.fieldslist_UserDeletingRow);
 			this.fieldslist.CellBeginEdit += new System.Windows.Forms.DataGridViewCellCancelEventHandler(this.fieldslist_CellBeginEdit);
 			this.fieldslist.CellDoubleClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.fieldslist_CellDoubleClick);
 			this.fieldslist.ColumnHeaderMouseClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.fieldslist_ColumnHeaderMouseClick);
 			this.fieldslist.MouseUp += new System.Windows.Forms.MouseEventHandler(this.fieldslist_MouseUp);
 			this.fieldslist.CellEndEdit += new System.Windows.Forms.DataGridViewCellEventHandler(this.fieldslist_CellEndEdit);
 			this.fieldslist.CellClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.fieldslist_CellClick);
 			this.fieldslist.DataError += new System.Windows.Forms.DataGridViewDataErrorEventHandler(this.fieldslist_DataError);
 			this.fieldslist.SelectionChanged += new System.EventHandler(this.fieldslist_SelectionChanged);
 			// 
 			// fieldname
 			// 
 			dataGridViewCellStyle21.BackColor = System.Drawing.SystemColors.Window;
 			dataGridViewCellStyle21.ForeColor = System.Drawing.SystemColors.WindowText;
 			dataGridViewCellStyle21.NullValue = null;
 			dataGridViewCellStyle21.SelectionBackColor = System.Drawing.SystemColors.Highlight;
 			dataGridViewCellStyle21.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
 			this.fieldname.DefaultCellStyle = dataGridViewCellStyle21;
 			this.fieldname.Frozen = true;
 			this.fieldname.HeaderText = "Property";
 			this.fieldname.Name = "fieldname";
 			this.fieldname.Width = 150;
 			// 
 			// fieldtype
 			// 
 			this.fieldtype.AutoComplete = false;
 			dataGridViewCellStyle22.BackColor = System.Drawing.SystemColors.Window;
 			dataGridViewCellStyle22.ForeColor = System.Drawing.SystemColors.WindowText;
 			dataGridViewCellStyle22.SelectionBackColor = System.Drawing.SystemColors.Highlight;
 			dataGridViewCellStyle22.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
 			this.fieldtype.DefaultCellStyle = dataGridViewCellStyle22;
 			this.fieldtype.DisplayStyle = System.Windows.Forms.DataGridViewComboBoxDisplayStyle.Nothing;
 			this.fieldtype.HeaderText = "Type";
 			this.fieldtype.Name = "fieldtype";
 			this.fieldtype.Resizable = System.Windows.Forms.DataGridViewTriState.True;
 			this.fieldtype.Sorted = true;
 			this.fieldtype.SortMode = System.Windows.Forms.DataGridViewColumnSortMode.Automatic;
 			// 
 			// fieldvalue
 			// 
 			dataGridViewCellStyle23.BackColor = System.Drawing.SystemColors.Window;
 			dataGridViewCellStyle23.ForeColor = System.Drawing.SystemColors.WindowText;
 			dataGridViewCellStyle23.SelectionBackColor = System.Drawing.SystemColors.Highlight;
 			dataGridViewCellStyle23.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
 			this.fieldvalue.DefaultCellStyle = dataGridViewCellStyle23;
 			this.fieldvalue.HeaderText = "Value";
 			this.fieldvalue.Name = "fieldvalue";
 			this.fieldvalue.Resizable = System.Windows.Forms.DataGridViewTriState.True;
 			this.fieldvalue.Width = 120;
 			// 
 			// deleterowstimer
 			// 
 			this.deleterowstimer.Interval = 1;
 			this.deleterowstimer.Tick += new System.EventHandler(this.deleterowstimer_Tick);
 			// 
 			// browsebutton
 			// 
 			this.browsebutton.FlatStyle = System.Windows.Forms.FlatStyle.Popup;
 			this.browsebutton.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.browsebutton.Image = global
 			this.browsebutton.Location = new System.Drawing.Point(343, 75);
 			this.browsebutton.Name = "browsebutton";
 			this.browsebutton.Size = new System.Drawing.Size(28, 22);
 			this.browsebutton.TabIndex = 2;
 			this.browsebutton.TabStop = false;
 			this.browsebutton.UseVisualStyleBackColor = true;
 			this.browsebutton.Click += new System.EventHandler(this.browsebutton_Click);
 			// 
 			// enumscombo
 			// 
 			this.enumscombo.FormattingEnabled = true;
 			this.enumscombo.ItemHeight = 14;
 			this.enumscombo.Location = new System.Drawing.Point(295, 121);
 			this.enumscombo.Name = "enumscombo";
 			this.enumscombo.Size = new System.Drawing.Size(128, 22);
 			this.enumscombo.TabIndex = 3;
 			this.enumscombo.Validating += new System.ComponentModel.CancelEventHandler(this.enumscombo_Validating);
 			// 
 			// FieldsEditorControl
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.enumscombo);
 			this.Controls.Add(this.browsebutton);
 			this.Controls.Add(this.fieldslist);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.Name = "FieldsEditorControl";
 			this.Size = new System.Drawing.Size(474, 286);
 			this.Layout += new System.Windows.Forms.LayoutEventHandler(this.FieldsEditorControl_Layout);
 			this.Resize += new System.EventHandler(this.FieldsEditorControl_Resize);
 			((System.ComponentModel.ISupportInitialize)(this.fieldslist)).EndInit();
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FieldsEditorControl.cs" startline="747" endline="762">
<![CDATA[
 		
 		// This sets up the new row
 		private void SetupNewRowStyle()
 		{
 			if(fieldslist.AllowUserToAddRows)
 			{
 				// Show text for new row
 				fieldslist.Rows[fieldslist.NewRowIndex].Cells[0].Value = ADD_FIELD_TEXT;
 				fieldslist.Rows[fieldslist.NewRowIndex].Cells[0].Style.ForeColor = SystemColors.GrayText;
 				fieldslist.Rows[fieldslist.NewRowIndex].Cells[0].ReadOnly = false;
 
 				// Make sure user can only enter property name in a new row
 				fieldslist.Rows[fieldslist.NewRowIndex].Cells[1].ReadOnly = true;
 				fieldslist.Rows[fieldslist.NewRowIndex].Cells[2].ReadOnly = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="419" endline="447">
<![CDATA[
 
 		// This draws a preview
 		public virtual void DrawPreview(Graphics target, Point targetpos)
 		{
 			lock(this)
 			{
 				// Preview ready?
 				if(!loadfailed && (previewstate == ImageLoadState.Ready))
 				{
 					// Draw preview
 					General.Map.Data.Previews.DrawPreview(previewindex, target, targetpos);
 				}
 				// Loading failed?
 				else if(loadfailed)
 				{
 					// Draw error bitmap
 					targetpos = new Point(targetpos.X + ((General.Map.Data.Previews.MaxImageWidth - Properties.Resources.Hourglass.Width) >> 1),
 										  targetpos.Y + ((General.Map.Data.Previews.MaxImageHeight - Properties.Resources.Hourglass.Height) >> 1));
 					target.DrawImageUnscaled(Properties.Resources.Failed, targetpos);
 				}
 				else
 				{
 					// Draw loading bitmap
 					targetpos = new Point(targetpos.X + ((General.Map.Data.Previews.MaxImageWidth - Properties.Resources.Hourglass.Width) >> 1),
 										  targetpos.Y + ((General.Map.Data.Previews.MaxImageHeight - Properties.Resources.Hourglass.Height) >> 1));
 					target.DrawImageUnscaled(Properties.Resources.Hourglass, targetpos);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="581" endline="757">
<![CDATA[
 
 		// This performs a single render pass
 		private void RenderSinglePass(int pass)
 		{
 			int currentshaderpass = shaderpass;
 			int highshaderpass = shaderpass + 2;
 			
 			// Get geometry for this pass
 			Dictionary<ImageData, BinaryHeap<VisualGeometry>> geopass = geometry[pass];
 
 			// Begin rendering with this shader
 			graphics.Shaders.World3D.BeginPass(shaderpass);
 			
 			// Render the geometry collected
 			foreach(KeyValuePair<ImageData, BinaryHeap<VisualGeometry>> group in geopass)
 			{
 				ImageData curtexture;
 
 				// What texture to use?
 				if(group.Key is UnknownImage)
 					curtexture = General.Map.Data.UnknownTexture3D;
 				else if((group.Key != null) && group.Key.IsImageLoaded && !group.Key.IsDisposed)
 					curtexture = group.Key;
 				else
 					curtexture = General.Map.Data.Hourglass3D;
 
 				// Create Direct3D texture if still needed
 				if((curtexture.Texture == null) || curtexture.Texture.Disposed)
 					curtexture.CreateTexture();
 
 				// Apply texture
 				if(!graphics.Shaders.Enabled) graphics.Device.SetTexture(0, curtexture.Texture);
 				graphics.Shaders.World3D.Texture1 = curtexture.Texture;
 				
 				// Go for all geometry that uses this texture
 				VisualSector sector = null;
 				foreach(VisualGeometry g in group.Value)
 				{
 					// Changing sector?
 					if(!object.ReferenceEquals(g.Sector, sector))
 					{
 						// Update the sector if needed
 						if(g.Sector.NeedsUpdateGeo) g.Sector.Update();
 
 						// Only do this sector when a vertexbuffer is created
 						if(g.Sector.GeometryBuffer != null)
 						{
 							// Change current sector
 							sector = g.Sector;
 
 							// Set stream source
 							graphics.Device.SetStreamSource(0, sector.GeometryBuffer, 0, WorldVertex.Stride);
 						}
 						else
 						{
 							sector = null;
 						}
 					}	
 					
 					if(sector != null)
 					{
 						// Determine the shader pass we want to use for this object
 						int wantedshaderpass = (((g == highlighted) && showhighlight) || (g.Selected && showselection)) ? highshaderpass 
 						
 						// Switch shader pass?
 						if(currentshaderpass != wantedshaderpass)
 						{
 							graphics.Shaders.World3D.EndPass();
 							graphics.Shaders.World3D.BeginPass(wantedshaderpass);
 							currentshaderpass = wantedshaderpass;
 						}
 						
 						// Set the colors to use
 						if(!graphics.Shaders.Enabled)
 						{
 							graphics.Device.SetTexture(2, (g.Selected && showselection) ? selectionimage.Texture 
 							graphics.Device.SetTexture(3, ((g == highlighted) && showhighlight) ? highlightimage.Texture 
 						}
 						else
 						{
 							graphics.Shaders.World3D.SetHighlightColor(CalculateHighlightColor((g == highlighted) && showhighlight, (g.Selected && showselection)).ToArgb());
 							graphics.Shaders.World3D.ApplySettings();
 						}
 						
 						// Render!
 						graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, g.VertexOffset, g.Triangles);
 					}
 				}
 				foreach(VisualGeometry g in group.Value)
 				{
 					// Changing sector?
 					if(!object.ReferenceEquals(g.Sector, sector))
 					{
 						// Update the sector if needed
 						if(g.Sector.NeedsUpdateGeo) g.Sector.Update();
 
 						// Only do this sector when a vertexbuffer is created
 						if(g.Sector.GeometryBuffer != null)
 						{
 							// Change current sector
 							sector = g.Sector;
 
 							// Set stream source
 							graphics.Device.SetStreamSource(0, sector.GeometryBuffer, 0, WorldVertex.Stride);
 						}
 						else
 						{
 							sector = null;
 						}
 					}	
 					
 					if(sector != null)
 					{
 						// Determine the shader pass we want to use for this object
 						int wantedshaderpass = (((g == highlighted) && showhighlight) || (g.Selected && showselection)) ? highshaderpass 
 						
 						// Switch shader pass?
 						if(currentshaderpass != wantedshaderpass)
 						{
 							graphics.Shaders.World3D.EndPass();
 							graphics.Shaders.World3D.BeginPass(wantedshaderpass);
 							currentshaderpass = wantedshaderpass;
 						}
 						
 						// Set the colors to use
 						if(!graphics.Shaders.Enabled)
 						{
 							graphics.Device.SetTexture(2, (g.Selected && showselection) ? selectionimage.Texture 
 							graphics.Device.SetTexture(3, ((g == highlighted) && showhighlight) ? highlightimage.Texture 
 						}
 						else
 						{
 							graphics.Shaders.World3D.SetHighlightColor(CalculateHighlightColor((g == highlighted) && showhighlight, (g.Selected && showselection)).ToArgb());
 							graphics.Shaders.World3D.ApplySettings();
 						}
 						
 						// Render!
 						graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, g.VertexOffset, g.Triangles);
 					}
 				}
 			}
 			foreach(KeyValuePair<ImageData, BinaryHeap<VisualGeometry>> group in geopass)
 			{
 				ImageData curtexture;
 
 				// What texture to use?
 				if(group.Key is UnknownImage)
 					curtexture = General.Map.Data.UnknownTexture3D;
 				else if((group.Key != null) && group.Key.IsImageLoaded && !group.Key.IsDisposed)
 					curtexture = group.Key;
 				else
 					curtexture = General.Map.Data.Hourglass3D;
 
 				// Create Direct3D texture if still needed
 				if((curtexture.Texture == null) || curtexture.Texture.Disposed)
 					curtexture.CreateTexture();
 
 				// Apply texture
 				if(!graphics.Shaders.Enabled) graphics.Device.SetTexture(0, curtexture.Texture);
 				graphics.Shaders.World3D.Texture1 = curtexture.Texture;
 				
 				// Go for all geometry that uses this texture
 				VisualSector sector = null;
 				foreach(VisualGeometry g in group.Value)
 				{
 					// Changing sector?
 					if(!object.ReferenceEquals(g.Sector, sector))
 					{
 						// Update the sector if needed
 						if(g.Sector.NeedsUpdateGeo) g.Sector.Update();
 
 						// Only do this sector when a vertexbuffer is created
 						if(g.Sector.GeometryBuffer != null)
 						{
 							// Change current sector
 							sector = g.Sector;
 
 							// Set stream source
 							graphics.Device.SetStreamSource(0, sector.GeometryBuffer, 0, WorldVertex.Stride);
 						}
 						else
 						{
 							sector = null;
 						}
 					}	
 					
 					if(sector != null)
 					{
 						// Determine the shader pass we want to use for this object
 						int wantedshaderpass = (((g == highlighted) && showhighlight) || (g.Selected && showselection)) ? highshaderpass 
 						
 						// Switch shader pass?
 						if(currentshaderpass != wantedshaderpass)
 						{
 							graphics.Shaders.World3D.EndPass();
 							graphics.Shaders.World3D.BeginPass(wantedshaderpass);
 							currentshaderpass = wantedshaderpass;
 						}
 						
 						// Set the colors to use
 						if(!graphics.Shaders.Enabled)
 						{
 							graphics.Device.SetTexture(2, (g.Selected && showselection) ? selectionimage.Texture 
 							graphics.Device.SetTexture(3, ((g == highlighted) && showhighlight) ? highlightimage.Texture 
 						}
 						else
 						{
 							graphics.Shaders.World3D.SetHighlightColor(CalculateHighlightColor((g == highlighted) && showhighlight, (g.Selected && showselection)).ToArgb());
 							graphics.Shaders.World3D.ApplySettings();
 						}
 						
 						// Render!
 						graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, g.VertexOffset, g.Triangles);
 					}
 				}
 			}
 
 			// Get things for this pass
 			Dictionary<ImageData, List<VisualThing>> thingspass = things[pass];
 			if(thingspass.Count > 0)
 			{
 				// Texture addressing
 				graphics.Device.SetSamplerState(0, SamplerState.AddressU, TextureAddress.Clamp);
 				graphics.Device.SetSamplerState(0, SamplerState.AddressV, TextureAddress.Clamp);
 				graphics.Device.SetSamplerState(0, SamplerState.AddressW, TextureAddress.Clamp);
 
 				// Render things collected
 				foreach(KeyValuePair<ImageData, List<VisualThing>> group in thingspass)
 				{
 					ImageData curtexture;
 
 					if(!(group.Key is UnknownImage))
 					{
 						// What texture to use?
 						if((group.Key != null) && group.Key.IsImageLoaded && !group.Key.IsDisposed)
 							curtexture = group.Key;
 						else
 							curtexture = General.Map.Data.Hourglass3D;
 
 						// Create Direct3D texture if still needed
 						if((curtexture.Texture == null) || curtexture.Texture.Disposed)
 							curtexture.CreateTexture();
 
 						// Apply texture
 						if(!graphics.Shaders.Enabled) graphics.Device.SetTexture(0, curtexture.Texture);
 						graphics.Shaders.World3D.Texture1 = curtexture.Texture;
 
 						// Render all things with this texture
 						foreach(VisualThing t in group.Value)
 						{
 							// Update buffer if needed
 							t.Update();
 
 							// Only do this sector when a vertexbuffer is created
 							if(t.GeometryBuffer != null)
 							{
 								// Determine the shader pass we want to use for this object
 								int wantedshaderpass = (((t == highlighted) && showhighlight) || (t.Selected && showselection)) ? highshaderpass 
 
 								// Switch shader pass?
 								if(currentshaderpass != wantedshaderpass)
 								{
 									graphics.Shaders.World3D.EndPass();
 									graphics.Shaders.World3D.BeginPass(wantedshaderpass);
 									currentshaderpass = wantedshaderpass;
 								}
 
 								// Set the colors to use
 								if(!graphics.Shaders.Enabled)
 								{
 									graphics.Device.SetTexture(2, (t.Selected && showselection) ? selectionimage.Texture 
 									graphics.Device.SetTexture(3, ((t == highlighted) && showhighlight) ? highlightimage.Texture 
 								}
 								else
 								{
 									graphics.Shaders.World3D.SetHighlightColor(CalculateHighlightColor((t == highlighted) && showhighlight, (t.Selected && showselection)).ToArgb());
 								}
 
 								// Create the matrix for positioning / rotation
 								world = t.Orientation;
 								if(t.Billboard) world = Matrix.Multiply(world, billboard);
 								world = Matrix.Multiply(world, t.Position);
 								ApplyMatrices3D();
 								graphics.Shaders.World3D.ApplySettings();
 
 								// Apply buffer
 								graphics.Device.SetStreamSource(0, t.GeometryBuffer, 0, WorldVertex.Stride);
 
 								// Render!
 								graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, 0, t.Triangles);
 							}
 						}
 						foreach(VisualThing t in group.Value)
 						{
 							// Update buffer if needed
 							t.Update();
 
 							// Only do this sector when a vertexbuffer is created
 							if(t.GeometryBuffer != null)
 							{
 								// Determine the shader pass we want to use for this object
 								int wantedshaderpass = (((t == highlighted) && showhighlight) || (t.Selected && showselection)) ? highshaderpass 
 
 								// Switch shader pass?
 								if(currentshaderpass != wantedshaderpass)
 								{
 									graphics.Shaders.World3D.EndPass();
 									graphics.Shaders.World3D.BeginPass(wantedshaderpass);
 									currentshaderpass = wantedshaderpass;
 								}
 
 								// Set the colors to use
 								if(!graphics.Shaders.Enabled)
 								{
 									graphics.Device.SetTexture(2, (t.Selected && showselection) ? selectionimage.Texture 
 									graphics.Device.SetTexture(3, ((t == highlighted) && showhighlight) ? highlightimage.Texture 
 								}
 								else
 								{
 									graphics.Shaders.World3D.SetHighlightColor(CalculateHighlightColor((t == highlighted) && showhighlight, (t.Selected && showselection)).ToArgb());
 								}
 
 								// Create the matrix for positioning / rotation
 								world = t.Orientation;
 								if(t.Billboard) world = Matrix.Multiply(world, billboard);
 								world = Matrix.Multiply(world, t.Position);
 								ApplyMatrices3D();
 								graphics.Shaders.World3D.ApplySettings();
 
 								// Apply buffer
 								graphics.Device.SetStreamSource(0, t.GeometryBuffer, 0, WorldVertex.Stride);
 
 								// Render!
 								graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, 0, t.Triangles);
 							}
 						}
 					}
 				}
 				foreach(KeyValuePair<ImageData, List<VisualThing>> group in thingspass)
 				{
 					ImageData curtexture;
 
 					if(!(group.Key is UnknownImage))
 					{
 						// What texture to use?
 						if((group.Key != null) && group.Key.IsImageLoaded && !group.Key.IsDisposed)
 							curtexture = group.Key;
 						else
 							curtexture = General.Map.Data.Hourglass3D;
 
 						// Create Direct3D texture if still needed
 						if((curtexture.Texture == null) || curtexture.Texture.Disposed)
 							curtexture.CreateTexture();
 
 						// Apply texture
 						if(!graphics.Shaders.Enabled) graphics.Device.SetTexture(0, curtexture.Texture);
 						graphics.Shaders.World3D.Texture1 = curtexture.Texture;
 
 						// Render all things with this texture
 						foreach(VisualThing t in group.Value)
 						{
 							// Update buffer if needed
 							t.Update();
 
 							// Only do this sector when a vertexbuffer is created
 							if(t.GeometryBuffer != null)
 							{
 								// Determine the shader pass we want to use for this object
 								int wantedshaderpass = (((t == highlighted) && showhighlight) || (t.Selected && showselection)) ? highshaderpass 
 
 								// Switch shader pass?
 								if(currentshaderpass != wantedshaderpass)
 								{
 									graphics.Shaders.World3D.EndPass();
 									graphics.Shaders.World3D.BeginPass(wantedshaderpass);
 									currentshaderpass = wantedshaderpass;
 								}
 
 								// Set the colors to use
 								if(!graphics.Shaders.Enabled)
 								{
 									graphics.Device.SetTexture(2, (t.Selected && showselection) ? selectionimage.Texture 
 									graphics.Device.SetTexture(3, ((t == highlighted) && showhighlight) ? highlightimage.Texture 
 								}
 								else
 								{
 									graphics.Shaders.World3D.SetHighlightColor(CalculateHighlightColor((t == highlighted) && showhighlight, (t.Selected && showselection)).ToArgb());
 								}
 
 								// Create the matrix for positioning / rotation
 								world = t.Orientation;
 								if(t.Billboard) world = Matrix.Multiply(world, billboard);
 								world = Matrix.Multiply(world, t.Position);
 								ApplyMatrices3D();
 								graphics.Shaders.World3D.ApplySettings();
 
 								// Apply buffer
 								graphics.Device.SetStreamSource(0, t.GeometryBuffer, 0, WorldVertex.Stride);
 
 								// Render!
 								graphics.Device.DrawPrimitives(PrimitiveType.TriangleList, 0, t.Triangles);
 							}
 						}
 					}
 				}
 				
 				// Texture addressing
 				graphics.Device.SetSamplerState(0, SamplerState.AddressU, TextureAddress.Wrap);
 				graphics.Device.SetSamplerState(0, SamplerState.AddressV, TextureAddress.Wrap);
 				graphics.Device.SetSamplerState(0, SamplerState.AddressW, TextureAddress.Wrap);
 			}
 
 			// Done rendering with this shader
 			graphics.Shaders.World3D.EndPass();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListEditor.Designer.cs" startline="22" endline="217">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			System.Windows.Forms.SplitContainer buttonsbar2;
 			System.Windows.Forms.SplitContainer buttonsbar1;
 			System.Windows.Forms.ListViewItem listViewItem1 = new System.Windows.Forms.ListViewItem(new string[] {
             "C
 			System.Windows.Forms.ListViewItem listViewItem2 = new System.Windows.Forms.ListViewItem(new string[] {
             "C
 			System.Windows.Forms.ListViewItem listViewItem3 = new System.Windows.Forms.ListViewItem("C
 			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ResourceListEditor));
 			this.editresource = new System.Windows.Forms.Button();
 			this.deleteresource = new System.Windows.Forms.Button();
 			this.addresource = new System.Windows.Forms.Button();
 			this.splitContainer1 = new System.Windows.Forms.SplitContainer();
 			this.resourceitems = new CodeImp.DoomBuilder.Controls.ResourceListView();
 			this.column = new System.Windows.Forms.ColumnHeader();
 			this.images = new System.Windows.Forms.ImageList(this.components);
 			buttonsbar2 = new System.Windows.Forms.SplitContainer();
 			buttonsbar1 = new System.Windows.Forms.SplitContainer();
 			buttonsbar2.Panel1.SuspendLayout();
 			buttonsbar2.Panel2.SuspendLayout();
 			buttonsbar2.SuspendLayout();
 			buttonsbar1.Panel1.SuspendLayout();
 			buttonsbar1.Panel2.SuspendLayout();
 			buttonsbar1.SuspendLayout();
 			this.splitContainer1.Panel1.SuspendLayout();
 			this.splitContainer1.Panel2.SuspendLayout();
 			this.splitContainer1.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// buttonsbar2
 			// 
 			buttonsbar2.Dock = System.Windows.Forms.DockStyle.Fill;
 			buttonsbar2.IsSplitterFixed = true;
 			buttonsbar2.Location = new System.Drawing.Point(0, 0);
 			buttonsbar2.Name = "buttonsbar2";
 			// 
 			// buttonsbar2.Panel1
 			// 
 			buttonsbar2.Panel1.Controls.Add(this.editresource);
 			// 
 			// buttonsbar2.Panel2
 			// 
 			buttonsbar2.Panel2.Controls.Add(this.deleteresource);
 			buttonsbar2.Size = new System.Drawing.Size(228, 24);
 			buttonsbar2.SplitterDistance = 136;
 			buttonsbar2.TabIndex = 0;
 			// 
 			// editresource
 			// 
 			this.editresource.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.editresource.Enabled = false;
 			this.editresource.Location = new System.Drawing.Point(0, 0);
 			this.editresource.Name = "editresource";
 			this.editresource.Size = new System.Drawing.Size(136, 24);
 			this.editresource.TabIndex = 0;
 			this.editresource.Text = "Resource options...";
 			this.editresource.UseVisualStyleBackColor = true;
 			this.editresource.Click += new System.EventHandler(this.editresource_Click);
 			// 
 			// deleteresource
 			// 
 			this.deleteresource.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.deleteresource.Enabled = false;
 			this.deleteresource.Location = new System.Drawing.Point(0, 0);
 			this.deleteresource.Name = "deleteresource";
 			this.deleteresource.Size = new System.Drawing.Size(88, 24);
 			this.deleteresource.TabIndex = 0;
 			this.deleteresource.Text = "Remove";
 			this.deleteresource.UseVisualStyleBackColor = true;
 			this.deleteresource.Click += new System.EventHandler(this.deleteresource_Click);
 			// 
 			// buttonsbar1
 			// 
 			buttonsbar1.Dock = System.Windows.Forms.DockStyle.Fill;
 			buttonsbar1.IsSplitterFixed = true;
 			buttonsbar1.Location = new System.Drawing.Point(0, 0);
 			buttonsbar1.Name = "buttonsbar1";
 			// 
 			// buttonsbar1.Panel1
 			// 
 			buttonsbar1.Panel1.Controls.Add(this.addresource);
 			// 
 			// buttonsbar1.Panel2
 			// 
 			buttonsbar1.Panel2.Controls.Add(buttonsbar2);
 			buttonsbar1.Size = new System.Drawing.Size(350, 24);
 			buttonsbar1.SplitterDistance = 118;
 			buttonsbar1.TabIndex = 0;
 			// 
 			// addresource
 			// 
 			this.addresource.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.addresource.Location = new System.Drawing.Point(0, 0);
 			this.addresource.Name = "addresource";
 			this.addresource.Size = new System.Drawing.Size(118, 24);
 			this.addresource.TabIndex = 0;
 			this.addresource.Text = "Add resource...";
 			this.addresource.UseVisualStyleBackColor = true;
 			this.addresource.Click += new System.EventHandler(this.addresource_Click);
 			// 
 			// splitContainer1
 			// 
 			this.splitContainer1.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.splitContainer1.FixedPanel = System.Windows.Forms.FixedPanel.Panel2;
 			this.splitContainer1.IsSplitterFixed = true;
 			this.splitContainer1.Location = new System.Drawing.Point(0, 0);
 			this.splitContainer1.Name = "splitContainer1";
 			this.splitContainer1.Orientation = System.Windows.Forms.Orientation.Horizontal;
 			// 
 			// splitContainer1.Panel1
 			// 
 			this.splitContainer1.Panel1.Controls.Add(this.resourceitems);
 			// 
 			// splitContainer1.Panel2
 			// 
 			this.splitContainer1.Panel2.Controls.Add(buttonsbar1);
 			this.splitContainer1.Panel2MinSize = 24;
 			this.splitContainer1.Size = new System.Drawing.Size(350, 166);
 			this.splitContainer1.SplitterDistance = 138;
 			this.splitContainer1.TabIndex = 0;
 			// 
 			// resourceitems
 			// 
 			this.resourceitems.AllowDrop = true;
 			this.resourceitems.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.column});
 			this.resourceitems.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.resourceitems.FullRowSelect = true;
 			this.resourceitems.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
 			this.resourceitems.HideSelection = false;
 			this.resourceitems.Items.AddRange(new System.Windows.Forms.ListViewItem[] {
             listViewItem1,
             listViewItem2,
             listViewItem3});
 			this.resourceitems.Location = new System.Drawing.Point(0, 0);
 			this.resourceitems.MultiSelect = false;
 			this.resourceitems.Name = "resourceitems";
 			this.resourceitems.ShowGroups = false;
 			this.resourceitems.ShowItemToolTips = true;
 			this.resourceitems.Size = new System.Drawing.Size(350, 138);
 			this.resourceitems.SmallImageList = this.images;
 			this.resourceitems.TabIndex = 0;
 			this.resourceitems.UseCompatibleStateImageBehavior = false;
 			this.resourceitems.View = System.Windows.Forms.View.Details;
 			this.resourceitems.ClientSizeChanged += new System.EventHandler(this.resourceitems_ClientSizeChanged);
 			this.resourceitems.SizeChanged += new System.EventHandler(this.resources_SizeChanged);
 			this.resourceitems.DoubleClick += new System.EventHandler(this.resourceitems_DoubleClick);
 			this.resourceitems.DragDrop += new System.Windows.Forms.DragEventHandler(this.resourceitems_DragDrop);
 			this.resourceitems.ItemSelectionChanged += new System.Windows.Forms.ListViewItemSelectionChangedEventHandler(this.resourceitems_ItemSelectionChanged);
 			this.resourceitems.DragOver += new System.Windows.Forms.DragEventHandler(this.resourceitems_DragOver);
 			// 
 			// column
 			// 
 			this.column.Text = "Resource location";
 			this.column.Width = 200;
 			// 
 			// images
 			// 
 			this.images.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("images.ImageStream")));
 			this.images.TransparentColor = System.Drawing.Color.Transparent;
 			this.images.Images.SetKeyName(0, "Folder.ico");
 			this.images.Images.SetKeyName(1, "File.ico");
 			this.images.Images.SetKeyName(2, "PK3.ico");
 			this.images.Images.SetKeyName(3, "FolderLocked.ico");
 			this.images.Images.SetKeyName(4, "FileLocked.ico");
 			this.images.Images.SetKeyName(5, "PK3Locked.ico");
 			// 
 			// ResourceListEditor
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.splitContainer1);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.Name = "ResourceListEditor";
 			this.Size = new System.Drawing.Size(350, 166);
 			buttonsbar2.Panel1.ResumeLayout(false);
 			buttonsbar2.Panel2.ResumeLayout(false);
 			buttonsbar2.ResumeLayout(false);
 			buttonsbar1.Panel1.ResumeLayout(false);
 			buttonsbar1.Panel2.ResumeLayout(false);
 			buttonsbar1.ResumeLayout(false);
 			this.splitContainer1.Panel1.ResumeLayout(false);
 			this.splitContainer1.Panel2.ResumeLayout(false);
 			this.splitContainer1.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingInfoPanel.cs" startline="53" endline="222">
<![CDATA[
 
 		// This shows the info
 		public void ShowInfo(Thing t)
 		{
 			ThingTypeInfo ti;
 			LinedefActionInfo act = null;
 			TypeHandler th;
 			string actioninfo = "";
 			string zinfo;
 			float zvalue;
 
 			// Show/hide stuff depending on format
 			if(!General.Map.FormatInterface.HasActionArgs)
 			{
 				arglbl1.Visible = false;
 				arglbl2.Visible = false;
 				arglbl3.Visible = false;
 				arglbl4.Visible = false;
 				arglbl5.Visible = false;
 				arg1.Visible = false;
 				arg2.Visible = false;
 				arg3.Visible = false;
 				arg4.Visible = false;
 				arg5.Visible = false;
 				infopanel.Width = doomformatwidth;
 			}
 			else
 			{
 				arglbl1.Visible = true;
 				arglbl2.Visible = true;
 				arglbl3.Visible = true;
 				arglbl4.Visible = true;
 				arglbl5.Visible = true;
 				arg1.Visible = true;
 				arg2.Visible = true;
 				arg3.Visible = true;
 				arg4.Visible = true;
 				arg5.Visible = true;
 				infopanel.Width = hexenformatwidth;
 			}
 
 			// Move panel
 			spritepanel.Left = infopanel.Left + infopanel.Width + infopanel.Margin.Right + spritepanel.Margin.Left;
 			
 			// Lookup thing info
 			ti = General.Map.Data.GetThingInfo(t.Type);
 
 			// Get thing action information
 			if(General.Map.Config.LinedefActions.ContainsKey(t.Action))
 			{
 				act = General.Map.Config.LinedefActions[t.Action];
 				actioninfo = act.ToString();
 			}
 			else if(t.Action == 0)
 				actioninfo = t.Action.ToString() + " - None";
 			else
 				actioninfo = t.Action.ToString() + " - Unknown";
 			
 			// Determine z info to show
 			t.DetermineSector();
 			if(ti.AbsoluteZ)
 			{
 				zvalue = t.Position.z;
 				zinfo = zvalue.ToString();
 			}
 			else
 			{
 				if(t.Sector != null)
 				{
 					// Hangs from ceiling?
 					if(ti.Hangs)
 					{
 						zvalue = (float)t.Sector.CeilHeight + t.Position.z;
 						zinfo = zvalue.ToString();
 					}
 					else
 					{
 						zvalue = (float)t.Sector.FloorHeight + t.Position.z;
 						zinfo = zvalue.ToString();
 					}
 				}
 				else
 				{
 					zvalue = t.Position.z;
 					if(zvalue >= 0.0f) zinfo = "+" + zvalue.ToString(); else zinfo = zvalue.ToString();
 				}
 			}
 
 			// Thing info
 			infopanel.Text = " Thing " + t.Index + " ";
 			type.Text = t.Type + " - " + ti.Title;
 			action.Text = actioninfo;
 			position.Text = t.Position.x.ToString() + ", " + t.Position.y.ToString() + ", " + zinfo;
 			tag.Text = t.Tag.ToString();
 			angle.Text = t.AngleDoom.ToString() + "\u00B0";
 			
 			// Sprite
 			if(ti.Sprite.ToLowerInvariant().StartsWith(DataManager.INTERNAL_PREFIX) && (ti.Sprite.Length > DataManager.INTERNAL_PREFIX.Length))
 			{
 				spritename.Text = "";
 				General.DisplayZoomedImage(spritetex, General.Map.Data.GetSpriteImage(ti.Sprite).GetBitmap());
 			}
 			else if((ti.Sprite.Length <= 8) && (ti.Sprite.Length > 0))
 			{
 				spritename.Text = ti.Sprite;
 				General.DisplayZoomedImage(spritetex, General.Map.Data.GetSpriteImage(ti.Sprite).GetPreview());
 			}
 			else
 			{
 				spritename.Text = "";
 				spritetex.BackgroundImage = null;
 			}
 			
 			// Arguments
 			if(act != null)
 			{
 				arglbl1.Text = act.Args[0].Title + "
 				arglbl2.Text = act.Args[1].Title + "
 				arglbl3.Text = act.Args[2].Title + "
 				arglbl4.Text = act.Args[3].Title + "
 				arglbl5.Text = act.Args[4].Title + "
 				arglbl1.Enabled = act.Args[0].Used;
 				arglbl2.Enabled = act.Args[1].Used;
 				arglbl3.Enabled = act.Args[2].Used;
 				arglbl4.Enabled = act.Args[3].Used;
 				arglbl5.Enabled = act.Args[4].Used;
 				arg1.Enabled = act.Args[0].Used;
 				arg2.Enabled = act.Args[1].Used;
 				arg3.Enabled = act.Args[2].Used;
 				arg4.Enabled = act.Args[3].Used;
 				arg5.Enabled = act.Args[4].Used;
 				th = General.Types.GetArgumentHandler(act.Args[0]);
 				th.SetValue(t.Args[0]); arg1.Text = th.GetStringValue();
 				th = General.Types.GetArgumentHandler(act.Args[1]);
 				th.SetValue(t.Args[1]); arg2.Text = th.GetStringValue();
 				th = General.Types.GetArgumentHandler(act.Args[2]);
 				th.SetValue(t.Args[2]); arg3.Text = th.GetStringValue();
 				th = General.Types.GetArgumentHandler(act.Args[3]);
 				th.SetValue(t.Args[3]); arg4.Text = th.GetStringValue();
 				th = General.Types.GetArgumentHandler(act.Args[4]);
 				th.SetValue(t.Args[4]); arg5.Text = th.GetStringValue();
 			}
 			else
 			{
 				arglbl1.Text = "Argument 1
 				arglbl2.Text = "Argument 2
 				arglbl3.Text = "Argument 3
 				arglbl4.Text = "Argument 4
 				arglbl5.Text = "Argument 5
 				arglbl1.Enabled = false;
 				arglbl2.Enabled = false;
 				arglbl3.Enabled = false;
 				arglbl4.Enabled = false;
 				arglbl5.Enabled = false;
 				arg1.Enabled = false;
 				arg2.Enabled = false;
 				arg3.Enabled = false;
 				arg4.Enabled = false;
 				arg5.Enabled = false;
 				arg1.Text = "-";
 				arg2.Text = "-";
 				arg3.Text = "-";
 				arg4.Text = "-";
 				arg5.Text = "-";
 			}
 
 			// Show the whole thing
 			this.Show();
 			this.Update();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="104" endline="124">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 		
 		// This returns the active child control
 		private Control FindActiveControl()
 		{
 			Control c = this.ActiveControl;
 			
 			while(c is IContainerControl)
 			{
 				IContainerControl cc = (c as IContainerControl);
 				if(cc.ActiveControl != null)
 					c = cc.ActiveControl;
 				else
 					break;
 			}
 			while(c is IContainerControl)
 			{
 				IContainerControl cc = (c as IContainerControl);
 				if(cc.ActiveControl != null)
 					c = cc.ActiveControl;
 				else
 					break;
 			}
 			
 			return c;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\FileImage.cs" startline="85" endline="133">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This loads the image
 		protected override void LocalLoadImage()
 		{
 			// Leave when already loaded
 			if(this.IsImageLoaded) return;
 
 			lock(this)
 			{
 				// Load file data
 				if(bitmap != null) bitmap.Dispose(); bitmap = null;
 				MemoryStream filedata = new MemoryStream(File.ReadAllBytes(filepathname));
 
 				// Get a reader for the data
 				IImageReader reader = ImageDataFormat.GetImageReader(filedata, probableformat, General.Map.Data.Palette);
 				if(!(reader is UnknownImageReader))
 				{
 					// Load the image
 					filedata.Seek(0, SeekOrigin.Begin);
 					try { bitmap = reader.ReadAsBitmap(filedata); }
 					catch(InvalidDataException)
 					{
 						// Data cannot be read!
 						bitmap = null;
 					}
 				}
 				
 				// Not loaded?
 				if(bitmap == null)
 				{
 					General.ErrorLogger.Add(ErrorType.Error, "Image file '" + filepathname + "' data format could not be read, while loading image '" + this.Name + "'. Is this a valid picture file at all?");
 					loadfailed = true;
 				}
 				else
 				{
 					// Get width and height
 					width = bitmap.Size.Width;
 					height = bitmap.Size.Height;
 				}
 				
 				// Pass on to base
 				filedata.Dispose();
 				base.LocalLoadImage();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\EffectBrowserForm.cs" startline="127" endline="136">
<![CDATA[
 		
 		// This browses for an effect
 		// Returns the new effect or the same effect when cancelled
 		public static int BrowseEffect(IWin32Window owner, int effect)
 		{
 			EffectBrowserForm f = new EffectBrowserForm(effect);
 			if(f.ShowDialog(owner) == DialogResult.OK) effect = f.SelectedEffect;
 			f.Dispose();
 			return effect;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingBrowserForm.cs" startline="57" endline="66">
<![CDATA[
 
 		// This browses for a thing type
 		// Returns the new thing type or the same thing type when cancelled
 		public static int BrowseThing(IWin32Window owner, int type)
 		{
 			ThingBrowserForm f = new ThingBrowserForm(type);
 			if(f.ShowDialog(owner) == DialogResult.OK) type = f.SelectedType;
 			f.Dispose();
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ActionBrowserForm.cs" startline="155" endline="164">
<![CDATA[
 		
 		// This browses for an action
 		// Returns the new action or the same action when cancelled
 		public static int BrowseAction(IWin32Window owner, int action)
 		{
 			ActionBrowserForm f = new ActionBrowserForm(action);
 			if(f.ShowDialog(owner) == DialogResult.OK) action = f.SelectedAction;
 			f.Dispose();
 			return action;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ActorStructure.cs" startline="531" endline="611">
<![CDATA[
 		
 		/// <summary>
 		/// This finds the best suitable sprite to use when presenting this actor to the user.
 		/// </summary>
 		public string FindSuitableSprite()
 		{
 			string result = "";
 			
 			// Sprite forced?
 			if(HasPropertyWithValue("$sprite"))
 			{
 				return GetPropertyValueString("$sprite", 0);
 			}
 			else
 			{
 				// Try the idle state
 				if(HasState("idle"))
 				{
 					StateStructure s = GetState("idle");
 					string spritename = s.GetSprite(0);
 					if(!string.IsNullOrEmpty(spritename))
 						result = spritename;
 				}
 				
 				// Try the see state
 				if(string.IsNullOrEmpty(result) && HasState("see"))
 				{
 					StateStructure s = GetState("see");
 					string spritename = s.GetSprite(0);
 					if(!string.IsNullOrEmpty(spritename))
 						result = spritename;
 				}
 				
 				// Try the inactive state
 				if(string.IsNullOrEmpty(result) && HasState("inactive"))
 				{
 					StateStructure s = GetState("inactive");
 					string spritename = s.GetSprite(0);
 					if(!string.IsNullOrEmpty(spritename))
 						result = spritename;
 				}
 				
 				// Try the spawn state
 				if(string.IsNullOrEmpty(result) && HasState("spawn"))
 				{
 					StateStructure s = GetState("spawn");
 					string spritename = s.GetSprite(0);
 					if(!string.IsNullOrEmpty(spritename))
 						result = spritename;
 				}
 				
 				// Still no sprite found? then just pick the first we can find
 				if(string.IsNullOrEmpty(result))
 				{
 					Dictionary<string, StateStructure> list = GetAllStates();
 					foreach(StateStructure s in list.Values)
 					{
 						string spritename = s.GetSprite(0);
 						if(!string.IsNullOrEmpty(spritename))
 						{
 							result = spritename;
 							break;
 						}
 					}
 					foreach(StateStructure s in list.Values)
 					{
 						string spritename = s.GetSprite(0);
 						if(!string.IsNullOrEmpty(spritename))
 						{
 							result = spritename;
 							break;
 						}
 					}
 				}
 				
 				if(!string.IsNullOrEmpty(result))
 				{
 					// The sprite name is not actually complete, we still have to append
 					// the direction characters to it. Find an existing sprite with direction.
 					foreach(string postfix in SPRITE_POSTFIXES)
 					{
 						if(General.Map.Data.GetSpriteExists(result + postfix))
 							return result + postfix;
 					}
 					foreach(string postfix in SPRITE_POSTFIXES)
 					{
 						if(General.Map.Data.GetSpriteExists(result + postfix))
 							return result + postfix;
 					}
 				}
 			}
 			
 			// No sprite found
 			return "";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalMapSetIO.cs" startline="140" endline="164">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Reading
 		
 		// This reads a map from the file and returns a MapSet
 		public override MapSet Read(MapSet map, string mapname)
 		{
 			UniversalStreamReader udmfreader = new UniversalStreamReader();
 			
 			// Find the index where first map lump begins
 			int firstindex = wad.FindLumpIndex(mapname) + 1;
 			
 			// Get the TEXTMAP lump from wad file
 			Lump lump = wad.FindLump("TEXTMAP", firstindex);
 			if(lump == null) throw new Exception("Could not find required lump TEXTMAP!");
 
 			// Read the UDMF data
 			lump.Stream.Seek(0, SeekOrigin.Begin);
 			udmfreader.SetKnownCustomTypes = true;
 			udmfreader.Read(map, lump.Stream);
 			
 			// Return result
 			return map;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="1066" endline="1086">
<![CDATA[
 
 		// This tests if a given sprite can be found
 		internal bool GetSpriteExists(string pname)
 		{
 			if(!string.IsNullOrEmpty(pname))
 			{
 				long longname = Lump.MakeLongName(pname);
 				if(sprites.ContainsKey(longname))
 					return true;
 				
 				// Go for all opened containers
 				for(int i = containers.Count - 1; i >= 0; i--)
 				{
 					// This contain provides this patch?
 					if(containers[i].GetSpriteExists(pname)) return true;
 				}
 				for(int i = containers.Count - 1; i >= 0; i--)
 				{
 					// This contain provides this patch?
 					if(containers[i].GetSpriteExists(pname)) return true;
 				}
 			}
 			
 			// No such patch found
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DirectoryReader.cs" startline="208" endline="238">
<![CDATA[
 
 		// This checks if the given sprite exists
 		public override bool GetSpriteExists(string pname)
 		{
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find in any of the wad files
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				if(wads[i].GetSpriteExists(pname)) return true;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				if(wads[i].GetSpriteExists(pname)) return true;
 			}
 
 			// Find in sprites directory
 			try
 			{
 				string path = Path.Combine(SPRITES_DIR, Path.GetDirectoryName(pname));
 				string filename = FindFirstFile(path, Path.GetFileName(pname), true);
 				if((filename != null) && FileExists(filename))
 				{
 					return true;
 				}
 			}
 			catch(Exception e)
 			{
 				General.ErrorLogger.Add(ErrorType.Error, e.GetType().Name + " while checking sprite '" + pname + "' existance in directory
 			}
 			
 			// Nothing found
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Triangulation.cs" startline="646" endline="802">
<![CDATA[
 
 		#endregion
 
 		#region ================== Ear Clipping
 
 		// This clips a polygon and returns the triangles
 		// The polygon may not have any holes or islands
 		// See
 		private int DoEarClip(EarClipPolygon poly, List<Vector2D> verticeslist, List<Sidedef> sidedefslist)
 		{
 			LinkedList<EarClipVertex> verts = new LinkedList<EarClipVertex>();
 			List<EarClipVertex> convexes = new List<EarClipVertex>(poly.Count);
 			LinkedList<EarClipVertex> reflexes = new LinkedList<EarClipVertex>();
 			LinkedList<EarClipVertex> eartips = new LinkedList<EarClipVertex>();
 			LinkedListNode<EarClipVertex> n1, n2;
 			EarClipVertex v, v1, v2;
 			EarClipVertex[] t, t1, t2;
 			int countvertices = 0;
 
 			// Go for all vertices to fill list
 			foreach(EarClipVertex vec in poly)
 				vec.SetVertsLink(verts.AddLast(vec));
 			foreach(EarClipVertex vec in poly)
 				vec.SetVertsLink(verts.AddLast(vec));
 
 			// Remove any zero-length lines, these will give problems
 			n1 = verts.First;
 			do
 			{
 				// Continue until adjacent zero-length lines are removed
 				n2 = n1.Next ?? verts.First;
 				Vector2D d = n1.Value.Position - n2.Value.Position;
 				while((Math.Abs(d.x) < 0.00001f) && (Math.Abs(d.y) < 0.00001f))
 				{
 					n2.Value.Remove();
 					n2 = n1.Next ?? verts.First;
 					if(n2 != null) d = n1.Value.Position - n2.Value.Position; else break;
 				}
 				while((Math.Abs(d.x) < 0.00001f) && (Math.Abs(d.y) < 0.00001f))
 				{
 					n2.Value.Remove();
 					n2 = n1.Next ?? verts.First;
 					if(n2 != null) d = n1.Value.Position - n2.Value.Position; else break;
 				}
 
 				// Next!
 				n1 = n2;
 			}
 			while(n1 != verts.First);
 			
 			// Optimization
 			// same angle are useless. Remove them!
 			n1 = verts.First;
 			while(n1 != null)
 			{
 				// Get the next vertex
 				n2 = n1.Next;
 				
 				// Get triangle for v
 				t = GetTriangle(n1.Value);
 				
 				// Check if both lines have the same angle
 				Line2D a = new Line2D(t[0].Position, t[1].Position);
 				Line2D b = new Line2D(t[1].Position, t[2].Position);
 				if(Math.Abs(Angle2D.Difference(a.GetAngle(), b.GetAngle())) < 0.00001f)
 				{
 					// Same angles, remove vertex
 					n1.Value.Remove();
 				}
 				
 				// Next!
 				n1 = n2;
 			}
 			while(n1 != null)
 			{
 				// Get the next vertex
 				n2 = n1.Next;
 				
 				// Get triangle for v
 				t = GetTriangle(n1.Value);
 				
 				// Check if both lines have the same angle
 				Line2D a = new Line2D(t[0].Position, t[1].Position);
 				Line2D b = new Line2D(t[1].Position, t[2].Position);
 				if(Math.Abs(Angle2D.Difference(a.GetAngle(), b.GetAngle())) < 0.00001f)
 				{
 					// Same angles, remove vertex
 					n1.Value.Remove();
 				}
 				
 				// Next!
 				n1 = n2;
 			}
 
 			// Go for all vertices to determine reflex or convex
 			foreach(EarClipVertex vv in verts)
 			{
 				// Add to reflex or convex list
 				if(IsReflex(GetTriangle(vv))) vv.AddReflex(reflexes); else convexes.Add(vv);
 			}
 			foreach(EarClipVertex vv in verts)
 			{
 				// Add to reflex or convex list
 				if(IsReflex(GetTriangle(vv))) vv.AddReflex(reflexes); else convexes.Add(vv);
 			}
 
 			// Go for all convex vertices to see if they are ear tips
 			foreach(EarClipVertex cv in convexes)
 			{
 				// Add when this is a valid ear
 				t = GetTriangle(cv);
 				if(CheckValidEar(t, reflexes)) cv.AddEarTip(eartips);
 			}
 			foreach(EarClipVertex cv in convexes)
 			{
 				// Add when this is a valid ear
 				t = GetTriangle(cv);
 				if(CheckValidEar(t, reflexes)) cv.AddEarTip(eartips);
 			}
 
 			#if DEBUG
 			if(OnShowPolygon != null) OnShowPolygon(verts);
 			#endif
 			
 			// Process ears until done
 			while((eartips.Count > 0) && (verts.Count > 2))
 			{
 				// Get next ear
 				v = eartips.First.Value;
 				t = GetTriangle(v);
 
 				// Only save this triangle when it has an area
 				if(TriangleHasArea(t))
 				{
 					// Add ear as triangle
 					AddTriangleToList(t, verticeslist, sidedefslist, (verts.Count == 3));
 					countvertices += 3;
 				}
 				
 				// Remove this ear from all lists
 				v.Remove();
 				v1 = t[0];
 				v2 = t[2];
 
 				#if DEBUG
 				if(TriangleHasArea(t))
 				{
 					if(OnShowEarClip != null) OnShowEarClip(t, verts);
 				}
 				#endif
 				
 				// Test first neighbour
 				t1 = GetTriangle(v1);
 				bool t1a = true;	//TriangleHasArea(t1);
 				if(t1a && IsReflex(t1))
 				{
 					// List as reflex if not listed yet
 					if(!v1.IsReflex) v1.AddReflex(reflexes);
 					v1.RemoveEarTip();
 				}
 				else
 				{
 					// Remove from reflexes
 					v1.RemoveReflex();
 				}
 				
 				// Test second neighbour
 				t2 = GetTriangle(v2);
 				bool t2a = true;	//TriangleHasArea(t2);
 				if(t2a && IsReflex(t2))
 				{
 					// List as reflex if not listed yet
 					if(!v2.IsReflex) v2.AddReflex(reflexes);
 					v2.RemoveEarTip();
 				}
 				else
 				{
 					// Remove from reflexes
 					v2.RemoveReflex();
 				}
 				
 				// Check if any neightbour have become a valid or invalid ear
 				if(!v1.IsReflex && (!t1a || CheckValidEar(t1, reflexes))) v1.AddEarTip(eartips); else v1.RemoveEarTip();
 				if(!v2.IsReflex && (!t2a || CheckValidEar(t2, reflexes))) v2.AddEarTip(eartips); else v2.RemoveEarTip();
 			}
 			while((eartips.Count > 0) && (verts.Count > 2))
 			{
 				// Get next ear
 				v = eartips.First.Value;
 				t = GetTriangle(v);
 
 				// Only save this triangle when it has an area
 				if(TriangleHasArea(t))
 				{
 					// Add ear as triangle
 					AddTriangleToList(t, verticeslist, sidedefslist, (verts.Count == 3));
 					countvertices += 3;
 				}
 				
 				// Remove this ear from all lists
 				v.Remove();
 				v1 = t[0];
 				v2 = t[2];
 
 				#if DEBUG
 				if(TriangleHasArea(t))
 				{
 					if(OnShowEarClip != null) OnShowEarClip(t, verts);
 				}
 				#endif
 				
 				// Test first neighbour
 				t1 = GetTriangle(v1);
 				bool t1a = true;	//TriangleHasArea(t1);
 				if(t1a && IsReflex(t1))
 				{
 					// List as reflex if not listed yet
 					if(!v1.IsReflex) v1.AddReflex(reflexes);
 					v1.RemoveEarTip();
 				}
 				else
 				{
 					// Remove from reflexes
 					v1.RemoveReflex();
 				}
 				
 				// Test second neighbour
 				t2 = GetTriangle(v2);
 				bool t2a = true;	//TriangleHasArea(t2);
 				if(t2a && IsReflex(t2))
 				{
 					// List as reflex if not listed yet
 					if(!v2.IsReflex) v2.AddReflex(reflexes);
 					v2.RemoveEarTip();
 				}
 				else
 				{
 					// Remove from reflexes
 					v2.RemoveReflex();
 				}
 				
 				// Check if any neightbour have become a valid or invalid ear
 				if(!v1.IsReflex && (!t1a || CheckValidEar(t1, reflexes))) v1.AddEarTip(eartips); else v1.RemoveEarTip();
 				if(!v2.IsReflex && (!t2a || CheckValidEar(t2, reflexes))) v2.AddEarTip(eartips); else v2.RemoveEarTip();
 			}
 
 			#if DEBUG
 			if(OnShowRemaining != null) OnShowRemaining(verts);
 			#endif
 			
 			// Dispose remaining vertices
 			foreach(EarClipVertex ecv in verts) ecv.Dispose();
 
 			// Return the number of vertices in the result
 			return countvertices;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\MapSetIO.cs" startline="110" endline="154">
<![CDATA[
 		
 		// This returns and instance of the specified IO class
 		public static MapSetIO Create(string classname, WAD wadfile, MapManager manager)
 		{
 			object[] args;
 			MapSetIO result;
 			string fullname;
 			
 			try
 			{
 				// Create arguments
 				args = new object[2];
 				args[0] = wadfile;
 				args[1] = manager;
 				
 				// Make the full class name
 				fullname = "CodeImp.DoomBuilder.IO." + classname;
 				
 				// Create IO class
 				result = (MapSetIO)General.ThisAssembly.CreateInstance(fullname, false,
 					BindingFlags.Default, null, args, CultureInfo.CurrentCulture, new object[0]);
 				
 				// Check result
 				if(result != null)
 				{
 					// Success
 					return result;
 				}
 				else
 				{
 					// No such class
 					throw new ArgumentException("No such map format interface found
 				}
 			}
 			// Catch errors
 			catch(TargetInvocationException e)
 			{
 				// Throw the actual exception
 				Debug.WriteLine(DateTime.Now.ToShortDateString() + " " + DateTime.Now.ToShortTimeString());
 				Debug.WriteLine(e.InnerException.Source + " throws " + e.InnerException.GetType().Name + "
 				Debug.WriteLine(e.InnerException.Message);
 				Debug.WriteLine(e.InnerException.StackTrace);
 				throw e.InnerException;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\WADReader.cs" startline="399" endline="507">
<![CDATA[
 		
 		// This loads a set of textures
 		public static void LoadTextureSet(string sourcename, Stream texturedata, ref List<ImageData> images, PatchNames pnames)
 		{
 			BinaryReader reader = new BinaryReader(texturedata);
 			int flags, width, height, patches, px, py, pi;
 			uint numtextures;
 			byte scalebytex, scalebytey;
 			float scalex, scaley, defaultscale;
 			byte[] namebytes;
 			TextureImage image = null;
 			bool strifedata;
 
 			if(texturedata.Length == 0)
 				return;
 
 			// Determine default scale
 			defaultscale = General.Map.Config.DefaultTextureScale;
 			
 			// Get number of textures
 			texturedata.Seek(0, SeekOrigin.Begin);
 			numtextures = reader.ReadUInt32();
 			
 			// Skip offset bytes (we will read all textures sequentially)
 			texturedata.Seek(4 * numtextures, SeekOrigin.Current);
 
 			// Go for all textures defined in this lump
 			for(uint i = 0; i < numtextures; i++)
 			{
 				// Read texture properties
 				namebytes = reader.ReadBytes(8);
 				flags = reader.ReadUInt16();
 				scalebytex = reader.ReadByte();
 				scalebytey = reader.ReadByte();
 				width = reader.ReadInt16();
 				height = reader.ReadInt16();
 				patches = reader.ReadInt16();
 				
 				// Check for doom or strife data format
 				if(patches == 0)
 				{
 					// Ignore 2 bytes and then read number of patches
 					texturedata.Seek(2, SeekOrigin.Current);
 					patches = reader.ReadInt16();
 					strifedata = false;
 				}
 				else
 				{
 					// Texture data is in strife format
 					strifedata = true;
 				}
 
 				// Determine actual scales
 				if(scalebytex == 0) scalex = defaultscale; else scalex = 1f / ((float)scalebytex / 8f);
 				if(scalebytey == 0) scaley = defaultscale; else scaley = 1f / ((float)scalebytey / 8f);
 				
 				// Validate data
 				if((width > 0) && (height > 0) && (patches > 0) &&
 				   (scalex != 0) || (scaley != 0))
 				{
 					string texname = Lump.MakeNormalName(namebytes, WAD.ENCODING);
 					if(texname.Length > 0)
 					{
 						// Make the image object
 						image = new TextureImage(Lump.MakeNormalName(namebytes, WAD.ENCODING),
 												 width, height, scalex, scaley);
 					}
 					else
 					{
 						// Can't load image without name
 						General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed texture from \"" + sourcename + "\". Please consider giving names to your resources.");
 					}
 					
 					// Go for all patches in texture
 					for(int p = 0; p < patches; p++)
 					{
 						// Read patch properties
 						px = reader.ReadInt16();
 						py = reader.ReadInt16();
 						pi = reader.ReadUInt16();
 						if(!strifedata) texturedata.Seek(4, SeekOrigin.Current);
 						
 						// Validate data
 						if((pi >= 0) && (pi < pnames.Length))
 						{
 							if(pnames[pi].Length > 0)
 							{
 								// Create patch on image
 								if(image != null) image.AddPatch(new TexturePatch(pnames[pi], px, py));
 							}
 							else
 							{
 								// Can't load image without name
 								General.ErrorLogger.Add(ErrorType.Error, "Can't use an unnamed patch referenced in \"" + sourcename + "\". Please consider giving names to your resources.");
 							}
 						}
 					}
 					for(int p = 0; p < patches; p++)
 					{
 						// Read patch properties
 						px = reader.ReadInt16();
 						py = reader.ReadInt16();
 						pi = reader.ReadUInt16();
 						if(!strifedata) texturedata.Seek(4, SeekOrigin.Current);
 						
 						// Validate data
 						if((pi >= 0) && (pi < pnames.Length))
 						{
 							if(pnames[pi].Length > 0)
 							{
 								// Create patch on image
 								if(image != null) image.AddPatch(new TexturePatch(pnames[pi], px, py));
 							}
 							else
 							{
 								// Can't load image without name
 								General.ErrorLogger.Add(ErrorType.Error, "Can't use an unnamed patch referenced in \"" + sourcename + "\". Please consider giving names to your resources.");
 							}
 						}
 					}
 					
 					// Add image to collection
 					images.Add(image);
 				}
 				else
 				{
 					// Skip patches data
 					texturedata.Seek(6 * patches, SeekOrigin.Current);
 					if(!strifedata) texturedata.Seek(4 * patches, SeekOrigin.Current);
 				}
 			}
 			for(uint i = 0; i < numtextures; i++)
 			{
 				// Read texture properties
 				namebytes = reader.ReadBytes(8);
 				flags = reader.ReadUInt16();
 				scalebytex = reader.ReadByte();
 				scalebytey = reader.ReadByte();
 				width = reader.ReadInt16();
 				height = reader.ReadInt16();
 				patches = reader.ReadInt16();
 				
 				// Check for doom or strife data format
 				if(patches == 0)
 				{
 					// Ignore 2 bytes and then read number of patches
 					texturedata.Seek(2, SeekOrigin.Current);
 					patches = reader.ReadInt16();
 					strifedata = false;
 				}
 				else
 				{
 					// Texture data is in strife format
 					strifedata = true;
 				}
 
 				// Determine actual scales
 				if(scalebytex == 0) scalex = defaultscale; else scalex = 1f / ((float)scalebytex / 8f);
 				if(scalebytey == 0) scaley = defaultscale; else scaley = 1f / ((float)scalebytey / 8f);
 				
 				// Validate data
 				if((width > 0) && (height > 0) && (patches > 0) &&
 				   (scalex != 0) || (scaley != 0))
 				{
 					string texname = Lump.MakeNormalName(namebytes, WAD.ENCODING);
 					if(texname.Length > 0)
 					{
 						// Make the image object
 						image = new TextureImage(Lump.MakeNormalName(namebytes, WAD.ENCODING),
 												 width, height, scalex, scaley);
 					}
 					else
 					{
 						// Can't load image without name
 						General.ErrorLogger.Add(ErrorType.Error, "Can't load an unnamed texture from \"" + sourcename + "\". Please consider giving names to your resources.");
 					}
 					
 					// Go for all patches in texture
 					for(int p = 0; p < patches; p++)
 					{
 						// Read patch properties
 						px = reader.ReadInt16();
 						py = reader.ReadInt16();
 						pi = reader.ReadUInt16();
 						if(!strifedata) texturedata.Seek(4, SeekOrigin.Current);
 						
 						// Validate data
 						if((pi >= 0) && (pi < pnames.Length))
 						{
 							if(pnames[pi].Length > 0)
 							{
 								// Create patch on image
 								if(image != null) image.AddPatch(new TexturePatch(pnames[pi], px, py));
 							}
 							else
 							{
 								// Can't load image without name
 								General.ErrorLogger.Add(ErrorType.Error, "Can't use an unnamed patch referenced in \"" + sourcename + "\". Please consider giving names to your resources.");
 							}
 						}
 					}
 					
 					// Add image to collection
 					images.Add(image);
 				}
 				else
 				{
 					// Skip patches data
 					texturedata.Seek(6 * patches, SeekOrigin.Current);
 					if(!strifedata) texturedata.Seek(4 * patches, SeekOrigin.Current);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\DecorateParser.cs" startline="95" endline="208">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Parsing
 
 		// This parses the given decorate stream
 		// Returns false on errors
 		public override bool Parse(Stream stream, string sourcefilename)
 		{
 			base.Parse(stream, sourcefilename);
 			
 			// Keep local data
 			Stream localstream = datastream;
 			string localsourcename = sourcename;
 			BinaryReader localreader = datareader;
 			
 			// Continue until at the end of the stream
 			while(SkipWhitespace(true))
 			{
 				// Read a token
 				string objdeclaration = ReadToken();
 				if(objdeclaration != null)
 				{
 					objdeclaration = objdeclaration.ToLowerInvariant();
 					if(objdeclaration == "actor")
 					{
 						// Read actor structure
 						ActorStructure actor = new ActorStructure(this);
 						if(this.HasError) break;
 						
 						// Add the actor
 						archivedactors[actor.ClassName.ToLowerInvariant()] = actor;
 						if(actor.CheckActorSupported())
 							actors[actor.ClassName.ToLowerInvariant()] = actor;
 						
 						// Replace an actor?
 						if(actor.ReplacesClass != null)
 						{
 							if(GetArchivedActorByName(actor.ReplacesClass) != null)
 								archivedactors[actor.ReplacesClass.ToLowerInvariant()] = actor;
 							else
 								General.ErrorLogger.Add(ErrorType.Warning, "Unable to find the DECORATE class '" + actor.ReplacesClass + "' to replace, while parsing '" + actor.ClassName + "'");
 							
 							if(actor.CheckActorSupported())
 							{
 								if(GetActorByName(actor.ReplacesClass) != null)
 									actors[actor.ReplacesClass.ToLowerInvariant()] = actor;
 							}
 						}
 					}
 					else if(objdeclaration == "#include")
 					{
 						// Include a file
 						SkipWhitespace(true);
 						string filename = ReadToken();
 						if(!string.IsNullOrEmpty(filename))
 						{
 							// Strip the quotes
 							filename = filename.Replace("\"", "");
 
 							// Callback to parse this file now
 							if(OnInclude != null) OnInclude(this, filename);
 
 							// Set our buffers back to continue parsing
 							datastream = localstream;
 							datareader = localreader;
 							sourcename = localsourcename;
 							if(HasError) break;
 						}
 						else
 						{
 							ReportError("Expected file name to include");
 							break;
 						}
 					}
 					else if((objdeclaration == "const") || (objdeclaration == "native"))
 					{
 						// We don't need this, ignore up to the first next ;
 						while(SkipWhitespace(true))
 						{
 							string t = ReadToken();
 							if((t == ";") || (t == null)) break;
 						}
 						while(SkipWhitespace(true))
 						{
 							string t = ReadToken();
 							if((t == ";") || (t == null)) break;
 						}
 					}
 					else
 					{
 						// Unknown structure!
 						// Best we can do now is just find the first { and then
 						// follow the scopes until the matching } is found
 						string token2;
 						do
 						{
 							if(!SkipWhitespace(true)) break;
 							token2 = ReadToken();
 							if(token2 == null) break;
 						}
 						while(token2 != "{");
 						int scopelevel = 1;
 						do
 						{
 							if(!SkipWhitespace(true)) break;
 							token2 = ReadToken();
 							if(token2 == null) break;
 							if(token2 == "{") scopelevel++;
 							if(token2 == "}") scopelevel--;
 						}
 						while(scopelevel > 0);
 					}
 				}
 			}
 			while(SkipWhitespace(true))
 			{
 				// Read a token
 				string objdeclaration = ReadToken();
 				if(objdeclaration != null)
 				{
 					objdeclaration = objdeclaration.ToLowerInvariant();
 					if(objdeclaration == "actor")
 					{
 						// Read actor structure
 						ActorStructure actor = new ActorStructure(this);
 						if(this.HasError) break;
 						
 						// Add the actor
 						archivedactors[actor.ClassName.ToLowerInvariant()] = actor;
 						if(actor.CheckActorSupported())
 							actors[actor.ClassName.ToLowerInvariant()] = actor;
 						
 						// Replace an actor?
 						if(actor.ReplacesClass != null)
 						{
 							if(GetArchivedActorByName(actor.ReplacesClass) != null)
 								archivedactors[actor.ReplacesClass.ToLowerInvariant()] = actor;
 							else
 								General.ErrorLogger.Add(ErrorType.Warning, "Unable to find the DECORATE class '" + actor.ReplacesClass + "' to replace, while parsing '" + actor.ClassName + "'");
 							
 							if(actor.CheckActorSupported())
 							{
 								if(GetActorByName(actor.ReplacesClass) != null)
 									actors[actor.ReplacesClass.ToLowerInvariant()] = actor;
 							}
 						}
 					}
 					else if(objdeclaration == "#include")
 					{
 						// Include a file
 						SkipWhitespace(true);
 						string filename = ReadToken();
 						if(!string.IsNullOrEmpty(filename))
 						{
 							// Strip the quotes
 							filename = filename.Replace("\"", "");
 
 							// Callback to parse this file now
 							if(OnInclude != null) OnInclude(this, filename);
 
 							// Set our buffers back to continue parsing
 							datastream = localstream;
 							datareader = localreader;
 							sourcename = localsourcename;
 							if(HasError) break;
 						}
 						else
 						{
 							ReportError("Expected file name to include");
 							break;
 						}
 					}
 					else if((objdeclaration == "const") || (objdeclaration == "native"))
 					{
 						// We don't need this, ignore up to the first next ;
 						while(SkipWhitespace(true))
 						{
 							string t = ReadToken();
 							if((t == ";") || (t == null)) break;
 						}
 					}
 					else
 					{
 						// Unknown structure!
 						// Best we can do now is just find the first { and then
 						// follow the scopes until the matching } is found
 						string token2;
 						do
 						{
 							if(!SkipWhitespace(true)) break;
 							token2 = ReadToken();
 							if(token2 == null) break;
 						}
 						while(token2 != "{");
 						int scopelevel = 1;
 						do
 						{
 							if(!SkipWhitespace(true)) break;
 							token2 = ReadToken();
 							if(token2 == null) break;
 							if(token2 == "{") scopelevel++;
 							if(token2 == "}") scopelevel--;
 						}
 						while(scopelevel > 0);
 					}
 				}
 			}
 			
 			// Return true when no errors occurred
 			return (ErrorDescription == null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3Reader.cs" startline="313" endline="364">
<![CDATA[
 
 		// This loads an entire file in memory and returns the stream
 		// NOTE
 		protected override MemoryStream LoadFile(string filename)
 		{
 			MemoryStream filedata = null;
 			byte[] copybuffer = new byte[4096];
 
 			// Open the zip file
 			ZipInputStream zipstream = OpenPK3File();
 
 			ZipEntry entry = zipstream.GetNextEntry();
 			while(entry != null)
 			{
 				if(entry.IsFile)
 				{
 					string entryname = entry.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
 					
 					// Is this the entry we are looking for?
 					if(string.Compare(entryname, filename, true) == 0)
 					{
 						int expectedsize = (int)entry.Size;
 						if(expectedsize < 1) expectedsize = 1024;
 						filedata = new MemoryStream(expectedsize);
 						int readsize = zipstream.Read(copybuffer, 0, copybuffer.Length);
 						while(readsize > 0)
 						{
 							filedata.Write(copybuffer, 0, readsize);
 							readsize = zipstream.Read(copybuffer, 0, copybuffer.Length);
 						}
 						while(readsize > 0)
 						{
 							filedata.Write(copybuffer, 0, readsize);
 							readsize = zipstream.Read(copybuffer, 0, copybuffer.Length);
 						}
 						break;
 					}
 				}
 				
 				// Next
 				entry = zipstream.GetNextEntry();
 			}
 			while(entry != null)
 			{
 				if(entry.IsFile)
 				{
 					string entryname = entry.Name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
 					
 					// Is this the entry we are looking for?
 					if(string.Compare(entryname, filename, true) == 0)
 					{
 						int expectedsize = (int)entry.Size;
 						if(expectedsize < 1) expectedsize = 1024;
 						filedata = new MemoryStream(expectedsize);
 						int readsize = zipstream.Read(copybuffer, 0, copybuffer.Length);
 						while(readsize > 0)
 						{
 							filedata.Write(copybuffer, 0, readsize);
 							readsize = zipstream.Read(copybuffer, 0, copybuffer.Length);
 						}
 						break;
 					}
 				}
 				
 				// Next
 				entry = zipstream.GetNextEntry();
 			}
 
 			// Done with the zip file
 			zipstream.Close();
 			zipstream.Dispose();
 			
 			// Nothing found?
 			if(filedata == null)
 			{
 				throw new FileNotFoundException("Cannot find the file " + filename + " in PK3 file " + location.location + ".");
 			}
 			else
 			{
 				return filedata;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="216" endline="400">
<![CDATA[
 
 		// This loads all data resources
 		internal void Load(DataLocationList locations)
 		{
 			int texcount, flatcount, spritecount, thingcount, colormapcount;
 			Dictionary<long, ImageData> texturesonly = new Dictionary<long, ImageData>();
 			Dictionary<long, ImageData> colormapsonly = new Dictionary<long, ImageData>();
 			Dictionary<long, ImageData> flatsonly = new Dictionary<long, ImageData>();
 			DataReader c;
 			
 			// Create collections
 			containers = new List<DataReader>();
 			textures = new Dictionary<long, ImageData>();
 			flats = new Dictionary<long, ImageData>();
 			sprites = new Dictionary<long, ImageData>();
 			texturenames = new List<string>();
 			flatnames = new List<string>();
 			imageque = new Queue<ImageData>();
 			previews = new PreviewManager();
 			texturesets = new List<MatchingTextureSet>();
 			usedimages = new Dictionary<long, long>();
 			internalsprites = new Dictionary<string, ImageData>();
 			thingcategories = General.Map.Config.GetThingCategories();
 			thingtypes = General.Map.Config.GetThingTypes();
 			
 			// Load texture sets
 			foreach(DefinedTextureSet ts in General.Map.ConfigSettings.TextureSets)
 				texturesets.Add(new MatchingTextureSet(ts));
 			foreach(DefinedTextureSet ts in General.Map.ConfigSettings.TextureSets)
 				texturesets.Add(new MatchingTextureSet(ts));
 			
 			// Sort the texture sets
 			texturesets.Sort();
 			
 			// Special textures sets
 			alltextures = new AllTextureSet();
 			resourcetextures = new List<ResourceTextureSet>();
 			
 			// Go for all locations
 			foreach(DataLocation dl in locations)
 			{
 				// Nothing chosen yet
 				c = null;
 
 				// TODO
 				// Make DataLocation.type of type Type and assign the
 				// types of the desired reader classes.
 
 				try
 				{
 					// Choose container type
 					switch(dl.type)
 					{
 						// WAD file container
 						case DataLocation.RESOURCE_WAD
 							c = new WADReader(dl);
 							break;
 
 						// Directory container
 						case DataLocation.RESOURCE_DIRECTORY
 							c = new DirectoryReader(dl);
 							break;
 
 						// PK3 file container
 						case DataLocation.RESOURCE_PK3
 							c = new PK3Reader(dl);
 							break;
 					}
 				}
 				catch(Exception e)
 				{
 					// Unable to load resource
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to load resources from location \"" + dl.location + "\". Please make sure the location is accessible and not in use by another program. The resources will now be loaded with this location excluded. You may reload the resources to try again.\n" + e.GetType().Name + " when creating data reader
 					General.WriteLogLine(e.StackTrace);
 					continue;
 				}	
 
 				// Add container
 				if(c != null)
 				{
 					containers.Add(c);
 					resourcetextures.Add(c.TextureSet);
 				}
 			}
 			foreach(DataLocation dl in locations)
 			{
 				// Nothing chosen yet
 				c = null;
 
 				// TODO
 				// Make DataLocation.type of type Type and assign the
 				// types of the desired reader classes.
 
 				try
 				{
 					// Choose container type
 					switch(dl.type)
 					{
 						// WAD file container
 						case DataLocation.RESOURCE_WAD
 							c = new WADReader(dl);
 							break;
 
 						// Directory container
 						case DataLocation.RESOURCE_DIRECTORY
 							c = new DirectoryReader(dl);
 							break;
 
 						// PK3 file container
 						case DataLocation.RESOURCE_PK3
 							c = new PK3Reader(dl);
 							break;
 					}
 				}
 				catch(Exception e)
 				{
 					// Unable to load resource
 					General.ErrorLogger.Add(ErrorType.Error, "Unable to load resources from location \"" + dl.location + "\". Please make sure the location is accessible and not in use by another program. The resources will now be loaded with this location excluded. You may reload the resources to try again.\n" + e.GetType().Name + " when creating data reader
 					General.WriteLogLine(e.StackTrace);
 					continue;
 				}	
 
 				// Add container
 				if(c != null)
 				{
 					containers.Add(c);
 					resourcetextures.Add(c.TextureSet);
 				}
 			}
 			
 			// Load stuff
 			LoadPalette();
 			texcount = LoadTextures(texturesonly);
 			flatcount = LoadFlats(flatsonly);
 			colormapcount = LoadColormaps(colormapsonly);
 			LoadSprites();
 			thingcount = LoadDecorateThings();
 			spritecount = LoadThingSprites();
 			LoadInternalSprites();
 			
 			// Process colormaps (we just put them in as textures)
 			foreach(KeyValuePair<long, ImageData> t in colormapsonly)
 			{
 				textures.Add(t.Key, t.Value);
 				texturenames.Add(t.Value.Name);
 			}
 			foreach(KeyValuePair<long, ImageData> t in colormapsonly)
 			{
 				textures.Add(t.Key, t.Value);
 				texturenames.Add(t.Value.Name);
 			}
 			
 			// Process textures
 			foreach(KeyValuePair<long, ImageData> t in texturesonly)
 			{
 				if(!textures.ContainsKey(t.Key))
 				{
 					textures.Add(t.Key, t.Value);
 					texturenames.Add(t.Value.Name);
 				}
 			}
 			foreach(KeyValuePair<long, ImageData> t in texturesonly)
 			{
 				if(!textures.ContainsKey(t.Key))
 				{
 					textures.Add(t.Key, t.Value);
 					texturenames.Add(t.Value.Name);
 				}
 			}
 
 			// Process flats
 			foreach(KeyValuePair<long, ImageData> f in flatsonly)
 			{
 				flats.Add(f.Key, f.Value);
 				flatnames.Add(f.Value.Name);
 			}
 			foreach(KeyValuePair<long, ImageData> f in flatsonly)
 			{
 				flats.Add(f.Key, f.Value);
 				flatnames.Add(f.Value.Name);
 			}
 
 			// Mixed textures and flats?
 			if(General.Map.Config.MixTexturesFlats)
 			{
 				// Add textures to flats
 				foreach(KeyValuePair<long, ImageData> t in texturesonly)
 				{
 					if(!flats.ContainsKey(t.Key))
 					{
 						flats.Add(t.Key, t.Value);
 						flatnames.Add(t.Value.Name);
 					}
 				}
 				foreach(KeyValuePair<long, ImageData> t in texturesonly)
 				{
 					if(!flats.ContainsKey(t.Key))
 					{
 						flats.Add(t.Key, t.Value);
 						flatnames.Add(t.Value.Name);
 					}
 				}
 
 				// Add flats to textures
 				foreach(KeyValuePair<long, ImageData> f in flatsonly)
 				{
 					if(!textures.ContainsKey(f.Key))
 					{
 						textures.Add(f.Key, f.Value);
 						texturenames.Add(f.Value.Name);
 					}
 				}
 				foreach(KeyValuePair<long, ImageData> f in flatsonly)
 				{
 					if(!textures.ContainsKey(f.Key))
 					{
 						textures.Add(f.Key, f.Value);
 						texturenames.Add(f.Value.Name);
 					}
 				}
 
 				// Do the same on the data readers
 				foreach(DataReader dr in containers)
 					dr.TextureSet.MixTexturesAndFlats();
 				foreach(DataReader dr in containers)
 					dr.TextureSet.MixTexturesAndFlats();
 			}
 			
 			// Sort names
 			texturenames.Sort();
 			flatnames.Sort();
 
 			// Sort things
 			foreach(ThingCategory tc in thingcategories) tc.SortIfNeeded();
 
 			// Update the used textures
 			General.Map.Data.UpdateUsedTextures();
 			
 			// Add texture names to texture sets
 			foreach(KeyValuePair<long, ImageData> img in textures)
 			{
 				// Add to all sets where it matches
 				bool matchfound = false;
 				foreach(MatchingTextureSet ms in texturesets)
 					matchfound |= ms.AddTexture(img.Value);
 				foreach(MatchingTextureSet ms in texturesets)
 					matchfound |= ms.AddTexture(img.Value);
 
 				// Add to all
 				alltextures.AddTexture(img.Value);
 			}
 			foreach(KeyValuePair<long, ImageData> img in textures)
 			{
 				// Add to all sets where it matches
 				bool matchfound = false;
 				foreach(MatchingTextureSet ms in texturesets)
 					matchfound |= ms.AddTexture(img.Value);
 
 				// Add to all
 				alltextures.AddTexture(img.Value);
 			}
 			
 			// Add flat names to texture sets
 			foreach(KeyValuePair<long, ImageData> img in flats)
 			{
 				// Add to all sets where it matches
 				bool matchfound = false;
 				foreach(MatchingTextureSet ms in texturesets)
 					matchfound |= ms.AddFlat(img.Value);
 				foreach(MatchingTextureSet ms in texturesets)
 					matchfound |= ms.AddFlat(img.Value);
 				
 				// Add to all
 				alltextures.AddFlat(img.Value);
 			}
 			foreach(KeyValuePair<long, ImageData> img in flats)
 			{
 				// Add to all sets where it matches
 				bool matchfound = false;
 				foreach(MatchingTextureSet ms in texturesets)
 					matchfound |= ms.AddFlat(img.Value);
 				
 				// Add to all
 				alltextures.AddFlat(img.Value);
 			}
 			
 			// Start background loading
 			StartBackgroundLoader();
 			
 			// Output info
 			General.WriteLogLine("Loaded " + texcount + " textures, " + flatcount + " flats, " + colormapcount + " colormaps, " + spritecount + " sprites, " + thingcount + " decorate things");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditModeInfo.cs" startline="138" endline="170">
<![CDATA[
 		
 		// This switches to the mode by user command
 		// (when user presses shortcut key)
 		public void UserSwitchToMode()
 		{
 			EditMode newmode;
 			
 			// Only when a map is opened
 			if(General.Map != null)
 			{
 				// Switching from volatile mode to volatile mode?
 				if((General.Editing.Mode != null) && General.Editing.Mode.Attributes.Volatile && this.attribs.Volatile)
 				{
 					// First cancel previous volatile mode
 					General.Editing.CancelVolatileMode();
 				}
 				
 				// When in VisualMode and switching to the same VisualMode, then we switch back to the previous classic mode
 				if((General.Editing.Mode is VisualMode) && (type == General.Editing.Mode.GetType()))
 				{
 					// Switch back to last classic mode
 					General.Editing.ChangeMode(General.Editing.PreviousClassicMode.Name);
 				}
 				else
 				{
 					// Create instance
 					newmode = plugin.CreateObject<EditMode>(type);
 					
 					// Switch mode
 					General.Editing.ChangeMode(newmode);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\VertexEditForm.Designer.cs" startline="22" endline="209">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.TabPage tabproperties;
 			System.Windows.Forms.Label label1;
 			System.Windows.Forms.Label label6;
 			this.groupposition = new System.Windows.Forms.GroupBox();
 			this.tabs = new System.Windows.Forms.TabControl();
 			this.tabcustom = new System.Windows.Forms.TabPage();
 			this.fieldslist = new CodeImp.DoomBuilder.Controls.FieldsEditorControl();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.positionx = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.positiony = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			tabproperties = new System.Windows.Forms.TabPage();
 			label1 = new System.Windows.Forms.Label();
 			label6 = new System.Windows.Forms.Label();
 			tabproperties.SuspendLayout();
 			this.groupposition.SuspendLayout();
 			this.tabs.SuspendLayout();
 			this.tabcustom.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// tabproperties
 			// 
 			tabproperties.Controls.Add(this.groupposition);
 			tabproperties.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			tabproperties.Location = new System.Drawing.Point(4, 23);
 			tabproperties.Name = "tabproperties";
 			tabproperties.Padding = new System.Windows.Forms.Padding(3);
 			tabproperties.Size = new System.Drawing.Size(428, 206);
 			tabproperties.TabIndex = 0;
 			tabproperties.Text = "Properties";
 			tabproperties.UseVisualStyleBackColor = true;
 			// 
 			// groupposition
 			// 
 			this.groupposition.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.groupposition.Controls.Add(this.positiony);
 			this.groupposition.Controls.Add(this.positionx);
 			this.groupposition.Controls.Add(label1);
 			this.groupposition.Controls.Add(label6);
 			this.groupposition.Location = new System.Drawing.Point(7, 6);
 			this.groupposition.Name = "groupposition";
 			this.groupposition.Size = new System.Drawing.Size(415, 194);
 			this.groupposition.TabIndex = 0;
 			this.groupposition.TabStop = false;
 			this.groupposition.Text = " Position ";
 			// 
 			// label1
 			// 
 			label1.AutoSize = true;
 			label1.Location = new System.Drawing.Point(212, 39);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(18, 14);
 			label1.TabIndex = 23;
 			label1.Text = "Y
 			// 
 			// label6
 			// 
 			label6.AutoSize = true;
 			label6.Location = new System.Drawing.Point(45, 39);
 			label6.Name = "label6";
 			label6.Size = new System.Drawing.Size(17, 14);
 			label6.TabIndex = 21;
 			label6.Text = "X
 			// 
 			// tabs
 			// 
 			this.tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tabs.Controls.Add(tabproperties);
 			this.tabs.Controls.Add(this.tabcustom);
 			this.tabs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabs.Location = new System.Drawing.Point(10, 10);
 			this.tabs.Margin = new System.Windows.Forms.Padding(1);
 			this.tabs.Name = "tabs";
 			this.tabs.SelectedIndex = 0;
 			this.tabs.Size = new System.Drawing.Size(436, 233);
 			this.tabs.SizeMode = System.Windows.Forms.TabSizeMode.Fixed;
 			this.tabs.TabIndex = 0;
 			// 
 			// tabcustom
 			// 
 			this.tabcustom.Controls.Add(this.fieldslist);
 			this.tabcustom.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabcustom.Location = new System.Drawing.Point(4, 23);
 			this.tabcustom.Name = "tabcustom";
 			this.tabcustom.Padding = new System.Windows.Forms.Padding(3);
 			this.tabcustom.Size = new System.Drawing.Size(428, 206);
 			this.tabcustom.TabIndex = 1;
 			this.tabcustom.Text = "Custom";
 			this.tabcustom.UseVisualStyleBackColor = true;
 			// 
 			// fieldslist
 			// 
 			this.fieldslist.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.fieldslist.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.fieldslist.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.fieldslist.Location = new System.Drawing.Point(11, 11);
 			this.fieldslist.Margin = new System.Windows.Forms.Padding(8);
 			this.fieldslist.Name = "fieldslist";
 			this.fieldslist.Size = new System.Drawing.Size(406, 187);
 			this.fieldslist.TabIndex = 2;
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(334, 259);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 2;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(215, 259);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 1;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// positionx
 			// 
 			this.positionx.AllowDecimal = false;
 			this.positionx.AllowNegative = true;
 			this.positionx.AllowRelative = true;
 			this.positionx.ButtonStep = 1;
 			this.positionx.Location = new System.Drawing.Point(68, 34);
 			this.positionx.Name = "positionx";
 			this.positionx.Size = new System.Drawing.Size(120, 24);
 			this.positionx.TabIndex = 24;
 			// 
 			// positiony
 			// 
 			this.positiony.AllowDecimal = false;
 			this.positiony.AllowNegative = true;
 			this.positiony.AllowRelative = true;
 			this.positiony.ButtonStep = 1;
 			this.positiony.Location = new System.Drawing.Point(236, 34);
 			this.positiony.Name = "positiony";
 			this.positiony.Size = new System.Drawing.Size(120, 24);
 			this.positiony.TabIndex = 25;
 			// 
 			// VertexEditForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(456, 294);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.tabs);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "VertexEditForm";
 			this.Opacity = 0;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Edit Vertex";
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.VertexEditForm_HelpRequested);
 			tabproperties.ResumeLayout(false);
 			this.groupposition.ResumeLayout(false);
 			this.groupposition.PerformLayout();
 			this.tabs.ResumeLayout(false);
 			this.tabcustom.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\OpenMapOptionsForm.Designer.cs" startline="22" endline="202">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.ColumnHeader columnHeader1;
 			System.Windows.Forms.Label label1;
 			System.Windows.Forms.Label label2;
 			System.Windows.Forms.Label label3;
 			this.panelres = new System.Windows.Forms.GroupBox();
 			this.strictpatches = new System.Windows.Forms.CheckBox();
 			this.datalocations = new CodeImp.DoomBuilder.Controls.ResourceListEditor();
 			this.apply = new System.Windows.Forms.Button();
 			this.cancel = new System.Windows.Forms.Button();
 			this.config = new System.Windows.Forms.ComboBox();
 			this.mapslist = new System.Windows.Forms.ListView();
 			columnHeader1 = new System.Windows.Forms.ColumnHeader();
 			label1 = new System.Windows.Forms.Label();
 			label2 = new System.Windows.Forms.Label();
 			label3 = new System.Windows.Forms.Label();
 			this.panelres.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// columnHeader1
 			// 
 			columnHeader1.Text = "Map name";
 			// 
 			// label1
 			// 
 			label1.AutoSize = true;
 			label1.Location = new System.Drawing.Point(30, 24);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(105, 14);
 			label1.TabIndex = 14;
 			label1.Text = "Game Configuration
 			// 
 			// label2
 			// 
 			label2.Location = new System.Drawing.Point(12, 57);
 			label2.Name = "label2";
 			label2.Size = new System.Drawing.Size(396, 30);
 			label2.TabIndex = 16;
 			label2.Text = "With the above selected configuration, the maps shown below were found in the cho" +
 				"sen WAD file. Please select the map to load for editing.";
 			// 
 			// label3
 			// 
 			label3.AutoSize = true;
 			label3.Location = new System.Drawing.Point(14, 193);
 			label3.Name = "label3";
 			label3.Size = new System.Drawing.Size(312, 28);
 			label3.TabIndex = 17;
 			label3.Text = "Drag items to change order (lower items override higher items).\r\nGrayed items are" +
 				" loaded according to the game configuration.";
 			// 
 			// panelres
 			// 
 			this.panelres.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.panelres.Controls.Add(this.strictpatches);
 			this.panelres.Controls.Add(this.datalocations);
 			this.panelres.Controls.Add(label3);
 			this.panelres.Location = new System.Drawing.Point(12, 215);
 			this.panelres.Name = "panelres";
 			this.panelres.Size = new System.Drawing.Size(396, 231);
 			this.panelres.TabIndex = 2;
 			this.panelres.TabStop = false;
 			this.panelres.Text = " Resources ";
 			// 
 			// strictpatches
 			// 
 			this.strictpatches.AutoSize = true;
 			this.strictpatches.Location = new System.Drawing.Point(14, 27);
 			this.strictpatches.Name = "strictpatches";
 			this.strictpatches.Size = new System.Drawing.Size(352, 18);
 			this.strictpatches.TabIndex = 19;
 			this.strictpatches.Text = "Strictly load patches between P_START and P_END only for this file";
 			this.strictpatches.UseVisualStyleBackColor = true;
 			// 
 			// datalocations
 			// 
 			this.datalocations.DialogOffset = new System.Drawing.Point(40, 20);
 			this.datalocations.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.datalocations.Location = new System.Drawing.Point(14, 58);
 			this.datalocations.Name = "datalocations";
 			this.datalocations.Size = new System.Drawing.Size(368, 127);
 			this.datalocations.TabIndex = 0;
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(178, 462);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 3;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(296, 462);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 4;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// config
 			// 
 			this.config.DropDownHeight = 206;
 			this.config.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.config.FormattingEnabled = true;
 			this.config.IntegralHeight = false;
 			this.config.Location = new System.Drawing.Point(141, 21);
 			this.config.Name = "config";
 			this.config.Size = new System.Drawing.Size(242, 22);
 			this.config.TabIndex = 0;
 			this.config.SelectedIndexChanged += new System.EventHandler(this.config_SelectedIndexChanged);
 			// 
 			// mapslist
 			// 
 			this.mapslist.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.mapslist.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             columnHeader1});
 			this.mapslist.FullRowSelect = true;
 			this.mapslist.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
 			this.mapslist.HideSelection = false;
 			this.mapslist.LabelWrap = false;
 			this.mapslist.Location = new System.Drawing.Point(12, 90);
 			this.mapslist.MultiSelect = false;
 			this.mapslist.Name = "mapslist";
 			this.mapslist.ShowGroups = false;
 			this.mapslist.Size = new System.Drawing.Size(396, 110);
 			this.mapslist.Sorting = System.Windows.Forms.SortOrder.Ascending;
 			this.mapslist.TabIndex = 1;
 			this.mapslist.UseCompatibleStateImageBehavior = false;
 			this.mapslist.View = System.Windows.Forms.View.List;
 			this.mapslist.DoubleClick += new System.EventHandler(this.mapslist_DoubleClick);
 			this.mapslist.ItemSelectionChanged += new System.Windows.Forms.ListViewItemSelectionChangedEventHandler(this.mapslist_ItemSelectionChanged);
 			// 
 			// OpenMapOptionsForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(420, 499);
 			this.Controls.Add(this.mapslist);
 			this.Controls.Add(label2);
 			this.Controls.Add(this.config);
 			this.Controls.Add(label1);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.panelres);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "OpenMapOptionsForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Open Map Options";
 			this.Shown += new System.EventHandler(this.OpenMapOptionsForm_Shown);
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.OpenMapOptionsForm_HelpRequested);
 			this.panelres.ResumeLayout(false);
 			this.panelres.PerformLayout();
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\SectorInfoPanel.Designer.cs" startline="22" endline="268">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.Label label13;
 			System.Windows.Forms.Label label5;
 			System.Windows.Forms.Label label4;
 			System.Windows.Forms.Label label3;
 			System.Windows.Forms.Label label2;
 			System.Windows.Forms.Label label1;
 			this.sectorinfo = new System.Windows.Forms.GroupBox();
 			this.brightness = new System.Windows.Forms.Label();
 			this.height = new System.Windows.Forms.Label();
 			this.tag = new System.Windows.Forms.Label();
 			this.floor = new System.Windows.Forms.Label();
 			this.ceiling = new System.Windows.Forms.Label();
 			this.effect = new System.Windows.Forms.Label();
 			this.ceilingpanel = new System.Windows.Forms.GroupBox();
 			this.ceilingname = new System.Windows.Forms.Label();
 			this.ceilingtex = new System.Windows.Forms.Panel();
 			this.floorpanel = new System.Windows.Forms.GroupBox();
 			this.floorname = new System.Windows.Forms.Label();
 			this.floortex = new System.Windows.Forms.Panel();
 			label13 = new System.Windows.Forms.Label();
 			label5 = new System.Windows.Forms.Label();
 			label4 = new System.Windows.Forms.Label();
 			label3 = new System.Windows.Forms.Label();
 			label2 = new System.Windows.Forms.Label();
 			label1 = new System.Windows.Forms.Label();
 			this.sectorinfo.SuspendLayout();
 			this.ceilingpanel.SuspendLayout();
 			this.floorpanel.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// label13
 			// 
 			label13.AutoSize = true;
 			label13.Location = new System.Drawing.Point(111, 77);
 			label13.Name = "label13";
 			label13.Size = new System.Drawing.Size(62, 14);
 			label13.TabIndex = 14;
 			label13.Text = "Brightness
 			// 
 			// label5
 			// 
 			label5.AutoSize = true;
 			label5.Location = new System.Drawing.Point(133, 58);
 			label5.Name = "label5";
 			label5.Size = new System.Drawing.Size(40, 14);
 			label5.TabIndex = 8;
 			label5.Text = "Height
 			// 
 			// label4
 			// 
 			label4.AutoSize = true;
 			label4.Location = new System.Drawing.Point(24, 77);
 			label4.Name = "label4";
 			label4.Size = new System.Drawing.Size(28, 14);
 			label4.TabIndex = 4;
 			label4.Text = "Tag
 			// 
 			// label3
 			// 
 			label3.AutoSize = true;
 			label3.Location = new System.Drawing.Point(18, 58);
 			label3.Name = "label3";
 			label3.Size = new System.Drawing.Size(34, 14);
 			label3.TabIndex = 3;
 			label3.Text = "Floor
 			// 
 			// label2
 			// 
 			label2.AutoSize = true;
 			label2.Location = new System.Drawing.Point(11, 39);
 			label2.Name = "label2";
 			label2.Size = new System.Drawing.Size(41, 14);
 			label2.TabIndex = 2;
 			label2.Text = "Ceiling
 			// 
 			// label1
 			// 
 			label1.AutoSize = true;
 			label1.Location = new System.Drawing.Point(13, 19);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(39, 14);
 			label1.TabIndex = 0;
 			label1.Text = "Effect
 			// 
 			// sectorinfo
 			// 
 			this.sectorinfo.Controls.Add(this.brightness);
 			this.sectorinfo.Controls.Add(label13);
 			this.sectorinfo.Controls.Add(this.height);
 			this.sectorinfo.Controls.Add(label5);
 			this.sectorinfo.Controls.Add(this.tag);
 			this.sectorinfo.Controls.Add(this.floor);
 			this.sectorinfo.Controls.Add(this.ceiling);
 			this.sectorinfo.Controls.Add(label4);
 			this.sectorinfo.Controls.Add(label3);
 			this.sectorinfo.Controls.Add(label2);
 			this.sectorinfo.Controls.Add(this.effect);
 			this.sectorinfo.Controls.Add(label1);
 			this.sectorinfo.Location = new System.Drawing.Point(0, 0);
 			this.sectorinfo.Name = "sectorinfo";
 			this.sectorinfo.Size = new System.Drawing.Size(230, 100);
 			this.sectorinfo.TabIndex = 2;
 			this.sectorinfo.TabStop = false;
 			this.sectorinfo.Text = " Sector ";
 			// 
 			// brightness
 			// 
 			this.brightness.AutoSize = true;
 			this.brightness.Location = new System.Drawing.Point(177, 77);
 			this.brightness.Name = "brightness";
 			this.brightness.Size = new System.Drawing.Size(13, 14);
 			this.brightness.TabIndex = 17;
 			this.brightness.Text = "0";
 			// 
 			// height
 			// 
 			this.height.AutoSize = true;
 			this.height.Location = new System.Drawing.Point(177, 58);
 			this.height.Name = "height";
 			this.height.Size = new System.Drawing.Size(13, 14);
 			this.height.TabIndex = 11;
 			this.height.Text = "0";
 			// 
 			// tag
 			// 
 			this.tag.AutoSize = true;
 			this.tag.Location = new System.Drawing.Point(55, 77);
 			this.tag.Name = "tag";
 			this.tag.Size = new System.Drawing.Size(13, 14);
 			this.tag.TabIndex = 7;
 			this.tag.Text = "0";
 			// 
 			// floor
 			// 
 			this.floor.AutoSize = true;
 			this.floor.Location = new System.Drawing.Point(55, 58);
 			this.floor.Name = "floor";
 			this.floor.Size = new System.Drawing.Size(25, 14);
 			this.floor.TabIndex = 6;
 			this.floor.Text = "360";
 			// 
 			// ceiling
 			// 
 			this.ceiling.AutoSize = true;
 			this.ceiling.Location = new System.Drawing.Point(55, 39);
 			this.ceiling.Name = "ceiling";
 			this.ceiling.Size = new System.Drawing.Size(31, 14);
 			this.ceiling.TabIndex = 5;
 			this.ceiling.Text = "1024";
 			// 
 			// effect
 			// 
 			this.effect.AutoSize = true;
 			this.effect.Location = new System.Drawing.Point(55, 19);
 			this.effect.Name = "effect";
 			this.effect.Size = new System.Drawing.Size(123, 14);
 			this.effect.TabIndex = 1;
 			this.effect.Text = "0 - Whacky Pool of Fluid";
 			// 
 			// ceilingpanel
 			// 
 			this.ceilingpanel.Controls.Add(this.ceilingname);
 			this.ceilingpanel.Controls.Add(this.ceilingtex);
 			this.ceilingpanel.Location = new System.Drawing.Point(349, 0);
 			this.ceilingpanel.Name = "ceilingpanel";
 			this.ceilingpanel.Size = new System.Drawing.Size(107, 100);
 			this.ceilingpanel.TabIndex = 3;
 			this.ceilingpanel.TabStop = false;
 			this.ceilingpanel.Text = " Ceiling ";
 			// 
 			// ceilingname
 			// 
 			this.ceilingname.Location = new System.Drawing.Point(11, 80);
 			this.ceilingname.Name = "ceilingname";
 			this.ceilingname.Size = new System.Drawing.Size(84, 13);
 			this.ceilingname.TabIndex = 1;
 			this.ceilingname.Text = "BROWNHUG";
 			this.ceilingname.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// ceilingtex
 			// 
 			this.ceilingtex.BackColor = System.Drawing.SystemColors.AppWorkspace;
 			this.ceilingtex.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Zoom;
 			this.ceilingtex.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.ceilingtex.Location = new System.Drawing.Point(19, 19);
 			this.ceilingtex.Name = "ceilingtex";
 			this.ceilingtex.Size = new System.Drawing.Size(68, 60);
 			this.ceilingtex.TabIndex = 0;
 			// 
 			// floorpanel
 			// 
 			this.floorpanel.Controls.Add(this.floorname);
 			this.floorpanel.Controls.Add(this.floortex);
 			this.floorpanel.Location = new System.Drawing.Point(236, 0);
 			this.floorpanel.Name = "floorpanel";
 			this.floorpanel.Size = new System.Drawing.Size(107, 100);
 			this.floorpanel.TabIndex = 4;
 			this.floorpanel.TabStop = false;
 			this.floorpanel.Text = " Floor ";
 			// 
 			// floorname
 			// 
 			this.floorname.Location = new System.Drawing.Point(11, 80);
 			this.floorname.Name = "floorname";
 			this.floorname.Size = new System.Drawing.Size(84, 13);
 			this.floorname.TabIndex = 1;
 			this.floorname.Text = "BROWNHUG";
 			this.floorname.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// floortex
 			// 
 			this.floortex.BackColor = System.Drawing.SystemColors.AppWorkspace;
 			this.floortex.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Zoom;
 			this.floortex.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.floortex.Location = new System.Drawing.Point(19, 19);
 			this.floortex.Name = "floortex";
 			this.floortex.Size = new System.Drawing.Size(68, 60);
 			this.floortex.TabIndex = 0;
 			// 
 			// SectorInfoPanel
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.floorpanel);
 			this.Controls.Add(this.ceilingpanel);
 			this.Controls.Add(this.sectorinfo);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.MaximumSize = new System.Drawing.Size(10000, 100);
 			this.MinimumSize = new System.Drawing.Size(100, 100);
 			this.Name = "SectorInfoPanel";
 			this.Size = new System.Drawing.Size(481, 100);
 			this.sectorinfo.ResumeLayout(false);
 			this.sectorinfo.PerformLayout();
 			this.ceilingpanel.ResumeLayout(false);
 			this.floorpanel.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\LinedefInfoPanel.cs" startline="52" endline="223">
<![CDATA[
 		
 		// This shows the info
 		public void ShowInfo(Linedef l)
 		{
 			TypeHandler th;
 			bool upperunpegged, lowerunpegged;
 			string peggedness;
 			
 			// Show/hide stuff depending on format
 			if(!General.Map.FormatInterface.HasActionArgs)
 			{
 				arglbl1.Visible = false;
 				arglbl2.Visible = false;
 				arglbl3.Visible = false;
 				arglbl4.Visible = false;
 				arglbl5.Visible = false;
 				arg1.Visible = false;
 				arg2.Visible = false;
 				arg3.Visible = false;
 				arg4.Visible = false;
 				arg5.Visible = false;
 				infopanel.Width = doomformatwidth;
 			}
 			else
 			{
 				arglbl1.Visible = true;
 				arglbl2.Visible = true;
 				arglbl3.Visible = true;
 				arglbl4.Visible = true;
 				arglbl5.Visible = true;
 				arg1.Visible = true;
 				arg2.Visible = true;
 				arg3.Visible = true;
 				arg4.Visible = true;
 				arg5.Visible = true;
 				infopanel.Width = hexenformatwidth;
 			}
 
 			// Move panels
 			frontpanel.Left = infopanel.Left + infopanel.Width + infopanel.Margin.Right + frontpanel.Margin.Left;
 			backpanel.Left = frontpanel.Left + frontpanel.Width + frontpanel.Margin.Right + backpanel.Margin.Left;
 			
 			// Get line action information
 			LinedefActionInfo act = General.Map.Config.GetLinedefActionInfo(l.Action);
 			
 			// Determine peggedness
 			upperunpegged = l.IsFlagSet(General.Map.Config.UpperUnpeggedFlag);
 			lowerunpegged = l.IsFlagSet(General.Map.Config.LowerUnpeggedFlag);
 			if(upperunpegged && lowerunpegged)
 				peggedness = "Upper & Lower";
 			else if(upperunpegged)
 				peggedness = "Upper";
 			else if(lowerunpegged)
 				peggedness = "Lower";
 			else
 				peggedness = "None";
 			
 			// Linedef info
 			infopanel.Text = " Linedef " + l.Index + " ";
 			action.Text = act.ToString();
 			length.Text = l.Length.ToString("0.##");
 			angle.Text = l.AngleDeg.ToString() + "\u00B0";
 			tag.Text = l.Tag.ToString();
 			unpegged.Text = peggedness;
 			
 			// Arguments
 			arglbl1.Text = act.Args[0].Title + "
 			arglbl2.Text = act.Args[1].Title + "
 			arglbl3.Text = act.Args[2].Title + "
 			arglbl4.Text = act.Args[3].Title + "
 			arglbl5.Text = act.Args[4].Title + "
 			arglbl1.Enabled = act.Args[0].Used;
 			arglbl2.Enabled = act.Args[1].Used;
 			arglbl3.Enabled = act.Args[2].Used;
 			arglbl4.Enabled = act.Args[3].Used;
 			arglbl5.Enabled = act.Args[4].Used;
 			arg1.Enabled = act.Args[0].Used;
 			arg2.Enabled = act.Args[1].Used;
 			arg3.Enabled = act.Args[2].Used;
 			arg4.Enabled = act.Args[3].Used;
 			arg5.Enabled = act.Args[4].Used;
 			th = General.Types.GetArgumentHandler(act.Args[0]);
 			th.SetValue(l.Args[0]); arg1.Text = th.GetStringValue();
 			th = General.Types.GetArgumentHandler(act.Args[1]);
 			th.SetValue(l.Args[1]); arg2.Text = th.GetStringValue();
 			th = General.Types.GetArgumentHandler(act.Args[2]);
 			th.SetValue(l.Args[2]); arg3.Text = th.GetStringValue();
 			th = General.Types.GetArgumentHandler(act.Args[3]);
 			th.SetValue(l.Args[3]); arg4.Text = th.GetStringValue();
 			th = General.Types.GetArgumentHandler(act.Args[4]);
 			th.SetValue(l.Args[4]); arg5.Text = th.GetStringValue();
 
 			// Front side available?
 			if(l.Front != null)
 			{
 				// Show sidedef info
 				frontpanel.Text = " Front Sidedef " + l.Front.Index + " ";
 				frontsector.Text = " Sector " + l.Front.Sector.Index;
 				frontsector.Visible = true;
 				frontoffset.Text = l.Front.OffsetX + ", " + l.Front.OffsetY;
 				fronthighname.Text = l.Front.HighTexture;
 				frontmidname.Text = l.Front.MiddleTexture;
 				frontlowname.Text = l.Front.LowTexture;
 				DisplaySidedefTexture(fronthightex, l.Front.HighTexture, l.Front.HighRequired());
 				DisplaySidedefTexture(frontmidtex, l.Front.MiddleTexture, l.Front.MiddleRequired());
 				DisplaySidedefTexture(frontlowtex, l.Front.LowTexture, l.Front.LowRequired());
 				frontoffsetlabel.Enabled = true;
 				frontoffset.Enabled = true;
 				frontpanel.Enabled = true;
 			}
 			else
 			{
 				// Show no info
 				frontpanel.Text = " Front Sidedef ";
 				frontsector.Text = "";
 				frontsector.Visible = false;
 				frontoffsetlabel.Enabled = false;
 				frontoffset.Enabled = false;
 				frontpanel.Enabled = false;
 				frontoffset.Text = "--, --";
 				fronthighname.Text = "";
 				frontmidname.Text = "";
 				frontlowname.Text = "";
 				fronthightex.BackgroundImage = null;
 				frontmidtex.BackgroundImage = null;
 				frontlowtex.BackgroundImage = null;
 			}
 
 			// Back size available?
 			if(l.Back != null)
 			{
 				// Show sidedef info
 				backpanel.Text = " Back Sidedef " + l.Back.Index + " ";
 				backsector.Text = " Sector " + l.Back.Sector.Index;
 				backsector.Visible = true;
 				backoffset.Text = l.Back.OffsetX + ", " + l.Back.OffsetY;
 				backhighname.Text = l.Back.HighTexture;
 				backmidname.Text = l.Back.MiddleTexture;
 				backlowname.Text = l.Back.LowTexture;
 				DisplaySidedefTexture(backhightex, l.Back.HighTexture, l.Back.HighRequired());
 				DisplaySidedefTexture(backmidtex, l.Back.MiddleTexture, l.Back.MiddleRequired());
 				DisplaySidedefTexture(backlowtex, l.Back.LowTexture, l.Back.LowRequired());
 				backoffsetlabel.Enabled = true;
 				backoffset.Enabled = true;
 				backpanel.Enabled = true;
 			}
 			else
 			{
 				// Show no info
 				backpanel.Text = " Back Sidedef ";
 				backsector.Text = "";
 				backsector.Visible = false;
 				backoffsetlabel.Enabled = false;
 				backoffset.Enabled = false;
 				backpanel.Enabled = false;
 				backoffset.Text = "--, --";
 				backhighname.Text = "";
 				backmidname.Text = "";
 				backlowname.Text = "";
 				backhightex.BackgroundImage = null;
 				backmidtex.BackgroundImage = null;
 				backlowtex.BackgroundImage = null;
 			}
 			
 			// Position labels
 			frontsector.Left = frontlowtex.Right - frontsector.Width;
 			backsector.Left = backlowtex.Right - backsector.Width;
 
 			// Show the whole thing
 			this.Show();
 			this.Update();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\LinedefEditForm.cs" startline="491" endline="531">
<![CDATA[
 
 		// Action changes
 		private void action_ValueChanges(object sender, EventArgs e)
 		{
 			int showaction = 0;
 			
 			// Only when line type is known
 			if(General.Map.Config.LinedefActions.ContainsKey(action.Value)) showaction = action.Value;
 			
 			// Change the argument descriptions
 			arg0label.Text = General.Map.Config.LinedefActions[showaction].Args[0].Title + "
 			arg1label.Text = General.Map.Config.LinedefActions[showaction].Args[1].Title + "
 			arg2label.Text = General.Map.Config.LinedefActions[showaction].Args[2].Title + "
 			arg3label.Text = General.Map.Config.LinedefActions[showaction].Args[3].Title + "
 			arg4label.Text = General.Map.Config.LinedefActions[showaction].Args[4].Title + "
 			arg0label.Enabled = General.Map.Config.LinedefActions[showaction].Args[0].Used;
 			arg1label.Enabled = General.Map.Config.LinedefActions[showaction].Args[1].Used;
 			arg2label.Enabled = General.Map.Config.LinedefActions[showaction].Args[2].Used;
 			arg3label.Enabled = General.Map.Config.LinedefActions[showaction].Args[3].Used;
 			arg4label.Enabled = General.Map.Config.LinedefActions[showaction].Args[4].Used;
 			if(arg0label.Enabled) arg0.ForeColor = SystemColors.WindowText; else arg0.ForeColor = SystemColors.GrayText;
 			if(arg1label.Enabled) arg1.ForeColor = SystemColors.WindowText; else arg1.ForeColor = SystemColors.GrayText;
 			if(arg2label.Enabled) arg2.ForeColor = SystemColors.WindowText; else arg2.ForeColor = SystemColors.GrayText;
 			if(arg3label.Enabled) arg3.ForeColor = SystemColors.WindowText; else arg3.ForeColor = SystemColors.GrayText;
 			if(arg4label.Enabled) arg4.ForeColor = SystemColors.WindowText; else arg4.ForeColor = SystemColors.GrayText;
 			arg0.Setup(General.Map.Config.LinedefActions[showaction].Args[0]);
 			arg1.Setup(General.Map.Config.LinedefActions[showaction].Args[1]);
 			arg2.Setup(General.Map.Config.LinedefActions[showaction].Args[2]);
 			arg3.Setup(General.Map.Config.LinedefActions[showaction].Args[3]);
 			arg4.Setup(General.Map.Config.LinedefActions[showaction].Args[4]);
 
 			// Zero all arguments when linedef action 0 (normal) is chosen
 			if(!preventchanges && (showaction == 0))
 			{
 				arg0.SetValue(0);
 				arg1.SetValue(0);
 				arg2.SetValue(0);
 				arg3.SetValue(0);
 				arg4.SetValue(0);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ScriptFindReplaceForm.cs" startline="101" endline="109">
<![CDATA[
 		
 		// Replace
 		private void replacebutton_Click(object sender, EventArgs e)
 		{
 			FindReplaceOptions options = MakeOptions();
 			
 			General.Map.ScriptEditor.Editor.Replace(options);
 			General.Map.ScriptEditor.Editor.FindNext(options);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ResourceListView.cs" startline="268" endline="282">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This deselects all items
 		private void DeselectAll()
 		{
 			// Go for all selected items
 			for(int i = base.SelectedItems.Count - 1; i >= 0; i--)
 			{
 				// Item grayed? Then abort!
 				base.SelectedItems[i].Selected = false;
 			}
 			for(int i = base.SelectedItems.Count - 1; i >= 0; i--)
 			{
 				// Item grayed? Then abort!
 				base.SelectedItems[i].Selected = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\HexenMapSetIO.cs" startline="269" endline="412">
<![CDATA[
 		
 		// This reads the LINEDEFS and SIDEDEFS from WAD file
 		private void ReadLinedefs(MapSet map, int firstindex,
 			Dictionary<int, Vertex> vertexlink, Dictionary<int, Sector> sectorlink)
 		{
 			MemoryStream linedefsmem, sidedefsmem;
 			BinaryReader readline, readside;
 			Lump linedefslump, sidedefslump;
 			int num, numsides, i, offsetx, offsety, v1, v2;
 			int s1, s2, flags, action, sc;
 			int[] args = new int[Linedef.NUM_ARGS];
 			Dictionary<string, bool> stringflags;
 			string thigh, tmid, tlow;
 			Linedef l;
 			Sidedef s;
 
 			// Get the linedefs lump from wad file
 			linedefslump = wad.FindLump("LINEDEFS", firstindex);
 			if(linedefslump == null) throw new Exception("Could not find required lump LINEDEFS!");
 
 			// Get the sidedefs lump from wad file
 			sidedefslump = wad.FindLump("SIDEDEFS", firstindex);
 			if(sidedefslump == null) throw new Exception("Could not find required lump SIDEDEFS!");
 
 			// Prepare to read the items
 			linedefsmem = new MemoryStream(linedefslump.Stream.ReadAllBytes());
 			sidedefsmem = new MemoryStream(sidedefslump.Stream.ReadAllBytes());
 			num = (int)linedefslump.Stream.Length / 16;
 			numsides = (int)sidedefslump.Stream.Length / 30;
 			readline = new BinaryReader(linedefsmem);
 			readside = new BinaryReader(sidedefsmem);
 
 			// Read items from the lump
 			map.SetCapacity(0, map.Linedefs.Count + num, map.Sidedefs.Count + numsides, 0, 0);
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				v1 = readline.ReadUInt16();
 				v2 = readline.ReadUInt16();
 				flags = readline.ReadUInt16();
 				action = readline.ReadByte();
 				args[0] = readline.ReadByte();
 				args[1] = readline.ReadByte();
 				args[2] = readline.ReadByte();
 				args[3] = readline.ReadByte();
 				args[4] = readline.ReadByte();
 				s1 = readline.ReadUInt16();
 				s2 = readline.ReadUInt16();
 				
 				// Make string flags
 				stringflags = new Dictionary<string, bool>();
 				foreach(string f in manager.Config.SortedLinedefFlags)
 				{
 					int fnum;
 					if(int.TryParse(f, out fnum)) stringflags[f] = ((flags & fnum) == fnum);
 				}
 				foreach(string f in manager.Config.SortedLinedefFlags)
 				{
 					int fnum;
 					if(int.TryParse(f, out fnum)) stringflags[f] = ((flags & fnum) == fnum);
 				}
 				
 				// Create new linedef
 				if(vertexlink.ContainsKey(v1) && vertexlink.ContainsKey(v2))
 				{
 					// Check if not zero-length
 					if(Vector2D.ManhattanDistance(vertexlink[v1].Position, vertexlink[v2].Position) > 0.0001f)
 					{
 						l = map.CreateLinedef(vertexlink[v1], vertexlink[v2]);
 						l.Update(stringflags, (flags & manager.Config.LinedefActivationsFilter), 0, action, args);
 						l.UpdateCache();
 
 						// Line has a front side?
 						if(s1 != ushort.MaxValue)
 						{
 							// Read front sidedef
 							sidedefsmem.Seek(s1 * 30, SeekOrigin.Begin);
 							if((s1 * 30L) <= (sidedefsmem.Length - 30L))
 							{
 								offsetx = readside.ReadInt16();
 								offsety = readside.ReadInt16();
 								thigh = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tlow = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tmid = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								sc = readside.ReadUInt16();
 
 								// Create front sidedef
 								if(sectorlink.ContainsKey(sc))
 								{
 									s = map.CreateSidedef(l, true, sectorlink[sc]);
 									s.Update(offsetx, offsety, thigh, tmid, tlow);
 								}
 								else
 								{
 									General.ErrorLogger.Add(ErrorType.Warning, "Sidedef " + s1 + " references invalid sector " + sc + ". Sidedef has been removed.");
 								}
 							}
 							else
 							{
 								General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references invalid sidedef " + s1 + ". Sidedef has been removed.");
 							}
 						}
 
 						// Line has a back side?
 						if(s2 != ushort.MaxValue)
 						{
 							// Read back sidedef
 							sidedefsmem.Seek(s2 * 30, SeekOrigin.Begin);
 							if((s2 * 30L) <= (sidedefsmem.Length - 30L))
 							{
 								offsetx = readside.ReadInt16();
 								offsety = readside.ReadInt16();
 								thigh = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tlow = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tmid = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								sc = readside.ReadUInt16();
 
 								// Create back sidedef
 								if(sectorlink.ContainsKey(sc))
 								{
 									s = map.CreateSidedef(l, false, sectorlink[sc]);
 									s.Update(offsetx, offsety, thigh, tmid, tlow);
 								}
 								else
 								{
 									General.ErrorLogger.Add(ErrorType.Warning, "Sidedef " + s2 + " references invalid sector " + sc + ". Sidedef has been removed.");
 								}
 							}
 							else
 							{
 								General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references invalid sidedef " + s2 + ". Sidedef has been removed.");
 							}
 						}
 					}
 					else
 					{
 						General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " is zero-length. Linedef has been removed.");
 					}
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references one or more invalid vertices. Linedef has been removed.");
 				}
 			}
 			for(i = 0; i < num; i++)
 			{
 				// Read properties from stream
 				v1 = readline.ReadUInt16();
 				v2 = readline.ReadUInt16();
 				flags = readline.ReadUInt16();
 				action = readline.ReadByte();
 				args[0] = readline.ReadByte();
 				args[1] = readline.ReadByte();
 				args[2] = readline.ReadByte();
 				args[3] = readline.ReadByte();
 				args[4] = readline.ReadByte();
 				s1 = readline.ReadUInt16();
 				s2 = readline.ReadUInt16();
 				
 				// Make string flags
 				stringflags = new Dictionary<string, bool>();
 				foreach(string f in manager.Config.SortedLinedefFlags)
 				{
 					int fnum;
 					if(int.TryParse(f, out fnum)) stringflags[f] = ((flags & fnum) == fnum);
 				}
 				
 				// Create new linedef
 				if(vertexlink.ContainsKey(v1) && vertexlink.ContainsKey(v2))
 				{
 					// Check if not zero-length
 					if(Vector2D.ManhattanDistance(vertexlink[v1].Position, vertexlink[v2].Position) > 0.0001f)
 					{
 						l = map.CreateLinedef(vertexlink[v1], vertexlink[v2]);
 						l.Update(stringflags, (flags & manager.Config.LinedefActivationsFilter), 0, action, args);
 						l.UpdateCache();
 
 						// Line has a front side?
 						if(s1 != ushort.MaxValue)
 						{
 							// Read front sidedef
 							sidedefsmem.Seek(s1 * 30, SeekOrigin.Begin);
 							if((s1 * 30L) <= (sidedefsmem.Length - 30L))
 							{
 								offsetx = readside.ReadInt16();
 								offsety = readside.ReadInt16();
 								thigh = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tlow = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tmid = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								sc = readside.ReadUInt16();
 
 								// Create front sidedef
 								if(sectorlink.ContainsKey(sc))
 								{
 									s = map.CreateSidedef(l, true, sectorlink[sc]);
 									s.Update(offsetx, offsety, thigh, tmid, tlow);
 								}
 								else
 								{
 									General.ErrorLogger.Add(ErrorType.Warning, "Sidedef " + s1 + " references invalid sector " + sc + ". Sidedef has been removed.");
 								}
 							}
 							else
 							{
 								General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references invalid sidedef " + s1 + ". Sidedef has been removed.");
 							}
 						}
 
 						// Line has a back side?
 						if(s2 != ushort.MaxValue)
 						{
 							// Read back sidedef
 							sidedefsmem.Seek(s2 * 30, SeekOrigin.Begin);
 							if((s2 * 30L) <= (sidedefsmem.Length - 30L))
 							{
 								offsetx = readside.ReadInt16();
 								offsety = readside.ReadInt16();
 								thigh = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tlow = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								tmid = Lump.MakeNormalName(readside.ReadBytes(8), WAD.ENCODING);
 								sc = readside.ReadUInt16();
 
 								// Create back sidedef
 								if(sectorlink.ContainsKey(sc))
 								{
 									s = map.CreateSidedef(l, false, sectorlink[sc]);
 									s.Update(offsetx, offsety, thigh, tmid, tlow);
 								}
 								else
 								{
 									General.ErrorLogger.Add(ErrorType.Warning, "Sidedef " + s2 + " references invalid sector " + sc + ". Sidedef has been removed.");
 								}
 							}
 							else
 							{
 								General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references invalid sidedef " + s2 + ". Sidedef has been removed.");
 							}
 						}
 					}
 					else
 					{
 						General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " is zero-length. Linedef has been removed.");
 					}
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references one or more invalid vertices. Linedef has been removed.");
 				}
 			}
 
 			// Done
 			linedefsmem.Dispose();
 			sidedefsmem.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="679" endline="724">
<![CDATA[
 		
 		// Compile Script clicked
 		private void buttoncompile_Click(object sender, EventArgs e)
 		{
 			// First save all implicit scripts to the temporary wad file
 			ImplicitSave();
 			
 			// Get script
 			ScriptDocumentTab t = (tabs.SelectedTab as ScriptDocumentTab);
 
 			// Check if it must be saved as a new file
 			if(t.ExplicitSave && t.IsSaveAsRequired)
 			{
 				// Save the script first!
 				if(MessageBox.Show(this.ParentForm, "You must save your script before you can compile it. Do you want to save your script now?", "Compile Script", MessageBoxButtons.YesNo, MessageBoxIcon.Warning) == DialogResult.Yes)
 				{
 					if(!SaveScript(t)) return;
 				}
 				else
 				{
 					return;
 				}
 			}
 			else
 			{
 				if(t.ExplicitSave && t.IsChanged)
 				{
 					// We can only compile when the script is saved
 					if(!SaveScript(t)) return;
 				}
 			}
 
 			// Compile now
 			General.MainWindow.DisplayStatus(StatusType.Busy, "Compiling script " + t.Text + "...");
 			Cursor.Current = Cursors.WaitCursor;
 			t.Compile();
 
 			// Show warning
 			if((compilererrors != null) && (compilererrors.Count > 0))
 				General.MainWindow.DisplayStatus(StatusType.Warning, compilererrors.Count.ToString() + " errors while compiling " + t.Text + "!");
 			else
 				General.MainWindow.DisplayStatus(StatusType.Info, "Script " + t.Text + " compiled without errors.");
 
 			Cursor.Current = Cursors.Default;
 			UpdateToolbar(true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\StateStructure.cs" startline="55" endline="155">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal StateStructure(ActorStructure actor, DecorateParser parser, string statename)
 		{
 			string lasttoken = "";
 			
 			this.gotostate = null;
 			this.parser = parser;
 			this.sprites = new List<string>();
 			
 			// Skip whitespace
 			while(parser.SkipWhitespace(true))
 			{
 				// Read first token
 				string token = parser.ReadToken();
 				token = token.ToLowerInvariant();
 				
 				// One of the flow control statements?
 				if((token == "loop") || (token == "stop") || (token == "wait") || (token == "fail"))
 				{
 					// Ignore flow control
 				}
 				// Goto?
 				else if(token == "goto")
 				{
 					gotostate = new StateGoto(actor, parser);
 					if(parser.HasError) return;
 				}
 				// Label?
 				else if(token == "
 				{
 					// Rewind so that this label can be read again
 					parser.DataStream.Seek(-(lasttoken.Length + 1), SeekOrigin.Current);
 					
 					// Done here
 					return;
 				}
 				// End of scope?
 				else if(token == "}")
 				{
 					// Rewind so that this scope end can be read again
 					parser.DataStream.Seek(-1, SeekOrigin.Current);
 
 					// Done here
 					return;
 				}
 				else
 				{
 					// First part of the sprite name
 					if(token == null)
 					{
 						parser.ReportError("Unexpected end of structure");
 						return;
 					}
 					
 					// Frames of the sprite name
 					parser.SkipWhitespace(true);
 					string spriteframes = parser.ReadToken();
 					if(spriteframes == null)
 					{
 						parser.ReportError("Unexpected end of structure");
 						return;
 					}
 					// Label?
 					else if(spriteframes == "
 					{
 						// Rewind so that this label can be read again
 						parser.DataStream.Seek(-(token.Length + 1), SeekOrigin.Current);
 
 						// Done here
 						return;
 					}
 					
 					// No first sprite yet?
 					if(spriteframes.Length > 0)
 					{
 						// Make the sprite name
 						string spritename = token + spriteframes[0];
 						spritename = spritename.ToUpperInvariant();
 						
 						// Ignore some odd ZDoom thing
 						if(!IGNORE_SPRITE.StartsWith(spritename))
 							sprites.Add(spritename);
 					}
 					
 					// Continue until the end of the line
 					string t = "";
 					while((t != "\n") && (t != null))
 					{
 						parser.SkipWhitespace(false);
 						t = parser.ReadToken();
 					}
 					while((t != "\n") && (t != null))
 					{
 						parser.SkipWhitespace(false);
 						t = parser.ReadToken();
 					}
 				}
 				
 				lasttoken = token;
 			}
 			while(parser.SkipWhitespace(true))
 			{
 				// Read first token
 				string token = parser.ReadToken();
 				token = token.ToLowerInvariant();
 				
 				// One of the flow control statements?
 				if((token == "loop") || (token == "stop") || (token == "wait") || (token == "fail"))
 				{
 					// Ignore flow control
 				}
 				// Goto?
 				else if(token == "goto")
 				{
 					gotostate = new StateGoto(actor, parser);
 					if(parser.HasError) return;
 				}
 				// Label?
 				else if(token == "
 				{
 					// Rewind so that this label can be read again
 					parser.DataStream.Seek(-(lasttoken.Length + 1), SeekOrigin.Current);
 					
 					// Done here
 					return;
 				}
 				// End of scope?
 				else if(token == "}")
 				{
 					// Rewind so that this scope end can be read again
 					parser.DataStream.Seek(-1, SeekOrigin.Current);
 
 					// Done here
 					return;
 				}
 				else
 				{
 					// First part of the sprite name
 					if(token == null)
 					{
 						parser.ReportError("Unexpected end of structure");
 						return;
 					}
 					
 					// Frames of the sprite name
 					parser.SkipWhitespace(true);
 					string spriteframes = parser.ReadToken();
 					if(spriteframes == null)
 					{
 						parser.ReportError("Unexpected end of structure");
 						return;
 					}
 					// Label?
 					else if(spriteframes == "
 					{
 						// Rewind so that this label can be read again
 						parser.DataStream.Seek(-(token.Length + 1), SeekOrigin.Current);
 
 						// Done here
 						return;
 					}
 					
 					// No first sprite yet?
 					if(spriteframes.Length > 0)
 					{
 						// Make the sprite name
 						string spritename = token + spriteframes[0];
 						spritename = spritename.ToUpperInvariant();
 						
 						// Ignore some odd ZDoom thing
 						if(!IGNORE_SPRITE.StartsWith(spritename))
 							sprites.Add(spritename);
 					}
 					
 					// Continue until the end of the line
 					string t = "";
 					while((t != "\n") && (t != null))
 					{
 						parser.SkipWhitespace(false);
 						t = parser.ReadToken();
 					}
 				}
 				
 				lasttoken = token;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersTabsControl.cs" startline="90" endline="204">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 		
 		// This redraws the tabs
 		protected unsafe void RedrawTabs()
 		{
 			// Determine length and width in pixels
 			int tabslength = 0;
 			for(int i = 0; i < this.TabPages.Count; i++)
 			{
 				Rectangle r = this.GetTabRect(i);
 				tabslength += r.Height;
 			}
 			for(int i = 0; i < this.TabPages.Count; i++)
 			{
 				Rectangle r = this.GetTabRect(i);
 				tabslength += r.Height;
 			}
 			tabslength += 4;
 			int tabswidth = this.ItemSize.Height + 2;
 			
 			// Dispose old image
 			if(tabsimage != null)
 			{
 				tabsimage.Dispose();
 				tabsimage = null;
 			}
 			
 			if(VisualStyleInformation.IsSupportedByOS && VisualStyleInformation.IsEnabledByUser)
 			{
 				StringFormat drawformat = new StringFormat();
 				drawformat.Alignment = StringAlignment.Center;
 				drawformat.HotkeyPrefix = HotkeyPrefix.None;
 				drawformat.LineAlignment = StringAlignment.Center;
 				
 				// Create images
 				tabsimage = new Bitmap(tabswidth, tabslength, PixelFormat.Format32bppArgb);
 				Bitmap drawimage = new Bitmap(tabslength, tabswidth, PixelFormat.Format32bppArgb);
 				Graphics g = Graphics.FromImage(drawimage);
 				
 				// Render the tabs (backwards when right-aligned)
 				int posoffset = 0;
 				int selectedposoffset = -1;
 				int start = (this.Alignment == TabAlignment.Left) ? 0 
 				int end = (this.Alignment == TabAlignment.Left) ? this.TabPages.Count 
 				int step = (this.Alignment == TabAlignment.Left) ? 1 
 				for(int i = start; i != end; i += step)
 				{
 					VisualStyleRenderer renderer;
 					Rectangle tr = this.GetTabRect(i);
 					
 					// Tab selected?
 					if(i == this.SelectedIndex)
 					{
 						// We will draw this later
 						selectedposoffset = posoffset;
 					}
 					else
 					{
 						if(i == highlighttab)
 							renderer = new VisualStyleRenderer(VisualStyleElement.Tab.TabItem.Hot);
 						else
 							renderer = new VisualStyleRenderer(VisualStyleElement.Tab.TabItem.Normal);
 						
 						// Draw tab
 						Rectangle r = new Rectangle(posoffset + 2, 2, tr.Height, tr.Width - 2);
 						renderer.DrawBackground(g, r);
 						g.DrawString(this.TabPages[i].Text, this.Font, SystemBrushes.ControlText, new RectangleF(r.Location, r.Size), drawformat);
 					}
 					
 					posoffset += tr.Height;
 				}
 				for(int i = start; i != end; i += step)
 				{
 					VisualStyleRenderer renderer;
 					Rectangle tr = this.GetTabRect(i);
 					
 					// Tab selected?
 					if(i == this.SelectedIndex)
 					{
 						// We will draw this later
 						selectedposoffset = posoffset;
 					}
 					else
 					{
 						if(i == highlighttab)
 							renderer = new VisualStyleRenderer(VisualStyleElement.Tab.TabItem.Hot);
 						else
 							renderer = new VisualStyleRenderer(VisualStyleElement.Tab.TabItem.Normal);
 						
 						// Draw tab
 						Rectangle r = new Rectangle(posoffset + 2, 2, tr.Height, tr.Width - 2);
 						renderer.DrawBackground(g, r);
 						g.DrawString(this.TabPages[i].Text, this.Font, SystemBrushes.ControlText, new RectangleF(r.Location, r.Size), drawformat);
 					}
 					
 					posoffset += tr.Height;
 				}
 				
 				// Render the selected tab, because it is slightly larger and overlapping the others
 				if(selectedposoffset > -1)
 				{
 					VisualStyleRenderer renderer = new VisualStyleRenderer(VisualStyleElement.Tab.TabItem.Pressed);
 					Rectangle tr = this.GetTabRect(this.SelectedIndex);
 					Rectangle r = new Rectangle(selectedposoffset, 0, tr.Height + 4, tr.Width);
 					renderer.DrawBackground(g, r);
 					g.DrawString(this.TabPages[this.SelectedIndex].Text, this.Font, SystemBrushes.ControlText, new RectangleF(r.X, r.Y, r.Width, r.Height - 2), drawformat);
 				}
 				
 				// Rotate the image and copy to tabsimage
 				BitmapData drawndata = drawimage.LockBits(new Rectangle(0, 0, drawimage.Size.Width, drawimage.Size.Height), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
 				BitmapData targetdata = tabsimage.LockBits(new Rectangle(0, 0, tabsimage.Size.Width, tabsimage.Size.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
 				int* dd = (int*)drawndata.Scan0.ToPointer();
 				int* td = (int*)targetdata.Scan0.ToPointer();
 				if(this.Alignment == TabAlignment.Right)
 				{
 					for(int y = 0; y < drawndata.Height; y++)
 					{
 						for(int x = 0; x < drawndata.Width; x++)
 						{
 							td[(drawndata.Width - 1 - x) * targetdata.Width + y] = *dd;
 							dd++;
 						}
 						for(int x = 0; x < drawndata.Width; x++)
 						{
 							td[(drawndata.Width - 1 - x) * targetdata.Width + y] = *dd;
 							dd++;
 						}
 					}
 					for(int y = 0; y < drawndata.Height; y++)
 					{
 						for(int x = 0; x < drawndata.Width; x++)
 						{
 							td[(drawndata.Width - 1 - x) * targetdata.Width + y] = *dd;
 							dd++;
 						}
 					}
 				}
 				else
 				{
 					for(int y = 0; y < drawndata.Height; y++)
 					{
 						for(int x = 0; x < drawndata.Width; x++)
 						{
 							td[x * targetdata.Width + (drawndata.Height - 1 - y)] = *dd;
 							dd++;
 						}
 						for(int x = 0; x < drawndata.Width; x++)
 						{
 							td[x * targetdata.Width + (drawndata.Height - 1 - y)] = *dd;
 							dd++;
 						}
 					}
 					for(int y = 0; y < drawndata.Height; y++)
 					{
 						for(int x = 0; x < drawndata.Width; x++)
 						{
 							td[x * targetdata.Width + (drawndata.Height - 1 - y)] = *dd;
 							dd++;
 						}
 					}
 				}
 				drawimage.UnlockBits(drawndata);
 				tabsimage.UnlockBits(targetdata);
 				
 				// Clean up
 				g.Dispose();
 				drawimage.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Sidedef.cs" startline="350" endline="371">
<![CDATA[
 
 		/// <summary>
 		/// This returns the height of the middle wall part.
 		/// </summary>
 		public int GetMiddleHeight()
 		{
 			Sidedef other = this.Other;
 			if(other != null)
 			{
 				int top = Math.Min(this.Sector.CeilHeight, other.Sector.CeilHeight);
 				int bottom = Math.Max(this.Sector.FloorHeight, other.Sector.FloorHeight);
 				int height = top - bottom;
 				return (height > 0) ? height 
 			}
 			else
 			{
 				int top = this.Sector.CeilHeight;
 				int bottom = this.Sector.FloorHeight;
 				int height = top - bottom;
 				return (height > 0) ? height 
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamReader.cs" startline="159" endline="207">
<![CDATA[
 
 		// This reads the things
 		private void ReadThings(MapSet map, UniversalParser textmap)
 		{
 			// Get list of entries
 			List<UniversalCollection> collections = GetNamedCollections(textmap.Root, "thing");
 
 			// Go for all collections
 			map.SetCapacity(0, 0, 0, 0, map.Things.Count + collections.Count);
 			for(int i = 0; i < collections.Count; i++)
 			{
 				// Read fields
 				UniversalCollection c = collections[i];
 				int[] args = new int[Linedef.NUM_ARGS];
 				string where = "thing " + i;
 				float x = GetCollectionEntry<float>(c, "x", true, 0.0f, where);
 				float y = GetCollectionEntry<float>(c, "y", true, 0.0f, where);
 				float height = GetCollectionEntry<float>(c, "height", false, 0.0f, where);
 				int tag = GetCollectionEntry<int>(c, "id", false, 0, where);
 				int angledeg = GetCollectionEntry<int>(c, "angle", false, 0, where);
 				int type = GetCollectionEntry<int>(c, "type", true, 0, where);
 				int special = GetCollectionEntry<int>(c, "special", false, 0, where);
 				args[0] = GetCollectionEntry<int>(c, "arg0", false, 0, where);
 				args[1] = GetCollectionEntry<int>(c, "arg1", false, 0, where);
 				args[2] = GetCollectionEntry<int>(c, "arg2", false, 0, where);
 				args[3] = GetCollectionEntry<int>(c, "arg3", false, 0, where);
 				args[4] = GetCollectionEntry<int>(c, "arg4", false, 0, where);
 
 				// Flags
 				Dictionary<string, bool> stringflags = new Dictionary<string, bool>();
 				foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 					stringflags[flag.Key] = GetCollectionEntry<bool>(c, flag.Key, false, false, where);
 				foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 					stringflags[flag.Key] = GetCollectionEntry<bool>(c, flag.Key, false, false, where);
 				foreach(FlagTranslation ft in General.Map.Config.ThingFlagsTranslation)
 				{
 					foreach(string field in ft.Fields)
 						stringflags[field] = GetCollectionEntry<bool>(c, field, false, false, where);
 					foreach(string field in ft.Fields)
 						stringflags[field] = GetCollectionEntry<bool>(c, field, false, false, where);
 				}
 				foreach(FlagTranslation ft in General.Map.Config.ThingFlagsTranslation)
 				{
 					foreach(string field in ft.Fields)
 						stringflags[field] = GetCollectionEntry<bool>(c, field, false, false, where);
 				}
 
 				// Create new item
 				Thing t = map.CreateThing();
 				if(t != null)
 				{
 					t.Update(type, x, y, height, angledeg, stringflags, tag, special, args);
 
 					// Custom fields
 					ReadCustomFields(c, t, "thing");
 				}
 			}
 			for(int i = 0; i < collections.Count; i++)
 			{
 				// Read fields
 				UniversalCollection c = collections[i];
 				int[] args = new int[Linedef.NUM_ARGS];
 				string where = "thing " + i;
 				float x = GetCollectionEntry<float>(c, "x", true, 0.0f, where);
 				float y = GetCollectionEntry<float>(c, "y", true, 0.0f, where);
 				float height = GetCollectionEntry<float>(c, "height", false, 0.0f, where);
 				int tag = GetCollectionEntry<int>(c, "id", false, 0, where);
 				int angledeg = GetCollectionEntry<int>(c, "angle", false, 0, where);
 				int type = GetCollectionEntry<int>(c, "type", true, 0, where);
 				int special = GetCollectionEntry<int>(c, "special", false, 0, where);
 				args[0] = GetCollectionEntry<int>(c, "arg0", false, 0, where);
 				args[1] = GetCollectionEntry<int>(c, "arg1", false, 0, where);
 				args[2] = GetCollectionEntry<int>(c, "arg2", false, 0, where);
 				args[3] = GetCollectionEntry<int>(c, "arg3", false, 0, where);
 				args[4] = GetCollectionEntry<int>(c, "arg4", false, 0, where);
 
 				// Flags
 				Dictionary<string, bool> stringflags = new Dictionary<string, bool>();
 				foreach(KeyValuePair<string, string> flag in General.Map.Config.ThingFlags)
 					stringflags[flag.Key] = GetCollectionEntry<bool>(c, flag.Key, false, false, where);
 				foreach(FlagTranslation ft in General.Map.Config.ThingFlagsTranslation)
 				{
 					foreach(string field in ft.Fields)
 						stringflags[field] = GetCollectionEntry<bool>(c, field, false, false, where);
 				}
 
 				// Create new item
 				Thing t = map.CreateThing();
 				if(t != null)
 				{
 					t.Update(type, x, y, height, angledeg, stringflags, tag, special, args);
 
 					// Custom fields
 					ReadCustomFields(c, t, "thing");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="296" endline="329">
<![CDATA[
 
 		// This loads all game configurations
 		private static void LoadAllGameConfigurations()
 		{
 			Configuration cfg;
 			string[] filenames;
 			string name, fullfilename;
 			
 			// Display status
 			mainwindow.DisplayStatus(StatusType.Busy, "Loading game configurations...");
 
 			// Make array
 			configs = new List<ConfigurationInfo>();
 
 			// Go for all cfg files in the configurations directory
 			filenames = Directory.GetFiles(configspath, "*.cfg", SearchOption.TopDirectoryOnly);
 			foreach(string filepath in filenames)
 			{
 				// Check if it can be loaded
 				cfg = LoadGameConfiguration(Path.GetFileName(filepath));
 				if(cfg != null)
 				{
 					fullfilename = Path.GetFileName(filepath);
 					ConfigurationInfo cfginfo = new ConfigurationInfo(cfg, fullfilename);
 					
 					// Add to lists
 					General.WriteLogLine("Registered game configuration '" + cfginfo.Name + "' from '" + fullfilename + "'");
 					configs.Add(cfginfo);
 				}
 			}
 			foreach(string filepath in filenames)
 			{
 				// Check if it can be loaded
 				cfg = LoadGameConfiguration(Path.GetFileName(filepath));
 				if(cfg != null)
 				{
 					fullfilename = Path.GetFileName(filepath);
 					ConfigurationInfo cfginfo = new ConfigurationInfo(cfg, fullfilename);
 					
 					// Add to lists
 					General.WriteLogLine("Registered game configuration '" + cfginfo.Name + "' from '" + fullfilename + "'");
 					configs.Add(cfginfo);
 				}
 			}
 
 			// Sort the list
 			configs.Sort();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="377" endline="422">
<![CDATA[
 
 		// This updates the script font preview label
 		private void UpdateScriptFontPreview()
 		{
 			if((scriptfontname.SelectedIndex > -1) &&
 			   (scriptfontsize.SelectedIndex > -1))
 			{
 				scriptfontlabel.Text = scriptfontname.Text;
 				scriptfontlabel.BackColor = General.Colors.ScriptBackground.ToColor();
 				scriptfontlabel.ForeColor = General.Colors.PlainText.ToColor();
 				FontFamily ff = new FontFamily(scriptfontname.Text);
 				FontStyle style = FontStyle.Regular;
 				if(scriptfontbold.Checked)
 				{
 					// Prefer bold over regular
 					if(ff.IsStyleAvailable(FontStyle.Bold))
 						style = FontStyle.Bold;
 					else if(ff.IsStyleAvailable(FontStyle.Regular))
 						style = FontStyle.Regular;
 					else if(ff.IsStyleAvailable(FontStyle.Italic))
 						style = FontStyle.Italic;
 					else if(ff.IsStyleAvailable(FontStyle.Underline))
 						style = FontStyle.Underline;
 					else if(ff.IsStyleAvailable(FontStyle.Strikeout))
 						style = FontStyle.Strikeout;
 				}
 				else
 				{
 					// Prefer regular over bold
 					if(ff.IsStyleAvailable(FontStyle.Regular))
 						style = FontStyle.Regular;
 					else if(ff.IsStyleAvailable(FontStyle.Bold))
 						style = FontStyle.Bold;
 					else if(ff.IsStyleAvailable(FontStyle.Italic))
 						style = FontStyle.Italic;
 					else if(ff.IsStyleAvailable(FontStyle.Underline))
 						style = FontStyle.Underline;
 					else if(ff.IsStyleAvailable(FontStyle.Strikeout))
 						style = FontStyle.Strikeout;
 				}
 				int fontsize = 8;
 				int.TryParse(scriptfontsize.Text, out fontsize);
 				if(ff.IsStyleAvailable(style))
 					scriptfontlabel.Font = new Font(scriptfontname.Text, (float)fontsize, style);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorControl.cs" startline="439" endline="567">
<![CDATA[
 		
 		
 		// This gathers information about the current caret position
 		private void UpdatePositionInfo()
 		{
 			int bracketlevel = 0;			// bracket level counting
 			int argindex = 0;				// function argument counting
 			int limitpos;					// lowest position we'll backtrack to
 			int pos = scriptedit.CurrentPos;
 			
 			// Decode the text
 			byte[] scripttextdata = scriptedit.GetText(scriptedit.TextSize);
 			Encoding encoder = Encoding.GetEncoding(scriptedit.CodePage);
 			string scripttext = encoder.GetString(scripttextdata);
 			
 			// Reset position info
 			curfunctionname = "";
 			curargumentindex = 0;
 			curfunctionstartpos = 0;
 			
 			// Determine lowest backtrack position
 			limitpos = scriptedit.CurrentPos - MAX_BACKTRACK_LENGTH;
 			if(limitpos < 0) limitpos = 0;
 			
 			// We can only do this when we have function syntax information
 			if((scriptconfig.ArgumentDelimiter.Length == 0) || (scriptconfig.FunctionClose.Length == 0) ||
 			   (scriptconfig.FunctionOpen.Length == 0) || (scriptconfig.Terminator.Length == 0)) return;
 			
 			// Get int versions of the function syntax informantion
 			int argumentdelimiter = scriptconfig.ArgumentDelimiter[0];
 			int functionclose = scriptconfig.FunctionClose[0];
 			int functionopen = scriptconfig.FunctionOpen[0];
 			int terminator = scriptconfig.Terminator[0];
 			
 			// Continue backtracking until we reached the limitpos
 			while(pos >= limitpos)
 			{
 				// Backtrack 1 character
 				pos--;
 				
 				// Get the style and character at this position
 				ScriptStyleType curstyle = GetScriptStyle(scriptedit.StyleAt(pos));
 				int curchar = scriptedit.CharAt(pos);
 				
 				// Then meeting ) then increase bracket level
 				// When meeting ( then decrease bracket level
 				// When bracket level goes -1, then the next word should be the function name
 				// Only when at bracket level 0, count the comma's for argument index
 				
 				// TODO
 				// Original code checked for scope character here and breaks if found
 				
 				// Check if in plain text or keyword
 				if((curstyle == ScriptStyleType.PlainText) || (curstyle == ScriptStyleType.Keyword))
 				{
 					// Closing bracket
 					if(curchar == functionclose)
 					{
 						bracketlevel++;
 					}
 					// Opening bracket
 					else if(curchar == functionopen)
 					{
 						bracketlevel--;
 						
 						// Out of the brackets?
 						if(bracketlevel < 0)
 						{
 							// Skip any whitespace before this bracket
 							do
 							{
 								// Backtrack 1 character
 								curchar = scriptedit.CharAt(--pos);
 							}
 							while((pos >= limitpos) && ((curchar == ' ') || (curchar == '\t') ||
 														(curchar == '\r') || (curchar == '\n')));
 							
 							// NOTE
 							// following calls to false to get any argument delimiter included,
 							// but this may also cause a valid keyword to be combined with other
 							// surrounding characters that do not belong to the keyword.
 							
 							// Find the word before this bracket
 							int wordstart = scriptedit.WordStartPosition(pos, true);
 							int wordend = scriptedit.WordEndPosition(pos, true);
 							string word = scripttext.Substring(wordstart, wordend - wordstart);
 							if(word.Length > 0)
 							{
 								// Check if this is an argument delimiter
 								// I can't remember why I did this, but I'll probably stumble
 								// upon the problem if this doesn't work right (see note above)
 								if(word[0] == argumentdelimiter)
 								{
 									// We are now in the parent function
 									bracketlevel++;
 									argindex = 0;
 								}
 								// Now check if this is a keyword
 								else if(scriptconfig.IsKeyword(word))
 								{
 									// Found it!
 									curfunctionname = scriptconfig.GetKeywordCase(word);
 									curargumentindex = argindex;
 									curfunctionstartpos = wordstart;
 									break;
 								}
 								else
 								{
 									// Don't know this word
 									break;
 								}
 							}
 						}
 					}
 					// Argument delimiter
 					else if(curchar == argumentdelimiter)
 					{
 						// Only count these at brackt level 0
 						if(bracketlevel == 0) argindex++;
 					}
 					// Terminator
 					else if(curchar == terminator)
 					{
 						// Can't find anything, break now
 						break;
 					}
 				}
 			}
 			while(pos >= limitpos)
 			{
 				// Backtrack 1 character
 				pos--;
 				
 				// Get the style and character at this position
 				ScriptStyleType curstyle = GetScriptStyle(scriptedit.StyleAt(pos));
 				int curchar = scriptedit.CharAt(pos);
 				
 				// Then meeting ) then increase bracket level
 				// When meeting ( then decrease bracket level
 				// When bracket level goes -1, then the next word should be the function name
 				// Only when at bracket level 0, count the comma's for argument index
 				
 				// TODO
 				// Original code checked for scope character here and breaks if found
 				
 				// Check if in plain text or keyword
 				if((curstyle == ScriptStyleType.PlainText) || (curstyle == ScriptStyleType.Keyword))
 				{
 					// Closing bracket
 					if(curchar == functionclose)
 					{
 						bracketlevel++;
 					}
 					// Opening bracket
 					else if(curchar == functionopen)
 					{
 						bracketlevel--;
 						
 						// Out of the brackets?
 						if(bracketlevel < 0)
 						{
 							// Skip any whitespace before this bracket
 							do
 							{
 								// Backtrack 1 character
 								curchar = scriptedit.CharAt(--pos);
 							}
 							while((pos >= limitpos) && ((curchar == ' ') || (curchar == '\t') ||
 														(curchar == '\r') || (curchar == '\n')));
 							
 							// NOTE
 							// following calls to false to get any argument delimiter included,
 							// but this may also cause a valid keyword to be combined with other
 							// surrounding characters that do not belong to the keyword.
 							
 							// Find the word before this bracket
 							int wordstart = scriptedit.WordStartPosition(pos, true);
 							int wordend = scriptedit.WordEndPosition(pos, true);
 							string word = scripttext.Substring(wordstart, wordend - wordstart);
 							if(word.Length > 0)
 							{
 								// Check if this is an argument delimiter
 								// I can't remember why I did this, but I'll probably stumble
 								// upon the problem if this doesn't work right (see note above)
 								if(word[0] == argumentdelimiter)
 								{
 									// We are now in the parent function
 									bracketlevel++;
 									argindex = 0;
 								}
 								// Now check if this is a keyword
 								else if(scriptconfig.IsKeyword(word))
 								{
 									// Found it!
 									curfunctionname = scriptconfig.GetKeywordCase(word);
 									curargumentindex = argindex;
 									curfunctionstartpos = wordstart;
 									break;
 								}
 								else
 								{
 									// Don't know this word
 									break;
 								}
 							}
 						}
 					}
 					// Argument delimiter
 					else if(curchar == argumentdelimiter)
 					{
 						// Only count these at brackt level 0
 						if(bracketlevel == 0) argindex++;
 					}
 					// Terminator
 					else if(curchar == terminator)
 					{
 						// Can't find anything, break now
 						break;
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalParser.cs" startline="761" endline="778">
<![CDATA[
 		public bool SaveConfiguration(string filename, string newline, bool whitespace)
 		{
 			// Kill the file if it exists
 			if(File.Exists(filename) == true) File.Delete(filename);
 			
 			// Open file stream for writing
 			FileStream fstream = File.OpenWrite(filename);
 			
 			// Create output structure and write to file
 			string data = OutputConfiguration(newline, whitespace);
 			byte[] baData= Encoding.ASCII.GetBytes(data);
 			fstream.Write(baData, 0, baData.Length);
 			fstream.Flush();
 			fstream.Close();
 			
 			// Return true when done, false when errors occurred
 			if(cpErrorResult == 0) return true; else return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\BlockMap.cs" startline="163" endline="174">
<![CDATA[
 		
 		// This clears the blockmap
 		public virtual void Clear()
 		{
 			for(int x = 0; x < size.Width; x++)
 			{
 				for(int y = 0; y < size.Height; y++)
 				{
 					blockmap[x, y] = new BE();
 				}
 				for(int y = 0; y < size.Height; y++)
 				{
 					blockmap[x, y] = new BE();
 				}
 			}
 			for(int x = 0; x < size.Width; x++)
 			{
 				for(int y = 0; y < size.Height; y++)
 				{
 					blockmap[x, y] = new BE();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1253" endline="1319">
<![CDATA[
 		internal static bool SaveMapAs()
 		{
 			SaveFileDialog savefile;
 			bool result = false;
 
 			if(map == null)
 				return false;
 
 			// Cancel volatile mode, if any
 			General.Editing.DisengageVolatileMode();
 
 			// Show save as dialog
 			savefile = new SaveFileDialog();
 			savefile.Filter = "Doom WAD Files (*.wad)|*.wad";
 			savefile.Title = "Save Map As";
 			savefile.AddExtension = true;
 			savefile.CheckPathExists = true;
 			savefile.OverwritePrompt = true;
 			savefile.ValidateNames = true;
 			if(savefile.ShowDialog(mainwindow) == DialogResult.OK)
 			{
 				// Check if we're saving to the same file as the original.
 				// Because some muppets use Save As even when saving to the same file.
 				string currentfilename = (map.FilePathName.Length > 0) ? Path.GetFullPath(map.FilePathName).ToLowerInvariant() 
 				string savefilename = Path.GetFullPath(savefile.FileName).ToLowerInvariant();
 				if(currentfilename == savefilename)
 				{
 					SaveMap();
 				}
 				else
 				{
 					// Display status
 					mainwindow.DisplayStatus(StatusType.Busy, "Saving map file...");
 					Cursor.Current = Cursors.WaitCursor;
 					
 					// Set this to false so we can see if errors are added
 					General.ErrorLogger.IsErrorAdded = false;
 					
 					// Save the map
 					General.Plugins.OnMapSaveBegin(SavePurpose.AsNewFile);
 					if(map.SaveMap(savefile.FileName, SavePurpose.AsNewFile))
 					{
 						// Add recent file
 						mainwindow.AddRecentFile(map.FilePathName);
 						result = true;
 					}
 					General.Plugins.OnMapSaveEnd(SavePurpose.AsNewFile);
 					
 					// All done
 					mainwindow.UpdateInterface();
 					
 					if(errorlogger.IsErrorAdded)
 					{
 						// Show any errors if preferred
 						mainwindow.DisplayStatus(StatusType.Warning, "There were errors during saving!");
 						if(!delaymainwindow && General.Settings.ShowErrorsWindow) mainwindow.ShowErrors();
 					}
 					else
 						mainwindow.DisplayStatus(StatusType.Info, "Map saved in " + map.FileTitle + ".");
 					
 					Cursor.Current = Cursors.Default;
 				}
 			}
 			
 			savefile.Dispose();
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="945" endline="967">
<![CDATA[
 
 		// This deserializes linedefs
 		private Linedef[] ReadLinedefs(DeserializerStream stream, Vertex[] verticesarray)
 		{
 			int c; stream.rInt(out c);
 
 			Linedef[] array = new Linedef[c];
 
 			// Go for all lines
 			for(int i = 0; i < c; i++)
 			{
 				int start, end;
 				
 				stream.rInt(out start);
 
 				stream.rInt(out end);
 
 				array[i] = CreateLinedef(verticesarray[start], verticesarray[end]);
 				array[i].ReadWrite(stream);
 			}
 			for(int i = 0; i < c; i++)
 			{
 				int start, end;
 				
 				stream.rInt(out start);
 
 				stream.rInt(out end);
 
 				array[i] = CreateLinedef(verticesarray[start], verticesarray[end]);
 				array[i].ReadWrite(stream);
 			}
 
 			return array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2023" endline="2048">
<![CDATA[
 
 		// This returns the trimmed file/path string
 		private string GetDisplayFilename(string filename)
 		{
 			string newname;
 			
 			// String doesnt fit?
 			if(GetStringWidth(filename) > MAX_RECENT_FILES_PIXELS)
 			{
 				// Start chopping off characters
 				for(int i = filename.Length - 6; i >= 0; i--)
 				{
 					// Does it fit now?
 					newname = filename.Substring(0, 3) + "..." + filename.Substring(filename.Length - i, i);
 					if(GetStringWidth(newname) <= MAX_RECENT_FILES_PIXELS) return newname;
 				}
 				for(int i = filename.Length - 6; i >= 0; i--)
 				{
 					// Does it fit now?
 					newname = filename.Substring(0, 3) + "..." + filename.Substring(filename.Length - i, i);
 					if(GetStringWidth(newname) <= MAX_RECENT_FILES_PIXELS) return newname;
 				}
 
 				// Cant find anything that fits (most unlikely!)
 				return "wtf?!";
 			}
 			else
 			{
 				// The whole string fits
 				return filename;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamReader.cs" startline="208" endline="294">
<![CDATA[
 
 		// This reads the linedefs and sidedefs
 		private void ReadLinedefs(MapSet map, UniversalParser textmap,
 			Dictionary<int, Vertex> vertexlink, Dictionary<int, Sector> sectorlink)
 		{
 			// Get list of entries
 			List<UniversalCollection> linescolls = GetNamedCollections(textmap.Root, "linedef");
 			List<UniversalCollection> sidescolls = GetNamedCollections(textmap.Root, "sidedef");
 
 			// Go for all lines
 			map.SetCapacity(0, map.Linedefs.Count + linescolls.Count, map.Sidedefs.Count + sidescolls.Count, 0, 0);
 			for(int i = 0; i < linescolls.Count; i++)
 			{
 				// Read fields
 				UniversalCollection lc = linescolls[i];
 				int[] args = new int[Linedef.NUM_ARGS];
 				string where = "linedef " + i;
 				int tag = GetCollectionEntry<int>(lc, "id", false, 0, where);
 				int v1 = GetCollectionEntry<int>(lc, "v1", true, 0, where);
 				int v2 = GetCollectionEntry<int>(lc, "v2", true, 0, where);
 				int special = GetCollectionEntry<int>(lc, "special", false, 0, where);
 				args[0] = GetCollectionEntry<int>(lc, "arg0", false, 0, where);
 				args[1] = GetCollectionEntry<int>(lc, "arg1", false, 0, where);
 				args[2] = GetCollectionEntry<int>(lc, "arg2", false, 0, where);
 				args[3] = GetCollectionEntry<int>(lc, "arg3", false, 0, where);
 				args[4] = GetCollectionEntry<int>(lc, "arg4", false, 0, where);
 				int s1 = GetCollectionEntry<int>(lc, "sidefront", true, -1, where);
 				int s2 = GetCollectionEntry<int>(lc, "sideback", false, -1, where);
 
 				// Flags
 				Dictionary<string, bool> stringflags = new Dictionary<string, bool>();
 				foreach(KeyValuePair<string, string> flag in General.Map.Config.LinedefFlags)
 					stringflags[flag.Key] = GetCollectionEntry<bool>(lc, flag.Key, false, false, where);
 				foreach(KeyValuePair<string, string> flag in General.Map.Config.LinedefFlags)
 					stringflags[flag.Key] = GetCollectionEntry<bool>(lc, flag.Key, false, false, where);
 				foreach(FlagTranslation ft in General.Map.Config.LinedefFlagsTranslation)
 				{
 					foreach(string field in ft.Fields)
 						stringflags[field] = GetCollectionEntry<bool>(lc, field, false, false, where);
 					foreach(string field in ft.Fields)
 						stringflags[field] = GetCollectionEntry<bool>(lc, field, false, false, where);
 				}
 				foreach(FlagTranslation ft in General.Map.Config.LinedefFlagsTranslation)
 				{
 					foreach(string field in ft.Fields)
 						stringflags[field] = GetCollectionEntry<bool>(lc, field, false, false, where);
 				}
 				
 				// Activations
 				foreach(LinedefActivateInfo activate in General.Map.Config.LinedefActivates)
 					stringflags[activate.Key] = GetCollectionEntry<bool>(lc, activate.Key, false, false, where);
 				foreach(LinedefActivateInfo activate in General.Map.Config.LinedefActivates)
 					stringflags[activate.Key] = GetCollectionEntry<bool>(lc, activate.Key, false, false, where);
 				
 				// Create new linedef
 				if(vertexlink.ContainsKey(v1) && vertexlink.ContainsKey(v2))
 				{
 					// Check if not zero-length
 					if(Vector2D.ManhattanDistance(vertexlink[v1].Position, vertexlink[v2].Position) > 0.0001f)
 					{
 						Linedef l = map.CreateLinedef(vertexlink[v1], vertexlink[v2]);
 						if(l != null)
 						{
 							l.Update(stringflags, 0, tag, special, args);
 							l.UpdateCache();
 
 							// Custom fields
 							ReadCustomFields(lc, l, "linedef");
 
 							// Read sidedefs and connect them to the line
 							if(s1 > -1)
 							{
 								if(s1 < sidescolls.Count)
 									ReadSidedef(map, sidescolls[s1], l, true, sectorlink, s1);
 								else
 									General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references invalid front sidedef " + s1 + ". Sidedef has been removed.");
 							}
 
 							if(s2 > -1)
 							{
 								if(s2 < sidescolls.Count)
 									ReadSidedef(map, sidescolls[s2], l, false, sectorlink, s2);
 								else
 									General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references invalid back sidedef " + s1 + ". Sidedef has been removed.");
 							}
 						}
 					}
 					else
 					{
 						General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " is zero-length. Linedef has been removed.");
 					}
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references one or more invalid vertices. Linedef has been removed.");
 				}
 			}
 			for(int i = 0; i < linescolls.Count; i++)
 			{
 				// Read fields
 				UniversalCollection lc = linescolls[i];
 				int[] args = new int[Linedef.NUM_ARGS];
 				string where = "linedef " + i;
 				int tag = GetCollectionEntry<int>(lc, "id", false, 0, where);
 				int v1 = GetCollectionEntry<int>(lc, "v1", true, 0, where);
 				int v2 = GetCollectionEntry<int>(lc, "v2", true, 0, where);
 				int special = GetCollectionEntry<int>(lc, "special", false, 0, where);
 				args[0] = GetCollectionEntry<int>(lc, "arg0", false, 0, where);
 				args[1] = GetCollectionEntry<int>(lc, "arg1", false, 0, where);
 				args[2] = GetCollectionEntry<int>(lc, "arg2", false, 0, where);
 				args[3] = GetCollectionEntry<int>(lc, "arg3", false, 0, where);
 				args[4] = GetCollectionEntry<int>(lc, "arg4", false, 0, where);
 				int s1 = GetCollectionEntry<int>(lc, "sidefront", true, -1, where);
 				int s2 = GetCollectionEntry<int>(lc, "sideback", false, -1, where);
 
 				// Flags
 				Dictionary<string, bool> stringflags = new Dictionary<string, bool>();
 				foreach(KeyValuePair<string, string> flag in General.Map.Config.LinedefFlags)
 					stringflags[flag.Key] = GetCollectionEntry<bool>(lc, flag.Key, false, false, where);
 				foreach(FlagTranslation ft in General.Map.Config.LinedefFlagsTranslation)
 				{
 					foreach(string field in ft.Fields)
 						stringflags[field] = GetCollectionEntry<bool>(lc, field, false, false, where);
 				}
 				
 				// Activations
 				foreach(LinedefActivateInfo activate in General.Map.Config.LinedefActivates)
 					stringflags[activate.Key] = GetCollectionEntry<bool>(lc, activate.Key, false, false, where);
 				
 				// Create new linedef
 				if(vertexlink.ContainsKey(v1) && vertexlink.ContainsKey(v2))
 				{
 					// Check if not zero-length
 					if(Vector2D.ManhattanDistance(vertexlink[v1].Position, vertexlink[v2].Position) > 0.0001f)
 					{
 						Linedef l = map.CreateLinedef(vertexlink[v1], vertexlink[v2]);
 						if(l != null)
 						{
 							l.Update(stringflags, 0, tag, special, args);
 							l.UpdateCache();
 
 							// Custom fields
 							ReadCustomFields(lc, l, "linedef");
 
 							// Read sidedefs and connect them to the line
 							if(s1 > -1)
 							{
 								if(s1 < sidescolls.Count)
 									ReadSidedef(map, sidescolls[s1], l, true, sectorlink, s1);
 								else
 									General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references invalid front sidedef " + s1 + ". Sidedef has been removed.");
 							}
 
 							if(s2 > -1)
 							{
 								if(s2 < sidescolls.Count)
 									ReadSidedef(map, sidescolls[s2], l, false, sectorlink, s2);
 								else
 									General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references invalid back sidedef " + s1 + ". Sidedef has been removed.");
 							}
 						}
 					}
 					else
 					{
 						General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " is zero-length. Linedef has been removed.");
 					}
 				}
 				else
 				{
 					General.ErrorLogger.Add(ErrorType.Warning, "Linedef " + i + " references one or more invalid vertices. Linedef has been removed.");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\TextLabel.cs" startline="144" endline="263">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 		
 		// This updates the text if needed
 		internal void Update(float translatex, float translatey, float scalex, float scaley)
 		{
 			FlatVertex[] verts;
 			RectangleF absview;
 			float beginx = 0;
 			float beginy = 0;
 			bool colorcode = false;
 			int characters = 0;
 			byte[] textbytes;
 			DataStream stream;
 
 			// Check if transformation changed and needs to be updated
 			if(transformcoords)
 			{
 				if((translatex != lasttranslatex) ||
 				   (translatey != lasttranslatey) ||
 				   (scalex != lastscalex) ||
 				   (scaley != lastscaley)) updateneeded = true;
 			}
 			
 			// Update if needed
 			if(updateneeded)
 			{
 				// Only build when there are any vertices
 				if(text.Length > 0)
 				{
 					// Do we have to make a new buffer?
 					if((textbuffer == null) || (text.Length > capacity))
 					{
 						// Dispose previous
 						if(textbuffer != null) textbuffer.Dispose();
 						
 						// Determine new capacity
 						if(capacity < text.Length) capacity = text.Length;
 						
 						// Create the buffer
 						textbuffer = new VertexBuffer(General.Map.Graphics.Device,
 													  capacity * 12 * FlatVertex.Stride,
 													  Usage.Dynamic | Usage.WriteOnly,
 													  VertexFormat.None, Pool.Default);
 					}
 					
 					// Transform?
 					if(transformcoords)
 					{
 						// Calculate absolute coordinates
 						Vector2D lt = new Vector2D(rect.Left, rect.Top);
 						Vector2D rb = new Vector2D(rect.Right, rect.Bottom);
 						lt = lt.GetTransformed(translatex, translatey, scalex, scaley);
 						rb = rb.GetTransformed(translatex, translatey, scalex, scaley);
 						absview = new RectangleF(lt.x, lt.y, rb.x - lt.x, rb.y - lt.y);
 					}
 					else
 					{
 						// Fixed coordinates
 						absview = rect;
 					}
 					
 					// Calculate text dimensions
 					size = General.Map.Graphics.Font.GetTextSize(text, scale);
 
 					// Align the text horizontally
 					switch(alignx)
 					{
 						case TextAlignmentX.Left
 						case TextAlignmentX.Center
 						case TextAlignmentX.Right
 					}
 
 					// Align the text vertically
 					switch(aligny)
 					{
 						case TextAlignmentY.Top
 						case TextAlignmentY.Middle
 						case TextAlignmentY.Bottom
 					}
 
 					// Get the ASCII bytes for the text
 					textbytes = Encoding.ASCII.GetBytes(text);
 
 					// Lock the buffer
 					stream = textbuffer.Lock(0, capacity * 12 * FlatVertex.Stride,
 									LockFlags.Discard | LockFlags.NoSystemLock);
 					
 					// Go for all chars in text to create the backgrounds
 					float textx = beginx;
 					foreach(byte b in textbytes)
 						General.Map.Graphics.Font.SetupVertices(stream, b, scale, backcolor.ToInt(),
 					foreach(byte b in textbytes)
 						General.Map.Graphics.Font.SetupVertices(stream, b, scale, backcolor.ToInt(),
 															ref textx, beginy, size.Height, 0.5f);
 
 					// Go for all chars in text to create the text
 					textx = beginx;
 					foreach(byte b in textbytes)
 						General.Map.Graphics.Font.SetupVertices(stream, b, scale, color.ToInt(),
 					foreach(byte b in textbytes)
 						General.Map.Graphics.Font.SetupVertices(stream, b, scale, color.ToInt(),
 															ref textx, beginy, size.Height, 0.0f);
 
 					// Done filling the vertex buffer
 					textbuffer.Unlock();
 					stream.Dispose();
 
 					// Calculate number of triangles
 					numfaces = text.Length * 4;
 				}
 				else
 				{
 					// No faces in polygon
 					numfaces = 0;
 					size = new SizeF(0f, 0f);
 				}
 
 				// Text updated
 				updateneeded = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="221" endline="277">
<![CDATA[
 
 		// This binds all methods marked with this attribute
 		private void BindMethods(object obj, Type type)
 		{
 			MethodInfo[] methods;
 			ActionAttribute[] attrs;
 			ActionDelegate del;
 			string actionname;
 
 			if(obj == null)
 				General.WriteLogLine("Binding static action methods for class " + type.Name + "...");
 			else
 				General.WriteLogLine("Binding action methods for " + type.Name + " object...");
 
 			// Go for all methods on obj
 			methods = type.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
 			foreach(MethodInfo m in methods)
 			{
 				// Check if the method has this attribute
 				attrs = (ActionAttribute[])m.GetCustomAttributes(typeof(BeginActionAttribute), true);
 
 				// Go for all attributes
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Bind method to action
 					if(Exists(actionname))
 						actions[actionname].BindBegin(del);
 					else
 						throw new ArgumentException("Could not bind " + m.ReflectedType.Name + "." + m.Name + " to action \"" + actionname + "\", that action does not exist! Refer to, or edit Actions.cfg for all available application actions.");
 				}
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Bind method to action
 					if(Exists(actionname))
 						actions[actionname].BindBegin(del);
 					else
 						throw new ArgumentException("Could not bind " + m.ReflectedType.Name + "." + m.Name + " to action \"" + actionname + "\", that action does not exist! Refer to, or edit Actions.cfg for all available application actions.");
 				}
 				
 				// Check if the method has this attribute
 				attrs = (ActionAttribute[])m.GetCustomAttributes(typeof(EndActionAttribute), true);
 
 				// Go for all attributes
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Bind method to action
 					if(Exists(actionname))
 						actions[actionname].BindEnd(del);
 					else
 						throw new ArgumentException("Could not bind " + m.ReflectedType.Name + "." + m.Name + " to action \"" + actionname + "\", that action does not exist. Refer to, or edit Actions.cfg for all available application actions.");
 				}
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Bind method to action
 					if(Exists(actionname))
 						actions[actionname].BindEnd(del);
 					else
 						throw new ArgumentException("Could not bind " + m.ReflectedType.Name + "." + m.Name + " to action \"" + actionname + "\", that action does not exist. Refer to, or edit Actions.cfg for all available application actions.");
 				}
 			}
 			foreach(MethodInfo m in methods)
 			{
 				// Check if the method has this attribute
 				attrs = (ActionAttribute[])m.GetCustomAttributes(typeof(BeginActionAttribute), true);
 
 				// Go for all attributes
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Bind method to action
 					if(Exists(actionname))
 						actions[actionname].BindBegin(del);
 					else
 						throw new ArgumentException("Could not bind " + m.ReflectedType.Name + "." + m.Name + " to action \"" + actionname + "\", that action does not exist! Refer to, or edit Actions.cfg for all available application actions.");
 				}
 				
 				// Check if the method has this attribute
 				attrs = (ActionAttribute[])m.GetCustomAttributes(typeof(EndActionAttribute), true);
 
 				// Go for all attributes
 				foreach(ActionAttribute a in attrs)
 				{
 					// Create a delegate for this method
 					del = (ActionDelegate)Delegate.CreateDelegate(typeof(ActionDelegate), obj, m);
 
 					// Make proper name
 					actionname = a.GetFullActionName(type.Assembly);
 
 					// Bind method to action
 					if(Exists(actionname))
 						actions[actionname].BindEnd(del);
 					else
 						throw new ArgumentException("Could not bind " + m.ReflectedType.Name + "." + m.Name + " to action \"" + actionname + "\", that action does not exist. Refer to, or edit Actions.cfg for all available application actions.");
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\NumericTextbox.cs" startline="194" endline="235">
<![CDATA[
 		
 		// This determines the result value
 		public int GetResult(int original)
 		{
 			string textpart = this.Text;
 			int result;
 			
 			// Strip prefixes
 			textpart = textpart.Replace("+", "");
 			textpart = textpart.Replace("-", "");
 			
 			// Any numbers left?
 			if(textpart.Length > 0)
 			{
 				// Prefixed with ++?
 				if(this.Text.StartsWith("++"))
 				{
 					// Add number to original
 					if(!int.TryParse(textpart, out result)) result = 0;
 					return original + result;
 				}
 				// Prefixed with --?
 				else if(this.Text.StartsWith("--"))
 				{
 					// Subtract number from original
 					if(!int.TryParse(textpart, out result)) result = 0;
 					int newvalue = original - result;
 					if(!allownegative && (newvalue < 0)) newvalue = 0;
 					return newvalue;
 				}
 				else
 				{
 					// Return the new value
 					return int.TryParse(this.Text, out result) ? result 
 				}
 			}
 			else
 			{
 				// Nothing given, keep original value
 				return original;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\NumericTextbox.cs" startline="236" endline="277">
<![CDATA[
 
 		// This determines the result value
 		public float GetResultFloat(float original)
 		{
 			string textpart = this.Text;
 			float result;
 
 			// Strip prefixes
 			textpart = textpart.Replace("+", "");
 			textpart = textpart.Replace("-", "");
 
 			// Any numbers left?
 			if(textpart.Length > 0)
 			{
 				// Prefixed with ++?
 				if(this.Text.StartsWith("++"))
 				{
 					// Add number to original
 					if(!float.TryParse(textpart, out result)) result = 0;
 					return original + result;
 				}
 				// Prefixed with --?
 				else if(this.Text.StartsWith("--"))
 				{
 					// Subtract number from original
 					if(!float.TryParse(textpart, out result)) result = 0;
 					float newvalue = original - result;
 					if(!allownegative && (newvalue < 0)) newvalue = 0;
 					return newvalue;
 				}
 				else
 				{
 					// Return the new value
 					return float.TryParse(this.Text, out result) ? result 
 				}
 			}
 			else
 			{
 				// Nothing given, keep original value
 				return original;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3Reader.cs" startline="183" endline="212">
<![CDATA[
 
 		#endregion
 
 		#region ================== Sprites
 
 		// This finds and returns a sprite stream
 		public override Stream GetSpriteData(string pname)
 		{
 			string pfilename = pname.Replace('\\', '^');
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find in any of the wad files
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream sprite = wads[i].GetSpriteData(pname);
 				if(sprite != null) return sprite;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				Stream sprite = wads[i].GetSpriteData(pname);
 				if(sprite != null) return sprite;
 			}
 
 			// Find in sprites directory
 			string filename = FindFirstFile(SPRITES_DIR, pfilename, true);
 			if((filename != null) && FileExists(filename))
 			{
 				return LoadFile(filename);
 			}
 
 			// Nothing found
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\BinaryHeap.cs" startline="173" endline="191">
<![CDATA[
 
 		// This removes a specific item from the list
 		// This is an O(n) operation, where n is Count
 		public virtual bool Remove(T item)
 		{
 			// Find the item in the heap
 			int index = IndexOf(item);
 			if(index > -1)
 			{
 				// Remove the item from the heap
 				RemoveAt(index);
 				return true;
 			}
 			else
 			{
 				// No such item
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3StructuredReader.cs" startline="464" endline="515">
<![CDATA[
 		
 		// This must create an image
 		protected abstract ImageData CreateImage(string name, string filename, int imagetype);
 
 		// This must return true if the specified file exists
 		protected abstract bool FileExists(string filename);
 
 		// This must return all files in a given directory
 		protected abstract string[] GetAllFiles(string path, bool subfolders);
 
 		// This must return all files in a given directory that have the given file title
 		protected abstract string[] GetAllFilesWithTitle(string path, string title, bool subfolders);
 
 		// This must return all files in a given directory that match the given extension
 		protected abstract string[] GetFilesWithExt(string path, string extension, bool subfolders);
 
 		// This must find the first file that has the specific name, regardless of file extension
 		protected abstract string FindFirstFile(string beginswith, bool subfolders);
 
 		// This must find the first file that has the specific name, regardless of file extension
 		protected abstract string FindFirstFile(string path, string beginswith, bool subfolders);
 
 		// This must find the first file that has the specific name
 		protected abstract string FindFirstFileWithExt(string path, string beginswith, bool subfolders);
 		
 		// This must load an entire file in memory and returns the stream
 		// NOTE
 		protected abstract MemoryStream LoadFile(string filename);
 
 		// This must create a temp file for the speciied file and return the absolute path to the temp file
 		// NOTE
 		protected abstract string CreateTempFile(string filename);
 
 		// This makes the path relative to the directory, if needed
 		protected virtual string MakeRelativePath(string anypath)
 		{
 			if(Path.IsPathRooted(anypath))
 			{
 				// Make relative
 				string lowpath = anypath.ToLowerInvariant();
 				string lowlocation = location.location.ToLowerInvariant();
 				if((lowpath.Length > (lowlocation.Length + 1)) && lowpath.StartsWith(lowlocation))
 					return anypath.Substring(lowlocation.Length + 1);
 				else
 					return anypath;
 			}
 			else
 			{
 				// Path is already relative
 				return anypath;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="736" endline="757">
<![CDATA[
 
 		// This returns the shortest distance from given coordinates to line
 		public float DistanceToSq(Vector2D p, bool bounded)
 		{
 			Vector2D v1 = start.Position;
 			Vector2D v2 = end.Position;
 			
 			// Calculate intersection offset
 			float u = ((p.x - v1.x) * (v2.x - v1.x) + (p.y - v1.y) * (v2.y - v1.y)) * lengthsqinv;
 
 			// Limit intersection offset to the line
 			if(bounded) if(u < 0f) u = 0f; else if(u > 1f) u = 1f;
 			
 			// Calculate intersection point
 			Vector2D i = v1 + u * (v2 - v1);
 
 			// Return distance between intersection and point
 			// which is the shortest distance to the line
 			float ldx = p.x - i.x;
 			float ldy = p.y - i.y;
 			return ldx * ldx + ldy * ldy;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="2515" endline="2529">
<![CDATA[
 
 		/// <summary>This returns the next unused tag number.</summary>
 		public int GetNewTag()
 		{
 			Dictionary<int, bool> usedtags = new Dictionary<int, bool>();
 			ForAllTags(NewTagHandler, false, usedtags);
 			ForAllTags(NewTagHandler, true, usedtags);
 			
 			// Now find the first unused index
 			for(int i = 1; i <= General.Map.FormatInterface.MaxTag; i++)
 				if(!usedtags.ContainsKey(i)) return i;
 			for(int i = 1; i <= General.Map.FormatInterface.MaxTag; i++)
 				if(!usedtags.ContainsKey(i)) return i;
 			
 			// All tags used!
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1478" endline="1513">
<![CDATA[
 
 		// This calculates the bits needed for a number
 		public static int BitsForInt(int v)
 		{
 			int[] LOGTABLE = new int[] {
 			  0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
 			  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 			  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 			  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 			  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 			  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 			  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 			  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 			  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 			  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 			  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 			  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 			  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 			  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 			  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 			  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 };
 			
 			int r;	// r will be lg(v)
 			int t, tt;
 
 			if(Int2Bool(tt = v >> 16))
 			{
 				r = Int2Bool(t = tt >> 8) ? 24 + LOGTABLE[t] 
 			}
 			else
 			{
 				r = Int2Bool(t = v >> 8) ? 8 + LOGTABLE[t] 
 			}
 			
 			return r;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\FileImageReader.cs" startline="406" endline="453">
<![CDATA[
 
 		// This draws the picture to the given pixel color data
 		// Throws exception on failure
 		public void DrawToPixelData(Stream stream, PixelColor* target, int targetwidth, int targetheight, int x, int y)
 		{
 			Bitmap bmp;
 			BitmapData bmpdata;
 			PixelColor* pixels;
 			int ox, oy, tx, ty;
 			int width, height;
 			
 			// Get bitmap
 			bmp = ReadAsBitmap(stream);
 			if(bmp != null)
 			{
 				width = bmp.Size.Width;
 				height = bmp.Size.Height;
 
 				// Lock bitmap pixels
 				bmpdata = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
 				pixels = (PixelColor*)bmpdata.Scan0.ToPointer();
 
 				// Go for all pixels in the original image
 				for(ox = 0; ox < width; ox++)
 				{
 					for(oy = 0; oy < height; oy++)
 					{
 						// Copy this pixel?
 						if(pixels[oy * width + ox].a > 0.5f)
 						{
 							// Calculate target pixel and copy when within bounds
 							tx = x + ox;
 							ty = y + oy;
 							if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 								target[ty * targetwidth + tx] = pixels[oy * width + ox];
 						}
 					}
 					for(oy = 0; oy < height; oy++)
 					{
 						// Copy this pixel?
 						if(pixels[oy * width + ox].a > 0.5f)
 						{
 							// Calculate target pixel and copy when within bounds
 							tx = x + ox;
 							ty = y + oy;
 							if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 								target[ty * targetwidth + tx] = pixels[oy * width + ox];
 						}
 					}
 				}
 				for(ox = 0; ox < width; ox++)
 				{
 					for(oy = 0; oy < height; oy++)
 					{
 						// Copy this pixel?
 						if(pixels[oy * width + ox].a > 0.5f)
 						{
 							// Calculate target pixel and copy when within bounds
 							tx = x + ox;
 							ty = y + oy;
 							if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 								target[ty * targetwidth + tx] = pixels[oy * width + ox];
 						}
 					}
 				}
 
 				// Done
 				bmp.UnlockBits(bmpdata);
 				bmp.Dispose();
 			}
 			else
 			{
 				throw new InvalidDataException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ErrorsForm.cs" startline="95" endline="104">
<![CDATA[
 
 		// Checking for more errors
 		private void checkerrors_Tick(object sender, EventArgs e)
 		{
 			// If errors have been added, update the list
 			if(General.ErrorLogger.HasChanged)
 			{
 				FillList();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="690" endline="699">
<![CDATA[
 
 		// This applies defaults to a sector
 		private static void ApplyDefaultsToSector(Sector s)
 		{
 			s.SetFloorTexture(General.Settings.DefaultFloorTexture);
 			s.SetCeilTexture(General.Settings.DefaultCeilingTexture);
 			s.FloorHeight = General.Settings.DefaultFloorHeight;
 			s.CeilHeight = General.Settings.DefaultCeilingHeight;
 			s.Brightness = General.Settings.DefaultBrightness;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="42" endline="173">
<![CDATA[
 		private bool allowapplycontrol = false;
 		private bool disregardshift = false;
 		private bool disregardcontrol = false;
 
 		private bool reloadresources = false;
 		private System.ComponentModel.IContainer components = null;
 		public PreferencesForm()
 		{
 			Actions.Action[] actions;
 			ListViewItem item;
 			
 			// Initialize
 			InitializeComponent();
 			
 			// Interface
 			imagebrightness.Value = General.Settings.ImageBrightness;
 			squarethings.Checked = General.Settings.SquareThings;
 			doublesidedalpha.Value = (int)((1.0f - General.Settings.DoubleSidedAlpha) * 10.0f);
 			defaultviewmode.SelectedIndex = General.Settings.DefaultViewMode;
 			fieldofview.Value = General.Settings.VisualFOV / 10;
 			mousespeed.Value = General.Settings.MouseSpeed / 100;
 			movespeed.Value = General.Settings.MoveSpeed / 100;
 			viewdistance.Value = General.Clamp((int)(General.Settings.ViewDistance / 200.0f), viewdistance.Minimum, viewdistance.Maximum);
 			invertyaxis.Checked = General.Settings.InvertYAxis;
 			scriptfontbold.Checked = General.Settings.ScriptFontBold;
 			scriptontop.Checked = General.Settings.ScriptOnTop;
 			scripttabwidth.Text = General.Settings.ScriptTabWidth.ToString();
 			scriptautoindent.Checked = General.Settings.ScriptAutoIndent;
 			previewsize.Value = General.Settings.PreviewImageSize;
 			autoscrollspeed.Value = General.Settings.AutoScrollSpeed;
 			zoomfactor.Value = General.Settings.ZoomFactor;
 			animatevisualselection.Checked = General.Settings.AnimateVisualSelection;
 			dockersposition.SelectedIndex = General.Settings.DockersPosition;
 			collapsedockers.Checked = General.Settings.CollapseDockers;
 			toolbar_file.Checked = General.Settings.ToolbarFile;
 			toolbar_script.Checked = General.Settings.ToolbarScript;
 			toolbar_undo.Checked = General.Settings.ToolbarUndo;
 			toolbar_copy.Checked = General.Settings.ToolbarCopy;
 			toolbar_prefabs.Checked = General.Settings.ToolbarPrefabs;
 			toolbar_filter.Checked = General.Settings.ToolbarFilter;
 			toolbar_viewmodes.Checked = General.Settings.ToolbarViewModes;
 			toolbar_geometry.Checked = General.Settings.ToolbarGeometry;
 			toolbar_testing.Checked = General.Settings.ToolbarTesting;
 			showtexturesizes.Checked = General.Settings.ShowTextureSizes;
 			
 			// Fill fonts list
 			scriptfontname.BeginUpdate();
 			foreach(FontFamily ff in System.Drawing.FontFamily.Families)
 				scriptfontname.Items.Add(ff.Name);
 			foreach(FontFamily ff in System.Drawing.FontFamily.Families)
 				scriptfontname.Items.Add(ff.Name);
 			scriptfontname.EndUpdate();
 			
 			// Select script font name
 			for(int i = 0; i < scriptfontname.Items.Count; i++)
 			{
 				if(string.Compare(scriptfontname.Items[i].ToString(), General.Settings.ScriptFontName, true) == 0)
 					scriptfontname.SelectedIndex = i;
 			}
 			for(int i = 0; i < scriptfontname.Items.Count; i++)
 			{
 				if(string.Compare(scriptfontname.Items[i].ToString(), General.Settings.ScriptFontName, true) == 0)
 					scriptfontname.SelectedIndex = i;
 			}
 
 			// Select script font size
 			for(int i = 0; i < scriptfontsize.Items.Count; i++)
 			{
 				if(string.Compare(scriptfontsize.Items[i].ToString(), General.Settings.ScriptFontSize.ToString(CultureInfo.InvariantCulture), true) == 0)
 					scriptfontsize.SelectedIndex = i;
 			}
 			for(int i = 0; i < scriptfontsize.Items.Count; i++)
 			{
 				if(string.Compare(scriptfontsize.Items[i].ToString(), General.Settings.ScriptFontSize.ToString(CultureInfo.InvariantCulture), true) == 0)
 					scriptfontsize.SelectedIndex = i;
 			}
 			
 			// Fill actions list with categories
 			foreach(KeyValuePair<string, string> c in General.Actions.Categories)
 				listactions.Groups.Add(c.Key, c.Value);
 			foreach(KeyValuePair<string, string> c in General.Actions.Categories)
 				listactions.Groups.Add(c.Key, c.Value);
 			
 			// Fill list of actions
 			actions = General.Actions.GetAllActions();
 			foreach(Actions.Action a in actions)
 			{
 				// Create item
 				item = listactions.Items.Add(a.Name, a.Title, 0);
 				item.SubItems.Add(Actions.Action.GetShortcutKeyDesc(a.ShortcutKey));
 				item.SubItems[1].Tag = a.ShortcutKey;
 
 				// Put in category, if the category exists
 				if(General.Actions.Categories.ContainsKey(a.Category))
 					item.Group = listactions.Groups[a.Category];
 			}
 			foreach(Actions.Action a in actions)
 			{
 				// Create item
 				item = listactions.Items.Add(a.Name, a.Title, 0);
 				item.SubItems.Add(Actions.Action.GetShortcutKeyDesc(a.ShortcutKey));
 				item.SubItems[1].Tag = a.ShortcutKey;
 
 				// Put in category, if the category exists
 				if(General.Actions.Categories.ContainsKey(a.Category))
 					item.Group = listactions.Groups[a.Category];
 			}
 
 			// Set the colors
 			// TODO
 			colorbackcolor.Color = General.Colors.Background;
 			colorvertices.Color = General.Colors.Vertices;
 			colorlinedefs.Color = General.Colors.Linedefs;
 			colorspeciallinedefs.Color = General.Colors.Actions;
 			colorsoundlinedefs.Color = General.Colors.Sounds;
 			colorhighlight.Color = General.Colors.Highlight;
 			colorselection.Color = General.Colors.Selection;
 			colorindication.Color = General.Colors.Indication;
 			colorgrid.Color = General.Colors.Grid;
 			colorgrid64.Color = General.Colors.Grid64;
 			colorscriptbackground.Color = General.Colors.ScriptBackground;
 			colorlinenumbers.Color = General.Colors.LineNumbers;
 			colorplaintext.Color = General.Colors.PlainText;
 			colorcomments.Color = General.Colors.Comments;
 			colorkeywords.Color = General.Colors.Keywords;
 			colorliterals.Color = General.Colors.Literals;
 			colorconstants.Color = General.Colors.Constants;
 			blackbrowsers.Checked = General.Settings.BlackBrowsers;
 			classicbilinear.Checked = General.Settings.ClassicBilinear;
 			visualbilinear.Checked = General.Settings.VisualBilinear;
 			qualitydisplay.Checked = General.Settings.QualityDisplay;
 			
 			// Paste options
 			pasteoptions.Setup(General.Settings.PasteOptions.Copy());
 
 			// Allow plugins to add tabs
 			this.SuspendLayout();
 			controller = new PreferencesController(this);
 			controller.AllowAddTab = true;
 			General.Plugins.OnShowPreferences(controller);
 			controller.AllowAddTab = false;
 			this.ResumeLayout(true);
 			
 			// Done
 			allowapplycontrol = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\StepsList.cs" startline="54" endline="73">
<![CDATA[
 		
 		// This returns a step lower
 		public int GetNextLower(int level)
 		{
 			int low = 0;
 			int high = base.Count - 1;
 
 			while(low < high)
 			{
 				int mid = (int)Math.Ceiling((float)(low + high) * 0.5f);
 				int l = base[mid];
 
 				if(l >= level)
 					high = mid - 1;
 				else
 					low = mid;
 			}
 			while(low < high)
 			{
 				int mid = (int)Math.Ceiling((float)(low + high) * 0.5f);
 				int l = base[mid];
 
 				if(l >= level)
 					high = mid - 1;
 				else
 					low = mid;
 			}
 
 			return base[low];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Actions\ActionManager.cs" startline="530" endline="543">
<![CDATA[
 
 		// This notifies a key has been released
 		// Returns true when the key release has been absorbed
 		internal bool KeyReleased(int key)
 		{
 			int strippedkey = key & ~((int)Keys.Alt | (int)Keys.Shift | (int)Keys.Control);
 			List<Action> keepactions = new List<Action>();
 			
 			// Update pressed keys
 			if(pressedkeys.Contains(strippedkey)) pressedkeys.Remove(strippedkey);
 
 			// End actions that no longer match
 			return EndActiveActions();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\FlatQuad.cs" startline="118" endline="129">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This sets the color on all vertices
 		public void SetColors(int color)
 		{
 			// Go for all vertices to set the color
 			for(int i = 0; i < numvertices; i++)
 				vertices[i].c = color;
 			for(int i = 0; i < numvertices; i++)
 				vertices[i].c = color;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="330" endline="339">
<![CDATA[
 
 		// This finds a lump by name, returns null when not found
 		public Lump FindLump(string name, int start)
 		{
 			int index = FindLumpIndex(name, start);
 			if(index == -1)
 				return null;
 			else
 				return lumps[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Lump.cs" startline="139" endline="156">
<![CDATA[
 
 		// This makes the fixed name from normal name
 		public static byte[] MakeFixedName(string name, Encoding encoding)
 		{
 			// Make uppercase name and count bytes
 			string uppername = name.Trim().ToUpper();
 			int bytes = encoding.GetByteCount(uppername);
 			if(bytes < 8) bytes = 8;
 			
 			// Make 8 bytes, all zeros
 			byte[] fixedname = new byte[bytes];
 
 			// Write the name in bytes
 			encoding.GetBytes(uppername, 0, uppername.Length, fixedname, 0);
 
 			// Return result
 			return fixedname;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageDataFormat.cs" startline="109" endline="127">
<![CDATA[
 
 		// This checks a signature as byte array
 		// NOTE
 		// signature, and expects the stream to be long enough.
 		private static bool CheckSignature(Stream data, int[] sig)
 		{
 			int b;
 			
 			// Go for all bytes
 			for(int i = 0; i < sig.Length; i++)
 			{
 				// When byte doesnt match the signature, leave
 				b = data.ReadByte();
 				if(b != sig[i]) return false;
 			}
 			for(int i = 0; i < sig.Length; i++)
 			{
 				// When byte doesnt match the signature, leave
 				b = data.ReadByte();
 				if(b != sig[i]) return false;
 			}
 
 			// Signature matches
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="700" endline="826">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Sector Labels
 		
 		// This finds the ideal label positions for a sector
 		public static List<LabelPositionInfo> FindLabelPositions(Sector s)
 		{
 			List<LabelPositionInfo> positions = new List<LabelPositionInfo>(2);
 			int islandoffset = 0;
 			
 			// Do we have a triangulation?
 			Triangulation triangles = s.Triangles;
 			if(triangles != null)
 			{
 				// Go for all islands
 				for(int i = 0; i < triangles.IslandVertices.Count; i++)
 				{
 					Dictionary<Sidedef, Linedef> sides = new Dictionary<Sidedef, Linedef>(triangles.IslandVertices[i] >> 1);
 					List<Vector2D> candidatepositions = new List<Vector2D>(triangles.IslandVertices[i] >> 1);
 					float founddistance = float.MinValue;
 					Vector2D foundposition = new Vector2D();
 					float minx = float.MaxValue;
 					float miny = float.MaxValue;
 					float maxx = float.MinValue;
 					float maxy = float.MinValue;
 					
 					// Make candidate lines that are not along sidedefs
 					// We do this before testing the candidate against the sidedefs so that
 					// we can collect the relevant sidedefs first in the same run
 					for(int t = 0; t < triangles.IslandVertices[i]; t += 3)
 					{
 						int triangleoffset = islandoffset + t;
 						Vector2D v1 = triangles.Vertices[triangleoffset + 2];
 						Sidedef sd = triangles.Sidedefs[triangleoffset + 2];
 						for(int v = 0; v < 3; v++)
 						{
 							Vector2D v2 = triangles.Vertices[triangleoffset + v];
 							
 							// Not along a sidedef? Then this line is across the sector
 							// and guaranteed to be inside the sector!
 							if(sd == null)
 							{
 								// Make the line
 								candidatepositions.Add(v1 + (v2 - v1) * 0.5f);
 							}
 							else
 							{
 								// This sidedefs is part of this island and must be checked
 								// so add it to the dictionary
 								sides[sd] = sd.Line;
 							}
 							
 							// Make bbox of this island
 							minx = Math.Min(minx, v1.x);
 							miny = Math.Min(miny, v1.y);
 							maxx = Math.Max(maxx, v1.x);
 							maxy = Math.Max(maxy, v1.y);
 							
 							// Next
 							sd = triangles.Sidedefs[triangleoffset + v];
 							v1 = v2;
 						}
 						for(int v = 0; v < 3; v++)
 						{
 							Vector2D v2 = triangles.Vertices[triangleoffset + v];
 							
 							// Not along a sidedef? Then this line is across the sector
 							// and guaranteed to be inside the sector!
 							if(sd == null)
 							{
 								// Make the line
 								candidatepositions.Add(v1 + (v2 - v1) * 0.5f);
 							}
 							else
 							{
 								// This sidedefs is part of this island and must be checked
 								// so add it to the dictionary
 								sides[sd] = sd.Line;
 							}
 							
 							// Make bbox of this island
 							minx = Math.Min(minx, v1.x);
 							miny = Math.Min(miny, v1.y);
 							maxx = Math.Max(maxx, v1.x);
 							maxy = Math.Max(maxy, v1.y);
 							
 							// Next
 							sd = triangles.Sidedefs[triangleoffset + v];
 							v1 = v2;
 						}
 					}
 					for(int t = 0; t < triangles.IslandVertices[i]; t += 3)
 					{
 						int triangleoffset = islandoffset + t;
 						Vector2D v1 = triangles.Vertices[triangleoffset + 2];
 						Sidedef sd = triangles.Sidedefs[triangleoffset + 2];
 						for(int v = 0; v < 3; v++)
 						{
 							Vector2D v2 = triangles.Vertices[triangleoffset + v];
 							
 							// Not along a sidedef? Then this line is across the sector
 							// and guaranteed to be inside the sector!
 							if(sd == null)
 							{
 								// Make the line
 								candidatepositions.Add(v1 + (v2 - v1) * 0.5f);
 							}
 							else
 							{
 								// This sidedefs is part of this island and must be checked
 								// so add it to the dictionary
 								sides[sd] = sd.Line;
 							}
 							
 							// Make bbox of this island
 							minx = Math.Min(minx, v1.x);
 							miny = Math.Min(miny, v1.y);
 							maxx = Math.Max(maxx, v1.x);
 							maxy = Math.Max(maxy, v1.y);
 							
 							// Next
 							sd = triangles.Sidedefs[triangleoffset + v];
 							v1 = v2;
 						}
 					}
 
 					// Any candidate lines found at all?
 					if(candidatepositions.Count > 0)
 					{
 						// Start with the first line
 						foreach(Vector2D candidatepos in candidatepositions)
 						{
 							// Check distance against other lines
 							float smallestdist = int.MaxValue;
 							foreach(KeyValuePair<Sidedef, Linedef> sd in sides)
 							{
 								// Check the distance
 								float distance = sd.Value.DistanceToSq(candidatepos, true);
 								smallestdist = Math.Min(smallestdist, distance);
 							}
 							foreach(KeyValuePair<Sidedef, Linedef> sd in sides)
 							{
 								// Check the distance
 								float distance = sd.Value.DistanceToSq(candidatepos, true);
 								smallestdist = Math.Min(smallestdist, distance);
 							}
 							
 							// Keep this candidate if it is better than previous
 							if(smallestdist > founddistance)
 							{
 								foundposition = candidatepos;
 								founddistance = smallestdist;
 							}
 						}
 						foreach(Vector2D candidatepos in candidatepositions)
 						{
 							// Check distance against other lines
 							float smallestdist = int.MaxValue;
 							foreach(KeyValuePair<Sidedef, Linedef> sd in sides)
 							{
 								// Check the distance
 								float distance = sd.Value.DistanceToSq(candidatepos, true);
 								smallestdist = Math.Min(smallestdist, distance);
 							}
 							
 							// Keep this candidate if it is better than previous
 							if(smallestdist > founddistance)
 							{
 								foundposition = candidatepos;
 								founddistance = smallestdist;
 							}
 						}
 						
 						// No cceptable line found, just use the first!
 						positions.Add(new LabelPositionInfo(foundposition, (float)Math.Sqrt(founddistance)));
 					}
 					else
 					{
 						// No candidate lines found.
 						
 						// Check to see if the island is a triangle
 						if(triangles.IslandVertices[i] == 3)
 						{
 							// Use the center of the triangle
 							// TODO
 							Vector2D v = (triangles.Vertices[islandoffset] + triangles.Vertices[islandoffset + 1] + triangles.Vertices[islandoffset + 2]) / 3.0f;
 							float d = Line2D.GetDistanceToLineSq(triangles.Vertices[islandoffset], triangles.Vertices[islandoffset + 1], v, false);
 							d = Math.Min(d, Line2D.GetDistanceToLineSq(triangles.Vertices[islandoffset + 1], triangles.Vertices[islandoffset + 2], v, false));
 							d = Math.Min(d, Line2D.GetDistanceToLineSq(triangles.Vertices[islandoffset + 2], triangles.Vertices[islandoffset], v, false));
 							positions.Add(new LabelPositionInfo(v, (float)Math.Sqrt(d)));
 						}
 						else
 						{
 							// Use the center of this island.
 							float d = Math.Min((maxx - minx) * 0.5f, (maxy - miny) * 0.5f);
 							positions.Add(new LabelPositionInfo(new Vector2D(minx + (maxx - minx) * 0.5f, miny + (maxy - miny) * 0.5f), d));
 						}
 					}
 					
 					// Done with this island
 					islandoffset += triangles.IslandVertices[i];
 				}
 				for(int i = 0; i < triangles.IslandVertices.Count; i++)
 				{
 					Dictionary<Sidedef, Linedef> sides = new Dictionary<Sidedef, Linedef>(triangles.IslandVertices[i] >> 1);
 					List<Vector2D> candidatepositions = new List<Vector2D>(triangles.IslandVertices[i] >> 1);
 					float founddistance = float.MinValue;
 					Vector2D foundposition = new Vector2D();
 					float minx = float.MaxValue;
 					float miny = float.MaxValue;
 					float maxx = float.MinValue;
 					float maxy = float.MinValue;
 					
 					// Make candidate lines that are not along sidedefs
 					// We do this before testing the candidate against the sidedefs so that
 					// we can collect the relevant sidedefs first in the same run
 					for(int t = 0; t < triangles.IslandVertices[i]; t += 3)
 					{
 						int triangleoffset = islandoffset + t;
 						Vector2D v1 = triangles.Vertices[triangleoffset + 2];
 						Sidedef sd = triangles.Sidedefs[triangleoffset + 2];
 						for(int v = 0; v < 3; v++)
 						{
 							Vector2D v2 = triangles.Vertices[triangleoffset + v];
 							
 							// Not along a sidedef? Then this line is across the sector
 							// and guaranteed to be inside the sector!
 							if(sd == null)
 							{
 								// Make the line
 								candidatepositions.Add(v1 + (v2 - v1) * 0.5f);
 							}
 							else
 							{
 								// This sidedefs is part of this island and must be checked
 								// so add it to the dictionary
 								sides[sd] = sd.Line;
 							}
 							
 							// Make bbox of this island
 							minx = Math.Min(minx, v1.x);
 							miny = Math.Min(miny, v1.y);
 							maxx = Math.Max(maxx, v1.x);
 							maxy = Math.Max(maxy, v1.y);
 							
 							// Next
 							sd = triangles.Sidedefs[triangleoffset + v];
 							v1 = v2;
 						}
 					}
 
 					// Any candidate lines found at all?
 					if(candidatepositions.Count > 0)
 					{
 						// Start with the first line
 						foreach(Vector2D candidatepos in candidatepositions)
 						{
 							// Check distance against other lines
 							float smallestdist = int.MaxValue;
 							foreach(KeyValuePair<Sidedef, Linedef> sd in sides)
 							{
 								// Check the distance
 								float distance = sd.Value.DistanceToSq(candidatepos, true);
 								smallestdist = Math.Min(smallestdist, distance);
 							}
 							
 							// Keep this candidate if it is better than previous
 							if(smallestdist > founddistance)
 							{
 								foundposition = candidatepos;
 								founddistance = smallestdist;
 							}
 						}
 						
 						// No cceptable line found, just use the first!
 						positions.Add(new LabelPositionInfo(foundposition, (float)Math.Sqrt(founddistance)));
 					}
 					else
 					{
 						// No candidate lines found.
 						
 						// Check to see if the island is a triangle
 						if(triangles.IslandVertices[i] == 3)
 						{
 							// Use the center of the triangle
 							// TODO
 							Vector2D v = (triangles.Vertices[islandoffset] + triangles.Vertices[islandoffset + 1] + triangles.Vertices[islandoffset + 2]) / 3.0f;
 							float d = Line2D.GetDistanceToLineSq(triangles.Vertices[islandoffset], triangles.Vertices[islandoffset + 1], v, false);
 							d = Math.Min(d, Line2D.GetDistanceToLineSq(triangles.Vertices[islandoffset + 1], triangles.Vertices[islandoffset + 2], v, false));
 							d = Math.Min(d, Line2D.GetDistanceToLineSq(triangles.Vertices[islandoffset + 2], triangles.Vertices[islandoffset], v, false));
 							positions.Add(new LabelPositionInfo(v, (float)Math.Sqrt(d)));
 						}
 						else
 						{
 							// Use the center of this island.
 							float d = Math.Min((maxx - minx) * 0.5f, (maxy - miny) * 0.5f);
 							positions.Add(new LabelPositionInfo(new Vector2D(minx + (maxx - minx) * 0.5f, miny + (maxy - miny) * 0.5f), d));
 						}
 					}
 					
 					// Done with this island
 					islandoffset += triangles.IslandVertices[i];
 				}
 			}
 			else
 			{
 				// No triangulation was made. FAIL!
 				General.Fail("No triangulation exists for sector " + s + " Triangulation is required to create label positions for a sector.");
 			}
 			
 			// Done
 			return positions;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualBlockMap.cs" startline="190" endline="272">
<![CDATA[
 
 		// This returns all blocks along the given line
 		public List<VisualBlockEntry> GetLineBlocks(Vector2D v1, Vector2D v2)
 		{
 			float deltax, deltay;
 			float posx, posy;
 			Point pos, end;
 			int dirx, diry;
 			
 			// Estimate number of blocks we will go through and create list
 			int entriescount = (int)(Vector2D.ManhattanDistance(v1, v2) * 2.0f) / BLOCK_SIZE;
 			List<VisualBlockEntry> entries = new List<VisualBlockEntry>(entriescount);
 
 			// Find start and end block
 			pos = GetBlockCoordinates(v1);
 			end = GetBlockCoordinates(v2);
 
 			// Add this block
 			entries.Add(GetBlock(pos));
 
 			// Moving outside the block?
 			if(pos != end)
 			{
 				// Calculate current block edges
 				float cl = pos.X * BLOCK_SIZE;
 				float cr = (pos.X + 1) * BLOCK_SIZE;
 				float ct = pos.Y * BLOCK_SIZE;
 				float cb = (pos.Y + 1) * BLOCK_SIZE;
 
 				// Line directions
 				dirx = Math.Sign(v2.x - v1.x);
 				diry = Math.Sign(v2.y - v1.y);
 
 				// Calculate offset and delta movement over x
 				if(dirx >= 0)
 				{
 					posx = (cr - v1.x) / (v2.x - v1.x);
 					deltax = BLOCK_SIZE / (v2.x - v1.x);
 				}
 				else
 				{
 					// Calculate offset and delta movement over x
 					posx = (v1.x - cl) / (v1.x - v2.x);
 					deltax = BLOCK_SIZE / (v1.x - v2.x);
 				}
 
 				// Calculate offset and delta movement over y
 				if(diry >= 0)
 				{
 					posy = (cb - v1.y) / (v2.y - v1.y);
 					deltay = BLOCK_SIZE / (v2.y - v1.y);
 				}
 				else
 				{
 					posy = (v1.y - ct) / (v1.y - v2.y);
 					deltay = BLOCK_SIZE / (v1.y - v2.y);
 				}
 
 				// Continue while not reached the end
 				while(pos != end)
 				{
 					// Check in which direction to move
 					if(posx < posy)
 					{
 						// Move horizontally
 						posx += deltax;
 						if(pos.X != end.X) pos.X += dirx;
 					}
 					else
 					{
 						// Move vertically
 						posy += deltay;
 						if(pos.Y != end.Y) pos.Y += diry;
 					}
 
 					// Add lines to this block
 					entries.Add(GetBlock(pos));
 				}
 				while(pos != end)
 				{
 					// Check in which direction to move
 					if(posx < posy)
 					{
 						// Move horizontally
 						posx += deltax;
 						if(pos.X != end.X) pos.X += dirx;
 					}
 					else
 					{
 						// Move vertically
 						posy += deltay;
 						if(pos.Y != end.Y) pos.Y += diry;
 					}
 
 					// Add lines to this block
 					entries.Add(GetBlock(pos));
 				}
 			}
 
 			// Return list
 			return entries;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="825" endline="891">
<![CDATA[
 		
 		
 		// This includes another file
 		private void FunctionInclude(IDictionary cs, ArrayList args, ref string file, int line)
 		{
 			string data;
 			
 			if(string.IsNullOrEmpty(file)) RaiseError(file, line, ERROR_INCLUDE_UNSUPPORTED);
 			if(args.Count < 1) RaiseError(file, line, ERROR_INVALID_ARGS);
 			if(!(args[0] is string)) RaiseError(file, line, ERROR_INVALID_ARGS + " Expected a string for argument 1.");
 			if((args.Count > 1) && !(args[1] is string)) RaiseError(file, line, ERROR_INVALID_ARGS + " Expected a string for argument 2.");
 			if(cpErrorResult) return;
 			
 			// Determine the full path of the file to include
 			string includefile = Path.GetDirectoryName(file) + Path.DirectorySeparatorChar + args[0].ToString();
 			
 			try
 			{
 				// Load the file contents
 				FileStream fstream = File.OpenRead(includefile);
 				byte[] fbuffer = new byte[fstream.Length];
 				fstream.Read(fbuffer, 0, fbuffer.Length);
 				fstream.Close();
 				
 				// Convert byte array to string
 				data = Encoding.UTF8.GetString(fbuffer);
 			}
 			catch(Exception e)
 			{
 				RaiseError(file, line, "Unable to include file '" + includefile + "'. " + e.GetType().Name + "
 				return;
 			}
 			
 			// Remove returns and tabs because the
 			// parser only uses newline for new lines.
 			data = data.Replace("\r", "");
 			data = data.Replace("\t", "");
 			
 			// Parse the data
 			IDictionary inc;
 			if(cs is ListDictionary) inc = new ListDictionary(); else inc = new Hashtable();
 			int npos = 0, nline = 1;
 			InputStructure(inc, ref includefile, ref data, ref npos, ref nline);
 			if(!cpErrorResult)
 			{
 				// Check if a path is given
 				if((args.Count > 1) && !string.IsNullOrEmpty(args[1].ToString()))
 				{
 					IDictionary def;
 					if(cs is ListDictionary) def = new ListDictionary(); else def = new Hashtable();
 					if(CheckSetting(inc, args[1].ToString(), DEFAULT_SEPERATOR))
 					{
 						inc = (IDictionary)ReadAnySetting(inc, file, line, args[1].ToString(), def, DEFAULT_SEPERATOR);
 					}
 					else
 					{
 						RaiseError(file, line, "Include missing structure '" + args[1].ToString() + "' in file '" + includefile + "'");
 						return;
 					}
 				}
 				
 				// Recursively merge the structures with the current structure
 				IDictionary newcs = Combine(cs, inc, (cs is ListDictionary));
 				cs.Clear();
 				foreach(DictionaryEntry de in newcs) cs.Add(de.Key, de.Value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\GridSetupForm.Designer.cs" startline="22" endline="285">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.GroupBox groupBox1;
 			System.Windows.Forms.Label label1;
 			System.Windows.Forms.GroupBox groupBox2;
 			this.gridsize = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.backscaley = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.backscalex = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.backoffsety = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.backoffsetx = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.backscale = new System.Windows.Forms.Label();
 			this.selectfile = new System.Windows.Forms.Button();
 			this.showbackground = new System.Windows.Forms.CheckBox();
 			this.backoffset = new System.Windows.Forms.Label();
 			this.selectflat = new System.Windows.Forms.Button();
 			this.selecttexture = new System.Windows.Forms.Button();
 			this.backgroundimage = new System.Windows.Forms.Panel();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.browsefile = new System.Windows.Forms.OpenFileDialog();
 			groupBox1 = new System.Windows.Forms.GroupBox();
 			label1 = new System.Windows.Forms.Label();
 			groupBox2 = new System.Windows.Forms.GroupBox();
 			groupBox1.SuspendLayout();
 			groupBox2.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// groupBox1
 			// 
 			groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			groupBox1.Controls.Add(this.gridsize);
 			groupBox1.Controls.Add(label1);
 			groupBox1.Location = new System.Drawing.Point(12, 12);
 			groupBox1.Name = "groupBox1";
 			groupBox1.Size = new System.Drawing.Size(293, 71);
 			groupBox1.TabIndex = 0;
 			groupBox1.TabStop = false;
 			groupBox1.Text = " Grid ";
 			// 
 			// gridsize
 			// 
 			this.gridsize.AllowNegative = false;
 			this.gridsize.AllowRelative = true;
 			this.gridsize.ButtonStep = 8;
 			this.gridsize.Location = new System.Drawing.Point(146, 26);
 			this.gridsize.Name = "gridsize";
 			this.gridsize.Size = new System.Drawing.Size(75, 24);
 			this.gridsize.TabIndex = 1;
 			// 
 			// label1
 			// 
 			label1.AutoSize = true;
 			label1.Location = new System.Drawing.Point(25, 31);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(115, 14);
 			label1.TabIndex = 0;
 			label1.Text = "Grid size in mappixels
 			// 
 			// groupBox2
 			// 
 			groupBox2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			groupBox2.Controls.Add(this.backscaley);
 			groupBox2.Controls.Add(this.backscalex);
 			groupBox2.Controls.Add(this.backoffsety);
 			groupBox2.Controls.Add(this.backoffsetx);
 			groupBox2.Controls.Add(this.backscale);
 			groupBox2.Controls.Add(this.selectfile);
 			groupBox2.Controls.Add(this.showbackground);
 			groupBox2.Controls.Add(this.backoffset);
 			groupBox2.Controls.Add(this.selectflat);
 			groupBox2.Controls.Add(this.selecttexture);
 			groupBox2.Controls.Add(this.backgroundimage);
 			groupBox2.Location = new System.Drawing.Point(12, 89);
 			groupBox2.Name = "groupBox2";
 			groupBox2.Size = new System.Drawing.Size(293, 261);
 			groupBox2.TabIndex = 1;
 			groupBox2.TabStop = false;
 			groupBox2.Text = " Background ";
 			// 
 			// backscaley
 			// 
 			this.backscaley.AllowNegative = false;
 			this.backscaley.AllowRelative = true;
 			this.backscaley.ButtonStep = 1;
 			this.backscaley.Enabled = false;
 			this.backscaley.Location = new System.Drawing.Point(197, 212);
 			this.backscaley.Name = "backscaley";
 			this.backscaley.Size = new System.Drawing.Size(67, 24);
 			this.backscaley.TabIndex = 13;
 			// 
 			// backscalex
 			// 
 			this.backscalex.AllowNegative = false;
 			this.backscalex.AllowRelative = true;
 			this.backscalex.ButtonStep = 1;
 			this.backscalex.Enabled = false;
 			this.backscalex.Location = new System.Drawing.Point(124, 212);
 			this.backscalex.Name = "backscalex";
 			this.backscalex.Size = new System.Drawing.Size(67, 24);
 			this.backscalex.TabIndex = 12;
 			// 
 			// backoffsety
 			// 
 			this.backoffsety.AllowNegative = true;
 			this.backoffsety.AllowRelative = true;
 			this.backoffsety.ButtonStep = 1;
 			this.backoffsety.Enabled = false;
 			this.backoffsety.Location = new System.Drawing.Point(197, 173);
 			this.backoffsety.Name = "backoffsety";
 			this.backoffsety.Size = new System.Drawing.Size(67, 24);
 			this.backoffsety.TabIndex = 11;
 			// 
 			// backoffsetx
 			// 
 			this.backoffsetx.AllowNegative = true;
 			this.backoffsetx.AllowRelative = true;
 			this.backoffsetx.ButtonStep = 1;
 			this.backoffsetx.Enabled = false;
 			this.backoffsetx.Location = new System.Drawing.Point(124, 173);
 			this.backoffsetx.Name = "backoffsetx";
 			this.backoffsetx.Size = new System.Drawing.Size(67, 24);
 			this.backoffsetx.TabIndex = 10;
 			// 
 			// backscale
 			// 
 			this.backscale.AutoSize = true;
 			this.backscale.Enabled = false;
 			this.backscale.Location = new System.Drawing.Point(30, 217);
 			this.backscale.Name = "backscale";
 			this.backscale.Size = new System.Drawing.Size(88, 14);
 			this.backscale.TabIndex = 9;
 			this.backscale.Text = "Scale in percent
 			// 
 			// selectfile
 			// 
 			this.selectfile.Enabled = false;
 			this.selectfile.Location = new System.Drawing.Point(147, 122);
 			this.selectfile.Name = "selectfile";
 			this.selectfile.Size = new System.Drawing.Size(117, 25);
 			this.selectfile.TabIndex = 3;
 			this.selectfile.Text = "Select File...";
 			this.selectfile.UseVisualStyleBackColor = true;
 			this.selectfile.Click += new System.EventHandler(this.selectfile_Click);
 			// 
 			// showbackground
 			// 
 			this.showbackground.AutoSize = true;
 			this.showbackground.Location = new System.Drawing.Point(28, 29);
 			this.showbackground.Name = "showbackground";
 			this.showbackground.Size = new System.Drawing.Size(146, 18);
 			this.showbackground.TabIndex = 0;
 			this.showbackground.Text = "Show background image";
 			this.showbackground.UseVisualStyleBackColor = true;
 			this.showbackground.CheckedChanged += new System.EventHandler(this.showbackground_CheckedChanged);
 			// 
 			// backoffset
 			// 
 			this.backoffset.AutoSize = true;
 			this.backoffset.Enabled = false;
 			this.backoffset.Location = new System.Drawing.Point(15, 178);
 			this.backoffset.Name = "backoffset";
 			this.backoffset.Size = new System.Drawing.Size(103, 14);
 			this.backoffset.TabIndex = 4;
 			this.backoffset.Text = "Offset in mappixels
 			// 
 			// selectflat
 			// 
 			this.selectflat.Enabled = false;
 			this.selectflat.Location = new System.Drawing.Point(147, 91);
 			this.selectflat.Name = "selectflat";
 			this.selectflat.Size = new System.Drawing.Size(117, 25);
 			this.selectflat.TabIndex = 2;
 			this.selectflat.Text = "Select Flat...";
 			this.selectflat.UseVisualStyleBackColor = true;
 			this.selectflat.Click += new System.EventHandler(this.selectflat_Click);
 			// 
 			// selecttexture
 			// 
 			this.selecttexture.Enabled = false;
 			this.selecttexture.Location = new System.Drawing.Point(147, 60);
 			this.selecttexture.Name = "selecttexture";
 			this.selecttexture.Size = new System.Drawing.Size(117, 25);
 			this.selecttexture.TabIndex = 1;
 			this.selecttexture.Text = "Select Texture...";
 			this.selecttexture.UseVisualStyleBackColor = true;
 			this.selecttexture.Click += new System.EventHandler(this.selecttexture_Click);
 			// 
 			// backgroundimage
 			// 
 			this.backgroundimage.BackColor = System.Drawing.SystemColors.AppWorkspace;
 			this.backgroundimage.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Zoom;
 			this.backgroundimage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.backgroundimage.Location = new System.Drawing.Point(28, 60);
 			this.backgroundimage.Name = "backgroundimage";
 			this.backgroundimage.Size = new System.Drawing.Size(91, 87);
 			this.backgroundimage.TabIndex = 1;
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(193, 368);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 3;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(75, 368);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 2;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// browsefile
 			// 
 			this.browsefile.Filter = "All supported images|*.bmp;*.gif;*.png|All Files|*.*";
 			this.browsefile.RestoreDirectory = true;
 			this.browsefile.Title = "Select Background Image File";
 			// 
 			// GridSetupForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(317, 403);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(groupBox2);
 			this.Controls.Add(groupBox1);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "GridSetupForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Custom Grid Setup";
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.GridSetupForm_HelpRequested);
 			groupBox1.ResumeLayout(false);
 			groupBox1.PerformLayout();
 			groupBox2.ResumeLayout(false);
 			groupBox2.PerformLayout();
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="1865" endline="1875">
<![CDATA[
 
 		// This returns the cohen-sutherland field bits for a vertex in a rectangle area
 		private static int GetCSFieldBits(Vertex v, ref RectangleF area)
 		{
 			int bits = 0;
 			if(v.Position.y < area.Top) bits |= 0x01;
 			if(v.Position.y > area.Bottom) bits |= 0x02;
 			if(v.Position.x < area.Left) bits |= 0x04;
 			if(v.Position.x > area.Right) bits |= 0x08;
 			return bits;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataLocationList.cs" startline="87" endline="111">
<![CDATA[
 
 		// This writes the list to configuration
 		internal void WriteToConfig(Configuration cfg, string path)
 		{
 			IDictionary resinfo, rlinfo;
 			
 			// Fill structure
 			resinfo = new ListDictionary();
 			for(int i = 0; i < this.Count; i++)
 			{
 				// Create structure for resource
 				rlinfo = new ListDictionary();
 				rlinfo.Add("type", this[i].type);
 				rlinfo.Add("location", this[i].location);
 				rlinfo.Add("option1", General.Bool2Int(this[i].option1));
 				rlinfo.Add("option2", General.Bool2Int(this[i].option2));
 				rlinfo.Add("notfortesting", General.Bool2Int(this[i].notfortesting));
 
 				// Add structure
 				resinfo.Add("resource" + i.ToString(CultureInfo.InvariantCulture), rlinfo);
 			}
 			for(int i = 0; i < this.Count; i++)
 			{
 				// Create structure for resource
 				rlinfo = new ListDictionary();
 				rlinfo.Add("type", this[i].type);
 				rlinfo.Add("location", this[i].location);
 				rlinfo.Add("option1", General.Bool2Int(this[i].option1));
 				rlinfo.Add("option2", General.Bool2Int(this[i].option2));
 				rlinfo.Add("notfortesting", General.Bool2Int(this[i].notfortesting));
 
 				// Add structure
 				resinfo.Add("resource" + i.ToString(CultureInfo.InvariantCulture), rlinfo);
 			}
 			
 			// Write to config
 			cfg.WriteSetting(path, resinfo);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingBrowserControl.Designer.cs" startline="22" endline="196">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			System.Windows.Forms.TreeNode treeNode1 = new System.Windows.Forms.TreeNode("Monsters");
 			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ThingBrowserControl));
 			this.sizecaption = new System.Windows.Forms.Label();
 			this.blockingcaption = new System.Windows.Forms.Label();
 			this.positioncaption = new System.Windows.Forms.Label();
 			this.typecaption = new System.Windows.Forms.Label();
 			this.sizelabel = new System.Windows.Forms.Label();
 			this.blockinglabel = new System.Windows.Forms.Label();
 			this.positionlabel = new System.Windows.Forms.Label();
 			this.typelist = new System.Windows.Forms.TreeView();
 			this.thingimages = new System.Windows.Forms.ImageList(this.components);
 			this.infopanel = new System.Windows.Forms.Panel();
 			this.typeid = new CodeImp.DoomBuilder.Controls.NumericTextbox();
 			this.infopanel.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// sizecaption
 			// 
 			this.sizecaption.AutoSize = true;
 			this.sizecaption.Location = new System.Drawing.Point(166, 13);
 			this.sizecaption.Name = "sizecaption";
 			this.sizecaption.Size = new System.Drawing.Size(30, 13);
 			this.sizecaption.TabIndex = 16;
 			this.sizecaption.Text = "Size
 			// 
 			// blockingcaption
 			// 
 			this.blockingcaption.AutoSize = true;
 			this.blockingcaption.Location = new System.Drawing.Point(145, 42);
 			this.blockingcaption.Name = "blockingcaption";
 			this.blockingcaption.Size = new System.Drawing.Size(51, 13);
 			this.blockingcaption.TabIndex = 14;
 			this.blockingcaption.Text = "Blocking
 			// 
 			// positioncaption
 			// 
 			this.positioncaption.AutoSize = true;
 			this.positioncaption.Location = new System.Drawing.Point(-2, 42);
 			this.positioncaption.Name = "positioncaption";
 			this.positioncaption.Size = new System.Drawing.Size(47, 13);
 			this.positioncaption.TabIndex = 12;
 			this.positioncaption.Text = "Position
 			// 
 			// typecaption
 			// 
 			this.typecaption.AutoSize = true;
 			this.typecaption.Location = new System.Drawing.Point(-2, 13);
 			this.typecaption.Name = "typecaption";
 			this.typecaption.Size = new System.Drawing.Size(34, 13);
 			this.typecaption.TabIndex = 10;
 			this.typecaption.Text = "Type
 			// 
 			// sizelabel
 			// 
 			this.sizelabel.AutoSize = true;
 			this.sizelabel.Location = new System.Drawing.Point(200, 13);
 			this.sizelabel.Name = "sizelabel";
 			this.sizelabel.Size = new System.Drawing.Size(42, 13);
 			this.sizelabel.TabIndex = 17;
 			this.sizelabel.Text = "16 x 96";
 			// 
 			// blockinglabel
 			// 
 			this.blockinglabel.AutoSize = true;
 			this.blockinglabel.Location = new System.Drawing.Point(198, 42);
 			this.blockinglabel.Name = "blockinglabel";
 			this.blockinglabel.Size = new System.Drawing.Size(63, 13);
 			this.blockinglabel.TabIndex = 15;
 			this.blockinglabel.Text = "True-Height";
 			// 
 			// positionlabel
 			// 
 			this.positionlabel.AutoSize = true;
 			this.positionlabel.Location = new System.Drawing.Point(48, 42);
 			this.positionlabel.Name = "positionlabel";
 			this.positionlabel.Size = new System.Drawing.Size(38, 13);
 			this.positionlabel.TabIndex = 13;
 			this.positionlabel.Text = "Ceiling";
 			// 
 			// typelist
 			// 
 			this.typelist.HideSelection = false;
 			this.typelist.ImageIndex = 0;
 			this.typelist.ImageList = this.thingimages;
 			this.typelist.Location = new System.Drawing.Point(0, 0);
 			this.typelist.Margin = new System.Windows.Forms.Padding(8, 8, 9, 8);
 			this.typelist.Name = "typelist";
 			treeNode1.Name = "Node0";
 			treeNode1.Text = "Monsters";
 			this.typelist.Nodes.AddRange(new System.Windows.Forms.TreeNode[] {
             treeNode1});
 			this.typelist.SelectedImageIndex = 0;
 			this.typelist.Size = new System.Drawing.Size(304, 261);
 			this.typelist.TabIndex = 0;
 			this.typelist.DoubleClick += new System.EventHandler(this.typelist_DoubleClick);
 			this.typelist.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.typelist_AfterSelect);
 			// 
 			// thingimages
 			// 
 			this.thingimages.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("thingimages.ImageStream")));
 			this.thingimages.TransparentColor = System.Drawing.SystemColors.Window;
 			this.thingimages.Images.SetKeyName(0, "thing00.png");
 			this.thingimages.Images.SetKeyName(1, "thing01.png");
 			this.thingimages.Images.SetKeyName(2, "thing02.png");
 			this.thingimages.Images.SetKeyName(3, "thing03.png");
 			this.thingimages.Images.SetKeyName(4, "thing04.png");
 			this.thingimages.Images.SetKeyName(5, "thing05.png");
 			this.thingimages.Images.SetKeyName(6, "thing06.png");
 			this.thingimages.Images.SetKeyName(7, "thing07.png");
 			this.thingimages.Images.SetKeyName(8, "thing08.png");
 			this.thingimages.Images.SetKeyName(9, "thing09.png");
 			this.thingimages.Images.SetKeyName(10, "thing10.png");
 			this.thingimages.Images.SetKeyName(11, "thing11.png");
 			this.thingimages.Images.SetKeyName(12, "thing12.png");
 			this.thingimages.Images.SetKeyName(13, "thing13.png");
 			this.thingimages.Images.SetKeyName(14, "thing14.png");
 			this.thingimages.Images.SetKeyName(15, "thing15.png");
 			this.thingimages.Images.SetKeyName(16, "thing16.png");
 			this.thingimages.Images.SetKeyName(17, "thing17.png");
 			this.thingimages.Images.SetKeyName(18, "thing18.png");
 			this.thingimages.Images.SetKeyName(19, "thing19.png");
 			// 
 			// infopanel
 			// 
 			this.infopanel.Controls.Add(this.sizelabel);
 			this.infopanel.Controls.Add(this.typecaption);
 			this.infopanel.Controls.Add(this.sizecaption);
 			this.infopanel.Controls.Add(this.typeid);
 			this.infopanel.Controls.Add(this.blockinglabel);
 			this.infopanel.Controls.Add(this.positioncaption);
 			this.infopanel.Controls.Add(this.blockingcaption);
 			this.infopanel.Controls.Add(this.positionlabel);
 			this.infopanel.Location = new System.Drawing.Point(0, 261);
 			this.infopanel.Name = "infopanel";
 			this.infopanel.Size = new System.Drawing.Size(304, 59);
 			this.infopanel.TabIndex = 18;
 			// 
 			// typeid
 			// 
 			this.typeid.AllowDecimal = false;
 			this.typeid.AllowNegative = false;
 			this.typeid.AllowRelative = false;
 			this.typeid.ImeMode = System.Windows.Forms.ImeMode.Off;
 			this.typeid.Location = new System.Drawing.Point(41, 10);
 			this.typeid.Name = "typeid";
 			this.typeid.Size = new System.Drawing.Size(68, 20);
 			this.typeid.TabIndex = 1;
 			this.typeid.TextChanged += new System.EventHandler(this.typeid_TextChanged);
 			// 
 			// ThingBrowserControl
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.typelist);
 			this.Controls.Add(this.infopanel);
 			this.Name = "ThingBrowserControl";
 			this.Size = new System.Drawing.Size(304, 320);
 			this.Layout += new System.Windows.Forms.LayoutEventHandler(this.ThingBrowserControl_Layout);
 			this.Resize += new System.EventHandler(this.ThingBrowserControl_Resize);
 			this.SizeChanged += new System.EventHandler(this.ThingBrowserControl_SizeChanged);
 			this.infopanel.ResumeLayout(false);
 			this.infopanel.PerformLayout();
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.cs" startline="148" endline="158">
<![CDATA[
 		
 		// This applies user preferences
 		public void ApplySettings()
 		{
 			// Apply settings
 			//int panel2size = General.Settings.ReadSetting("scriptspanel.splitter", splitter.ClientRectangle.Height - splitter.SplitterDistance);
 			//splitter.SplitterDistance = splitter.ClientRectangle.Height - panel2size;
 			errorlist.Columns[0].Width = General.Settings.ReadSetting("scriptspanel.errorscolumn0width", errorlist.Columns[0].Width);
 			errorlist.Columns[1].Width = General.Settings.ReadSetting("scriptspanel.errorscolumn1width", errorlist.Columns[1].Width);
 			errorlist.Columns[2].Width = General.Settings.ReadSetting("scriptspanel.errorscolumn2width", errorlist.Columns[2].Width);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\Launcher.cs" startline="86" endline="224">
<![CDATA[
 
 		#endregion
 
 		#region ================== Parameters
 
 		// This takes the unconverted parameters (with placeholders) and converts it
 		// to parameters with full paths, names and numbers where placeholders were put.
 		// The tempfile must be the full path and filename to the PWAD file to test.
 		public string ConvertParameters(string parameters, int skill, bool shortpaths)
 		{
 			string outp = parameters;
 			DataLocation iwadloc;
 			string p_wp = "", p_wf = "";
 			string p_ap = "", p_apq = "";
 			string p_l1 = "", p_l2 = "";
 			string p_nm = "";
 			string f = tempwad;
 			
 			// Make short path if needed
 			if(shortpaths) f = General.GetShortFilePath(f);
 			
 			// Find the first IWAD file
 			if(General.Map.Data.FindFirstIWAD(out iwadloc))
 			{
 				// %WP and %WF result in IWAD file
 				p_wp = iwadloc.location;
 				p_wf = Path.GetFileName(p_wp);
 				if(shortpaths)
 				{
 					p_wp = General.GetShortFilePath(p_wp);
 					p_wf = General.GetShortFilePath(p_wf);
 				}
 			}
 			
 			// Make a list of all data locations, including map location
 			DataLocation maplocation = new DataLocation(DataLocation.RESOURCE_WAD, General.Map.FilePathName, false, false, false);
 			DataLocationList locations = new DataLocationList();
 			locations.AddRange(General.Map.ConfigSettings.Resources);
 			locations.AddRange(General.Map.Options.Resources);
 			locations.Add(maplocation);
 			
 			// Go for all data locations
 			foreach(DataLocation dl in locations)
 			{
 				// Location not the IWAD file?
 				if((dl.type != DataLocation.RESOURCE_WAD) || (dl.location != iwadloc.location))
 				{
 					// Location not included?
 					if(!dl.notfortesting)
 					{
 						// Add to string of files
 						if(shortpaths)
 						{
 							p_ap += General.GetShortFilePath(dl.location) + " ";
 							p_apq += "\"" + General.GetShortFilePath(dl.location) + "\" ";
 						}
 						else
 						{
 							p_ap += dl.location + " ";
 							p_apq += "\"" + dl.location + "\" ";
 						}
 					}
 				}
 			}
 			foreach(DataLocation dl in locations)
 			{
 				// Location not the IWAD file?
 				if((dl.type != DataLocation.RESOURCE_WAD) || (dl.location != iwadloc.location))
 				{
 					// Location not included?
 					if(!dl.notfortesting)
 					{
 						// Add to string of files
 						if(shortpaths)
 						{
 							p_ap += General.GetShortFilePath(dl.location) + " ";
 							p_apq += "\"" + General.GetShortFilePath(dl.location) + "\" ";
 						}
 						else
 						{
 							p_ap += dl.location + " ";
 							p_apq += "\"" + dl.location + "\" ";
 						}
 					}
 				}
 			}
 
 			// Trim last space from resource file locations
 			p_ap = p_ap.TrimEnd(' ');
 			p_apq = p_apq.TrimEnd(' ');
 
 			// Try finding the L1 and L2 numbers from the map name
 			string numstr = "";
 			bool first = true;
 			foreach(char c in General.Map.Options.CurrentName)
 			{
 				// Character is a number?
 				if(NUMBERS.IndexOf(c) > -1)
 				{
 					// Include it
 					numstr += c;
 				}
 				else
 				{
 					// Store the number if we found one
 					if(numstr.Length > 0)
 					{
 						int num = 0;
 						int.TryParse(numstr, out num);
 						if(first) p_l1 = num.ToString(); else p_l2 = num.ToString();
 						numstr = "";
 						first = false;
 					}
 				}
 			}
 			foreach(char c in General.Map.Options.CurrentName)
 			{
 				// Character is a number?
 				if(NUMBERS.IndexOf(c) > -1)
 				{
 					// Include it
 					numstr += c;
 				}
 				else
 				{
 					// Store the number if we found one
 					if(numstr.Length > 0)
 					{
 						int num = 0;
 						int.TryParse(numstr, out num);
 						if(first) p_l1 = num.ToString(); else p_l2 = num.ToString();
 						numstr = "";
 						first = false;
 					}
 				}
 			}
 			
 			// Store the number if we found one
 			if(numstr.Length > 0)
 			{
 				int num = 0;
 				int.TryParse(numstr, out num);
 				if(first) p_l1 = num.ToString(); else p_l2 = num.ToString();
 			}
 
 			// No monsters?
 			if(!General.Settings.TestMonsters) p_nm = "-nomonsters";
 			
 			// Make sure all our placeholders are in uppercase
 			outp = outp.Replace("%f", "%F");
 			outp = outp.Replace("%wp", "%WP");
 			outp = outp.Replace("%wf", "%WF");
 			outp = outp.Replace("%wP", "%WP");
 			outp = outp.Replace("%wF", "%WF");
 			outp = outp.Replace("%Wp", "%WP");
 			outp = outp.Replace("%Wf", "%WF");
 			outp = outp.Replace("%l1", "%L1");
 			outp = outp.Replace("%l2", "%L2");
 			outp = outp.Replace("%l", "%L");
 			outp = outp.Replace("%ap", "%AP");
 			outp = outp.Replace("%aP", "%AP");
 			outp = outp.Replace("%Ap", "%AP");
 			outp = outp.Replace("%s", "%S");
 			outp = outp.Replace("%nM", "%NM");
 			outp = outp.Replace("%Nm", "%NM");
 			outp = outp.Replace("%nm", "%NM");
 			
 			// Replace placeholders with actual values
 			outp = outp.Replace("%F", f);
 			outp = outp.Replace("%WP", p_wp);
 			outp = outp.Replace("%WF", p_wf);
 			outp = outp.Replace("%L1", p_l1);
 			outp = outp.Replace("%L2", p_l2);
 			outp = outp.Replace("%L", General.Map.Options.CurrentName);
 			outp = outp.Replace("\"%AP\"", p_apq);
 			outp = outp.Replace("%AP", p_ap);
 			outp = outp.Replace("%S", skill.ToString());
 			outp = outp.Replace("%NM", p_nm);
 			
 			// Return result
 			return outp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomPictureReader.cs" startline="56" endline="98">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 		
 		// This validates the data as doom picture
 		public bool Validate(Stream stream)
 		{
 			BinaryReader reader = new BinaryReader(stream);
 			int width, height;
 			int dataoffset;
 			int datalength;
 			int columnaddr;
 			
 			// Initialize
 			dataoffset = (int)stream.Position;
 			datalength = (int)stream.Length - (int)stream.Position;
 
 			// Need at least 4 bytes
 			if(datalength < 4) return false;
 
 			// Read size and offset
 			width = reader.ReadInt16();
 			height = reader.ReadInt16();
 			reader.ReadInt16();
 			reader.ReadInt16();
 
 			// Valid width and height?
 			if((width <= 0) || (height <= 0)) return false;
 			
 			// Go for all columns
 			for(int x = 0; x < width; x++)
 			{
 				// Get column address
 				columnaddr = reader.ReadInt32();
 				
 				// Check if address is outside valid range
 				if((columnaddr < (8 + width * 4)) || (columnaddr >= datalength)) return false;
 			}
 			for(int x = 0; x < width; x++)
 			{
 				// Get column address
 				columnaddr = reader.ReadInt32();
 				
 				// Check if address is outside valid range
 				if((columnaddr < (8 + width * 4)) || (columnaddr >= datalength)) return false;
 			}
 
 			// Return success
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UnknownImageReader.cs" startline="71" endline="111">
<![CDATA[
 
 		// This draws the picture to the given pixel color data
 		// Throws exception on failure
 		public unsafe void DrawToPixelData(Stream stream, PixelColor* target, int targetwidth, int targetheight, int x, int y)
 		{
 			Bitmap bmp;
 			BitmapData bmpdata;
 			PixelColor* pixels;
 			int ox, oy, tx, ty;
 			int width, height;
 
 			// Get bitmap
 			bmp = ReadAsBitmap(stream);
 			width = bmp.Size.Width;
 			height = bmp.Size.Height;
 
 			// Lock bitmap pixels
 			bmpdata = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
 			pixels = (PixelColor*)bmpdata.Scan0.ToPointer();
 
 			// Go for all pixels in the original image
 			for(ox = 0; ox < width; ox++)
 			{
 				for(oy = 0; oy < height; oy++)
 				{
 					// Copy this pixel?
 					if(pixels[oy * width + ox].a > 0.5f)
 					{
 						// Calculate target pixel and copy when within bounds
 						tx = x + ox;
 						ty = y + oy;
 						if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 							target[ty * targetwidth + tx] = pixels[oy * width + ox];
 					}
 				}
 				for(oy = 0; oy < height; oy++)
 				{
 					// Copy this pixel?
 					if(pixels[oy * width + ox].a > 0.5f)
 					{
 						// Calculate target pixel and copy when within bounds
 						tx = x + ox;
 						ty = y + oy;
 						if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 							target[ty * targetwidth + tx] = pixels[oy * width + ox];
 					}
 				}
 			}
 			for(ox = 0; ox < width; ox++)
 			{
 				for(oy = 0; oy < height; oy++)
 				{
 					// Copy this pixel?
 					if(pixels[oy * width + ox].a > 0.5f)
 					{
 						// Calculate target pixel and copy when within bounds
 						tx = x + ox;
 						ty = y + oy;
 						if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 							target[ty * targetwidth + tx] = pixels[oy * width + ox];
 					}
 				}
 			}
 
 			// Done
 			bmp.UnlockBits(bmpdata);
 			bmp.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomColormapReader.cs" startline="130" endline="170">
<![CDATA[
 
 		// This draws the picture to the given pixel color data
 		// Throws exception on failure
 		public unsafe void DrawToPixelData(Stream stream, PixelColor* target, int targetwidth, int targetheight, int x, int y)
 		{
 			Bitmap bmp;
 			BitmapData bmpdata;
 			PixelColor* pixels;
 			int ox, oy, tx, ty;
 			int width, height;
 
 			// Get bitmap
 			bmp = ReadAsBitmap(stream);
 			width = bmp.Size.Width;
 			height = bmp.Size.Height;
 
 			// Lock bitmap pixels
 			bmpdata = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
 			pixels = (PixelColor*)bmpdata.Scan0.ToPointer();
 
 			// Go for all pixels in the original image
 			for(ox = 0; ox < width; ox++)
 			{
 				for(oy = 0; oy < height; oy++)
 				{
 					// Copy this pixel?
 					if(pixels[oy * width + ox].a > 0.5f)
 					{
 						// Calculate target pixel and copy when within bounds
 						tx = x + ox;
 						ty = y + oy;
 						if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 							target[ty * targetwidth + tx] = pixels[oy * width + ox];
 					}
 				}
 				for(oy = 0; oy < height; oy++)
 				{
 					// Copy this pixel?
 					if(pixels[oy * width + ox].a > 0.5f)
 					{
 						// Calculate target pixel and copy when within bounds
 						tx = x + ox;
 						ty = y + oy;
 						if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 							target[ty * targetwidth + tx] = pixels[oy * width + ox];
 					}
 				}
 			}
 			for(ox = 0; ox < width; ox++)
 			{
 				for(oy = 0; oy < height; oy++)
 				{
 					// Copy this pixel?
 					if(pixels[oy * width + ox].a > 0.5f)
 					{
 						// Calculate target pixel and copy when within bounds
 						tx = x + ox;
 						ty = y + oy;
 						if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 							target[ty * targetwidth + tx] = pixels[oy * width + ox];
 					}
 				}
 			}
 
 			// Done
 			bmp.UnlockBits(bmpdata);
 			bmp.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomFlatReader.cs" startline="136" endline="176">
<![CDATA[
 
 		// This draws the picture to the given pixel color data
 		// Throws exception on failure
 		public unsafe void DrawToPixelData(Stream stream, PixelColor* target, int targetwidth, int targetheight, int x, int y)
 		{
 			Bitmap bmp;
 			BitmapData bmpdata;
 			PixelColor* pixels;
 			int ox, oy, tx, ty;
 			int width, height;
 
 			// Get bitmap
 			bmp = ReadAsBitmap(stream);
 			width = bmp.Size.Width;
 			height = bmp.Size.Height;
 
 			// Lock bitmap pixels
 			bmpdata = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
 			pixels = (PixelColor*)bmpdata.Scan0.ToPointer();
 
 			// Go for all pixels in the original image
 			for(ox = 0; ox < width; ox++)
 			{
 				for(oy = 0; oy < height; oy++)
 				{
 					// Copy this pixel?
 					if(pixels[oy * width + ox].a > 0.5f)
 					{
 						// Calculate target pixel and copy when within bounds
 						tx = x + ox;
 						ty = y + oy;
 						if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 							target[ty * targetwidth + tx] = pixels[oy * width + ox];
 					}
 				}
 				for(oy = 0; oy < height; oy++)
 				{
 					// Copy this pixel?
 					if(pixels[oy * width + ox].a > 0.5f)
 					{
 						// Calculate target pixel and copy when within bounds
 						tx = x + ox;
 						ty = y + oy;
 						if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 							target[ty * targetwidth + tx] = pixels[oy * width + ox];
 					}
 				}
 			}
 			for(ox = 0; ox < width; ox++)
 			{
 				for(oy = 0; oy < height; oy++)
 				{
 					// Copy this pixel?
 					if(pixels[oy * width + ox].a > 0.5f)
 					{
 						// Calculate target pixel and copy when within bounds
 						tx = x + ox;
 						ty = y + oy;
 						if((tx >= 0) && (tx < targetwidth) && (ty >= 0) && (ty < targetheight))
 							target[ty * targetwidth + tx] = pixels[oy * width + ox];
 					}
 				}
 			}
 
 			// Done
 			bmp.UnlockBits(bmpdata);
 			bmp.Dispose();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomPictureReader.cs" startline="182" endline="274">
<![CDATA[
 
 		// This creates pixel color data from the given data
 		// Returns null on failure
 		private PixelColorBlock ReadAsPixelData(Stream stream, out int width, out int height, out int offsetx, out int offsety)
 		{
 			BinaryReader reader = new BinaryReader(stream);
 			PixelColorBlock pixeldata = null;
 			int y, read_y, count, p;
 			int[] columns;
 			int dataoffset;
 			
 			// Initialize
 			width = 0;
 			height = 0;
 			offsetx = 0;
 			offsety = 0;
 			dataoffset = (int)stream.Position;
 
 			// Need at least 4 bytes
 			if((stream.Length - stream.Position) < 4) return null;
 			
 			#if !DEBUG
 			try
 			{
 			#endif
 			
 			// Read size and offset
 			width = reader.ReadInt16();
 			height = reader.ReadInt16();
 			offsetx = reader.ReadInt16();
 			offsety = reader.ReadInt16();
 			
 			// Valid width and height?
 			if((width <= 0) || (height <= 0)) return null;
 			
 			// Read the column addresses
 			columns = new int[width];
 			for(int x = 0; x < width; x++) columns[x] = reader.ReadInt32();
 			
 			// Allocate memory
 			pixeldata = new PixelColorBlock(width, height);
 			pixeldata.Clear();
 			
 			// Go for all columns
 			for(int x = 0; x < width; x++)
 			{
 				// Seek to column start
 				stream.Seek(dataoffset + columns[x], SeekOrigin.Begin);
 				
 				// Read first post start
 				y = reader.ReadByte();
 				read_y = y;
 				
 				// Continue while not end of column reached
 				while(read_y < 255)
 				{
 					// Read number of pixels in post
 					count = reader.ReadByte();
 
 					// Skip unused pixel
 					stream.Seek(1, SeekOrigin.Current);
 
 					// Draw post
 					for(int yo = 0; yo < count; yo++)
 					{
 						// Read pixel color index
 						p = reader.ReadByte();
 
 						// Draw pixel
 						pixeldata.Pointer[(y + yo) * width + x] = palette[p];
 					}
 					for(int yo = 0; yo < count; yo++)
 					{
 						// Read pixel color index
 						p = reader.ReadByte();
 
 						// Draw pixel
 						pixeldata.Pointer[(y + yo) * width + x] = palette[p];
 					}
 					
 					// Skip unused pixel
 					stream.Seek(1, SeekOrigin.Current);
 
 					// Read next post start
 					read_y = reader.ReadByte();
 					if(read_y < y) y += read_y; else y = read_y;
 				}
 				while(read_y < 255)
 				{
 					// Read number of pixels in post
 					count = reader.ReadByte();
 
 					// Skip unused pixel
 					stream.Seek(1, SeekOrigin.Current);
 
 					// Draw post
 					for(int yo = 0; yo < count; yo++)
 					{
 						// Read pixel color index
 						p = reader.ReadByte();
 
 						// Draw pixel
 						pixeldata.Pointer[(y + yo) * width + x] = palette[p];
 					}
 					
 					// Skip unused pixel
 					stream.Seek(1, SeekOrigin.Current);
 
 					// Read next post start
 					read_y = reader.ReadByte();
 					if(read_y < y) y += read_y; else y = read_y;
 				}
 			}
 			for(int x = 0; x < width; x++)
 			{
 				// Seek to column start
 				stream.Seek(dataoffset + columns[x], SeekOrigin.Begin);
 				
 				// Read first post start
 				y = reader.ReadByte();
 				read_y = y;
 				
 				// Continue while not end of column reached
 				while(read_y < 255)
 				{
 					// Read number of pixels in post
 					count = reader.ReadByte();
 
 					// Skip unused pixel
 					stream.Seek(1, SeekOrigin.Current);
 
 					// Draw post
 					for(int yo = 0; yo < count; yo++)
 					{
 						// Read pixel color index
 						p = reader.ReadByte();
 
 						// Draw pixel
 						pixeldata.Pointer[(y + yo) * width + x] = palette[p];
 					}
 					
 					// Skip unused pixel
 					stream.Seek(1, SeekOrigin.Current);
 
 					// Read next post start
 					read_y = reader.ReadByte();
 					if(read_y < y) y += read_y; else y = read_y;
 				}
 			}
 
 			// Return pointer
 			return pixeldata;
 			
 			#if !DEBUG
 			}
 			catch(Exception)
 			{
 				// Return nothing
 				return null;
 			}
 			#endif
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataLocationList.cs" startline="44" endline="73">
<![CDATA[
 
 		// This creates a list from a configuration structure
 		internal DataLocationList(Configuration cfg, string path)
 		{
 			IDictionary resinfo, rlinfo;
 			DataLocation res;
 
 			// Go for all items in the map info
 			resinfo = cfg.ReadSetting(path, new ListDictionary());
 			foreach(DictionaryEntry rl in resinfo)
 			{
 				// Item is a structure?
 				if(rl.Value is IDictionary)
 				{
 					// Create resource location
 					rlinfo = (IDictionary)rl.Value;
 					res = new DataLocation();
 
 					// Copy information from Configuration to ResourceLocation
 					if(rlinfo.Contains("type") && (rlinfo["type"] is int)) res.type = (int)rlinfo["type"];
 					if(rlinfo.Contains("location") && (rlinfo["location"] is string)) res.location = (string)rlinfo["location"];
 					if(rlinfo.Contains("option1") && (rlinfo["option1"] is int)) res.option1 = General.Int2Bool((int)rlinfo["option1"]);
 					if(rlinfo.Contains("option2") && (rlinfo["option2"] is int)) res.option2 = General.Int2Bool((int)rlinfo["option2"]);
 					if(rlinfo.Contains("notfortesting") && (rlinfo["notfortesting"] is int)) res.notfortesting = General.Int2Bool((int)rlinfo["notfortesting"]);
 
 					// Add resource
 					Add(res);
 				}
 			}
 			foreach(DictionaryEntry rl in resinfo)
 			{
 				// Item is a structure?
 				if(rl.Value is IDictionary)
 				{
 					// Create resource location
 					rlinfo = (IDictionary)rl.Value;
 					res = new DataLocation();
 
 					// Copy information from Configuration to ResourceLocation
 					if(rlinfo.Contains("type") && (rlinfo["type"] is int)) res.type = (int)rlinfo["type"];
 					if(rlinfo.Contains("location") && (rlinfo["location"] is string)) res.location = (string)rlinfo["location"];
 					if(rlinfo.Contains("option1") && (rlinfo["option1"] is int)) res.option1 = General.Int2Bool((int)rlinfo["option1"]);
 					if(rlinfo.Contains("option2") && (rlinfo["option2"] is int)) res.option2 = General.Int2Bool((int)rlinfo["option2"]);
 					if(rlinfo.Contains("notfortesting") && (rlinfo["notfortesting"] is int)) res.notfortesting = General.Int2Bool((int)rlinfo["notfortesting"]);
 
 					// Add resource
 					Add(res);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\LinedefEditForm.cs" startline="116" endline="305">
<![CDATA[
 		
 		// This sets up the form to edit the given lines
 		public void Setup(ICollection<Linedef> lines)
 		{
 			LinedefActivateInfo sai;
 			Linedef fl;
 
 			preventchanges = true;
 			
 			// Keep this list
 			this.lines = lines;
 			if(lines.Count > 1) this.Text = "Edit Linedefs (" + lines.Count + ")";
 			
 			////////////////////////////////////////////////////////////////////////
 			// Set all options to the first linedef properties
 			////////////////////////////////////////////////////////////////////////
 
 			// Get first line
 			fl = General.GetByIndex(lines, 0);
 			
 			// Flags
 			foreach(CheckBox c in flags.Checkboxes)
 				if(fl.Flags.ContainsKey(c.Tag.ToString())) c.Checked = fl.Flags[c.Tag.ToString()];
 			foreach(CheckBox c in flags.Checkboxes)
 				if(fl.Flags.ContainsKey(c.Tag.ToString())) c.Checked = fl.Flags[c.Tag.ToString()];
 			
 			// Activations
 			foreach(LinedefActivateInfo ai in activation.Items)
 				if((fl.Activate & ai.Index) == ai.Index) activation.SelectedItem = ai;
 			foreach(LinedefActivateInfo ai in activation.Items)
 				if((fl.Activate & ai.Index) == ai.Index) activation.SelectedItem = ai;
 
 			// UDMF Activations
 			foreach(CheckBox c in udmfactivates.Checkboxes)
 			{
 				LinedefActivateInfo ai = (c.Tag as LinedefActivateInfo);
 				if(fl.Flags.ContainsKey(ai.Key)) c.Checked = fl.Flags[ai.Key];
 			}
 			foreach(CheckBox c in udmfactivates.Checkboxes)
 			{
 				LinedefActivateInfo ai = (c.Tag as LinedefActivateInfo);
 				if(fl.Flags.ContainsKey(ai.Key)) c.Checked = fl.Flags[ai.Key];
 			}
 
 			// Action/tags
 			action.Value = fl.Action;
 			tag.Text = fl.Tag.ToString();
 			arg0.SetValue(fl.Args[0]);
 			arg1.SetValue(fl.Args[1]);
 			arg2.SetValue(fl.Args[2]);
 			arg3.SetValue(fl.Args[3]);
 			arg4.SetValue(fl.Args[4]);
 			
 			// Front side and back side checkboxes
 			frontside.Checked = (fl.Front != null);
 			backside.Checked = (fl.Back != null);
 
 			// Front settings
 			if(fl.Front != null)
 			{
 				fronthigh.TextureName = fl.Front.HighTexture;
 				frontmid.TextureName = fl.Front.MiddleTexture;
 				frontlow.TextureName = fl.Front.LowTexture;
 				fronthigh.Required = fl.Front.HighRequired();
 				frontmid.Required = fl.Front.MiddleRequired();
 				frontlow.Required = fl.Front.LowRequired();
 				frontsector.Text = fl.Front.Sector.Index.ToString();
 				frontoffsetx.Text = fl.Front.OffsetX.ToString();
 				frontoffsety.Text = fl.Front.OffsetY.ToString();
 			}
 
 			// Back settings
 			if(fl.Back != null)
 			{
 				backhigh.TextureName = fl.Back.HighTexture;
 				backmid.TextureName = fl.Back.MiddleTexture;
 				backlow.TextureName = fl.Back.LowTexture;
 				backhigh.Required = fl.Back.HighRequired();
 				backmid.Required = fl.Back.MiddleRequired();
 				backlow.Required = fl.Back.LowRequired();
 				backsector.Text = fl.Back.Sector.Index.ToString();
 				backoffsetx.Text = fl.Back.OffsetX.ToString();
 				backoffsety.Text = fl.Back.OffsetY.ToString();
 			}
 
 			// Custom fields
 			fieldslist.SetValues(fl.Fields, true);
 
 			////////////////////////////////////////////////////////////////////////
 			// Now go for all lines and change the options when a setting is different
 			////////////////////////////////////////////////////////////////////////
 
 			// Go for all lines
 			foreach(Linedef l in lines)
 			{
 				// Flags
 				foreach(CheckBox c in flags.Checkboxes)
 				{
 					if(l.Flags.ContainsKey(c.Tag.ToString()))
 					{
 						if(l.Flags[c.Tag.ToString()] != c.Checked)
 						{
 							c.ThreeState = true;
 							c.CheckState = CheckState.Indeterminate;
 						}
 					}
 				}
 				foreach(CheckBox c in flags.Checkboxes)
 				{
 					if(l.Flags.ContainsKey(c.Tag.ToString()))
 					{
 						if(l.Flags[c.Tag.ToString()] != c.Checked)
 						{
 							c.ThreeState = true;
 							c.CheckState = CheckState.Indeterminate;
 						}
 					}
 				}
 
 				// Activations
 				if(activation.Items.Count > 0)
 				{
 					sai = (activation.Items[0] as LinedefActivateInfo);
 					foreach(LinedefActivateInfo ai in activation.Items)
 						if((l.Activate & ai.Index) == ai.Index) sai = ai;
 					foreach(LinedefActivateInfo ai in activation.Items)
 						if((l.Activate & ai.Index) == ai.Index) sai = ai;
 					if(sai != activation.SelectedItem) activation.SelectedIndex = -1;
 				}
 
 				// UDMF Activations
 				foreach(CheckBox c in udmfactivates.Checkboxes)
 				{
 					LinedefActivateInfo ai = (c.Tag as LinedefActivateInfo);
 					if(l.Flags.ContainsKey(ai.Key))
 					{
 						if(c.Checked != l.Flags[ai.Key])
 						{
 							c.ThreeState = true;
 							c.CheckState = CheckState.Indeterminate;
 						}
 					}
 				}
 				foreach(CheckBox c in udmfactivates.Checkboxes)
 				{
 					LinedefActivateInfo ai = (c.Tag as LinedefActivateInfo);
 					if(l.Flags.ContainsKey(ai.Key))
 					{
 						if(c.Checked != l.Flags[ai.Key])
 						{
 							c.ThreeState = true;
 							c.CheckState = CheckState.Indeterminate;
 						}
 					}
 				}
 
 				// Action/tags
 				if(l.Action != action.Value) action.Empty = true;
 				if(l.Tag.ToString() != tag.Text) tag.Text = "";
 				if(l.Args[0] != arg0.GetResult(-1)) arg0.ClearValue();
 				if(l.Args[1] != arg1.GetResult(-1)) arg1.ClearValue();
 				if(l.Args[2] != arg2.GetResult(-1)) arg2.ClearValue();
 				if(l.Args[3] != arg3.GetResult(-1)) arg3.ClearValue();
 				if(l.Args[4] != arg4.GetResult(-1)) arg4.ClearValue();
 				
 				// Front side checkbox
 				if((l.Front != null) != frontside.Checked)
 				{
 					frontside.ThreeState = true;
 					frontside.CheckState = CheckState.Indeterminate;
 					frontside.AutoCheck = false;
 				}
 
 				// Back side checkbox
 				if((l.Back != null) != backside.Checked)
 				{
 					backside.ThreeState = true;
 					backside.CheckState = CheckState.Indeterminate;
 					backside.AutoCheck = false;
 				}
 
 				// Front settings
 				if(l.Front != null)
 				{
 					if(fronthigh.TextureName != l.Front.HighTexture) fronthigh.TextureName = "";
 					if(frontmid.TextureName != l.Front.MiddleTexture) frontmid.TextureName = "";
 					if(frontlow.TextureName != l.Front.LowTexture) frontlow.TextureName = "";
 					if(fronthigh.Required != l.Front.HighRequired()) fronthigh.Required = false;
 					if(frontmid.Required != l.Front.MiddleRequired()) frontmid.Required = false;
 					if(frontlow.Required != l.Front.LowRequired()) frontlow.Required = false;
 					if(frontsector.Text != l.Front.Sector.Index.ToString()) frontsector.Text = "";
 					if(frontoffsetx.Text != l.Front.OffsetX.ToString()) frontoffsetx.Text = "";
 					if(frontoffsety.Text != l.Front.OffsetY.ToString()) frontoffsety.Text = "";
 				}
 
 				// Back settings
 				if(l.Back != null)
 				{
 					if(backhigh.TextureName != l.Back.HighTexture) backhigh.TextureName = "";
 					if(backmid.TextureName != l.Back.MiddleTexture) backmid.TextureName = "";
 					if(backlow.TextureName != l.Back.LowTexture) backlow.TextureName = "";
 					if(backhigh.Required != l.Back.HighRequired()) backhigh.Required = false;
 					if(backmid.Required != l.Back.MiddleRequired()) backmid.Required = false;
 					if(backlow.Required != l.Back.LowRequired()) backlow.Required = false;
 					if(backsector.Text != l.Back.Sector.Index.ToString()) backsector.Text = "";
 					if(backoffsetx.Text != l.Back.OffsetX.ToString()) backoffsetx.Text = "";
 					if(backoffsety.Text != l.Back.OffsetY.ToString()) backoffsety.Text = "";
 					if(General.Map.FormatInterface.HasCustomFields) custombackbutton.Visible = true;
 				}
 				
 				// Custom fields
 				fieldslist.SetValues(l.Fields, false);
 			}
 			foreach(Linedef l in lines)
 			{
 				// Flags
 				foreach(CheckBox c in flags.Checkboxes)
 				{
 					if(l.Flags.ContainsKey(c.Tag.ToString()))
 					{
 						if(l.Flags[c.Tag.ToString()] != c.Checked)
 						{
 							c.ThreeState = true;
 							c.CheckState = CheckState.Indeterminate;
 						}
 					}
 				}
 
 				// Activations
 				if(activation.Items.Count > 0)
 				{
 					sai = (activation.Items[0] as LinedefActivateInfo);
 					foreach(LinedefActivateInfo ai in activation.Items)
 						if((l.Activate & ai.Index) == ai.Index) sai = ai;
 					if(sai != activation.SelectedItem) activation.SelectedIndex = -1;
 				}
 
 				// UDMF Activations
 				foreach(CheckBox c in udmfactivates.Checkboxes)
 				{
 					LinedefActivateInfo ai = (c.Tag as LinedefActivateInfo);
 					if(l.Flags.ContainsKey(ai.Key))
 					{
 						if(c.Checked != l.Flags[ai.Key])
 						{
 							c.ThreeState = true;
 							c.CheckState = CheckState.Indeterminate;
 						}
 					}
 				}
 
 				// Action/tags
 				if(l.Action != action.Value) action.Empty = true;
 				if(l.Tag.ToString() != tag.Text) tag.Text = "";
 				if(l.Args[0] != arg0.GetResult(-1)) arg0.ClearValue();
 				if(l.Args[1] != arg1.GetResult(-1)) arg1.ClearValue();
 				if(l.Args[2] != arg2.GetResult(-1)) arg2.ClearValue();
 				if(l.Args[3] != arg3.GetResult(-1)) arg3.ClearValue();
 				if(l.Args[4] != arg4.GetResult(-1)) arg4.ClearValue();
 				
 				// Front side checkbox
 				if((l.Front != null) != frontside.Checked)
 				{
 					frontside.ThreeState = true;
 					frontside.CheckState = CheckState.Indeterminate;
 					frontside.AutoCheck = false;
 				}
 
 				// Back side checkbox
 				if((l.Back != null) != backside.Checked)
 				{
 					backside.ThreeState = true;
 					backside.CheckState = CheckState.Indeterminate;
 					backside.AutoCheck = false;
 				}
 
 				// Front settings
 				if(l.Front != null)
 				{
 					if(fronthigh.TextureName != l.Front.HighTexture) fronthigh.TextureName = "";
 					if(frontmid.TextureName != l.Front.MiddleTexture) frontmid.TextureName = "";
 					if(frontlow.TextureName != l.Front.LowTexture) frontlow.TextureName = "";
 					if(fronthigh.Required != l.Front.HighRequired()) fronthigh.Required = false;
 					if(frontmid.Required != l.Front.MiddleRequired()) frontmid.Required = false;
 					if(frontlow.Required != l.Front.LowRequired()) frontlow.Required = false;
 					if(frontsector.Text != l.Front.Sector.Index.ToString()) frontsector.Text = "";
 					if(frontoffsetx.Text != l.Front.OffsetX.ToString()) frontoffsetx.Text = "";
 					if(frontoffsety.Text != l.Front.OffsetY.ToString()) frontoffsety.Text = "";
 				}
 
 				// Back settings
 				if(l.Back != null)
 				{
 					if(backhigh.TextureName != l.Back.HighTexture) backhigh.TextureName = "";
 					if(backmid.TextureName != l.Back.MiddleTexture) backmid.TextureName = "";
 					if(backlow.TextureName != l.Back.LowTexture) backlow.TextureName = "";
 					if(backhigh.Required != l.Back.HighRequired()) backhigh.Required = false;
 					if(backmid.Required != l.Back.MiddleRequired()) backmid.Required = false;
 					if(backlow.Required != l.Back.LowRequired()) backlow.Required = false;
 					if(backsector.Text != l.Back.Sector.Index.ToString()) backsector.Text = "";
 					if(backoffsetx.Text != l.Back.OffsetX.ToString()) backoffsetx.Text = "";
 					if(backoffsety.Text != l.Back.OffsetY.ToString()) backoffsety.Text = "";
 					if(General.Map.FormatInterface.HasCustomFields) custombackbutton.Visible = true;
 				}
 				
 				// Custom fields
 				fieldslist.SetValues(l.Fields, false);
 			}
 			
 			// Refresh controls so that they show their image
 			backhigh.Refresh();
 			backmid.Refresh();
 			backlow.Refresh();
 			fronthigh.Refresh();
 			frontmid.Refresh();
 			frontlow.Refresh();
 
 			preventchanges = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\MapManager.cs" startline="436" endline="711">
<![CDATA[
 
 		// Initializes for an existing map
 		internal bool SaveMap(string newfilepathname, SavePurpose purpose)
 		{
 			MapSet outputset;
 			string nodebuildername, settingsfile;
 			StatusInfo oldstatus;
 			WAD targetwad;
 			int index;
 			bool includenodes = false;
 			string origmapname;
 			bool success = true;
 			
 			General.WriteLogLine("Saving map to file
 			
 			// Scripts changed?
 			bool localscriptschanged = CheckScriptChanged();
 			
 			// If the scripts window is open, save the scripts first
 			if(IsScriptsWindowOpen) scriptwindow.Editor.ImplicitSave();
 			
 			// Only recompile scripts when the scripts have changed
 			// (not when only the map changed)
 			if(localscriptschanged)
 			{
 				if(!CompileScriptLumps())
 				{
 					// Compiler failure
 					if(errors.Count > 0)
 						General.ShowErrorMessage("Error while compiling scripts
 					else
 						General.ShowErrorMessage("Unknown compiler error while compiling scripts!", MessageBoxButtons.OK);
 				}
 			}
 
 			// Show script window if there are any errors and we are going to test the map
 			// and always update the errors on the scripts window.
 			if((errors.Count > 0) && (scriptwindow == null) && (purpose == SavePurpose.Testing)) ShowScriptEditor();
 			if(scriptwindow != null) scriptwindow.Editor.ShowErrors(errors);
 			
 			// Only write the map and rebuild nodes when the actual map has changed
 			// (not when only scripts have changed)
 			if(changed)
 			{
 				// Make a copy of the map data
 				outputset = map.Clone();
 
 				// Remove all flags from all 3D Start things
 				foreach(Thing t in outputset.Things)
 				{
 					if(t.Type == config.Start3DModeThingType)
 					{
 						// We're not using SetFlag here, this doesn't have to be undone.
 						// Please note that this is totally exceptional!
 						List<string> flagkeys = new List<string>(t.Flags.Keys);
 						foreach(string k in flagkeys) t.Flags[k] = false;
 					}
 				}
 				foreach(Thing t in outputset.Things)
 				{
 					if(t.Type == config.Start3DModeThingType)
 					{
 						// We're not using SetFlag here, this doesn't have to be undone.
 						// Please note that this is totally exceptional!
 						List<string> flagkeys = new List<string>(t.Flags.Keys);
 						foreach(string k in flagkeys) t.Flags[k] = false;
 					}
 				}
 
 				// Do we need sidedefs compression?
 				if(map.Sidedefs.Count > io.MaxSidedefs)
 				{
 					// Compress sidedefs
 					oldstatus = General.MainWindow.Status;
 					General.MainWindow.DisplayStatus(StatusType.Busy, "Compressing sidedefs...");
 					outputset.CompressSidedefs();
 					General.MainWindow.DisplayStatus(oldstatus);
 					
 					// Check if it still doesnt fit
 					if(outputset.Sidedefs.Count > io.MaxSidedefs)
 					{
 						// Problem! Can't save the map like this!
 						General.ShowErrorMessage("Unable to save the map
 						return false;
 					}
 				}
 
 				// Check things
 				if(map.Things.Count > io.MaxThings)
 				{
 					General.ShowErrorMessage("Unable to save the map
 					return false;
 				}
 
 				// Check sectors
 				if(map.Sectors.Count > io.MaxSectors)
 				{
 					General.ShowErrorMessage("Unable to save the map
 					return false;
 				}
 
 				// Check linedefs
 				if(map.Linedefs.Count > io.MaxLinedefs)
 				{
 					General.ShowErrorMessage("Unable to save the map
 					return false;
 				}
 
 				// Check vertices
 				if(map.Vertices.Count > io.MaxVertices)
 				{
 					General.ShowErrorMessage("Unable to save the map
 					return false;
 				}
 				
 				// TODO
 				
 				// Write to temporary file
 				General.WriteLogLine("Writing map data structures to file...");
 				index = tempwad.FindLumpIndex(TEMP_MAP_HEADER);
 				if(index == -1) index = 0;
 				io.Write(outputset, TEMP_MAP_HEADER, index);
 				outputset.Dispose();
 				
 				// Get the corresponding nodebuilder
 				nodebuildername = (purpose == SavePurpose.Testing) ? configinfo.NodebuilderTest 
 
 				// Build the nodes
 				oldstatus = General.MainWindow.Status;
 				General.MainWindow.DisplayStatus(StatusType.Busy, "Building map nodes...");
 				if(!string.IsNullOrEmpty(nodebuildername))
 					includenodes = BuildNodes(nodebuildername, true);
 				else
 					includenodes = false;
 				General.MainWindow.DisplayStatus(oldstatus);
 			}
 			else
 			{
 				// Check if we have nodebuilder lumps
 				includenodes = VerifyNodebuilderLumps(tempwad, TEMP_MAP_HEADER);
 			}
 			
 			// Suspend data resources
 			data.Suspend();
 
 			// Determine original map name
 			origmapname = (options.PreviousName != "") ? options.PreviousName 
 			
 			try
 			{
 				// Backup existing file, if any
 				if(File.Exists(newfilepathname))
 				{
 					if(File.Exists(newfilepathname + ".backup3")) File.Delete(newfilepathname + ".backup3");
 					if(File.Exists(newfilepathname + ".backup2")) File.Move(newfilepathname + ".backup2", newfilepathname + ".backup3");
 					if(File.Exists(newfilepathname + ".backup1")) File.Move(newfilepathname + ".backup1", newfilepathname + ".backup2");
 					File.Copy(newfilepathname, newfilepathname + ".backup1");
 				}
 				
 				// Except when saving INTO another file,
 				// kill the target file if it is different from source file
 				if((purpose != SavePurpose.IntoFile) && (newfilepathname != filepathname))
 				{
 					// Kill target file
 					if(File.Exists(newfilepathname)) File.Delete(newfilepathname);
 
 					// Kill .dbs settings file
 					settingsfile = newfilepathname.Substring(0, newfilepathname.Length - 4) + ".dbs";
 					if(File.Exists(settingsfile)) File.Delete(settingsfile);
 				}
 
 				// On Save AS we have to copy the previous file to the new file
 				if((purpose == SavePurpose.AsNewFile) && (filepathname != ""))
 				{
 					// Copy if original file still exists
 					if(File.Exists(filepathname)) File.Copy(filepathname, newfilepathname, true);
 				}
 				
 				// If the target file exists, we need to rebuild it
 				if(File.Exists(newfilepathname))
 				{
 					// Move the target file aside
 					string origwadfile = newfilepathname + ".temp";
 					File.Move(newfilepathname, origwadfile);
 
 					// Open original file
 					WAD origwad = new WAD(origwadfile, true);
 					
 					// Create new target file
 					targetwad = new WAD(newfilepathname);
 
 					// Copy all lumps, except the original map
 					CopyAllLumpsExceptMap(origwad, targetwad, origmapname);
 					
 					// Close original file and delete it
 					origwad.Dispose();
 					File.Delete(origwadfile);
 				}
 				else
 				{
 					// Create new target file
 					targetwad = new WAD(newfilepathname);
 				}
 			}
 			catch(IOException)
 			{
 				General.ShowErrorMessage("IO Error while writing target file
 				data.Resume();
 				General.WriteLogLine("Map saving failed");
 				return false;
 			}
 			catch(UnauthorizedAccessException)
 			{
 				General.ShowErrorMessage("Error while accessing target file
 				data.Resume();
 				General.WriteLogLine("Map saving failed");
 				return false;
 			}
 			
 			// Copy map lumps to target file
 			CopyLumpsByType(tempwad, TEMP_MAP_HEADER, targetwad, origmapname, true, true, includenodes, true);
 
 			// Was the map lump name renamed?
 			if((options.PreviousName != options.CurrentName) &&
 			   (options.PreviousName != ""))
 			{
 				General.WriteLogLine("Renaming map lump name from " + options.PreviousName + " to " + options.CurrentName);
 				
 				// Find the map header in target
 				index = targetwad.FindLumpIndex(options.PreviousName);
 				if(index > -1)
 				{
 					// Rename the map lump name
 					targetwad.Lumps[index].Rename(options.CurrentName);
 					options.PreviousName = "";
 				}
 				else
 				{
 					// Houston, we've got a problem!
 					General.ShowErrorMessage("Error renaming map lump name
 					options.CurrentName = options.PreviousName;
 					options.PreviousName = "";
 				}
 			}
 
 			// Done with the target file
 			targetwad.Dispose();
 
 			// Resume data resources
 			data.Resume();
 			
 			// Not saved for testing purpose?
 			if(purpose != SavePurpose.Testing)
 			{
 				// Saved in a different file?
 				if(newfilepathname != filepathname)
 				{
 					// Keep new filename
 					filepathname = newfilepathname;
 					filetitle = Path.GetFileName(filepathname);
 
 					// Reload resources
 					ReloadResources();
 				}
 
 				try
 				{
 					// Open or create the map settings
 					settingsfile = newfilepathname.Substring(0, newfilepathname.Length - 4) + ".dbs";
 					options.WriteConfiguration(settingsfile);
 				}
 				catch(Exception e)
 				{
 					// Warning only
 					General.ErrorLogger.Add(ErrorType.Warning, "Could not write the map settings configuration file. " + e.GetType().Name + "
 				}
 				
 				// Changes saved
 				changed = false;
 				scriptschanged = false;
 			}
 			
 			// Success!
 			General.WriteLogLine("Map saving done");
 			return success;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureSetForm.Designer.cs" startline="22" endline="302">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			this.label1 = new System.Windows.Forms.Label();
 			this.name = new System.Windows.Forms.TextBox();
 			this.filters = new System.Windows.Forms.ListView();
 			this.filtercolumn = new System.Windows.Forms.ColumnHeader();
 			this.label2 = new System.Windows.Forms.Label();
 			this.label3 = new System.Windows.Forms.Label();
 			this.label4 = new System.Windows.Forms.Label();
 			this.apply = new System.Windows.Forms.Button();
 			this.cancel = new System.Windows.Forms.Button();
 			this.addfilter = new System.Windows.Forms.Button();
 			this.removefilter = new System.Windows.Forms.Button();
 			this.groupBox1 = new System.Windows.Forms.GroupBox();
 			this.filterstimer = new System.Windows.Forms.Timer(this.components);
 			this.groupBox2 = new System.Windows.Forms.GroupBox();
 			this.nomatchesbutton = new System.Windows.Forms.RadioButton();
 			this.matchesbutton = new System.Windows.Forms.RadioButton();
 			this.matcheslist = new CodeImp.DoomBuilder.Controls.ImageBrowserControl();
 			this.noresultlabel = new System.Windows.Forms.Label();
 			this.pictureBox1 = new System.Windows.Forms.PictureBox();
 			this.groupBox1.SuspendLayout();
 			this.groupBox2.SuspendLayout();
 			((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
 			this.SuspendLayout();
 			// 
 			// label1
 			// 
 			this.label1.AutoSize = true;
 			this.label1.Location = new System.Drawing.Point(36, 24);
 			this.label1.Name = "label1";
 			this.label1.Size = new System.Drawing.Size(37, 14);
 			this.label1.TabIndex = 0;
 			this.label1.Text = "Name
 			// 
 			// name
 			// 
 			this.name.Location = new System.Drawing.Point(79, 21);
 			this.name.Name = "name";
 			this.name.Size = new System.Drawing.Size(173, 20);
 			this.name.TabIndex = 0;
 			// 
 			// filters
 			// 
 			this.filters.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.filters.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.filtercolumn});
 			this.filters.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
 			this.filters.HideSelection = false;
 			this.filters.LabelEdit = true;
 			this.filters.Location = new System.Drawing.Point(21, 110);
 			this.filters.Name = "filters";
 			this.filters.ShowGroups = false;
 			this.filters.Size = new System.Drawing.Size(219, 280);
 			this.filters.TabIndex = 0;
 			this.filters.UseCompatibleStateImageBehavior = false;
 			this.filters.View = System.Windows.Forms.View.Details;
 			this.filters.AfterLabelEdit += new System.Windows.Forms.LabelEditEventHandler(this.filters_AfterLabelEdit);
 			this.filters.SelectedIndexChanged += new System.EventHandler(this.filters_SelectedIndexChanged);
 			this.filters.DoubleClick += new System.EventHandler(this.filters_DoubleClick);
 			// 
 			// filtercolumn
 			// 
 			this.filtercolumn.Text = "Filter";
 			this.filtercolumn.Width = 192;
 			// 
 			// label2
 			// 
 			this.label2.Location = new System.Drawing.Point(18, 28);
 			this.label2.Name = "label2";
 			this.label2.Size = new System.Drawing.Size(248, 42);
 			this.label2.TabIndex = 3;
 			this.label2.Text = "Add the names of the textures in this set below. You can use the following wildca" +
 				"rds
 			// 
 			// label3
 			// 
 			this.label3.AutoSize = true;
 			this.label3.Location = new System.Drawing.Point(28, 65);
 			this.label3.Name = "label3";
 			this.label3.Size = new System.Drawing.Size(175, 14);
 			this.label3.TabIndex = 4;
 			this.label3.Text = "? = matches exactly one character";
 			// 
 			// label4
 			// 
 			this.label4.AutoSize = true;
 			this.label4.Location = new System.Drawing.Point(28, 83);
 			this.label4.Name = "label4";
 			this.label4.Size = new System.Drawing.Size(185, 14);
 			this.label4.TabIndex = 5;
 			this.label4.Text = "* = matches zero or more characters";
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(503, 515);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(105, 25);
 			this.apply.TabIndex = 3;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(614, 515);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(105, 25);
 			this.cancel.TabIndex = 4;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// addfilter
 			// 
 			this.addfilter.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.addfilter.Location = new System.Drawing.Point(21, 396);
 			this.addfilter.Name = "addfilter";
 			this.addfilter.Size = new System.Drawing.Size(97, 24);
 			this.addfilter.TabIndex = 1;
 			this.addfilter.Text = "Add Texture";
 			this.addfilter.UseVisualStyleBackColor = true;
 			this.addfilter.Click += new System.EventHandler(this.addfilter_Click);
 			// 
 			// removefilter
 			// 
 			this.removefilter.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.removefilter.Enabled = false;
 			this.removefilter.Location = new System.Drawing.Point(124, 396);
 			this.removefilter.Name = "removefilter";
 			this.removefilter.Size = new System.Drawing.Size(105, 24);
 			this.removefilter.TabIndex = 2;
 			this.removefilter.Text = "Remove Selection";
 			this.removefilter.UseVisualStyleBackColor = true;
 			this.removefilter.Click += new System.EventHandler(this.removefilter_Click);
 			// 
 			// groupBox1
 			// 
 			this.groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)));
 			this.groupBox1.Controls.Add(this.removefilter);
 			this.groupBox1.Controls.Add(this.label4);
 			this.groupBox1.Controls.Add(this.addfilter);
 			this.groupBox1.Controls.Add(this.label3);
 			this.groupBox1.Controls.Add(this.label2);
 			this.groupBox1.Controls.Add(this.filters);
 			this.groupBox1.Location = new System.Drawing.Point(12, 60);
 			this.groupBox1.Name = "groupBox1";
 			this.groupBox1.Size = new System.Drawing.Size(270, 440);
 			this.groupBox1.TabIndex = 1;
 			this.groupBox1.TabStop = false;
 			this.groupBox1.Text = " Filters ";
 			// 
 			// filterstimer
 			// 
 			this.filterstimer.Interval = 1;
 			this.filterstimer.Tick += new System.EventHandler(this.filterstimer_Tick);
 			// 
 			// groupBox2
 			// 
 			this.groupBox2.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.groupBox2.Controls.Add(this.nomatchesbutton);
 			this.groupBox2.Controls.Add(this.matchesbutton);
 			this.groupBox2.Controls.Add(this.matcheslist);
 			this.groupBox2.Controls.Add(this.noresultlabel);
 			this.groupBox2.Location = new System.Drawing.Point(298, 60);
 			this.groupBox2.Name = "groupBox2";
 			this.groupBox2.Size = new System.Drawing.Size(421, 440);
 			this.groupBox2.TabIndex = 2;
 			this.groupBox2.TabStop = false;
 			this.groupBox2.Text = " Results ";
 			// 
 			// nomatchesbutton
 			// 
 			this.nomatchesbutton.Appearance = System.Windows.Forms.Appearance.Button;
 			this.nomatchesbutton.Location = new System.Drawing.Point(141, 25);
 			this.nomatchesbutton.Name = "nomatchesbutton";
 			this.nomatchesbutton.Size = new System.Drawing.Size(117, 24);
 			this.nomatchesbutton.TabIndex = 1;
 			this.nomatchesbutton.Text = "Show Not Matching";
 			this.nomatchesbutton.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
 			this.nomatchesbutton.UseVisualStyleBackColor = true;
 			this.nomatchesbutton.Click += new System.EventHandler(this.matchesbutton_Click);
 			// 
 			// matchesbutton
 			// 
 			this.matchesbutton.Appearance = System.Windows.Forms.Appearance.Button;
 			this.matchesbutton.Checked = true;
 			this.matchesbutton.Location = new System.Drawing.Point(18, 25);
 			this.matchesbutton.Name = "matchesbutton";
 			this.matchesbutton.Size = new System.Drawing.Size(117, 24);
 			this.matchesbutton.TabIndex = 0;
 			this.matchesbutton.TabStop = true;
 			this.matchesbutton.Text = "Show Matches";
 			this.matchesbutton.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
 			this.matchesbutton.UseVisualStyleBackColor = true;
 			this.matchesbutton.Click += new System.EventHandler(this.matchesbutton_Click);
 			// 
 			// matcheslist
 			// 
 			this.matcheslist.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.matcheslist.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.matcheslist.HideInputBox = true;
 			this.matcheslist.LabelText = "Select or type object name
 			this.matcheslist.Location = new System.Drawing.Point(18, 55);
 			this.matcheslist.Name = "matcheslist";
 			this.matcheslist.PreventSelection = true;
 			this.matcheslist.Size = new System.Drawing.Size(387, 365);
 			this.matcheslist.TabIndex = 2;
 			this.matcheslist.SelectedItemDoubleClicked += new CodeImp.DoomBuilder.Controls.ImageBrowserControl.SelectedItemDoubleClickDelegate(this.matcheslist_SelectedItemDoubleClicked);
 			// 
 			// noresultlabel
 			// 
 			this.noresultlabel.Location = new System.Drawing.Point(15, 28);
 			this.noresultlabel.Name = "noresultlabel";
 			this.noresultlabel.Size = new System.Drawing.Size(272, 43);
 			this.noresultlabel.TabIndex = 33;
 			this.noresultlabel.Text = "An example result cannot be displayed, because it requires a map to be loaded.";
 			this.noresultlabel.Visible = false;
 			// 
 			// pictureBox1
 			// 
 			this.pictureBox1.Image = global
 			this.pictureBox1.Location = new System.Drawing.Point(12, 23);
 			this.pictureBox1.Name = "pictureBox1";
 			this.pictureBox1.Size = new System.Drawing.Size(19, 16);
 			this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
 			this.pictureBox1.TabIndex = 12;
 			this.pictureBox1.TabStop = false;
 			// 
 			// TextureSetForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(731, 552);
 			this.Controls.Add(this.pictureBox1);
 			this.Controls.Add(this.groupBox2);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.name);
 			this.Controls.Add(this.label1);
 			this.Controls.Add(this.groupBox1);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "TextureSetForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Edit Texture Set";
 			this.Shown += new System.EventHandler(this.TextureSetForm_Shown);
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.TextureSetForm_HelpRequested);
 			this.groupBox1.ResumeLayout(false);
 			this.groupBox1.PerformLayout();
 			this.groupBox2.ResumeLayout(false);
 			((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1759" endline="1769">
<![CDATA[
 
 		// This handles edit mode button clicks
 		private void EditModeButtonHandler(object sender, EventArgs e)
 		{
 			EditModeInfo modeinfo;
 			
 			this.Update();
 			modeinfo = (EditModeInfo)((sender as ToolStripItem).Tag);
 			General.Actions.InvokeAction(modeinfo.SwitchAction.GetFullActionName(modeinfo.Plugin.Assembly));
 			this.Update();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalParser.cs" startline="134" endline="170">
<![CDATA[
 		
 		
 		// This validates a given key and sets
 		// error properties if key is invalid and errorline > -1
 		private bool ValidateKey(string key, int errorline)
 		{
 			bool validateresult = true;
 			
 			// Check if key is an empty string
 			if(key.Length == 0)
 			{
 				// ERROR
 				if(errorline > -1) RaiseError(errorline, ERROR_KEYMISSING);
 				validateresult = false;
 			}
 			else
 			{
 				// Only when strict checking
 				if(strictchecking)
 				{
 					// Check if all characters are valid
 					foreach(char c in key)
 					{
 						if(KEY_CHARACTERS.IndexOf(c) == -1)
 						{
 							// ERROR
 							if(errorline > -1) RaiseError(errorline, ERROR_KEYCHARACTERS);
 							validateresult = false;
 							break;
 						}
 					}
 					foreach(char c in key)
 					{
 						if(KEY_CHARACTERS.IndexOf(c) == -1)
 						{
 							// ERROR
 							if(errorline > -1) RaiseError(errorline, ERROR_KEYCHARACTERS);
 							validateresult = false;
 							break;
 						}
 					}
 				}
 			}
 			
 			// Return result
 			return validateresult;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3Reader.cs" startline="304" endline="312">
<![CDATA[
 
 		// This finds the first file that has the specific name
 		protected override string FindFirstFileWithExt(string path, string beginswith, bool subfolders)
 		{
 			string title = Path.GetFileNameWithoutExtension(beginswith);
 			string ext = Path.GetExtension(beginswith);
 			if(ext.Length > 1) ext = ext.Substring(1); else ext = "";
 			return files.GetFirstFile(path, title, subfolders, ext);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DirectoryReader.cs" startline="305" endline="313">
<![CDATA[
 
 		// This finds the first file that has the specific name
 		protected override string FindFirstFileWithExt(string path, string beginswith, bool subfolders)
 		{
 			string title = Path.GetFileNameWithoutExtension(beginswith);
 			string ext = Path.GetExtension(beginswith);
 			if(ext.Length > 1) ext = ext.Substring(1); else ext = "";
 			return files.GetFirstFile(path, title, subfolders, ext);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2373" endline="2550">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Message Pump
 		
 		// This handles messages
 		protected override void WndProc(ref System.Windows.Forms.Message m)
 		{
 			// Notify message?
 			if(m.Msg == WM_NOTIFY)
 			{
 				SCNotification scn = (SCNotification)Marshal.PtrToStructure(m.LParam, typeof(SCNotification));
 
 				if(scn.nmhdr.hwndFrom == controlptr)
 				{
 					switch(scn.nmhdr.code)
 					{
 						#region "scintilla-event-dispatch"
 
 						case (uint)ScintillaEvents.StyleNeeded
 							if(StyleNeeded != null)
 								StyleNeeded(this, scn.position);
 							break;
 
 						case (uint)ScintillaEvents.CharAdded
 							if(CharAdded != null)
 								CharAdded(this, scn.ch);
 							break;
 
 						case (uint)ScintillaEvents.SavePointReached
 							if(SavePointReached != null)
 								SavePointReached(this);
 							break;
 
 						case (uint)ScintillaEvents.SavePointLeft
 							if(SavePointLeft != null)
 								SavePointLeft(this);
 							break;
 
 						case (uint)ScintillaEvents.ModifyAttemptRO
 							if(ModifyAttemptRO != null)
 								ModifyAttemptRO(this);
 							break;
 
 						case (uint)ScintillaEvents.Key
 							if(Key != null)
 								Key(this, scn.ch, scn.modifiers);
 							break;
 
 						case (uint)ScintillaEvents.DoubleClick
 							if(DoubleClick != null)
 								DoubleClick(this);
 							break;
 
 						case (uint)ScintillaEvents.UpdateUI
 							if(UpdateUI != null)
 								UpdateUI(this);
 							break;
 
 						case (uint)ScintillaEvents.MacroRecord
 							if(MacroRecord != null)
 								MacroRecord(this, scn.message, scn.wParam, scn.lParam);
 							break;
 
 						case (uint)ScintillaEvents.MarginClick
 							if(MarginClick != null)
 								MarginClick(this, scn.modifiers, scn.position, scn.margin);
 							break;
 
 						case (uint)ScintillaEvents.NeedShown
 							if(NeedShown != null)
 								NeedShown(this, scn.position, scn.length);
 							break;
 
 						case (uint)ScintillaEvents.Painted
 							if(Painted != null)
 								Painted(this);
 							break;
 
 						case (uint)ScintillaEvents.UserlistSelection
 							//if(UserListSelection != null)
 							//	UserListSelection(this, scn.listType, System.Runtime.InteropServices.Marshal.PtrToStringAuto(scn.text));
 							break;
 
 						case (uint)ScintillaEvents.UriDropped
 							//if(URIDropped != null)
 							//	URIDropped(this, System.Runtime.InteropServices.Marshal.PtrToStringAuto(scn.text));
 							break;
 
 						case (uint)ScintillaEvents.DwellStart
 							if(DwellStart != null)
 								DwellStart(this, scn.position);
 							break;
 
 						case (uint)ScintillaEvents.DwellEnd
 							if(DwellEnd != null)
 								DwellEnd(this, scn.position);
 							break;
 
 						case (uint)ScintillaEvents.Zoom
 							if(Zoom != null)
 								Zoom(this);
 							break;
 
 						case (uint)ScintillaEvents.HotspotClick
 							if(HotSpotClick != null)
 								HotSpotClick(this, scn.modifiers, scn.position);
 							break;
 
 						case (uint)ScintillaEvents.HotspotDoubleClick
 							if(HotSpotDoubleClick != null)
 								HotSpotDoubleClick(this, scn.modifiers, scn.position);
 							break;
 
 						case (uint)ScintillaEvents.CallTipClick
 							if(CallTipClick != null)
 								CallTipClick(this, scn.position);
 							break;
 						#endregion
 
 						case (uint)ScintillaEvents.Modified
 							if((scn.modificationType & (uint)ScriptModificationFlags.InsertText) > 0)
 								if(TextInserted != null)
 									TextInserted(this, scn.position, scn.length, scn.linesAdded);
 							if((scn.modificationType & (uint)ScriptModificationFlags.DeleteText) > 0)
 								if(TextDeleted != null)
 									TextDeleted(this, scn.position, scn.length, scn.linesAdded);
 							if((scn.modificationType & (uint)ScriptModificationFlags.ChangeStyle) > 0)
 								if(StyleChanged != null)
 									StyleChanged(this, scn.position, scn.length);
 							if((scn.modificationType & (uint)ScriptModificationFlags.ChangeFold) > 0)
 								if(FoldChanged != null)
 									FoldChanged(this, scn.line, scn.foldLevelNow, scn.foldLevelPrev);
 							if((scn.modificationType & (uint)ScriptModificationFlags.User) > 0)
 								if(UserPerformed != null)
 									UserPerformed(this);
 							if((scn.modificationType & (uint)ScriptModificationFlags.Undo) > 0)
 								if(UndoPerformed != null)
 									UndoPerformed(this);
 							if((scn.modificationType & (uint)ScriptModificationFlags.Redo) > 0)
 								if(RedoPerformed != null)
 									RedoPerformed(this);
 							if((scn.modificationType & (uint)ScriptModificationFlags.StepInUndoRedo) > 0)
 								if(LastStepInUndoRedo != null)
 									LastStepInUndoRedo(this);
 							if((scn.modificationType & (uint)ScriptModificationFlags.ChangeMarker) > 0)
 								if(MarkerChanged != null)
 									MarkerChanged(this, scn.line);
 							if((scn.modificationType & (uint)ScriptModificationFlags.BeforeInsert) > 0)
 								if(BeforeInsert != null)
 									BeforeInsert(this, scn.position, scn.length);
 							if((scn.modificationType & (uint)ScriptModificationFlags.BeforeDelete) > 0)
 								if(BeforeDelete != null)
 									BeforeDelete(this, scn.position, scn.length);
 
 								if(Modified != null)
 								{
 									string textstr = null;
 									try
 									{
 										textstr = System.Runtime.InteropServices.Marshal.PtrToStringAuto(scn.text);
 									}
 									catch(IndexOutOfRangeException e)
 									{
 										// I don't know why this is happening, but I don't need the text here anyways
 									}
 									
 									Modified(this, scn.position, scn.modificationType, textstr, scn.length, scn.linesAdded, scn.line, scn.foldLevelNow, scn.foldLevelPrev);
 								}
 							break;
 
 					}
 				}
 
 			}
 			else
 				base.WndProc(ref m);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\PK3Reader.cs" startline="213" endline="237">
<![CDATA[
 
 		// This checks if the given sprite exists
 		public override bool GetSpriteExists(string pname)
 		{
 			string pfilename = pname.Replace('\\', '^');
 
 			// Error when suspended
 			if(issuspended) throw new Exception("Data reader is suspended");
 
 			// Find in any of the wad files
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				if(wads[i].GetSpriteExists(pname)) return true;
 			}
 			for(int i = wads.Count - 1; i >= 0; i--)
 			{
 				if(wads[i].GetSpriteExists(pname)) return true;
 			}
 
 			// Find in sprites directory
 			string filename = FindFirstFile(SPRITES_DIR, pfilename, true);
 			if((filename != null) && FileExists(filename))
 			{
 				return true;
 			}
 
 			// Nothing found
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="320" endline="329">
<![CDATA[
 		
 		// This finds a lump by name, returns null when not found
 		public Lump FindLump(string name)
 		{
 			int index = FindLumpIndex(name);
 			if(index == -1)
 				return null;
 			else
 				return lumps[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\MapSet.cs" startline="928" endline="944">
<![CDATA[
 
 		// This deserializes vertices
 		private Vertex[] ReadVertices(DeserializerStream stream)
 		{
 			int c; stream.rInt(out c);
 
 			Vertex[] array = new Vertex[c];
 
 			// Go for all vertices
 			for(int i = 0; i < c; i++)
 			{
 				array[i] = CreateVertex(new Vector2D());
 				array[i].ReadWrite(stream);
 			}
 			for(int i = 0; i < c; i++)
 			{
 				array[i] = CreateVertex(new Vector2D());
 				array[i].ReadWrite(stream);
 			}
 
 			return array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\ColorCollection.cs" startline="227" endline="238">
<![CDATA[
 
 		// This creates assist colors
 		internal void CreateAssistColors()
 		{
 			// Go for all colors
 			for(int i = 0; i < NUM_COLORS; i++)
 			{
 				// Create assist colors
 				brightcolors[i] = CreateBrightVariant(colors[i]);
 				darkcolors[i] = CreateDarkVariant(colors[i]);
 			}
 			for(int i = 0; i < NUM_COLORS; i++)
 			{
 				// Create assist colors
 				brightcolors[i] = CreateBrightVariant(colors[i]);
 				darkcolors[i] = CreateDarkVariant(colors[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\Clock.cs" startline="98" endline="119">
<![CDATA[
 		
 		// This queries the system for the current time
 		public double GetCurrentTime()
 		{
 			// Get the current system time
 			uint nexttime = GetTime();
 
 			// Determine delta time since previous update
 			// (this takes care of time wrapping around to 0)
 			uint deltatime;
 			if(nexttime < lasttime)
 				deltatime = (uint.MaxValue - lasttime) + nexttime;
 			else
 				deltatime = nexttime - lasttime;
 
 			// Add the elapsed time to our internal time
 			currenttime += deltatime;
 
 			lasttime = nexttime;
 
 			return currenttime;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ThingInfoPanel.Designer.cs" startline="22" endline="329">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.Label label5;
 			System.Windows.Forms.Label label4;
 			System.Windows.Forms.Label label3;
 			System.Windows.Forms.Label label2;
 			System.Windows.Forms.Label label1;
 			this.infopanel = new System.Windows.Forms.GroupBox();
 			this.arg5 = new System.Windows.Forms.Label();
 			this.arglbl5 = new System.Windows.Forms.Label();
 			this.arglbl4 = new System.Windows.Forms.Label();
 			this.arg4 = new System.Windows.Forms.Label();
 			this.arglbl3 = new System.Windows.Forms.Label();
 			this.arglbl2 = new System.Windows.Forms.Label();
 			this.arg3 = new System.Windows.Forms.Label();
 			this.arglbl1 = new System.Windows.Forms.Label();
 			this.arg2 = new System.Windows.Forms.Label();
 			this.arg1 = new System.Windows.Forms.Label();
 			this.angle = new System.Windows.Forms.Label();
 			this.tag = new System.Windows.Forms.Label();
 			this.position = new System.Windows.Forms.Label();
 			this.action = new System.Windows.Forms.Label();
 			this.type = new System.Windows.Forms.Label();
 			this.spritepanel = new System.Windows.Forms.GroupBox();
 			this.spritename = new System.Windows.Forms.Label();
 			this.spritetex = new System.Windows.Forms.Panel();
 			label5 = new System.Windows.Forms.Label();
 			label4 = new System.Windows.Forms.Label();
 			label3 = new System.Windows.Forms.Label();
 			label2 = new System.Windows.Forms.Label();
 			label1 = new System.Windows.Forms.Label();
 			this.infopanel.SuspendLayout();
 			this.spritepanel.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// label5
 			// 
 			label5.AutoSize = true;
 			label5.Location = new System.Drawing.Point(165, 77);
 			label5.Name = "label5";
 			label5.Size = new System.Drawing.Size(38, 14);
 			label5.TabIndex = 8;
 			label5.Text = "Angle
 			// 
 			// label4
 			// 
 			label4.AutoSize = true;
 			label4.Location = new System.Drawing.Point(30, 77);
 			label4.Name = "label4";
 			label4.Size = new System.Drawing.Size(28, 14);
 			label4.TabIndex = 4;
 			label4.Text = "Tag
 			// 
 			// label3
 			// 
 			label3.AutoSize = true;
 			label3.Location = new System.Drawing.Point(11, 58);
 			label3.Name = "label3";
 			label3.Size = new System.Drawing.Size(47, 14);
 			label3.TabIndex = 3;
 			label3.Text = "Position
 			// 
 			// label2
 			// 
 			label2.AutoSize = true;
 			label2.Location = new System.Drawing.Point(17, 39);
 			label2.Name = "label2";
 			label2.Size = new System.Drawing.Size(41, 14);
 			label2.TabIndex = 2;
 			label2.Text = "Action
 			// 
 			// label1
 			// 
 			label1.AutoSize = true;
 			label1.Location = new System.Drawing.Point(24, 19);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(34, 14);
 			label1.TabIndex = 0;
 			label1.Text = "Type
 			// 
 			// infopanel
 			// 
 			this.infopanel.Controls.Add(this.arg5);
 			this.infopanel.Controls.Add(this.arglbl5);
 			this.infopanel.Controls.Add(this.arglbl4);
 			this.infopanel.Controls.Add(this.arg4);
 			this.infopanel.Controls.Add(this.arglbl3);
 			this.infopanel.Controls.Add(this.arglbl2);
 			this.infopanel.Controls.Add(this.arg3);
 			this.infopanel.Controls.Add(this.arglbl1);
 			this.infopanel.Controls.Add(this.arg2);
 			this.infopanel.Controls.Add(this.arg1);
 			this.infopanel.Controls.Add(this.angle);
 			this.infopanel.Controls.Add(label5);
 			this.infopanel.Controls.Add(this.tag);
 			this.infopanel.Controls.Add(this.position);
 			this.infopanel.Controls.Add(this.action);
 			this.infopanel.Controls.Add(label4);
 			this.infopanel.Controls.Add(label3);
 			this.infopanel.Controls.Add(label2);
 			this.infopanel.Controls.Add(this.type);
 			this.infopanel.Controls.Add(label1);
 			this.infopanel.Location = new System.Drawing.Point(0, 0);
 			this.infopanel.Name = "infopanel";
 			this.infopanel.Size = new System.Drawing.Size(473, 100);
 			this.infopanel.TabIndex = 4;
 			this.infopanel.TabStop = false;
 			this.infopanel.Text = " Thing ";
 			// 
 			// arg5
 			// 
 			this.arg5.AutoEllipsis = true;
 			this.arg5.Location = new System.Drawing.Point(384, 79);
 			this.arg5.Name = "arg5";
 			this.arg5.Size = new System.Drawing.Size(83, 14);
 			this.arg5.TabIndex = 37;
 			this.arg5.Text = "Arg 1
 			// 
 			// arglbl5
 			// 
 			this.arglbl5.AutoEllipsis = true;
 			this.arglbl5.BackColor = System.Drawing.Color.Transparent;
 			this.arglbl5.Location = new System.Drawing.Point(257, 79);
 			this.arglbl5.Name = "arglbl5";
 			this.arglbl5.Size = new System.Drawing.Size(121, 14);
 			this.arglbl5.TabIndex = 32;
 			this.arglbl5.Text = "Arg 1
 			this.arglbl5.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			// 
 			// arglbl4
 			// 
 			this.arglbl4.AutoEllipsis = true;
 			this.arglbl4.BackColor = System.Drawing.Color.Transparent;
 			this.arglbl4.Location = new System.Drawing.Point(257, 64);
 			this.arglbl4.Name = "arglbl4";
 			this.arglbl4.Size = new System.Drawing.Size(121, 14);
 			this.arglbl4.TabIndex = 31;
 			this.arglbl4.Text = "Arg 1
 			this.arglbl4.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			// 
 			// arg4
 			// 
 			this.arg4.AutoEllipsis = true;
 			this.arg4.Location = new System.Drawing.Point(384, 64);
 			this.arg4.Name = "arg4";
 			this.arg4.Size = new System.Drawing.Size(83, 14);
 			this.arg4.TabIndex = 36;
 			this.arg4.Text = "Arg 1
 			// 
 			// arglbl3
 			// 
 			this.arglbl3.AutoEllipsis = true;
 			this.arglbl3.BackColor = System.Drawing.Color.Transparent;
 			this.arglbl3.Location = new System.Drawing.Point(257, 49);
 			this.arglbl3.Name = "arglbl3";
 			this.arglbl3.Size = new System.Drawing.Size(121, 14);
 			this.arglbl3.TabIndex = 30;
 			this.arglbl3.Text = "Arg 1
 			this.arglbl3.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			// 
 			// arglbl2
 			// 
 			this.arglbl2.AutoEllipsis = true;
 			this.arglbl2.BackColor = System.Drawing.Color.Transparent;
 			this.arglbl2.Location = new System.Drawing.Point(257, 34);
 			this.arglbl2.Name = "arglbl2";
 			this.arglbl2.Size = new System.Drawing.Size(121, 14);
 			this.arglbl2.TabIndex = 29;
 			this.arglbl2.Text = "Arg 1
 			this.arglbl2.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			// 
 			// arg3
 			// 
 			this.arg3.AutoEllipsis = true;
 			this.arg3.Location = new System.Drawing.Point(384, 49);
 			this.arg3.Name = "arg3";
 			this.arg3.Size = new System.Drawing.Size(83, 14);
 			this.arg3.TabIndex = 35;
 			this.arg3.Text = "Arg 1
 			// 
 			// arglbl1
 			// 
 			this.arglbl1.AutoEllipsis = true;
 			this.arglbl1.BackColor = System.Drawing.Color.Transparent;
 			this.arglbl1.Location = new System.Drawing.Point(257, 19);
 			this.arglbl1.Name = "arglbl1";
 			this.arglbl1.Size = new System.Drawing.Size(121, 14);
 			this.arglbl1.TabIndex = 28;
 			this.arglbl1.Text = "Arg 1
 			this.arglbl1.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			// 
 			// arg2
 			// 
 			this.arg2.AutoEllipsis = true;
 			this.arg2.Location = new System.Drawing.Point(384, 34);
 			this.arg2.Name = "arg2";
 			this.arg2.Size = new System.Drawing.Size(83, 14);
 			this.arg2.TabIndex = 34;
 			this.arg2.Text = "Arg 1
 			// 
 			// arg1
 			// 
 			this.arg1.AutoEllipsis = true;
 			this.arg1.Location = new System.Drawing.Point(384, 19);
 			this.arg1.Name = "arg1";
 			this.arg1.Size = new System.Drawing.Size(83, 14);
 			this.arg1.TabIndex = 33;
 			this.arg1.Text = "Arg 1
 			// 
 			// angle
 			// 
 			this.angle.AutoSize = true;
 			this.angle.Location = new System.Drawing.Point(206, 77);
 			this.angle.Name = "angle";
 			this.angle.Size = new System.Drawing.Size(13, 14);
 			this.angle.TabIndex = 11;
 			this.angle.Text = "0";
 			// 
 			// tag
 			// 
 			this.tag.AutoSize = true;
 			this.tag.Location = new System.Drawing.Point(61, 77);
 			this.tag.Name = "tag";
 			this.tag.Size = new System.Drawing.Size(13, 14);
 			this.tag.TabIndex = 7;
 			this.tag.Text = "0";
 			// 
 			// position
 			// 
 			this.position.AutoSize = true;
 			this.position.Location = new System.Drawing.Point(61, 58);
 			this.position.Name = "position";
 			this.position.Size = new System.Drawing.Size(91, 14);
 			this.position.TabIndex = 6;
 			this.position.Text = "1024, 1024, 1024";
 			// 
 			// action
 			// 
 			this.action.AutoEllipsis = true;
 			this.action.Location = new System.Drawing.Point(61, 39);
 			this.action.Name = "action";
 			this.action.Size = new System.Drawing.Size(210, 14);
 			this.action.TabIndex = 5;
 			this.action.Text = "0 - Spawn a Blue Poopie and Ammo";
 			// 
 			// type
 			// 
 			this.type.AutoSize = true;
 			this.type.Location = new System.Drawing.Point(61, 19);
 			this.type.Name = "type";
 			this.type.Size = new System.Drawing.Size(99, 14);
 			this.type.TabIndex = 1;
 			this.type.Text = "0 - Big Brown Pimp";
 			// 
 			// spritepanel
 			// 
 			this.spritepanel.Controls.Add(this.spritename);
 			this.spritepanel.Controls.Add(this.spritetex);
 			this.spritepanel.Location = new System.Drawing.Point(479, 0);
 			this.spritepanel.Name = "spritepanel";
 			this.spritepanel.Size = new System.Drawing.Size(107, 100);
 			this.spritepanel.TabIndex = 5;
 			this.spritepanel.TabStop = false;
 			this.spritepanel.Text = " Sprite ";
 			// 
 			// spritename
 			// 
 			this.spritename.Location = new System.Drawing.Point(11, 80);
 			this.spritename.Name = "spritename";
 			this.spritename.Size = new System.Drawing.Size(84, 13);
 			this.spritename.TabIndex = 1;
 			this.spritename.Text = "BROWNHUG";
 			this.spritename.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// spritetex
 			// 
 			this.spritetex.BackColor = System.Drawing.SystemColors.AppWorkspace;
 			this.spritetex.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Zoom;
 			this.spritetex.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.spritetex.Location = new System.Drawing.Point(19, 19);
 			this.spritetex.Name = "spritetex";
 			this.spritetex.Size = new System.Drawing.Size(68, 60);
 			this.spritetex.TabIndex = 0;
 			// 
 			// ThingInfoPanel
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.Controls.Add(this.spritepanel);
 			this.Controls.Add(this.infopanel);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.MaximumSize = new System.Drawing.Size(10000, 100);
 			this.MinimumSize = new System.Drawing.Size(100, 100);
 			this.Name = "ThingInfoPanel";
 			this.Size = new System.Drawing.Size(650, 100);
 			this.infopanel.ResumeLayout(false);
 			this.infopanel.PerformLayout();
 			this.spritepanel.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScriptEditorPanel.Designer.cs" startline="22" endline="372">
<![CDATA[
 
 		#region Component Designer generated code
 
 		/// <summary> 
 		/// Required method for Designer support - do not modify 
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ScriptEditorPanel));
 			this.tabs = new System.Windows.Forms.TabControl();
 			this.toolbar = new System.Windows.Forms.ToolStrip();
 			this.buttonnew = new System.Windows.Forms.ToolStripDropDownButton();
 			this.buttonopen = new System.Windows.Forms.ToolStripButton();
 			this.buttonsave = new System.Windows.Forms.ToolStripButton();
 			this.buttonsaveall = new System.Windows.Forms.ToolStripButton();
 			this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
 			this.buttonundo = new System.Windows.Forms.ToolStripButton();
 			this.buttonredo = new System.Windows.Forms.ToolStripButton();
 			this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
 			this.buttoncut = new System.Windows.Forms.ToolStripButton();
 			this.buttoncopy = new System.Windows.Forms.ToolStripButton();
 			this.buttonpaste = new System.Windows.Forms.ToolStripButton();
 			this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
 			this.buttonscriptconfig = new System.Windows.Forms.ToolStripDropDownButton();
 			this.buttoncompile = new System.Windows.Forms.ToolStripButton();
 			this.buttonclose = new System.Windows.Forms.ToolStripButton();
 			this.buttonkeywordhelp = new System.Windows.Forms.ToolStripButton();
 			this.openfile = new System.Windows.Forms.OpenFileDialog();
 			this.savefile = new System.Windows.Forms.SaveFileDialog();
 			this.splitter = new System.Windows.Forms.SplitContainer();
 			this.label1 = new System.Windows.Forms.Label();
 			this.errorlist = new System.Windows.Forms.ListView();
 			this.colIndex = new System.Windows.Forms.ColumnHeader();
 			this.colDescription = new System.Windows.Forms.ColumnHeader();
 			this.colFile = new System.Windows.Forms.ColumnHeader();
 			this.errorimages = new System.Windows.Forms.ImageList(this.components);
 			this.toolbar.SuspendLayout();
 			this.splitter.Panel1.SuspendLayout();
 			this.splitter.Panel2.SuspendLayout();
 			this.splitter.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// tabs
 			// 
 			this.tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tabs.Location = new System.Drawing.Point(3, 8);
 			this.tabs.Margin = new System.Windows.Forms.Padding(3, 8, 3, 3);
 			this.tabs.Name = "tabs";
 			this.tabs.Padding = new System.Drawing.Point(12, 3);
 			this.tabs.SelectedIndex = 0;
 			this.tabs.Size = new System.Drawing.Size(720, 401);
 			this.tabs.TabIndex = 0;
 			this.tabs.TabStop = false;
 			this.tabs.Selecting += new System.Windows.Forms.TabControlCancelEventHandler(this.tabs_Selecting);
 			this.tabs.MouseUp += new System.Windows.Forms.MouseEventHandler(this.tabs_MouseUp);
 			// 
 			// toolbar
 			// 
 			this.toolbar.AllowMerge = false;
 			this.toolbar.GripStyle = System.Windows.Forms.ToolStripGripStyle.Hidden;
 			this.toolbar.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.buttonnew,
             this.buttonopen,
             this.buttonsave,
             this.buttonsaveall,
             this.toolStripSeparator1,
             this.buttonundo,
             this.buttonredo,
             this.toolStripSeparator2,
             this.buttoncut,
             this.buttoncopy,
             this.buttonpaste,
             this.toolStripSeparator3,
             this.buttonscriptconfig,
             this.buttoncompile,
             this.buttonclose,
             this.buttonkeywordhelp});
 			this.toolbar.Location = new System.Drawing.Point(0, 0);
 			this.toolbar.Name = "toolbar";
 			this.toolbar.Size = new System.Drawing.Size(726, 25);
 			this.toolbar.TabIndex = 1;
 			// 
 			// buttonnew
 			// 
 			this.buttonnew.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonnew.Image = global
 			this.buttonnew.ImageScaling = System.Windows.Forms.ToolStripItemImageScaling.None;
 			this.buttonnew.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonnew.Margin = new System.Windows.Forms.Padding(6, 1, 0, 2);
 			this.buttonnew.Name = "buttonnew";
 			this.buttonnew.Size = new System.Drawing.Size(29, 22);
 			this.buttonnew.Text = "New File";
 			// 
 			// buttonopen
 			// 
 			this.buttonopen.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonopen.Image = global
 			this.buttonopen.ImageScaling = System.Windows.Forms.ToolStripItemImageScaling.None;
 			this.buttonopen.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonopen.Margin = new System.Windows.Forms.Padding(3, 1, 0, 2);
 			this.buttonopen.Name = "buttonopen";
 			this.buttonopen.Size = new System.Drawing.Size(23, 22);
 			this.buttonopen.Text = "Open File";
 			this.buttonopen.Click += new System.EventHandler(this.buttonopen_Click);
 			// 
 			// buttonsave
 			// 
 			this.buttonsave.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonsave.Enabled = false;
 			this.buttonsave.Image = global
 			this.buttonsave.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonsave.Name = "buttonsave";
 			this.buttonsave.Size = new System.Drawing.Size(23, 22);
 			this.buttonsave.Text = "Save File";
 			this.buttonsave.Click += new System.EventHandler(this.buttonsave_Click);
 			// 
 			// buttonsaveall
 			// 
 			this.buttonsaveall.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonsaveall.Enabled = false;
 			this.buttonsaveall.Image = global
 			this.buttonsaveall.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonsaveall.Name = "buttonsaveall";
 			this.buttonsaveall.Size = new System.Drawing.Size(23, 22);
 			this.buttonsaveall.Text = "Save All Files";
 			this.buttonsaveall.Click += new System.EventHandler(this.buttonsaveall_Click);
 			// 
 			// toolStripSeparator1
 			// 
 			this.toolStripSeparator1.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.toolStripSeparator1.Name = "toolStripSeparator1";
 			this.toolStripSeparator1.Size = new System.Drawing.Size(6, 25);
 			// 
 			// buttonundo
 			// 
 			this.buttonundo.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonundo.Image = global
 			this.buttonundo.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonundo.Name = "buttonundo";
 			this.buttonundo.Size = new System.Drawing.Size(23, 22);
 			this.buttonundo.Text = "Undo";
 			this.buttonundo.Click += new System.EventHandler(this.buttonundo_Click);
 			// 
 			// buttonredo
 			// 
 			this.buttonredo.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonredo.Image = global
 			this.buttonredo.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonredo.Name = "buttonredo";
 			this.buttonredo.Size = new System.Drawing.Size(23, 22);
 			this.buttonredo.Text = "Redo";
 			this.buttonredo.Click += new System.EventHandler(this.buttonredo_Click);
 			// 
 			// toolStripSeparator2
 			// 
 			this.toolStripSeparator2.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.toolStripSeparator2.Name = "toolStripSeparator2";
 			this.toolStripSeparator2.Size = new System.Drawing.Size(6, 25);
 			// 
 			// buttoncut
 			// 
 			this.buttoncut.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttoncut.Image = global
 			this.buttoncut.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttoncut.Name = "buttoncut";
 			this.buttoncut.Size = new System.Drawing.Size(23, 22);
 			this.buttoncut.Text = "Cut Selection";
 			this.buttoncut.Click += new System.EventHandler(this.buttoncut_Click);
 			// 
 			// buttoncopy
 			// 
 			this.buttoncopy.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttoncopy.Image = global
 			this.buttoncopy.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttoncopy.Name = "buttoncopy";
 			this.buttoncopy.Size = new System.Drawing.Size(23, 22);
 			this.buttoncopy.Text = "Copy Selection";
 			this.buttoncopy.Click += new System.EventHandler(this.buttoncopy_Click);
 			// 
 			// buttonpaste
 			// 
 			this.buttonpaste.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonpaste.Image = global
 			this.buttonpaste.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonpaste.Name = "buttonpaste";
 			this.buttonpaste.Size = new System.Drawing.Size(23, 22);
 			this.buttonpaste.Text = "Paste";
 			this.buttonpaste.Click += new System.EventHandler(this.buttonpaste_Click);
 			// 
 			// toolStripSeparator3
 			// 
 			this.toolStripSeparator3.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.toolStripSeparator3.Name = "toolStripSeparator3";
 			this.toolStripSeparator3.Size = new System.Drawing.Size(6, 25);
 			// 
 			// buttonscriptconfig
 			// 
 			this.buttonscriptconfig.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonscriptconfig.Enabled = false;
 			this.buttonscriptconfig.Image = global
 			this.buttonscriptconfig.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonscriptconfig.Name = "buttonscriptconfig";
 			this.buttonscriptconfig.Size = new System.Drawing.Size(29, 22);
 			this.buttonscriptconfig.Text = "Change Script Type";
 			// 
 			// buttoncompile
 			// 
 			this.buttoncompile.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttoncompile.Image = global
 			this.buttoncompile.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttoncompile.Margin = new System.Windows.Forms.Padding(3, 1, 0, 2);
 			this.buttoncompile.Name = "buttoncompile";
 			this.buttoncompile.Size = new System.Drawing.Size(23, 22);
 			this.buttoncompile.Text = "Compile Script";
 			this.buttoncompile.Click += new System.EventHandler(this.buttoncompile_Click);
 			// 
 			// buttonclose
 			// 
 			this.buttonclose.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
 			this.buttonclose.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonclose.Image = global
 			this.buttonclose.ImageScaling = System.Windows.Forms.ToolStripItemImageScaling.None;
 			this.buttonclose.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonclose.Name = "buttonclose";
 			this.buttonclose.Size = new System.Drawing.Size(23, 22);
 			this.buttonclose.Text = "Close File";
 			this.buttonclose.Click += new System.EventHandler(this.buttonclose_Click);
 			// 
 			// buttonkeywordhelp
 			// 
 			this.buttonkeywordhelp.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
 			this.buttonkeywordhelp.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonkeywordhelp.Image = global
 			this.buttonkeywordhelp.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonkeywordhelp.Name = "buttonkeywordhelp";
 			this.buttonkeywordhelp.Size = new System.Drawing.Size(23, 22);
 			this.buttonkeywordhelp.Text = "Keyword Help";
 			this.buttonkeywordhelp.Click += new System.EventHandler(this.buttonkeywordhelp_Click);
 			// 
 			// openfile
 			// 
 			this.openfile.Title = "Open Script";
 			// 
 			// savefile
 			// 
 			this.savefile.Title = "Save Script As";
 			// 
 			// splitter
 			// 
 			this.splitter.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.splitter.FixedPanel = System.Windows.Forms.FixedPanel.Panel2;
 			this.splitter.IsSplitterFixed = true;
 			this.splitter.Location = new System.Drawing.Point(0, 25);
 			this.splitter.Name = "splitter";
 			this.splitter.Orientation = System.Windows.Forms.Orientation.Horizontal;
 			// 
 			// splitter.Panel1
 			// 
 			this.splitter.Panel1.Controls.Add(this.tabs);
 			// 
 			// splitter.Panel2
 			// 
 			this.splitter.Panel2.Controls.Add(this.label1);
 			this.splitter.Panel2.Controls.Add(this.errorlist);
 			this.splitter.Size = new System.Drawing.Size(726, 538);
 			this.splitter.SplitterDistance = 412;
 			this.splitter.TabIndex = 2;
 			this.splitter.TabStop = false;
 			// 
 			// label1
 			// 
 			this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.label1.BackColor = System.Drawing.SystemColors.ActiveCaption;
 			this.label1.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.label1.ForeColor = System.Drawing.SystemColors.ActiveCaptionText;
 			this.label1.Location = new System.Drawing.Point(3, 0);
 			this.label1.Name = "label1";
 			this.label1.Padding = new System.Windows.Forms.Padding(1);
 			this.label1.Size = new System.Drawing.Size(720, 16);
 			this.label1.TabIndex = 1;
 			this.label1.Text = "Errors";
 			// 
 			// errorlist
 			// 
 			this.errorlist.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.errorlist.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.colIndex,
             this.colDescription,
             this.colFile});
 			this.errorlist.FullRowSelect = true;
 			this.errorlist.GridLines = true;
 			this.errorlist.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
 			this.errorlist.LabelWrap = false;
 			this.errorlist.Location = new System.Drawing.Point(3, 19);
 			this.errorlist.MultiSelect = false;
 			this.errorlist.Name = "errorlist";
 			this.errorlist.ShowGroups = false;
 			this.errorlist.Size = new System.Drawing.Size(720, 100);
 			this.errorlist.SmallImageList = this.errorimages;
 			this.errorlist.TabIndex = 0;
 			this.errorlist.TabStop = false;
 			this.errorlist.UseCompatibleStateImageBehavior = false;
 			this.errorlist.View = System.Windows.Forms.View.Details;
 			this.errorlist.ItemActivate += new System.EventHandler(this.errorlist_ItemActivate);
 			// 
 			// colIndex
 			// 
 			this.colIndex.Text = "";
 			this.colIndex.Width = 45;
 			// 
 			// colDescription
 			// 
 			this.colDescription.Text = "Description";
 			this.colDescription.Width = 500;
 			// 
 			// colFile
 			// 
 			this.colFile.Text = "File";
 			this.colFile.Width = 150;
 			// 
 			// errorimages
 			// 
 			this.errorimages.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("errorimages.ImageStream")));
 			this.errorimages.TransparentColor = System.Drawing.Color.Transparent;
 			this.errorimages.Images.SetKeyName(0, "ScriptError3.png");
 			// 
 			// ScriptEditorPanel
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.BackColor = System.Drawing.SystemColors.Control;
 			this.Controls.Add(this.splitter);
 			this.Controls.Add(this.toolbar);
 			this.Name = "ScriptEditorPanel";
 			this.Size = new System.Drawing.Size(726, 563);
 			this.toolbar.ResumeLayout(false);
 			this.toolbar.PerformLayout();
 			this.splitter.Panel1.ResumeLayout(false);
 			this.splitter.Panel2.ResumeLayout(false);
 			this.splitter.ResumeLayout(false);
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="288" endline="304">
<![CDATA[
 
 		// This returns a normalized vector
 		public Vector2D GetNormal()
 		{
 			float lensq = this.GetLengthSq();
 			if(lensq > TINY_VALUE)
 			{
 				// Divide each element by the length
 				float mul = 1f / (float)Math.Sqrt(lensq);
 				return new Vector2D(x * mul, y * mul);
 			}
 			else
 			{
 				// Cannot make normal
 				return new Vector2D(0f, 0f);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\EffectBrowserForm.Designer.cs" startline="22" endline="367">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.GroupBox groupBox2;
 			this.option7 = new System.Windows.Forms.ComboBox();
 			this.option7label = new System.Windows.Forms.Label();
 			this.option6 = new System.Windows.Forms.ComboBox();
 			this.option6label = new System.Windows.Forms.Label();
 			this.option5 = new System.Windows.Forms.ComboBox();
 			this.option5label = new System.Windows.Forms.Label();
 			this.option4 = new System.Windows.Forms.ComboBox();
 			this.option4label = new System.Windows.Forms.Label();
 			this.option3 = new System.Windows.Forms.ComboBox();
 			this.option3label = new System.Windows.Forms.Label();
 			this.option2 = new System.Windows.Forms.ComboBox();
 			this.option2label = new System.Windows.Forms.Label();
 			this.option1 = new System.Windows.Forms.ComboBox();
 			this.option1label = new System.Windows.Forms.Label();
 			this.option0 = new System.Windows.Forms.ComboBox();
 			this.option0label = new System.Windows.Forms.Label();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.tabs = new System.Windows.Forms.TabControl();
 			this.tabeffects = new System.Windows.Forms.TabPage();
 			this.effects = new System.Windows.Forms.ListView();
 			this.colnumber = new System.Windows.Forms.ColumnHeader();
 			this.colname = new System.Windows.Forms.ColumnHeader();
 			this.tabgeneralized = new System.Windows.Forms.TabPage();
 			groupBox2 = new System.Windows.Forms.GroupBox();
 			groupBox2.SuspendLayout();
 			this.tabs.SuspendLayout();
 			this.tabeffects.SuspendLayout();
 			this.tabgeneralized.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// groupBox2
 			// 
 			groupBox2.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			groupBox2.Controls.Add(this.option7);
 			groupBox2.Controls.Add(this.option7label);
 			groupBox2.Controls.Add(this.option6);
 			groupBox2.Controls.Add(this.option6label);
 			groupBox2.Controls.Add(this.option5);
 			groupBox2.Controls.Add(this.option5label);
 			groupBox2.Controls.Add(this.option4);
 			groupBox2.Controls.Add(this.option4label);
 			groupBox2.Controls.Add(this.option3);
 			groupBox2.Controls.Add(this.option3label);
 			groupBox2.Controls.Add(this.option2);
 			groupBox2.Controls.Add(this.option2label);
 			groupBox2.Controls.Add(this.option1);
 			groupBox2.Controls.Add(this.option1label);
 			groupBox2.Controls.Add(this.option0);
 			groupBox2.Controls.Add(this.option0label);
 			groupBox2.Location = new System.Drawing.Point(6, 6);
 			groupBox2.Name = "groupBox2";
 			groupBox2.Size = new System.Drawing.Size(379, 397);
 			groupBox2.TabIndex = 1;
 			groupBox2.TabStop = false;
 			groupBox2.Text = " Options ";
 			// 
 			// option7
 			// 
 			this.option7.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option7.FormattingEnabled = true;
 			this.option7.Location = new System.Drawing.Point(118, 280);
 			this.option7.Name = "option7";
 			this.option7.Size = new System.Drawing.Size(199, 22);
 			this.option7.TabIndex = 7;
 			this.option7.Visible = false;
 			// 
 			// option7label
 			// 
 			this.option7label.Location = new System.Drawing.Point(3, 283);
 			this.option7label.Name = "option7label";
 			this.option7label.Size = new System.Drawing.Size(109, 19);
 			this.option7label.TabIndex = 16;
 			this.option7label.Text = "Option
 			this.option7label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option7label.Visible = false;
 			// 
 			// option6
 			// 
 			this.option6.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option6.FormattingEnabled = true;
 			this.option6.Location = new System.Drawing.Point(118, 244);
 			this.option6.Name = "option6";
 			this.option6.Size = new System.Drawing.Size(199, 22);
 			this.option6.TabIndex = 6;
 			this.option6.Visible = false;
 			// 
 			// option6label
 			// 
 			this.option6label.Location = new System.Drawing.Point(3, 247);
 			this.option6label.Name = "option6label";
 			this.option6label.Size = new System.Drawing.Size(109, 19);
 			this.option6label.TabIndex = 14;
 			this.option6label.Text = "Option
 			this.option6label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option6label.Visible = false;
 			// 
 			// option5
 			// 
 			this.option5.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option5.FormattingEnabled = true;
 			this.option5.Location = new System.Drawing.Point(118, 208);
 			this.option5.Name = "option5";
 			this.option5.Size = new System.Drawing.Size(199, 22);
 			this.option5.TabIndex = 5;
 			this.option5.Visible = false;
 			// 
 			// option5label
 			// 
 			this.option5label.Location = new System.Drawing.Point(3, 211);
 			this.option5label.Name = "option5label";
 			this.option5label.Size = new System.Drawing.Size(109, 19);
 			this.option5label.TabIndex = 12;
 			this.option5label.Text = "Option
 			this.option5label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option5label.Visible = false;
 			// 
 			// option4
 			// 
 			this.option4.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option4.FormattingEnabled = true;
 			this.option4.Location = new System.Drawing.Point(118, 172);
 			this.option4.Name = "option4";
 			this.option4.Size = new System.Drawing.Size(199, 22);
 			this.option4.TabIndex = 4;
 			this.option4.Visible = false;
 			// 
 			// option4label
 			// 
 			this.option4label.Location = new System.Drawing.Point(3, 175);
 			this.option4label.Name = "option4label";
 			this.option4label.Size = new System.Drawing.Size(109, 19);
 			this.option4label.TabIndex = 10;
 			this.option4label.Text = "Option
 			this.option4label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option4label.Visible = false;
 			// 
 			// option3
 			// 
 			this.option3.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option3.FormattingEnabled = true;
 			this.option3.Location = new System.Drawing.Point(118, 136);
 			this.option3.Name = "option3";
 			this.option3.Size = new System.Drawing.Size(199, 22);
 			this.option3.TabIndex = 3;
 			this.option3.Visible = false;
 			// 
 			// option3label
 			// 
 			this.option3label.Location = new System.Drawing.Point(3, 139);
 			this.option3label.Name = "option3label";
 			this.option3label.Size = new System.Drawing.Size(109, 19);
 			this.option3label.TabIndex = 8;
 			this.option3label.Text = "Option
 			this.option3label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option3label.Visible = false;
 			// 
 			// option2
 			// 
 			this.option2.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option2.FormattingEnabled = true;
 			this.option2.Location = new System.Drawing.Point(118, 100);
 			this.option2.Name = "option2";
 			this.option2.Size = new System.Drawing.Size(199, 22);
 			this.option2.TabIndex = 2;
 			this.option2.Visible = false;
 			// 
 			// option2label
 			// 
 			this.option2label.Location = new System.Drawing.Point(3, 103);
 			this.option2label.Name = "option2label";
 			this.option2label.Size = new System.Drawing.Size(109, 19);
 			this.option2label.TabIndex = 6;
 			this.option2label.Text = "Option
 			this.option2label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option2label.Visible = false;
 			// 
 			// option1
 			// 
 			this.option1.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option1.FormattingEnabled = true;
 			this.option1.Location = new System.Drawing.Point(118, 64);
 			this.option1.Name = "option1";
 			this.option1.Size = new System.Drawing.Size(199, 22);
 			this.option1.TabIndex = 1;
 			this.option1.Visible = false;
 			// 
 			// option1label
 			// 
 			this.option1label.Location = new System.Drawing.Point(3, 67);
 			this.option1label.Name = "option1label";
 			this.option1label.Size = new System.Drawing.Size(109, 19);
 			this.option1label.TabIndex = 4;
 			this.option1label.Text = "Option
 			this.option1label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option1label.Visible = false;
 			// 
 			// option0
 			// 
 			this.option0.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option0.FormattingEnabled = true;
 			this.option0.Location = new System.Drawing.Point(118, 28);
 			this.option0.Name = "option0";
 			this.option0.Size = new System.Drawing.Size(199, 22);
 			this.option0.TabIndex = 0;
 			this.option0.Visible = false;
 			// 
 			// option0label
 			// 
 			this.option0label.Location = new System.Drawing.Point(3, 31);
 			this.option0label.Name = "option0label";
 			this.option0label.Size = new System.Drawing.Size(109, 19);
 			this.option0label.TabIndex = 2;
 			this.option0label.Text = "Option
 			this.option0label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option0label.Visible = false;
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(297, 459);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 27);
 			this.cancel.TabIndex = 2;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(177, 459);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 27);
 			this.apply.TabIndex = 1;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// tabs
 			// 
 			this.tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tabs.Controls.Add(this.tabeffects);
 			this.tabs.Controls.Add(this.tabgeneralized);
 			this.tabs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabs.ItemSize = new System.Drawing.Size(150, 19);
 			this.tabs.Location = new System.Drawing.Point(10, 10);
 			this.tabs.Margin = new System.Windows.Forms.Padding(1);
 			this.tabs.Name = "tabs";
 			this.tabs.SelectedIndex = 0;
 			this.tabs.Size = new System.Drawing.Size(399, 436);
 			this.tabs.SizeMode = System.Windows.Forms.TabSizeMode.Fixed;
 			this.tabs.TabIndex = 0;
 			// 
 			// tabeffects
 			// 
 			this.tabeffects.Controls.Add(this.effects);
 			this.tabeffects.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabeffects.Location = new System.Drawing.Point(4, 23);
 			this.tabeffects.Name = "tabeffects";
 			this.tabeffects.Padding = new System.Windows.Forms.Padding(3);
 			this.tabeffects.Size = new System.Drawing.Size(391, 409);
 			this.tabeffects.TabIndex = 0;
 			this.tabeffects.Text = "Predefined Effects";
 			this.tabeffects.UseVisualStyleBackColor = true;
 			// 
 			// effects
 			// 
 			this.effects.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.colnumber,
             this.colname});
 			this.effects.FullRowSelect = true;
 			this.effects.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
 			this.effects.HideSelection = false;
 			this.effects.Location = new System.Drawing.Point(6, 6);
 			this.effects.MultiSelect = false;
 			this.effects.Name = "effects";
 			this.effects.Size = new System.Drawing.Size(379, 397);
 			this.effects.TabIndex = 0;
 			this.effects.UseCompatibleStateImageBehavior = false;
 			this.effects.View = System.Windows.Forms.View.Details;
 			this.effects.DoubleClick += new System.EventHandler(this.effects_DoubleClick);
 			// 
 			// colnumber
 			// 
 			this.colnumber.Text = "Effect";
 			this.colnumber.Width = 70;
 			// 
 			// colname
 			// 
 			this.colname.Text = "Description";
 			this.colname.Width = 280;
 			// 
 			// tabgeneralized
 			// 
 			this.tabgeneralized.Controls.Add(groupBox2);
 			this.tabgeneralized.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabgeneralized.Location = new System.Drawing.Point(4, 23);
 			this.tabgeneralized.Name = "tabgeneralized";
 			this.tabgeneralized.Padding = new System.Windows.Forms.Padding(3);
 			this.tabgeneralized.Size = new System.Drawing.Size(391, 409);
 			this.tabgeneralized.TabIndex = 1;
 			this.tabgeneralized.Text = "Generalized Effects";
 			this.tabgeneralized.UseVisualStyleBackColor = true;
 			// 
 			// EffectBrowserForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(419, 496);
 			this.Controls.Add(this.tabs);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "EffectBrowserForm";
 			this.Opacity = 0;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Edit Effect";
 			groupBox2.ResumeLayout(false);
 			this.tabs.ResumeLayout(false);
 			this.tabeffects.ResumeLayout(false);
 			this.tabgeneralized.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="1075" endline="1108">
<![CDATA[
 
 		// Mouse up
 		private void display_MouseUp(object sender, MouseEventArgs e)
 		{
 			int key = 0;
 			
 			int mod = 0;
 			if(alt) mod |= (int)Keys.Alt;
 			if(shift) mod |= (int)Keys.Shift;
 			if(ctrl) mod |= (int)Keys.Control;
 			
 			// Apply button
 			mousebuttons &= ~e.Button;
 			
 			// Create key
 			switch(e.Button)
 			{
 				case MouseButtons.Left
 				case MouseButtons.Middle
 				case MouseButtons.Right
 				case MouseButtons.XButton1
 				case MouseButtons.XButton2
 			}
 			
 			// Invoke any actions associated with this key
 			General.Actions.KeyReleased(key | mod);
 
 			// Invoke on editing mode
 			if((General.Map != null) && (General.Editing.Mode != null))
 			{
 				General.Plugins.OnEditMouseUp(e);
 				General.Editing.Mode.OnMouseUp(e);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalStreamReader.cs" startline="326" endline="369">
<![CDATA[
 
 		// This reads the sectors
 		private Dictionary<int, Sector> ReadSectors(MapSet map, UniversalParser textmap)
 		{
 			Dictionary<int, Sector> link;
 
 			// Get list of entries
 			List<UniversalCollection> collections = GetNamedCollections(textmap.Root, "sector");
 
 			// Create lookup table
 			link = new Dictionary<int, Sector>(collections.Count);
 
 			// Go for all collections
 			map.SetCapacity(0, 0, 0, map.Sectors.Count + collections.Count, 0);
 			for(int i = 0; i < collections.Count; i++)
 			{
 				// Read fields
 				UniversalCollection c = collections[i];
 				string where = "sector " + i;
 				int hfloor = GetCollectionEntry<int>(c, "heightfloor", false, 0, where);
 				int hceil = GetCollectionEntry<int>(c, "heightceiling", false, 0, where);
 				string tfloor = GetCollectionEntry<string>(c, "texturefloor", true, "-", where);
 				string tceil = GetCollectionEntry<string>(c, "textureceiling", true, "-", where);
 				int bright = GetCollectionEntry<int>(c, "lightlevel", false, 160, where);
 				int special = GetCollectionEntry<int>(c, "special", false, 0, where);
 				int tag = GetCollectionEntry<int>(c, "id", false, 0, where);
 
 				// Create new item
 				Sector s = map.CreateSector();
 				if(s != null)
 				{
 					s.Update(hfloor, hceil, tfloor, tceil, special, tag, bright);
 
 					// Custom fields
 					ReadCustomFields(c, s, "sector");
 
 					// Add it to the lookup table
 					link.Add(i, s);
 				}
 			}
 			for(int i = 0; i < collections.Count; i++)
 			{
 				// Read fields
 				UniversalCollection c = collections[i];
 				string where = "sector " + i;
 				int hfloor = GetCollectionEntry<int>(c, "heightfloor", false, 0, where);
 				int hceil = GetCollectionEntry<int>(c, "heightceiling", false, 0, where);
 				string tfloor = GetCollectionEntry<string>(c, "texturefloor", true, "-", where);
 				string tceil = GetCollectionEntry<string>(c, "textureceiling", true, "-", where);
 				int bright = GetCollectionEntry<int>(c, "lightlevel", false, 160, where);
 				int special = GetCollectionEntry<int>(c, "special", false, 0, where);
 				int tag = GetCollectionEntry<int>(c, "id", false, 0, where);
 
 				// Create new item
 				Sector s = map.CreateSector();
 				if(s != null)
 				{
 					s.Update(hfloor, hceil, tfloor, tceil, special, tag, bright);
 
 					// Custom fields
 					ReadCustomFields(c, s, "sector");
 
 					// Add it to the lookup table
 					link.Add(i, s);
 				}
 			}
 
 			// Return lookup table
 			return link;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\StepsList.cs" startline="37" endline="53">
<![CDATA[
 		{
 			int low = 0;
 			int high = base.Count - 1;
 
 			while(low < high)
 			{
 				int mid = (int)Math.Floor((float)(low + high) * 0.5f);
 				int l = base[mid];
 
 				if(l <= level)
 					low = mid + 1;
 				else
 					high = mid;
 			}
 			while(low < high)
 			{
 				int mid = (int)Math.Floor((float)(low + high) * 0.5f);
 				int l = base[mid];
 
 				if(l <= level)
 					low = mid + 1;
 				else
 					high = mid;
 			}
 			
 			return base[high];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\EditMode.cs" startline="113" endline="137">
<![CDATA[
 
 		#endregion
 
 		#region ================== Static Methods
 
 		// This creates an instance of a specific mode
 		public static EditMode Create(Type modetype, object[] args)
 		{
 			try
 			{
 				// Create new mode
 				return (EditMode)General.ThisAssembly.CreateInstance(modetype.FullName, false,
 					BindingFlags.Default, null, args, CultureInfo.CurrentCulture, new object[0]);
 			}
 			// Catch errors
 			catch(TargetInvocationException e)
 			{
 				// Throw the actual exception
 				Debug.WriteLine(DateTime.Now.ToShortDateString() + " " + DateTime.Now.ToShortTimeString());
 				Debug.WriteLine(e.InnerException.Source + " throws " + e.InnerException.GetType().Name + "
 				Debug.WriteLine(e.InnerException.Message);
 				Debug.WriteLine(e.InnerException.StackTrace);
 				throw e.InnerException;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="827" endline="864">
<![CDATA[
 
 		// This renders the crosshair
 		public void RenderCrosshair()
 		{
 			// Set renderstates
 			graphics.Device.SetRenderState(RenderState.CullMode, Cull.None);
 			graphics.Device.SetRenderState(RenderState.ZEnable, false);
 			graphics.Device.SetRenderState(RenderState.AlphaBlendEnable, true);
 			graphics.Device.SetRenderState(RenderState.AlphaTestEnable, false);
 			graphics.Device.SetRenderState(RenderState.SourceBlend, Blend.SourceAlpha);
 			graphics.Device.SetRenderState(RenderState.DestinationBlend, Blend.InverseSourceAlpha);
 			graphics.Device.SetRenderState(RenderState.TextureFactor, -1);
 			graphics.Device.SetTransform(TransformState.World, Matrix.Identity);
 			graphics.Device.SetTransform(TransformState.Projection, Matrix.Identity);
 			ApplyMatrices2D();
 			
 			// Texture
 			if(crosshairbusy)
 			{
 				if(General.Map.Data.CrosshairBusy3D.Texture == null) General.Map.Data.CrosshairBusy3D.CreateTexture();
 				graphics.Device.SetTexture(0, General.Map.Data.CrosshairBusy3D.Texture);
 				graphics.Shaders.Display2D.Texture1 = General.Map.Data.CrosshairBusy3D.Texture;
 			}
 			else
 			{
 				if(General.Map.Data.Crosshair3D.Texture == null) General.Map.Data.Crosshair3D.CreateTexture();
 				graphics.Device.SetTexture(0, General.Map.Data.Crosshair3D.Texture);
 				graphics.Shaders.Display2D.Texture1 = General.Map.Data.Crosshair3D.Texture;
 			}
 			
 			// Draw
 			graphics.Shaders.Display2D.Begin();
 			graphics.Shaders.Display2D.SetSettings(1.0f, 1.0f, 0.0f, 1.0f, true);
 			graphics.Shaders.Display2D.BeginPass(1);
 			graphics.Device.DrawUserPrimitives<FlatVertex>(PrimitiveType.TriangleStrip, 0, 2, crosshairverts);
 			graphics.Shaders.Display2D.EndPass();
 			graphics.Shaders.Display2D.End();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ActorStructure.cs" startline="38" endline="354">
<![CDATA[
 		private readonly string[] SPRITE_POSTFIXES = new string[] {"2C8", "2D8", "2A8", "2B8", "1C1", "1D1", "1A1", "1B1", "A2", "A1", "A0", "2", "1", "0" };
 		
 		#endregion
 		
 		#region ================== Variables
 		
 		// Declaration
 		private string classname;
 		private string inheritclass;
 		private string replaceclass;
 		private int doomednum = -1;
 		
 		// Inheriting
 		private ActorStructure baseclass;
 		private bool skipsuper;
 		
 		// Flags
 		private Dictionary<string, bool> flags;
 		
 		// Properties
 		private Dictionary<string, List<string>> props;
 		
 		// States
 		private Dictionary<string, StateStructure> states;
 		
 		#endregion
 		
 		#region ================== Properties
 		
 		public Dictionary<string, bool> Flags { get { return flags; } }
 		public Dictionary<string, List<string>> Properties { get { return props; } }
 		public string ClassName { get { return classname; } }
 		public string InheritsClass { get { return inheritclass; } }
 		public string ReplacesClass { get { return replaceclass; } }
 		public ActorStructure BaseClass { get { return baseclass; } }
 		public int DoomEdNum { get { return doomednum; } }
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		internal ActorStructure(DecorateParser parser)
 		{
 			// Initialize
 			flags = new Dictionary<string, bool>();
 			props = new Dictionary<string, List<string>>();
 			states = new Dictionary<string, StateStructure>();
 			
 			// Always define a game property, but default to 0 values
 			props["game"] = new List<string>();
 			
 			inheritclass = "actor";
 			replaceclass = null;
 			baseclass = null;
 			skipsuper = false;
 			
 			// First next token is the class name
 			parser.SkipWhitespace(true);
 			classname = parser.StripTokenQuotes(parser.ReadToken());
 			if(string.IsNullOrEmpty(classname))
 			{
 				parser.ReportError("Expected actor class name");
 				return;
 			}
 
 			// Parse tokens before entering the actor scope
 			while(parser.SkipWhitespace(true))
 			{
 				string token = parser.ReadToken();
 				if(!string.IsNullOrEmpty(token))
 				{
 					token = token.ToLowerInvariant();
 					if(token == "
 					{
 						// The next token must be the class to inherit from
 						parser.SkipWhitespace(true);
 						inheritclass = parser.StripTokenQuotes(parser.ReadToken());
 						if(string.IsNullOrEmpty(inheritclass) || parser.IsSpecialToken(inheritclass))
 						{
 							parser.ReportError("Expected class name to inherit from");
 							return;
 						}
 						else
 						{
 							// Find the actor to inherit from
 							baseclass = parser.GetArchivedActorByName(inheritclass);
 							if(baseclass == null)
 								General.ErrorLogger.Add(ErrorType.Warning, "Unable to find the DECORATE class '" + inheritclass + "' to inherit from, while parsing '" + classname + "'");
 						}
 					}
 					else if(token == "replaces")
 					{
 						// The next token must be the class to replace
 						parser.SkipWhitespace(true);
 						replaceclass = parser.StripTokenQuotes(parser.ReadToken());
 						if(string.IsNullOrEmpty(replaceclass) || parser.IsSpecialToken(replaceclass))
 						{
 							parser.ReportError("Expected class name to replace");
 							return;
 						}
 					}
 					else if(token == "native")
 					{
 						// Igore this token
 					}
 					else if(token == "{")
 					{
 						// Actor scope begins here,
 						// break out of this parse loop
 						break;
 					}
 					else if(token == "-")
 					{
 						// This could be a negative doomednum (but our parser sees the - as separate token)
 						// So read whatever is after this token and ignore it (negative doomednum indicates no doomednum)
 						parser.ReadToken();
 					}
 					else
 					{
 						// Check if numeric
 						if(!int.TryParse(token, NumberStyles.Integer, CultureInfo.InvariantCulture, out doomednum))
 						{
 							// Not numeric!
 							parser.ReportError("Expected numeric editor thing number or start of actor scope");
 							return;
 						}
 					}
 				}
 				else
 				{
 					parser.ReportError("Unexpected end of structure");
 					return;
 				}
 			}
 			while(parser.SkipWhitespace(true))
 			{
 				string token = parser.ReadToken();
 				if(!string.IsNullOrEmpty(token))
 				{
 					token = token.ToLowerInvariant();
 					if(token == "
 					{
 						// The next token must be the class to inherit from
 						parser.SkipWhitespace(true);
 						inheritclass = parser.StripTokenQuotes(parser.ReadToken());
 						if(string.IsNullOrEmpty(inheritclass) || parser.IsSpecialToken(inheritclass))
 						{
 							parser.ReportError("Expected class name to inherit from");
 							return;
 						}
 						else
 						{
 							// Find the actor to inherit from
 							baseclass = parser.GetArchivedActorByName(inheritclass);
 							if(baseclass == null)
 								General.ErrorLogger.Add(ErrorType.Warning, "Unable to find the DECORATE class '" + inheritclass + "' to inherit from, while parsing '" + classname + "'");
 						}
 					}
 					else if(token == "replaces")
 					{
 						// The next token must be the class to replace
 						parser.SkipWhitespace(true);
 						replaceclass = parser.StripTokenQuotes(parser.ReadToken());
 						if(string.IsNullOrEmpty(replaceclass) || parser.IsSpecialToken(replaceclass))
 						{
 							parser.ReportError("Expected class name to replace");
 							return;
 						}
 					}
 					else if(token == "native")
 					{
 						// Igore this token
 					}
 					else if(token == "{")
 					{
 						// Actor scope begins here,
 						// break out of this parse loop
 						break;
 					}
 					else if(token == "-")
 					{
 						// This could be a negative doomednum (but our parser sees the - as separate token)
 						// So read whatever is after this token and ignore it (negative doomednum indicates no doomednum)
 						parser.ReadToken();
 					}
 					else
 					{
 						// Check if numeric
 						if(!int.TryParse(token, NumberStyles.Integer, CultureInfo.InvariantCulture, out doomednum))
 						{
 							// Not numeric!
 							parser.ReportError("Expected numeric editor thing number or start of actor scope");
 							return;
 						}
 					}
 				}
 				else
 				{
 					parser.ReportError("Unexpected end of structure");
 					return;
 				}
 			}
 			
 			// Now parse the contents of actor structure
 			string previoustoken = "";
 			while(parser.SkipWhitespace(true))
 			{
 				string token = parser.ReadToken();
 				token = token.ToLowerInvariant();
 
 				if((token == "+") || (token == "-"))
 				{
 					// Next token is a flag (option) to set or remove
 					bool flagvalue = (token == "+");
 					parser.SkipWhitespace(true);
 					string flagname = parser.ReadToken();
 					if(!string.IsNullOrEmpty(flagname))
 					{
 						// Add the flag with its value
 						flagname = flagname.ToLowerInvariant();
 						flags[flagname] = flagvalue;
 					}
 					else
 					{
 						parser.ReportError("Expected flag name");
 						return;
 					}
 				}
 				else if((token == "action") || (token == "native"))
 				{
 					// We don't need this, ignore up to the first next ;
 					while(parser.SkipWhitespace(true))
 					{
 						string t = parser.ReadToken();
 						if((t == ";") || (t == null)) break;
 					}
 					while(parser.SkipWhitespace(true))
 					{
 						string t = parser.ReadToken();
 						if((t == ";") || (t == null)) break;
 					}
 				}
 				else if(token == "skip_super")
 				{
 					skipsuper = true;
 				}
 				else if(token == "states")
 				{
 					// Now parse actor states until we reach the end of the states structure
 					while(parser.SkipWhitespace(true))
 					{
 						string statetoken = parser.ReadToken();
 						if(!string.IsNullOrEmpty(statetoken))
 						{
 							// Start of scope?
 							if(statetoken == "{")
 							{
 								// This is fine
 							}
 							// End of scope?
 							else if(statetoken == "}")
 							{
 								// Done with the states,
 								// break out of this parse loop
 								break;
 							}
 							// State label?
 							else if(statetoken == "
 							{
 								if(!string.IsNullOrEmpty(previoustoken))
 								{
 									// Parse actor state
 									StateStructure st = new StateStructure(this, parser, previoustoken);
 									if(parser.HasError) return;
 									states[previoustoken.ToLowerInvariant()] = st;
 								}
 								else
 								{
 									parser.ReportError("Unexpected end of structure");
 									return;
 								}
 							}
 							else
 							{
 								// Keep token
 								previoustoken = statetoken;
 							}
 						}
 						else
 						{
 							parser.ReportError("Unexpected end of structure");
 							return;
 						}
 					}
 					while(parser.SkipWhitespace(true))
 					{
 						string statetoken = parser.ReadToken();
 						if(!string.IsNullOrEmpty(statetoken))
 						{
 							// Start of scope?
 							if(statetoken == "{")
 							{
 								// This is fine
 							}
 							// End of scope?
 							else if(statetoken == "}")
 							{
 								// Done with the states,
 								// break out of this parse loop
 								break;
 							}
 							// State label?
 							else if(statetoken == "
 							{
 								if(!string.IsNullOrEmpty(previoustoken))
 								{
 									// Parse actor state
 									StateStructure st = new StateStructure(this, parser, previoustoken);
 									if(parser.HasError) return;
 									states[previoustoken.ToLowerInvariant()] = st;
 								}
 								else
 								{
 									parser.ReportError("Unexpected end of structure");
 									return;
 								}
 							}
 							else
 							{
 								// Keep token
 								previoustoken = statetoken;
 							}
 						}
 						else
 						{
 							parser.ReportError("Unexpected end of structure");
 							return;
 						}
 					}
 				}
 				else if(token == "}")
 				{
 					// Actor scope ends here,
 					// break out of this parse loop
 					break;
 				}
 				// Monster property?
 				else if(token == "monster")
 				{
 					// This sets certain flags we are interested in
 					flags["shootable"] = true;
 					flags["countkill"] = true;
 					flags["solid"] = true;
 					flags["canpushwalls"] = true;
 					flags["canusewalls"] = true;
 					flags["activatemcross"] = true;
 					flags["canpass"] = true;
 					flags["ismonster"] = true;
 				}
 				// Projectile property?
 				else if(token == "projectile")
 				{
 					// This sets certain flags we are interested in
 					flags["noblockmap"] = true;
 					flags["nogravity"] = true;
 					flags["dropoff"] = true;
 					flags["missile"] = true;
 					flags["activateimpact"] = true;
 					flags["activatepcross"] = true;
 					flags["noteleport"] = true;
 				}
 				// Clearflags property?
 				else if(token == "clearflags")
 				{
 					// Clear all flags
 					flags.Clear();
 				}
 				// Game property?
 				else if(token == "game")
 				{
 					// Include all tokens on the same line
 					List<string> games = new List<string>();
 					while(parser.SkipWhitespace(false))
 					{
 						string v = parser.ReadToken();
 						if(v == null)
 						{
 							parser.ReportError("Unexpected end of structure");
 							return;
 						}
 						if(v == "\n") break;
 						if(v != ",")
 							games.Add(v.ToLowerInvariant());
 					}
 					while(parser.SkipWhitespace(false))
 					{
 						string v = parser.ReadToken();
 						if(v == null)
 						{
 							parser.ReportError("Unexpected end of structure");
 							return;
 						}
 						if(v == "\n") break;
 						if(v != ",")
 							games.Add(v.ToLowerInvariant());
 					}
 					props[token] = games;
 				}
 				// Property
 				else
 				{
 					// Property begins with $? Then the whole line is a single value
 					if(token.StartsWith("$"))
 					{
 						// This is for editor-only properties such as $sprite and $category
 						List<string> values = new List<string>();
 						if(parser.SkipWhitespace(false))
 							values.Add(parser.ReadLine());
 						else
 							values.Add("");
 						props[token] = values;
 					}
 					else
 					{
 						// Next tokens up until the next newline are values
 						List<string> values = new List<string>();
 						while(parser.SkipWhitespace(false))
 						{
 							string v = parser.ReadToken();
 							if(v == null)
 							{
 								parser.ReportError("Unexpected end of structure");
 								return;
 							}
 							if(v == "\n") break;
 							if(v != ",")
 								values.Add(v);
 						}
 						while(parser.SkipWhitespace(false))
 						{
 							string v = parser.ReadToken();
 							if(v == null)
 							{
 								parser.ReportError("Unexpected end of structure");
 								return;
 							}
 							if(v == "\n") break;
 							if(v != ",")
 								values.Add(v);
 						}
 						props[token] = values;
 					}
 				}
 				
 				// Keep token
 				previoustoken = token;
 			}
 			while(parser.SkipWhitespace(true))
 			{
 				string token = parser.ReadToken();
 				token = token.ToLowerInvariant();
 
 				if((token == "+") || (token == "-"))
 				{
 					// Next token is a flag (option) to set or remove
 					bool flagvalue = (token == "+");
 					parser.SkipWhitespace(true);
 					string flagname = parser.ReadToken();
 					if(!string.IsNullOrEmpty(flagname))
 					{
 						// Add the flag with its value
 						flagname = flagname.ToLowerInvariant();
 						flags[flagname] = flagvalue;
 					}
 					else
 					{
 						parser.ReportError("Expected flag name");
 						return;
 					}
 				}
 				else if((token == "action") || (token == "native"))
 				{
 					// We don't need this, ignore up to the first next ;
 					while(parser.SkipWhitespace(true))
 					{
 						string t = parser.ReadToken();
 						if((t == ";") || (t == null)) break;
 					}
 				}
 				else if(token == "skip_super")
 				{
 					skipsuper = true;
 				}
 				else if(token == "states")
 				{
 					// Now parse actor states until we reach the end of the states structure
 					while(parser.SkipWhitespace(true))
 					{
 						string statetoken = parser.ReadToken();
 						if(!string.IsNullOrEmpty(statetoken))
 						{
 							// Start of scope?
 							if(statetoken == "{")
 							{
 								// This is fine
 							}
 							// End of scope?
 							else if(statetoken == "}")
 							{
 								// Done with the states,
 								// break out of this parse loop
 								break;
 							}
 							// State label?
 							else if(statetoken == "
 							{
 								if(!string.IsNullOrEmpty(previoustoken))
 								{
 									// Parse actor state
 									StateStructure st = new StateStructure(this, parser, previoustoken);
 									if(parser.HasError) return;
 									states[previoustoken.ToLowerInvariant()] = st;
 								}
 								else
 								{
 									parser.ReportError("Unexpected end of structure");
 									return;
 								}
 							}
 							else
 							{
 								// Keep token
 								previoustoken = statetoken;
 							}
 						}
 						else
 						{
 							parser.ReportError("Unexpected end of structure");
 							return;
 						}
 					}
 				}
 				else if(token == "}")
 				{
 					// Actor scope ends here,
 					// break out of this parse loop
 					break;
 				}
 				// Monster property?
 				else if(token == "monster")
 				{
 					// This sets certain flags we are interested in
 					flags["shootable"] = true;
 					flags["countkill"] = true;
 					flags["solid"] = true;
 					flags["canpushwalls"] = true;
 					flags["canusewalls"] = true;
 					flags["activatemcross"] = true;
 					flags["canpass"] = true;
 					flags["ismonster"] = true;
 				}
 				// Projectile property?
 				else if(token == "projectile")
 				{
 					// This sets certain flags we are interested in
 					flags["noblockmap"] = true;
 					flags["nogravity"] = true;
 					flags["dropoff"] = true;
 					flags["missile"] = true;
 					flags["activateimpact"] = true;
 					flags["activatepcross"] = true;
 					flags["noteleport"] = true;
 				}
 				// Clearflags property?
 				else if(token == "clearflags")
 				{
 					// Clear all flags
 					flags.Clear();
 				}
 				// Game property?
 				else if(token == "game")
 				{
 					// Include all tokens on the same line
 					List<string> games = new List<string>();
 					while(parser.SkipWhitespace(false))
 					{
 						string v = parser.ReadToken();
 						if(v == null)
 						{
 							parser.ReportError("Unexpected end of structure");
 							return;
 						}
 						if(v == "\n") break;
 						if(v != ",")
 							games.Add(v.ToLowerInvariant());
 					}
 					props[token] = games;
 				}
 				// Property
 				else
 				{
 					// Property begins with $? Then the whole line is a single value
 					if(token.StartsWith("$"))
 					{
 						// This is for editor-only properties such as $sprite and $category
 						List<string> values = new List<string>();
 						if(parser.SkipWhitespace(false))
 							values.Add(parser.ReadLine());
 						else
 							values.Add("");
 						props[token] = values;
 					}
 					else
 					{
 						// Next tokens up until the next newline are values
 						List<string> values = new List<string>();
 						while(parser.SkipWhitespace(false))
 						{
 							string v = parser.ReadToken();
 							if(v == null)
 							{
 								parser.ReportError("Unexpected end of structure");
 								return;
 							}
 							if(v == "\n") break;
 							if(v != ",")
 								values.Add(v);
 						}
 						props[token] = values;
 					}
 				}
 				
 				// Keep token
 				previoustoken = token;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="273" endline="289">
<![CDATA[
 
 		// This normalizes the vector
 		public Vector3D GetNormal()
 		{
 			float lensq = this.GetLengthSq();
 			if(lensq > TINY_VALUE)
 			{
 				// Divide each element by the length
 				float mul = 1f / (float)Math.Sqrt(lensq);
 				return new Vector3D(x * mul, y * mul, z * mul);
 			}
 			else
 			{
 				// Cannot normalize
 				return new Vector3D(0f, 0f, 0f);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\WAD.cs" startline="340" endline="349">
<![CDATA[
 
 		// This finds a lump by name, returns null when not found
 		public Lump FindLump(string name, int start, int end)
 		{
 			int index = FindLumpIndex(name, start, end);
 			if(index == -1)
 				return null;
 			else
 				return lumps[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\SectorEditForm.Designer.cs" startline="22" endline="466">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.Label label1;
 			System.Windows.Forms.Label label3;
 			System.Windows.Forms.GroupBox groupaction;
 			System.Windows.Forms.Label taglabel;
 			System.Windows.Forms.GroupBox groupeffect;
 			System.Windows.Forms.Label label9;
 			System.Windows.Forms.Label label8;
 			System.Windows.Forms.GroupBox groupfloorceiling;
 			System.Windows.Forms.Label label5;
 			System.Windows.Forms.Label label2;
 			System.Windows.Forms.Label label4;
 			System.Windows.Forms.Label label6;
 			this.tag = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.newtag = new System.Windows.Forms.Button();
 			this.brightness = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.browseeffect = new System.Windows.Forms.Button();
 			this.effect = new CodeImp.DoomBuilder.Controls.ActionSelectorControl();
 			this.floorheight = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.ceilingheight = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.sectorheight = new System.Windows.Forms.Label();
 			this.sectorheightlabel = new System.Windows.Forms.Label();
 			this.floortex = new CodeImp.DoomBuilder.Controls.FlatSelectorControl();
 			this.ceilingtex = new CodeImp.DoomBuilder.Controls.FlatSelectorControl();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.tabs = new System.Windows.Forms.TabControl();
 			this.tabproperties = new System.Windows.Forms.TabPage();
 			this.tabcustom = new System.Windows.Forms.TabPage();
 			this.fieldslist = new CodeImp.DoomBuilder.Controls.FieldsEditorControl();
 			this.flatSelectorControl2 = new CodeImp.DoomBuilder.Controls.FlatSelectorControl();
 			this.flatSelectorControl1 = new CodeImp.DoomBuilder.Controls.FlatSelectorControl();
 			label1 = new System.Windows.Forms.Label();
 			label3 = new System.Windows.Forms.Label();
 			groupaction = new System.Windows.Forms.GroupBox();
 			taglabel = new System.Windows.Forms.Label();
 			groupeffect = new System.Windows.Forms.GroupBox();
 			label9 = new System.Windows.Forms.Label();
 			label8 = new System.Windows.Forms.Label();
 			groupfloorceiling = new System.Windows.Forms.GroupBox();
 			label5 = new System.Windows.Forms.Label();
 			label2 = new System.Windows.Forms.Label();
 			label4 = new System.Windows.Forms.Label();
 			label6 = new System.Windows.Forms.Label();
 			groupaction.SuspendLayout();
 			groupeffect.SuspendLayout();
 			groupfloorceiling.SuspendLayout();
 			this.tabs.SuspendLayout();
 			this.tabproperties.SuspendLayout();
 			this.tabcustom.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// label1
 			// 
 			label1.Location = new System.Drawing.Point(271, 18);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(83, 16);
 			label1.TabIndex = 15;
 			label1.Text = "Floor";
 			label1.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// label3
 			// 
 			label3.Location = new System.Drawing.Point(363, 18);
 			label3.Name = "label3";
 			label3.Size = new System.Drawing.Size(83, 16);
 			label3.TabIndex = 14;
 			label3.Text = "Ceiling";
 			label3.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// groupaction
 			// 
 			groupaction.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			groupaction.Controls.Add(this.tag);
 			groupaction.Controls.Add(taglabel);
 			groupaction.Controls.Add(this.newtag);
 			groupaction.Location = new System.Drawing.Point(7, 290);
 			groupaction.Name = "groupaction";
 			groupaction.Size = new System.Drawing.Size(436, 71);
 			groupaction.TabIndex = 2;
 			groupaction.TabStop = false;
 			groupaction.Text = " Identification ";
 			// 
 			// tag
 			// 
 			this.tag.AllowDecimal = false;
 			this.tag.AllowNegative = false;
 			this.tag.AllowRelative = true;
 			this.tag.ButtonStep = 1;
 			this.tag.Location = new System.Drawing.Point(89, 26);
 			this.tag.Name = "tag";
 			this.tag.Size = new System.Drawing.Size(73, 24);
 			this.tag.StepValues = null;
 			this.tag.TabIndex = 25;
 			// 
 			// taglabel
 			// 
 			taglabel.AutoSize = true;
 			taglabel.Location = new System.Drawing.Point(55, 31);
 			taglabel.Name = "taglabel";
 			taglabel.Size = new System.Drawing.Size(28, 14);
 			taglabel.TabIndex = 9;
 			taglabel.Text = "Tag
 			// 
 			// newtag
 			// 
 			this.newtag.Location = new System.Drawing.Point(174, 27);
 			this.newtag.Name = "newtag";
 			this.newtag.Size = new System.Drawing.Size(76, 23);
 			this.newtag.TabIndex = 1;
 			this.newtag.Text = "New Tag";
 			this.newtag.UseVisualStyleBackColor = true;
 			this.newtag.Click += new System.EventHandler(this.newtag_Click);
 			// 
 			// groupeffect
 			// 
 			groupeffect.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			groupeffect.Controls.Add(this.brightness);
 			groupeffect.Controls.Add(this.browseeffect);
 			groupeffect.Controls.Add(label9);
 			groupeffect.Controls.Add(this.effect);
 			groupeffect.Controls.Add(label8);
 			groupeffect.Location = new System.Drawing.Point(7, 176);
 			groupeffect.Name = "groupeffect";
 			groupeffect.Size = new System.Drawing.Size(436, 105);
 			groupeffect.TabIndex = 1;
 			groupeffect.TabStop = false;
 			groupeffect.Text = " Effects ";
 			// 
 			// brightness
 			// 
 			this.brightness.AllowDecimal = false;
 			this.brightness.AllowNegative = false;
 			this.brightness.AllowRelative = true;
 			this.brightness.ButtonStep = 8;
 			this.brightness.Location = new System.Drawing.Point(89, 61);
 			this.brightness.Name = "brightness";
 			this.brightness.Size = new System.Drawing.Size(73, 24);
 			this.brightness.StepValues = null;
 			this.brightness.TabIndex = 24;
 			// 
 			// browseeffect
 			// 
 			this.browseeffect.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.browseeffect.Image = global
 			this.browseeffect.Location = new System.Drawing.Point(385, 26);
 			this.browseeffect.Name = "browseeffect";
 			this.browseeffect.Padding = new System.Windows.Forms.Padding(0, 0, 1, 3);
 			this.browseeffect.Size = new System.Drawing.Size(28, 25);
 			this.browseeffect.TabIndex = 1;
 			this.browseeffect.Text = " ";
 			this.browseeffect.UseVisualStyleBackColor = true;
 			this.browseeffect.Click += new System.EventHandler(this.browseeffect_Click);
 			// 
 			// label9
 			// 
 			label9.AutoSize = true;
 			label9.Location = new System.Drawing.Point(21, 66);
 			label9.Name = "label9";
 			label9.Size = new System.Drawing.Size(62, 14);
 			label9.TabIndex = 2;
 			label9.Text = "Brightness
 			// 
 			// effect
 			// 
 			this.effect.BackColor = System.Drawing.Color.Transparent;
 			this.effect.Cursor = System.Windows.Forms.Cursors.Default;
 			this.effect.Empty = false;
 			this.effect.GeneralizedCategories = null;
 			this.effect.Location = new System.Drawing.Point(89, 28);
 			this.effect.Name = "effect";
 			this.effect.Size = new System.Drawing.Size(290, 21);
 			this.effect.TabIndex = 0;
 			this.effect.Value = 402;
 			// 
 			// label8
 			// 
 			label8.AutoSize = true;
 			label8.Location = new System.Drawing.Point(38, 31);
 			label8.Name = "label8";
 			label8.Size = new System.Drawing.Size(45, 14);
 			label8.TabIndex = 0;
 			label8.Text = "Special
 			// 
 			// groupfloorceiling
 			// 
 			groupfloorceiling.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			groupfloorceiling.Controls.Add(this.floorheight);
 			groupfloorceiling.Controls.Add(this.ceilingheight);
 			groupfloorceiling.Controls.Add(this.sectorheight);
 			groupfloorceiling.Controls.Add(this.sectorheightlabel);
 			groupfloorceiling.Controls.Add(label5);
 			groupfloorceiling.Controls.Add(label2);
 			groupfloorceiling.Controls.Add(label4);
 			groupfloorceiling.Controls.Add(this.floortex);
 			groupfloorceiling.Controls.Add(this.ceilingtex);
 			groupfloorceiling.Controls.Add(label6);
 			groupfloorceiling.Location = new System.Drawing.Point(7, 6);
 			groupfloorceiling.Name = "groupfloorceiling";
 			groupfloorceiling.Size = new System.Drawing.Size(436, 161);
 			groupfloorceiling.TabIndex = 0;
 			groupfloorceiling.TabStop = false;
 			groupfloorceiling.Text = "Floor and Ceiling ";
 			// 
 			// floorheight
 			// 
 			this.floorheight.AllowDecimal = false;
 			this.floorheight.AllowNegative = true;
 			this.floorheight.AllowRelative = true;
 			this.floorheight.ButtonStep = 8;
 			this.floorheight.Location = new System.Drawing.Point(112, 69);
 			this.floorheight.Name = "floorheight";
 			this.floorheight.Size = new System.Drawing.Size(88, 24);
 			this.floorheight.StepValues = null;
 			this.floorheight.TabIndex = 23;
 			this.floorheight.WhenTextChanged += new System.EventHandler(this.floorheight_TextChanged);
 			// 
 			// ceilingheight
 			// 
 			this.ceilingheight.AllowDecimal = false;
 			this.ceilingheight.AllowNegative = true;
 			this.ceilingheight.AllowRelative = true;
 			this.ceilingheight.ButtonStep = 8;
 			this.ceilingheight.Location = new System.Drawing.Point(112, 35);
 			this.ceilingheight.Name = "ceilingheight";
 			this.ceilingheight.Size = new System.Drawing.Size(88, 24);
 			this.ceilingheight.StepValues = null;
 			this.ceilingheight.TabIndex = 22;
 			this.ceilingheight.WhenTextChanged += new System.EventHandler(this.ceilingheight_TextChanged);
 			// 
 			// sectorheight
 			// 
 			this.sectorheight.AutoSize = true;
 			this.sectorheight.Location = new System.Drawing.Point(113, 109);
 			this.sectorheight.Name = "sectorheight";
 			this.sectorheight.Size = new System.Drawing.Size(13, 14);
 			this.sectorheight.TabIndex = 21;
 			this.sectorheight.Text = "0";
 			// 
 			// sectorheightlabel
 			// 
 			this.sectorheightlabel.AutoSize = true;
 			this.sectorheightlabel.Location = new System.Drawing.Point(32, 109);
 			this.sectorheightlabel.Name = "sectorheightlabel";
 			this.sectorheightlabel.Size = new System.Drawing.Size(74, 14);
 			this.sectorheightlabel.TabIndex = 20;
 			this.sectorheightlabel.Text = "Sector height
 			// 
 			// label5
 			// 
 			label5.AutoSize = true;
 			label5.Location = new System.Drawing.Point(40, 74);
 			label5.Name = "label5";
 			label5.Size = new System.Drawing.Size(66, 14);
 			label5.TabIndex = 17;
 			label5.Text = "Floor height
 			// 
 			// label2
 			// 
 			label2.Location = new System.Drawing.Point(237, 18);
 			label2.Name = "label2";
 			label2.Size = new System.Drawing.Size(83, 16);
 			label2.TabIndex = 15;
 			label2.Text = "Floor";
 			label2.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// label4
 			// 
 			label4.Location = new System.Drawing.Point(332, 18);
 			label4.Name = "label4";
 			label4.Size = new System.Drawing.Size(83, 16);
 			label4.TabIndex = 14;
 			label4.Text = "Ceiling";
 			label4.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// floortex
 			// 
 			this.floortex.Location = new System.Drawing.Point(237, 37);
 			this.floortex.Name = "floortex";
 			this.floortex.Size = new System.Drawing.Size(83, 105);
 			this.floortex.TabIndex = 2;
 			this.floortex.TextureName = "";
 			// 
 			// ceilingtex
 			// 
 			this.ceilingtex.Location = new System.Drawing.Point(332, 37);
 			this.ceilingtex.Name = "ceilingtex";
 			this.ceilingtex.Size = new System.Drawing.Size(83, 105);
 			this.ceilingtex.TabIndex = 3;
 			this.ceilingtex.TextureName = "";
 			// 
 			// label6
 			// 
 			label6.AutoSize = true;
 			label6.Location = new System.Drawing.Point(33, 40);
 			label6.Name = "label6";
 			label6.Size = new System.Drawing.Size(73, 14);
 			label6.TabIndex = 19;
 			label6.Text = "Ceiling height
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(355, 423);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 2;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(236, 423);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 1;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// tabs
 			// 
 			this.tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tabs.Controls.Add(this.tabproperties);
 			this.tabs.Controls.Add(this.tabcustom);
 			this.tabs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabs.Location = new System.Drawing.Point(10, 10);
 			this.tabs.Margin = new System.Windows.Forms.Padding(1);
 			this.tabs.Name = "tabs";
 			this.tabs.SelectedIndex = 0;
 			this.tabs.Size = new System.Drawing.Size(457, 396);
 			this.tabs.SizeMode = System.Windows.Forms.TabSizeMode.Fixed;
 			this.tabs.TabIndex = 0;
 			// 
 			// tabproperties
 			// 
 			this.tabproperties.Controls.Add(groupaction);
 			this.tabproperties.Controls.Add(groupeffect);
 			this.tabproperties.Controls.Add(groupfloorceiling);
 			this.tabproperties.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabproperties.Location = new System.Drawing.Point(4, 23);
 			this.tabproperties.Name = "tabproperties";
 			this.tabproperties.Padding = new System.Windows.Forms.Padding(3);
 			this.tabproperties.Size = new System.Drawing.Size(449, 369);
 			this.tabproperties.TabIndex = 0;
 			this.tabproperties.Text = "Properties";
 			this.tabproperties.UseVisualStyleBackColor = true;
 			// 
 			// tabcustom
 			// 
 			this.tabcustom.Controls.Add(this.fieldslist);
 			this.tabcustom.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabcustom.Location = new System.Drawing.Point(4, 23);
 			this.tabcustom.Name = "tabcustom";
 			this.tabcustom.Padding = new System.Windows.Forms.Padding(3);
 			this.tabcustom.Size = new System.Drawing.Size(449, 369);
 			this.tabcustom.TabIndex = 1;
 			this.tabcustom.Text = "Custom";
 			this.tabcustom.UseVisualStyleBackColor = true;
 			// 
 			// fieldslist
 			// 
 			this.fieldslist.AllowInsert = true;
 			this.fieldslist.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.fieldslist.AutoInsertUserPrefix = true;
 			this.fieldslist.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.fieldslist.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.fieldslist.Location = new System.Drawing.Point(11, 11);
 			this.fieldslist.Margin = new System.Windows.Forms.Padding(8);
 			this.fieldslist.Name = "fieldslist";
 			this.fieldslist.PropertyColumnVisible = true;
 			this.fieldslist.PropertyColumnWidth = 150;
 			this.fieldslist.Size = new System.Drawing.Size(427, 347);
 			this.fieldslist.TabIndex = 1;
 			this.fieldslist.TypeColumnVisible = true;
 			this.fieldslist.TypeColumnWidth = 100;
 			this.fieldslist.ValueColumnVisible = true;
 			// 
 			// flatSelectorControl2
 			// 
 			this.flatSelectorControl2.Location = new System.Drawing.Point(271, 37);
 			this.flatSelectorControl2.Name = "flatSelectorControl2";
 			this.flatSelectorControl2.Size = new System.Drawing.Size(83, 105);
 			this.flatSelectorControl2.TabIndex = 13;
 			this.flatSelectorControl2.TextureName = "";
 			// 
 			// flatSelectorControl1
 			// 
 			this.flatSelectorControl1.Location = new System.Drawing.Point(363, 37);
 			this.flatSelectorControl1.Name = "flatSelectorControl1";
 			this.flatSelectorControl1.Size = new System.Drawing.Size(83, 105);
 			this.flatSelectorControl1.TabIndex = 12;
 			this.flatSelectorControl1.TextureName = "";
 			// 
 			// SectorEditForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(477, 458);
 			this.Controls.Add(this.tabs);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "SectorEditForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Edit Sector";
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.SectorEditForm_HelpRequested);
 			groupaction.ResumeLayout(false);
 			groupaction.PerformLayout();
 			groupeffect.ResumeLayout(false);
 			groupeffect.PerformLayout();
 			groupfloorceiling.ResumeLayout(false);
 			groupfloorceiling.PerformLayout();
 			this.tabs.ResumeLayout(false);
 			this.tabproperties.ResumeLayout(false);
 			this.tabcustom.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ActionBrowserForm.Designer.cs" startline="22" endline="475">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.Label label1;
 			System.Windows.Forms.Label label2;
 			System.Windows.Forms.Label label3;
 			System.Windows.Forms.Label label4;
 			System.Windows.Forms.Label label5;
 			System.Windows.Forms.Label label6;
 			System.Windows.Forms.GroupBox groupBox1;
 			System.Windows.Forms.Label label7;
 			System.Windows.Forms.GroupBox groupBox2;
 			this.category = new System.Windows.Forms.ComboBox();
 			this.option7 = new System.Windows.Forms.ComboBox();
 			this.option7label = new System.Windows.Forms.Label();
 			this.option6 = new System.Windows.Forms.ComboBox();
 			this.option6label = new System.Windows.Forms.Label();
 			this.option5 = new System.Windows.Forms.ComboBox();
 			this.option5label = new System.Windows.Forms.Label();
 			this.option4 = new System.Windows.Forms.ComboBox();
 			this.option4label = new System.Windows.Forms.Label();
 			this.option3 = new System.Windows.Forms.ComboBox();
 			this.option3label = new System.Windows.Forms.Label();
 			this.option2 = new System.Windows.Forms.ComboBox();
 			this.option2label = new System.Windows.Forms.Label();
 			this.option1 = new System.Windows.Forms.ComboBox();
 			this.option1label = new System.Windows.Forms.Label();
 			this.option0 = new System.Windows.Forms.ComboBox();
 			this.option0label = new System.Windows.Forms.Label();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.actions = new System.Windows.Forms.TreeView();
 			this.tabs = new System.Windows.Forms.TabControl();
 			this.tabactions = new System.Windows.Forms.TabPage();
 			this.prefixespanel = new System.Windows.Forms.Panel();
 			this.tabgeneralized = new System.Windows.Forms.TabPage();
 			label1 = new System.Windows.Forms.Label();
 			label2 = new System.Windows.Forms.Label();
 			label3 = new System.Windows.Forms.Label();
 			label4 = new System.Windows.Forms.Label();
 			label5 = new System.Windows.Forms.Label();
 			label6 = new System.Windows.Forms.Label();
 			groupBox1 = new System.Windows.Forms.GroupBox();
 			label7 = new System.Windows.Forms.Label();
 			groupBox2 = new System.Windows.Forms.GroupBox();
 			groupBox1.SuspendLayout();
 			groupBox2.SuspendLayout();
 			this.tabs.SuspendLayout();
 			this.tabactions.SuspendLayout();
 			this.prefixespanel.SuspendLayout();
 			this.tabgeneralized.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// label1
 			// 
 			label1.AutoSize = true;
 			label1.Location = new System.Drawing.Point(27, 0);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(60, 14);
 			label1.TabIndex = 21;
 			label1.Text = "S = Switch";
 			// 
 			// label2
 			// 
 			label2.AutoSize = true;
 			label2.Location = new System.Drawing.Point(140, 0);
 			label2.Name = "label2";
 			label2.Size = new System.Drawing.Size(77, 14);
 			label2.TabIndex = 22;
 			label2.Text = "W = Walk over";
 			// 
 			// label3
 			// 
 			label3.AutoSize = true;
 			label3.Location = new System.Drawing.Point(269, 0);
 			label3.Name = "label3";
 			label3.Size = new System.Drawing.Size(63, 14);
 			label3.TabIndex = 23;
 			label3.Text = "G = Gunfire";
 			// 
 			// label4
 			// 
 			label4.AutoSize = true;
 			label4.Location = new System.Drawing.Point(27, 16);
 			label4.Name = "label4";
 			label4.Size = new System.Drawing.Size(49, 14);
 			label4.TabIndex = 24;
 			label4.Text = "D = Door";
 			// 
 			// label5
 			// 
 			label5.AutoSize = true;
 			label5.Location = new System.Drawing.Point(140, 16);
 			label5.Name = "label5";
 			label5.Size = new System.Drawing.Size(80, 14);
 			label5.TabIndex = 25;
 			label5.Text = "R = Repeatable";
 			// 
 			// label6
 			// 
 			label6.AutoSize = true;
 			label6.Location = new System.Drawing.Point(269, 16);
 			label6.Name = "label6";
 			label6.Size = new System.Drawing.Size(74, 14);
 			label6.TabIndex = 26;
 			label6.Text = "1 = Once only";
 			// 
 			// groupBox1
 			// 
 			groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			groupBox1.Controls.Add(this.category);
 			groupBox1.Controls.Add(label7);
 			groupBox1.Location = new System.Drawing.Point(6, 6);
 			groupBox1.Name = "groupBox1";
 			groupBox1.Size = new System.Drawing.Size(379, 65);
 			groupBox1.TabIndex = 0;
 			groupBox1.TabStop = false;
 			groupBox1.Text = " Category ";
 			// 
 			// category
 			// 
 			this.category.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.category.FormattingEnabled = true;
 			this.category.Location = new System.Drawing.Point(118, 25);
 			this.category.Name = "category";
 			this.category.Size = new System.Drawing.Size(199, 22);
 			this.category.TabIndex = 0;
 			this.category.SelectedIndexChanged += new System.EventHandler(this.category_SelectedIndexChanged);
 			// 
 			// label7
 			// 
 			label7.AutoSize = true;
 			label7.Location = new System.Drawing.Point(58, 28);
 			label7.Name = "label7";
 			label7.Size = new System.Drawing.Size(54, 14);
 			label7.TabIndex = 0;
 			label7.Text = "Category
 			// 
 			// groupBox2
 			// 
 			groupBox2.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			groupBox2.Controls.Add(this.option7);
 			groupBox2.Controls.Add(this.option7label);
 			groupBox2.Controls.Add(this.option6);
 			groupBox2.Controls.Add(this.option6label);
 			groupBox2.Controls.Add(this.option5);
 			groupBox2.Controls.Add(this.option5label);
 			groupBox2.Controls.Add(this.option4);
 			groupBox2.Controls.Add(this.option4label);
 			groupBox2.Controls.Add(this.option3);
 			groupBox2.Controls.Add(this.option3label);
 			groupBox2.Controls.Add(this.option2);
 			groupBox2.Controls.Add(this.option2label);
 			groupBox2.Controls.Add(this.option1);
 			groupBox2.Controls.Add(this.option1label);
 			groupBox2.Controls.Add(this.option0);
 			groupBox2.Controls.Add(this.option0label);
 			groupBox2.Location = new System.Drawing.Point(6, 77);
 			groupBox2.Name = "groupBox2";
 			groupBox2.Size = new System.Drawing.Size(379, 326);
 			groupBox2.TabIndex = 1;
 			groupBox2.TabStop = false;
 			groupBox2.Text = " Options ";
 			// 
 			// option7
 			// 
 			this.option7.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option7.FormattingEnabled = true;
 			this.option7.Location = new System.Drawing.Point(118, 280);
 			this.option7.Name = "option7";
 			this.option7.Size = new System.Drawing.Size(199, 22);
 			this.option7.TabIndex = 7;
 			this.option7.Visible = false;
 			// 
 			// option7label
 			// 
 			this.option7label.Location = new System.Drawing.Point(3, 283);
 			this.option7label.Name = "option7label";
 			this.option7label.Size = new System.Drawing.Size(109, 19);
 			this.option7label.TabIndex = 16;
 			this.option7label.Text = "Option
 			this.option7label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option7label.Visible = false;
 			// 
 			// option6
 			// 
 			this.option6.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option6.FormattingEnabled = true;
 			this.option6.Location = new System.Drawing.Point(118, 244);
 			this.option6.Name = "option6";
 			this.option6.Size = new System.Drawing.Size(199, 22);
 			this.option6.TabIndex = 6;
 			this.option6.Visible = false;
 			// 
 			// option6label
 			// 
 			this.option6label.Location = new System.Drawing.Point(3, 247);
 			this.option6label.Name = "option6label";
 			this.option6label.Size = new System.Drawing.Size(109, 19);
 			this.option6label.TabIndex = 14;
 			this.option6label.Text = "Option
 			this.option6label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option6label.Visible = false;
 			// 
 			// option5
 			// 
 			this.option5.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option5.FormattingEnabled = true;
 			this.option5.Location = new System.Drawing.Point(118, 208);
 			this.option5.Name = "option5";
 			this.option5.Size = new System.Drawing.Size(199, 22);
 			this.option5.TabIndex = 5;
 			this.option5.Visible = false;
 			// 
 			// option5label
 			// 
 			this.option5label.Location = new System.Drawing.Point(3, 211);
 			this.option5label.Name = "option5label";
 			this.option5label.Size = new System.Drawing.Size(109, 19);
 			this.option5label.TabIndex = 12;
 			this.option5label.Text = "Option
 			this.option5label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option5label.Visible = false;
 			// 
 			// option4
 			// 
 			this.option4.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option4.FormattingEnabled = true;
 			this.option4.Location = new System.Drawing.Point(118, 172);
 			this.option4.Name = "option4";
 			this.option4.Size = new System.Drawing.Size(199, 22);
 			this.option4.TabIndex = 4;
 			this.option4.Visible = false;
 			// 
 			// option4label
 			// 
 			this.option4label.Location = new System.Drawing.Point(3, 175);
 			this.option4label.Name = "option4label";
 			this.option4label.Size = new System.Drawing.Size(109, 19);
 			this.option4label.TabIndex = 10;
 			this.option4label.Text = "Option
 			this.option4label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option4label.Visible = false;
 			// 
 			// option3
 			// 
 			this.option3.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option3.FormattingEnabled = true;
 			this.option3.Location = new System.Drawing.Point(118, 136);
 			this.option3.Name = "option3";
 			this.option3.Size = new System.Drawing.Size(199, 22);
 			this.option3.TabIndex = 3;
 			this.option3.Visible = false;
 			// 
 			// option3label
 			// 
 			this.option3label.Location = new System.Drawing.Point(3, 139);
 			this.option3label.Name = "option3label";
 			this.option3label.Size = new System.Drawing.Size(109, 19);
 			this.option3label.TabIndex = 8;
 			this.option3label.Text = "Option
 			this.option3label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option3label.Visible = false;
 			// 
 			// option2
 			// 
 			this.option2.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option2.FormattingEnabled = true;
 			this.option2.Location = new System.Drawing.Point(118, 100);
 			this.option2.Name = "option2";
 			this.option2.Size = new System.Drawing.Size(199, 22);
 			this.option2.TabIndex = 2;
 			this.option2.Visible = false;
 			// 
 			// option2label
 			// 
 			this.option2label.Location = new System.Drawing.Point(3, 103);
 			this.option2label.Name = "option2label";
 			this.option2label.Size = new System.Drawing.Size(109, 19);
 			this.option2label.TabIndex = 6;
 			this.option2label.Text = "Option
 			this.option2label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option2label.Visible = false;
 			// 
 			// option1
 			// 
 			this.option1.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option1.FormattingEnabled = true;
 			this.option1.Location = new System.Drawing.Point(118, 64);
 			this.option1.Name = "option1";
 			this.option1.Size = new System.Drawing.Size(199, 22);
 			this.option1.TabIndex = 1;
 			this.option1.Visible = false;
 			// 
 			// option1label
 			// 
 			this.option1label.Location = new System.Drawing.Point(3, 67);
 			this.option1label.Name = "option1label";
 			this.option1label.Size = new System.Drawing.Size(109, 19);
 			this.option1label.TabIndex = 4;
 			this.option1label.Text = "Option
 			this.option1label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option1label.Visible = false;
 			// 
 			// option0
 			// 
 			this.option0.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.option0.FormattingEnabled = true;
 			this.option0.Location = new System.Drawing.Point(118, 28);
 			this.option0.Name = "option0";
 			this.option0.Size = new System.Drawing.Size(199, 22);
 			this.option0.TabIndex = 0;
 			this.option0.Visible = false;
 			// 
 			// option0label
 			// 
 			this.option0label.Location = new System.Drawing.Point(3, 31);
 			this.option0label.Name = "option0label";
 			this.option0label.Size = new System.Drawing.Size(109, 19);
 			this.option0label.TabIndex = 2;
 			this.option0label.Text = "Option
 			this.option0label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.option0label.Visible = false;
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(297, 459);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 27);
 			this.cancel.TabIndex = 2;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(177, 459);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 27);
 			this.apply.TabIndex = 1;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// actions
 			// 
 			this.actions.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.actions.HideSelection = false;
 			this.actions.Location = new System.Drawing.Point(6, 52);
 			this.actions.Name = "actions";
 			this.actions.Size = new System.Drawing.Size(379, 351);
 			this.actions.TabIndex = 0;
 			this.actions.DoubleClick += new System.EventHandler(this.actions_DoubleClick);
 			// 
 			// tabs
 			// 
 			this.tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tabs.Controls.Add(this.tabactions);
 			this.tabs.Controls.Add(this.tabgeneralized);
 			this.tabs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabs.ItemSize = new System.Drawing.Size(150, 19);
 			this.tabs.Location = new System.Drawing.Point(10, 10);
 			this.tabs.Margin = new System.Windows.Forms.Padding(1);
 			this.tabs.Name = "tabs";
 			this.tabs.SelectedIndex = 0;
 			this.tabs.Size = new System.Drawing.Size(399, 436);
 			this.tabs.SizeMode = System.Windows.Forms.TabSizeMode.Fixed;
 			this.tabs.TabIndex = 0;
 			// 
 			// tabactions
 			// 
 			this.tabactions.Controls.Add(this.actions);
 			this.tabactions.Controls.Add(this.prefixespanel);
 			this.tabactions.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabactions.Location = new System.Drawing.Point(4, 23);
 			this.tabactions.Name = "tabactions";
 			this.tabactions.Padding = new System.Windows.Forms.Padding(3);
 			this.tabactions.Size = new System.Drawing.Size(391, 409);
 			this.tabactions.TabIndex = 0;
 			this.tabactions.Text = "Predefined Actions";
 			this.tabactions.UseVisualStyleBackColor = true;
 			// 
 			// prefixespanel
 			// 
 			this.prefixespanel.Controls.Add(label6);
 			this.prefixespanel.Controls.Add(label5);
 			this.prefixespanel.Controls.Add(label4);
 			this.prefixespanel.Controls.Add(label3);
 			this.prefixespanel.Controls.Add(label2);
 			this.prefixespanel.Controls.Add(label1);
 			this.prefixespanel.Location = new System.Drawing.Point(7, 12);
 			this.prefixespanel.Name = "prefixespanel";
 			this.prefixespanel.Size = new System.Drawing.Size(378, 34);
 			this.prefixespanel.TabIndex = 27;
 			// 
 			// tabgeneralized
 			// 
 			this.tabgeneralized.Controls.Add(groupBox2);
 			this.tabgeneralized.Controls.Add(groupBox1);
 			this.tabgeneralized.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabgeneralized.Location = new System.Drawing.Point(4, 23);
 			this.tabgeneralized.Name = "tabgeneralized";
 			this.tabgeneralized.Padding = new System.Windows.Forms.Padding(3);
 			this.tabgeneralized.Size = new System.Drawing.Size(391, 409);
 			this.tabgeneralized.TabIndex = 1;
 			this.tabgeneralized.Text = "Generalized Actions";
 			this.tabgeneralized.UseVisualStyleBackColor = true;
 			// 
 			// ActionBrowserForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(419, 496);
 			this.Controls.Add(this.tabs);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "ActionBrowserForm";
 			this.Opacity = 0;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Edit Action";
 			groupBox1.ResumeLayout(false);
 			groupBox1.PerformLayout();
 			groupBox2.ResumeLayout(false);
 			this.tabs.ResumeLayout(false);
 			this.tabactions.ResumeLayout(false);
 			this.prefixespanel.ResumeLayout(false);
 			this.prefixespanel.PerformLayout();
 			this.tabgeneralized.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1" nfragments="45" Csharpe_files="45" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\StateGoto.cs" startline="53" endline="210">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Constructor
 		internal StateGoto(ActorStructure actor, DecorateParser parser)
 		{
 			string firsttarget = "";
 			string secondtarget = "";
 			bool commentreached = false;
 			bool offsetreached = false;
 			string offsetstr = "";
 			int cindex = 0;
 			
 			// This is a bitch to parse because for some bizarre reason someone thought it
 			// was funny to allow quotes here. Read the whole line and start parsing this manually.
 			string line = parser.ReadLine();
 			
 			// Skip whitespace
 			while((cindex < line.Length) && ((line[cindex] == ' ') || (line[cindex] == '\t')))
 				cindex++;
 			while((cindex < line.Length) && ((line[cindex] == ' ') || (line[cindex] == '\t')))
 				cindex++;
 			
 			// Parse first target
 			while((cindex < line.Length) && (line[cindex] != '
 			{
 				// When a comment is reached, we're done here
 				if(line[cindex] == '/')
 				{
 					if((cindex + 1 < line.Length) && ((line[cindex + 1] == '/') || (line[cindex + 1] == '*')))
 					{
 						commentreached = true;
 						break;
 					}
 				}
 				
 				// Whitespace ends the string
 				if((line[cindex] == ' ') || (line[cindex] == '\t'))
 					break;
 				
 				// + sign indicates offset start
 				if(line[cindex] == '+')
 				{
 					cindex++;
 					offsetreached = true;
 					break;
 				}
 				
 				// Ignore quotes
 				if(line[cindex] != '"')
 					firsttarget += line[cindex];
 				
 				cindex++;
 			}
 			while((cindex < line.Length) && (line[cindex] != '
 			{
 				// When a comment is reached, we're done here
 				if(line[cindex] == '/')
 				{
 					if((cindex + 1 < line.Length) && ((line[cindex + 1] == '/') || (line[cindex + 1] == '*')))
 					{
 						commentreached = true;
 						break;
 					}
 				}
 				
 				// Whitespace ends the string
 				if((line[cindex] == ' ') || (line[cindex] == '\t'))
 					break;
 				
 				// + sign indicates offset start
 				if(line[cindex] == '+')
 				{
 					cindex++;
 					offsetreached = true;
 					break;
 				}
 				
 				// Ignore quotes
 				if(line[cindex] != '"')
 					firsttarget += line[cindex];
 				
 				cindex++;
 			}
 			
 			if(!commentreached && !offsetreached)
 			{
 				// Skip whitespace
 				while((cindex < line.Length) && ((line[cindex] == ' ') || (line[cindex] == '\t')))
 					cindex++;
 				while((cindex < line.Length) && ((line[cindex] == ' ') || (line[cindex] == '\t')))
 					cindex++;
 				
 				// Parse second target
 				while(cindex < line.Length)
 				{
 					// When a comment is reached, we're done here
 					if(line[cindex] == '/')
 					{
 						if((cindex + 1 < line.Length) && ((line[cindex + 1] == '/') || (line[cindex + 1] == '*')))
 						{
 							commentreached = true;
 							break;
 						}
 					}
 					
 					// Whitespace ends the string
 					if((line[cindex] == ' ') || (line[cindex] == '\t'))
 						break;
 					
 					// + sign indicates offset start
 					if(line[cindex] == '+')
 					{
 						cindex++;
 						offsetreached = true;
 						break;
 					}
 
 					// Ignore quotes and semicolons
 					if((line[cindex] != '"') && (line[cindex] != '
 						secondtarget += line[cindex];
 						
 					cindex++;
 				}
 				while(cindex < line.Length)
 				{
 					// When a comment is reached, we're done here
 					if(line[cindex] == '/')
 					{
 						if((cindex + 1 < line.Length) && ((line[cindex + 1] == '/') || (line[cindex + 1] == '*')))
 						{
 							commentreached = true;
 							break;
 						}
 					}
 					
 					// Whitespace ends the string
 					if((line[cindex] == ' ') || (line[cindex] == '\t'))
 						break;
 					
 					// + sign indicates offset start
 					if(line[cindex] == '+')
 					{
 						cindex++;
 						offsetreached = true;
 						break;
 					}
 
 					// Ignore quotes and semicolons
 					if((line[cindex] != '"') && (line[cindex] != '
 						secondtarget += line[cindex];
 						
 					cindex++;
 				}
 			}
 			
 			// Try to find the offset if we still haven't found it yet
 			if(!offsetreached)
 			{
 				// Skip whitespace
 				while((cindex < line.Length) && ((line[cindex] == ' ') || (line[cindex] == '\t')))
 					cindex++;
 				while((cindex < line.Length) && ((line[cindex] == ' ') || (line[cindex] == '\t')))
 					cindex++;
 				
 				if((cindex < line.Length) && (line[cindex] == '+'))
 				{
 					cindex++;
 					offsetreached = true;
 				}
 			}
 			
 			if(offsetreached)
 			{
 				// Parse offset
 				while(cindex < line.Length)
 				{
 					// When a comment is reached, we're done here
 					if(line[cindex] == '/')
 					{
 						if((cindex + 1 < line.Length) && ((line[cindex + 1] == '/') || (line[cindex + 1] == '*')))
 						{
 							commentreached = true;
 							break;
 						}
 					}
 					
 					// Whitespace ends the string
 					if((line[cindex] == ' ') || (line[cindex] == '\t'))
 						break;
 					
 					// Ignore quotes and semicolons
 					if((line[cindex] != '"') && (line[cindex] != '
 						offsetstr += line[cindex];
 					
 					cindex++;
 				}
 				while(cindex < line.Length)
 				{
 					// When a comment is reached, we're done here
 					if(line[cindex] == '/')
 					{
 						if((cindex + 1 < line.Length) && ((line[cindex + 1] == '/') || (line[cindex + 1] == '*')))
 						{
 							commentreached = true;
 							break;
 						}
 					}
 					
 					// Whitespace ends the string
 					if((line[cindex] == ' ') || (line[cindex] == '\t'))
 						break;
 					
 					// Ignore quotes and semicolons
 					if((line[cindex] != '"') && (line[cindex] != '
 						offsetstr += line[cindex];
 					
 					cindex++;
 				}
 			}
 			
 			// We should now have a first target, optionally a second target and optionally a sprite offset
 			
 			// Check if we don't have the class specified
 			if(string.IsNullOrEmpty(secondtarget))
 			{
 				// First target is the state to go to
 				classname = actor.ClassName;
 				statename = firsttarget.ToLowerInvariant().Trim();
 			}
 			else
 			{
 				// First target is the base class to use
 				// Second target is the state to go to
 				classname = firsttarget.ToLowerInvariant().Trim();
 				statename = secondtarget.ToLowerInvariant().Trim();
 			}
 			
 			if(offsetstr.Length > 0)
 				int.TryParse(offsetstr, out spriteoffset);
 				
 			if((classname == "super") && (actor.BaseClass != null))
 				classname = actor.BaseClass.ClassName;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="731" endline="873">
<![CDATA[
 
 		// This parses the command line arguments
 		private static void ParseCommandLineArgs(string[] args)
 		{
 			autoloadresources = new DataLocationList();
 			
 			// Keep a copy
 			cmdargs = args;
 			
 			// Make a queue so we can parse the values from left to right
 			Queue<string> argslist = new Queue<string>(args);
 			
 			// Parse list
 			while(argslist.Count > 0)
 			{
 				// Get next arg
 				string curarg = argslist.Dequeue();
 				
 				// Delay window?
 				if(string.Compare(curarg, "-DELAYWINDOW", true) == 0)
 				{
 					// Delay showing the main window
 					delaymainwindow = true;
 				}
 				// No settings?
 				else if(string.Compare(curarg, "-NOSETTINGS", true) == 0)
 				{
 					// Don't load or save program settings
 					nosettings = true;
 				}
 				// Map name info?
 				else if(string.Compare(curarg, "-MAP", true) == 0)
 				{
 					// Store next arg as map name information
 					autoloadmap = argslist.Dequeue();
 				}
 				// Config name info?
 				else if((string.Compare(curarg, "-CFG", true) == 0) ||
 						(string.Compare(curarg, "-CONFIG", true) == 0))
 				{
 					// Store next arg as config filename information
 					autoloadconfig = argslist.Dequeue();
 				}
 				// Strict patches rules?
 				else if(string.Compare(curarg, "-STRICTPATCHES", true) == 0)
 				{
 					autoloadstrictpatches = true;
 				}
 				// Resource?
 				else if(string.Compare(curarg, "-RESOURCE", true) == 0)
 				{
 					DataLocation dl = new DataLocation();
 
 					// Parse resource type
 					string resourcetype = argslist.Dequeue();
 					if(string.Compare(resourcetype, "WAD", true) == 0)
 						dl.type = DataLocation.RESOURCE_WAD;
 					else if(string.Compare(resourcetype, "DIR", true) == 0)
 						dl.type = DataLocation.RESOURCE_DIRECTORY;
 					else if(string.Compare(resourcetype, "PK3", true) == 0)
 						dl.type = DataLocation.RESOURCE_PK3;
 					else
 					{
 						General.WriteLogLine("Unexpected resource type \"" + resourcetype + "\" in program parameters. Expected \"wad\", \"dir\" or \"pk3\".");
 						break;
 					}
 
 					// We continue parsing args until an existing filename is found
 					// all other arguments must be one of the optional keywords.
 					while(string.IsNullOrEmpty(dl.location))
 					{
 						curarg = argslist.Dequeue();
 
 						if((string.Compare(curarg, "ROOTTEXTURES", true) == 0) &&
 						   (dl.type == DataLocation.RESOURCE_DIRECTORY))
 						{
 							// Load images in the root directory of the resource as textures
 							dl.option1 = true;
 						}
 						else if((string.Compare(curarg, "ROOTFLATS", true) == 0) &&
 								(dl.type == DataLocation.RESOURCE_DIRECTORY))
 						{
 							// Load images in the root directory of the resource as flats
 							dl.option2 = true;
 						}
 						else if((string.Compare(curarg, "STRICTPATCHES", true) == 0) &&
 								(dl.type == DataLocation.RESOURCE_WAD))
 						{
 							// Use strict rules for patches
 							dl.option1 = true;
 						}
 						else if(string.Compare(curarg, "NOTEST", true) == 0)
 						{
 							// Exclude this resource from testing parameters
 							dl.notfortesting = true;
 						}
 						else
 						{
 							// This must be an existing file, or it is an invalid argument
 							if(dl.type == DataLocation.RESOURCE_DIRECTORY)
 							{
 								if(Directory.Exists(curarg))
 									dl.location = curarg;
 							}
 							else
 							{
 								if(File.Exists(curarg))
 									dl.location = curarg;
 							}
 							
 							if(string.IsNullOrEmpty(dl.location))
 							{
 								General.WriteLogLine("Unexpected argument \"" + curarg + "\" in program parameters. Expected a valid resource option or a resource filename.");
 								break;
 							}
 						}
 					}
 					while(string.IsNullOrEmpty(dl.location))
 					{
 						curarg = argslist.Dequeue();
 
 						if((string.Compare(curarg, "ROOTTEXTURES", true) == 0) &&
 						   (dl.type == DataLocation.RESOURCE_DIRECTORY))
 						{
 							// Load images in the root directory of the resource as textures
 							dl.option1 = true;
 						}
 						else if((string.Compare(curarg, "ROOTFLATS", true) == 0) &&
 								(dl.type == DataLocation.RESOURCE_DIRECTORY))
 						{
 							// Load images in the root directory of the resource as flats
 							dl.option2 = true;
 						}
 						else if((string.Compare(curarg, "STRICTPATCHES", true) == 0) &&
 								(dl.type == DataLocation.RESOURCE_WAD))
 						{
 							// Use strict rules for patches
 							dl.option1 = true;
 						}
 						else if(string.Compare(curarg, "NOTEST", true) == 0)
 						{
 							// Exclude this resource from testing parameters
 							dl.notfortesting = true;
 						}
 						else
 						{
 							// This must be an existing file, or it is an invalid argument
 							if(dl.type == DataLocation.RESOURCE_DIRECTORY)
 							{
 								if(Directory.Exists(curarg))
 									dl.location = curarg;
 							}
 							else
 							{
 								if(File.Exists(curarg))
 									dl.location = curarg;
 							}
 							
 							if(string.IsNullOrEmpty(dl.location))
 							{
 								General.WriteLogLine("Unexpected argument \"" + curarg + "\" in program parameters. Expected a valid resource option or a resource filename.");
 								break;
 							}
 						}
 					}
 
 					// Add resource to list
 					if(!string.IsNullOrEmpty(dl.location))
 						autoloadresources.Add(dl);
 				}
 				// Every other arg
 				else
 				{
 					// No command to load file yet?
 					if(autoloadfile == null)
 					{
 						// Check if this is a file we can load
 						if(File.Exists(curarg))
 						{
 							// Load this file!
 							autoloadfile = curarg.Trim();
 						}
 						else
 						{
 							// Note in the log that we cannot find this file
 							General.WriteLogLine("Cannot find the specified file \"" + curarg + "\"");
 						}
 					}
 				}
 			}
 			while(argslist.Count > 0)
 			{
 				// Get next arg
 				string curarg = argslist.Dequeue();
 				
 				// Delay window?
 				if(string.Compare(curarg, "-DELAYWINDOW", true) == 0)
 				{
 					// Delay showing the main window
 					delaymainwindow = true;
 				}
 				// No settings?
 				else if(string.Compare(curarg, "-NOSETTINGS", true) == 0)
 				{
 					// Don't load or save program settings
 					nosettings = true;
 				}
 				// Map name info?
 				else if(string.Compare(curarg, "-MAP", true) == 0)
 				{
 					// Store next arg as map name information
 					autoloadmap = argslist.Dequeue();
 				}
 				// Config name info?
 				else if((string.Compare(curarg, "-CFG", true) == 0) ||
 						(string.Compare(curarg, "-CONFIG", true) == 0))
 				{
 					// Store next arg as config filename information
 					autoloadconfig = argslist.Dequeue();
 				}
 				// Strict patches rules?
 				else if(string.Compare(curarg, "-STRICTPATCHES", true) == 0)
 				{
 					autoloadstrictpatches = true;
 				}
 				// Resource?
 				else if(string.Compare(curarg, "-RESOURCE", true) == 0)
 				{
 					DataLocation dl = new DataLocation();
 
 					// Parse resource type
 					string resourcetype = argslist.Dequeue();
 					if(string.Compare(resourcetype, "WAD", true) == 0)
 						dl.type = DataLocation.RESOURCE_WAD;
 					else if(string.Compare(resourcetype, "DIR", true) == 0)
 						dl.type = DataLocation.RESOURCE_DIRECTORY;
 					else if(string.Compare(resourcetype, "PK3", true) == 0)
 						dl.type = DataLocation.RESOURCE_PK3;
 					else
 					{
 						General.WriteLogLine("Unexpected resource type \"" + resourcetype + "\" in program parameters. Expected \"wad\", \"dir\" or \"pk3\".");
 						break;
 					}
 
 					// We continue parsing args until an existing filename is found
 					// all other arguments must be one of the optional keywords.
 					while(string.IsNullOrEmpty(dl.location))
 					{
 						curarg = argslist.Dequeue();
 
 						if((string.Compare(curarg, "ROOTTEXTURES", true) == 0) &&
 						   (dl.type == DataLocation.RESOURCE_DIRECTORY))
 						{
 							// Load images in the root directory of the resource as textures
 							dl.option1 = true;
 						}
 						else if((string.Compare(curarg, "ROOTFLATS", true) == 0) &&
 								(dl.type == DataLocation.RESOURCE_DIRECTORY))
 						{
 							// Load images in the root directory of the resource as flats
 							dl.option2 = true;
 						}
 						else if((string.Compare(curarg, "STRICTPATCHES", true) == 0) &&
 								(dl.type == DataLocation.RESOURCE_WAD))
 						{
 							// Use strict rules for patches
 							dl.option1 = true;
 						}
 						else if(string.Compare(curarg, "NOTEST", true) == 0)
 						{
 							// Exclude this resource from testing parameters
 							dl.notfortesting = true;
 						}
 						else
 						{
 							// This must be an existing file, or it is an invalid argument
 							if(dl.type == DataLocation.RESOURCE_DIRECTORY)
 							{
 								if(Directory.Exists(curarg))
 									dl.location = curarg;
 							}
 							else
 							{
 								if(File.Exists(curarg))
 									dl.location = curarg;
 							}
 							
 							if(string.IsNullOrEmpty(dl.location))
 							{
 								General.WriteLogLine("Unexpected argument \"" + curarg + "\" in program parameters. Expected a valid resource option or a resource filename.");
 								break;
 							}
 						}
 					}
 
 					// Add resource to list
 					if(!string.IsNullOrEmpty(dl.location))
 						autoloadresources.Add(dl);
 				}
 				// Every other arg
 				else
 				{
 					// No command to load file yet?
 					if(autoloadfile == null)
 					{
 						// Check if this is a file we can load
 						if(File.Exists(curarg))
 						{
 							// Load this file!
 							autoloadfile = curarg.Trim();
 						}
 						else
 						{
 							// Note in the log that we cannot find this file
 							General.WriteLogLine("Cannot find the specified file \"" + curarg + "\"");
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersTabsControl.cs" startline="63" endline="77">
<![CDATA[
 		public DockersTabsControl()
 		{
 			if(VisualStyleInformation.IsSupportedByOS && VisualStyleInformation.IsEnabledByUser)
 			{
 				// Style settings
 				this.SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
 				this.SetStyle(ControlStyles.SupportsTransparentBackColor, false);
 				this.SetStyle(ControlStyles.UserPaint, true);
 				this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);
 				this.SetStyle(ControlStyles.Opaque, true);
 				this.UpdateStyles();
 			}
 			
 			highlighttab = -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\World3DShader.cs" startline="171" endline="276">
<![CDATA[
 
 		// This sets up the render pipeline
 		public override void BeginPass(int index)
 		{
 			Device device = manager.D3DDevice.Device;
 
 			if(!manager.Enabled)
 			{
 				// Sampler settings
 				if(General.Settings.VisualBilinear)
 				{
 					device.SetSamplerState(0, SamplerState.MagFilter, TextureFilter.Linear);
 					device.SetSamplerState(0, SamplerState.MinFilter, TextureFilter.Linear);
 					device.SetSamplerState(0, SamplerState.MipFilter, TextureFilter.Linear);
 					device.SetSamplerState(0, SamplerState.MipMapLodBias, 0f);
 				}
 				else
 				{
 					device.SetSamplerState(0, SamplerState.MagFilter, TextureFilter.Point);
 					device.SetSamplerState(0, SamplerState.MinFilter, TextureFilter.Point);
 					device.SetSamplerState(0, SamplerState.MipFilter, TextureFilter.Linear);
 					device.SetSamplerState(0, SamplerState.MipMapLodBias, 0f);
 				}
 
 				// Texture addressing
 				device.SetSamplerState(0, SamplerState.AddressU, TextureAddress.Wrap);
 				device.SetSamplerState(0, SamplerState.AddressV, TextureAddress.Wrap);
 				device.SetSamplerState(0, SamplerState.AddressW, TextureAddress.Wrap);
 				
 				// First texture stage
 				if((index == 0) || (index == 2))
 				{
 					// Normal
 					device.SetTextureStageState(0, TextureStage.ColorOperation, TextureOperation.Modulate);
 					device.SetTextureStageState(0, TextureStage.ColorArg1, TextureArgument.Texture);
 					device.SetTextureStageState(0, TextureStage.ColorArg2, TextureArgument.Diffuse);
 					device.SetTextureStageState(0, TextureStage.ResultArg, TextureArgument.Current);
 					device.SetTextureStageState(0, TextureStage.TexCoordIndex, 0);
 				}
 				else
 				{
 					// Full brightness
 					device.SetTextureStageState(0, TextureStage.ColorOperation, TextureOperation.SelectArg1);
 					device.SetTextureStageState(0, TextureStage.ColorArg1, TextureArgument.Texture);
 					device.SetTextureStageState(0, TextureStage.ResultArg, TextureArgument.Current);
 					device.SetTextureStageState(0, TextureStage.TexCoordIndex, 0);
 				}
 
 				// First alpha stage
 				device.SetTextureStageState(0, TextureStage.AlphaOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(0, TextureStage.AlphaArg1, TextureArgument.Texture);
 				device.SetTextureStageState(0, TextureStage.AlphaArg2, TextureArgument.Diffuse);
 				
 				// Second texture stage
 				device.SetTextureStageState(1, TextureStage.ColorOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(1, TextureStage.ColorArg1, TextureArgument.Current);
 				device.SetTextureStageState(1, TextureStage.ColorArg2, TextureArgument.TFactor);
 				device.SetTextureStageState(1, TextureStage.ResultArg, TextureArgument.Current);
 				device.SetTextureStageState(1, TextureStage.TexCoordIndex, 0);
 
 				// Second alpha stage
 				device.SetTextureStageState(1, TextureStage.AlphaOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(1, TextureStage.AlphaArg1, TextureArgument.Current);
 				device.SetTextureStageState(1, TextureStage.AlphaArg2, TextureArgument.TFactor);
 
 				// Highlight?
 				if(index > 1)
 				{
 					// Third texture stage
 					device.SetTextureStageState(2, TextureStage.ColorOperation, TextureOperation.AddSigned);
 					device.SetTextureStageState(2, TextureStage.ColorArg1, TextureArgument.Current);
 					device.SetTextureStageState(2, TextureStage.ColorArg2, TextureArgument.Texture);
 					device.SetTextureStageState(2, TextureStage.ColorArg0, TextureArgument.Texture);
 					device.SetTextureStageState(2, TextureStage.ResultArg, TextureArgument.Current);
 					device.SetTextureStageState(2, TextureStage.TexCoordIndex, 0);
 
 					// Third alpha stage
 					device.SetTextureStageState(2, TextureStage.AlphaOperation, TextureOperation.SelectArg1);
 					device.SetTextureStageState(2, TextureStage.AlphaArg1, TextureArgument.Current);
 
 					// Fourth texture stage
 					device.SetTextureStageState(3, TextureStage.ColorOperation, TextureOperation.AddSigned);
 					device.SetTextureStageState(3, TextureStage.ColorArg1, TextureArgument.Current);
 					device.SetTextureStageState(3, TextureStage.ColorArg2, TextureArgument.Texture);
 					device.SetTextureStageState(3, TextureStage.ColorArg0, TextureArgument.Texture);
 					device.SetTextureStageState(3, TextureStage.ResultArg, TextureArgument.Current);
 					device.SetTextureStageState(3, TextureStage.TexCoordIndex, 0);
 
 					// Fourth alpha stage
 					device.SetTextureStageState(3, TextureStage.AlphaOperation, TextureOperation.SelectArg1);
 					device.SetTextureStageState(3, TextureStage.AlphaArg1, TextureArgument.Current);
 
 					// No more further stages
 					device.SetTextureStageState(4, TextureStage.ColorOperation, TextureOperation.Disable);
 					device.SetTextureStageState(4, TextureStage.AlphaOperation, TextureOperation.Disable);
 				}
 				else
 				{
 					// No more further stages
 					device.SetTextureStageState(2, TextureStage.ColorOperation, TextureOperation.Disable);
 					device.SetTextureStageState(2, TextureStage.AlphaOperation, TextureOperation.Disable);
 				}
 			}
 
 			base.BeginPass(index);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="3196" endline="3206">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Draw the selection in normal style or with selection highlighted.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void HideSelection(bool normal)
 		{
 			FastPerform(2163, (uint)(normal ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="4441" endline="4452">
<![CDATA[
 
 
 		/// <summary>
 		/// Set whether a pop up menu is displayed automatically when the user presses
 		/// the wrong mouse button.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void UsePopUp(bool allowPopUp)
 		{
 			FastPerform(2371, (uint)(allowPopUp ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="429" endline="440">
<![CDATA[
 
 		/// <summary>
 		/// Is undo history being collected?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsUndoCollection
 		{
 			get
 			{
 				return FastPerform(2019, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="493" endline="505">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Is drawing done first into a buffer or direct to the screen?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsBufferedDraw
 		{
 			get
 			{
 				return FastPerform(2034, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="714" endline="726">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Is the background of the line containing the caret in a different colour?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsCaretLineVisible
 		{
 			get
 			{
 				return FastPerform(2095, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="765" endline="777">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Retrieve whether auto-completion cancelled by backspacing before start.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCGetCancelAtStart
 		{
 			get
 			{
 				return FastPerform(2111, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="782" endline="794">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Retrieve whether a single item auto-completion list automatically choose the item.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCGetChooseSingle
 		{
 			get
 			{
 				return FastPerform(2114, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="799" endline="811">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Retrieve state of ignore case flag.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCGetIgnoreCase
 		{
 			get
 			{
 				return FastPerform(2116, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="816" endline="828">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Retrieve whether or not autocompletion is hidden automatically when nothing matches.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCGetAutoHide
 		{
 			get
 			{
 				return FastPerform(2119, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="833" endline="846">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Retrieve whether or not autocompletion deletes any word characters
 		/// after the inserted text upon completion.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCGetDropRestOfWord
 		{
 			get
 			{
 				return FastPerform(2271, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="885" endline="897">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Retrieve whether tabs will be used in indentation.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsUseTabs
 		{
 			get
 			{
 				return FastPerform(2125, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="943" endline="954">
<![CDATA[
 
 		/// <summary>
 		/// Is the horizontal scroll bar visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsHScrollBar
 		{
 			get
 			{
 				return FastPerform(2131, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1037" endline="1049">
<![CDATA[
 		}
 
 		/// <summary>
 		/// In palette mode?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsUsePalette
 		{
 			get
 			{
 				return FastPerform(2139, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1054" endline="1066">
<![CDATA[
 		}
 
 		/// <summary>
 		/// In read-only mode?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsReadOnly
 		{
 			get
 			{
 				return FastPerform(2140, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1199" endline="1211">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Is the document different from when it was last saved?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsModify
 		{
 			get
 			{
 				return FastPerform(2159, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1252" endline="1264">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Returns true if overtype mode is active otherwise false is returned.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsOvertype
 		{
 			get
 			{
 				return FastPerform(2187, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1390" endline="1401">
<![CDATA[
 
 		/// <summary>
 		/// Is a line visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsLineVisible
 		{
 			get
 			{
 				return FastPerform(2228, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1423" endline="1434">
<![CDATA[
 
 		/// <summary>
 		/// Does a tab pressed when caret is within indentation indent?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsTabIndents
 		{
 			get
 			{
 				return FastPerform(2261, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1439" endline="1451">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Does a backspace pressed when caret is within indentation unindent?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsBackSpaceUnIndents
 		{
 			get
 			{
 				return FastPerform(2263, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1593" endline="1605">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Is the vertical scroll bar visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsVScrollBar
 		{
 			get
 			{
 				return FastPerform(2281, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1610" endline="1622">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Is drawing done in two phases with backgrounds drawn before faoregrounds?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsTwoPhaseDraw
 		{
 			get
 			{
 				return FastPerform(2283, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1627" endline="1639">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Are the end of line characters visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsViewEOL
 		{
 			get
 			{
 				return FastPerform(2355, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1725" endline="1737">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Is the selection rectangular? The alternative is the more common stream selection.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsSelectionIsRectangle
 		{
 			get
 			{
 				return FastPerform(2372, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1774" endline="1787">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Change internal focus flag.
 		/// Get internal focus flag.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsFocus
 		{
 			get
 			{
 				return FastPerform(2381, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1810" endline="1823">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Set whether the mouse is captured when its button is pressed.
 		/// Get whether mouse gets captured.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsMouseDownCaptures
 		{
 			get
 			{
 				return FastPerform(2385, 0, 0) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="180" endline="191">
<![CDATA[
 
 		/// <summary>
 		/// Are there any redoable actions in the undo history?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool CanRedo
 		{
 			get
 			{
 				return FastPerform(2016, 0, 0) != 0 ? true 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="192" endline="204">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Is there an auto-completion list visible?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsAutoCActive
 		{
 			get
 			{
 				return FastPerform(2102, 0, 0) != 0 ? true 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="218" endline="230">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Will a paste succeed?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool CanPaste
 		{
 			get
 			{
 				return FastPerform(2173, 0, 0) != 0 ? true 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="231" endline="243">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Are there any undoable actions in the undo history?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool CanUndo
 		{
 			get
 			{
 				return FastPerform(2174, 0, 0) != 0 ? true 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="244" endline="256">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Is there an active call tip?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool IsCallTipActive
 		{
 			get
 			{
 				return FastPerform(2202, 0, 0) != 0 ? true 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\RenderTargetControl.cs" startline="77" endline="96">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 
 		// This sets up the control to display the splash logo
 		public void SetSplashLogoDisplay()
 		{
 			// Change display to show splash logo
 			this.SetStyle(ControlStyles.SupportsTransparentBackColor, false);
 			this.SetStyle(ControlStyles.ContainerControl, true);
 			this.SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
 			this.SetStyle(ControlStyles.UserPaint, true);
 			this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);
 			this.SetStyle(ControlStyles.Opaque, false);
 			this.UpdateStyles();
 			this.BackColor = System.Drawing.SystemColors.AppWorkspace;
 			this.BackgroundImage = global
 			this.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Center;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\RenderTargetControl.cs" startline="97" endline="112">
<![CDATA[
 		
 		// This sets up the control for manual rendering
 		public void SetManualRendering()
 		{
 			// Change display for rendering
 			this.SetStyle(ControlStyles.SupportsTransparentBackColor, false);
 			this.SetStyle(ControlStyles.ContainerControl, true);
 			this.SetStyle(ControlStyles.OptimizedDoubleBuffer, false);
 			this.SetStyle(ControlStyles.UserPaint, true);
 			this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);
 			this.SetStyle(ControlStyles.Opaque, true);
 			this.UpdateStyles();
 			this.BackColor = Color.Black;
 			this.BackgroundImage = null;
 			this.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Things2DShader.cs" startline="53" endline="84">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public Things2DShader(ShaderManager manager) 
 		{
 			// Load effect from file
 			effect = LoadEffect("things2d.fx");
 
 			// Get the property handlers from effect
 			if(effect != null)
 			{
 				texture1 = effect.GetParameter(null, "texture1");
 				rendersettings = effect.GetParameter(null, "rendersettings");
 				transformsettings = effect.GetParameter(null, "transformsettings");
 			}
 
 			// Initialize world vertex declaration
 			VertexElement[] elements = new VertexElement[]
 			{
 				new VertexElement(0, 0, DeclarationType.Float3, DeclarationMethod.Default, DeclarationUsage.Position, 0),
 				new VertexElement(0, 12, DeclarationType.Color, DeclarationMethod.Default, DeclarationUsage.Color, 0),
 				new VertexElement(0, 16, DeclarationType.Float2, DeclarationMethod.Default, DeclarationUsage.TextureCoordinate, 0),
 				VertexElement.VertexDeclarationEnd
 			};
 			vertexdecl = new VertexDeclaration(General.Map.Graphics.Device, elements);
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Display2DShader.cs" startline="54" endline="86">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public Display2DShader(ShaderManager manager) 
 		{
 			// Load effect from file
 			effect = LoadEffect("display2d.fx");
 
 			// Get the property handlers from effect
 			if(effect != null)
 			{
 				texture1 = effect.GetParameter(null, "texture1");
 				rendersettings = effect.GetParameter(null, "rendersettings");
 				transformsettings = effect.GetParameter(null, "transformsettings");
 				filtersettings = effect.GetParameter(null, "filtersettings");
 			}
 			
 			// Initialize world vertex declaration
 			VertexElement[] elements = new VertexElement[]
 			{
 				new VertexElement(0, 0, DeclarationType.Float3, DeclarationMethod.Default, DeclarationUsage.Position, 0),
 				new VertexElement(0, 12, DeclarationType.Color, DeclarationMethod.Default, DeclarationUsage.Color, 0),
 				new VertexElement(0, 16, DeclarationType.Float2, DeclarationMethod.Default, DeclarationUsage.TextureCoordinate, 0),
 				VertexElement.VertexDeclarationEnd
 			};
 			vertexdecl = new VertexDeclaration(General.Map.Graphics.Device, elements);
 
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Display2DShader.cs" startline="124" endline="185">
<![CDATA[
 
 		// This sets up the render pipeline
 		public override void BeginPass(int index)
 		{
 			Device device = manager.D3DDevice.Device;
 
 			if(!manager.Enabled)
 			{
 				// Sampler settings
 				if(General.Settings.ClassicBilinear)
 				{
 					device.SetSamplerState(0, SamplerState.MagFilter, TextureFilter.Linear);
 					device.SetSamplerState(0, SamplerState.MinFilter, TextureFilter.Linear);
 					device.SetSamplerState(0, SamplerState.MipFilter, TextureFilter.Linear);
 					device.SetSamplerState(0, SamplerState.MipMapLodBias, 0f);
 				}
 				else
 				{
 					device.SetSamplerState(0, SamplerState.MagFilter, TextureFilter.Point);
 					device.SetSamplerState(0, SamplerState.MinFilter, TextureFilter.Point);
 					device.SetSamplerState(0, SamplerState.MipFilter, TextureFilter.Point);
 					device.SetSamplerState(0, SamplerState.MipMapLodBias, 0f);
 				}
 
 				// Texture addressing
 				device.SetSamplerState(0, SamplerState.AddressU, TextureAddress.Wrap);
 				device.SetSamplerState(0, SamplerState.AddressV, TextureAddress.Wrap);
 				device.SetSamplerState(0, SamplerState.AddressW, TextureAddress.Wrap);
 
 				// First texture stage
 				device.SetTextureStageState(0, TextureStage.ColorOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(0, TextureStage.ColorArg1, TextureArgument.Texture);
 				device.SetTextureStageState(0, TextureStage.ColorArg2, TextureArgument.Diffuse);
 				device.SetTextureStageState(0, TextureStage.ResultArg, TextureArgument.Current);
 				device.SetTextureStageState(0, TextureStage.TexCoordIndex, 0);
 
 				// Second texture stage
 				device.SetTextureStageState(1, TextureStage.ColorOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(1, TextureStage.ColorArg1, TextureArgument.Current);
 				device.SetTextureStageState(1, TextureStage.ColorArg2, TextureArgument.TFactor);
 				device.SetTextureStageState(1, TextureStage.ResultArg, TextureArgument.Current);
 				device.SetTextureStageState(1, TextureStage.TexCoordIndex, 0);
 
 				// No more further stages
 				device.SetTextureStageState(2, TextureStage.ColorOperation, TextureOperation.Disable);
 
 				// First alpha stage
 				device.SetTextureStageState(0, TextureStage.AlphaOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(0, TextureStage.AlphaArg1, TextureArgument.Texture);
 				device.SetTextureStageState(0, TextureStage.AlphaArg2, TextureArgument.Diffuse);
 
 				// Second alpha stage
 				device.SetTextureStageState(1, TextureStage.AlphaOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(1, TextureStage.AlphaArg1, TextureArgument.Current);
 				device.SetTextureStageState(1, TextureStage.AlphaArg2, TextureArgument.TFactor);
 
 				// No more further stages
 				device.SetTextureStageState(2, TextureStage.AlphaOperation, TextureOperation.Disable);
 			}
 
 			base.BeginPass(index);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Things2DShader.cs" startline="118" endline="179">
<![CDATA[
 		
 		// This sets up the render pipeline
 		public override void BeginPass(int index)
 		{
 			Device device = manager.D3DDevice.Device;
 
 			if(!manager.Enabled)
 			{
 				// Sampler settings
 				if(General.Settings.ClassicBilinear)
 				{
 					device.SetSamplerState(0, SamplerState.MagFilter, TextureFilter.Linear);
 					device.SetSamplerState(0, SamplerState.MinFilter, TextureFilter.Linear);
 					device.SetSamplerState(0, SamplerState.MipFilter, TextureFilter.Linear);
 					device.SetSamplerState(0, SamplerState.MipMapLodBias, 0f);
 				}
 				else
 				{
 					device.SetSamplerState(0, SamplerState.MagFilter, TextureFilter.Point);
 					device.SetSamplerState(0, SamplerState.MinFilter, TextureFilter.Point);
 					device.SetSamplerState(0, SamplerState.MipFilter, TextureFilter.Point);
 					device.SetSamplerState(0, SamplerState.MipMapLodBias, 0f);
 				}
 
 				// Texture addressing
 				device.SetSamplerState(0, SamplerState.AddressU, TextureAddress.Wrap);
 				device.SetSamplerState(0, SamplerState.AddressV, TextureAddress.Wrap);
 				device.SetSamplerState(0, SamplerState.AddressW, TextureAddress.Wrap);
 
 				// First texture stage
 				device.SetTextureStageState(0, TextureStage.ColorOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(0, TextureStage.ColorArg1, TextureArgument.Texture);
 				device.SetTextureStageState(0, TextureStage.ColorArg2, TextureArgument.Diffuse);
 				device.SetTextureStageState(0, TextureStage.ResultArg, TextureArgument.Current);
 				device.SetTextureStageState(0, TextureStage.TexCoordIndex, 0);
 
 				// Second texture stage
 				device.SetTextureStageState(1, TextureStage.ColorOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(1, TextureStage.ColorArg1, TextureArgument.Current);
 				device.SetTextureStageState(1, TextureStage.ColorArg2, TextureArgument.TFactor);
 				device.SetTextureStageState(1, TextureStage.ResultArg, TextureArgument.Current);
 				device.SetTextureStageState(1, TextureStage.TexCoordIndex, 0);
 
 				// No more further stages
 				device.SetTextureStageState(2, TextureStage.ColorOperation, TextureOperation.Disable);
 
 				// First alpha stage
 				device.SetTextureStageState(0, TextureStage.AlphaOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(0, TextureStage.AlphaArg1, TextureArgument.Texture);
 				device.SetTextureStageState(0, TextureStage.AlphaArg2, TextureArgument.Diffuse);
 
 				// Second alpha stage
 				device.SetTextureStageState(1, TextureStage.AlphaOperation, TextureOperation.Modulate);
 				device.SetTextureStageState(1, TextureStage.AlphaArg1, TextureArgument.Current);
 				device.SetTextureStageState(1, TextureStage.AlphaArg2, TextureArgument.TFactor);
 
 				// No more further stages
 				device.SetTextureStageState(2, TextureStage.AlphaOperation, TextureOperation.Disable);
 			}
 
 			base.BeginPass(index);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TanColorTable.cs" startline="57" endline="95">
<![CDATA[
 
 		internal static void InitTanLunaColors(ref Dictionary<TanColorTable.KnownColors, Color> rgbTable)
 		{
 			rgbTable[TanColorTable.KnownColors.GripDark] = Color.FromArgb(0xc1, 190, 0xb3);
 			rgbTable[TanColorTable.KnownColors.SeparatorDark] = Color.FromArgb(0xc5, 0xc2, 0xb8);
 			rgbTable[TanColorTable.KnownColors.MenuItemSelected] = Color.FromArgb(0xc1, 210, 0xee);
 			rgbTable[TanColorTable.KnownColors.ButtonPressedBorder] = Color.FromArgb(0x31, 0x6a, 0xc5);
 			rgbTable[TanColorTable.KnownColors.CheckBackground] = Color.FromArgb(0xe1, 230, 0xe8);
 			rgbTable[TanColorTable.KnownColors.MenuItemBorder] = Color.FromArgb(0x31, 0x6a, 0xc5);
 			rgbTable[TanColorTable.KnownColors.CheckBackgroundMouseOver] = Color.FromArgb(0x31, 0x6a, 0xc5);
 			rgbTable[TanColorTable.KnownColors.MenuItemBorderMouseOver] = Color.FromArgb(0x4b, 0x4b, 0x6f);
 			rgbTable[TanColorTable.KnownColors.ToolStripDropDownBackground] = Color.FromArgb(0xfc, 0xfc, 0xf9);
 			rgbTable[TanColorTable.KnownColors.MenuBorder] = Color.FromArgb(0x8a, 0x86, 0x7a);
 			rgbTable[TanColorTable.KnownColors.SeparatorLight] = Color.FromArgb(0xff, 0xff, 0xff);
 			rgbTable[TanColorTable.KnownColors.ToolStripBorder] = Color.FromArgb(0xa3, 0xa3, 0x7c);
 			rgbTable[TanColorTable.KnownColors.MenuStripGradientBegin] = Color.FromArgb(0xe5, 0xe5, 0xd7);
 			rgbTable[TanColorTable.KnownColors.MenuStripGradientEnd] = Color.FromArgb(0xf4, 0xf2, 0xe8);
 			rgbTable[TanColorTable.KnownColors.ImageMarginGradientBegin] = Color.FromArgb(0xfe, 0xfe, 0xfb);
 			rgbTable[TanColorTable.KnownColors.ImageMarginGradientMiddle] = Color.FromArgb(0xec, 0xe7, 0xe0);
 			rgbTable[TanColorTable.KnownColors.ImageMarginGradientEnd] = Color.FromArgb(0xbd, 0xbd, 0xa3);
 			rgbTable[TanColorTable.KnownColors.OverflowButtonGradientBegin] = Color.FromArgb(0xf3, 0xf2, 240);
 			rgbTable[TanColorTable.KnownColors.OverflowButtonGradientMiddle] = Color.FromArgb(0xe2, 0xe1, 0xdb);
 			rgbTable[TanColorTable.KnownColors.OverflowButtonGradientEnd] = Color.FromArgb(0x92, 0x92, 0x76);
 			rgbTable[TanColorTable.KnownColors.MenuItemPressedGradientBegin] = Color.FromArgb(0xfc, 0xfc, 0xf9);
 			rgbTable[TanColorTable.KnownColors.MenuItemPressedGradientEnd] = Color.FromArgb(0xf6, 0xf4, 0xec);
 			rgbTable[TanColorTable.KnownColors.ImageMarginRevealedGradientBegin] = Color.FromArgb(0xf7, 0xf6, 0xef);
 			rgbTable[TanColorTable.KnownColors.ImageMarginRevealedGradientMiddle] = Color.FromArgb(0xf2, 240, 0xe4);
 			rgbTable[TanColorTable.KnownColors.ImageMarginRevealedGradientEnd] = Color.FromArgb(230, 0xe3, 210);
 			rgbTable[TanColorTable.KnownColors.ButtonCheckedGradientBegin] = Color.FromArgb(0xe1, 230, 0xe8);
 			rgbTable[TanColorTable.KnownColors.ButtonCheckedGradientMiddle] = Color.FromArgb(0xe1, 230, 0xe8);
 			rgbTable[TanColorTable.KnownColors.ButtonCheckedGradientEnd] = Color.FromArgb(0xe1, 230, 0xe8);
 			rgbTable[TanColorTable.KnownColors.ButtonSelectedGradientBegin] = Color.FromArgb(0xc1, 210, 0xee);
 			rgbTable[TanColorTable.KnownColors.ButtonSelectedGradientMiddle] = Color.FromArgb(0xc1, 210, 0xee);
 			rgbTable[TanColorTable.KnownColors.ButtonSelectedGradientEnd] = Color.FromArgb(0xc1, 210, 0xee);
 			rgbTable[TanColorTable.KnownColors.ButtonPressedGradientBegin] = Color.FromArgb(0x98, 0xb5, 0xe2);
 			rgbTable[TanColorTable.KnownColors.ButtonPressedGradientMiddle] = Color.FromArgb(0x98, 0xb5, 0xe2);
 			rgbTable[TanColorTable.KnownColors.ButtonPressedGradientEnd] = Color.FromArgb(0x98, 0xb5, 0xe2);
 			rgbTable[TanColorTable.KnownColors.GripLight] = Color.FromArgb(0xff, 0xff, 0xff);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DDevice.cs" startline="127" endline="240">
<![CDATA[
 
 		#endregion
 
 		#region ================== Renderstates
 
 		// This completes initialization after the device has started or has been reset
 		public void SetupSettings()
 		{
 			// Setup renderstates
 			device.SetRenderState(RenderState.AlphaBlendEnable, false);
 			device.SetRenderState(RenderState.AlphaBlendEnable, false);
 			device.SetRenderState(RenderState.AlphaFunc, Compare.GreaterEqual);
 			device.SetRenderState(RenderState.AlphaRef, 0x0000007E);
 			device.SetRenderState(RenderState.AlphaTestEnable, false);
 			device.SetRenderState(RenderState.Ambient, Color.White.ToArgb());
 			device.SetRenderState(RenderState.AmbientMaterialSource, ColorSource.Material);
 			device.SetRenderState(RenderState.AntialiasedLineEnable, false);
 			device.SetRenderState(RenderState.Clipping, true);
 			device.SetRenderState(RenderState.ColorVertex, false);
 			device.SetRenderState(RenderState.ColorWriteEnable, ColorWriteEnable.Red | ColorWriteEnable.Green | ColorWriteEnable.Blue | ColorWriteEnable.Alpha);
 			device.SetRenderState(RenderState.CullMode, Cull.None);
 			device.SetRenderState(RenderState.DestinationBlend, Blend.InverseSourceAlpha);
 			device.SetRenderState(RenderState.DiffuseMaterialSource, ColorSource.Color1);
 			device.SetRenderState(RenderState.DitherEnable, true);
 			device.SetRenderState(RenderState.FillMode, FillMode.Solid);
 			device.SetRenderState(RenderState.FogEnable, false);
 			device.SetRenderState(RenderState.FogTableMode, FogMode.Linear);
 			device.SetRenderState(RenderState.Lighting, false);
 			device.SetRenderState(RenderState.LocalViewer, false);
 			device.SetRenderState(RenderState.NormalizeNormals, false);
 			device.SetRenderState(RenderState.PointSpriteEnable, false);
 			device.SetRenderState(RenderState.RangeFogEnable, false);
 			device.SetRenderState(RenderState.SourceBlend, Blend.SourceAlpha);
 			device.SetRenderState(RenderState.SpecularEnable, false);
 			device.SetRenderState(RenderState.StencilEnable, false);
 			device.SetRenderState(RenderState.TextureFactor, -1);
 			device.SetRenderState(RenderState.ZEnable, false);
 			device.SetRenderState(RenderState.ZWriteEnable, false);
 			device.PixelShader = null;
 			device.VertexShader = null;
 
 			// Matrices
 			device.SetTransform(TransformState.World, Matrix.Identity);
 			device.SetTransform(TransformState.View, Matrix.Identity);
 			device.SetTransform(TransformState.Projection, Matrix.Identity);
 			
 			// Sampler settings
 			if(General.Settings.ClassicBilinear)
 			{
 				device.SetSamplerState(0, SamplerState.MagFilter, TextureFilter.Linear);
 				device.SetSamplerState(0, SamplerState.MinFilter, TextureFilter.Linear);
 				device.SetSamplerState(0, SamplerState.MipFilter, TextureFilter.Linear);
 				device.SetSamplerState(0, SamplerState.MipMapLodBias, 0f);
 			}
 			else
 			{
 				device.SetSamplerState(0, SamplerState.MagFilter, TextureFilter.Point);
 				device.SetSamplerState(0, SamplerState.MinFilter, TextureFilter.Point);
 				device.SetSamplerState(0, SamplerState.MipFilter, TextureFilter.Point);
 				device.SetSamplerState(0, SamplerState.MipMapLodBias, 0f);
 			}
 			
 			// Texture addressing
 			device.SetSamplerState(0, SamplerState.AddressU, TextureAddress.Wrap);
 			device.SetSamplerState(0, SamplerState.AddressV, TextureAddress.Wrap);
 			device.SetSamplerState(0, SamplerState.AddressW, TextureAddress.Wrap);
 
 			// First texture stage
 			device.SetTextureStageState(0, TextureStage.ColorOperation, TextureOperation.Modulate);
 			device.SetTextureStageState(0, TextureStage.ColorArg1, TextureArgument.Texture);
 			device.SetTextureStageState(0, TextureStage.ColorArg2, TextureArgument.Diffuse);
 			device.SetTextureStageState(0, TextureStage.ResultArg, TextureArgument.Current);
 			device.SetTextureStageState(0, TextureStage.TexCoordIndex, 0);
 
 			// Second texture stage
 			device.SetTextureStageState(1, TextureStage.ColorOperation, TextureOperation.Modulate);
 			device.SetTextureStageState(1, TextureStage.ColorArg1, TextureArgument.Current);
 			device.SetTextureStageState(1, TextureStage.ColorArg2, TextureArgument.TFactor);
 			device.SetTextureStageState(1, TextureStage.ResultArg, TextureArgument.Current);
 			device.SetTextureStageState(1, TextureStage.TexCoordIndex, 0);
 
 			// No more further stages
 			device.SetTextureStageState(2, TextureStage.ColorOperation, TextureOperation.Disable);
 			
 			// First alpha stage
 			device.SetTextureStageState(0, TextureStage.AlphaOperation, TextureOperation.Modulate);
 			device.SetTextureStageState(0, TextureStage.AlphaArg1, TextureArgument.Texture);
 			device.SetTextureStageState(0, TextureStage.AlphaArg2, TextureArgument.Diffuse);
 
 			// Second alpha stage
 			device.SetTextureStageState(1, TextureStage.AlphaOperation, TextureOperation.Modulate);
 			device.SetTextureStageState(1, TextureStage.AlphaArg1, TextureArgument.Current);
 			device.SetTextureStageState(1, TextureStage.AlphaArg2, TextureArgument.TFactor);
 			
 			// No more further stages
 			device.SetTextureStageState(2, TextureStage.AlphaOperation, TextureOperation.Disable);
 			
 			// Setup material
 			Material material = new Material();
 			material.Ambient = new Color4(Color.White);
 			material.Diffuse = new Color4(Color.White);
 			material.Specular = new Color4(Color.White);
 			device.Material = material;
 			
 			// Shader settings
 			shaders.World3D.SetConstants(General.Settings.VisualBilinear, true, General.Settings.FilterAnisotropy);
 			
 			// Texture filters
 			postfilter = Filter.Point;
 			mipgeneratefilter = Filter.Box;
 			
 			// Initialize presentations
 			Presentation.Initialize();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ColorControl.cs" startline="73" endline="80">
<![CDATA[
 
 		// Mouse pressed on button
 		private void button_MouseDown(object sender, MouseEventArgs e)
 		{
 			// This moves the image 1 pixel to right-bottom
 			if(e.Button == MouseButtons.Left)
 				button.Padding = new Padding(1, 0, 1, 1);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="588" endline="597">
<![CDATA[
 
 		/// <summary>
 		/// Retrieve the mouse click sensitivity of a margin.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool MarginSensitiveN(int margin)
 		{
 			return FastPerform(2247, (uint)margin, 0) != 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1402" endline="1412">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Is a header line expanded?
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public bool FoldExpanded(int line)
 		{
 			return FastPerform(2230, (uint)line, 0) != 0;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="223" endline="229">
<![CDATA[
 
 		// This returns the square distance between two points
 		public static float DistanceSq(Vector2D a, Vector2D b)
 		{
 			Vector2D d = a - b;
 			return d.GetLengthSq();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="230" endline="236">
<![CDATA[
 
 		// This returns the distance between two points
 		public static float Distance(Vector2D a, Vector2D b)
 		{
 			Vector2D d = a - b;
 			return d.GetLength();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="312" endline="318">
<![CDATA[
 
 		// This changes the vector length
 		public Vector2D GetFixedLength(float l)
 		{
 			// Normalize, then scale
 			return this.GetNormal().GetScaled(l);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="297" endline="303">
<![CDATA[
 
 		// This changes the vector length
 		public Vector3D GetFixedLength(float l)
 		{
 			// Normalize, then scale
 			return this.GetNormal().GetScaled(l);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="857" endline="864">
<![CDATA[
 		
 		// This returns an image by string
 		public ImageData GetTextureImage(string name)
 		{
 			// Get the long name
 			long longname = Lump.MakeLongName(name);
 			return GetTextureImage(longname);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DataManager.cs" startline="946" endline="953">
<![CDATA[
 		
 		// This returns an image by string
 		public ImageData GetFlatImage(string name)
 		{
 			// Get the long name
 			long longname = Lump.MakeLongName(name);
 			return GetFlatImage(longname);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Line2D.cs" startline="72" endline="82">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Statics
 
 		// This calculates the length
 		public static float GetLength(float dx, float dy)
 		{
 			// Calculate and return the length
 			return (float)Math.Sqrt(GetLengthSq(dx, dy));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="202" endline="208">
<![CDATA[
 
 		// This returns a vector from an angle
 		public static Vector2D FromAngle(float angle)
 		{
 			// Return vector from angle
 			return new Vector2D((float)Math.Sin(angle), -(float)Math.Cos(angle));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="206" endline="212">
<![CDATA[
 
 		// This returns a vector from an angle
 		public static Vector3D FromAngleXY(float angle)
 		{
 			// Return vector from angle
 			return new Vector3D((float)Math.Sin(angle), -(float)Math.Cos(angle), 0f);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2178" endline="2187">
<![CDATA[
 
 		#endregion
 
 		#region ================== Mode Menu
 
 		// This sets up the modes menu
 		private void UpdateModeMenu()
 		{
 			menumode.Visible = (General.Map != null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.cs" startline="2238" endline="2248">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Tools Menu
 
 		// This sets up the tools menu
 		private void UpdateToolsMenu()
 		{
 			// Enable/disable items
 			itemreloadresources.Enabled = (General.Map != null);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="5" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="244" endline="253">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 
 		// This returns the perpendicular vector by simply making a normal
 		public Vector2D GetPerpendicular()
 		{
 			return new Vector2D(-y, x);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Plane.cs" startline="153" endline="160">
<![CDATA[
 
 		/// <summary>
 		/// This inverts the plane
 		/// </summary>
 		public Plane GetInverted()
 		{
 			return new Plane(-normal, -offset);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="6" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="493" endline="499">
<![CDATA[
 		
 		// This snaps the vertex to the grid
 		public void SnapToGrid()
 		{
 			// Calculate nearest grid coordinates
 			this.Move(General.Map.Grid.SnappedToGrid((Vector2D)pos));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\ImageData.cs" startline="215" endline="225">
<![CDATA[
 		
 		// This loads the image
 		public void LoadImage()
 		{
 			// Do the loading
 			LocalLoadImage();
 
 			// Notify the main thread about the change so that sectors can update their buffers
 			IntPtr strptr = Marshal.StringToCoTaskMemAuto(this.name);
 			General.SendMessage(General.MainWindow.Handle, (int)MainForm.ThreadMessages.ImageDataLoaded, strptr.ToInt32(), 0);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="7" nfragments="17" Csharpe_files="17" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="598" endline="607">
<![CDATA[
 
 		/// <summary>
 		/// Make a margin sensitive or insensitive to mouse clicks.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void MarginSensitiveN(int margin, bool sensitive)
 		{
 			FastPerform(2246, (uint)margin, (uint)(sensitive ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1413" endline="1422">
<![CDATA[
 
 		/// <summary>
 		/// Show the children of a header line.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void FoldExpanded(int line, bool expanded)
 		{
 			FastPerform(2229, (uint)line, (uint)(expanded ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1964" endline="1973">
<![CDATA[
 
 		/// <summary>
 		/// Set a style to be bold or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetBold(int style, bool bold)
 		{
 			FastPerform(2053, (uint)style, (uint)(bold ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="1974" endline="1983">
<![CDATA[
 
 		/// <summary>
 		/// Set a style to be italic or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetItalic(int style, bool italic)
 		{
 			FastPerform(2054, (uint)style, (uint)(italic ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2008" endline="2018">
<![CDATA[
 
 
 		/// <summary>
 		/// Set a style to have its end of line filled or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetEOLFilled(int style, bool filled)
 		{
 			FastPerform(2057, (uint)style, (uint)(filled ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2019" endline="2028">
<![CDATA[
 
 		/// <summary>
 		/// Set a style to be underlined or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetUnderline(int style, bool underline)
 		{
 			FastPerform(2059, (uint)style, (uint)(underline ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2049" endline="2058">
<![CDATA[
 
 		/// <summary>
 		/// Set a style to be a hotspot or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetHotSpot(int style, bool hotspot)
 		{
 			FastPerform(2409, (uint)style, (uint)(hotspot ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2059" endline="2068">
<![CDATA[
 
 		/// <summary>
 		/// Set a style to be visible or not.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetVisible(int style, bool visible)
 		{
 			FastPerform(2074, (uint)style, (uint)(visible ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2084" endline="2095">
<![CDATA[
 
 
 		/// <summary>
 		/// Set a style to be changeable or not (read only).
 		/// Experimental feature, currently buggy.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void StyleSetChangeable(int style, bool changeable)
 		{
 			FastPerform(2099, (uint)style, (uint)(changeable ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2111" endline="2121">
<![CDATA[
 
 
 		/// <summary>
 		/// Set a fore colour for active hotspots.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void HotspotActiveFore(bool useSetting, int fore)
 		{
 			FastPerform(2410, (uint)(useSetting ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2122" endline="2131">
<![CDATA[
 
 		/// <summary>
 		/// Set a back colour for active hotspots.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void HotspotActiveBack(bool useSetting, int back)
 		{
 			FastPerform(2411, (uint)(useSetting ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2897" endline="2907">
<![CDATA[
 
 
 		/// <summary>
 		/// Set the foreground colour of the selection and whether to use this setting.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetSelFore(bool useSetting, int fore)
 		{
 			FastPerform(2067, (uint)(useSetting ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2908" endline="2918">
<![CDATA[
 
 
 		/// <summary>
 		/// Set the background colour of the selection and whether to use this setting.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetSelBack(bool useSetting, int back)
 		{
 			FastPerform(2068, (uint)(useSetting ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2990" endline="3000">
<![CDATA[
 
 
 		/// <summary>
 		/// Set the foreground colour of all whitespace and whether to use this setting.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetWhitespaceFore(bool useSetting, int fore)
 		{
 			FastPerform(2084, (uint)(useSetting ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="3001" endline="3011">
<![CDATA[
 
 
 		/// <summary>
 		/// Set the background colour of all whitespace and whether to use this setting.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetWhitespaceBack(bool useSetting, int back)
 		{
 			FastPerform(2085, (uint)(useSetting ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="3695" endline="3705">
<![CDATA[
 
 
 		/// <summary>
 		/// Set the colours used as a chequerboard pattern in the fold margin
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetFoldMarginColour(bool useSetting, int back)
 		{
 			FastPerform(2290, (uint)(useSetting ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="3706" endline="3716">
<![CDATA[
 
 
 		/// <summary>
 		/// Set the colours used as a chequerboard pattern in the fold margin
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public void SetFoldMarginHiColour(bool useSetting, int fore)
 		{
 			FastPerform(2291, (uint)(useSetting ? 1 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="8" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="195" endline="201">
<![CDATA[
 
 		// This returns the reversed vector
 		public static Vector2D Reversed(Vector2D v)
 		{
 			// Return reversed vector
 			return new Vector2D(-v.x, -v.y);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="199" endline="205">
<![CDATA[
 
 		// This returns the reversed vector
 		public static Vector3D Reversed(Vector3D v)
 		{
 			// Return reversed vector
 			return new Vector3D(-v.x, -v.y, -v.z);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="9" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Line2D.cs" startline="193" endline="203">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Methods
 
 		// This returns the perpendicular vector by simply making a normal
 		public Vector2D GetPerpendicular()
 		{
 			Vector2D d = GetDelta();
 			return new Vector2D(-d.y, d.x);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="237" endline="243">
<![CDATA[
 
 		// This returns the manhattan distance between two points
 		public static float ManhattanDistance(Vector2D a, Vector2D b)
 		{
 			Vector2D d = a - b;
 			return Math.Abs(d.x) + Math.Abs(d.y);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="758" endline="765">
<![CDATA[
 
 		// This calculates the highlight/selection color
 		public Color4 CalculateHighlightColor(bool ishighlighted, bool isselected)
 		{
 			Color4 highlightcolor = isselected ? General.Colors.Selection.ToColorValue() 
 			highlightcolor.Alpha = ishighlighted ? highlightglowinv 
 			return highlightcolor;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="10" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\VisualModes\VisualBlockMap.cs" startline="107" endline="113">
<![CDATA[
 
 		// This returns the key for a block at the given coordinates
 		// TODO
 		private ulong GetBlockKey(Point p)
 		{
 			return unchecked( ((ulong)(uint)p.X << 32) + (ulong)(uint)p.Y );
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1727" endline="1733">
<![CDATA[
 
 		// This calculates the new rectangle when one is scaled into another keeping aspect ratio
 		public static RectangleF MakeZoomedRect(Size source, Rectangle target)
 		{
 			return MakeZoomedRect(new SizeF((int)source.Width, (int)source.Height),
 								  new RectangleF((int)target.Left, (int)target.Top, (int)target.Width, (int)target.Height));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="11" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="185" endline="194">
<![CDATA[
 
 		// This zooms in
 		[BeginAction("zoomin", BaseAction = true)]
 		public virtual void ZoomIn()
 		{
 			float z = 1.0f + General.Settings.ZoomFactor * 0.1f;
 
 			// Zoom
 			ZoomBy(z);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ClassicMode.cs" startline="195" endline="204">
<![CDATA[
 
 		// This zooms out
 		[BeginAction("zoomout", BaseAction = true)]
 		public virtual void ZoomOut()
 		{
 			float z = 1.0f + General.Settings.ZoomFactor * 0.1f;
 
 			// Zoom
 			ZoomBy(1.0f / z);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="12" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="3596" endline="3606">
<![CDATA[
 
 
 		/// <summary>
 		/// Get position of start of word.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int WordStartPosition(int pos, bool onlyWordCharacters)
 		{
 			return (int)FastPerform(2266, (uint)pos, (uint)(onlyWordCharacters ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="3607" endline="3617">
<![CDATA[
 
 
 		/// <summary>
 		/// Get position of end of word.
 		/// 
 		/// </summary>
 		/// <remarks>Autogenerated
 		public int WordEndPosition(int pos, bool onlyWordCharacters)
 		{
 			return (int)FastPerform(2267, (uint)pos, (uint)(onlyWordCharacters ? 1 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="13" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="260" endline="266">
<![CDATA[
 		
 		// This calculates the angle
 		public float GetAngle()
 		{
 			// Calculate and return the angle
 			return -(float)Math.Atan2(-y, x) + (float)Math.PI * 0.5f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="232" endline="242">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Methods
 
 		// This calculates the angle
 		public float GetAngleXY()
 		{
 			// Calculate and return the angle
 			return -(float)Math.Atan2(-y, x) + (float)Math.PI * 0.5f;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="14" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="1779" endline="1791">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Misc Exported Functions
 
 		/// <summary>
 		/// This performs a Hermite spline interpolation and returns the result position.
 		/// Where u (0 - 1) is the wanted position on the curve between p1 (using tangent t1) and p2 (using tangent t2).
 		/// </summary>
 		public static Vector2D HermiteSpline(Vector2D p1, Vector2D t1, Vector2D p2, Vector2D t2, float u)
 		{
 			return D3DDevice.V2D(Vector2.Hermite(D3DDevice.V2(p1), D3DDevice.V2(t1), D3DDevice.V2(p2), D3DDevice.V2(t2), u));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Tools.cs" startline="1792" endline="1800">
<![CDATA[
 
 		/// <summary>
 		/// This performs a Hermite spline interpolation and returns the result position.
 		/// Where u (0 - 1) is the wanted position on the curve between p1 (using tangent t1) and p2 (using tangent t2).
 		/// </summary>
 		public static Vector3D HermiteSpline(Vector3D p1, Vector3D t1, Vector3D p2, Vector3D t2, float u)
 		{
 			return D3DDevice.V3D(Vector3.Hermite(D3DDevice.V3(p1), D3DDevice.V3(t1), D3DDevice.V3(p2), D3DDevice.V3(t2), u));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="15" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="148" endline="154">
<![CDATA[
 
 		// This calculates the dot product
 		public static float DotProduct(Vector2D a, Vector2D b)
 		{
 			// Calculate and return the dot product
 			return a.x * b.x + a.y * b.y;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="175" endline="181">
<![CDATA[
 
 		// This calculates the dot product
 		public static float DotProduct(Vector3D a, Vector3D b)
 		{
 			// Calculate and return the dot product
 			return a.x * b.x + a.y * b.y + a.z * b.z;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="16" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Data\DirectoryReader.cs" startline="321" endline="330">
<![CDATA[
 
 		// This creates a temp file for the speciied file and return the absolute path to the temp file
 		// NOTE
 		protected override string CreateTempFile(string filename)
 		{
 			// Just copy the file
 			string tempfile = General.MakeTempFilename(General.Map.TempPath, "wad");
 			File.Copy(Path.Combine(location.location, filename), tempfile);
 			return tempfile;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1626" endline="1646">
<![CDATA[
 
 		// This shows the reference manual
 		public static void ShowHelp(string pagefile, string chmfile)
 		{
 			// Check if the file can be found in the root
 			string filepathname = Path.Combine(apppath, chmfile);
 			if(!File.Exists(filepathname))
 			{
 				// Check if the file exists in the plugins directory
 				filepathname = Path.Combine(pluginspath, chmfile);
 				if(!File.Exists(filepathname))
 				{
 					// Fail
 					WriteLogLine("ERROR
 					return;
 				}
 			}
 			
 			// Show help file
 			Help.ShowHelp(mainwindow, filepathname, HelpNavigator.Topic, pagefile);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="17" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\EnumItem.cs" startline="73" endline="82">
<![CDATA[
 
 		// This returns the value as int
 		public int GetIntValue()
 		{
 			int result;
 			if(int.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out result))
 				return result;
 			else
 				return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TanColorTable.cs" startline="650" endline="665">
<![CDATA[
 		}
 
 		private bool UseBaseColorTable
 		{
 			get
 			{
 				bool flag1 = !TanColorTable.DisplayInformation.IsLunaTheme ||
 								((TanColorTable.ColorScheme != oliveColorScheme) &&
 								 (TanColorTable.ColorScheme != blueColorScheme));
 				if(flag1 && (this.tanRGB != null))
 				{
 					this.tanRGB.Clear();
 					this.tanRGB = null;
 				}
 				return flag1;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="18" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="216" endline="222">
<![CDATA[
 
 		// This calculates the angle
 		public static float GetAngle(Vector2D a, Vector2D b)
 		{
 			// Calculate and return the angle
 			return -(float)Math.Atan2(-(a.y - b.y), (a.x - b.x)) + (float)Math.PI * 0.5f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Line2D.cs" startline="137" endline="144">
<![CDATA[
 
 		// This tests on which side of the line the given coordinates are
 		// returns < 0 for front (right) side, > 0 for back (left) side and 0 if on the line
 		public static float GetSideOfLine(Vector2D v1, Vector2D v2, Vector2D p)
 		{
 			// Calculate and return side information
 			return (p.y - v1.y) * (v2.x - v1.x) - (p.x - v1.x) * (v2.y - v1.y);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Line2D.cs" startline="179" endline="185">
<![CDATA[
 
 		// This returns the offset coordinates on the line nearest to the given coordinates
 		public static float GetNearestOnLine(Vector2D v1, Vector2D v2, Vector2D p)
 		{
 			// Calculate and return intersection offset
 			return ((p.x - v1.x) * (v2.x - v1.x) + (p.y - v1.y) * (v2.y - v1.y)) / GetLengthSq(v2.x - v1.x, v2.y - v1.y);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Line2D.cs" startline="186" endline="192">
<![CDATA[
 
 		// This returns the coordinates at a specific position on the line
 		public static Vector2D GetCoordinatesAt(Vector2D v1, Vector2D v2, float u)
 		{
 			// Calculate and return intersection offset
 			return new Vector2D(v1.x + u * (v2.x - v1.x), v1.y + u * (v2.y - v1.y));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="163" endline="174">
<![CDATA[
 
 		// This calculates the cross product
 		public static Vector3D CrossProduct(Vector3D a, Vector3D b)
 		{
 			Vector3D result = new Vector3D();
 
 			// Calculate and return the dot product
 			result.x = a.y * b.z - a.z * b.y;
 			result.y = a.z * b.x - a.x * b.z;
 			result.z = a.x * b.y - a.y * b.x;
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="178" endline="194">
<![CDATA[
 		
 		// This reflects the vector v over mirror m
 		// Note that mirror m must be normalized!
 		// R = V - 2 * M * (M dot V)
 		public static Vector2D Reflect(Vector2D v, Vector2D m)
 		{
 			// Get the dot product of v and m
 			float dp = Vector2D.DotProduct(m, v);
 
 			// Make the reflected vector
 			Vector2D mv = new Vector2D();
 			mv.x = v.x - (2f * m.x * dp);
 			mv.y = v.y - (2f * m.y * dp);
 
 			// Return the reflected vector
 			return mv;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="19" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\PixelColor.cs" startline="133" endline="141">
<![CDATA[
 
 		// To ColorValue
 		public Color4 ToColorValue(float withalpha)
 		{
 			return new Color4(withalpha,
 							  (float)r * BYTE_TO_FLOAT,
 							  (float)g * BYTE_TO_FLOAT,
 							  (float)b * BYTE_TO_FLOAT);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\D3DDevice.cs" startline="547" endline="556">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Tools
 
 		// Make a color from ARGB
 		public static int ARGB(float a, float r, float g, float b)
 		{
 			return Color.FromArgb((int)(a * 255f), (int)(r * 255f), (int)(g * 255f), (int)(b * 255f)).ToArgb();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\PixelColor.cs" startline="124" endline="132">
<![CDATA[
 		
 		// To ColorValue
 		public Color4 ToColorValue()
 		{
 			return new Color4((float)a * BYTE_TO_FLOAT,
 							  (float)r * BYTE_TO_FLOAT,
 							  (float)g * BYTE_TO_FLOAT,
 							  (float)b * BYTE_TO_FLOAT);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="20" nfragments="6" Csharpe_files="6" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\NumericTextbox.cs" startline="43" endline="64">
<![CDATA[
 		private bool allownegative = false;		// Allow negative numbers
 		private bool allowrelative = false;		// Allow ++ and -- prefix for relative changes
 		private bool allowdecimal = false;		// Allow decimal (float) numbers
 		private bool controlpressed = false;
 		
 		#endregion
 
 		#region ================== Properties
 
 		public bool AllowNegative { get { return allownegative; } set { allownegative = value; } }
 		public bool AllowRelative { get { return allowrelative; } set { allowrelative = value; } }
 		public bool AllowDecimal { get { return allowdecimal; } set { allowdecimal = value; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public NumericTextbox()
 		{
 			this.ImeMode = ImeMode.Off;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\ScintillaControl.cs" startline="2210" endline="2224">
<![CDATA[
 
 		// Initializer
 		public void Initialize()
 		{
 			// Initialize control
 			libraryptr = General.LoadLibrary(SCINTILLA_FILENAME);
 			controlptr = General.CreateWindowEx(0, SCINTILLA_CLASSNAME, "", WS_CHILD | WS_VISIBLE | WS_TABSTOP, 0, 0,
 												this.Width, this.Height, this.Handle, 0, new IntPtr(0), null);
 			
 			// Get a direct pointer
 			directptr = (int)SlowPerform(2185, 0, 0);
 
 			// Don't know why this is done here again
 			directptr = (int)FastPerform(2185, 0, 0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\LinedefsTracePath.cs" startline="75" endline="97">
<![CDATA[
 
 		#endregion
 
 		#region ================== Methods
 
 		// This checks if the polygon is closed
 		public bool CheckIsClosed()
 		{
 			// There must be at least 2 sidedefs
 			if(base.Count > 1)
 			{
 				// The end sidedef must share a vertex with the first
 				return (base[0].Start == base[base.Count - 1].Start) ||
 					   (base[0].Start == base[base.Count - 1].End) ||
 					   (base[0].End == base[base.Count - 1].Start) ||
 					   (base[0].End == base[base.Count - 1].End);
 			}
 			else
 			{
 				// Not closed
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ThingTypeInfo.cs" startline="95" endline="125">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		internal ThingTypeInfo(int index)
 		{
 			// Initialize
 			this.index = index;
 			this.category = null;
 			this.actor = null;
 			this.title = "<" + index.ToString(CultureInfo.InvariantCulture) + ">";
 			this.sprite = DataManager.INTERNAL_PREFIX + "unknownthing";
 			this.color = 0;
 			this.arrow = true;
 			this.radius = 10f;
 			this.height = 20f;
 			this.hangs = false;
 			this.blocking = 0;
 			this.errorcheck = 0;
 			this.spritescale = new SizeF(1.0f, 1.0f);
 			this.fixedsize = false;
 			this.spritelongname = long.MaxValue;
 			this.args = new ArgumentInfo[Linedef.NUM_ARGS];
 			this.isknown = false;
 			this.absolutez = false;
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\TextLabel.cs" startline="67" endline="126">
<![CDATA[
 		private float lasttranslatex = float.MinValue;
 		private float lasttranslatey;
 		private float lastscalex;
 		private float lastscaley;
 		
 		// Disposing
 		private bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		// Properties
 		public RectangleF Rectangle { get { return rect; } set { rect = value; updateneeded = true; } }
 		public float Left { get { return rect.X; } set { rect.X = value; updateneeded = true; } }
 		public float Top { get { return rect.Y; } set { rect.Y = value; updateneeded = true; } }
 		public float Width { get { return rect.Width; } set { rect.Width = value; updateneeded = true; } }
 		public float Height { get { return rect.Height; } set { rect.Height = value; updateneeded = true; } }
 		public float Right { get { return rect.Right; } set { rect.Width = value - rect.X + 1f; updateneeded = true; } }
 		public float Bottom { get { return rect.Bottom; } set { rect.Height = value - rect.Y + 1f; updateneeded = true; } }
 		public string Text { get { return text; } set { if(text != value.ToUpperInvariant()) { text = value.ToUpperInvariant(); updateneeded = true; } } }
 		public bool TransformCoords { get { return transformcoords; } set { transformcoords = value; updateneeded = true; } }
 		public SizeF TextSize { get { return size; } }
 		public float Scale { get { return scale; } set { scale = value; updateneeded = true; } }
 		public TextAlignmentX AlignX { get { return alignx; } set { alignx = value; updateneeded = true; } }
 		public TextAlignmentY AlignY { get { return aligny; } set { aligny = value; updateneeded = true; } }
 		public PixelColor Color { get { return color; } set { color = value; updateneeded = true; } }
 		public PixelColor Backcolor { get { return backcolor; } set { backcolor = value; updateneeded = true; } }
 		internal VertexBuffer VertexBuffer { get { return textbuffer; } }
 		internal int NumFaces { get { return numfaces; } }
 		
 		// Disposing
 		public bool IsDisposed { get { return isdisposed; } }
 
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor
 		public TextLabel(int capacity)
 		{
 			// Initialize
 			this.text = "";
 			this.rect = new RectangleF(0f, 0f, 1f, 1f);
 			this.color = new PixelColor(255, 255, 255, 255);
 			this.backcolor = new PixelColor(0, 0, 0, 0);
 			this.scale = 10f;
 			this.alignx = TextAlignmentX.Left;
 			this.aligny = TextAlignmentY.Top;
 			this.size = new SizeF(0f, 0f);
 			this.updateneeded = true;
 			this.numfaces = 0;
 			this.capacity = capacity;
 			
 			// Register as resource
 			General.Map.Graphics.RegisterResource(this);
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ThingsFilter.cs" startline="73" endline="116">
<![CDATA[
 		protected bool isdisposed = false;
 
 		#endregion
 
 		#region ================== Properties
 
 		public string Name { get { return name; } internal set { name = value; } }
 		public string CategoryName { get { return categoryname; } internal set { categoryname = value; } }
 		internal int ThingType { get { return thingtype; } set { thingtype = value; } }
 		internal int ThingAngle { get { return thingangle; } set { thingangle = value; } }
 		internal int ThingZHeight { get { return thingzheight; } set { thingzheight = value; } }
 		internal int ThingAction { get { return thingaction; } set { thingaction = value; } }
 		internal int[] ThingArgs { get { return thingargs; } set { Array.Copy(value, thingargs, Thing.NUM_ARGS); } }
 		internal int ThingTag { get { return thingtag; } set { thingtag = value; } }
 		internal UniFields ThingCustomFields { get { return customfields; } set { customfields = new UniFields(value); } }
 		internal ICollection<string> RequiredFields { get { return requiredfields; } }
 		internal ICollection<string> ForbiddenFields { get { return forbiddenfields; } }
 		public ICollection<Thing> VisibleThings { get { return visiblethings; } }
 		public ICollection<Thing> HiddenThings { get { return hiddenthings; } }
 		internal bool IsDisposed { get { return isdisposed; } }
 		
 		#endregion
 		
 		#region ================== Constructor / Disposer
 		
 		// Copy constructor
 		internal ThingsFilter(ThingsFilter f)
 		{
 			// Copy
 			name = f.name;
 			categoryname = f.categoryname;
 			thingtype = f.thingtype;
 			thingzheight = f.thingzheight;
 			thingangle = f.thingangle;
 			thingaction = f.thingaction;
 			thingargs = new int[Thing.NUM_ARGS];
 			Array.Copy(f.thingargs, thingargs, Thing.NUM_ARGS);
 			thingtag = f.thingtag;
 			customfields = new UniFields(f.customfields);
 			requiredfields = new List<string>(f.requiredfields);
 			forbiddenfields = new List<string>(f.forbiddenfields);
 			
 			AdjustForMapFormat();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="21" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ActorStructure.cs" startline="420" endline="433">
<![CDATA[
 		
 		/// <summary>
 		/// This returns a specific value of a specific property as an integer. Returns 0 when the propery does not have the specified value.
 		/// </summary>
 		public int GetPropertyValueInt(string propname, int valueindex)
 		{
 			string str = GetPropertyValueString(propname, valueindex);
 			
 			int intvalue;
 			if(int.TryParse(str, NumberStyles.Integer, CultureInfo.InvariantCulture, out intvalue))
 				return intvalue;
 			else
 				return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1595" endline="1619">
<![CDATA[
 
 		// This shows a message and logs the message
 		public static DialogResult ShowWarningMessage(string message, MessageBoxButtons buttons, MessageBoxDefaultButton defaultbutton)
 		{
 			Cursor oldcursor;
 			DialogResult result;
 
 			// Log the message
 			WriteLogLine(message);
 
 			// Use normal cursor
 			oldcursor = Cursor.Current;
 			Cursor.Current = Cursors.Default;
 
 			// Show message
 			IWin32Window window = null;
 			if((Form.ActiveForm != null) && Form.ActiveForm.Visible) window = Form.ActiveForm;
 			result = MessageBox.Show(window, message, Application.ProductName, buttons, MessageBoxIcon.Warning, defaultbutton);
 
 			// Restore old cursor
 			Cursor.Current = oldcursor;
 
 			// Return result
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1564" endline="1588">
<![CDATA[
 
 		// This shows a message and logs the message
 		public static DialogResult ShowErrorMessage(string message, MessageBoxButtons buttons)
 		{
 			Cursor oldcursor;
 			DialogResult result;
 			
 			// Log the message
 			WriteLogLine(message);
 			
 			// Use normal cursor
 			oldcursor = Cursor.Current;
 			Cursor.Current = Cursors.Default;
 			
 			// Show message
 			IWin32Window window = null;
 			if((Form.ActiveForm != null) && Form.ActiveForm.Visible) window = Form.ActiveForm;
 			result = MessageBox.Show(window, message, Application.ProductName, buttons, MessageBoxIcon.Error);
 
 			// Restore old cursor
 			Cursor.Current = oldcursor;
 			
 			// Return result
 			return result;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="22" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Vertex.cs" startline="246" endline="254">
<![CDATA[
 
 		// This snaps the vertex to the map format accuracy
 		public void SnapToAccuracy()
 		{
 			// Round the coordinates
 			Vector2D newpos = new Vector2D((float)Math.Round(pos.x, General.Map.FormatInterface.VertexDecimals),
 										   (float)Math.Round(pos.y, General.Map.FormatInterface.VertexDecimals));
 			this.Move(newpos);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Thing.cs" startline="500" endline="509">
<![CDATA[
 
 		// This snaps the vertex to the map format accuracy
 		public void SnapToAccuracy()
 		{
 			// Round the coordinates
 			Vector3D newpos = new Vector3D((float)Math.Round(pos.x, General.Map.FormatInterface.VertexDecimals),
 										   (float)Math.Round(pos.y, General.Map.FormatInterface.VertexDecimals),
 										   (float)Math.Round(pos.z, General.Map.FormatInterface.VertexDecimals));
 			this.Move(newpos);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="23" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\UniversalParser.cs" startline="106" endline="123">
<![CDATA[
 		
 		#endregion
 		
 		#region ================== Private Methods
 
 		// This returns a string added with escape characters
 		private string EscapedString(string str)
 		{
 			// Replace the \ with \\ first!
 			str = str.Replace("\\", "\\\\");
 			str = str.Replace("\n", "\\n");
 			str = str.Replace("\r", "\\r");
 			str = str.Replace("\t", "\\t");
 			str = str.Replace("\"", "\\\"");
 			
 			// Return result
 			return str;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\Configuration.cs" startline="405" endline="419">
<![CDATA[
 		
 		
 		// This returns a string added with escape characters
 		private string EscapedString(string str)
 		{
 			// Replace the \ with \\ first!
 			str = str.Replace("\\", "\\\\");
 			str = str.Replace("\n", "\\n");
 			str = str.Replace("\r", "\\r");
 			str = str.Replace("\t", "\\t");
 			str = str.Replace("\"", "\\\"");
 			
 			// Return result
 			return str;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="24" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\FlatSelectorControl.cs" startline="51" endline="66">
<![CDATA[
 		
 		// This finds the image we need for the given flat name
 		protected override Image FindImage(string imagename)
 		{
 			// Check if name is a "none" texture
 			if((imagename.Length < 1) || (imagename[0] == '-'))
 			{
 				// Flat required!
 				return CodeImp.DoomBuilder.Properties.Resources.MissingTexture;
 			}
 			else
 			{
 				// Set the image
 				return General.Map.Data.GetFlatImage(imagename).GetPreview();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\ZDoom\ZDTextParser.cs" startline="113" endline="126">
<![CDATA[
 		
 		// This removes beginning and ending quotes from a token
 		protected internal string StripTokenQuotes(string token)
 		{
 			// Remove first character, if it is a quote
 			if(!string.IsNullOrEmpty(token) && (token[0] == '"'))
 				token = token.Substring(1);
 			
 			// Remove last character, if it is a quote
 			if(!string.IsNullOrEmpty(token) && (token[token.Length - 1] == '"'))
 				token = token.Substring(0, token.Length - 1);
 			
 			return token;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="25" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="8" endline="103">
<![CDATA[
 		private System.ComponentModel.IContainer components = null;
 		public DockersControl()
 		{
 			InitializeComponent();
 			expandedwidth = (int)((float)this.Width * (this.CurrentAutoScaleDimensions.Width / this.AutoScaleDimensions.Width));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="336" endline="358">
<![CDATA[
 		
 		// This creates matrices for a camera view
 		public void PositionAndLookAt(Vector3D pos, Vector3D lookat)
 		{
 			Vector3D delta;
 			float anglexy, anglez;
 			
 			// Calculate delta vector
 			cameraposition = pos;
 			delta = lookat - pos;
 			anglexy = delta.GetAngleXY();
 			anglez = delta.GetAngleZ();
 
 			// Create frustum
 			frustum = new ProjectedFrustum2D(pos, anglexy, anglez, PROJ_NEAR_PLANE,
 				General.Settings.ViewDistance, Angle2D.DegToRad((float)General.Settings.VisualFOV));
 			
 			// Make the view matrix
 			view3d = Matrix.LookAtRH(D3DDevice.V3(pos), D3DDevice.V3(lookat), new Vector3(0f, 0f, 1f));
 			
 			// Make the billboard matrix
 			billboard = Matrix.RotationZ(anglexy + Angle2D.PI);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="359" endline="367">
<![CDATA[
 		
 		// This creates 2D view matrix
 		private void CreateMatrices2D()
 		{
 			windowsize = graphics.RenderTarget.ClientSize;
 			Matrix scaling = Matrix.Scaling((1f / (float)windowsize.Width) * 2f, (1f / (float)windowsize.Height) * -2f, 1f);
 			Matrix translate = Matrix.Translation(-(float)windowsize.Width * 0.5f, -(float)windowsize.Height * 0.5f, 0f);
 			view2d = Matrix.Multiply(translate, scaling);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="26" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector3D.cs" startline="220" endline="231">
<![CDATA[
 
 		// This returns a vector from an angle with a given legnth
 		public static Vector3D FromAngleXYZ(float anglexy, float anglez)
 		{
 			// Calculate x y and z
 			float ax = (float)Math.Sin(anglexy) * (float)Math.Cos(anglez);
 			float ay = -(float)Math.Cos(anglexy) * (float)Math.Cos(anglez);
 			float az = (float)Math.Sin(anglez);
 
 			// Return vector
 			return new Vector3D(ax, ay, az);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\Vector2D.cs" startline="337" endline="346">
<![CDATA[
 		
         // Rotate (Added by Anders ?strand 2008-05-18)
         public unsafe Vector2D GetRotated(float theta)
         {
 			double cos = Math.Cos(theta);
 			double sin = Math.Sin(theta);
             double rx = cos * x - sin * y;
             double ry = sin * x + cos * y;
             return new Vector2D((float)rx, (float)ry);
         }
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="27" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Controls\DockersControl.cs" startline="193" endline="203">
<![CDATA[
 		
 		// This calculates the collapsed width
 		public int GetCollapsedWidth()
 		{
 			Rectangle r;
 			if(tabs.TabPages.Count > 0)
 				r = tabs.GetTabRect(0);
 			else
 				r = new Rectangle(0, 0, 26, 26);
 			return r.Width + (int)(1.0f * (this.CurrentAutoScaleDimensions.Width / this.AutoScaleDimensions.Width));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\ColorCollection.cs" startline="239" endline="251">
<![CDATA[
 		
 		// This creates a brighter color
 		public PixelColor CreateBrightVariant(PixelColor pc)
 		{
 			Color4 o = pc.ToColorValue();
 			Color4 c = new Color4(1f, 0f, 0f, 0f);
 						
 			// Create brighter color
 			c.Red = Saturate(o.Red * BRIGHT_MULTIPLIER + BRIGHT_ADDITION);
 			c.Green = Saturate(o.Green * BRIGHT_MULTIPLIER + BRIGHT_ADDITION);
 			c.Blue = Saturate(o.Blue * BRIGHT_MULTIPLIER + BRIGHT_ADDITION);
 			return PixelColor.FromInt(c.ToArgb());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\ColorCollection.cs" startline="252" endline="264">
<![CDATA[
 
 		// This creates a darker color
 		public PixelColor CreateDarkVariant(PixelColor pc)
 		{
 			Color4 o = pc.ToColorValue();
 			Color4 c = new Color4(1f, 0f, 0f, 0f);
 
 			// Create darker color
 			c.Red = Saturate(o.Red * DARK_MULTIPLIER + DARK_ADDITION);
 			c.Green = Saturate(o.Green * DARK_MULTIPLIER + DARK_ADDITION);
 			c.Blue = Saturate(o.Blue * DARK_MULTIPLIER + DARK_ADDITION);
 			return PixelColor.FromInt(c.ToArgb());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="28" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Plotter.cs" startline="179" endline="193">
<![CDATA[
 
 		// This draws a dotted grid line vertically
 		public void DrawGridLineV(int x, int y1, int y2, ref PixelColor c)
 		{
 			int numpixels = visibleheight >> 1;
 			int offset = x & 0x01;
 			y1 = General.Clamp(y1 >> 1, 0, numpixels - 1);
 			y2 = General.Clamp(y2 >> 1, 0, numpixels - 1);
 			
 			if((x >= 0) && (x < width))
 			{
 				// Draw all pixels on this line
 				for (int i = y1; i < y2; i++) pixels[((i << 1) | offset) * width + x] = c;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\IO\DoomFlatReader.cs" startline="177" endline="240">
<![CDATA[
 
 		// This creates pixel color data from the given data
 		// Returns null on failure
 		private PixelColorBlock ReadAsPixelData(Stream stream, out int width, out int height)
 		{
 			BinaryReader reader = new BinaryReader(stream);
 			PixelColorBlock pixeldata = null;
 			float sqrlength;
 			byte[] bytes;
 			
 			// Check if the flat is square
 			sqrlength = (float)Math.Sqrt(stream.Length);
 			if(sqrlength == (float)Math.Truncate(sqrlength))
 			{
 				// Calculate image size
 				width = (int)sqrlength;
 				height = (int)sqrlength;
 			}
 			// Check if the data is more than 4096
 			else if(stream.Length > 4096)
 			{
 				// Image will be 64x64
 				width = 64;
 				height = 64;
 			}
 			else
 			{
 				// Invalid
 				width = 0;
 				height = 0;
 				return null;
 			}
 
 			#if !DEBUG
 			try
 			{
 			#endif
 			
 			// Valid width and height?
 			if((width <= 0) || (height <= 0)) return null;
 
 			// Allocate memory
 			pixeldata = new PixelColorBlock(width, height);
 			pixeldata.Clear();
 
 			// Read flat bytes from stream
 			bytes = new byte[width * height];
 			stream.Read(bytes, 0, width * height);
 
 			// Convert bytes with palette
 			for(uint i = 0; i < width * height; i++) pixeldata.Pointer[i] = palette[bytes[i];
 
 			// Return pointer
 			return pixeldata;
 			
 			#if !DEBUG
 			}
 			catch(Exception)
 			{
 				// Return nothing
 				return null;
 			}
 			#endif
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="29" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\TextureBrowserForm.cs" startline="261" endline="286">
<![CDATA[
 
 		// Closing
 		private void TextureBrowserForm_FormClosing(object sender, FormClosingEventArgs e)
 		{
 			int windowstate;
 
 			// Determine window state to save
 			if(this.WindowState != FormWindowState.Minimized)
 				windowstate = (int)this.WindowState;
 			else
 				windowstate = (int)FormWindowState.Normal;
 
 			// Save window settings
 			General.Settings.WriteSetting("browserwindow.positionx", lastposition.X);
 			General.Settings.WriteSetting("browserwindow.positiony", lastposition.Y);
 			General.Settings.WriteSetting("browserwindow.sizewidth", lastsize.Width);
 			General.Settings.WriteSetting("browserwindow.sizeheight", lastsize.Height);
 			General.Settings.WriteSetting("browserwindow.windowstate", windowstate);
 			
 			// Save last selected texture set
 			if(texturesets.SelectedItems.Count > 0)
 				General.Settings.WriteSetting("browserwindow.textureset", texturesets.SelectedItems[0].Text);
 			
 			// Clean up
 			browser.CleanUp();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\FlatBrowserForm.cs" startline="260" endline="285">
<![CDATA[
 
 		// Closing
 		private void FlatBrowserForm_FormClosing(object sender, FormClosingEventArgs e)
 		{
 			int windowstate;
 
 			// Determine window state to save
 			if(this.WindowState != FormWindowState.Minimized)
 				windowstate = (int)this.WindowState;
 			else
 				windowstate = (int)FormWindowState.Normal;
 
 			// Save window settings
 			General.Settings.WriteSetting("browserwindow.positionx", lastposition.X);
 			General.Settings.WriteSetting("browserwindow.positiony", lastposition.Y);
 			General.Settings.WriteSetting("browserwindow.sizewidth", lastsize.Width);
 			General.Settings.WriteSetting("browserwindow.sizeheight", lastsize.Height);
 			General.Settings.WriteSetting("browserwindow.windowstate", windowstate);
 			
 			// Save last selected texture set
 			if(texturesets.SelectedItems.Count > 0)
 				General.Settings.WriteSetting("browserwindow.textureset", texturesets.SelectedItems[0].Text);
 			
 			// Clean up
 			browser.CleanUp();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="30" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\PixelColor.cs" startline="148" endline="162">
<![CDATA[
 		
 		// This blends two colors with respect to alpha
 		public PixelColor Blend(PixelColor a, PixelColor b)
 		{
 			PixelColor c = new PixelColor();
 			float ba;
 			
 			ba = (float)a.a * BYTE_TO_FLOAT;
 			c.r = (byte)((float)a.r * (1f - ba) + (float)b.r * ba);
 			c.g = (byte)((float)a.g * (1f - ba) + (float)b.g * ba);
 			c.b = (byte)((float)a.b * (1f - ba) + (float)b.b * ba);
 			c.a = (byte)((float)a.a * (1f - ba) + ba);
 			
 			return c;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\PixelColor.cs" startline="163" endline="181">
<![CDATA[
 		
 		// This modulates two colors
 		public static PixelColor Modulate(PixelColor a, PixelColor b)
 		{
 			float aa = (float)a.a * BYTE_TO_FLOAT;
 			float ar = (float)a.r * BYTE_TO_FLOAT;
 			float ag = (float)a.g * BYTE_TO_FLOAT;
 			float ab = (float)a.b * BYTE_TO_FLOAT;
 			float ba = (float)b.a * BYTE_TO_FLOAT;
 			float br = (float)b.r * BYTE_TO_FLOAT;
 			float bg = (float)b.g * BYTE_TO_FLOAT;
 			float bb = (float)b.b * BYTE_TO_FLOAT;
 			PixelColor c = new PixelColor();
 			c.a = (byte)((aa * ba) * 255.0f);
 			c.r = (byte)((ar * br) * 255.0f);
 			c.g = (byte)((ag * bg) * 255.0f);
 			c.b = (byte)((ab * bb) * 255.0f);
 			return c;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="31" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1039" endline="1079">
<![CDATA[
 		internal static bool CloseMap()
 		{
 			// Cancel volatile mode, if any
 			General.Editing.DisengageVolatileMode();
 
 			// Ask the user to save changes (if any)
 			if(General.AskSaveMap())
 			{
 				// Display status
 				mainwindow.DisplayStatus(StatusType.Busy, "Closing map...");
 				General.WriteLogLine("Unloading map...");
 				Cursor.Current = Cursors.WaitCursor;
 				
 				// Trash the current map
 				if(map != null) map.Dispose();
 				map = null;
 				
 				// Clear errors
 				General.ErrorLogger.Clear();
 				
 				// Show splash logo on display
 				mainwindow.ShowSplashDisplay();
 				
 				// Done
 				Cursor.Current = Cursors.Default;
 				editing.UpdateCurrentEditModes();
 				mainwindow.SetupInterface();
 				mainwindow.RedrawDisplay();
 				mainwindow.HideInfo();
 				mainwindow.UpdateThingsFilters();
 				mainwindow.UpdateInterface();
 				mainwindow.DisplayReady();
 				General.WriteLogLine("Map unload done");
 				return true;
 			}
 			else
 			{
 				// User cancelled
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\General\General.cs" startline="1131" endline="1189">
<![CDATA[
 		
 		// This opens the specified file without dialog
 		internal static void OpenMapFileWithOptions(string filename, MapOptions options)
 		{
 			// Display status
 			mainwindow.DisplayStatus(StatusType.Busy, "Opening map file...");
 			Cursor.Current = Cursors.WaitCursor;
 
 			// Clear the display
 			mainwindow.ClearDisplay();
 
 			// Trash the current map, if any
 			if(map != null) map.Dispose();
 
 			// Let the plugins know
 			plugins.OnMapOpenBegin();
 
 			// Set this to false so we can see if errors are added
 			General.ErrorLogger.IsErrorAdded = false;
 
 			// Create map manager with given options
 			map = new MapManager();
 			if(map.InitializeOpenMap(filename, options))
 			{
 				// Add recent file
 				mainwindow.AddRecentFile(filename);
 			}
 			else
 			{
 				// Unable to create map manager
 				map.Dispose();
 				map = null;
 
 				// Show splash logo on display
 				mainwindow.ShowSplashDisplay();
 			}
 
 			// Let the plugins know
 			plugins.OnMapOpenEnd();
 
 			// All done
 			settings.FindDefaultDrawSettings();
 			mainwindow.SetupInterface();
 			mainwindow.RedrawDisplay();
 			mainwindow.UpdateThingsFilters();
 			mainwindow.UpdateInterface();
 			mainwindow.HideInfo();
 
 			if(errorlogger.IsErrorAdded)
 			{
 				// Show any errors if preferred
 				mainwindow.DisplayStatus(StatusType.Warning, "There were errors during loading!");
 				if(!delaymainwindow && General.Settings.ShowErrorsWindow) mainwindow.ShowErrors();
 			}
 			else
 				mainwindow.DisplayReady();
 			
 			Cursor.Current = Cursors.Default;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="32" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Map\Linedef.cs" startline="586" endline="605">
<![CDATA[
 		
 		// This returns a point for testing on one side
 		public Vector2D GetSidePoint(bool front)
 		{
 			Vector2D n = new Vector2D();
 			n.x = (end.Position.x - start.Position.x) * lengthinv * SIDE_POINT_DISTANCE;
 			n.y = (end.Position.y - start.Position.y) * lengthinv * SIDE_POINT_DISTANCE;
 
 			if(front)
 			{
 				n.x = -n.x;
 				n.y = -n.y;
 			}
 
 			Vector2D p = new Vector2D();
 			p.x = start.Position.x + (end.Position.x - start.Position.x) * 0.5f - n.y;
 			p.y = start.Position.y + (end.Position.y - start.Position.y) * 0.5f + n.x;
 
 			return p;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="748" endline="795">
<![CDATA[
 
 		#endregion
 
 		#region ================== Background
 
 		// This sets up background image vertices
 		private void SetupBackground()
 		{
 			Vector2D ltpos, rbpos;
 			Vector2D backoffset = new Vector2D((float)General.Map.Grid.BackgroundX, (float)General.Map.Grid.BackgroundY);
 			Vector2D backimagesize = new Vector2D((float)General.Map.Grid.Background.ScaledWidth, (float)General.Map.Grid.Background.ScaledHeight);
 			Vector2D backimagescale = new Vector2D(General.Map.Grid.BackgroundScaleX, General.Map.Grid.BackgroundScaleY);
 			
 			// Scale the background image size
 			backimagesize *= backimagescale;
 			
 			// Only if a background image is set
 			if((General.Map.Grid.Background != null) &&
 			   !(General.Map.Grid.Background is UnknownImage))
 			{
 				// Make vertices
 				backimageverts = CreateScreenVerts(windowsize);
 
 				// Determine map coordinates for view window
 				ltpos = DisplayToMap(new Vector2D(0f, 0f));
 				rbpos = DisplayToMap(new Vector2D(windowsize.Width, windowsize.Height));
 				
 				// Offset by given background offset
 				ltpos -= backoffset;
 				rbpos -= backoffset;
 				
 				// Calculate UV coordinates
 				// NOTE
 				backimageverts[0].u = ltpos.x / backimagesize.x;
 				backimageverts[0].v = ltpos.y / -backimagesize.y;
 				backimageverts[1].u = rbpos.x / backimagesize.x;
 				backimageverts[1].v = ltpos.y / -backimagesize.y;
 				backimageverts[2].u = ltpos.x / backimagesize.x;
 				backimageverts[2].v = rbpos.y / -backimagesize.y;
 				backimageverts[3].u = rbpos.x / backimagesize.x;
 				backimageverts[3].v = rbpos.y / -backimagesize.y;
 			}
 			else
 			{
 				// No background image
 				backimageverts = null;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="33" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.Designer.cs" startline="23" endline="1494">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.Label label7;
 			System.Windows.Forms.Label label6;
 			System.Windows.Forms.Label label5;
 			System.Windows.Forms.GroupBox groupBox1;
 			System.Windows.Forms.Label label1;
 			this.scriptontop = new System.Windows.Forms.CheckBox();
 			this.zoomfactor = new Dotnetrix.Controls.TrackBar();
 			this.zoomfactorlabel = new System.Windows.Forms.Label();
 			this.label19 = new System.Windows.Forms.Label();
 			this.autoscrollspeed = new Dotnetrix.Controls.TrackBar();
 			this.autoscrollspeedlabel = new System.Windows.Forms.Label();
 			this.label15 = new System.Windows.Forms.Label();
 			this.previewsize = new Dotnetrix.Controls.TrackBar();
 			this.previewsizelabel = new System.Windows.Forms.Label();
 			this.label12 = new System.Windows.Forms.Label();
 			this.label14 = new System.Windows.Forms.Label();
 			this.defaultviewmode = new System.Windows.Forms.ComboBox();
 			this.keyusedlabel = new System.Windows.Forms.Label();
 			this.colorsgroup1 = new System.Windows.Forms.GroupBox();
 			this.label2 = new System.Windows.Forms.Label();
 			this.colorgrid64 = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.squarethings = new System.Windows.Forms.CheckBox();
 			this.colorgrid = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.doublesidedalphalabel = new System.Windows.Forms.Label();
 			this.colorindication = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorsoundlinedefs = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorspeciallinedefs = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.qualitydisplay = new System.Windows.Forms.CheckBox();
 			this.colorbackcolor = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorselection = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorvertices = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.doublesidedalpha = new Dotnetrix.Controls.TrackBar();
 			this.colorhighlight = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorlinedefs = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.tabs = new System.Windows.Forms.TabControl();
 			this.tabinterface = new System.Windows.Forms.TabPage();
 			this.groupBox5 = new System.Windows.Forms.GroupBox();
 			this.toolbar_file = new System.Windows.Forms.CheckBox();
 			this.toolbar_testing = new System.Windows.Forms.CheckBox();
 			this.toolbar_geometry = new System.Windows.Forms.CheckBox();
 			this.toolbar_viewmodes = new System.Windows.Forms.CheckBox();
 			this.toolbar_filter = new System.Windows.Forms.CheckBox();
 			this.toolbar_prefabs = new System.Windows.Forms.CheckBox();
 			this.toolbar_copy = new System.Windows.Forms.CheckBox();
 			this.toolbar_undo = new System.Windows.Forms.CheckBox();
 			this.toolbar_script = new System.Windows.Forms.CheckBox();
 			this.groupBox4 = new System.Windows.Forms.GroupBox();
 			this.collapsedockers = new System.Windows.Forms.CheckBox();
 			this.dockersposition = new System.Windows.Forms.ComboBox();
 			this.label17 = new System.Windows.Forms.Label();
 			this.groupBox2 = new System.Windows.Forms.GroupBox();
 			this.viewdistance = new Dotnetrix.Controls.TrackBar();
 			this.movespeed = new Dotnetrix.Controls.TrackBar();
 			this.mousespeed = new Dotnetrix.Controls.TrackBar();
 			this.fieldofview = new Dotnetrix.Controls.TrackBar();
 			this.viewdistancelabel = new System.Windows.Forms.Label();
 			this.label13 = new System.Windows.Forms.Label();
 			this.invertyaxis = new System.Windows.Forms.CheckBox();
 			this.movespeedlabel = new System.Windows.Forms.Label();
 			this.label11 = new System.Windows.Forms.Label();
 			this.mousespeedlabel = new System.Windows.Forms.Label();
 			this.label9 = new System.Windows.Forms.Label();
 			this.fieldofviewlabel = new System.Windows.Forms.Label();
 			this.label4 = new System.Windows.Forms.Label();
 			this.tabkeys = new System.Windows.Forms.TabPage();
 			this.listactions = new System.Windows.Forms.ListView();
 			this.columncontrolaction = new System.Windows.Forms.ColumnHeader();
 			this.columncontrolkey = new System.Windows.Forms.ColumnHeader();
 			this.actioncontrolpanel = new System.Windows.Forms.GroupBox();
 			this.keyusedlist = new System.Windows.Forms.ListBox();
 			this.disregardshiftlabel = new System.Windows.Forms.Label();
 			this.actioncontrol = new System.Windows.Forms.ComboBox();
 			this.actiontitle = new System.Windows.Forms.Label();
 			this.actioncontrolclear = new System.Windows.Forms.Button();
 			this.actionkey = new System.Windows.Forms.TextBox();
 			this.actiondescription = new System.Windows.Forms.Label();
 			this.tabcolors = new System.Windows.Forms.TabPage();
 			this.appearancegroup1 = new System.Windows.Forms.GroupBox();
 			this.animatevisualselection = new System.Windows.Forms.CheckBox();
 			this.blackbrowsers = new System.Windows.Forms.CheckBox();
 			this.visualbilinear = new System.Windows.Forms.CheckBox();
 			this.classicbilinear = new System.Windows.Forms.CheckBox();
 			this.imagebrightnesslabel = new System.Windows.Forms.Label();
 			this.imagebrightness = new Dotnetrix.Controls.TrackBar();
 			this.colorsgroup3 = new System.Windows.Forms.GroupBox();
 			this.scripttabwidth = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.scriptautoindent = new System.Windows.Forms.CheckBox();
 			this.label10 = new System.Windows.Forms.Label();
 			this.panel1 = new System.Windows.Forms.Panel();
 			this.scriptfontlabel = new System.Windows.Forms.Label();
 			this.scriptfontsize = new System.Windows.Forms.ComboBox();
 			this.label8 = new System.Windows.Forms.Label();
 			this.scriptfontbold = new System.Windows.Forms.CheckBox();
 			this.scriptfontname = new System.Windows.Forms.ComboBox();
 			this.label3 = new System.Windows.Forms.Label();
 			this.colorconstants = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorliterals = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorscriptbackground = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorkeywords = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorlinenumbers = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorcomments = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.colorplaintext = new CodeImp.DoomBuilder.Controls.ColorControl();
 			this.tabpasting = new System.Windows.Forms.TabPage();
 			this.label16 = new System.Windows.Forms.Label();
 			this.pasteoptions = new CodeImp.DoomBuilder.Controls.PasteOptionsControl();
 			this.showtexturesizes = new System.Windows.Forms.CheckBox();
 			label7 = new System.Windows.Forms.Label();
 			label6 = new System.Windows.Forms.Label();
 			label5 = new System.Windows.Forms.Label();
 			groupBox1 = new System.Windows.Forms.GroupBox();
 			label1 = new System.Windows.Forms.Label();
 			groupBox1.SuspendLayout();
 			((System.ComponentModel.ISupportInitialize)(this.zoomfactor)).BeginInit();
 			((System.ComponentModel.ISupportInitialize)(this.autoscrollspeed)).BeginInit();
 			((System.ComponentModel.ISupportInitialize)(this.previewsize)).BeginInit();
 			this.colorsgroup1.SuspendLayout();
 			((System.ComponentModel.ISupportInitialize)(this.doublesidedalpha)).BeginInit();
 			this.tabs.SuspendLayout();
 			this.tabinterface.SuspendLayout();
 			this.groupBox5.SuspendLayout();
 			this.groupBox4.SuspendLayout();
 			this.groupBox2.SuspendLayout();
 			((System.ComponentModel.ISupportInitialize)(this.viewdistance)).BeginInit();
 			((System.ComponentModel.ISupportInitialize)(this.movespeed)).BeginInit();
 			((System.ComponentModel.ISupportInitialize)(this.mousespeed)).BeginInit();
 			((System.ComponentModel.ISupportInitialize)(this.fieldofview)).BeginInit();
 			this.tabkeys.SuspendLayout();
 			this.actioncontrolpanel.SuspendLayout();
 			this.tabcolors.SuspendLayout();
 			this.appearancegroup1.SuspendLayout();
 			((System.ComponentModel.ISupportInitialize)(this.imagebrightness)).BeginInit();
 			this.colorsgroup3.SuspendLayout();
 			this.panel1.SuspendLayout();
 			this.tabpasting.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// label7
 			// 
 			label7.AutoSize = true;
 			label7.Location = new System.Drawing.Point(20, 172);
 			label7.Name = "label7";
 			label7.Size = new System.Drawing.Size(187, 14);
 			label7.TabIndex = 7;
 			label7.Text = "Or select a special input control here
 			// 
 			// label6
 			// 
 			label6.AutoSize = true;
 			label6.Location = new System.Drawing.Point(20, 30);
 			label6.Name = "label6";
 			label6.Size = new System.Drawing.Size(41, 14);
 			label6.TabIndex = 2;
 			label6.Text = "Action
 			// 
 			// label5
 			// 
 			label5.AutoSize = true;
 			label5.Location = new System.Drawing.Point(20, 122);
 			label5.Name = "label5";
 			label5.Size = new System.Drawing.Size(200, 14);
 			label5.TabIndex = 4;
 			label5.Text = "Press the desired key combination here
 			// 
 			// groupBox1
 			// 
 			groupBox1.Controls.Add(this.showtexturesizes);
 			groupBox1.Controls.Add(this.scriptontop);
 			groupBox1.Controls.Add(this.zoomfactor);
 			groupBox1.Controls.Add(this.zoomfactorlabel);
 			groupBox1.Controls.Add(this.label19);
 			groupBox1.Controls.Add(this.autoscrollspeed);
 			groupBox1.Controls.Add(this.autoscrollspeedlabel);
 			groupBox1.Controls.Add(this.label15);
 			groupBox1.Controls.Add(this.previewsize);
 			groupBox1.Controls.Add(this.previewsizelabel);
 			groupBox1.Controls.Add(this.label12);
 			groupBox1.Controls.Add(this.label14);
 			groupBox1.Controls.Add(this.defaultviewmode);
 			groupBox1.Location = new System.Drawing.Point(8, 8);
 			groupBox1.Name = "groupBox1";
 			groupBox1.Size = new System.Drawing.Size(331, 313);
 			groupBox1.TabIndex = 0;
 			groupBox1.TabStop = false;
 			groupBox1.Text = " Options ";
 			// 
 			// scriptontop
 			// 
 			this.scriptontop.AutoSize = true;
 			this.scriptontop.Location = new System.Drawing.Point(32, 248);
 			this.scriptontop.Name = "scriptontop";
 			this.scriptontop.Size = new System.Drawing.Size(237, 18);
 			this.scriptontop.TabIndex = 40;
 			this.scriptontop.Text = "Script Editor always on top of main window";
 			this.scriptontop.UseVisualStyleBackColor = true;
 			// 
 			// zoomfactor
 			// 
 			this.zoomfactor.LargeChange = 1;
 			this.zoomfactor.Location = new System.Drawing.Point(127, 187);
 			this.zoomfactor.Minimum = 1;
 			this.zoomfactor.Name = "zoomfactor";
 			this.zoomfactor.Size = new System.Drawing.Size(116, 42);
 			this.zoomfactor.TabIndex = 37;
 			this.zoomfactor.TickStyle = System.Windows.Forms.TickStyle.Both;
 			this.zoomfactor.Value = 3;
 			this.zoomfactor.ValueChanged += new System.EventHandler(this.zoomfactor_ValueChanged);
 			// 
 			// zoomfactorlabel
 			// 
 			this.zoomfactorlabel.AutoSize = true;
 			this.zoomfactorlabel.Location = new System.Drawing.Point(249, 199);
 			this.zoomfactorlabel.Name = "zoomfactorlabel";
 			this.zoomfactorlabel.Size = new System.Drawing.Size(29, 14);
 			this.zoomfactorlabel.TabIndex = 39;
 			this.zoomfactorlabel.Text = "30%";
 			// 
 			// label19
 			// 
 			this.label19.AutoSize = true;
 			this.label19.Location = new System.Drawing.Point(52, 199);
 			this.label19.Name = "label19";
 			this.label19.Size = new System.Drawing.Size(69, 14);
 			this.label19.TabIndex = 38;
 			this.label19.Text = "Zoom factor
 			// 
 			// autoscrollspeed
 			// 
 			this.autoscrollspeed.LargeChange = 1;
 			this.autoscrollspeed.Location = new System.Drawing.Point(127, 135);
 			this.autoscrollspeed.Maximum = 5;
 			this.autoscrollspeed.Name = "autoscrollspeed";
 			this.autoscrollspeed.Size = new System.Drawing.Size(116, 42);
 			this.autoscrollspeed.TabIndex = 2;
 			this.autoscrollspeed.TickStyle = System.Windows.Forms.TickStyle.Both;
 			this.autoscrollspeed.ValueChanged += new System.EventHandler(this.autoscrollspeed_ValueChanged);
 			// 
 			// autoscrollspeedlabel
 			// 
 			this.autoscrollspeedlabel.AutoSize = true;
 			this.autoscrollspeedlabel.Location = new System.Drawing.Point(249, 147);
 			this.autoscrollspeedlabel.Name = "autoscrollspeedlabel";
 			this.autoscrollspeedlabel.Size = new System.Drawing.Size(23, 14);
 			this.autoscrollspeedlabel.TabIndex = 36;
 			this.autoscrollspeedlabel.Text = "Off";
 			// 
 			// label15
 			// 
 			this.label15.AutoSize = true;
 			this.label15.Location = new System.Drawing.Point(29, 147);
 			this.label15.Name = "label15";
 			this.label15.Size = new System.Drawing.Size(92, 14);
 			this.label15.TabIndex = 35;
 			this.label15.Text = "Autoscroll speed
 			// 
 			// previewsize
 			// 
 			this.previewsize.LargeChange = 1;
 			this.previewsize.Location = new System.Drawing.Point(127, 81);
 			this.previewsize.Maximum = 5;
 			this.previewsize.Name = "previewsize";
 			this.previewsize.Size = new System.Drawing.Size(116, 42);
 			this.previewsize.TabIndex = 1;
 			this.previewsize.TickStyle = System.Windows.Forms.TickStyle.Both;
 			this.previewsize.Value = 5;
 			this.previewsize.ValueChanged += new System.EventHandler(this.previewsize_ValueChanged);
 			// 
 			// previewsizelabel
 			// 
 			this.previewsizelabel.AutoSize = true;
 			this.previewsizelabel.Location = new System.Drawing.Point(249, 93);
 			this.previewsizelabel.Name = "previewsizelabel";
 			this.previewsizelabel.Size = new System.Drawing.Size(55, 14);
 			this.previewsizelabel.TabIndex = 33;
 			this.previewsizelabel.Text = "128 x 128";
 			// 
 			// label12
 			// 
 			this.label12.AutoSize = true;
 			this.label12.Location = new System.Drawing.Point(17, 93);
 			this.label12.Name = "label12";
 			this.label12.Size = new System.Drawing.Size(104, 14);
 			this.label12.TabIndex = 32;
 			this.label12.Text = "Preview image size
 			// 
 			// label14
 			// 
 			this.label14.AutoSize = true;
 			this.label14.Location = new System.Drawing.Point(50, 41);
 			this.label14.Name = "label14";
 			this.label14.Size = new System.Drawing.Size(71, 14);
 			this.label14.TabIndex = 14;
 			this.label14.Text = "Default view
 			// 
 			// defaultviewmode
 			// 
 			this.defaultviewmode.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.defaultviewmode.FormattingEnabled = true;
 			this.defaultviewmode.Items.AddRange(new object[] {
             "Wireframe",
             "Brightness Levels",
             "Floor Textures",
             "Ceiling Textures"});
 			this.defaultviewmode.Location = new System.Drawing.Point(135, 38);
 			this.defaultviewmode.Name = "defaultviewmode";
 			this.defaultviewmode.Size = new System.Drawing.Size(145, 22);
 			this.defaultviewmode.TabIndex = 0;
 			// 
 			// label1
 			// 
 			label1.AutoSize = true;
 			label1.Location = new System.Drawing.Point(22, 40);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(148, 14);
 			label1.TabIndex = 20;
 			label1.Text = "Texture and Flats brightness
 			label1.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			// 
 			// keyusedlabel
 			// 
 			this.keyusedlabel.AutoSize = true;
 			this.keyusedlabel.Location = new System.Drawing.Point(20, 287);
 			this.keyusedlabel.Name = "keyusedlabel";
 			this.keyusedlabel.Size = new System.Drawing.Size(222, 14);
 			this.keyusedlabel.TabIndex = 10;
 			this.keyusedlabel.Text = "Key combination also used by these actions
 			this.keyusedlabel.Visible = false;
 			// 
 			// colorsgroup1
 			// 
 			this.colorsgroup1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)));
 			this.colorsgroup1.Controls.Add(this.label2);
 			this.colorsgroup1.Controls.Add(this.colorgrid64);
 			this.colorsgroup1.Controls.Add(this.squarethings);
 			this.colorsgroup1.Controls.Add(this.colorgrid);
 			this.colorsgroup1.Controls.Add(this.doublesidedalphalabel);
 			this.colorsgroup1.Controls.Add(this.colorindication);
 			this.colorsgroup1.Controls.Add(this.colorsoundlinedefs);
 			this.colorsgroup1.Controls.Add(this.colorspeciallinedefs);
 			this.colorsgroup1.Controls.Add(this.qualitydisplay);
 			this.colorsgroup1.Controls.Add(this.colorbackcolor);
 			this.colorsgroup1.Controls.Add(this.colorselection);
 			this.colorsgroup1.Controls.Add(this.colorvertices);
 			this.colorsgroup1.Controls.Add(this.doublesidedalpha);
 			this.colorsgroup1.Controls.Add(this.colorhighlight);
 			this.colorsgroup1.Controls.Add(this.colorlinedefs);
 			this.colorsgroup1.Location = new System.Drawing.Point(8, 8);
 			this.colorsgroup1.Name = "colorsgroup1";
 			this.colorsgroup1.Size = new System.Drawing.Size(203, 472);
 			this.colorsgroup1.TabIndex = 0;
 			this.colorsgroup1.TabStop = false;
 			this.colorsgroup1.Text = " Display ";
 			this.colorsgroup1.Visible = false;
 			// 
 			// label2
 			// 
 			this.label2.AutoSize = true;
 			this.label2.Location = new System.Drawing.Point(18, 315);
 			this.label2.Name = "label2";
 			this.label2.Size = new System.Drawing.Size(147, 14);
 			this.label2.TabIndex = 14;
 			this.label2.Text = "Passable lines transparency
 			this.label2.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			// 
 			// colorgrid64
 			// 
 			this.colorgrid64.BackColor = System.Drawing.Color.Transparent;
 			this.colorgrid64.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorgrid64.Label = "64 Block grid
 			this.colorgrid64.Location = new System.Drawing.Point(15, 270);
 			this.colorgrid64.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorgrid64.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorgrid64.Name = "colorgrid64";
 			this.colorgrid64.Size = new System.Drawing.Size(168, 23);
 			this.colorgrid64.TabIndex = 9;
 			// 
 			// squarethings
 			// 
 			this.squarethings.AutoSize = true;
 			this.squarethings.Location = new System.Drawing.Point(21, 427);
 			this.squarethings.Name = "squarethings";
 			this.squarethings.Size = new System.Drawing.Size(93, 18);
 			this.squarethings.TabIndex = 8;
 			this.squarethings.Text = "Square things";
 			this.squarethings.UseVisualStyleBackColor = true;
 			// 
 			// colorgrid
 			// 
 			this.colorgrid.BackColor = System.Drawing.Color.Transparent;
 			this.colorgrid.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorgrid.Label = "Custom grid
 			this.colorgrid.Location = new System.Drawing.Point(15, 243);
 			this.colorgrid.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorgrid.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorgrid.Name = "colorgrid";
 			this.colorgrid.Size = new System.Drawing.Size(168, 23);
 			this.colorgrid.TabIndex = 8;
 			// 
 			// doublesidedalphalabel
 			// 
 			this.doublesidedalphalabel.AutoSize = true;
 			this.doublesidedalphalabel.Location = new System.Drawing.Point(148, 347);
 			this.doublesidedalphalabel.Name = "doublesidedalphalabel";
 			this.doublesidedalphalabel.Size = new System.Drawing.Size(23, 14);
 			this.doublesidedalphalabel.TabIndex = 16;
 			this.doublesidedalphalabel.Text = "0%";
 			// 
 			// colorindication
 			// 
 			this.colorindication.BackColor = System.Drawing.Color.Transparent;
 			this.colorindication.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorindication.Label = "Indications
 			this.colorindication.Location = new System.Drawing.Point(15, 216);
 			this.colorindication.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorindication.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorindication.Name = "colorindication";
 			this.colorindication.Size = new System.Drawing.Size(168, 23);
 			this.colorindication.TabIndex = 7;
 			// 
 			// colorsoundlinedefs
 			// 
 			this.colorsoundlinedefs.BackColor = System.Drawing.Color.Transparent;
 			this.colorsoundlinedefs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorsoundlinedefs.Label = "Sound lines
 			this.colorsoundlinedefs.Location = new System.Drawing.Point(15, 135);
 			this.colorsoundlinedefs.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorsoundlinedefs.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorsoundlinedefs.Name = "colorsoundlinedefs";
 			this.colorsoundlinedefs.Size = new System.Drawing.Size(168, 23);
 			this.colorsoundlinedefs.TabIndex = 4;
 			// 
 			// colorspeciallinedefs
 			// 
 			this.colorspeciallinedefs.BackColor = System.Drawing.Color.Transparent;
 			this.colorspeciallinedefs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorspeciallinedefs.Label = "Action lines
 			this.colorspeciallinedefs.Location = new System.Drawing.Point(15, 108);
 			this.colorspeciallinedefs.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorspeciallinedefs.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorspeciallinedefs.Name = "colorspeciallinedefs";
 			this.colorspeciallinedefs.Size = new System.Drawing.Size(168, 23);
 			this.colorspeciallinedefs.TabIndex = 3;
 			// 
 			// qualitydisplay
 			// 
 			this.qualitydisplay.AutoSize = true;
 			this.qualitydisplay.Location = new System.Drawing.Point(21, 395);
 			this.qualitydisplay.Name = "qualitydisplay";
 			this.qualitydisplay.Size = new System.Drawing.Size(130, 18);
 			this.qualitydisplay.TabIndex = 7;
 			this.qualitydisplay.Text = "High quality rendering";
 			this.qualitydisplay.UseVisualStyleBackColor = true;
 			// 
 			// colorbackcolor
 			// 
 			this.colorbackcolor.BackColor = System.Drawing.Color.Transparent;
 			this.colorbackcolor.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorbackcolor.Label = "Background
 			this.colorbackcolor.Location = new System.Drawing.Point(15, 27);
 			this.colorbackcolor.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorbackcolor.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorbackcolor.Name = "colorbackcolor";
 			this.colorbackcolor.Size = new System.Drawing.Size(168, 23);
 			this.colorbackcolor.TabIndex = 0;
 			// 
 			// colorselection
 			// 
 			this.colorselection.BackColor = System.Drawing.Color.Transparent;
 			this.colorselection.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorselection.Label = "Selection
 			this.colorselection.Location = new System.Drawing.Point(15, 189);
 			this.colorselection.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorselection.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorselection.Name = "colorselection";
 			this.colorselection.Size = new System.Drawing.Size(168, 23);
 			this.colorselection.TabIndex = 6;
 			// 
 			// colorvertices
 			// 
 			this.colorvertices.BackColor = System.Drawing.Color.Transparent;
 			this.colorvertices.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorvertices.Label = "Vertices
 			this.colorvertices.Location = new System.Drawing.Point(15, 54);
 			this.colorvertices.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorvertices.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorvertices.Name = "colorvertices";
 			this.colorvertices.Size = new System.Drawing.Size(168, 23);
 			this.colorvertices.TabIndex = 1;
 			// 
 			// doublesidedalpha
 			// 
 			this.doublesidedalpha.LargeChange = 3;
 			this.doublesidedalpha.Location = new System.Drawing.Point(11, 334);
 			this.doublesidedalpha.Name = "doublesidedalpha";
 			this.doublesidedalpha.Size = new System.Drawing.Size(130, 42);
 			this.doublesidedalpha.TabIndex = 2;
 			this.doublesidedalpha.TickStyle = System.Windows.Forms.TickStyle.Both;
 			this.doublesidedalpha.ValueChanged += new System.EventHandler(this.doublesidedalpha_ValueChanged);
 			// 
 			// colorhighlight
 			// 
 			this.colorhighlight.BackColor = System.Drawing.Color.Transparent;
 			this.colorhighlight.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorhighlight.Label = "Highlight
 			this.colorhighlight.Location = new System.Drawing.Point(15, 162);
 			this.colorhighlight.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorhighlight.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorhighlight.Name = "colorhighlight";
 			this.colorhighlight.Size = new System.Drawing.Size(168, 23);
 			this.colorhighlight.TabIndex = 5;
 			// 
 			// colorlinedefs
 			// 
 			this.colorlinedefs.BackColor = System.Drawing.Color.Transparent;
 			this.colorlinedefs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorlinedefs.Label = "Common lines
 			this.colorlinedefs.Location = new System.Drawing.Point(15, 81);
 			this.colorlinedefs.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorlinedefs.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorlinedefs.Name = "colorlinedefs";
 			this.colorlinedefs.Size = new System.Drawing.Size(168, 23);
 			this.colorlinedefs.TabIndex = 2;
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(589, 558);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 2;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.apply.Location = new System.Drawing.Point(471, 558);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 1;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// tabs
 			// 
 			this.tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tabs.Controls.Add(this.tabinterface);
 			this.tabs.Controls.Add(this.tabkeys);
 			this.tabs.Controls.Add(this.tabcolors);
 			this.tabs.Controls.Add(this.tabpasting);
 			this.tabs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabs.ItemSize = new System.Drawing.Size(110, 19);
 			this.tabs.Location = new System.Drawing.Point(11, 13);
 			this.tabs.Name = "tabs";
 			this.tabs.Padding = new System.Drawing.Point(20, 3);
 			this.tabs.SelectedIndex = 0;
 			this.tabs.Size = new System.Drawing.Size(690, 536);
 			this.tabs.TabIndex = 0;
 			this.tabs.SelectedIndexChanged += new System.EventHandler(this.tabs_SelectedIndexChanged);
 			// 
 			// tabinterface
 			// 
 			this.tabinterface.Controls.Add(this.groupBox5);
 			this.tabinterface.Controls.Add(this.groupBox4);
 			this.tabinterface.Controls.Add(this.groupBox2);
 			this.tabinterface.Controls.Add(groupBox1);
 			this.tabinterface.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabinterface.Location = new System.Drawing.Point(4, 23);
 			this.tabinterface.Name = "tabinterface";
 			this.tabinterface.Padding = new System.Windows.Forms.Padding(5);
 			this.tabinterface.Size = new System.Drawing.Size(682, 509);
 			this.tabinterface.TabIndex = 0;
 			this.tabinterface.Text = "Interface";
 			this.tabinterface.UseVisualStyleBackColor = true;
 			// 
 			// groupBox5
 			// 
 			this.groupBox5.Controls.Add(this.toolbar_file);
 			this.groupBox5.Controls.Add(this.toolbar_testing);
 			this.groupBox5.Controls.Add(this.toolbar_geometry);
 			this.groupBox5.Controls.Add(this.toolbar_viewmodes);
 			this.groupBox5.Controls.Add(this.toolbar_filter);
 			this.groupBox5.Controls.Add(this.toolbar_prefabs);
 			this.groupBox5.Controls.Add(this.toolbar_copy);
 			this.groupBox5.Controls.Add(this.toolbar_undo);
 			this.groupBox5.Controls.Add(this.toolbar_script);
 			this.groupBox5.Location = new System.Drawing.Point(8, 327);
 			this.groupBox5.Name = "groupBox5";
 			this.groupBox5.Size = new System.Drawing.Size(331, 173);
 			this.groupBox5.TabIndex = 4;
 			this.groupBox5.TabStop = false;
 			this.groupBox5.Text = " Toolbar Buttons ";
 			// 
 			// toolbar_file
 			// 
 			this.toolbar_file.AutoSize = true;
 			this.toolbar_file.Location = new System.Drawing.Point(32, 33);
 			this.toolbar_file.Name = "toolbar_file";
 			this.toolbar_file.Size = new System.Drawing.Size(118, 18);
 			this.toolbar_file.TabIndex = 49;
 			this.toolbar_file.Text = "New / Open / Save";
 			this.toolbar_file.UseVisualStyleBackColor = true;
 			// 
 			// toolbar_testing
 			// 
 			this.toolbar_testing.AutoSize = true;
 			this.toolbar_testing.Location = new System.Drawing.Point(188, 111);
 			this.toolbar_testing.Name = "toolbar_testing";
 			this.toolbar_testing.Size = new System.Drawing.Size(61, 18);
 			this.toolbar_testing.TabIndex = 48;
 			this.toolbar_testing.Text = "Testing";
 			this.toolbar_testing.UseVisualStyleBackColor = true;
 			// 
 			// toolbar_geometry
 			// 
 			this.toolbar_geometry.AutoSize = true;
 			this.toolbar_geometry.Location = new System.Drawing.Point(188, 85);
 			this.toolbar_geometry.Name = "toolbar_geometry";
 			this.toolbar_geometry.Size = new System.Drawing.Size(90, 18);
 			this.toolbar_geometry.TabIndex = 47;
 			this.toolbar_geometry.Text = "Snap / Merge";
 			this.toolbar_geometry.UseVisualStyleBackColor = true;
 			// 
 			// toolbar_viewmodes
 			// 
 			this.toolbar_viewmodes.AutoSize = true;
 			this.toolbar_viewmodes.Location = new System.Drawing.Point(188, 59);
 			this.toolbar_viewmodes.Name = "toolbar_viewmodes";
 			this.toolbar_viewmodes.Size = new System.Drawing.Size(87, 18);
 			this.toolbar_viewmodes.TabIndex = 46;
 			this.toolbar_viewmodes.Text = "View Modes";
 			this.toolbar_viewmodes.UseVisualStyleBackColor = true;
 			// 
 			// toolbar_filter
 			// 
 			this.toolbar_filter.AutoSize = true;
 			this.toolbar_filter.Location = new System.Drawing.Point(188, 33);
 			this.toolbar_filter.Name = "toolbar_filter";
 			this.toolbar_filter.Size = new System.Drawing.Size(84, 18);
 			this.toolbar_filter.TabIndex = 45;
 			this.toolbar_filter.Text = "Things Filter";
 			this.toolbar_filter.UseVisualStyleBackColor = true;
 			// 
 			// toolbar_prefabs
 			// 
 			this.toolbar_prefabs.AutoSize = true;
 			this.toolbar_prefabs.Location = new System.Drawing.Point(32, 137);
 			this.toolbar_prefabs.Name = "toolbar_prefabs";
 			this.toolbar_prefabs.Size = new System.Drawing.Size(64, 18);
 			this.toolbar_prefabs.TabIndex = 44;
 			this.toolbar_prefabs.Text = "Prefabs";
 			this.toolbar_prefabs.UseVisualStyleBackColor = true;
 			// 
 			// toolbar_copy
 			// 
 			this.toolbar_copy.AutoSize = true;
 			this.toolbar_copy.Location = new System.Drawing.Point(32, 111);
 			this.toolbar_copy.Name = "toolbar_copy";
 			this.toolbar_copy.Size = new System.Drawing.Size(112, 18);
 			this.toolbar_copy.TabIndex = 43;
 			this.toolbar_copy.Text = "Cut / Copy / Paste";
 			this.toolbar_copy.UseVisualStyleBackColor = true;
 			// 
 			// toolbar_undo
 			// 
 			this.toolbar_undo.AutoSize = true;
 			this.toolbar_undo.Location = new System.Drawing.Point(32, 85);
 			this.toolbar_undo.Name = "toolbar_undo";
 			this.toolbar_undo.Size = new System.Drawing.Size(85, 18);
 			this.toolbar_undo.TabIndex = 42;
 			this.toolbar_undo.Text = "Undo / Redo";
 			this.toolbar_undo.UseVisualStyleBackColor = true;
 			// 
 			// toolbar_script
 			// 
 			this.toolbar_script.AutoSize = true;
 			this.toolbar_script.Location = new System.Drawing.Point(32, 59);
 			this.toolbar_script.Name = "toolbar_script";
 			this.toolbar_script.Size = new System.Drawing.Size(84, 18);
 			this.toolbar_script.TabIndex = 41;
 			this.toolbar_script.Text = "Script Editor";
 			this.toolbar_script.UseVisualStyleBackColor = true;
 			// 
 			// groupBox4
 			// 
 			this.groupBox4.Controls.Add(this.collapsedockers);
 			this.groupBox4.Controls.Add(this.dockersposition);
 			this.groupBox4.Controls.Add(this.label17);
 			this.groupBox4.Location = new System.Drawing.Point(345, 327);
 			this.groupBox4.Name = "groupBox4";
 			this.groupBox4.Size = new System.Drawing.Size(329, 173);
 			this.groupBox4.TabIndex = 3;
 			this.groupBox4.TabStop = false;
 			this.groupBox4.Text = " Side Panels ";
 			// 
 			// collapsedockers
 			// 
 			this.collapsedockers.AutoSize = true;
 			this.collapsedockers.Location = new System.Drawing.Point(204, 36);
 			this.collapsedockers.Name = "collapsedockers";
 			this.collapsedockers.Size = new System.Drawing.Size(72, 18);
 			this.collapsedockers.TabIndex = 2;
 			this.collapsedockers.Text = "Auto hide";
 			this.collapsedockers.UseVisualStyleBackColor = true;
 			// 
 			// dockersposition
 			// 
 			this.dockersposition.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.dockersposition.FormattingEnabled = true;
 			this.dockersposition.Items.AddRange(new object[] {
             "Left",
             "Right",
             "None"});
 			this.dockersposition.Location = new System.Drawing.Point(95, 34);
 			this.dockersposition.Name = "dockersposition";
 			this.dockersposition.Size = new System.Drawing.Size(85, 22);
 			this.dockersposition.TabIndex = 1;
 			// 
 			// label17
 			// 
 			this.label17.AutoSize = true;
 			this.label17.Location = new System.Drawing.Point(33, 37);
 			this.label17.Name = "label17";
 			this.label17.Size = new System.Drawing.Size(47, 14);
 			this.label17.TabIndex = 0;
 			this.label17.Text = "Position
 			// 
 			// groupBox2
 			// 
 			this.groupBox2.Controls.Add(this.viewdistance);
 			this.groupBox2.Controls.Add(this.movespeed);
 			this.groupBox2.Controls.Add(this.mousespeed);
 			this.groupBox2.Controls.Add(this.fieldofview);
 			this.groupBox2.Controls.Add(this.viewdistancelabel);
 			this.groupBox2.Controls.Add(this.label13);
 			this.groupBox2.Controls.Add(this.invertyaxis);
 			this.groupBox2.Controls.Add(this.movespeedlabel);
 			this.groupBox2.Controls.Add(this.label11);
 			this.groupBox2.Controls.Add(this.mousespeedlabel);
 			this.groupBox2.Controls.Add(this.label9);
 			this.groupBox2.Controls.Add(this.fieldofviewlabel);
 			this.groupBox2.Controls.Add(this.label4);
 			this.groupBox2.Location = new System.Drawing.Point(345, 8);
 			this.groupBox2.Name = "groupBox2";
 			this.groupBox2.Size = new System.Drawing.Size(329, 313);
 			this.groupBox2.TabIndex = 2;
 			this.groupBox2.TabStop = false;
 			this.groupBox2.Text = " Visual Modes ";
 			// 
 			// viewdistance
 			// 
 			this.viewdistance.LargeChange = 2;
 			this.viewdistance.Location = new System.Drawing.Point(108, 187);
 			this.viewdistance.Maximum = 15;
 			this.viewdistance.Minimum = 1;
 			this.viewdistance.Name = "viewdistance";
 			this.viewdistance.Size = new System.Drawing.Size(150, 42);
 			this.viewdistance.TabIndex = 3;
 			this.viewdistance.TickStyle = System.Windows.Forms.TickStyle.Both;
 			this.viewdistance.Value = 1;
 			this.viewdistance.ValueChanged += new System.EventHandler(this.viewdistance_ValueChanged);
 			// 
 			// movespeed
 			// 
 			this.movespeed.Location = new System.Drawing.Point(108, 135);
 			this.movespeed.Maximum = 20;
 			this.movespeed.Minimum = 1;
 			this.movespeed.Name = "movespeed";
 			this.movespeed.Size = new System.Drawing.Size(150, 42);
 			this.movespeed.TabIndex = 2;
 			this.movespeed.TickStyle = System.Windows.Forms.TickStyle.Both;
 			this.movespeed.Value = 1;
 			this.movespeed.ValueChanged += new System.EventHandler(this.movespeed_ValueChanged);
 			// 
 			// mousespeed
 			// 
 			this.mousespeed.Location = new System.Drawing.Point(108, 81);
 			this.mousespeed.Maximum = 20;
 			this.mousespeed.Minimum = 1;
 			this.mousespeed.Name = "mousespeed";
 			this.mousespeed.Size = new System.Drawing.Size(150, 42);
 			this.mousespeed.TabIndex = 1;
 			this.mousespeed.TickStyle = System.Windows.Forms.TickStyle.Both;
 			this.mousespeed.Value = 1;
 			this.mousespeed.ValueChanged += new System.EventHandler(this.mousespeed_ValueChanged);
 			// 
 			// fieldofview
 			// 
 			this.fieldofview.LargeChange = 1;
 			this.fieldofview.Location = new System.Drawing.Point(108, 29);
 			this.fieldofview.Maximum = 17;
 			this.fieldofview.Minimum = 5;
 			this.fieldofview.Name = "fieldofview";
 			this.fieldofview.Size = new System.Drawing.Size(150, 42);
 			this.fieldofview.TabIndex = 0;
 			this.fieldofview.TickStyle = System.Windows.Forms.TickStyle.Both;
 			this.fieldofview.Value = 5;
 			this.fieldofview.ValueChanged += new System.EventHandler(this.fieldofview_ValueChanged);
 			// 
 			// viewdistancelabel
 			// 
 			this.viewdistancelabel.AutoSize = true;
 			this.viewdistancelabel.Location = new System.Drawing.Point(264, 199);
 			this.viewdistancelabel.Name = "viewdistancelabel";
 			this.viewdistancelabel.Size = new System.Drawing.Size(42, 14);
 			this.viewdistancelabel.TabIndex = 30;
 			this.viewdistancelabel.Text = "200 mp";
 			// 
 			// label13
 			// 
 			this.label13.AutoSize = true;
 			this.label13.Location = new System.Drawing.Point(22, 199);
 			this.label13.Name = "label13";
 			this.label13.Size = new System.Drawing.Size(80, 14);
 			this.label13.TabIndex = 28;
 			this.label13.Text = "View distance
 			// 
 			// invertyaxis
 			// 
 			this.invertyaxis.AutoSize = true;
 			this.invertyaxis.Location = new System.Drawing.Point(36, 248);
 			this.invertyaxis.Name = "invertyaxis";
 			this.invertyaxis.Size = new System.Drawing.Size(122, 18);
 			this.invertyaxis.TabIndex = 4;
 			this.invertyaxis.Text = "Invert mouse Y axis";
 			this.invertyaxis.UseVisualStyleBackColor = true;
 			// 
 			// movespeedlabel
 			// 
 			this.movespeedlabel.AutoSize = true;
 			this.movespeedlabel.Location = new System.Drawing.Point(264, 147);
 			this.movespeedlabel.Name = "movespeedlabel";
 			this.movespeedlabel.Size = new System.Drawing.Size(25, 14);
 			this.movespeedlabel.TabIndex = 25;
 			this.movespeedlabel.Text = "100";
 			// 
 			// label11
 			// 
 			this.label11.AutoSize = true;
 			this.label11.Location = new System.Drawing.Point(33, 147);
 			this.label11.Name = "label11";
 			this.label11.Size = new System.Drawing.Size(69, 14);
 			this.label11.TabIndex = 23;
 			this.label11.Text = "Move speed
 			// 
 			// mousespeedlabel
 			// 
 			this.mousespeedlabel.AutoSize = true;
 			this.mousespeedlabel.Location = new System.Drawing.Point(264, 93);
 			this.mousespeedlabel.Name = "mousespeedlabel";
 			this.mousespeedlabel.Size = new System.Drawing.Size(25, 14);
 			this.mousespeedlabel.TabIndex = 22;
 			this.mousespeedlabel.Text = "100";
 			// 
 			// label9
 			// 
 			this.label9.AutoSize = true;
 			this.label9.Location = new System.Drawing.Point(27, 93);
 			this.label9.Name = "label9";
 			this.label9.Size = new System.Drawing.Size(75, 14);
 			this.label9.TabIndex = 20;
 			this.label9.Text = "Mouse speed
 			// 
 			// fieldofviewlabel
 			// 
 			this.fieldofviewlabel.AutoSize = true;
 			this.fieldofviewlabel.Location = new System.Drawing.Point(264, 41);
 			this.fieldofviewlabel.Name = "fieldofviewlabel";
 			this.fieldofviewlabel.Size = new System.Drawing.Size(23, 14);
 			this.fieldofviewlabel.TabIndex = 19;
 			this.fieldofviewlabel.Text = "50?";
 			// 
 			// label4
 			// 
 			this.label4.AutoSize = true;
 			this.label4.Location = new System.Drawing.Point(30, 41);
 			this.label4.Name = "label4";
 			this.label4.Size = new System.Drawing.Size(72, 14);
 			this.label4.TabIndex = 17;
 			this.label4.Text = "Field of view
 			// 
 			// tabkeys
 			// 
 			this.tabkeys.Controls.Add(this.listactions);
 			this.tabkeys.Controls.Add(this.actioncontrolpanel);
 			this.tabkeys.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabkeys.Location = new System.Drawing.Point(4, 23);
 			this.tabkeys.Name = "tabkeys";
 			this.tabkeys.Padding = new System.Windows.Forms.Padding(3);
 			this.tabkeys.Size = new System.Drawing.Size(682, 488);
 			this.tabkeys.TabIndex = 1;
 			this.tabkeys.Text = "Controls";
 			this.tabkeys.UseVisualStyleBackColor = true;
 			// 
 			// listactions
 			// 
 			this.listactions.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.listactions.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.columncontrolaction,
             this.columncontrolkey});
 			this.listactions.FullRowSelect = true;
 			this.listactions.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
 			this.listactions.HideSelection = false;
 			this.listactions.Location = new System.Drawing.Point(11, 12);
 			this.listactions.Margin = new System.Windows.Forms.Padding(8, 9, 8, 9);
 			this.listactions.MultiSelect = false;
 			this.listactions.Name = "listactions";
 			this.listactions.Size = new System.Drawing.Size(352, 462);
 			this.listactions.Sorting = System.Windows.Forms.SortOrder.Ascending;
 			this.listactions.TabIndex = 0;
 			this.listactions.TabStop = false;
 			this.listactions.UseCompatibleStateImageBehavior = false;
 			this.listactions.View = System.Windows.Forms.View.Details;
 			this.listactions.MouseUp += new System.Windows.Forms.MouseEventHandler(this.listactions_MouseUp);
 			this.listactions.ItemSelectionChanged += new System.Windows.Forms.ListViewItemSelectionChangedEventHandler(this.listactions_ItemSelectionChanged);
 			this.listactions.KeyUp += new System.Windows.Forms.KeyEventHandler(this.listactions_KeyUp);
 			// 
 			// columncontrolaction
 			// 
 			this.columncontrolaction.Text = "Action";
 			this.columncontrolaction.Width = 179;
 			// 
 			// columncontrolkey
 			// 
 			this.columncontrolkey.Text = "Key";
 			this.columncontrolkey.Width = 130;
 			// 
 			// actioncontrolpanel
 			// 
 			this.actioncontrolpanel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.actioncontrolpanel.Controls.Add(this.keyusedlist);
 			this.actioncontrolpanel.Controls.Add(this.keyusedlabel);
 			this.actioncontrolpanel.Controls.Add(this.disregardshiftlabel);
 			this.actioncontrolpanel.Controls.Add(this.actioncontrol);
 			this.actioncontrolpanel.Controls.Add(label7);
 			this.actioncontrolpanel.Controls.Add(this.actiontitle);
 			this.actioncontrolpanel.Controls.Add(this.actioncontrolclear);
 			this.actioncontrolpanel.Controls.Add(label6);
 			this.actioncontrolpanel.Controls.Add(this.actionkey);
 			this.actioncontrolpanel.Controls.Add(this.actiondescription);
 			this.actioncontrolpanel.Controls.Add(label5);
 			this.actioncontrolpanel.Enabled = false;
 			this.actioncontrolpanel.Location = new System.Drawing.Point(377, 12);
 			this.actioncontrolpanel.Margin = new System.Windows.Forms.Padding(6);
 			this.actioncontrolpanel.Name = "actioncontrolpanel";
 			this.actioncontrolpanel.Size = new System.Drawing.Size(282, 462);
 			this.actioncontrolpanel.TabIndex = 9;
 			this.actioncontrolpanel.TabStop = false;
 			this.actioncontrolpanel.Text = " Action control ";
 			// 
 			// keyusedlist
 			// 
 			this.keyusedlist.BackColor = System.Drawing.SystemColors.Control;
 			this.keyusedlist.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
 			this.keyusedlist.FormattingEnabled = true;
 			this.keyusedlist.IntegralHeight = false;
 			this.keyusedlist.ItemHeight = 14;
 			this.keyusedlist.Location = new System.Drawing.Point(33, 307);
 			this.keyusedlist.Name = "keyusedlist";
 			this.keyusedlist.SelectionMode = System.Windows.Forms.SelectionMode.None;
 			this.keyusedlist.Size = new System.Drawing.Size(232, 115);
 			this.keyusedlist.Sorted = true;
 			this.keyusedlist.TabIndex = 11;
 			this.keyusedlist.Visible = false;
 			// 
 			// disregardshiftlabel
 			// 
 			this.disregardshiftlabel.Location = new System.Drawing.Point(20, 224);
 			this.disregardshiftlabel.Name = "disregardshiftlabel";
 			this.disregardshiftlabel.Size = new System.Drawing.Size(245, 47);
 			this.disregardshiftlabel.TabIndex = 9;
 			this.disregardshiftlabel.Tag = "The selected actions uses %s to modify its behavior. These modifiers can not be u" +
 				"sed in a key combination for this action.";
 			this.disregardshiftlabel.Text = "The selected actions uses Shift, Alt and Control to modify its behavior. These mo" +
 				"difiers can not be used in a key combination for this action.";
 			this.disregardshiftlabel.Visible = false;
 			// 
 			// actioncontrol
 			// 
 			this.actioncontrol.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.actioncontrol.FormattingEnabled = true;
 			this.actioncontrol.ImeMode = System.Windows.Forms.ImeMode.Off;
 			this.actioncontrol.Location = new System.Drawing.Point(23, 190);
 			this.actioncontrol.Name = "actioncontrol";
 			this.actioncontrol.Size = new System.Drawing.Size(197, 22);
 			this.actioncontrol.TabIndex = 8;
 			this.actioncontrol.TabStop = false;
 			this.actioncontrol.SelectedIndexChanged += new System.EventHandler(this.actioncontrol_SelectedIndexChanged);
 			// 
 			// actiontitle
 			// 
 			this.actiontitle.AutoSize = true;
 			this.actiontitle.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.actiontitle.Location = new System.Drawing.Point(67, 30);
 			this.actiontitle.Name = "actiontitle";
 			this.actiontitle.Size = new System.Drawing.Size(172, 14);
 			this.actiontitle.TabIndex = 1;
 			this.actiontitle.Text = "(select an action from the list)";
 			this.actiontitle.UseMnemonic = false;
 			// 
 			// actioncontrolclear
 			// 
 			this.actioncontrolclear.Location = new System.Drawing.Point(193, 138);
 			this.actioncontrolclear.Name = "actioncontrolclear";
 			this.actioncontrolclear.Size = new System.Drawing.Size(63, 25);
 			this.actioncontrolclear.TabIndex = 6;
 			this.actioncontrolclear.TabStop = false;
 			this.actioncontrolclear.Text = "Clear";
 			this.actioncontrolclear.UseVisualStyleBackColor = true;
 			this.actioncontrolclear.Click += new System.EventHandler(this.actioncontrolclear_Click);
 			// 
 			// actionkey
 			// 
 			this.actionkey.ImeMode = System.Windows.Forms.ImeMode.Off;
 			this.actionkey.Location = new System.Drawing.Point(23, 140);
 			this.actionkey.Name = "actionkey";
 			this.actionkey.Size = new System.Drawing.Size(163, 20);
 			this.actionkey.TabIndex = 5;
 			this.actionkey.TabStop = false;
 			this.actionkey.KeyDown += new System.Windows.Forms.KeyEventHandler(this.actionkey_KeyDown);
 			// 
 			// actiondescription
 			// 
 			this.actiondescription.AutoEllipsis = true;
 			this.actiondescription.Location = new System.Drawing.Point(20, 50);
 			this.actiondescription.Name = "actiondescription";
 			this.actiondescription.Size = new System.Drawing.Size(245, 71);
 			this.actiondescription.TabIndex = 3;
 			this.actiondescription.UseMnemonic = false;
 			// 
 			// tabcolors
 			// 
 			this.tabcolors.Controls.Add(this.appearancegroup1);
 			this.tabcolors.Controls.Add(this.colorsgroup3);
 			this.tabcolors.Controls.Add(this.colorsgroup1);
 			this.tabcolors.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabcolors.Location = new System.Drawing.Point(4, 23);
 			this.tabcolors.Name = "tabcolors";
 			this.tabcolors.Padding = new System.Windows.Forms.Padding(5);
 			this.tabcolors.Size = new System.Drawing.Size(682, 488);
 			this.tabcolors.TabIndex = 2;
 			this.tabcolors.Text = "Appearance";
 			this.tabcolors.UseVisualStyleBackColor = true;
 			// 
 			// appearancegroup1
 			// 
 			this.appearancegroup1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.appearancegroup1.Controls.Add(this.animatevisualselection);
 			this.appearancegroup1.Controls.Add(this.blackbrowsers);
 			this.appearancegroup1.Controls.Add(this.visualbilinear);
 			this.appearancegroup1.Controls.Add(label1);
 			this.appearancegroup1.Controls.Add(this.classicbilinear);
 			this.appearancegroup1.Controls.Add(this.imagebrightnesslabel);
 			this.appearancegroup1.Controls.Add(this.imagebrightness);
 			this.appearancegroup1.Location = new System.Drawing.Point(217, 251);
 			this.appearancegroup1.Name = "appearancegroup1";
 			this.appearancegroup1.Size = new System.Drawing.Size(457, 229);
 			this.appearancegroup1.TabIndex = 24;
 			this.appearancegroup1.TabStop = false;
 			this.appearancegroup1.Text = " Additional Options ";
 			// 
 			// animatevisualselection
 			// 
 			this.animatevisualselection.AutoSize = true;
 			this.animatevisualselection.Location = new System.Drawing.Point(244, 123);
 			this.animatevisualselection.Name = "animatevisualselection";
 			this.animatevisualselection.Size = new System.Drawing.Size(188, 18);
 			this.animatevisualselection.TabIndex = 23;
 			this.animatevisualselection.Text = "Animate selection in visual modes";
 			this.animatevisualselection.UseVisualStyleBackColor = true;
 			// 
 			// blackbrowsers
 			// 
 			this.blackbrowsers.AutoSize = true;
 			this.blackbrowsers.Location = new System.Drawing.Point(244, 93);
 			this.blackbrowsers.Name = "blackbrowsers";
 			this.blackbrowsers.Size = new System.Drawing.Size(199, 18);
 			this.blackbrowsers.TabIndex = 4;
 			this.blackbrowsers.Text = "Black background in image browser";
 			this.blackbrowsers.UseVisualStyleBackColor = true;
 			// 
 			// visualbilinear
 			// 
 			this.visualbilinear.AutoSize = true;
 			this.visualbilinear.Location = new System.Drawing.Point(25, 123);
 			this.visualbilinear.Name = "visualbilinear";
 			this.visualbilinear.Size = new System.Drawing.Size(176, 18);
 			this.visualbilinear.TabIndex = 6;
 			this.visualbilinear.Text = "Bilinear filtering in visual modes";
 			this.visualbilinear.UseVisualStyleBackColor = true;
 			// 
 			// classicbilinear
 			// 
 			this.classicbilinear.AutoSize = true;
 			this.classicbilinear.Location = new System.Drawing.Point(25, 93);
 			this.classicbilinear.Name = "classicbilinear";
 			this.classicbilinear.Size = new System.Drawing.Size(182, 18);
 			this.classicbilinear.TabIndex = 5;
 			this.classicbilinear.Text = "Bilinear filtering in classic modes";
 			this.classicbilinear.UseVisualStyleBackColor = true;
 			// 
 			// imagebrightnesslabel
 			// 
 			this.imagebrightnesslabel.AutoSize = true;
 			this.imagebrightnesslabel.Location = new System.Drawing.Point(337, 40);
 			this.imagebrightnesslabel.Name = "imagebrightnesslabel";
 			this.imagebrightnesslabel.Size = new System.Drawing.Size(31, 14);
 			this.imagebrightnesslabel.TabIndex = 22;
 			this.imagebrightnesslabel.Text = "+ 0 y";
 			// 
 			// imagebrightness
 			// 
 			this.imagebrightness.LargeChange = 3;
 			this.imagebrightness.Location = new System.Drawing.Point(176, 27);
 			this.imagebrightness.Name = "imagebrightness";
 			this.imagebrightness.Size = new System.Drawing.Size(154, 42);
 			this.imagebrightness.TabIndex = 3;
 			this.imagebrightness.TickStyle = System.Windows.Forms.TickStyle.Both;
 			this.imagebrightness.ValueChanged += new System.EventHandler(this.imagebrightness_ValueChanged);
 			// 
 			// colorsgroup3
 			// 
 			this.colorsgroup3.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.colorsgroup3.Controls.Add(this.scripttabwidth);
 			this.colorsgroup3.Controls.Add(this.scriptautoindent);
 			this.colorsgroup3.Controls.Add(this.label10);
 			this.colorsgroup3.Controls.Add(this.panel1);
 			this.colorsgroup3.Controls.Add(this.scriptfontsize);
 			this.colorsgroup3.Controls.Add(this.label8);
 			this.colorsgroup3.Controls.Add(this.scriptfontbold);
 			this.colorsgroup3.Controls.Add(this.scriptfontname);
 			this.colorsgroup3.Controls.Add(this.label3);
 			this.colorsgroup3.Controls.Add(this.colorconstants);
 			this.colorsgroup3.Controls.Add(this.colorliterals);
 			this.colorsgroup3.Controls.Add(this.colorscriptbackground);
 			this.colorsgroup3.Controls.Add(this.colorkeywords);
 			this.colorsgroup3.Controls.Add(this.colorlinenumbers);
 			this.colorsgroup3.Controls.Add(this.colorcomments);
 			this.colorsgroup3.Controls.Add(this.colorplaintext);
 			this.colorsgroup3.Location = new System.Drawing.Point(217, 8);
 			this.colorsgroup3.Name = "colorsgroup3";
 			this.colorsgroup3.Size = new System.Drawing.Size(457, 237);
 			this.colorsgroup3.TabIndex = 1;
 			this.colorsgroup3.TabStop = false;
 			this.colorsgroup3.Text = " Script editor ";
 			this.colorsgroup3.Visible = false;
 			// 
 			// scripttabwidth
 			// 
 			this.scripttabwidth.AllowDecimal = false;
 			this.scripttabwidth.AllowNegative = false;
 			this.scripttabwidth.AllowRelative = false;
 			this.scripttabwidth.ButtonStep = 2;
 			this.scripttabwidth.Location = new System.Drawing.Point(259, 165);
 			this.scripttabwidth.Name = "scripttabwidth";
 			this.scripttabwidth.Size = new System.Drawing.Size(71, 24);
 			this.scripttabwidth.StepValues = null;
 			this.scripttabwidth.TabIndex = 32;
 			// 
 			// scriptautoindent
 			// 
 			this.scriptautoindent.AutoSize = true;
 			this.scriptautoindent.Location = new System.Drawing.Point(354, 169);
 			this.scriptautoindent.Name = "scriptautoindent";
 			this.scriptautoindent.Size = new System.Drawing.Size(81, 18);
 			this.scriptautoindent.TabIndex = 31;
 			this.scriptautoindent.Text = "Auto indent";
 			this.scriptautoindent.UseVisualStyleBackColor = true;
 			// 
 			// label10
 			// 
 			this.label10.AutoSize = true;
 			this.label10.Location = new System.Drawing.Point(199, 170);
 			this.label10.Name = "label10";
 			this.label10.Size = new System.Drawing.Size(58, 14);
 			this.label10.TabIndex = 30;
 			this.label10.Text = "Tab width
 			// 
 			// panel1
 			// 
 			this.panel1.BackColor = System.Drawing.SystemColors.Window;
 			this.panel1.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.panel1.Controls.Add(this.scriptfontlabel);
 			this.panel1.Location = new System.Drawing.Point(236, 109);
 			this.panel1.Name = "panel1";
 			this.panel1.Size = new System.Drawing.Size(199, 38);
 			this.panel1.TabIndex = 29;
 			// 
 			// scriptfontlabel
 			// 
 			this.scriptfontlabel.BackColor = System.Drawing.SystemColors.Window;
 			this.scriptfontlabel.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.scriptfontlabel.Location = new System.Drawing.Point(0, 0);
 			this.scriptfontlabel.Name = "scriptfontlabel";
 			this.scriptfontlabel.Size = new System.Drawing.Size(195, 34);
 			this.scriptfontlabel.TabIndex = 0;
 			this.scriptfontlabel.Text = "Font";
 			this.scriptfontlabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
 			// 
 			// scriptfontsize
 			// 
 			this.scriptfontsize.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.scriptfontsize.FormattingEnabled = true;
 			this.scriptfontsize.Items.AddRange(new object[] {
             "7",
             "8",
             "9",
             "10",
             "11",
             "12",
             "14",
             "16",
             "18",
             "20",
             "22",
             "24",
             "26",
             "28",
             "36",
             "48",
             "72"});
 			this.scriptfontsize.Location = new System.Drawing.Point(236, 67);
 			this.scriptfontsize.Name = "scriptfontsize";
 			this.scriptfontsize.Size = new System.Drawing.Size(94, 22);
 			this.scriptfontsize.TabIndex = 25;
 			// 
 			// label8
 			// 
 			this.label8.AutoSize = true;
 			this.label8.Location = new System.Drawing.Point(199, 70);
 			this.label8.Name = "label8";
 			this.label8.Size = new System.Drawing.Size(31, 14);
 			this.label8.TabIndex = 28;
 			this.label8.Text = "Size
 			// 
 			// scriptfontbold
 			// 
 			this.scriptfontbold.AutoSize = true;
 			this.scriptfontbold.Location = new System.Drawing.Point(354, 69);
 			this.scriptfontbold.Name = "scriptfontbold";
 			this.scriptfontbold.Size = new System.Drawing.Size(47, 18);
 			this.scriptfontbold.TabIndex = 26;
 			this.scriptfontbold.Text = "Bold";
 			this.scriptfontbold.UseVisualStyleBackColor = true;
 			// 
 			// scriptfontname
 			// 
 			this.scriptfontname.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.scriptfontname.FormattingEnabled = true;
 			this.scriptfontname.Location = new System.Drawing.Point(236, 27);
 			this.scriptfontname.Name = "scriptfontname";
 			this.scriptfontname.Size = new System.Drawing.Size(199, 22);
 			this.scriptfontname.Sorted = true;
 			this.scriptfontname.TabIndex = 23;
 			// 
 			// label3
 			// 
 			this.label3.AutoSize = true;
 			this.label3.Location = new System.Drawing.Point(199, 30);
 			this.label3.Name = "label3";
 			this.label3.Size = new System.Drawing.Size(31, 14);
 			this.label3.TabIndex = 24;
 			this.label3.Text = "Font
 			// 
 			// colorconstants
 			// 
 			this.colorconstants.BackColor = System.Drawing.Color.Transparent;
 			this.colorconstants.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorconstants.Label = "Constants
 			this.colorconstants.Location = new System.Drawing.Point(15, 189);
 			this.colorconstants.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorconstants.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorconstants.Name = "colorconstants";
 			this.colorconstants.Size = new System.Drawing.Size(150, 23);
 			this.colorconstants.TabIndex = 6;
 			// 
 			// colorliterals
 			// 
 			this.colorliterals.BackColor = System.Drawing.Color.Transparent;
 			this.colorliterals.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorliterals.Label = "Literals
 			this.colorliterals.Location = new System.Drawing.Point(15, 162);
 			this.colorliterals.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorliterals.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorliterals.Name = "colorliterals";
 			this.colorliterals.Size = new System.Drawing.Size(150, 23);
 			this.colorliterals.TabIndex = 5;
 			// 
 			// colorscriptbackground
 			// 
 			this.colorscriptbackground.BackColor = System.Drawing.Color.Transparent;
 			this.colorscriptbackground.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorscriptbackground.Label = "Background
 			this.colorscriptbackground.Location = new System.Drawing.Point(15, 27);
 			this.colorscriptbackground.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorscriptbackground.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorscriptbackground.Name = "colorscriptbackground";
 			this.colorscriptbackground.Size = new System.Drawing.Size(150, 23);
 			this.colorscriptbackground.TabIndex = 0;
 			// 
 			// colorkeywords
 			// 
 			this.colorkeywords.BackColor = System.Drawing.Color.Transparent;
 			this.colorkeywords.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorkeywords.Label = "Keywords
 			this.colorkeywords.Location = new System.Drawing.Point(15, 135);
 			this.colorkeywords.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorkeywords.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorkeywords.Name = "colorkeywords";
 			this.colorkeywords.Size = new System.Drawing.Size(150, 23);
 			this.colorkeywords.TabIndex = 4;
 			// 
 			// colorlinenumbers
 			// 
 			this.colorlinenumbers.BackColor = System.Drawing.Color.Transparent;
 			this.colorlinenumbers.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorlinenumbers.Label = "Line numbers
 			this.colorlinenumbers.Location = new System.Drawing.Point(15, 54);
 			this.colorlinenumbers.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorlinenumbers.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorlinenumbers.Name = "colorlinenumbers";
 			this.colorlinenumbers.Size = new System.Drawing.Size(150, 23);
 			this.colorlinenumbers.TabIndex = 1;
 			// 
 			// colorcomments
 			// 
 			this.colorcomments.BackColor = System.Drawing.Color.Transparent;
 			this.colorcomments.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorcomments.Label = "Comments
 			this.colorcomments.Location = new System.Drawing.Point(15, 108);
 			this.colorcomments.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorcomments.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorcomments.Name = "colorcomments";
 			this.colorcomments.Size = new System.Drawing.Size(150, 23);
 			this.colorcomments.TabIndex = 3;
 			// 
 			// colorplaintext
 			// 
 			this.colorplaintext.BackColor = System.Drawing.Color.Transparent;
 			this.colorplaintext.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.colorplaintext.Label = "Plain text
 			this.colorplaintext.Location = new System.Drawing.Point(15, 81);
 			this.colorplaintext.MaximumSize = new System.Drawing.Size(10000, 23);
 			this.colorplaintext.MinimumSize = new System.Drawing.Size(100, 23);
 			this.colorplaintext.Name = "colorplaintext";
 			this.colorplaintext.Size = new System.Drawing.Size(150, 23);
 			this.colorplaintext.TabIndex = 2;
 			// 
 			// tabpasting
 			// 
 			this.tabpasting.Controls.Add(this.label16);
 			this.tabpasting.Controls.Add(this.pasteoptions);
 			this.tabpasting.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabpasting.Location = new System.Drawing.Point(4, 23);
 			this.tabpasting.Name = "tabpasting";
 			this.tabpasting.Padding = new System.Windows.Forms.Padding(5);
 			this.tabpasting.Size = new System.Drawing.Size(682, 488);
 			this.tabpasting.TabIndex = 3;
 			this.tabpasting.Text = "Pasting ";
 			this.tabpasting.UseVisualStyleBackColor = true;
 			// 
 			// label16
 			// 
 			this.label16.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.label16.Location = new System.Drawing.Point(11, 15);
 			this.label16.Name = "label16";
 			this.label16.Size = new System.Drawing.Size(649, 35);
 			this.label16.TabIndex = 1;
 			this.label16.Text = "These are the default options for pasting geometry. You can also choose these opt" +
 				"ions when you use the Paste Special function. These options also apply when inse" +
 				"rting prefabs.";
 			// 
 			// pasteoptions
 			// 
 			this.pasteoptions.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.pasteoptions.Location = new System.Drawing.Point(8, 53);
 			this.pasteoptions.Name = "pasteoptions";
 			this.pasteoptions.Size = new System.Drawing.Size(666, 427);
 			this.pasteoptions.TabIndex = 0;
 			// 
 			// showtexturesizes
 			// 
 			this.showtexturesizes.AutoSize = true;
 			this.showtexturesizes.Location = new System.Drawing.Point(32, 276);
 			this.showtexturesizes.Name = "showtexturesizes";
 			this.showtexturesizes.Size = new System.Drawing.Size(222, 18);
 			this.showtexturesizes.TabIndex = 41;
 			this.showtexturesizes.Text = "Show texture and flat sizes in browsers";
 			this.showtexturesizes.UseVisualStyleBackColor = true;
 			// 
 			// PreferencesForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.apply;
 			this.ClientSize = new System.Drawing.Size(711, 594);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.tabs);
 			this.DoubleBuffered = true;
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "PreferencesForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Preferences";
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.PreferencesForm_HelpRequested);
 			groupBox1.ResumeLayout(false);
 			groupBox1.PerformLayout();
 			((System.ComponentModel.ISupportInitialize)(this.zoomfactor)).EndInit();
 			((System.ComponentModel.ISupportInitialize)(this.autoscrollspeed)).EndInit();
 			((System.ComponentModel.ISupportInitialize)(this.previewsize)).EndInit();
 			this.colorsgroup1.ResumeLayout(false);
 			this.colorsgroup1.PerformLayout();
 			((System.ComponentModel.ISupportInitialize)(this.doublesidedalpha)).EndInit();
 			this.tabs.ResumeLayout(false);
 			this.tabinterface.ResumeLayout(false);
 			this.groupBox5.ResumeLayout(false);
 			this.groupBox5.PerformLayout();
 			this.groupBox4.ResumeLayout(false);
 			this.groupBox4.PerformLayout();
 			this.groupBox2.ResumeLayout(false);
 			this.groupBox2.PerformLayout();
 			((System.ComponentModel.ISupportInitialize)(this.viewdistance)).EndInit();
 			((System.ComponentModel.ISupportInitialize)(this.movespeed)).EndInit();
 			((System.ComponentModel.ISupportInitialize)(this.mousespeed)).EndInit();
 			((System.ComponentModel.ISupportInitialize)(this.fieldofview)).EndInit();
 			this.tabkeys.ResumeLayout(false);
 			this.actioncontrolpanel.ResumeLayout(false);
 			this.actioncontrolpanel.PerformLayout();
 			this.tabcolors.ResumeLayout(false);
 			this.appearancegroup1.ResumeLayout(false);
 			this.appearancegroup1.PerformLayout();
 			((System.ComponentModel.ISupportInitialize)(this.imagebrightness)).EndInit();
 			this.colorsgroup3.ResumeLayout(false);
 			this.colorsgroup3.PerformLayout();
 			this.panel1.ResumeLayout(false);
 			this.tabpasting.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ConfigForm.Designer.cs" startline="22" endline="698">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			System.Windows.Forms.Label label5;
 			System.Windows.Forms.Label label6;
 			System.Windows.Forms.Label label3;
 			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ConfigForm));
 			System.Windows.Forms.Label label2;
 			System.Windows.Forms.Label label7;
 			System.Windows.Forms.Label label9;
 			System.Windows.Forms.Label label1;
 			System.Windows.Forms.Label label8;
 			System.Windows.Forms.Label label4;
 			System.Windows.Forms.Label label10;
 			this.labelparameters = new System.Windows.Forms.Label();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.tabs = new System.Windows.Forms.TabControl();
 			this.tabresources = new System.Windows.Forms.TabPage();
 			this.configdata = new CodeImp.DoomBuilder.Controls.ResourceListEditor();
 			this.tabnodebuilder = new System.Windows.Forms.TabPage();
 			this.nodebuildertest = new System.Windows.Forms.ComboBox();
 			this.nodebuildersave = new System.Windows.Forms.ComboBox();
 			this.tabtesting = new System.Windows.Forms.TabPage();
 			this.shortpaths = new System.Windows.Forms.CheckBox();
 			this.customparameters = new System.Windows.Forms.CheckBox();
 			this.skill = new CodeImp.DoomBuilder.Controls.ActionSelectorControl();
 			this.browsetestprogram = new System.Windows.Forms.Button();
 			this.noresultlabel = new System.Windows.Forms.Label();
 			this.testresult = new System.Windows.Forms.TextBox();
 			this.labelresult = new System.Windows.Forms.Label();
 			this.testparameters = new System.Windows.Forms.TextBox();
 			this.testapplication = new System.Windows.Forms.TextBox();
 			this.tabtextures = new System.Windows.Forms.TabPage();
 			this.listtextures = new System.Windows.Forms.ListView();
 			this.smallimages = new System.Windows.Forms.ImageList(this.components);
 			this.restoretexturesets = new System.Windows.Forms.Button();
 			this.edittextureset = new System.Windows.Forms.Button();
 			this.pastetexturesets = new System.Windows.Forms.Button();
 			this.copytexturesets = new System.Windows.Forms.Button();
 			this.removetextureset = new System.Windows.Forms.Button();
 			this.addtextureset = new System.Windows.Forms.Button();
 			this.tabmodes = new System.Windows.Forms.TabPage();
 			this.startmode = new System.Windows.Forms.ComboBox();
 			this.label11 = new System.Windows.Forms.Label();
 			this.listmodes = new System.Windows.Forms.ListView();
 			this.colmodename = new System.Windows.Forms.ColumnHeader();
 			this.colmodeplugin = new System.Windows.Forms.ColumnHeader();
 			this.listconfigs = new System.Windows.Forms.ListView();
 			this.columnname = new System.Windows.Forms.ColumnHeader();
 			this.testprogramdialog = new System.Windows.Forms.OpenFileDialog();
 			label5 = new System.Windows.Forms.Label();
 			label6 = new System.Windows.Forms.Label();
 			label3 = new System.Windows.Forms.Label();
 			label2 = new System.Windows.Forms.Label();
 			label7 = new System.Windows.Forms.Label();
 			label9 = new System.Windows.Forms.Label();
 			label1 = new System.Windows.Forms.Label();
 			label8 = new System.Windows.Forms.Label();
 			label4 = new System.Windows.Forms.Label();
 			label10 = new System.Windows.Forms.Label();
 			this.tabs.SuspendLayout();
 			this.tabresources.SuspendLayout();
 			this.tabnodebuilder.SuspendLayout();
 			this.tabtesting.SuspendLayout();
 			this.tabtextures.SuspendLayout();
 			this.tabmodes.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// label5
 			// 
 			label5.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			label5.AutoSize = true;
 			label5.Location = new System.Drawing.Point(12, 276);
 			label5.Name = "label5";
 			label5.Size = new System.Drawing.Size(312, 14);
 			label5.TabIndex = 19;
 			label5.Text = "Drag items to change order (lower items override higher items).";
 			// 
 			// label6
 			// 
 			label6.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			label6.AutoEllipsis = true;
 			label6.Location = new System.Drawing.Point(12, 15);
 			label6.Name = "label6";
 			label6.Size = new System.Drawing.Size(452, 37);
 			label6.TabIndex = 21;
 			label6.Text = "These are the resources that will be loaded when this configuration is chosen for" +
 				" editing. Usually you add your IWAD (like doom.wad or doom2.wad) here.";
 			// 
 			// label3
 			// 
 			label3.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			label3.AutoEllipsis = true;
 			label3.Location = new System.Drawing.Point(12, 15);
 			label3.Name = "label3";
 			label3.Size = new System.Drawing.Size(443, 54);
 			label3.TabIndex = 22;
 			label3.Text = resources.GetString("label3.Text");
 			// 
 			// label2
 			// 
 			label2.AutoSize = true;
 			label2.Location = new System.Drawing.Point(12, 86);
 			label2.Name = "label2";
 			label2.Size = new System.Drawing.Size(149, 14);
 			label2.TabIndex = 24;
 			label2.Text = "Configuration for saving map
 			// 
 			// label7
 			// 
 			label7.AutoSize = true;
 			label7.Location = new System.Drawing.Point(35, 125);
 			label7.Name = "label7";
 			label7.Size = new System.Drawing.Size(126, 14);
 			label7.TabIndex = 26;
 			label7.Text = "Configuration for testing
 			// 
 			// label9
 			// 
 			label9.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			label9.AutoEllipsis = true;
 			label9.Location = new System.Drawing.Point(12, 15);
 			label9.Name = "label9";
 			label9.Size = new System.Drawing.Size(452, 54);
 			label9.TabIndex = 23;
 			label9.Text = "Here you can specify the program settings to use for launching a game engine when" +
 				" testing the map. Press F1 for help with custom parameters.";
 			// 
 			// label1
 			// 
 			label1.AutoSize = true;
 			label1.Location = new System.Drawing.Point(15, 62);
 			label1.Name = "label1";
 			label1.Size = new System.Drawing.Size(63, 14);
 			label1.TabIndex = 24;
 			label1.Text = "Application
 			// 
 			// label8
 			// 
 			label8.AutoSize = true;
 			label8.Location = new System.Drawing.Point(21, 97);
 			label8.Name = "label8";
 			label8.Size = new System.Drawing.Size(57, 14);
 			label8.TabIndex = 34;
 			label8.Text = "Skill Level
 			// 
 			// label4
 			// 
 			label4.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			label4.AutoEllipsis = true;
 			label4.Location = new System.Drawing.Point(12, 15);
 			label4.Name = "label4";
 			label4.Size = new System.Drawing.Size(458, 46);
 			label4.TabIndex = 24;
 			label4.Text = "Texture Sets are a way to group textures and flats into categories, so that you c" +
 				"an easily find a texture for the specific style or purpose you need by selecting" +
 				" one of the categories.";
 			// 
 			// label10
 			// 
 			label10.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			label10.AutoEllipsis = true;
 			label10.Location = new System.Drawing.Point(12, 15);
 			label10.Name = "label10";
 			label10.Size = new System.Drawing.Size(445, 58);
 			label10.TabIndex = 25;
 			label10.Text = resources.GetString("label10.Text");
 			// 
 			// labelparameters
 			// 
 			this.labelparameters.AutoSize = true;
 			this.labelparameters.Location = new System.Drawing.Point(15, 159);
 			this.labelparameters.Name = "labelparameters";
 			this.labelparameters.Size = new System.Drawing.Size(65, 14);
 			this.labelparameters.TabIndex = 27;
 			this.labelparameters.Text = "Parameters
 			this.labelparameters.Visible = false;
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(617, 381);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 3;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(499, 381);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 2;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// tabs
 			// 
 			this.tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tabs.Controls.Add(this.tabresources);
 			this.tabs.Controls.Add(this.tabnodebuilder);
 			this.tabs.Controls.Add(this.tabtesting);
 			this.tabs.Controls.Add(this.tabtextures);
 			this.tabs.Controls.Add(this.tabmodes);
 			this.tabs.Enabled = false;
 			this.tabs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabs.ItemSize = new System.Drawing.Size(100, 19);
 			this.tabs.Location = new System.Drawing.Point(248, 12);
 			this.tabs.Name = "tabs";
 			this.tabs.Padding = new System.Drawing.Point(20, 3);
 			this.tabs.SelectedIndex = 0;
 			this.tabs.Size = new System.Drawing.Size(481, 358);
 			this.tabs.TabIndex = 1;
 			// 
 			// tabresources
 			// 
 			this.tabresources.Controls.Add(label6);
 			this.tabresources.Controls.Add(this.configdata);
 			this.tabresources.Controls.Add(label5);
 			this.tabresources.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabresources.Location = new System.Drawing.Point(4, 23);
 			this.tabresources.Name = "tabresources";
 			this.tabresources.Padding = new System.Windows.Forms.Padding(6);
 			this.tabresources.Size = new System.Drawing.Size(473, 331);
 			this.tabresources.TabIndex = 0;
 			this.tabresources.Text = "Resources";
 			this.tabresources.UseVisualStyleBackColor = true;
 			// 
 			// configdata
 			// 
 			this.configdata.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.configdata.DialogOffset = new System.Drawing.Point(-120, 10);
 			this.configdata.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.configdata.Location = new System.Drawing.Point(15, 55);
 			this.configdata.Name = "configdata";
 			this.configdata.Size = new System.Drawing.Size(440, 208);
 			this.configdata.TabIndex = 0;
 			this.configdata.OnContentChanged += new CodeImp.DoomBuilder.Controls.ResourceListEditor.ContentChanged(this.resourcelocations_OnContentChanged);
 			// 
 			// tabnodebuilder
 			// 
 			this.tabnodebuilder.Controls.Add(label7);
 			this.tabnodebuilder.Controls.Add(this.nodebuildertest);
 			this.tabnodebuilder.Controls.Add(label2);
 			this.tabnodebuilder.Controls.Add(this.nodebuildersave);
 			this.tabnodebuilder.Controls.Add(label3);
 			this.tabnodebuilder.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabnodebuilder.Location = new System.Drawing.Point(4, 23);
 			this.tabnodebuilder.Name = "tabnodebuilder";
 			this.tabnodebuilder.Padding = new System.Windows.Forms.Padding(6);
 			this.tabnodebuilder.Size = new System.Drawing.Size(473, 331);
 			this.tabnodebuilder.TabIndex = 1;
 			this.tabnodebuilder.Text = "Nodebuilder";
 			this.tabnodebuilder.UseVisualStyleBackColor = true;
 			// 
 			// nodebuildertest
 			// 
 			this.nodebuildertest.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.nodebuildertest.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.nodebuildertest.FormattingEnabled = true;
 			this.nodebuildertest.Location = new System.Drawing.Point(167, 122);
 			this.nodebuildertest.Name = "nodebuildertest";
 			this.nodebuildertest.Size = new System.Drawing.Size(288, 22);
 			this.nodebuildertest.Sorted = true;
 			this.nodebuildertest.TabIndex = 1;
 			this.nodebuildertest.SelectedIndexChanged += new System.EventHandler(this.nodebuildertest_SelectedIndexChanged);
 			// 
 			// nodebuildersave
 			// 
 			this.nodebuildersave.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.nodebuildersave.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.nodebuildersave.FormattingEnabled = true;
 			this.nodebuildersave.Location = new System.Drawing.Point(167, 83);
 			this.nodebuildersave.Name = "nodebuildersave";
 			this.nodebuildersave.Size = new System.Drawing.Size(288, 22);
 			this.nodebuildersave.Sorted = true;
 			this.nodebuildersave.TabIndex = 0;
 			this.nodebuildersave.SelectedIndexChanged += new System.EventHandler(this.nodebuildersave_SelectedIndexChanged);
 			// 
 			// tabtesting
 			// 
 			this.tabtesting.Controls.Add(this.shortpaths);
 			this.tabtesting.Controls.Add(this.customparameters);
 			this.tabtesting.Controls.Add(this.skill);
 			this.tabtesting.Controls.Add(label8);
 			this.tabtesting.Controls.Add(this.browsetestprogram);
 			this.tabtesting.Controls.Add(this.noresultlabel);
 			this.tabtesting.Controls.Add(this.testresult);
 			this.tabtesting.Controls.Add(this.labelresult);
 			this.tabtesting.Controls.Add(this.testparameters);
 			this.tabtesting.Controls.Add(this.labelparameters);
 			this.tabtesting.Controls.Add(this.testapplication);
 			this.tabtesting.Controls.Add(label1);
 			this.tabtesting.Controls.Add(label9);
 			this.tabtesting.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabtesting.Location = new System.Drawing.Point(4, 23);
 			this.tabtesting.Name = "tabtesting";
 			this.tabtesting.Padding = new System.Windows.Forms.Padding(6);
 			this.tabtesting.Size = new System.Drawing.Size(473, 331);
 			this.tabtesting.TabIndex = 2;
 			this.tabtesting.Text = "Testing";
 			this.tabtesting.UseVisualStyleBackColor = true;
 			// 
 			// shortpaths
 			// 
 			this.shortpaths.AutoSize = true;
 			this.shortpaths.Location = new System.Drawing.Point(87, 203);
 			this.shortpaths.Name = "shortpaths";
 			this.shortpaths.Size = new System.Drawing.Size(276, 18);
 			this.shortpaths.TabIndex = 5;
 			this.shortpaths.Text = "Use short paths and file names (MSDOS 8.3 format)";
 			this.shortpaths.UseVisualStyleBackColor = true;
 			this.shortpaths.Visible = false;
 			this.shortpaths.CheckedChanged += new System.EventHandler(this.shortpaths_CheckedChanged);
 			// 
 			// customparameters
 			// 
 			this.customparameters.AutoSize = true;
 			this.customparameters.Location = new System.Drawing.Point(86, 132);
 			this.customparameters.Name = "customparameters";
 			this.customparameters.Size = new System.Drawing.Size(134, 18);
 			this.customparameters.TabIndex = 3;
 			this.customparameters.Text = "Customize parameters";
 			this.customparameters.UseVisualStyleBackColor = true;
 			this.customparameters.CheckedChanged += new System.EventHandler(this.customparameters_CheckedChanged);
 			// 
 			// skill
 			// 
 			this.skill.BackColor = System.Drawing.Color.Transparent;
 			this.skill.Cursor = System.Windows.Forms.Cursors.Default;
 			this.skill.Empty = false;
 			this.skill.GeneralizedCategories = null;
 			this.skill.Location = new System.Drawing.Point(87, 94);
 			this.skill.Name = "skill";
 			this.skill.Size = new System.Drawing.Size(329, 21);
 			this.skill.TabIndex = 2;
 			this.skill.Value = 402;
 			this.skill.ValueChanges += new System.EventHandler(this.skill_ValueChanges);
 			// 
 			// browsetestprogram
 			// 
 			this.browsetestprogram.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
 			this.browsetestprogram.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.browsetestprogram.Image = global
 			this.browsetestprogram.Location = new System.Drawing.Point(422, 58);
 			this.browsetestprogram.Name = "browsetestprogram";
 			this.browsetestprogram.Padding = new System.Windows.Forms.Padding(0, 0, 1, 3);
 			this.browsetestprogram.Size = new System.Drawing.Size(30, 23);
 			this.browsetestprogram.TabIndex = 1;
 			this.browsetestprogram.Text = " ";
 			this.browsetestprogram.UseVisualStyleBackColor = true;
 			this.browsetestprogram.Click += new System.EventHandler(this.browsetestprogram_Click);
 			// 
 			// noresultlabel
 			// 
 			this.noresultlabel.Location = new System.Drawing.Point(84, 236);
 			this.noresultlabel.Name = "noresultlabel";
 			this.noresultlabel.Size = new System.Drawing.Size(272, 43);
 			this.noresultlabel.TabIndex = 32;
 			this.noresultlabel.Text = "An example result cannot be displayed, because it requires a map to be loaded.";
 			this.noresultlabel.Visible = false;
 			// 
 			// testresult
 			// 
 			this.testresult.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.testresult.BackColor = System.Drawing.SystemColors.Control;
 			this.testresult.Location = new System.Drawing.Point(86, 233);
 			this.testresult.Multiline = true;
 			this.testresult.Name = "testresult";
 			this.testresult.ReadOnly = true;
 			this.testresult.Size = new System.Drawing.Size(366, 79);
 			this.testresult.TabIndex = 6;
 			this.testresult.Visible = false;
 			// 
 			// labelresult
 			// 
 			this.labelresult.AutoSize = true;
 			this.labelresult.Location = new System.Drawing.Point(38, 236);
 			this.labelresult.Name = "labelresult";
 			this.labelresult.Size = new System.Drawing.Size(40, 14);
 			this.labelresult.TabIndex = 30;
 			this.labelresult.Text = "Result
 			this.labelresult.Visible = false;
 			// 
 			// testparameters
 			// 
 			this.testparameters.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.testparameters.Location = new System.Drawing.Point(86, 156);
 			this.testparameters.Multiline = true;
 			this.testparameters.Name = "testparameters";
 			this.testparameters.Size = new System.Drawing.Size(366, 41);
 			this.testparameters.TabIndex = 4;
 			this.testparameters.Visible = false;
 			this.testparameters.TextChanged += new System.EventHandler(this.testparameters_TextChanged);
 			// 
 			// testapplication
 			// 
 			this.testapplication.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.testapplication.Location = new System.Drawing.Point(86, 59);
 			this.testapplication.Name = "testapplication";
 			this.testapplication.ReadOnly = true;
 			this.testapplication.Size = new System.Drawing.Size(330, 20);
 			this.testapplication.TabIndex = 0;
 			this.testapplication.TextChanged += new System.EventHandler(this.testapplication_TextChanged);
 			// 
 			// tabtextures
 			// 
 			this.tabtextures.Controls.Add(this.listtextures);
 			this.tabtextures.Controls.Add(this.restoretexturesets);
 			this.tabtextures.Controls.Add(this.edittextureset);
 			this.tabtextures.Controls.Add(this.pastetexturesets);
 			this.tabtextures.Controls.Add(this.copytexturesets);
 			this.tabtextures.Controls.Add(this.removetextureset);
 			this.tabtextures.Controls.Add(this.addtextureset);
 			this.tabtextures.Controls.Add(label4);
 			this.tabtextures.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabtextures.Location = new System.Drawing.Point(4, 23);
 			this.tabtextures.Name = "tabtextures";
 			this.tabtextures.Size = new System.Drawing.Size(473, 331);
 			this.tabtextures.TabIndex = 3;
 			this.tabtextures.Text = "Textures";
 			this.tabtextures.UseVisualStyleBackColor = true;
 			// 
 			// listtextures
 			// 
 			this.listtextures.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.listtextures.FullRowSelect = true;
 			this.listtextures.HideSelection = false;
 			this.listtextures.Location = new System.Drawing.Point(15, 64);
 			this.listtextures.Name = "listtextures";
 			this.listtextures.ShowGroups = false;
 			this.listtextures.Size = new System.Drawing.Size(442, 175);
 			this.listtextures.SmallImageList = this.smallimages;
 			this.listtextures.Sorting = System.Windows.Forms.SortOrder.Ascending;
 			this.listtextures.TabIndex = 0;
 			this.listtextures.UseCompatibleStateImageBehavior = false;
 			this.listtextures.View = System.Windows.Forms.View.List;
 			this.listtextures.SelectedIndexChanged += new System.EventHandler(this.listtextures_SelectedIndexChanged);
 			this.listtextures.DoubleClick += new System.EventHandler(this.listtextures_DoubleClick);
 			// 
 			// smallimages
 			// 
 			this.smallimages.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("smallimages.ImageStream")));
 			this.smallimages.TransparentColor = System.Drawing.Color.Transparent;
 			this.smallimages.Images.SetKeyName(0, "KnownTextureSet.ico");
 			// 
 			// restoretexturesets
 			// 
 			this.restoretexturesets.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.restoretexturesets.Location = new System.Drawing.Point(15, 283);
 			this.restoretexturesets.Name = "restoretexturesets";
 			this.restoretexturesets.Size = new System.Drawing.Size(140, 24);
 			this.restoretexturesets.TabIndex = 6;
 			this.restoretexturesets.Text = "Add Default Sets";
 			this.restoretexturesets.UseVisualStyleBackColor = true;
 			this.restoretexturesets.Click += new System.EventHandler(this.restoretexturesets_Click);
 			// 
 			// edittextureset
 			// 
 			this.edittextureset.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.edittextureset.Enabled = false;
 			this.edittextureset.Location = new System.Drawing.Point(88, 245);
 			this.edittextureset.Name = "edittextureset";
 			this.edittextureset.Size = new System.Drawing.Size(67, 24);
 			this.edittextureset.TabIndex = 2;
 			this.edittextureset.Text = "Edit...";
 			this.edittextureset.UseVisualStyleBackColor = true;
 			this.edittextureset.Click += new System.EventHandler(this.edittextureset_Click);
 			// 
 			// pastetexturesets
 			// 
 			this.pastetexturesets.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.pastetexturesets.Enabled = false;
 			this.pastetexturesets.Location = new System.Drawing.Point(399, 245);
 			this.pastetexturesets.Name = "pastetexturesets";
 			this.pastetexturesets.Size = new System.Drawing.Size(58, 24);
 			this.pastetexturesets.TabIndex = 5;
 			this.pastetexturesets.Text = "Paste";
 			this.pastetexturesets.UseVisualStyleBackColor = true;
 			this.pastetexturesets.Click += new System.EventHandler(this.pastetexturesets_Click);
 			// 
 			// copytexturesets
 			// 
 			this.copytexturesets.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.copytexturesets.Enabled = false;
 			this.copytexturesets.Location = new System.Drawing.Point(335, 245);
 			this.copytexturesets.Name = "copytexturesets";
 			this.copytexturesets.Size = new System.Drawing.Size(58, 24);
 			this.copytexturesets.TabIndex = 4;
 			this.copytexturesets.Text = "Copy";
 			this.copytexturesets.UseVisualStyleBackColor = true;
 			this.copytexturesets.Click += new System.EventHandler(this.copytexturesets_Click);
 			// 
 			// removetextureset
 			// 
 			this.removetextureset.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.removetextureset.Enabled = false;
 			this.removetextureset.Location = new System.Drawing.Point(161, 245);
 			this.removetextureset.Name = "removetextureset";
 			this.removetextureset.Size = new System.Drawing.Size(68, 24);
 			this.removetextureset.TabIndex = 3;
 			this.removetextureset.Text = "Remove";
 			this.removetextureset.UseVisualStyleBackColor = true;
 			this.removetextureset.Click += new System.EventHandler(this.removetextureset_Click);
 			// 
 			// addtextureset
 			// 
 			this.addtextureset.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.addtextureset.Location = new System.Drawing.Point(15, 245);
 			this.addtextureset.Name = "addtextureset";
 			this.addtextureset.Size = new System.Drawing.Size(67, 24);
 			this.addtextureset.TabIndex = 1;
 			this.addtextureset.Text = "Add...";
 			this.addtextureset.UseVisualStyleBackColor = true;
 			this.addtextureset.Click += new System.EventHandler(this.addtextureset_Click);
 			// 
 			// tabmodes
 			// 
 			this.tabmodes.Controls.Add(this.startmode);
 			this.tabmodes.Controls.Add(this.label11);
 			this.tabmodes.Controls.Add(this.listmodes);
 			this.tabmodes.Controls.Add(label10);
 			this.tabmodes.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabmodes.Location = new System.Drawing.Point(4, 23);
 			this.tabmodes.Name = "tabmodes";
 			this.tabmodes.Size = new System.Drawing.Size(473, 331);
 			this.tabmodes.TabIndex = 4;
 			this.tabmodes.Text = "Modes";
 			this.tabmodes.UseVisualStyleBackColor = true;
 			// 
 			// startmode
 			// 
 			this.startmode.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.startmode.FormattingEnabled = true;
 			this.startmode.Location = new System.Drawing.Point(239, 288);
 			this.startmode.Name = "startmode";
 			this.startmode.Size = new System.Drawing.Size(218, 22);
 			this.startmode.TabIndex = 27;
 			this.startmode.SelectedIndexChanged += new System.EventHandler(this.startmode_SelectedIndexChanged);
 			// 
 			// label11
 			// 
 			this.label11.AutoSize = true;
 			this.label11.Location = new System.Drawing.Point(12, 291);
 			this.label11.Name = "label11";
 			this.label11.Size = new System.Drawing.Size(199, 14);
 			this.label11.TabIndex = 26;
 			this.label11.Text = "When opening a map, start in this mode
 			// 
 			// listmodes
 			// 
 			this.listmodes.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.listmodes.CheckBoxes = true;
 			this.listmodes.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.colmodename,
             this.colmodeplugin});
 			this.listmodes.FullRowSelect = true;
 			this.listmodes.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
 			this.listmodes.Location = new System.Drawing.Point(15, 70);
 			this.listmodes.MultiSelect = false;
 			this.listmodes.Name = "listmodes";
 			this.listmodes.ShowGroups = false;
 			this.listmodes.Size = new System.Drawing.Size(442, 202);
 			this.listmodes.Sorting = System.Windows.Forms.SortOrder.Ascending;
 			this.listmodes.TabIndex = 0;
 			this.listmodes.UseCompatibleStateImageBehavior = false;
 			this.listmodes.View = System.Windows.Forms.View.Details;
 			this.listmodes.ItemChecked += new System.Windows.Forms.ItemCheckedEventHandler(this.listmodes_ItemChecked);
 			// 
 			// colmodename
 			// 
 			this.colmodename.Text = "Editing Mode";
 			this.colmodename.Width = 179;
 			// 
 			// colmodeplugin
 			// 
 			this.colmodeplugin.Text = "Plugin";
 			this.colmodeplugin.Width = 221;
 			// 
 			// listconfigs
 			// 
 			this.listconfigs.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)));
 			this.listconfigs.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.columnname});
 			this.listconfigs.FullRowSelect = true;
 			this.listconfigs.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
 			this.listconfigs.HideSelection = false;
 			this.listconfigs.Location = new System.Drawing.Point(12, 12);
 			this.listconfigs.MultiSelect = false;
 			this.listconfigs.Name = "listconfigs";
 			this.listconfigs.ShowGroups = false;
 			this.listconfigs.Size = new System.Drawing.Size(230, 358);
 			this.listconfigs.Sorting = System.Windows.Forms.SortOrder.Ascending;
 			this.listconfigs.TabIndex = 0;
 			this.listconfigs.UseCompatibleStateImageBehavior = false;
 			this.listconfigs.View = System.Windows.Forms.View.Details;
 			this.listconfigs.SelectedIndexChanged += new System.EventHandler(this.listconfigs_SelectedIndexChanged);
 			this.listconfigs.MouseUp += new System.Windows.Forms.MouseEventHandler(this.listconfigs_MouseUp);
 			this.listconfigs.KeyUp += new System.Windows.Forms.KeyEventHandler(this.listconfigs_KeyUp);
 			// 
 			// columnname
 			// 
 			this.columnname.Text = "Configuration";
 			this.columnname.Width = 200;
 			// 
 			// testprogramdialog
 			// 
 			this.testprogramdialog.Filter = "Executable Files (*.exe)|*.exe|Batch Files (*.bat)|*.bat";
 			this.testprogramdialog.Title = "Browse Test Program";
 			// 
 			// ConfigForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(740, 416);
 			this.Controls.Add(this.listconfigs);
 			this.Controls.Add(this.tabs);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "ConfigForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Game Configurations";
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.ConfigForm_HelpRequested);
 			this.tabs.ResumeLayout(false);
 			this.tabresources.ResumeLayout(false);
 			this.tabresources.PerformLayout();
 			this.tabnodebuilder.ResumeLayout(false);
 			this.tabnodebuilder.PerformLayout();
 			this.tabtesting.ResumeLayout(false);
 			this.tabtesting.PerformLayout();
 			this.tabtextures.ResumeLayout(false);
 			this.tabmodes.ResumeLayout(false);
 			this.tabmodes.PerformLayout();
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\ThingsFiltersForm.Designer.cs" startline="22" endline="660">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.listfilters = new System.Windows.Forms.ListView();
 			this.columnname = new System.Windows.Forms.ColumnHeader();
 			this.addfilter = new System.Windows.Forms.Button();
 			this.deletefilter = new System.Windows.Forms.Button();
 			this.filtergroup = new System.Windows.Forms.GroupBox();
 			this.tabs = new System.Windows.Forms.TabControl();
 			this.tabbasic = new System.Windows.Forms.TabPage();
 			this.label6 = new System.Windows.Forms.Label();
 			this.labelzheight = new System.Windows.Forms.Label();
 			this.filterzheight = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.browseangle = new System.Windows.Forms.Button();
 			this.filterangle = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.filtertype = new CodeImp.DoomBuilder.Controls.ActionSelectorControl();
 			this.label5 = new System.Windows.Forms.Label();
 			this.browsetype = new System.Windows.Forms.Button();
 			this.label4 = new System.Windows.Forms.Label();
 			this.filtercategory = new System.Windows.Forms.ComboBox();
 			this.label2 = new System.Windows.Forms.Label();
 			this.tabflags = new System.Windows.Forms.TabPage();
 			this.filterfields = new CodeImp.DoomBuilder.Controls.CheckboxArrayControl();
 			this.label3 = new System.Windows.Forms.Label();
 			this.tabaction = new System.Windows.Forms.TabPage();
 			this.argumentspanel = new System.Windows.Forms.Panel();
 			this.label8 = new System.Windows.Forms.Label();
 			this.arg2 = new CodeImp.DoomBuilder.Controls.ArgumentBox();
 			this.arg1 = new CodeImp.DoomBuilder.Controls.ArgumentBox();
 			this.arg0 = new CodeImp.DoomBuilder.Controls.ArgumentBox();
 			this.arg3 = new CodeImp.DoomBuilder.Controls.ArgumentBox();
 			this.arg4 = new CodeImp.DoomBuilder.Controls.ArgumentBox();
 			this.arg1label = new System.Windows.Forms.Label();
 			this.arg0label = new System.Windows.Forms.Label();
 			this.arg3label = new System.Windows.Forms.Label();
 			this.arg2label = new System.Windows.Forms.Label();
 			this.arg4label = new System.Windows.Forms.Label();
 			this.filteraction = new CodeImp.DoomBuilder.Controls.ActionSelectorControl();
 			this.browseaction = new System.Windows.Forms.Button();
 			this.label7 = new System.Windows.Forms.Label();
 			this.filtertag = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.labeltag = new System.Windows.Forms.Label();
 			this.tabcustom = new System.Windows.Forms.TabPage();
 			this.fieldslist = new CodeImp.DoomBuilder.Controls.FieldsEditorControl();
 			this.filtername = new System.Windows.Forms.TextBox();
 			this.label1 = new System.Windows.Forms.Label();
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.filtergroup.SuspendLayout();
 			this.tabs.SuspendLayout();
 			this.tabbasic.SuspendLayout();
 			this.tabflags.SuspendLayout();
 			this.tabaction.SuspendLayout();
 			this.argumentspanel.SuspendLayout();
 			this.tabcustom.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// listfilters
 			// 
 			this.listfilters.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)));
 			this.listfilters.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.columnname});
 			this.listfilters.FullRowSelect = true;
 			this.listfilters.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
 			this.listfilters.HideSelection = false;
 			this.listfilters.Location = new System.Drawing.Point(12, 12);
 			this.listfilters.MultiSelect = false;
 			this.listfilters.Name = "listfilters";
 			this.listfilters.ShowGroups = false;
 			this.listfilters.Size = new System.Drawing.Size(202, 354);
 			this.listfilters.Sorting = System.Windows.Forms.SortOrder.Ascending;
 			this.listfilters.TabIndex = 0;
 			this.listfilters.UseCompatibleStateImageBehavior = false;
 			this.listfilters.View = System.Windows.Forms.View.Details;
 			this.listfilters.SelectedIndexChanged += new System.EventHandler(this.listfilters_SelectedIndexChanged);
 			// 
 			// columnname
 			// 
 			this.columnname.Text = "Configuration";
 			this.columnname.Width = 177;
 			// 
 			// addfilter
 			// 
 			this.addfilter.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.addfilter.Location = new System.Drawing.Point(12, 372);
 			this.addfilter.Name = "addfilter";
 			this.addfilter.Size = new System.Drawing.Size(98, 25);
 			this.addfilter.TabIndex = 1;
 			this.addfilter.Text = "New Filter";
 			this.addfilter.UseVisualStyleBackColor = true;
 			this.addfilter.Click += new System.EventHandler(this.addfilter_Click);
 			// 
 			// deletefilter
 			// 
 			this.deletefilter.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
 			this.deletefilter.Enabled = false;
 			this.deletefilter.Location = new System.Drawing.Point(116, 372);
 			this.deletefilter.Name = "deletefilter";
 			this.deletefilter.Size = new System.Drawing.Size(98, 25);
 			this.deletefilter.TabIndex = 2;
 			this.deletefilter.Text = "Delete Selected";
 			this.deletefilter.UseVisualStyleBackColor = true;
 			this.deletefilter.Click += new System.EventHandler(this.deletefilter_Click);
 			// 
 			// filtergroup
 			// 
 			this.filtergroup.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.filtergroup.Controls.Add(this.tabs);
 			this.filtergroup.Controls.Add(this.filtername);
 			this.filtergroup.Controls.Add(this.label1);
 			this.filtergroup.Enabled = false;
 			this.filtergroup.Location = new System.Drawing.Point(232, 12);
 			this.filtergroup.Name = "filtergroup";
 			this.filtergroup.Size = new System.Drawing.Size(465, 385);
 			this.filtergroup.TabIndex = 3;
 			this.filtergroup.TabStop = false;
 			this.filtergroup.Text = " Selected Filter ";
 			// 
 			// tabs
 			// 
 			this.tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tabs.Controls.Add(this.tabbasic);
 			this.tabs.Controls.Add(this.tabflags);
 			this.tabs.Controls.Add(this.tabaction);
 			this.tabs.Controls.Add(this.tabcustom);
 			this.tabs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabs.Location = new System.Drawing.Point(6, 63);
 			this.tabs.Name = "tabs";
 			this.tabs.SelectedIndex = 0;
 			this.tabs.Size = new System.Drawing.Size(453, 316);
 			this.tabs.SizeMode = System.Windows.Forms.TabSizeMode.Fixed;
 			this.tabs.TabIndex = 5;
 			// 
 			// tabbasic
 			// 
 			this.tabbasic.Controls.Add(this.label6);
 			this.tabbasic.Controls.Add(this.labelzheight);
 			this.tabbasic.Controls.Add(this.filterzheight);
 			this.tabbasic.Controls.Add(this.browseangle);
 			this.tabbasic.Controls.Add(this.filterangle);
 			this.tabbasic.Controls.Add(this.filtertype);
 			this.tabbasic.Controls.Add(this.label5);
 			this.tabbasic.Controls.Add(this.browsetype);
 			this.tabbasic.Controls.Add(this.label4);
 			this.tabbasic.Controls.Add(this.filtercategory);
 			this.tabbasic.Controls.Add(this.label2);
 			this.tabbasic.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabbasic.Location = new System.Drawing.Point(4, 23);
 			this.tabbasic.Name = "tabbasic";
 			this.tabbasic.Padding = new System.Windows.Forms.Padding(3);
 			this.tabbasic.Size = new System.Drawing.Size(445, 289);
 			this.tabbasic.TabIndex = 0;
 			this.tabbasic.Text = "Properties";
 			this.tabbasic.UseVisualStyleBackColor = true;
 			// 
 			// label6
 			// 
 			this.label6.AutoSize = true;
 			this.label6.Location = new System.Drawing.Point(34, 235);
 			this.label6.Name = "label6";
 			this.label6.Size = new System.Drawing.Size(342, 14);
 			this.label6.TabIndex = 15;
 			this.label6.Text = "Note
 			// 
 			// labelzheight
 			// 
 			this.labelzheight.AutoSize = true;
 			this.labelzheight.Location = new System.Drawing.Point(19, 167);
 			this.labelzheight.Name = "labelzheight";
 			this.labelzheight.Size = new System.Drawing.Size(90, 14);
 			this.labelzheight.TabIndex = 14;
 			this.labelzheight.Text = "Filter by Z height
 			// 
 			// filterzheight
 			// 
 			this.filterzheight.AllowDecimal = false;
 			this.filterzheight.AllowNegative = true;
 			this.filterzheight.AllowRelative = false;
 			this.filterzheight.ButtonStep = 1;
 			this.filterzheight.Location = new System.Drawing.Point(123, 162);
 			this.filterzheight.Name = "filterzheight";
 			this.filterzheight.Size = new System.Drawing.Size(72, 24);
 			this.filterzheight.StepValues = null;
 			this.filterzheight.TabIndex = 13;
 			this.filterzheight.WhenTextChanged += new System.EventHandler(this.filterzheight_WhenTextChanged);
 			// 
 			// browseangle
 			// 
 			this.browseangle.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.browseangle.Image = global
 			this.browseangle.ImageAlign = System.Drawing.ContentAlignment.TopCenter;
 			this.browseangle.Location = new System.Drawing.Point(201, 119);
 			this.browseangle.Name = "browseangle";
 			this.browseangle.Padding = new System.Windows.Forms.Padding(0, 0, 1, 3);
 			this.browseangle.Size = new System.Drawing.Size(28, 25);
 			this.browseangle.TabIndex = 12;
 			this.browseangle.Text = " ";
 			this.browseangle.UseVisualStyleBackColor = true;
 			this.browseangle.Click += new System.EventHandler(this.browseangle_Click);
 			// 
 			// filterangle
 			// 
 			this.filterangle.AllowDecimal = false;
 			this.filterangle.AllowNegative = true;
 			this.filterangle.AllowRelative = false;
 			this.filterangle.ButtonStep = 45;
 			this.filterangle.Location = new System.Drawing.Point(123, 119);
 			this.filterangle.Name = "filterangle";
 			this.filterangle.Size = new System.Drawing.Size(72, 24);
 			this.filterangle.StepValues = null;
 			this.filterangle.TabIndex = 11;
 			this.filterangle.WhenTextChanged += new System.EventHandler(this.filterangle_WhenTextChanged);
 			// 
 			// filtertype
 			// 
 			this.filtertype.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.filtertype.BackColor = System.Drawing.Color.Transparent;
 			this.filtertype.Cursor = System.Windows.Forms.Cursors.Default;
 			this.filtertype.Empty = false;
 			this.filtertype.GeneralizedCategories = null;
 			this.filtertype.Location = new System.Drawing.Point(123, 76);
 			this.filtertype.Name = "filtertype";
 			this.filtertype.Size = new System.Drawing.Size(268, 21);
 			this.filtertype.TabIndex = 7;
 			this.filtertype.Value = 402;
 			this.filtertype.ValueChanges += new System.EventHandler(this.filtertype_ValueChanges);
 			// 
 			// label5
 			// 
 			this.label5.AutoSize = true;
 			this.label5.Location = new System.Drawing.Point(32, 124);
 			this.label5.Name = "label5";
 			this.label5.Size = new System.Drawing.Size(77, 14);
 			this.label5.TabIndex = 6;
 			this.label5.Text = "Filter by angle
 			// 
 			// browsetype
 			// 
 			this.browsetype.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
 			this.browsetype.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.browsetype.Image = global
 			this.browsetype.ImageAlign = System.Drawing.ContentAlignment.TopCenter;
 			this.browsetype.Location = new System.Drawing.Point(397, 74);
 			this.browsetype.Name = "browsetype";
 			this.browsetype.Padding = new System.Windows.Forms.Padding(0, 0, 1, 3);
 			this.browsetype.Size = new System.Drawing.Size(28, 25);
 			this.browsetype.TabIndex = 5;
 			this.browsetype.UseVisualStyleBackColor = true;
 			this.browsetype.Click += new System.EventHandler(this.browsetype_Click);
 			// 
 			// label4
 			// 
 			this.label4.AutoSize = true;
 			this.label4.Location = new System.Drawing.Point(37, 79);
 			this.label4.Name = "label4";
 			this.label4.Size = new System.Drawing.Size(72, 14);
 			this.label4.TabIndex = 3;
 			this.label4.Text = "Filter by type
 			// 
 			// filtercategory
 			// 
 			this.filtercategory.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.filtercategory.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.filtercategory.FormattingEnabled = true;
 			this.filtercategory.Location = new System.Drawing.Point(123, 30);
 			this.filtercategory.Name = "filtercategory";
 			this.filtercategory.Size = new System.Drawing.Size(302, 22);
 			this.filtercategory.TabIndex = 1;
 			this.filtercategory.SelectedIndexChanged += new System.EventHandler(this.filtercategory_SelectedIndexChanged);
 			// 
 			// label2
 			// 
 			this.label2.AutoSize = true;
 			this.label2.Location = new System.Drawing.Point(15, 33);
 			this.label2.Name = "label2";
 			this.label2.Size = new System.Drawing.Size(94, 14);
 			this.label2.TabIndex = 2;
 			this.label2.Text = "Filter by category
 			// 
 			// tabflags
 			// 
 			this.tabflags.Controls.Add(this.filterfields);
 			this.tabflags.Controls.Add(this.label3);
 			this.tabflags.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabflags.Location = new System.Drawing.Point(4, 23);
 			this.tabflags.Name = "tabflags";
 			this.tabflags.Padding = new System.Windows.Forms.Padding(3);
 			this.tabflags.Size = new System.Drawing.Size(445, 289);
 			this.tabflags.TabIndex = 1;
 			this.tabflags.Text = "Flags";
 			this.tabflags.UseVisualStyleBackColor = true;
 			// 
 			// filterfields
 			// 
 			this.filterfields.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.filterfields.AutoScroll = true;
 			this.filterfields.Columns = 2;
 			this.filterfields.Location = new System.Drawing.Point(20, 39);
 			this.filterfields.Name = "filterfields";
 			this.filterfields.Size = new System.Drawing.Size(402, 229);
 			this.filterfields.TabIndex = 5;
 			// 
 			// label3
 			// 
 			this.label3.AutoSize = true;
 			this.label3.Location = new System.Drawing.Point(17, 20);
 			this.label3.Name = "label3";
 			this.label3.Size = new System.Drawing.Size(89, 14);
 			this.label3.TabIndex = 6;
 			this.label3.Text = "Filter by settings
 			// 
 			// tabaction
 			// 
 			this.tabaction.Controls.Add(this.argumentspanel);
 			this.tabaction.Controls.Add(this.filteraction);
 			this.tabaction.Controls.Add(this.browseaction);
 			this.tabaction.Controls.Add(this.label7);
 			this.tabaction.Controls.Add(this.filtertag);
 			this.tabaction.Controls.Add(this.labeltag);
 			this.tabaction.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabaction.Location = new System.Drawing.Point(4, 23);
 			this.tabaction.Name = "tabaction";
 			this.tabaction.Padding = new System.Windows.Forms.Padding(3);
 			this.tabaction.Size = new System.Drawing.Size(445, 289);
 			this.tabaction.TabIndex = 2;
 			this.tabaction.Text = "Action";
 			this.tabaction.UseVisualStyleBackColor = true;
 			// 
 			// argumentspanel
 			// 
 			this.argumentspanel.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.argumentspanel.Controls.Add(this.label8);
 			this.argumentspanel.Controls.Add(this.arg2);
 			this.argumentspanel.Controls.Add(this.arg1);
 			this.argumentspanel.Controls.Add(this.arg0);
 			this.argumentspanel.Controls.Add(this.arg3);
 			this.argumentspanel.Controls.Add(this.arg4);
 			this.argumentspanel.Controls.Add(this.arg1label);
 			this.argumentspanel.Controls.Add(this.arg0label);
 			this.argumentspanel.Controls.Add(this.arg3label);
 			this.argumentspanel.Controls.Add(this.arg2label);
 			this.argumentspanel.Controls.Add(this.arg4label);
 			this.argumentspanel.Location = new System.Drawing.Point(6, 70);
 			this.argumentspanel.Name = "argumentspanel";
 			this.argumentspanel.Size = new System.Drawing.Size(418, 163);
 			this.argumentspanel.TabIndex = 17;
 			// 
 			// label8
 			// 
 			this.label8.AutoSize = true;
 			this.label8.Location = new System.Drawing.Point(22, 4);
 			this.label8.Name = "label8";
 			this.label8.Size = new System.Drawing.Size(102, 14);
 			this.label8.TabIndex = 21;
 			this.label8.Text = "Filter by arguments
 			// 
 			// arg2
 			// 
 			this.arg2.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.arg2.Location = new System.Drawing.Point(236, 75);
 			this.arg2.Name = "arg2";
 			this.arg2.Size = new System.Drawing.Size(93, 24);
 			this.arg2.TabIndex = 2;
 			this.arg2.Tag = "2";
 			this.arg2.Validated += new System.EventHandler(this.arg_Validated);
 			// 
 			// arg1
 			// 
 			this.arg1.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.arg1.Location = new System.Drawing.Point(236, 49);
 			this.arg1.Name = "arg1";
 			this.arg1.Size = new System.Drawing.Size(93, 24);
 			this.arg1.TabIndex = 1;
 			this.arg1.Tag = "1";
 			this.arg1.Validated += new System.EventHandler(this.arg_Validated);
 			// 
 			// arg0
 			// 
 			this.arg0.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.arg0.Location = new System.Drawing.Point(236, 23);
 			this.arg0.Name = "arg0";
 			this.arg0.Size = new System.Drawing.Size(93, 24);
 			this.arg0.TabIndex = 0;
 			this.arg0.Tag = "0";
 			this.arg0.Validated += new System.EventHandler(this.arg_Validated);
 			// 
 			// arg3
 			// 
 			this.arg3.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.arg3.Location = new System.Drawing.Point(236, 102);
 			this.arg3.Name = "arg3";
 			this.arg3.Size = new System.Drawing.Size(93, 24);
 			this.arg3.TabIndex = 3;
 			this.arg3.Tag = "3";
 			this.arg3.Validated += new System.EventHandler(this.arg_Validated);
 			// 
 			// arg4
 			// 
 			this.arg4.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.arg4.Location = new System.Drawing.Point(236, 128);
 			this.arg4.Name = "arg4";
 			this.arg4.Size = new System.Drawing.Size(93, 24);
 			this.arg4.TabIndex = 4;
 			this.arg4.Tag = "4";
 			this.arg4.Validated += new System.EventHandler(this.arg_Validated);
 			// 
 			// arg1label
 			// 
 			this.arg1label.Location = new System.Drawing.Point(33, 54);
 			this.arg1label.Name = "arg1label";
 			this.arg1label.Size = new System.Drawing.Size(197, 14);
 			this.arg1label.TabIndex = 14;
 			this.arg1label.Text = "Argument 2
 			this.arg1label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.arg1label.UseMnemonic = false;
 			// 
 			// arg0label
 			// 
 			this.arg0label.Location = new System.Drawing.Point(33, 28);
 			this.arg0label.Name = "arg0label";
 			this.arg0label.Size = new System.Drawing.Size(197, 14);
 			this.arg0label.TabIndex = 12;
 			this.arg0label.Text = "Argument 1
 			this.arg0label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.arg0label.UseMnemonic = false;
 			// 
 			// arg3label
 			// 
 			this.arg3label.Location = new System.Drawing.Point(33, 107);
 			this.arg3label.Name = "arg3label";
 			this.arg3label.Size = new System.Drawing.Size(197, 14);
 			this.arg3label.TabIndex = 20;
 			this.arg3label.Text = "Argument 4
 			this.arg3label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.arg3label.UseMnemonic = false;
 			// 
 			// arg2label
 			// 
 			this.arg2label.Location = new System.Drawing.Point(33, 80);
 			this.arg2label.Name = "arg2label";
 			this.arg2label.Size = new System.Drawing.Size(197, 14);
 			this.arg2label.TabIndex = 18;
 			this.arg2label.Text = "Argument 3
 			this.arg2label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.arg2label.UseMnemonic = false;
 			// 
 			// arg4label
 			// 
 			this.arg4label.Location = new System.Drawing.Point(33, 133);
 			this.arg4label.Name = "arg4label";
 			this.arg4label.Size = new System.Drawing.Size(197, 14);
 			this.arg4label.TabIndex = 16;
 			this.arg4label.Text = "Argument 5
 			this.arg4label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.arg4label.UseMnemonic = false;
 			// 
 			// filteraction
 			// 
 			this.filteraction.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.filteraction.BackColor = System.Drawing.Color.Transparent;
 			this.filteraction.Cursor = System.Windows.Forms.Cursors.Default;
 			this.filteraction.Empty = false;
 			this.filteraction.GeneralizedCategories = null;
 			this.filteraction.Location = new System.Drawing.Point(122, 30);
 			this.filteraction.Name = "filteraction";
 			this.filteraction.Size = new System.Drawing.Size(268, 21);
 			this.filteraction.TabIndex = 16;
 			this.filteraction.Value = 402;
 			this.filteraction.ValueChanges += new System.EventHandler(this.filteraction_ValueChanges);
 			// 
 			// browseaction
 			// 
 			this.browseaction.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
 			this.browseaction.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.browseaction.Image = global
 			this.browseaction.ImageAlign = System.Drawing.ContentAlignment.TopCenter;
 			this.browseaction.Location = new System.Drawing.Point(396, 28);
 			this.browseaction.Name = "browseaction";
 			this.browseaction.Padding = new System.Windows.Forms.Padding(0, 0, 1, 3);
 			this.browseaction.Size = new System.Drawing.Size(28, 25);
 			this.browseaction.TabIndex = 15;
 			this.browseaction.UseVisualStyleBackColor = true;
 			this.browseaction.Click += new System.EventHandler(this.browseaction_Click);
 			// 
 			// label7
 			// 
 			this.label7.AutoSize = true;
 			this.label7.Location = new System.Drawing.Point(28, 33);
 			this.label7.Name = "label7";
 			this.label7.Size = new System.Drawing.Size(80, 14);
 			this.label7.TabIndex = 14;
 			this.label7.Text = "Filter by action
 			// 
 			// filtertag
 			// 
 			this.filtertag.AllowDecimal = false;
 			this.filtertag.AllowNegative = true;
 			this.filtertag.AllowRelative = false;
 			this.filtertag.ButtonStep = 1;
 			this.filtertag.Location = new System.Drawing.Point(122, 244);
 			this.filtertag.Name = "filtertag";
 			this.filtertag.Size = new System.Drawing.Size(72, 24);
 			this.filtertag.StepValues = null;
 			this.filtertag.TabIndex = 13;
 			this.filtertag.WhenTextChanged += new System.EventHandler(this.filtertag_WhenTextChanged);
 			// 
 			// labeltag
 			// 
 			this.labeltag.AutoSize = true;
 			this.labeltag.Location = new System.Drawing.Point(42, 249);
 			this.labeltag.Name = "labeltag";
 			this.labeltag.Size = new System.Drawing.Size(66, 14);
 			this.labeltag.TabIndex = 12;
 			this.labeltag.Text = "Filter by tag
 			// 
 			// tabcustom
 			// 
 			this.tabcustom.Controls.Add(this.fieldslist);
 			this.tabcustom.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabcustom.Location = new System.Drawing.Point(4, 23);
 			this.tabcustom.Name = "tabcustom";
 			this.tabcustom.Padding = new System.Windows.Forms.Padding(3);
 			this.tabcustom.Size = new System.Drawing.Size(445, 289);
 			this.tabcustom.TabIndex = 3;
 			this.tabcustom.Text = "Custom";
 			this.tabcustom.UseVisualStyleBackColor = true;
 			// 
 			// fieldslist
 			// 
 			this.fieldslist.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.fieldslist.AutoInsertUserPrefix = false;
 			this.fieldslist.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.fieldslist.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.fieldslist.Location = new System.Drawing.Point(8, 9);
 			this.fieldslist.Margin = new System.Windows.Forms.Padding(8, 9, 8, 9);
 			this.fieldslist.Name = "fieldslist";
 			this.fieldslist.Size = new System.Drawing.Size(426, 271);
 			this.fieldslist.TabIndex = 2;
 			this.fieldslist.Validated += new System.EventHandler(this.fieldslist_Validated);
 			// 
 			// filtername
 			// 
 			this.filtername.Location = new System.Drawing.Point(70, 27);
 			this.filtername.MaxLength = 50;
 			this.filtername.Name = "filtername";
 			this.filtername.Size = new System.Drawing.Size(232, 20);
 			this.filtername.TabIndex = 0;
 			this.filtername.Validating += new System.ComponentModel.CancelEventHandler(this.filtername_Validating);
 			// 
 			// label1
 			// 
 			this.label1.AutoSize = true;
 			this.label1.Location = new System.Drawing.Point(27, 30);
 			this.label1.Name = "label1";
 			this.label1.Size = new System.Drawing.Size(37, 14);
 			this.label1.TabIndex = 0;
 			this.label1.Text = "Name
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(585, 414);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 5;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(467, 414);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 4;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// ThingsFiltersForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(707, 449);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.filtergroup);
 			this.Controls.Add(this.deletefilter);
 			this.Controls.Add(this.addfilter);
 			this.Controls.Add(this.listfilters);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "ThingsFiltersForm";
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Things Filters";
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.ThingsFiltersForm_HelpRequested);
 			this.filtergroup.ResumeLayout(false);
 			this.filtergroup.PerformLayout();
 			this.tabs.ResumeLayout(false);
 			this.tabbasic.ResumeLayout(false);
 			this.tabbasic.PerformLayout();
 			this.tabflags.ResumeLayout(false);
 			this.tabflags.PerformLayout();
 			this.tabaction.ResumeLayout(false);
 			this.tabaction.PerformLayout();
 			this.argumentspanel.ResumeLayout(false);
 			this.argumentspanel.PerformLayout();
 			this.tabcustom.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\MainForm.Designer.cs" startline="22" endline="1629">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			this.components = new System.ComponentModel.Container();
 			System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
 			System.Windows.Forms.ToolStripSeparator toolStripSeparator9;
 			System.Windows.Forms.ToolStripSeparator toolStripSeparator12;
 			System.Windows.Forms.ToolStripSeparator toolStripMenuItem4;
 			System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
 			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
 			this.seperatorfileopen = new System.Windows.Forms.ToolStripSeparator();
 			this.seperatorfilerecent = new System.Windows.Forms.ToolStripSeparator();
 			this.seperatoreditgrid = new System.Windows.Forms.ToolStripSeparator();
 			this.seperatoreditcopypaste = new System.Windows.Forms.ToolStripSeparator();
 			this.seperatorfile = new System.Windows.Forms.ToolStripSeparator();
 			this.seperatorscript = new System.Windows.Forms.ToolStripSeparator();
 			this.seperatorprefabs = new System.Windows.Forms.ToolStripSeparator();
 			this.seperatorundo = new System.Windows.Forms.ToolStripSeparator();
 			this.seperatorcopypaste = new System.Windows.Forms.ToolStripSeparator();
 			this.seperatormodes = new System.Windows.Forms.ToolStripSeparator();
 			this.poscommalabel = new System.Windows.Forms.ToolStripStatusLabel();
 			this.menumain = new System.Windows.Forms.MenuStrip();
 			this.menufile = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemnewmap = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemopenmap = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemclosemap = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemsavemap = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemsavemapas = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemsavemapinto = new System.Windows.Forms.ToolStripMenuItem();
 			this.seperatorfilesave = new System.Windows.Forms.ToolStripSeparator();
 			this.itemnorecent = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemexit = new System.Windows.Forms.ToolStripMenuItem();
 			this.menuedit = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemundo = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemredo = new System.Windows.Forms.ToolStripMenuItem();
 			this.seperatoreditundo = new System.Windows.Forms.ToolStripSeparator();
 			this.itemcut = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemcopy = new System.Windows.Forms.ToolStripMenuItem();
 			this.itempaste = new System.Windows.Forms.ToolStripMenuItem();
 			this.itempastespecial = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemsnaptogrid = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemautomerge = new System.Windows.Forms.ToolStripMenuItem();
 			this.seperatoreditgeometry = new System.Windows.Forms.ToolStripSeparator();
 			this.itemgridinc = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgriddec = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgridsetup = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemmapoptions = new System.Windows.Forms.ToolStripMenuItem();
 			this.menuview = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemthingsfilter = new System.Windows.Forms.ToolStripMenuItem();
 			this.seperatorviewthings = new System.Windows.Forms.ToolStripSeparator();
 			this.itemviewnormal = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemviewbrightness = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemviewfloors = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemviewceilings = new System.Windows.Forms.ToolStripMenuItem();
 			this.seperatorviewviews = new System.Windows.Forms.ToolStripSeparator();
 			this.menuzoom = new System.Windows.Forms.ToolStripMenuItem();
 			this.item2zoom200 = new System.Windows.Forms.ToolStripMenuItem();
 			this.item2zoom100 = new System.Windows.Forms.ToolStripMenuItem();
 			this.item2zoom50 = new System.Windows.Forms.ToolStripMenuItem();
 			this.item2zoom25 = new System.Windows.Forms.ToolStripMenuItem();
 			this.item2zoom10 = new System.Windows.Forms.ToolStripMenuItem();
 			this.item2zoom5 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemfittoscreen = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemtoggleinfo = new System.Windows.Forms.ToolStripMenuItem();
 			this.seperatorviewzoom = new System.Windows.Forms.ToolStripSeparator();
 			this.itemscripteditor = new System.Windows.Forms.ToolStripMenuItem();
 			this.menumode = new System.Windows.Forms.ToolStripMenuItem();
 			this.menuprefabs = new System.Windows.Forms.ToolStripMenuItem();
 			this.iteminsertprefabfile = new System.Windows.Forms.ToolStripMenuItem();
 			this.iteminsertpreviousprefab = new System.Windows.Forms.ToolStripMenuItem();
 			this.seperatorprefabsinsert = new System.Windows.Forms.ToolStripSeparator();
 			this.itemcreateprefab = new System.Windows.Forms.ToolStripMenuItem();
 			this.menutools = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemreloadresources = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemshowerrors = new System.Windows.Forms.ToolStripMenuItem();
 			this.seperatortoolsresources = new System.Windows.Forms.ToolStripSeparator();
 			this.configurationToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
 			this.preferencesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
 			this.seperatortoolsconfig = new System.Windows.Forms.ToolStripSeparator();
 			this.itemtestmap = new System.Windows.Forms.ToolStripMenuItem();
 			this.menuhelp = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemhelprefmanual = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemhelpeditmode = new System.Windows.Forms.ToolStripMenuItem();
 			this.seperatorhelpmanual = new System.Windows.Forms.ToolStripSeparator();
 			this.itemhelpabout = new System.Windows.Forms.ToolStripMenuItem();
 			this.toolbar = new System.Windows.Forms.ToolStrip();
 			this.buttonnewmap = new System.Windows.Forms.ToolStripButton();
 			this.buttonopenmap = new System.Windows.Forms.ToolStripButton();
 			this.buttonsavemap = new System.Windows.Forms.ToolStripButton();
 			this.buttonscripteditor = new System.Windows.Forms.ToolStripButton();
 			this.buttonundo = new System.Windows.Forms.ToolStripButton();
 			this.buttonredo = new System.Windows.Forms.ToolStripButton();
 			this.buttoncut = new System.Windows.Forms.ToolStripButton();
 			this.buttoncopy = new System.Windows.Forms.ToolStripButton();
 			this.buttonpaste = new System.Windows.Forms.ToolStripButton();
 			this.buttoninsertprefabfile = new System.Windows.Forms.ToolStripButton();
 			this.buttoninsertpreviousprefab = new System.Windows.Forms.ToolStripButton();
 			this.buttonthingsfilter = new System.Windows.Forms.ToolStripButton();
 			this.thingfilters = new System.Windows.Forms.ToolStripComboBox();
 			this.buttonviewnormal = new System.Windows.Forms.ToolStripButton();
 			this.buttonviewbrightness = new System.Windows.Forms.ToolStripButton();
 			this.buttonviewfloors = new System.Windows.Forms.ToolStripButton();
 			this.buttonviewceilings = new System.Windows.Forms.ToolStripButton();
 			this.seperatorviews = new System.Windows.Forms.ToolStripSeparator();
 			this.buttonsnaptogrid = new System.Windows.Forms.ToolStripButton();
 			this.buttonautomerge = new System.Windows.Forms.ToolStripButton();
 			this.seperatorgeometry = new System.Windows.Forms.ToolStripSeparator();
 			this.buttontest = new System.Windows.Forms.ToolStripSplitButton();
 			this.seperatortesting = new System.Windows.Forms.ToolStripSeparator();
 			this.statusbar = new System.Windows.Forms.StatusStrip();
 			this.statuslabel = new System.Windows.Forms.ToolStripStatusLabel();
 			this.configlabel = new System.Windows.Forms.ToolStripStatusLabel();
 			this.gridlabel = new System.Windows.Forms.ToolStripStatusLabel();
 			this.buttongrid = new System.Windows.Forms.ToolStripDropDownButton();
 			this.itemgrid1024 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgrid512 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgrid256 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgrid128 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgrid64 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgrid32 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgrid16 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgrid8 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgrid4 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemgridcustom = new System.Windows.Forms.ToolStripMenuItem();
 			this.zoomlabel = new System.Windows.Forms.ToolStripStatusLabel();
 			this.buttonzoom = new System.Windows.Forms.ToolStripDropDownButton();
 			this.itemzoom200 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemzoom100 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemzoom50 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemzoom25 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemzoom10 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemzoom5 = new System.Windows.Forms.ToolStripMenuItem();
 			this.itemzoomfittoscreen = new System.Windows.Forms.ToolStripMenuItem();
 			this.xposlabel = new System.Windows.Forms.ToolStripStatusLabel();
 			this.yposlabel = new System.Windows.Forms.ToolStripStatusLabel();
 			this.panelinfo = new System.Windows.Forms.Panel();
 			this.heightpanel1 = new System.Windows.Forms.Panel();
 			this.vertexinfo = new CodeImp.DoomBuilder.Controls.VertexInfoPanel();
 			this.labelcollapsedinfo = new System.Windows.Forms.Label();
 			this.buttontoggleinfo = new System.Windows.Forms.Button();
 			this.modename = new System.Windows.Forms.Label();
 			this.linedefinfo = new CodeImp.DoomBuilder.Controls.LinedefInfoPanel();
 			this.thinginfo = new CodeImp.DoomBuilder.Controls.ThingInfoPanel();
 			this.sectorinfo = new CodeImp.DoomBuilder.Controls.SectorInfoPanel();
 			this.redrawtimer = new System.Windows.Forms.Timer(this.components);
 			this.display = new CodeImp.DoomBuilder.Controls.RenderTargetControl();
 			this.processor = new System.Windows.Forms.Timer(this.components);
 			this.statusflasher = new System.Windows.Forms.Timer(this.components);
 			this.statusresetter = new System.Windows.Forms.Timer(this.components);
 			this.dockersspace = new System.Windows.Forms.Panel();
 			this.dockerspanel = new CodeImp.DoomBuilder.Controls.DockersControl();
 			this.dockerscollapser = new System.Windows.Forms.Timer(this.components);
 			toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
 			toolStripSeparator9 = new System.Windows.Forms.ToolStripSeparator();
 			toolStripSeparator12 = new System.Windows.Forms.ToolStripSeparator();
 			toolStripMenuItem4 = new System.Windows.Forms.ToolStripSeparator();
 			toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
 			this.menumain.SuspendLayout();
 			this.toolbar.SuspendLayout();
 			this.statusbar.SuspendLayout();
 			this.panelinfo.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// toolStripSeparator1
 			// 
 			toolStripSeparator1.Margin = new System.Windows.Forms.Padding(3, 0, 3, 0);
 			toolStripSeparator1.Name = "toolStripSeparator1";
 			toolStripSeparator1.Size = new System.Drawing.Size(6, 23);
 			// 
 			// toolStripSeparator9
 			// 
 			toolStripSeparator9.Margin = new System.Windows.Forms.Padding(3, 0, 3, 0);
 			toolStripSeparator9.Name = "toolStripSeparator9";
 			toolStripSeparator9.Size = new System.Drawing.Size(6, 23);
 			// 
 			// toolStripSeparator12
 			// 
 			toolStripSeparator12.Margin = new System.Windows.Forms.Padding(3, 0, 3, 0);
 			toolStripSeparator12.Name = "toolStripSeparator12";
 			toolStripSeparator12.Size = new System.Drawing.Size(6, 23);
 			// 
 			// toolStripMenuItem4
 			// 
 			toolStripMenuItem4.Name = "toolStripMenuItem4";
 			toolStripMenuItem4.Size = new System.Drawing.Size(150, 6);
 			// 
 			// toolStripSeparator2
 			// 
 			toolStripSeparator2.Name = "toolStripSeparator2";
 			toolStripSeparator2.Size = new System.Drawing.Size(153, 6);
 			// 
 			// seperatorfileopen
 			// 
 			this.seperatorfileopen.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatorfileopen.Name = "seperatorfileopen";
 			this.seperatorfileopen.Size = new System.Drawing.Size(199, 6);
 			// 
 			// seperatorfilerecent
 			// 
 			this.seperatorfilerecent.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatorfilerecent.Name = "seperatorfilerecent";
 			this.seperatorfilerecent.Size = new System.Drawing.Size(199, 6);
 			// 
 			// seperatoreditgrid
 			// 
 			this.seperatoreditgrid.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatoreditgrid.Name = "seperatoreditgrid";
 			this.seperatoreditgrid.Size = new System.Drawing.Size(160, 6);
 			// 
 			// seperatoreditcopypaste
 			// 
 			this.seperatoreditcopypaste.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatoreditcopypaste.Name = "seperatoreditcopypaste";
 			this.seperatoreditcopypaste.Size = new System.Drawing.Size(160, 6);
 			// 
 			// seperatorfile
 			// 
 			this.seperatorfile.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.seperatorfile.Name = "seperatorfile";
 			this.seperatorfile.Size = new System.Drawing.Size(6, 25);
 			// 
 			// seperatorscript
 			// 
 			this.seperatorscript.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.seperatorscript.Name = "seperatorscript";
 			this.seperatorscript.Size = new System.Drawing.Size(6, 25);
 			// 
 			// seperatorprefabs
 			// 
 			this.seperatorprefabs.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.seperatorprefabs.Name = "seperatorprefabs";
 			this.seperatorprefabs.Size = new System.Drawing.Size(6, 25);
 			// 
 			// seperatorundo
 			// 
 			this.seperatorundo.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.seperatorundo.Name = "seperatorundo";
 			this.seperatorundo.Size = new System.Drawing.Size(6, 25);
 			// 
 			// seperatorcopypaste
 			// 
 			this.seperatorcopypaste.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.seperatorcopypaste.Name = "seperatorcopypaste";
 			this.seperatorcopypaste.Size = new System.Drawing.Size(6, 25);
 			// 
 			// seperatormodes
 			// 
 			this.seperatormodes.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.seperatormodes.Name = "seperatormodes";
 			this.seperatormodes.Size = new System.Drawing.Size(6, 25);
 			this.seperatormodes.Visible = false;
 			// 
 			// poscommalabel
 			// 
 			this.poscommalabel.Name = "poscommalabel";
 			this.poscommalabel.Size = new System.Drawing.Size(11, 18);
 			this.poscommalabel.Text = ",";
 			this.poscommalabel.ToolTipText = "Current X, Y coordinates on map";
 			// 
 			// menumain
 			// 
 			this.menumain.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.menufile,
             this.menuedit,
             this.menuview,
             this.menumode,
             this.menuprefabs,
             this.menutools,
             this.menuhelp});
 			this.menumain.Location = new System.Drawing.Point(0, 0);
 			this.menumain.Name = "menumain";
 			this.menumain.Size = new System.Drawing.Size(1012, 24);
 			this.menumain.TabIndex = 0;
 			// 
 			// menufile
 			// 
 			this.menufile.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.itemnewmap,
             this.itemopenmap,
             this.itemclosemap,
             this.seperatorfileopen,
             this.itemsavemap,
             this.itemsavemapas,
             this.itemsavemapinto,
             this.seperatorfilesave,
             this.itemnorecent,
             this.seperatorfilerecent,
             this.itemexit});
 			this.menufile.Name = "menufile";
 			this.menufile.Size = new System.Drawing.Size(37, 20);
 			this.menufile.Text = "&File";
 			// 
 			// itemnewmap
 			// 
 			this.itemnewmap.Image = global
 			this.itemnewmap.Name = "itemnewmap";
 			this.itemnewmap.ShortcutKeyDisplayString = "";
 			this.itemnewmap.Size = new System.Drawing.Size(202, 22);
 			this.itemnewmap.Tag = "builder_newmap";
 			this.itemnewmap.Text = "&New Map";
 			this.itemnewmap.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemopenmap
 			// 
 			this.itemopenmap.Image = global
 			this.itemopenmap.Name = "itemopenmap";
 			this.itemopenmap.Size = new System.Drawing.Size(202, 22);
 			this.itemopenmap.Tag = "builder_openmap";
 			this.itemopenmap.Text = "&Open Map...";
 			this.itemopenmap.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemclosemap
 			// 
 			this.itemclosemap.Name = "itemclosemap";
 			this.itemclosemap.Size = new System.Drawing.Size(202, 22);
 			this.itemclosemap.Tag = "builder_closemap";
 			this.itemclosemap.Text = "&Close Map";
 			this.itemclosemap.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemsavemap
 			// 
 			this.itemsavemap.Image = global
 			this.itemsavemap.Name = "itemsavemap";
 			this.itemsavemap.Size = new System.Drawing.Size(202, 22);
 			this.itemsavemap.Tag = "builder_savemap";
 			this.itemsavemap.Text = "&Save Map";
 			this.itemsavemap.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemsavemapas
 			// 
 			this.itemsavemapas.Name = "itemsavemapas";
 			this.itemsavemapas.Size = new System.Drawing.Size(202, 22);
 			this.itemsavemapas.Tag = "builder_savemapas";
 			this.itemsavemapas.Text = "Save Map &As...";
 			this.itemsavemapas.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemsavemapinto
 			// 
 			this.itemsavemapinto.Name = "itemsavemapinto";
 			this.itemsavemapinto.Size = new System.Drawing.Size(202, 22);
 			this.itemsavemapinto.Tag = "builder_savemapinto";
 			this.itemsavemapinto.Text = "Save Map &Into...";
 			this.itemsavemapinto.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatorfilesave
 			// 
 			this.seperatorfilesave.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatorfilesave.Name = "seperatorfilesave";
 			this.seperatorfilesave.Size = new System.Drawing.Size(199, 6);
 			// 
 			// itemnorecent
 			// 
 			this.itemnorecent.Enabled = false;
 			this.itemnorecent.Name = "itemnorecent";
 			this.itemnorecent.Size = new System.Drawing.Size(202, 22);
 			this.itemnorecent.Text = "No recently opened files";
 			// 
 			// itemexit
 			// 
 			this.itemexit.Name = "itemexit";
 			this.itemexit.Size = new System.Drawing.Size(202, 22);
 			this.itemexit.Text = "E&xit";
 			this.itemexit.Click += new System.EventHandler(this.itemexit_Click);
 			// 
 			// menuedit
 			// 
 			this.menuedit.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.itemundo,
             this.itemredo,
             this.seperatoreditundo,
             this.itemcut,
             this.itemcopy,
             this.itempaste,
             this.itempastespecial,
             this.seperatoreditcopypaste,
             this.itemsnaptogrid,
             this.itemautomerge,
             this.seperatoreditgeometry,
             this.itemgridinc,
             this.itemgriddec,
             this.itemgridsetup,
             this.seperatoreditgrid,
             this.itemmapoptions});
 			this.menuedit.Name = "menuedit";
 			this.menuedit.Size = new System.Drawing.Size(39, 20);
 			this.menuedit.Text = "&Edit";
 			// 
 			// itemundo
 			// 
 			this.itemundo.Image = global
 			this.itemundo.Name = "itemundo";
 			this.itemundo.Size = new System.Drawing.Size(163, 22);
 			this.itemundo.Tag = "builder_undo";
 			this.itemundo.Text = "&Undo";
 			this.itemundo.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemredo
 			// 
 			this.itemredo.Image = global
 			this.itemredo.Name = "itemredo";
 			this.itemredo.Size = new System.Drawing.Size(163, 22);
 			this.itemredo.Tag = "builder_redo";
 			this.itemredo.Text = "&Redo";
 			this.itemredo.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatoreditundo
 			// 
 			this.seperatoreditundo.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatoreditundo.Name = "seperatoreditundo";
 			this.seperatoreditundo.Size = new System.Drawing.Size(160, 6);
 			// 
 			// itemcut
 			// 
 			this.itemcut.Image = global
 			this.itemcut.Name = "itemcut";
 			this.itemcut.Size = new System.Drawing.Size(163, 22);
 			this.itemcut.Tag = "builder_cutselection";
 			this.itemcut.Text = "Cu&t";
 			this.itemcut.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemcopy
 			// 
 			this.itemcopy.Image = global
 			this.itemcopy.Name = "itemcopy";
 			this.itemcopy.Size = new System.Drawing.Size(163, 22);
 			this.itemcopy.Tag = "builder_copyselection";
 			this.itemcopy.Text = "&Copy";
 			this.itemcopy.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itempaste
 			// 
 			this.itempaste.Image = global
 			this.itempaste.Name = "itempaste";
 			this.itempaste.Size = new System.Drawing.Size(163, 22);
 			this.itempaste.Tag = "builder_pasteselection";
 			this.itempaste.Text = "&Paste";
 			this.itempaste.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itempastespecial
 			// 
 			this.itempastespecial.Image = global
 			this.itempastespecial.Name = "itempastespecial";
 			this.itempastespecial.Size = new System.Drawing.Size(163, 22);
 			this.itempastespecial.Tag = "builder_pasteselectionspecial";
 			this.itempastespecial.Text = "Paste Special...";
 			this.itempastespecial.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemsnaptogrid
 			// 
 			this.itemsnaptogrid.Checked = true;
 			this.itemsnaptogrid.CheckState = System.Windows.Forms.CheckState.Checked;
 			this.itemsnaptogrid.Image = global
 			this.itemsnaptogrid.Name = "itemsnaptogrid";
 			this.itemsnaptogrid.Size = new System.Drawing.Size(163, 22);
 			this.itemsnaptogrid.Tag = "builder_togglesnap";
 			this.itemsnaptogrid.Text = "&Snap to Grid";
 			this.itemsnaptogrid.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemautomerge
 			// 
 			this.itemautomerge.Checked = true;
 			this.itemautomerge.CheckState = System.Windows.Forms.CheckState.Checked;
 			this.itemautomerge.Image = global
 			this.itemautomerge.Name = "itemautomerge";
 			this.itemautomerge.Size = new System.Drawing.Size(163, 22);
 			this.itemautomerge.Tag = "builder_toggleautomerge";
 			this.itemautomerge.Text = "&Merge Geometry";
 			this.itemautomerge.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatoreditgeometry
 			// 
 			this.seperatoreditgeometry.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatoreditgeometry.Name = "seperatoreditgeometry";
 			this.seperatoreditgeometry.Size = new System.Drawing.Size(160, 6);
 			// 
 			// itemgridinc
 			// 
 			this.itemgridinc.Name = "itemgridinc";
 			this.itemgridinc.Size = new System.Drawing.Size(163, 22);
 			this.itemgridinc.Tag = "builder_griddec";
 			this.itemgridinc.Text = "&Increase Grid";
 			this.itemgridinc.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemgriddec
 			// 
 			this.itemgriddec.Name = "itemgriddec";
 			this.itemgriddec.Size = new System.Drawing.Size(163, 22);
 			this.itemgriddec.Tag = "builder_gridinc";
 			this.itemgriddec.Text = "&Decrease Grid";
 			this.itemgriddec.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemgridsetup
 			// 
 			this.itemgridsetup.Image = global
 			this.itemgridsetup.Name = "itemgridsetup";
 			this.itemgridsetup.Size = new System.Drawing.Size(163, 22);
 			this.itemgridsetup.Tag = "builder_gridsetup";
 			this.itemgridsetup.Text = "&Grid Setup...";
 			this.itemgridsetup.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemmapoptions
 			// 
 			this.itemmapoptions.Image = global
 			this.itemmapoptions.Name = "itemmapoptions";
 			this.itemmapoptions.Size = new System.Drawing.Size(163, 22);
 			this.itemmapoptions.Tag = "builder_mapoptions";
 			this.itemmapoptions.Text = "Map &Options....";
 			this.itemmapoptions.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// menuview
 			// 
 			this.menuview.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.itemthingsfilter,
             this.seperatorviewthings,
             this.itemviewnormal,
             this.itemviewbrightness,
             this.itemviewfloors,
             this.itemviewceilings,
             this.seperatorviewviews,
             this.menuzoom,
             this.itemfittoscreen,
             this.itemtoggleinfo,
             this.seperatorviewzoom,
             this.itemscripteditor});
 			this.menuview.Name = "menuview";
 			this.menuview.Size = new System.Drawing.Size(44, 20);
 			this.menuview.Text = "&View";
 			// 
 			// itemthingsfilter
 			// 
 			this.itemthingsfilter.Image = global
 			this.itemthingsfilter.Name = "itemthingsfilter";
 			this.itemthingsfilter.Size = new System.Drawing.Size(209, 22);
 			this.itemthingsfilter.Tag = "builder_thingsfilterssetup";
 			this.itemthingsfilter.Text = "Configure &Things Filters...";
 			this.itemthingsfilter.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatorviewthings
 			// 
 			this.seperatorviewthings.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatorviewthings.Name = "seperatorviewthings";
 			this.seperatorviewthings.Size = new System.Drawing.Size(206, 6);
 			// 
 			// itemviewnormal
 			// 
 			this.itemviewnormal.Image = global
 			this.itemviewnormal.Name = "itemviewnormal";
 			this.itemviewnormal.Size = new System.Drawing.Size(209, 22);
 			this.itemviewnormal.Tag = "builder_viewmodenormal";
 			this.itemviewnormal.Text = "&Wireframe";
 			this.itemviewnormal.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemviewbrightness
 			// 
 			this.itemviewbrightness.Image = global
 			this.itemviewbrightness.Name = "itemviewbrightness";
 			this.itemviewbrightness.Size = new System.Drawing.Size(209, 22);
 			this.itemviewbrightness.Tag = "builder_viewmodebrightness";
 			this.itemviewbrightness.Text = "&Brightness Levels";
 			this.itemviewbrightness.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemviewfloors
 			// 
 			this.itemviewfloors.Image = global
 			this.itemviewfloors.Name = "itemviewfloors";
 			this.itemviewfloors.Size = new System.Drawing.Size(209, 22);
 			this.itemviewfloors.Tag = "builder_viewmodefloors";
 			this.itemviewfloors.Text = "&Floor Textures";
 			this.itemviewfloors.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemviewceilings
 			// 
 			this.itemviewceilings.Image = global
 			this.itemviewceilings.Name = "itemviewceilings";
 			this.itemviewceilings.Size = new System.Drawing.Size(209, 22);
 			this.itemviewceilings.Tag = "builder_viewmodeceilings";
 			this.itemviewceilings.Text = "&Ceiling Textures";
 			this.itemviewceilings.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatorviewviews
 			// 
 			this.seperatorviewviews.Name = "seperatorviewviews";
 			this.seperatorviewviews.Size = new System.Drawing.Size(206, 6);
 			// 
 			// menuzoom
 			// 
 			this.menuzoom.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.item2zoom200,
             this.item2zoom100,
             this.item2zoom50,
             this.item2zoom25,
             this.item2zoom10,
             this.item2zoom5});
 			this.menuzoom.Image = global
 			this.menuzoom.Name = "menuzoom";
 			this.menuzoom.Size = new System.Drawing.Size(209, 22);
 			this.menuzoom.Text = "&Zoom";
 			// 
 			// item2zoom200
 			// 
 			this.item2zoom200.Name = "item2zoom200";
 			this.item2zoom200.Size = new System.Drawing.Size(102, 22);
 			this.item2zoom200.Tag = "200";
 			this.item2zoom200.Text = "200%";
 			this.item2zoom200.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// item2zoom100
 			// 
 			this.item2zoom100.Name = "item2zoom100";
 			this.item2zoom100.Size = new System.Drawing.Size(102, 22);
 			this.item2zoom100.Tag = "100";
 			this.item2zoom100.Text = "100%";
 			this.item2zoom100.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// item2zoom50
 			// 
 			this.item2zoom50.Name = "item2zoom50";
 			this.item2zoom50.Size = new System.Drawing.Size(102, 22);
 			this.item2zoom50.Tag = "50";
 			this.item2zoom50.Text = "50%";
 			this.item2zoom50.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// item2zoom25
 			// 
 			this.item2zoom25.Name = "item2zoom25";
 			this.item2zoom25.Size = new System.Drawing.Size(102, 22);
 			this.item2zoom25.Tag = "25";
 			this.item2zoom25.Text = "25%";
 			this.item2zoom25.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// item2zoom10
 			// 
 			this.item2zoom10.Name = "item2zoom10";
 			this.item2zoom10.Size = new System.Drawing.Size(102, 22);
 			this.item2zoom10.Tag = "10";
 			this.item2zoom10.Text = "10%";
 			this.item2zoom10.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// item2zoom5
 			// 
 			this.item2zoom5.Name = "item2zoom5";
 			this.item2zoom5.Size = new System.Drawing.Size(102, 22);
 			this.item2zoom5.Tag = "5";
 			this.item2zoom5.Text = "5%";
 			this.item2zoom5.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// itemfittoscreen
 			// 
 			this.itemfittoscreen.Name = "itemfittoscreen";
 			this.itemfittoscreen.Size = new System.Drawing.Size(209, 22);
 			this.itemfittoscreen.Tag = "builder_centerinscreen";
 			this.itemfittoscreen.Text = "Fit to screen";
 			this.itemfittoscreen.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemtoggleinfo
 			// 
 			this.itemtoggleinfo.Name = "itemtoggleinfo";
 			this.itemtoggleinfo.Size = new System.Drawing.Size(209, 22);
 			this.itemtoggleinfo.Tag = "builder_toggleinfopanel";
 			this.itemtoggleinfo.Text = "&Expanded Info Panel";
 			this.itemtoggleinfo.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatorviewzoom
 			// 
 			this.seperatorviewzoom.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatorviewzoom.Name = "seperatorviewzoom";
 			this.seperatorviewzoom.Size = new System.Drawing.Size(206, 6);
 			// 
 			// itemscripteditor
 			// 
 			this.itemscripteditor.Image = global
 			this.itemscripteditor.Name = "itemscripteditor";
 			this.itemscripteditor.Size = new System.Drawing.Size(209, 22);
 			this.itemscripteditor.Tag = "builder_openscripteditor";
 			this.itemscripteditor.Text = "&Script Editor...";
 			this.itemscripteditor.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// menumode
 			// 
 			this.menumode.Name = "menumode";
 			this.menumode.Size = new System.Drawing.Size(50, 20);
 			this.menumode.Text = "&Mode";
 			// 
 			// menuprefabs
 			// 
 			this.menuprefabs.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.iteminsertprefabfile,
             this.iteminsertpreviousprefab,
             this.seperatorprefabsinsert,
             this.itemcreateprefab});
 			this.menuprefabs.Name = "menuprefabs";
 			this.menuprefabs.Size = new System.Drawing.Size(58, 20);
 			this.menuprefabs.Text = "&Prefabs";
 			// 
 			// iteminsertprefabfile
 			// 
 			this.iteminsertprefabfile.Name = "iteminsertprefabfile";
 			this.iteminsertprefabfile.Size = new System.Drawing.Size(199, 22);
 			this.iteminsertprefabfile.Tag = "builder_insertprefabfile";
 			this.iteminsertprefabfile.Text = "&Insert Prefab from File...";
 			this.iteminsertprefabfile.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// iteminsertpreviousprefab
 			// 
 			this.iteminsertpreviousprefab.Name = "iteminsertpreviousprefab";
 			this.iteminsertpreviousprefab.Size = new System.Drawing.Size(199, 22);
 			this.iteminsertpreviousprefab.Tag = "builder_insertpreviousprefab";
 			this.iteminsertpreviousprefab.Text = "Insert &Previous Prefab";
 			this.iteminsertpreviousprefab.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatorprefabsinsert
 			// 
 			this.seperatorprefabsinsert.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatorprefabsinsert.Name = "seperatorprefabsinsert";
 			this.seperatorprefabsinsert.Size = new System.Drawing.Size(196, 6);
 			// 
 			// itemcreateprefab
 			// 
 			this.itemcreateprefab.Name = "itemcreateprefab";
 			this.itemcreateprefab.Size = new System.Drawing.Size(199, 22);
 			this.itemcreateprefab.Tag = "builder_createprefab";
 			this.itemcreateprefab.Text = "&Create From Selection...";
 			this.itemcreateprefab.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// menutools
 			// 
 			this.menutools.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.itemreloadresources,
             this.itemshowerrors,
             this.seperatortoolsresources,
             this.configurationToolStripMenuItem,
             this.preferencesToolStripMenuItem,
             this.seperatortoolsconfig,
             this.itemtestmap});
 			this.menutools.Name = "menutools";
 			this.menutools.Size = new System.Drawing.Size(48, 20);
 			this.menutools.Text = "&Tools";
 			// 
 			// itemreloadresources
 			// 
 			this.itemreloadresources.Name = "itemreloadresources";
 			this.itemreloadresources.Size = new System.Drawing.Size(196, 22);
 			this.itemreloadresources.Tag = "builder_reloadresources";
 			this.itemreloadresources.Text = "&Reload Resources";
 			this.itemreloadresources.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// itemshowerrors
 			// 
 			this.itemshowerrors.Image = global
 			this.itemshowerrors.Name = "itemshowerrors";
 			this.itemshowerrors.Size = new System.Drawing.Size(196, 22);
 			this.itemshowerrors.Tag = "builder_showerrors";
 			this.itemshowerrors.Text = "&Errors and Warnings...";
 			this.itemshowerrors.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatortoolsresources
 			// 
 			this.seperatortoolsresources.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatortoolsresources.Name = "seperatortoolsresources";
 			this.seperatortoolsresources.Size = new System.Drawing.Size(193, 6);
 			// 
 			// configurationToolStripMenuItem
 			// 
 			this.configurationToolStripMenuItem.Name = "configurationToolStripMenuItem";
 			this.configurationToolStripMenuItem.Size = new System.Drawing.Size(196, 22);
 			this.configurationToolStripMenuItem.Tag = "builder_configuration";
 			this.configurationToolStripMenuItem.Text = "&Game Configurations...";
 			this.configurationToolStripMenuItem.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// preferencesToolStripMenuItem
 			// 
 			this.preferencesToolStripMenuItem.Name = "preferencesToolStripMenuItem";
 			this.preferencesToolStripMenuItem.Size = new System.Drawing.Size(196, 22);
 			this.preferencesToolStripMenuItem.Tag = "builder_preferences";
 			this.preferencesToolStripMenuItem.Text = "Preferences...";
 			this.preferencesToolStripMenuItem.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatortoolsconfig
 			// 
 			this.seperatortoolsconfig.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatortoolsconfig.Name = "seperatortoolsconfig";
 			this.seperatortoolsconfig.Size = new System.Drawing.Size(193, 6);
 			// 
 			// itemtestmap
 			// 
 			this.itemtestmap.Image = global
 			this.itemtestmap.Name = "itemtestmap";
 			this.itemtestmap.Size = new System.Drawing.Size(196, 22);
 			this.itemtestmap.Tag = "builder_testmap";
 			this.itemtestmap.Text = "&Test Map";
 			this.itemtestmap.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// menuhelp
 			// 
 			this.menuhelp.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.itemhelprefmanual,
             this.itemhelpeditmode,
             this.seperatorhelpmanual,
             this.itemhelpabout});
 			this.menuhelp.Name = "menuhelp";
 			this.menuhelp.Size = new System.Drawing.Size(44, 20);
 			this.menuhelp.Text = "&Help";
 			// 
 			// itemhelprefmanual
 			// 
 			this.itemhelprefmanual.Image = global
 			this.itemhelprefmanual.Name = "itemhelprefmanual";
 			this.itemhelprefmanual.Size = new System.Drawing.Size(203, 22);
 			this.itemhelprefmanual.Text = "Reference &Manual";
 			this.itemhelprefmanual.Click += new System.EventHandler(this.itemhelprefmanual_Click);
 			// 
 			// itemhelpeditmode
 			// 
 			this.itemhelpeditmode.Image = global
 			this.itemhelpeditmode.Name = "itemhelpeditmode";
 			this.itemhelpeditmode.Size = new System.Drawing.Size(203, 22);
 			this.itemhelpeditmode.Text = "About this &Editing Mode";
 			this.itemhelpeditmode.Click += new System.EventHandler(this.itemhelpeditmode_Click);
 			// 
 			// seperatorhelpmanual
 			// 
 			this.seperatorhelpmanual.Margin = new System.Windows.Forms.Padding(0, 3, 0, 3);
 			this.seperatorhelpmanual.Name = "seperatorhelpmanual";
 			this.seperatorhelpmanual.Size = new System.Drawing.Size(200, 6);
 			// 
 			// itemhelpabout
 			// 
 			this.itemhelpabout.Name = "itemhelpabout";
 			this.itemhelpabout.Size = new System.Drawing.Size(203, 22);
 			this.itemhelpabout.Text = "&About Doom Builder...";
 			this.itemhelpabout.Click += new System.EventHandler(this.itemhelpabout_Click);
 			// 
 			// toolbar
 			// 
 			this.toolbar.AutoSize = false;
 			this.toolbar.GripStyle = System.Windows.Forms.ToolStripGripStyle.Hidden;
 			this.toolbar.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.buttonnewmap,
             this.buttonopenmap,
             this.buttonsavemap,
             this.seperatorfile,
             this.buttonscripteditor,
             this.seperatorscript,
             this.buttonundo,
             this.buttonredo,
             this.seperatorundo,
             this.buttoncut,
             this.buttoncopy,
             this.buttonpaste,
             this.seperatorcopypaste,
             this.buttoninsertprefabfile,
             this.buttoninsertpreviousprefab,
             this.seperatorprefabs,
             this.seperatormodes,
             this.buttonthingsfilter,
             this.thingfilters,
             this.buttonviewnormal,
             this.buttonviewbrightness,
             this.buttonviewfloors,
             this.buttonviewceilings,
             this.seperatorviews,
             this.buttonsnaptogrid,
             this.buttonautomerge,
             this.seperatorgeometry,
             this.buttontest,
             this.seperatortesting});
 			this.toolbar.Location = new System.Drawing.Point(0, 24);
 			this.toolbar.Name = "toolbar";
 			this.toolbar.Size = new System.Drawing.Size(1012, 25);
 			this.toolbar.TabIndex = 1;
 			// 
 			// buttonnewmap
 			// 
 			this.buttonnewmap.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonnewmap.Image = global
 			this.buttonnewmap.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonnewmap.Margin = new System.Windows.Forms.Padding(6, 1, 0, 2);
 			this.buttonnewmap.Name = "buttonnewmap";
 			this.buttonnewmap.Size = new System.Drawing.Size(23, 22);
 			this.buttonnewmap.Tag = "builder_newmap";
 			this.buttonnewmap.Text = "New Map";
 			this.buttonnewmap.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonopenmap
 			// 
 			this.buttonopenmap.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonopenmap.Image = global
 			this.buttonopenmap.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonopenmap.Name = "buttonopenmap";
 			this.buttonopenmap.Size = new System.Drawing.Size(23, 22);
 			this.buttonopenmap.Tag = "builder_openmap";
 			this.buttonopenmap.Text = "Open Map";
 			this.buttonopenmap.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonsavemap
 			// 
 			this.buttonsavemap.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonsavemap.Image = global
 			this.buttonsavemap.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonsavemap.Name = "buttonsavemap";
 			this.buttonsavemap.Size = new System.Drawing.Size(23, 22);
 			this.buttonsavemap.Tag = "builder_savemap";
 			this.buttonsavemap.Text = "Save Map";
 			this.buttonsavemap.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonscripteditor
 			// 
 			this.buttonscripteditor.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonscripteditor.Image = global
 			this.buttonscripteditor.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonscripteditor.Name = "buttonscripteditor";
 			this.buttonscripteditor.Size = new System.Drawing.Size(23, 22);
 			this.buttonscripteditor.Tag = "builder_openscripteditor";
 			this.buttonscripteditor.Text = "Open Script Editor";
 			this.buttonscripteditor.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonundo
 			// 
 			this.buttonundo.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonundo.Image = global
 			this.buttonundo.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonundo.Name = "buttonundo";
 			this.buttonundo.Size = new System.Drawing.Size(23, 22);
 			this.buttonundo.Tag = "builder_undo";
 			this.buttonundo.Text = "Undo";
 			this.buttonundo.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonredo
 			// 
 			this.buttonredo.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonredo.Image = global
 			this.buttonredo.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonredo.Name = "buttonredo";
 			this.buttonredo.Size = new System.Drawing.Size(23, 22);
 			this.buttonredo.Tag = "builder_redo";
 			this.buttonredo.Text = "Redo";
 			this.buttonredo.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttoncut
 			// 
 			this.buttoncut.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttoncut.Image = global
 			this.buttoncut.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttoncut.Name = "buttoncut";
 			this.buttoncut.Size = new System.Drawing.Size(23, 22);
 			this.buttoncut.Tag = "builder_cutselection";
 			this.buttoncut.Text = "Cut Selection";
 			this.buttoncut.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttoncopy
 			// 
 			this.buttoncopy.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttoncopy.Image = global
 			this.buttoncopy.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttoncopy.Name = "buttoncopy";
 			this.buttoncopy.Size = new System.Drawing.Size(23, 22);
 			this.buttoncopy.Tag = "builder_copyselection";
 			this.buttoncopy.Text = "Copy Selection";
 			this.buttoncopy.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonpaste
 			// 
 			this.buttonpaste.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonpaste.Image = global
 			this.buttonpaste.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonpaste.Name = "buttonpaste";
 			this.buttonpaste.Size = new System.Drawing.Size(23, 22);
 			this.buttonpaste.Tag = "builder_pasteselection";
 			this.buttonpaste.Text = "Paste Selection";
 			this.buttonpaste.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttoninsertprefabfile
 			// 
 			this.buttoninsertprefabfile.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttoninsertprefabfile.Image = global
 			this.buttoninsertprefabfile.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttoninsertprefabfile.Name = "buttoninsertprefabfile";
 			this.buttoninsertprefabfile.Size = new System.Drawing.Size(23, 22);
 			this.buttoninsertprefabfile.Tag = "builder_insertprefabfile";
 			this.buttoninsertprefabfile.Text = "Insert Prefab from File";
 			this.buttoninsertprefabfile.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttoninsertpreviousprefab
 			// 
 			this.buttoninsertpreviousprefab.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttoninsertpreviousprefab.Image = global
 			this.buttoninsertpreviousprefab.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttoninsertpreviousprefab.Name = "buttoninsertpreviousprefab";
 			this.buttoninsertpreviousprefab.Size = new System.Drawing.Size(23, 22);
 			this.buttoninsertpreviousprefab.Tag = "builder_insertpreviousprefab";
 			this.buttoninsertpreviousprefab.Text = "Insert Previous Prefab";
 			this.buttoninsertpreviousprefab.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonthingsfilter
 			// 
 			this.buttonthingsfilter.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonthingsfilter.Enabled = false;
 			this.buttonthingsfilter.Image = global
 			this.buttonthingsfilter.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonthingsfilter.Name = "buttonthingsfilter";
 			this.buttonthingsfilter.Size = new System.Drawing.Size(23, 22);
 			this.buttonthingsfilter.Tag = "builder_thingsfilterssetup";
 			this.buttonthingsfilter.Text = "Configure Things Filters";
 			this.buttonthingsfilter.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// thingfilters
 			// 
 			this.thingfilters.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.thingfilters.Enabled = false;
 			this.thingfilters.Items.AddRange(new object[] {
             "(none)",
             "(custom)",
             "Easy skill items only",
             "Medium skill items only",
             "Hard skill items only"});
 			this.thingfilters.Margin = new System.Windows.Forms.Padding(1, 0, 6, 0);
 			this.thingfilters.Name = "thingfilters";
 			this.thingfilters.Size = new System.Drawing.Size(130, 25);
 			this.thingfilters.ToolTipText = "Things Filter";
 			this.thingfilters.SelectedIndexChanged += new System.EventHandler(this.thingfilters_SelectedIndexChanged);
 			this.thingfilters.DropDownClosed += new System.EventHandler(this.LoseFocus);
 			// 
 			// buttonviewnormal
 			// 
 			this.buttonviewnormal.CheckOnClick = true;
 			this.buttonviewnormal.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonviewnormal.Image = global
 			this.buttonviewnormal.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonviewnormal.Name = "buttonviewnormal";
 			this.buttonviewnormal.Size = new System.Drawing.Size(23, 22);
 			this.buttonviewnormal.Tag = "builder_viewmodenormal";
 			this.buttonviewnormal.Text = "View Wireframe";
 			this.buttonviewnormal.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonviewbrightness
 			// 
 			this.buttonviewbrightness.CheckOnClick = true;
 			this.buttonviewbrightness.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonviewbrightness.Image = global
 			this.buttonviewbrightness.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonviewbrightness.Name = "buttonviewbrightness";
 			this.buttonviewbrightness.Size = new System.Drawing.Size(23, 22);
 			this.buttonviewbrightness.Tag = "builder_viewmodebrightness";
 			this.buttonviewbrightness.Text = "View Brightness Levels";
 			this.buttonviewbrightness.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonviewfloors
 			// 
 			this.buttonviewfloors.CheckOnClick = true;
 			this.buttonviewfloors.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonviewfloors.Image = global
 			this.buttonviewfloors.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonviewfloors.Name = "buttonviewfloors";
 			this.buttonviewfloors.Size = new System.Drawing.Size(23, 22);
 			this.buttonviewfloors.Tag = "builder_viewmodefloors";
 			this.buttonviewfloors.Text = "View Floor Textures";
 			this.buttonviewfloors.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonviewceilings
 			// 
 			this.buttonviewceilings.CheckOnClick = true;
 			this.buttonviewceilings.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonviewceilings.Image = global
 			this.buttonviewceilings.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonviewceilings.Name = "buttonviewceilings";
 			this.buttonviewceilings.Size = new System.Drawing.Size(23, 22);
 			this.buttonviewceilings.Tag = "builder_viewmodeceilings";
 			this.buttonviewceilings.Text = "View Ceiling Textures";
 			this.buttonviewceilings.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatorviews
 			// 
 			this.seperatorviews.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.seperatorviews.Name = "seperatorviews";
 			this.seperatorviews.Size = new System.Drawing.Size(6, 25);
 			// 
 			// buttonsnaptogrid
 			// 
 			this.buttonsnaptogrid.Checked = true;
 			this.buttonsnaptogrid.CheckState = System.Windows.Forms.CheckState.Checked;
 			this.buttonsnaptogrid.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonsnaptogrid.Image = global
 			this.buttonsnaptogrid.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonsnaptogrid.Name = "buttonsnaptogrid";
 			this.buttonsnaptogrid.Size = new System.Drawing.Size(23, 22);
 			this.buttonsnaptogrid.Tag = "builder_togglesnap";
 			this.buttonsnaptogrid.Text = "Snap to Grid";
 			this.buttonsnaptogrid.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// buttonautomerge
 			// 
 			this.buttonautomerge.Checked = true;
 			this.buttonautomerge.CheckState = System.Windows.Forms.CheckState.Checked;
 			this.buttonautomerge.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonautomerge.Image = global
 			this.buttonautomerge.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttonautomerge.Name = "buttonautomerge";
 			this.buttonautomerge.Size = new System.Drawing.Size(23, 22);
 			this.buttonautomerge.Tag = "builder_toggleautomerge";
 			this.buttonautomerge.Text = "Merge Geometry";
 			this.buttonautomerge.Click += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatorgeometry
 			// 
 			this.seperatorgeometry.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.seperatorgeometry.Name = "seperatorgeometry";
 			this.seperatorgeometry.Size = new System.Drawing.Size(6, 25);
 			// 
 			// buttontest
 			// 
 			this.buttontest.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttontest.Image = global
 			this.buttontest.ImageScaling = System.Windows.Forms.ToolStripItemImageScaling.None;
 			this.buttontest.ImageTransparentColor = System.Drawing.Color.Magenta;
 			this.buttontest.Name = "buttontest";
 			this.buttontest.Size = new System.Drawing.Size(32, 22);
 			this.buttontest.Tag = "builder_testmap";
 			this.buttontest.Text = "Test Map";
 			this.buttontest.ButtonClick += new System.EventHandler(this.InvokeTaggedAction);
 			// 
 			// seperatortesting
 			// 
 			this.seperatortesting.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);
 			this.seperatortesting.Name = "seperatortesting";
 			this.seperatortesting.Size = new System.Drawing.Size(6, 25);
 			// 
 			// statusbar
 			// 
 			this.statusbar.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.statusbar.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.statuslabel,
             this.configlabel,
             toolStripSeparator12,
             this.gridlabel,
             this.buttongrid,
             toolStripSeparator1,
             this.zoomlabel,
             this.buttonzoom,
             toolStripSeparator9,
             this.xposlabel,
             this.poscommalabel,
             this.yposlabel});
 			this.statusbar.Location = new System.Drawing.Point(0, 670);
 			this.statusbar.Name = "statusbar";
 			this.statusbar.ShowItemToolTips = true;
 			this.statusbar.Size = new System.Drawing.Size(1012, 23);
 			this.statusbar.TabIndex = 2;
 			// 
 			// statuslabel
 			// 
 			this.statuslabel.Image = global
 			this.statuslabel.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft;
 			this.statuslabel.ImageScaling = System.Windows.Forms.ToolStripItemImageScaling.None;
 			this.statuslabel.Name = "statuslabel";
 			this.statuslabel.Size = new System.Drawing.Size(396, 18);
 			this.statuslabel.Spring = true;
 			this.statuslabel.Text = "Initializing user interface...";
 			this.statuslabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
 			// 
 			// configlabel
 			// 
 			this.configlabel.AutoSize = false;
 			this.configlabel.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.configlabel.Name = "configlabel";
 			this.configlabel.Size = new System.Drawing.Size(280, 18);
 			this.configlabel.Text = "ZDoom (Doom in Hexen Format)";
 			this.configlabel.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
 			this.configlabel.ToolTipText = "Current Game Configuration";
 			// 
 			// gridlabel
 			// 
 			this.gridlabel.AutoSize = false;
 			this.gridlabel.AutoToolTip = true;
 			this.gridlabel.Name = "gridlabel";
 			this.gridlabel.Size = new System.Drawing.Size(62, 18);
 			this.gridlabel.Text = "32 mp";
 			this.gridlabel.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
 			this.gridlabel.TextImageRelation = System.Windows.Forms.TextImageRelation.Overlay;
 			this.gridlabel.ToolTipText = "Grid size";
 			// 
 			// buttongrid
 			// 
 			this.buttongrid.AutoToolTip = false;
 			this.buttongrid.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttongrid.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.itemgrid1024,
             this.itemgrid512,
             this.itemgrid256,
             this.itemgrid128,
             this.itemgrid64,
             this.itemgrid32,
             this.itemgrid16,
             this.itemgrid8,
             this.itemgrid4,
             toolStripMenuItem4,
             this.itemgridcustom});
 			this.buttongrid.Image = global
 			this.buttongrid.ImageScaling = System.Windows.Forms.ToolStripItemImageScaling.None;
 			this.buttongrid.ImageTransparentColor = System.Drawing.Color.Transparent;
 			this.buttongrid.Name = "buttongrid";
 			this.buttongrid.ShowDropDownArrow = false;
 			this.buttongrid.Size = new System.Drawing.Size(29, 21);
 			this.buttongrid.Text = "Grid";
 			// 
 			// itemgrid1024
 			// 
 			this.itemgrid1024.Name = "itemgrid1024";
 			this.itemgrid1024.Size = new System.Drawing.Size(153, 22);
 			this.itemgrid1024.Tag = "1024";
 			this.itemgrid1024.Text = "1024 mp";
 			this.itemgrid1024.Click += new System.EventHandler(this.itemgridsize_Click);
 			// 
 			// itemgrid512
 			// 
 			this.itemgrid512.Name = "itemgrid512";
 			this.itemgrid512.Size = new System.Drawing.Size(153, 22);
 			this.itemgrid512.Tag = "512";
 			this.itemgrid512.Text = "512 mp";
 			this.itemgrid512.Click += new System.EventHandler(this.itemgridsize_Click);
 			// 
 			// itemgrid256
 			// 
 			this.itemgrid256.Name = "itemgrid256";
 			this.itemgrid256.Size = new System.Drawing.Size(153, 22);
 			this.itemgrid256.Tag = "256";
 			this.itemgrid256.Text = "256 mp";
 			this.itemgrid256.Click += new System.EventHandler(this.itemgridsize_Click);
 			// 
 			// itemgrid128
 			// 
 			this.itemgrid128.Name = "itemgrid128";
 			this.itemgrid128.Size = new System.Drawing.Size(153, 22);
 			this.itemgrid128.Tag = "128";
 			this.itemgrid128.Text = "128 mp";
 			this.itemgrid128.Click += new System.EventHandler(this.itemgridsize_Click);
 			// 
 			// itemgrid64
 			// 
 			this.itemgrid64.Name = "itemgrid64";
 			this.itemgrid64.Size = new System.Drawing.Size(153, 22);
 			this.itemgrid64.Tag = "64";
 			this.itemgrid64.Text = "64 mp";
 			this.itemgrid64.Click += new System.EventHandler(this.itemgridsize_Click);
 			// 
 			// itemgrid32
 			// 
 			this.itemgrid32.Name = "itemgrid32";
 			this.itemgrid32.Size = new System.Drawing.Size(153, 22);
 			this.itemgrid32.Tag = "32";
 			this.itemgrid32.Text = "32 mp";
 			this.itemgrid32.Click += new System.EventHandler(this.itemgridsize_Click);
 			// 
 			// itemgrid16
 			// 
 			this.itemgrid16.Name = "itemgrid16";
 			this.itemgrid16.Size = new System.Drawing.Size(153, 22);
 			this.itemgrid16.Tag = "16";
 			this.itemgrid16.Text = "16 mp";
 			this.itemgrid16.Click += new System.EventHandler(this.itemgridsize_Click);
 			// 
 			// itemgrid8
 			// 
 			this.itemgrid8.Name = "itemgrid8";
 			this.itemgrid8.Size = new System.Drawing.Size(153, 22);
 			this.itemgrid8.Tag = "8";
 			this.itemgrid8.Text = "8 mp";
 			this.itemgrid8.Click += new System.EventHandler(this.itemgridsize_Click);
 			// 
 			// itemgrid4
 			// 
 			this.itemgrid4.Name = "itemgrid4";
 			this.itemgrid4.Size = new System.Drawing.Size(153, 22);
 			this.itemgrid4.Tag = "4";
 			this.itemgrid4.Text = "4 mp";
 			this.itemgrid4.Click += new System.EventHandler(this.itemgridsize_Click);
 			// 
 			// itemgridcustom
 			// 
 			this.itemgridcustom.Name = "itemgridcustom";
 			this.itemgridcustom.Size = new System.Drawing.Size(153, 22);
 			this.itemgridcustom.Text = "Customize...";
 			this.itemgridcustom.Click += new System.EventHandler(this.itemgridcustom_Click);
 			// 
 			// zoomlabel
 			// 
 			this.zoomlabel.AutoSize = false;
 			this.zoomlabel.AutoToolTip = true;
 			this.zoomlabel.Name = "zoomlabel";
 			this.zoomlabel.Size = new System.Drawing.Size(54, 18);
 			this.zoomlabel.Text = "50%";
 			this.zoomlabel.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
 			this.zoomlabel.TextImageRelation = System.Windows.Forms.TextImageRelation.Overlay;
 			this.zoomlabel.ToolTipText = "Zoom level";
 			// 
 			// buttonzoom
 			// 
 			this.buttonzoom.AutoToolTip = false;
 			this.buttonzoom.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
 			this.buttonzoom.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.itemzoom200,
             this.itemzoom100,
             this.itemzoom50,
             this.itemzoom25,
             this.itemzoom10,
             this.itemzoom5,
             toolStripSeparator2,
             this.itemzoomfittoscreen});
 			this.buttonzoom.Image = global
 			this.buttonzoom.ImageScaling = System.Windows.Forms.ToolStripItemImageScaling.None;
 			this.buttonzoom.ImageTransparentColor = System.Drawing.Color.Transparent;
 			this.buttonzoom.Name = "buttonzoom";
 			this.buttonzoom.ShowDropDownArrow = false;
 			this.buttonzoom.Size = new System.Drawing.Size(29, 21);
 			this.buttonzoom.Text = "Zoom";
 			// 
 			// itemzoom200
 			// 
 			this.itemzoom200.Name = "itemzoom200";
 			this.itemzoom200.Size = new System.Drawing.Size(156, 22);
 			this.itemzoom200.Tag = "200";
 			this.itemzoom200.Text = "200%";
 			this.itemzoom200.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// itemzoom100
 			// 
 			this.itemzoom100.Name = "itemzoom100";
 			this.itemzoom100.Size = new System.Drawing.Size(156, 22);
 			this.itemzoom100.Tag = "100";
 			this.itemzoom100.Text = "100%";
 			this.itemzoom100.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// itemzoom50
 			// 
 			this.itemzoom50.Name = "itemzoom50";
 			this.itemzoom50.Size = new System.Drawing.Size(156, 22);
 			this.itemzoom50.Tag = "50";
 			this.itemzoom50.Text = "50%";
 			this.itemzoom50.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// itemzoom25
 			// 
 			this.itemzoom25.Name = "itemzoom25";
 			this.itemzoom25.Size = new System.Drawing.Size(156, 22);
 			this.itemzoom25.Tag = "25";
 			this.itemzoom25.Text = "25%";
 			this.itemzoom25.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// itemzoom10
 			// 
 			this.itemzoom10.Name = "itemzoom10";
 			this.itemzoom10.Size = new System.Drawing.Size(156, 22);
 			this.itemzoom10.Tag = "10";
 			this.itemzoom10.Text = "10%";
 			this.itemzoom10.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// itemzoom5
 			// 
 			this.itemzoom5.Name = "itemzoom5";
 			this.itemzoom5.Size = new System.Drawing.Size(156, 22);
 			this.itemzoom5.Tag = "5";
 			this.itemzoom5.Text = "5%";
 			this.itemzoom5.Click += new System.EventHandler(this.itemzoomto_Click);
 			// 
 			// itemzoomfittoscreen
 			// 
 			this.itemzoomfittoscreen.Name = "itemzoomfittoscreen";
 			this.itemzoomfittoscreen.Size = new System.Drawing.Size(156, 22);
 			this.itemzoomfittoscreen.Text = "Fit to screen";
 			this.itemzoomfittoscreen.Click += new System.EventHandler(this.itemzoomfittoscreen_Click);
 			// 
 			// xposlabel
 			// 
 			this.xposlabel.AutoSize = false;
 			this.xposlabel.Name = "xposlabel";
 			this.xposlabel.Size = new System.Drawing.Size(50, 18);
 			this.xposlabel.Text = "0";
 			this.xposlabel.ToolTipText = "Current X, Y coordinates on map";
 			// 
 			// yposlabel
 			// 
 			this.yposlabel.AutoSize = false;
 			this.yposlabel.Name = "yposlabel";
 			this.yposlabel.Size = new System.Drawing.Size(50, 18);
 			this.yposlabel.Text = "0";
 			this.yposlabel.ToolTipText = "Current X, Y coordinates on map";
 			// 
 			// panelinfo
 			// 
 			this.panelinfo.Controls.Add(this.heightpanel1);
 			this.panelinfo.Controls.Add(this.vertexinfo);
 			this.panelinfo.Controls.Add(this.labelcollapsedinfo);
 			this.panelinfo.Controls.Add(this.buttontoggleinfo);
 			this.panelinfo.Controls.Add(this.modename);
 			this.panelinfo.Controls.Add(this.linedefinfo);
 			this.panelinfo.Controls.Add(this.thinginfo);
 			this.panelinfo.Controls.Add(this.sectorinfo);
 			this.panelinfo.Dock = System.Windows.Forms.DockStyle.Bottom;
 			this.panelinfo.Location = new System.Drawing.Point(26, 564);
 			this.panelinfo.Name = "panelinfo";
 			this.panelinfo.Size = new System.Drawing.Size(986, 106);
 			this.panelinfo.TabIndex = 4;
 			// 
 			// heightpanel1
 			// 
 			this.heightpanel1.BackColor = System.Drawing.Color.Navy;
 			this.heightpanel1.ForeColor = System.Drawing.SystemColors.ControlText;
 			this.heightpanel1.Location = new System.Drawing.Point(0, 0);
 			this.heightpanel1.Name = "heightpanel1";
 			this.heightpanel1.Size = new System.Drawing.Size(29, 106);
 			this.heightpanel1.TabIndex = 7;
 			this.heightpanel1.Visible = false;
 			// 
 			// vertexinfo
 			// 
 			this.vertexinfo.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.vertexinfo.Location = new System.Drawing.Point(3, 3);
 			this.vertexinfo.MaximumSize = new System.Drawing.Size(10000, 100);
 			this.vertexinfo.MinimumSize = new System.Drawing.Size(100, 100);
 			this.vertexinfo.Name = "vertexinfo";
 			this.vertexinfo.Size = new System.Drawing.Size(310, 100);
 			this.vertexinfo.TabIndex = 1;
 			this.vertexinfo.Visible = false;
 			// 
 			// labelcollapsedinfo
 			// 
 			this.labelcollapsedinfo.AutoSize = true;
 			this.labelcollapsedinfo.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.labelcollapsedinfo.Location = new System.Drawing.Point(2, 2);
 			this.labelcollapsedinfo.Name = "labelcollapsedinfo";
 			this.labelcollapsedinfo.Size = new System.Drawing.Size(137, 13);
 			this.labelcollapsedinfo.TabIndex = 6;
 			this.labelcollapsedinfo.Text = "Collapsed Descriptions";
 			this.labelcollapsedinfo.Visible = false;
 			// 
 			// buttontoggleinfo
 			// 
 			this.buttontoggleinfo.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
 			this.buttontoggleinfo.FlatStyle = System.Windows.Forms.FlatStyle.Popup;
 			this.buttontoggleinfo.Font = new System.Drawing.Font("Marlett", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(2)));
 			this.buttontoggleinfo.Location = new System.Drawing.Point(962, 1);
 			this.buttontoggleinfo.Name = "buttontoggleinfo";
 			this.buttontoggleinfo.Size = new System.Drawing.Size(22, 19);
 			this.buttontoggleinfo.TabIndex = 5;
 			this.buttontoggleinfo.TabStop = false;
 			this.buttontoggleinfo.Tag = "builder_toggleinfopanel";
 			this.buttontoggleinfo.Text = "6";
 			this.buttontoggleinfo.UseVisualStyleBackColor = true;
 			this.buttontoggleinfo.Click += new System.EventHandler(this.InvokeTaggedAction);
 			this.buttontoggleinfo.MouseUp += new System.Windows.Forms.MouseEventHandler(this.buttontoggleinfo_MouseUp);
 			// 
 			// modename
 			// 
 			this.modename.AutoSize = true;
 			this.modename.Font = new System.Drawing.Font("Verdana", 36F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.modename.ForeColor = System.Drawing.SystemColors.GrayText;
 			this.modename.Location = new System.Drawing.Point(12, 20);
 			this.modename.Name = "modename";
 			this.modename.Size = new System.Drawing.Size(244, 59);
 			this.modename.TabIndex = 4;
 			this.modename.Text = "Vertices";
 			this.modename.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
 			this.modename.UseMnemonic = false;
 			this.modename.Visible = false;
 			// 
 			// linedefinfo
 			// 
 			this.linedefinfo.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.linedefinfo.Location = new System.Drawing.Point(3, 3);
 			this.linedefinfo.MaximumSize = new System.Drawing.Size(10000, 100);
 			this.linedefinfo.MinimumSize = new System.Drawing.Size(100, 100);
 			this.linedefinfo.Name = "linedefinfo";
 			this.linedefinfo.Size = new System.Drawing.Size(1039, 100);
 			this.linedefinfo.TabIndex = 0;
 			this.linedefinfo.Visible = false;
 			// 
 			// thinginfo
 			// 
 			this.thinginfo.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.thinginfo.Location = new System.Drawing.Point(3, 3);
 			this.thinginfo.MaximumSize = new System.Drawing.Size(10000, 100);
 			this.thinginfo.MinimumSize = new System.Drawing.Size(100, 100);
 			this.thinginfo.Name = "thinginfo";
 			this.thinginfo.Size = new System.Drawing.Size(639, 100);
 			this.thinginfo.TabIndex = 3;
 			this.thinginfo.Visible = false;
 			// 
 			// sectorinfo
 			// 
 			this.sectorinfo.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.sectorinfo.Location = new System.Drawing.Point(3, 3);
 			this.sectorinfo.MaximumSize = new System.Drawing.Size(10000, 100);
 			this.sectorinfo.MinimumSize = new System.Drawing.Size(100, 100);
 			this.sectorinfo.Name = "sectorinfo";
 			this.sectorinfo.Size = new System.Drawing.Size(522, 100);
 			this.sectorinfo.TabIndex = 2;
 			this.sectorinfo.Visible = false;
 			// 
 			// redrawtimer
 			// 
 			this.redrawtimer.Interval = 1;
 			this.redrawtimer.Tick += new System.EventHandler(this.redrawtimer_Tick);
 			// 
 			// display
 			// 
 			this.display.BackColor = System.Drawing.SystemColors.AppWorkspace;
 			this.display.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Center;
 			this.display.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.display.CausesValidation = false;
 			this.display.Location = new System.Drawing.Point(373, 141);
 			this.display.Name = "display";
 			this.display.Size = new System.Drawing.Size(542, 307);
 			this.display.TabIndex = 5;
 			this.display.MouseLeave += new System.EventHandler(this.display_MouseLeave);
 			this.display.Paint += new System.Windows.Forms.PaintEventHandler(this.display_Paint);
 			this.display.PreviewKeyDown += new System.Windows.Forms.PreviewKeyDownEventHandler(this.display_PreviewKeyDown);
 			this.display.MouseMove += new System.Windows.Forms.MouseEventHandler(this.display_MouseMove);
 			this.display.MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(this.display_MouseDoubleClick);
 			this.display.MouseClick += new System.Windows.Forms.MouseEventHandler(this.display_MouseClick);
 			this.display.MouseDown += new System.Windows.Forms.MouseEventHandler(this.display_MouseDown);
 			this.display.Resize += new System.EventHandler(this.display_Resize);
 			this.display.MouseUp += new System.Windows.Forms.MouseEventHandler(this.display_MouseUp);
 			this.display.MouseEnter += new System.EventHandler(this.display_MouseEnter);
 			// 
 			// processor
 			// 
 			this.processor.Interval = 10;
 			this.processor.Tick += new System.EventHandler(this.processor_Tick);
 			// 
 			// statusflasher
 			// 
 			this.statusflasher.Tick += new System.EventHandler(this.statusflasher_Tick);
 			// 
 			// statusresetter
 			// 
 			this.statusresetter.Tick += new System.EventHandler(this.statusresetter_Tick);
 			// 
 			// dockersspace
 			// 
 			this.dockersspace.Dock = System.Windows.Forms.DockStyle.Left;
 			this.dockersspace.Location = new System.Drawing.Point(0, 49);
 			this.dockersspace.Name = "dockersspace";
 			this.dockersspace.Size = new System.Drawing.Size(26, 621);
 			this.dockersspace.TabIndex = 6;
 			// 
 			// dockerspanel
 			// 
 			this.dockerspanel.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.dockerspanel.Location = new System.Drawing.Point(62, 67);
 			this.dockerspanel.Name = "dockerspanel";
 			this.dockerspanel.Size = new System.Drawing.Size(236, 467);
 			this.dockerspanel.TabIndex = 7;
 			this.dockerspanel.TabStop = false;
 			this.dockerspanel.UserResize += new System.EventHandler(this.dockerspanel_UserResize);
 			this.dockerspanel.Collapsed += new System.EventHandler(this.LoseFocus);
 			this.dockerspanel.MouseContainerEnter += new System.EventHandler(this.dockerspanel_MouseContainerEnter);
 			// 
 			// dockerscollapser
 			// 
 			this.dockerscollapser.Interval = 200;
 			this.dockerscollapser.Tick += new System.EventHandler(this.dockerscollapser_Tick);
 			// 
 			// MainForm
 			// 
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.ClientSize = new System.Drawing.Size(1012, 693);
 			this.Controls.Add(this.dockerspanel);
 			this.Controls.Add(this.display);
 			this.Controls.Add(this.panelinfo);
 			this.Controls.Add(this.dockersspace);
 			this.Controls.Add(this.statusbar);
 			this.Controls.Add(this.toolbar);
 			this.Controls.Add(this.menumain);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
 			this.KeyPreview = true;
 			this.MainMenuStrip = this.menumain;
 			this.Name = "MainForm";
 			this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
 			this.Text = "Doom Builder";
 			this.Deactivate += new System.EventHandler(this.MainForm_Deactivate);
 			this.Load += new System.EventHandler(this.MainForm_Load);
 			this.Shown += new System.EventHandler(this.MainForm_Shown);
 			this.Activated += new System.EventHandler(this.MainForm_Activated);
 			this.KeyUp += new System.Windows.Forms.KeyEventHandler(this.MainForm_KeyUp);
 			this.Move += new System.EventHandler(this.MainForm_Move);
 			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.MainForm_FormClosing);
 			this.Resize += new System.EventHandler(this.MainForm_Resize);
 			this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.MainForm_KeyDown);
 			this.ResizeEnd += new System.EventHandler(this.MainForm_ResizeEnd);
 			this.menumain.ResumeLayout(false);
 			this.menumain.PerformLayout();
 			this.toolbar.ResumeLayout(false);
 			this.toolbar.PerformLayout();
 			this.statusbar.ResumeLayout(false);
 			this.statusbar.PerformLayout();
 			this.panelinfo.ResumeLayout(false);
 			this.panelinfo.PerformLayout();
 			this.ResumeLayout(false);
 			this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\LinedefEditForm.Designer.cs" startline="22" endline="907">
<![CDATA[
 
 		#region Windows Form Designer generated code
 
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
 			System.Windows.Forms.Label label2;
 			System.Windows.Forms.Label taglabel;
 			System.Windows.Forms.Label label3;
 			System.Windows.Forms.Label label4;
 			System.Windows.Forms.Label label5;
 			System.Windows.Forms.Label label6;
 			System.Windows.Forms.Label label7;
 			System.Windows.Forms.Label label8;
 			System.Windows.Forms.Label label9;
 			System.Windows.Forms.Label label10;
 			System.Windows.Forms.Label label11;
 			System.Windows.Forms.Label label12;
 			System.Windows.Forms.Label activationlabel;
 			this.cancel = new System.Windows.Forms.Button();
 			this.apply = new System.Windows.Forms.Button();
 			this.actiongroup = new System.Windows.Forms.GroupBox();
 			this.argspanel = new System.Windows.Forms.Panel();
 			this.arg2 = new CodeImp.DoomBuilder.Controls.ArgumentBox();
 			this.arg1 = new CodeImp.DoomBuilder.Controls.ArgumentBox();
 			this.arg0 = new CodeImp.DoomBuilder.Controls.ArgumentBox();
 			this.arg3 = new CodeImp.DoomBuilder.Controls.ArgumentBox();
 			this.arg4 = new CodeImp.DoomBuilder.Controls.ArgumentBox();
 			this.arg1label = new System.Windows.Forms.Label();
 			this.arg0label = new System.Windows.Forms.Label();
 			this.arg3label = new System.Windows.Forms.Label();
 			this.arg2label = new System.Windows.Forms.Label();
 			this.arg4label = new System.Windows.Forms.Label();
 			this.hexenpanel = new System.Windows.Forms.Panel();
 			this.activation = new System.Windows.Forms.ComboBox();
 			this.action = new CodeImp.DoomBuilder.Controls.ActionSelectorControl();
 			this.browseaction = new System.Windows.Forms.Button();
 			this.udmfpanel = new System.Windows.Forms.Panel();
 			this.udmfactivates = new CodeImp.DoomBuilder.Controls.CheckboxArrayControl();
 			this.newtag = new System.Windows.Forms.Button();
 			this.settingsgroup = new System.Windows.Forms.GroupBox();
 			this.flags = new CodeImp.DoomBuilder.Controls.CheckboxArrayControl();
 			this.checkBox1 = new System.Windows.Forms.CheckBox();
 			this.tabs = new System.Windows.Forms.TabControl();
 			this.tabproperties = new System.Windows.Forms.TabPage();
 			this.idgroup = new System.Windows.Forms.GroupBox();
 			this.tag = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.tabsidedefs = new System.Windows.Forms.TabPage();
 			this.splitter = new System.Windows.Forms.SplitContainer();
 			this.frontside = new System.Windows.Forms.CheckBox();
 			this.frontgroup = new System.Windows.Forms.GroupBox();
 			this.frontoffsety = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.frontoffsetx = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.frontsector = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.customfrontbutton = new System.Windows.Forms.Button();
 			this.frontlow = new CodeImp.DoomBuilder.Controls.TextureSelectorControl();
 			this.frontmid = new CodeImp.DoomBuilder.Controls.TextureSelectorControl();
 			this.fronthigh = new CodeImp.DoomBuilder.Controls.TextureSelectorControl();
 			this.backside = new System.Windows.Forms.CheckBox();
 			this.backgroup = new System.Windows.Forms.GroupBox();
 			this.backoffsety = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.backoffsetx = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.backsector = new CodeImp.DoomBuilder.Controls.ButtonsNumericTextbox();
 			this.custombackbutton = new System.Windows.Forms.Button();
 			this.backlow = new CodeImp.DoomBuilder.Controls.TextureSelectorControl();
 			this.backmid = new CodeImp.DoomBuilder.Controls.TextureSelectorControl();
 			this.backhigh = new CodeImp.DoomBuilder.Controls.TextureSelectorControl();
 			this.tabcustom = new System.Windows.Forms.TabPage();
 			this.fieldslist = new CodeImp.DoomBuilder.Controls.FieldsEditorControl();
 			this.heightpanel1 = new System.Windows.Forms.Panel();
 			this.heightpanel2 = new System.Windows.Forms.Panel();
 			label2 = new System.Windows.Forms.Label();
 			taglabel = new System.Windows.Forms.Label();
 			label3 = new System.Windows.Forms.Label();
 			label4 = new System.Windows.Forms.Label();
 			label5 = new System.Windows.Forms.Label();
 			label6 = new System.Windows.Forms.Label();
 			label7 = new System.Windows.Forms.Label();
 			label8 = new System.Windows.Forms.Label();
 			label9 = new System.Windows.Forms.Label();
 			label10 = new System.Windows.Forms.Label();
 			label11 = new System.Windows.Forms.Label();
 			label12 = new System.Windows.Forms.Label();
 			activationlabel = new System.Windows.Forms.Label();
 			this.actiongroup.SuspendLayout();
 			this.argspanel.SuspendLayout();
 			this.hexenpanel.SuspendLayout();
 			this.udmfpanel.SuspendLayout();
 			this.settingsgroup.SuspendLayout();
 			this.tabs.SuspendLayout();
 			this.tabproperties.SuspendLayout();
 			this.idgroup.SuspendLayout();
 			this.tabsidedefs.SuspendLayout();
 			this.splitter.Panel1.SuspendLayout();
 			this.splitter.Panel2.SuspendLayout();
 			this.splitter.SuspendLayout();
 			this.frontgroup.SuspendLayout();
 			this.backgroup.SuspendLayout();
 			this.tabcustom.SuspendLayout();
 			this.SuspendLayout();
 			// 
 			// label2
 			// 
 			label2.AutoSize = true;
 			label2.Location = new System.Drawing.Point(15, 30);
 			label2.Name = "label2";
 			label2.Size = new System.Drawing.Size(41, 14);
 			label2.TabIndex = 9;
 			label2.Text = "Action
 			// 
 			// taglabel
 			// 
 			taglabel.AutoSize = true;
 			taglabel.Location = new System.Drawing.Point(28, 31);
 			taglabel.Name = "taglabel";
 			taglabel.Size = new System.Drawing.Size(28, 14);
 			taglabel.TabIndex = 6;
 			taglabel.Text = "Tag
 			// 
 			// label3
 			// 
 			label3.Location = new System.Drawing.Point(252, 18);
 			label3.Name = "label3";
 			label3.Size = new System.Drawing.Size(83, 16);
 			label3.TabIndex = 3;
 			label3.Text = "Upper";
 			label3.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// label4
 			// 
 			label4.Location = new System.Drawing.Point(343, 18);
 			label4.Name = "label4";
 			label4.Size = new System.Drawing.Size(83, 16);
 			label4.TabIndex = 4;
 			label4.Text = "Middle";
 			label4.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// label5
 			// 
 			label5.Location = new System.Drawing.Point(434, 18);
 			label5.Name = "label5";
 			label5.Size = new System.Drawing.Size(83, 16);
 			label5.TabIndex = 5;
 			label5.Text = "Lower";
 			label5.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// label6
 			// 
 			label6.AutoSize = true;
 			label6.Location = new System.Drawing.Point(16, 79);
 			label6.Name = "label6";
 			label6.Size = new System.Drawing.Size(81, 14);
 			label6.TabIndex = 7;
 			label6.Text = "Texture Offset
 			// 
 			// label7
 			// 
 			label7.AutoSize = true;
 			label7.Location = new System.Drawing.Point(16, 79);
 			label7.Name = "label7";
 			label7.Size = new System.Drawing.Size(81, 14);
 			label7.TabIndex = 7;
 			label7.Text = "Texture Offset
 			// 
 			// label8
 			// 
 			label8.Location = new System.Drawing.Point(437, 18);
 			label8.Name = "label8";
 			label8.Size = new System.Drawing.Size(83, 16);
 			label8.TabIndex = 5;
 			label8.Text = "Lower";
 			label8.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// label9
 			// 
 			label9.Location = new System.Drawing.Point(346, 18);
 			label9.Name = "label9";
 			label9.Size = new System.Drawing.Size(83, 16);
 			label9.TabIndex = 4;
 			label9.Text = "Middle";
 			label9.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// label10
 			// 
 			label10.Location = new System.Drawing.Point(255, 18);
 			label10.Name = "label10";
 			label10.Size = new System.Drawing.Size(83, 16);
 			label10.TabIndex = 3;
 			label10.Text = "Upper";
 			label10.TextAlign = System.Drawing.ContentAlignment.TopCenter;
 			// 
 			// label11
 			// 
 			label11.AutoSize = true;
 			label11.Location = new System.Drawing.Point(26, 40);
 			label11.Name = "label11";
 			label11.Size = new System.Drawing.Size(71, 14);
 			label11.TabIndex = 13;
 			label11.Text = "Sector Index
 			// 
 			// label12
 			// 
 			label12.AutoSize = true;
 			label12.Location = new System.Drawing.Point(26, 40);
 			label12.Name = "label12";
 			label12.Size = new System.Drawing.Size(71, 14);
 			label12.TabIndex = 16;
 			label12.Text = "Sector Index
 			// 
 			// activationlabel
 			// 
 			activationlabel.AutoSize = true;
 			activationlabel.Location = new System.Drawing.Point(6, 17);
 			activationlabel.Name = "activationlabel";
 			activationlabel.Size = new System.Drawing.Size(44, 14);
 			activationlabel.TabIndex = 10;
 			activationlabel.Text = "Trigger
 			// 
 			// cancel
 			// 
 			this.cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
 			this.cancel.Location = new System.Drawing.Point(455, 592);
 			this.cancel.Name = "cancel";
 			this.cancel.Size = new System.Drawing.Size(112, 25);
 			this.cancel.TabIndex = 2;
 			this.cancel.Text = "Cancel";
 			this.cancel.UseVisualStyleBackColor = true;
 			this.cancel.Click += new System.EventHandler(this.cancel_Click);
 			// 
 			// apply
 			// 
 			this.apply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
 			this.apply.Location = new System.Drawing.Point(336, 592);
 			this.apply.Name = "apply";
 			this.apply.Size = new System.Drawing.Size(112, 25);
 			this.apply.TabIndex = 1;
 			this.apply.Text = "OK";
 			this.apply.UseVisualStyleBackColor = true;
 			this.apply.Click += new System.EventHandler(this.apply_Click);
 			// 
 			// actiongroup
 			// 
 			this.actiongroup.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.actiongroup.Controls.Add(this.argspanel);
 			this.actiongroup.Controls.Add(this.hexenpanel);
 			this.actiongroup.Controls.Add(label2);
 			this.actiongroup.Controls.Add(this.action);
 			this.actiongroup.Controls.Add(this.browseaction);
 			this.actiongroup.Controls.Add(this.udmfpanel);
 			this.actiongroup.Location = new System.Drawing.Point(8, 177);
 			this.actiongroup.Name = "actiongroup";
 			this.actiongroup.Size = new System.Drawing.Size(533, 281);
 			this.actiongroup.TabIndex = 1;
 			this.actiongroup.TabStop = false;
 			this.actiongroup.Text = " Action ";
 			// 
 			// argspanel
 			// 
 			this.argspanel.Controls.Add(this.arg2);
 			this.argspanel.Controls.Add(this.arg1);
 			this.argspanel.Controls.Add(this.arg0);
 			this.argspanel.Controls.Add(this.arg3);
 			this.argspanel.Controls.Add(this.arg4);
 			this.argspanel.Controls.Add(this.arg1label);
 			this.argspanel.Controls.Add(this.arg0label);
 			this.argspanel.Controls.Add(this.arg3label);
 			this.argspanel.Controls.Add(this.arg2label);
 			this.argspanel.Controls.Add(this.arg4label);
 			this.argspanel.Location = new System.Drawing.Point(6, 54);
 			this.argspanel.Name = "argspanel";
 			this.argspanel.Size = new System.Drawing.Size(521, 83);
 			this.argspanel.TabIndex = 2;
 			this.argspanel.Visible = false;
 			// 
 			// arg2
 			// 
 			this.arg2.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.arg2.Location = new System.Drawing.Point(123, 55);
 			this.arg2.Name = "arg2";
 			this.arg2.Size = new System.Drawing.Size(93, 24);
 			this.arg2.TabIndex = 2;
 			// 
 			// arg1
 			// 
 			this.arg1.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.arg1.Location = new System.Drawing.Point(123, 29);
 			this.arg1.Name = "arg1";
 			this.arg1.Size = new System.Drawing.Size(93, 24);
 			this.arg1.TabIndex = 1;
 			// 
 			// arg0
 			// 
 			this.arg0.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.arg0.Location = new System.Drawing.Point(123, 3);
 			this.arg0.Name = "arg0";
 			this.arg0.Size = new System.Drawing.Size(93, 24);
 			this.arg0.TabIndex = 0;
 			// 
 			// arg3
 			// 
 			this.arg3.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.arg3.Location = new System.Drawing.Point(364, 3);
 			this.arg3.Name = "arg3";
 			this.arg3.Size = new System.Drawing.Size(93, 24);
 			this.arg3.TabIndex = 3;
 			// 
 			// arg4
 			// 
 			this.arg4.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.arg4.Location = new System.Drawing.Point(364, 29);
 			this.arg4.Name = "arg4";
 			this.arg4.Size = new System.Drawing.Size(93, 24);
 			this.arg4.TabIndex = 4;
 			// 
 			// arg1label
 			// 
 			this.arg1label.Location = new System.Drawing.Point(-62, 34);
 			this.arg1label.Name = "arg1label";
 			this.arg1label.Size = new System.Drawing.Size(179, 14);
 			this.arg1label.TabIndex = 33;
 			this.arg1label.Text = "Argument 2
 			this.arg1label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.arg1label.UseMnemonic = false;
 			// 
 			// arg0label
 			// 
 			this.arg0label.Location = new System.Drawing.Point(-62, 8);
 			this.arg0label.Name = "arg0label";
 			this.arg0label.Size = new System.Drawing.Size(179, 14);
 			this.arg0label.TabIndex = 32;
 			this.arg0label.Text = "Argument 1
 			this.arg0label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.arg0label.UseMnemonic = false;
 			// 
 			// arg3label
 			// 
 			this.arg3label.Location = new System.Drawing.Point(179, 8);
 			this.arg3label.Name = "arg3label";
 			this.arg3label.Size = new System.Drawing.Size(179, 14);
 			this.arg3label.TabIndex = 36;
 			this.arg3label.Text = "Argument 4
 			this.arg3label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.arg3label.UseMnemonic = false;
 			// 
 			// arg2label
 			// 
 			this.arg2label.Location = new System.Drawing.Point(-62, 60);
 			this.arg2label.Name = "arg2label";
 			this.arg2label.Size = new System.Drawing.Size(179, 14);
 			this.arg2label.TabIndex = 35;
 			this.arg2label.Text = "Argument 3
 			this.arg2label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.arg2label.UseMnemonic = false;
 			// 
 			// arg4label
 			// 
 			this.arg4label.Location = new System.Drawing.Point(179, 34);
 			this.arg4label.Name = "arg4label";
 			this.arg4label.Size = new System.Drawing.Size(179, 14);
 			this.arg4label.TabIndex = 34;
 			this.arg4label.Text = "Argument 5
 			this.arg4label.TextAlign = System.Drawing.ContentAlignment.TopRight;
 			this.arg4label.UseMnemonic = false;
 			// 
 			// hexenpanel
 			// 
 			this.hexenpanel.Controls.Add(this.activation);
 			this.hexenpanel.Controls.Add(activationlabel);
 			this.hexenpanel.Location = new System.Drawing.Point(6, 139);
 			this.hexenpanel.Name = "hexenpanel";
 			this.hexenpanel.Size = new System.Drawing.Size(521, 49);
 			this.hexenpanel.TabIndex = 3;
 			this.hexenpanel.Visible = false;
 			// 
 			// activation
 			// 
 			this.activation.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
 			this.activation.FormattingEnabled = true;
 			this.activation.Location = new System.Drawing.Point(56, 13);
 			this.activation.Name = "activation";
 			this.activation.Size = new System.Drawing.Size(437, 22);
 			this.activation.TabIndex = 0;
 			// 
 			// action
 			// 
 			this.action.BackColor = System.Drawing.Color.Transparent;
 			this.action.Cursor = System.Windows.Forms.Cursors.Default;
 			this.action.Empty = false;
 			this.action.GeneralizedCategories = null;
 			this.action.Location = new System.Drawing.Point(62, 27);
 			this.action.Name = "action";
 			this.action.Size = new System.Drawing.Size(401, 21);
 			this.action.TabIndex = 0;
 			this.action.Value = 402;
 			this.action.ValueChanges += new System.EventHandler(this.action_ValueChanges);
 			// 
 			// browseaction
 			// 
 			this.browseaction.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.browseaction.Image = global
 			this.browseaction.Location = new System.Drawing.Point(469, 25);
 			this.browseaction.Name = "browseaction";
 			this.browseaction.Padding = new System.Windows.Forms.Padding(0, 0, 1, 3);
 			this.browseaction.Size = new System.Drawing.Size(28, 25);
 			this.browseaction.TabIndex = 1;
 			this.browseaction.Text = " ";
 			this.browseaction.UseVisualStyleBackColor = true;
 			this.browseaction.Click += new System.EventHandler(this.browseaction_Click);
 			// 
 			// udmfpanel
 			// 
 			this.udmfpanel.Controls.Add(this.udmfactivates);
 			this.udmfpanel.Location = new System.Drawing.Point(6, 143);
 			this.udmfpanel.Name = "udmfpanel";
 			this.udmfpanel.Size = new System.Drawing.Size(505, 132);
 			this.udmfpanel.TabIndex = 4;
 			this.udmfpanel.Visible = false;
 			// 
 			// udmfactivates
 			// 
 			this.udmfactivates.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.udmfactivates.AutoScroll = true;
 			this.udmfactivates.Columns = 2;
 			this.udmfactivates.Location = new System.Drawing.Point(56, 5);
 			this.udmfactivates.Name = "udmfactivates";
 			this.udmfactivates.Size = new System.Drawing.Size(437, 123);
 			this.udmfactivates.TabIndex = 0;
 			// 
 			// newtag
 			// 
 			this.newtag.Location = new System.Drawing.Point(149, 27);
 			this.newtag.Name = "newtag";
 			this.newtag.Size = new System.Drawing.Size(76, 23);
 			this.newtag.TabIndex = 1;
 			this.newtag.Text = "New Tag";
 			this.newtag.UseVisualStyleBackColor = true;
 			this.newtag.Click += new System.EventHandler(this.newtag_Click);
 			// 
 			// settingsgroup
 			// 
 			this.settingsgroup.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.settingsgroup.Controls.Add(this.flags);
 			this.settingsgroup.Location = new System.Drawing.Point(8, 8);
 			this.settingsgroup.Name = "settingsgroup";
 			this.settingsgroup.Size = new System.Drawing.Size(533, 163);
 			this.settingsgroup.TabIndex = 0;
 			this.settingsgroup.TabStop = false;
 			this.settingsgroup.Text = " Settings ";
 			// 
 			// flags
 			// 
 			this.flags.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.flags.AutoScroll = true;
 			this.flags.Columns = 3;
 			this.flags.Location = new System.Drawing.Point(18, 26);
 			this.flags.Name = "flags";
 			this.flags.Size = new System.Drawing.Size(509, 125);
 			this.flags.TabIndex = 0;
 			// 
 			// checkBox1
 			// 
 			this.checkBox1.Location = new System.Drawing.Point(0, 0);
 			this.checkBox1.Name = "checkBox1";
 			this.checkBox1.Size = new System.Drawing.Size(104, 24);
 			this.checkBox1.TabIndex = 0;
 			this.checkBox1.Text = "checkBox1";
 			this.checkBox1.UseVisualStyleBackColor = true;
 			// 
 			// tabs
 			// 
 			this.tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.tabs.Controls.Add(this.tabproperties);
 			this.tabs.Controls.Add(this.tabsidedefs);
 			this.tabs.Controls.Add(this.tabcustom);
 			this.tabs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabs.Location = new System.Drawing.Point(10, 10);
 			this.tabs.Margin = new System.Windows.Forms.Padding(1);
 			this.tabs.Name = "tabs";
 			this.tabs.SelectedIndex = 0;
 			this.tabs.Size = new System.Drawing.Size(557, 565);
 			this.tabs.SizeMode = System.Windows.Forms.TabSizeMode.Fixed;
 			this.tabs.TabIndex = 0;
 			// 
 			// tabproperties
 			// 
 			this.tabproperties.Controls.Add(this.idgroup);
 			this.tabproperties.Controls.Add(this.settingsgroup);
 			this.tabproperties.Controls.Add(this.actiongroup);
 			this.tabproperties.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabproperties.Location = new System.Drawing.Point(4, 23);
 			this.tabproperties.Name = "tabproperties";
 			this.tabproperties.Padding = new System.Windows.Forms.Padding(5);
 			this.tabproperties.Size = new System.Drawing.Size(549, 538);
 			this.tabproperties.TabIndex = 0;
 			this.tabproperties.Text = "Properties";
 			this.tabproperties.UseVisualStyleBackColor = true;
 			// 
 			// idgroup
 			// 
 			this.idgroup.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.idgroup.Controls.Add(this.tag);
 			this.idgroup.Controls.Add(taglabel);
 			this.idgroup.Controls.Add(this.newtag);
 			this.idgroup.Location = new System.Drawing.Point(8, 464);
 			this.idgroup.Name = "idgroup";
 			this.idgroup.Size = new System.Drawing.Size(533, 66);
 			this.idgroup.TabIndex = 2;
 			this.idgroup.TabStop = false;
 			this.idgroup.Text = " Identification ";
 			// 
 			// tag
 			// 
 			this.tag.AllowDecimal = false;
 			this.tag.AllowNegative = false;
 			this.tag.AllowRelative = true;
 			this.tag.ButtonStep = 1;
 			this.tag.Location = new System.Drawing.Point(62, 26);
 			this.tag.Name = "tag";
 			this.tag.Size = new System.Drawing.Size(75, 24);
 			this.tag.StepValues = null;
 			this.tag.TabIndex = 7;
 			// 
 			// tabsidedefs
 			// 
 			this.tabsidedefs.Controls.Add(this.splitter);
 			this.tabsidedefs.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabsidedefs.Location = new System.Drawing.Point(4, 23);
 			this.tabsidedefs.Name = "tabsidedefs";
 			this.tabsidedefs.Padding = new System.Windows.Forms.Padding(5);
 			this.tabsidedefs.Size = new System.Drawing.Size(549, 538);
 			this.tabsidedefs.TabIndex = 1;
 			this.tabsidedefs.Text = "Sidedefs";
 			this.tabsidedefs.UseVisualStyleBackColor = true;
 			// 
 			// splitter
 			// 
 			this.splitter.Dock = System.Windows.Forms.DockStyle.Fill;
 			this.splitter.IsSplitterFixed = true;
 			this.splitter.Location = new System.Drawing.Point(5, 5);
 			this.splitter.Name = "splitter";
 			this.splitter.Orientation = System.Windows.Forms.Orientation.Horizontal;
 			// 
 			// splitter.Panel1
 			// 
 			this.splitter.Panel1.Controls.Add(this.frontside);
 			this.splitter.Panel1.Controls.Add(this.frontgroup);
 			// 
 			// splitter.Panel2
 			// 
 			this.splitter.Panel2.Controls.Add(this.backside);
 			this.splitter.Panel2.Controls.Add(this.backgroup);
 			this.splitter.Size = new System.Drawing.Size(539, 528);
 			this.splitter.SplitterDistance = 256;
 			this.splitter.TabIndex = 3;
 			// 
 			// frontside
 			// 
 			this.frontside.AutoSize = true;
 			this.frontside.Location = new System.Drawing.Point(15, 1);
 			this.frontside.Name = "frontside";
 			this.frontside.Size = new System.Drawing.Size(75, 18);
 			this.frontside.TabIndex = 0;
 			this.frontside.Text = "Front Side";
 			this.frontside.UseVisualStyleBackColor = true;
 			this.frontside.CheckStateChanged += new System.EventHandler(this.frontside_CheckStateChanged);
 			// 
 			// frontgroup
 			// 
 			this.frontgroup.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.frontgroup.Controls.Add(this.frontoffsety);
 			this.frontgroup.Controls.Add(this.frontoffsetx);
 			this.frontgroup.Controls.Add(this.frontsector);
 			this.frontgroup.Controls.Add(this.customfrontbutton);
 			this.frontgroup.Controls.Add(label11);
 			this.frontgroup.Controls.Add(this.frontlow);
 			this.frontgroup.Controls.Add(this.frontmid);
 			this.frontgroup.Controls.Add(this.fronthigh);
 			this.frontgroup.Controls.Add(label6);
 			this.frontgroup.Controls.Add(label5);
 			this.frontgroup.Controls.Add(label4);
 			this.frontgroup.Controls.Add(label3);
 			this.frontgroup.Enabled = false;
 			this.frontgroup.Location = new System.Drawing.Point(3, 3);
 			this.frontgroup.Name = "frontgroup";
 			this.frontgroup.Size = new System.Drawing.Size(533, 250);
 			this.frontgroup.TabIndex = 1;
 			this.frontgroup.TabStop = false;
 			this.frontgroup.Text = "     ";
 			// 
 			// frontoffsety
 			// 
 			this.frontoffsety.AllowDecimal = false;
 			this.frontoffsety.AllowNegative = true;
 			this.frontoffsety.AllowRelative = true;
 			this.frontoffsety.ButtonStep = 1;
 			this.frontoffsety.Location = new System.Drawing.Point(171, 74);
 			this.frontoffsety.Name = "frontoffsety";
 			this.frontoffsety.Size = new System.Drawing.Size(62, 24);
 			this.frontoffsety.StepValues = null;
 			this.frontoffsety.TabIndex = 16;
 			// 
 			// frontoffsetx
 			// 
 			this.frontoffsetx.AllowDecimal = false;
 			this.frontoffsetx.AllowNegative = true;
 			this.frontoffsetx.AllowRelative = true;
 			this.frontoffsetx.ButtonStep = 1;
 			this.frontoffsetx.Location = new System.Drawing.Point(103, 74);
 			this.frontoffsetx.Name = "frontoffsetx";
 			this.frontoffsetx.Size = new System.Drawing.Size(62, 24);
 			this.frontoffsetx.StepValues = null;
 			this.frontoffsetx.TabIndex = 15;
 			// 
 			// frontsector
 			// 
 			this.frontsector.AllowDecimal = false;
 			this.frontsector.AllowNegative = false;
 			this.frontsector.AllowRelative = false;
 			this.frontsector.ButtonStep = 1;
 			this.frontsector.Location = new System.Drawing.Point(103, 35);
 			this.frontsector.Name = "frontsector";
 			this.frontsector.Size = new System.Drawing.Size(130, 24);
 			this.frontsector.StepValues = null;
 			this.frontsector.TabIndex = 14;
 			// 
 			// customfrontbutton
 			// 
 			this.customfrontbutton.Location = new System.Drawing.Point(103, 124);
 			this.customfrontbutton.Name = "customfrontbutton";
 			this.customfrontbutton.Size = new System.Drawing.Size(115, 25);
 			this.customfrontbutton.TabIndex = 3;
 			this.customfrontbutton.Text = "Custom fields...";
 			this.customfrontbutton.UseVisualStyleBackColor = true;
 			this.customfrontbutton.Visible = false;
 			this.customfrontbutton.Click += new System.EventHandler(this.customfrontbutton_Click);
 			// 
 			// frontlow
 			// 
 			this.frontlow.Location = new System.Drawing.Point(434, 37);
 			this.frontlow.Name = "frontlow";
 			this.frontlow.Required = false;
 			this.frontlow.Size = new System.Drawing.Size(83, 112);
 			this.frontlow.TabIndex = 6;
 			this.frontlow.TextureName = "";
 			// 
 			// frontmid
 			// 
 			this.frontmid.Location = new System.Drawing.Point(343, 37);
 			this.frontmid.Name = "frontmid";
 			this.frontmid.Required = false;
 			this.frontmid.Size = new System.Drawing.Size(83, 112);
 			this.frontmid.TabIndex = 5;
 			this.frontmid.TextureName = "";
 			// 
 			// fronthigh
 			// 
 			this.fronthigh.Location = new System.Drawing.Point(252, 37);
 			this.fronthigh.Name = "fronthigh";
 			this.fronthigh.Required = false;
 			this.fronthigh.Size = new System.Drawing.Size(83, 112);
 			this.fronthigh.TabIndex = 4;
 			this.fronthigh.TextureName = "";
 			// 
 			// backside
 			// 
 			this.backside.AutoSize = true;
 			this.backside.Location = new System.Drawing.Point(15, 1);
 			this.backside.Name = "backside";
 			this.backside.Size = new System.Drawing.Size(74, 18);
 			this.backside.TabIndex = 0;
 			this.backside.Text = "Back Side";
 			this.backside.UseVisualStyleBackColor = true;
 			this.backside.CheckStateChanged += new System.EventHandler(this.backside_CheckStateChanged);
 			// 
 			// backgroup
 			// 
 			this.backgroup.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.backgroup.Controls.Add(this.backoffsety);
 			this.backgroup.Controls.Add(this.backoffsetx);
 			this.backgroup.Controls.Add(this.backsector);
 			this.backgroup.Controls.Add(this.custombackbutton);
 			this.backgroup.Controls.Add(label12);
 			this.backgroup.Controls.Add(this.backlow);
 			this.backgroup.Controls.Add(this.backmid);
 			this.backgroup.Controls.Add(this.backhigh);
 			this.backgroup.Controls.Add(label7);
 			this.backgroup.Controls.Add(label8);
 			this.backgroup.Controls.Add(label9);
 			this.backgroup.Controls.Add(label10);
 			this.backgroup.Enabled = false;
 			this.backgroup.Location = new System.Drawing.Point(3, 3);
 			this.backgroup.Name = "backgroup";
 			this.backgroup.Size = new System.Drawing.Size(535, 262);
 			this.backgroup.TabIndex = 1;
 			this.backgroup.TabStop = false;
 			this.backgroup.Text = "     ";
 			// 
 			// backoffsety
 			// 
 			this.backoffsety.AllowDecimal = false;
 			this.backoffsety.AllowNegative = true;
 			this.backoffsety.AllowRelative = true;
 			this.backoffsety.ButtonStep = 1;
 			this.backoffsety.Location = new System.Drawing.Point(171, 74);
 			this.backoffsety.Name = "backoffsety";
 			this.backoffsety.Size = new System.Drawing.Size(62, 24);
 			this.backoffsety.StepValues = null;
 			this.backoffsety.TabIndex = 19;
 			// 
 			// backoffsetx
 			// 
 			this.backoffsetx.AllowDecimal = false;
 			this.backoffsetx.AllowNegative = true;
 			this.backoffsetx.AllowRelative = true;
 			this.backoffsetx.ButtonStep = 1;
 			this.backoffsetx.Location = new System.Drawing.Point(103, 74);
 			this.backoffsetx.Name = "backoffsetx";
 			this.backoffsetx.Size = new System.Drawing.Size(62, 24);
 			this.backoffsetx.StepValues = null;
 			this.backoffsetx.TabIndex = 18;
 			// 
 			// backsector
 			// 
 			this.backsector.AllowDecimal = false;
 			this.backsector.AllowNegative = false;
 			this.backsector.AllowRelative = false;
 			this.backsector.ButtonStep = 1;
 			this.backsector.Location = new System.Drawing.Point(103, 35);
 			this.backsector.Name = "backsector";
 			this.backsector.Size = new System.Drawing.Size(130, 24);
 			this.backsector.StepValues = null;
 			this.backsector.TabIndex = 17;
 			// 
 			// custombackbutton
 			// 
 			this.custombackbutton.Location = new System.Drawing.Point(103, 124);
 			this.custombackbutton.Name = "custombackbutton";
 			this.custombackbutton.Size = new System.Drawing.Size(115, 25);
 			this.custombackbutton.TabIndex = 3;
 			this.custombackbutton.Text = "Custom fields...";
 			this.custombackbutton.UseVisualStyleBackColor = true;
 			this.custombackbutton.Visible = false;
 			this.custombackbutton.Click += new System.EventHandler(this.custombackbutton_Click);
 			// 
 			// backlow
 			// 
 			this.backlow.Location = new System.Drawing.Point(437, 37);
 			this.backlow.Name = "backlow";
 			this.backlow.Required = false;
 			this.backlow.Size = new System.Drawing.Size(83, 112);
 			this.backlow.TabIndex = 6;
 			this.backlow.TextureName = "";
 			// 
 			// backmid
 			// 
 			this.backmid.Location = new System.Drawing.Point(346, 37);
 			this.backmid.Name = "backmid";
 			this.backmid.Required = false;
 			this.backmid.Size = new System.Drawing.Size(83, 112);
 			this.backmid.TabIndex = 5;
 			this.backmid.TextureName = "";
 			// 
 			// backhigh
 			// 
 			this.backhigh.Location = new System.Drawing.Point(255, 37);
 			this.backhigh.Name = "backhigh";
 			this.backhigh.Required = false;
 			this.backhigh.Size = new System.Drawing.Size(83, 112);
 			this.backhigh.TabIndex = 4;
 			this.backhigh.TextureName = "";
 			// 
 			// tabcustom
 			// 
 			this.tabcustom.Controls.Add(this.fieldslist);
 			this.tabcustom.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.tabcustom.Location = new System.Drawing.Point(4, 23);
 			this.tabcustom.Name = "tabcustom";
 			this.tabcustom.Padding = new System.Windows.Forms.Padding(3);
 			this.tabcustom.Size = new System.Drawing.Size(549, 538);
 			this.tabcustom.TabIndex = 2;
 			this.tabcustom.Text = "Custom";
 			this.tabcustom.UseVisualStyleBackColor = true;
 			// 
 			// fieldslist
 			// 
 			this.fieldslist.AllowInsert = true;
 			this.fieldslist.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
 						| System.Windows.Forms.AnchorStyles.Left)
 						| System.Windows.Forms.AnchorStyles.Right)));
 			this.fieldslist.AutoInsertUserPrefix = true;
 			this.fieldslist.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
 			this.fieldslist.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.fieldslist.Location = new System.Drawing.Point(11, 11);
 			this.fieldslist.Margin = new System.Windows.Forms.Padding(8);
 			this.fieldslist.Name = "fieldslist";
 			this.fieldslist.PropertyColumnVisible = true;
 			this.fieldslist.PropertyColumnWidth = 150;
 			this.fieldslist.Size = new System.Drawing.Size(511, 516);
 			this.fieldslist.TabIndex = 0;
 			this.fieldslist.TypeColumnVisible = true;
 			this.fieldslist.TypeColumnWidth = 100;
 			this.fieldslist.ValueColumnVisible = true;
 			// 
 			// heightpanel1
 			// 
 			this.heightpanel1.BackColor = System.Drawing.Color.Navy;
 			this.heightpanel1.Location = new System.Drawing.Point(0, -19);
 			this.heightpanel1.Name = "heightpanel1";
 			this.heightpanel1.Size = new System.Drawing.Size(78, 510);
 			this.heightpanel1.TabIndex = 3;
 			this.heightpanel1.Visible = false;
 			// 
 			// heightpanel2
 			// 
 			this.heightpanel2.BackColor = System.Drawing.Color.Navy;
 			this.heightpanel2.Location = new System.Drawing.Point(473, -19);
 			this.heightpanel2.Name = "heightpanel2";
 			this.heightpanel2.Size = new System.Drawing.Size(88, 470);
 			this.heightpanel2.TabIndex = 4;
 			this.heightpanel2.Visible = false;
 			// 
 			// LinedefEditForm
 			// 
 			this.AcceptButton = this.apply;
 			this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
 			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
 			this.CancelButton = this.cancel;
 			this.ClientSize = new System.Drawing.Size(577, 627);
 			this.Controls.Add(this.tabs);
 			this.Controls.Add(this.cancel);
 			this.Controls.Add(this.apply);
 			this.Controls.Add(this.heightpanel1);
 			this.Controls.Add(this.heightpanel2);
 			this.Font = new System.Drawing.Font("Arial", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
 			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
 			this.MaximizeBox = false;
 			this.MinimizeBox = false;
 			this.Name = "LinedefEditForm";
 			this.Opacity = 0;
 			this.ShowIcon = false;
 			this.ShowInTaskbar = false;
 			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
 			this.Text = "Edit Linedef";
 			this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.LinedefEditForm_HelpRequested);
 			this.actiongroup.ResumeLayout(false);
 			this.actiongroup.PerformLayout();
 			this.argspanel.ResumeLayout(false);
 			this.hexenpanel.ResumeLayout(false);
 			this.hexenpanel.PerformLayout();
 			this.udmfpanel.ResumeLayout(false);
 			this.settingsgroup.ResumeLayout(false);
 			this.tabs.ResumeLayout(false);
 			this.tabproperties.ResumeLayout(false);
 			this.idgroup.ResumeLayout(false);
 			this.idgroup.PerformLayout();
 			this.tabsidedefs.ResumeLayout(false);
 			this.splitter.Panel1.ResumeLayout(false);
 			this.splitter.Panel1.PerformLayout();
 			this.splitter.Panel2.ResumeLayout(false);
 			this.splitter.Panel2.PerformLayout();
 			this.splitter.ResumeLayout(false);
 			this.frontgroup.ResumeLayout(false);
 			this.frontgroup.PerformLayout();
 			this.backgroup.ResumeLayout(false);
 			this.backgroup.PerformLayout();
 			this.tabcustom.ResumeLayout(false);
 			this.ResumeLayout(false);
 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="34" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer2D.cs" startline="462" endline="488">
<![CDATA[
 
 		// This makes screen vertices for display
 		private FlatVertex[] CreateScreenVerts(Size texturesize)
 		{
 			FlatVertex[] screenverts = new FlatVertex[4];
 			screenverts[0].x = 0.5f;
 			screenverts[0].y = 0.5f;
 			screenverts[0].c = -1;
 			screenverts[0].u = 1f / texturesize.Width;
 			screenverts[0].v = 1f / texturesize.Height;
 			screenverts[1].x = texturesize.Width - 1.5f;
 			screenverts[1].y = 0.5f;
 			screenverts[1].c = -1;
 			screenverts[1].u = 1f - 1f / texturesize.Width;
 			screenverts[1].v = 1f / texturesize.Height;
 			screenverts[2].x = 0.5f;
 			screenverts[2].y = texturesize.Height - 1.5f;
 			screenverts[2].c = -1;
 			screenverts[2].u = 1f / texturesize.Width;
 			screenverts[2].v = 1f - 1f / texturesize.Height;
 			screenverts[3].x = texturesize.Width - 1.5f;
 			screenverts[3].y = texturesize.Height - 1.5f;
 			screenverts[3].c = -1;
 			screenverts[3].u = 1f - 1f / texturesize.Width;
 			screenverts[3].v = 1f - 1f / texturesize.Height;
 			return screenverts;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\Renderer3D.cs" startline="182" endline="214">
<![CDATA[
 
 		// This makes screen vertices for display
 		private void CreateCrosshairVerts(Size texturesize)
 		{
 			// Determine coordinates
 			float width = (float)windowsize.Width;
 			float height = (float)windowsize.Height;
 			float size = (float)height * CROSSHAIR_SCALE;
 			RectangleF rect = new RectangleF((width - size) / 2, (height - size) / 2, size, size);
 			
 			// Make vertices
 			crosshairverts = new FlatVertex[4];
 			crosshairverts[0].x = rect.Left;
 			crosshairverts[0].y = rect.Top;
 			crosshairverts[0].c = -1;
 			crosshairverts[0].u = 1f / texturesize.Width;
 			crosshairverts[0].v = 1f / texturesize.Height;
 			crosshairverts[1].x = rect.Right;
 			crosshairverts[1].y = rect.Top;
 			crosshairverts[1].c = -1;
 			crosshairverts[1].u = 1f - 1f / texturesize.Width;
 			crosshairverts[1].v = 1f / texturesize.Height;
 			crosshairverts[2].x = rect.Left;
 			crosshairverts[2].y = rect.Bottom;
 			crosshairverts[2].c = -1;
 			crosshairverts[2].u = 1f / texturesize.Width;
 			crosshairverts[2].v = 1f - 1f / texturesize.Height;
 			crosshairverts[3].x = rect.Right;
 			crosshairverts[3].y = rect.Bottom;
 			crosshairverts[3].c = -1;
 			crosshairverts[3].u = 1f - 1f / texturesize.Width;
 			crosshairverts[3].v = 1f - 1f / texturesize.Height;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="35" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Editing\ThingsFilter.cs" startline="232" endline="261">
<![CDATA[
 
 		// This writes the filter to configuration
 		internal void WriteSettings(Configuration cfg, string path)
 		{
 			// Write settings to config
 			cfg.WriteSetting(path + ".name", name);
 			cfg.WriteSetting(path + ".category", categoryname);
 			cfg.WriteSetting(path + ".type", thingtype);
 			cfg.WriteSetting(path + ".angle", thingangle);
 			cfg.WriteSetting(path + ".zheight", thingzheight);
 			cfg.WriteSetting(path + ".action", thingaction);
 			for(int i = 0; i < Thing.NUM_ARGS; i++)
 				cfg.WriteSetting(path + ".arg" + i.ToString(CultureInfo.InvariantCulture), thingargs[i]);
 			for(int i = 0; i < Thing.NUM_ARGS; i++)
 				cfg.WriteSetting(path + ".arg" + i.ToString(CultureInfo.InvariantCulture), thingargs[i]);
 			cfg.WriteSetting(path + ".tag", thingtag);
 			
 			// Write required fields to config
 			foreach(string s in requiredfields)
 				cfg.WriteSetting(path + ".fields." + s, true);
 			foreach(string s in requiredfields)
 				cfg.WriteSetting(path + ".fields." + s, true);
 			
 			// Write forbidden fields to config
 			foreach(string s in forbiddenfields)
 				cfg.WriteSetting(path + ".fields." + s, false);
 			foreach(string s in forbiddenfields)
 				cfg.WriteSetting(path + ".fields." + s, false);
 			
 			// Custom fields
 			foreach(KeyValuePair<string, UniValue> u in customfields)
 			{
 				cfg.WriteSetting(path + ".customfieldtypes." + u.Key, u.Value.Type);
 				cfg.WriteSetting(path + ".customfieldvalues." + u.Key, u.Value.Value);
 			}
 			foreach(KeyValuePair<string, UniValue> u in customfields)
 			{
 				cfg.WriteSetting(path + ".customfieldtypes." + u.Key, u.Value.Type);
 				cfg.WriteSetting(path + ".customfieldvalues." + u.Key, u.Value.Value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ProgramConfiguration.cs" startline="250" endline="306">
<![CDATA[
 
 		// This saves the program configuration
 		internal void Save(string filepathname)
 		{
 			Version v = General.ThisAssembly.GetName().Version;
 			
 			// Write the cache variables
 			cfg.WriteSetting("blackbrowsers", blackbrowsers);
 			//cfg.WriteSetting("undolevels", undolevels);
 			cfg.WriteSetting("visualfov", visualfov);
 			cfg.WriteSetting("visualmousesensx", visualmousesensx);
 			cfg.WriteSetting("visualmousesensy", visualmousesensy);
 			cfg.WriteSetting("imagebrightness", imagebrightness);
 			cfg.WriteSetting("qualitydisplay", qualitydisplay);
 			cfg.WriteSetting("squarethings", squarethings);
 			cfg.WriteSetting("testmonsters", testmonsters);
 			cfg.WriteSetting("doublesidedalpha", doublesidedalpha);
 			cfg.WriteSetting("backgroundalpha", backgroundalpha);
 			cfg.WriteSetting("defaultviewmode", defaultviewmode);
 			cfg.WriteSetting("classicbilinear", classicbilinear);
 			cfg.WriteSetting("visualbilinear", visualbilinear);
 			cfg.WriteSetting("mousespeed", mousespeed);
 			cfg.WriteSetting("movespeed", movespeed);
 			cfg.WriteSetting("viewdistance", viewdistance);
 			cfg.WriteSetting("invertyaxis", invertyaxis);
 			cfg.WriteSetting("scriptfontname", scriptfontname);
 			cfg.WriteSetting("scriptfontsize", scriptfontsize);
 			cfg.WriteSetting("scriptfontbold", scriptfontbold);
 			cfg.WriteSetting("scriptontop", scriptontop);
 			cfg.WriteSetting("scripttabwidth", scripttabwidth);
 			cfg.WriteSetting("scriptautoindent", scriptautoindent);
 			cfg.WriteSetting("previewimagesize", previewimagesize);
 			cfg.WriteSetting("autoscrollspeed", autoscrollspeed);
 			cfg.WriteSetting("zoomfactor", zoomfactor);
 			cfg.WriteSetting("showerrorswindow", showerrorswindow);
 			cfg.WriteSetting("animatevisualselection", animatevisualselection);
 			cfg.WriteSetting("currentversion", v.Major * 1000000 + v.Revision);
 			cfg.WriteSetting("dockersposition", dockersposition);
 			cfg.WriteSetting("collapsedockers", collapsedockers);
 			cfg.WriteSetting("dockerswidth", dockerswidth);
 			pasteoptions.WriteConfiguration(cfg, "pasteoptions");
 			cfg.WriteSetting("toolbarscript", toolbarscript);
 			cfg.WriteSetting("toolbarundo", toolbarundo);
 			cfg.WriteSetting("toolbarcopy", toolbarcopy);
 			cfg.WriteSetting("toolbarprefabs", toolbarprefabs);
 			cfg.WriteSetting("toolbarfilter", toolbarfilter);
 			cfg.WriteSetting("toolbarviewmodes", toolbarviewmodes);
 			cfg.WriteSetting("toolbargeometry", toolbargeometry);
 			cfg.WriteSetting("toolbartesting", toolbartesting);
 			cfg.WriteSetting("toolbarfile", toolbarfile);
 			cfg.WriteSetting("filteranisotropy", filteranisotropy);
 			cfg.WriteSetting("showtexturesizes", showtexturesizes);
 			
 			// Save settings configuration
 			General.WriteLogLine("Saving program configuration...");
 			cfg.SaveConfiguration(filepathname);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Windows\PreferencesForm.cs" startline="472" endline="531">
<![CDATA[
 		
 		// This fills the list of available controls for the specified action
 		private void FillControlsList(Actions.Action a)
 		{
 			actioncontrol.Items.Clear();
 			
 			// Fill combobox with special controls
 			if(a.AllowMouse)
 			{
 				actioncontrol.Items.Add(new KeyControl(Keys.LButton, "LButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.MButton, "MButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.RButton, "RButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.XButton1, "XButton1"));
 				actioncontrol.Items.Add(new KeyControl(Keys.XButton2, "XButton2"));
 			}
 			if(a.AllowScroll)
 			{
 				actioncontrol.Items.Add(new KeyControl(SpecialKeys.MScrollUp, "ScrollUp"));
 				actioncontrol.Items.Add(new KeyControl(SpecialKeys.MScrollDown, "ScrollDown"));
 			}
 			if(a.AllowMouse && !a.DisregardShift)
 			{
 				actioncontrol.Items.Add(new KeyControl(Keys.LButton | Keys.Shift, "Shift+LButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.MButton | Keys.Shift, "Shift+MButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.RButton | Keys.Shift, "Shift+RButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.XButton1 | Keys.Shift, "Shift+XButton1"));
 				actioncontrol.Items.Add(new KeyControl(Keys.XButton2 | Keys.Shift, "Shift+XButton2"));
 			}
 			if(a.AllowScroll && !a.DisregardShift)
 			{
 				actioncontrol.Items.Add(new KeyControl((int)SpecialKeys.MScrollUp | (int)Keys.Shift, "Shift+ScrollUp"));
 				actioncontrol.Items.Add(new KeyControl((int)SpecialKeys.MScrollDown | (int)Keys.Shift, "Shift+ScrollDown"));
 			}
 			if(a.AllowMouse && !a.DisregardControl)
 			{
 				actioncontrol.Items.Add(new KeyControl(Keys.LButton | Keys.Control, "Ctrl+LButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.MButton | Keys.Control, "Ctrl+MButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.RButton | Keys.Control, "Ctrl+RButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.XButton1 | Keys.Control, "Ctrl+XButton1"));
 				actioncontrol.Items.Add(new KeyControl(Keys.XButton2 | Keys.Control, "Ctrl+XButton2"));
 			}
 			if(a.AllowScroll && !a.DisregardControl)
 			{
 				actioncontrol.Items.Add(new KeyControl((int)SpecialKeys.MScrollUp | (int)Keys.Control, "Ctrl+ScrollUp"));
 				actioncontrol.Items.Add(new KeyControl((int)SpecialKeys.MScrollDown | (int)Keys.Control, "Ctrl+ScrollDown"));
 			}
 			if(a.AllowMouse && !a.DisregardShift && !a.DisregardControl)
 			{
 				actioncontrol.Items.Add(new KeyControl(Keys.LButton | Keys.Shift | Keys.Control, "Ctrl+Shift+LButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.MButton | Keys.Shift | Keys.Control, "Ctrl+Shift+MButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.RButton | Keys.Shift | Keys.Control, "Ctrl+Shift+RButton"));
 				actioncontrol.Items.Add(new KeyControl(Keys.XButton1 | Keys.Shift | Keys.Control, "Ctrl+Shift+XButton1"));
 				actioncontrol.Items.Add(new KeyControl(Keys.XButton2 | Keys.Shift | Keys.Control, "Ctrl+Shift+XButton2"));
 			}
 			if(a.AllowScroll && !a.DisregardShift && !a.DisregardControl)
 			{
 				actioncontrol.Items.Add(new KeyControl((int)SpecialKeys.MScrollUp | (int)Keys.Shift | (int)Keys.Control, "Ctrl+Shift+ScrollUp"));
 				actioncontrol.Items.Add(new KeyControl((int)SpecialKeys.MScrollDown | (int)Keys.Shift | (int)Keys.Control, "Ctrl+Shift+ScrollDown"));
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="36" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Config\ProgramConfiguration.cs" startline="307" endline="377">
<![CDATA[
 		
 		// This reads the configuration
 		private bool Read(string cfgfilepathname, string defaultfilepathname)
 		{
 			DialogResult result;
 
 			// Check if no config for this user exists yet
 			if(!File.Exists(cfgfilepathname))
 			{
 				// Copy new configuration
 				General.WriteLogLine("Local user program configuration is missing!");
 				File.Copy(defaultfilepathname, cfgfilepathname);
 				General.WriteLogLine("New program configuration copied for local user");
 			}
 
 			// Load it
 			cfg = new Configuration(cfgfilepathname, true);
 			if(cfg.ErrorResult)
 			{
 				// Error in configuration
 				// Ask user for a new copy
 				result = General.ShowErrorMessage("Error in program configuration near line " + cfg.ErrorLine + "
 				if(result == DialogResult.Yes)
 				{
 					// Remove old configuration and make a new copy
 					General.WriteLogLine("User requested a new copy of the program configuration");
 					File.Delete(cfgfilepathname);
 					File.Copy(defaultfilepathname, cfgfilepathname);
 					General.WriteLogLine("New program configuration copied for local user");
 
 					// Load it
 					cfg = new Configuration(cfgfilepathname, true);
 					if(cfg.ErrorResult)
 					{
 						// Error in configuration
 						General.WriteLogLine("Error in program configuration near line " + cfg.ErrorLine + "
 						General.ShowErrorMessage("Default program configuration is corrupted. Please re-install Doom Builder.", MessageBoxButtons.OK);
 						return false;
 					}
 				}
 				else if(result == DialogResult.Cancel)
 				{
 					// User requested to cancel startup
 					General.WriteLogLine("User cancelled startup");
 					return false;
 				}
 			}
 			
 			// Check if a version number is missing
 			previousversion = cfg.ReadSetting("currentversion", -1);
 			if(!General.NoSettings && (previousversion == -1))
 			{
 				// Remove old configuration and make a new copy
 				General.WriteLogLine("Program configuration is outdated, new configuration will be copied for local user");
 				File.Delete(cfgfilepathname);
 				File.Copy(defaultfilepathname, cfgfilepathname);
 				
 				// Load it
 				cfg = new Configuration(cfgfilepathname, true);
 				if(cfg.ErrorResult)
 				{
 					// Error in configuration
 					General.WriteLogLine("Error in program configuration near line " + cfg.ErrorLine + "
 					General.ShowErrorMessage("Default program configuration is corrupted. Please re-install Doom Builder.", MessageBoxButtons.OK);
 					return false;
 				}
 			}
 			
 			// Success
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Rendering\ColorCollection.cs" startline="135" endline="185">
<![CDATA[
 		
 		#endregion
 
 		#region ================== Constructor / Disposer
 
 		// Constructor for settings from configuration
 		internal ColorCollection(Configuration cfg)
 		{
 			// Initialize
 			colors = new PixelColor[NUM_COLORS];
 			brightcolors = new PixelColor[NUM_COLORS];
 			darkcolors = new PixelColor[NUM_COLORS];
 			
 			// Read all colors from config
 			for(int i = 0; i < NUM_COLORS; i++)
 			{
 				// Read color
 				colors[i] = PixelColor.FromInt(cfg.ReadSetting("colors.color" + i.ToString(CultureInfo.InvariantCulture), 0));
 			}
 			for(int i = 0; i < NUM_COLORS; i++)
 			{
 				// Read color
 				colors[i] = PixelColor.FromInt(cfg.ReadSetting("colors.color" + i.ToString(CultureInfo.InvariantCulture), 0));
 			}
 
 			// Set new colors
 			if(colors[THINGCOLOR00].ToInt() == 0) colors[THINGCOLOR00] = PixelColor.FromColor(Color.DimGray);
 			if(colors[THINGCOLOR01].ToInt() == 0) colors[THINGCOLOR01] = PixelColor.FromColor(Color.RoyalBlue);
 			if(colors[THINGCOLOR02].ToInt() == 0) colors[THINGCOLOR02] = PixelColor.FromColor(Color.ForestGreen);
 			if(colors[THINGCOLOR03].ToInt() == 0) colors[THINGCOLOR03] = PixelColor.FromColor(Color.LightSeaGreen);
 			if(colors[THINGCOLOR04].ToInt() == 0) colors[THINGCOLOR04] = PixelColor.FromColor(Color.Firebrick);
 			if(colors[THINGCOLOR05].ToInt() == 0) colors[THINGCOLOR05] = PixelColor.FromColor(Color.DarkViolet);
 			if(colors[THINGCOLOR06].ToInt() == 0) colors[THINGCOLOR06] = PixelColor.FromColor(Color.DarkGoldenrod);
 			if(colors[THINGCOLOR07].ToInt() == 0) colors[THINGCOLOR07] = PixelColor.FromColor(Color.Silver);
 			if(colors[THINGCOLOR08].ToInt() == 0) colors[THINGCOLOR08] = PixelColor.FromColor(Color.Gray);
 			if(colors[THINGCOLOR09].ToInt() == 0) colors[THINGCOLOR09] = PixelColor.FromColor(Color.DeepSkyBlue);
 			if(colors[THINGCOLOR10].ToInt() == 0) colors[THINGCOLOR10] = PixelColor.FromColor(Color.LimeGreen);
 			if(colors[THINGCOLOR11].ToInt() == 0) colors[THINGCOLOR11] = PixelColor.FromColor(Color.PaleTurquoise);
 			if(colors[THINGCOLOR12].ToInt() == 0) colors[THINGCOLOR12] = PixelColor.FromColor(Color.Tomato);
 			if(colors[THINGCOLOR13].ToInt() == 0) colors[THINGCOLOR13] = PixelColor.FromColor(Color.Violet);
 			if(colors[THINGCOLOR14].ToInt() == 0) colors[THINGCOLOR14] = PixelColor.FromColor(Color.Yellow);
 			if(colors[THINGCOLOR15].ToInt() == 0) colors[THINGCOLOR15] = PixelColor.FromColor(Color.WhiteSmoke);
 			if(colors[THINGCOLOR16].ToInt() == 0) colors[THINGCOLOR16] = PixelColor.FromColor(Color.LightPink);
 			if(colors[THINGCOLOR17].ToInt() == 0) colors[THINGCOLOR17] = PixelColor.FromColor(Color.DarkOrange);
 			if(colors[THINGCOLOR18].ToInt() == 0) colors[THINGCOLOR18] = PixelColor.FromColor(Color.DarkKhaki);
 			if(colors[THINGCOLOR19].ToInt() == 0) colors[THINGCOLOR19] = PixelColor.FromColor(Color.Goldenrod);
 			
 			// Create assist colors
 			CreateAssistColors();
 			
 			// Create color correction table
 			CreateCorrectionTable();
 			
 			// We have no destructor
 			GC.SuppressFinalize(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\Games\doombuilder\trunk\Source\Core\Geometry\ProjectedFrustum2D.cs" startline="62" endline="128">
<![CDATA[
 
 		#endregion
 
 		#region ================== Constructor / Destructor
 
 		// Constructor
 		public ProjectedFrustum2D(Vector2D pos, float xyangle, float zangle, float near, float far, float fov)
 		{
 			Vector2D[] forwards = new Vector2D[4];
 			Vector2D[] downwards = new Vector2D[4];
 			Vector2D[] corners = new Vector2D[4];
 			
 			// Initialize
 			this.pos = pos;
 			this.xyangle = xyangle;
 			this.zangle = zangle;
 			this.near = near;
 			this.far = far;
 			this.fov = fov;
 			
 			// Make the corners for a forward frustum
 			// The corners are in this order
 			float fovhalf = fov * 0.5f;
 			float fovhalfcos = (float)Math.Cos(fovhalf);
 			float farsidelength = far / fovhalfcos;
 			float nearsidelength = near / fovhalfcos;
 			forwards[0] = pos + Vector2D.FromAngle(xyangle - fovhalf, farsidelength);
 			forwards[1] = pos + Vector2D.FromAngle(xyangle + fovhalf, farsidelength);
 			forwards[2] = pos + Vector2D.FromAngle(xyangle - fovhalf, nearsidelength);
 			forwards[3] = pos + Vector2D.FromAngle(xyangle + fovhalf, nearsidelength);
 			
 			// Make the corners for a downward frustum
 			// The corners are in the same order as above
 			//float farradius = far * (float)Math.Tan(fovhalf) * Angle2D.SQRT2;
 			float farradius = far * 0.5f * Angle2D.SQRT2;
 			downwards[0] = pos + Vector2D.FromAngle(xyangle - Angle2D.PI * 0.25f, farradius);
 			downwards[1] = pos + Vector2D.FromAngle(xyangle + Angle2D.PI * 0.25f, farradius);
 			downwards[2] = pos + Vector2D.FromAngle(xyangle - Angle2D.PI * 0.75f, farradius);
 			downwards[3] = pos + Vector2D.FromAngle(xyangle + Angle2D.PI * 0.75f, farradius);
 			
 			// Interpolate between the two to make the final corners depending on the z angle
 			float d = Math.Abs((float)Math.Sin(zangle));
 			corners[0] = forwards[0] * (1.0f - d) + downwards[0] * d;
 			corners[1] = forwards[1] * (1.0f - d) + downwards[1] * d;
 			corners[2] = forwards[2] * (1.0f - d) + downwards[2] * d;
 			corners[3] = forwards[3] * (1.0f - d) + downwards[3] * d;
 			
 			// Make the frustum lines
 			// Note that the lines all have their right side inside the frustum!
 			lines = new Line2D[4];
 			lines[0] = new Line2D(corners[2], corners[0]);
 			lines[1] = new Line2D(corners[1], corners[3]);
 			lines[2] = new Line2D(corners[3], corners[2]);
 			lines[3] = new Line2D(corners[0], corners[1]);
 
 			// Calculate the circle center
 			center = (corners[0] + corners[1] + corners[2] + corners[3]) * 0.25f;
 			
 			// Calculate the radius from the center to the farthest corner
 			float radius2 = 0.0f;
 			for(int i = 0; i < corners.Length; i++)
 			{
 				float distance2 = Vector2D.DistanceSq(center, corners[i]);
 				if(distance2 > radius2) radius2 = distance2;
 			}
 			for(int i = 0; i < corners.Length; i++)
 			{
 				float distance2 = Vector2D.DistanceSq(center, corners[i]);
 				if(distance2 > radius2) radius2 = distance2;
 			}
 			radius = (float)Math.Sqrt(radius2);
 		}
]]>
</clone_fragment>
</clone_pair>
</clones>
