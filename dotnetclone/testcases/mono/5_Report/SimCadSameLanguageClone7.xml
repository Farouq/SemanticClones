<clones  >
<clone_pair groupid="0" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1230" endline="1246">
<![CDATA[
 
 
 		/// <summary>
 		///   Attempts to apply the `Standard Implicit
 		///   Conversion' rules to the expression `expr' into
 		///   the `target_type'.  It returns a new expression
 		///   that can be used in a context that expects a
 		///   `target_type'.
 		///
 		///   This is different from `ImplicitConversion' in that the
 		///   user defined implicit conversions are excluded.
 		/// </summary>
 		static public Expression ImplicitConversionStandard (ResolveContext ec, Expression expr,
 								     TypeSpec target_type, Location loc)
 		{
 			return ImplicitConversionStandard (ec, expr, target_type, loc, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="968" endline="975">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Explicit conversions
 		/// </summary>
 		static Expression ExplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, false, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1230" endline="1246">
<![CDATA[
 
 
 		/// <summary>
 		///   Attempts to apply the `Standard Implicit
 		///   Conversion' rules to the expression `expr' into
 		///   the `target_type'.  It returns a new expression
 		///   that can be used in a context that expects a
 		///   `target_type'.
 		///
 		///   This is different from `ImplicitConversion' in that the
 		///   user defined implicit conversions are excluded.
 		/// </summary>
 		static public Expression ImplicitConversionStandard (ResolveContext ec, Expression expr,
 								     TypeSpec target_type, Location loc)
 		{
 			return ImplicitConversionStandard (ec, expr, target_type, loc, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="190" endline="205">
<![CDATA[
 
 		public enum Operation {
 			//
 			// If you change this, review the whole InterfaceMethod routine as there
 			// are a couple of assumptions on these three states
 			//
 			Lookup, ClearOne, ClearAll
 		}
 
 		/// <summary>
 		///   Whether the specified method is an interface method implementation
 		/// </summary>
 		public MethodSpec IsInterfaceMethod (MemberName name, TypeSpec ifaceType, MethodData method)
 		{
 			return InterfaceMethod (name, ifaceType, method, Operation.Lookup);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="2" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4094" endline="4105">
<![CDATA[
 	}
 
 	public class Lock 
 		Expression expr;
 		TemporaryVariableReference expr_copy;
 		TemporaryVariableReference lock_taken;
 			
 		public Lock (Expression expr, Statement stmt, Location loc)
 			
 		{
 			this.expr = expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4755" endline="4764">
<![CDATA[
 	}
 
 	public class TryFinally 
 		Block fini;
 
 		public TryFinally (Statement stmt, Block fini, Location loc)
 			 
 		{
 			this.fini = fini;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="3" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4094" endline="4105">
<![CDATA[
 	}
 
 	public class Lock 
 		Expression expr;
 		TemporaryVariableReference expr_copy;
 		TemporaryVariableReference lock_taken;
 			
 		public Lock (Expression expr, Statement stmt, Location loc)
 			
 		{
 			this.expr = expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1543" endline="1553">
<![CDATA[
 	}
 
 	class ImportedMemberDefinition 
 	{
 		readonly TypeSpec type;
 
 		public ImportedMemberDefinition (MemberInfo member, TypeSpec type, MetadataImporter importer)
 			
 		{
 			this.type = type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="4" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1214" endline="1220">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			UnaryMutator target = (UnaryMutator) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="5" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="767" endline="773">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Unary target = (Unary) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="6" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8025" endline="8031">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			UnCheckedExpr target = (UnCheckedExpr) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="7" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7908" endline="7914">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="8" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7970" endline="7976">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CheckedExpr target = (CheckedExpr) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="9" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="82" endline="88">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Yield target = (Yield) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="10" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="329" endline="336">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Do target = (Do) t;
 
 			target.EmbeddedStatement = EmbeddedStatement.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="11" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1698" endline="1711">
<![CDATA[
 
 #if NET_4_0 && !STATIC
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			return SLE.Expression.Default (type.GetMetaInfo ());
 		}
 #endif
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			DefaultValueExpression target = (DefaultValueExpression) t;
 			
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="12" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="105" endline="112">
<![CDATA[
 
 		//
 		//  Returns a constant instance based on Type
 		//
 		public static Constant CreateConstant (ResolveContext rc, TypeSpec t, object v, Location loc)
 		{
 			return CreateConstantFromValue (t, v, loc).Resolve (rc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="13" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9130" endline="9136">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			StackAlloc target = (StackAlloc) t;
 			target.count = count.Clone (clonectx);
 			target.t = t.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="14" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1213" endline="1219">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			AnonymousMethodExpression target = (AnonymousMethodExpression) t;
 
 			target.Block = (ParametersBlock) clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="15" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1278" endline="1287">
<![CDATA[
 
 		protected abstract string OperatorName { get; }
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Probe target = (Probe) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.ProbeType = ProbeType.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="16" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2106" endline="2114">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			value = value.Resolve (rc);
 
 			type = value.Type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="17" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="402" endline="409">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Assign _target = (Assign) t;
 
 			_target.target = target.Clone (clonectx);
 			_target.source = source.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="18" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3862" endline="3869">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Binary target = (Binary) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="19" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4242" endline="4249">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Lock target = (Lock) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.stmt = Statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="20" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1199" endline="1206">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			NullCoalescingOperator target = (NullCoalescingOperator) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="21" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8148" endline="8156">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			ElementAccess target = (ElementAccess) t;
 
 			target.Expr = Expr.Clone (clonectx);
 			if (Arguments != null)
 				target.Arguments = Arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="22" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9310" endline="9316">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			base.expr = new AddMemberAccess (ec.CurrentInitializerVariable, loc);
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="23" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="443" endline="450">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			While target = (While) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.Statement = Statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="24" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="246" endline="255">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			If target = (If) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.TrueStatement = TrueStatement.Clone (clonectx);
 			if (FalseStatement != null)
 				target.FalseStatement = FalseStatement.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="25" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1035" endline="1041">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			GotoCase target = (GotoCase) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="26" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5755" endline="5763">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Foreach target = (Foreach) t;
 
 			target.type = type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 			target.statement = statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="27" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5095" endline="5106">
<![CDATA[
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="28" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4802" endline="4810">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			TryFinally target = (TryFinally) t;
 
 			target.stmt = (Statement) stmt.Clone (clonectx);
 			if (fini != null)
 				target.fini = clonectx.LookupBlock (fini);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="29" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="761" endline="768">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CompoundAssign ctarget = (CompoundAssign) t;
 
 			ctarget.right = ctarget.source = source.Clone (clonectx);
 			ctarget.target = target.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="30" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5873" endline="5882">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			New target = (New) t;
 
 			target.RequestedType = RequestedType.Clone (clonectx);
 			if (arguments != null){
 				target.arguments = arguments.Clone (clonectx);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="31" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1606" endline="1613">
<![CDATA[
 		
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Cast target = (Cast) t;
 
 			target.target_type = target_type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="32" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="517" endline="524">
<![CDATA[
 
 		public override EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			EmitContext ec = new EmitContext (this, ig, MemberType);
 
 			ec.CurrentAnonymousMethod = host.Iterator;
 			return ec;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="33" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4620" endline="4627">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Fixed target = (Fixed) t;
 
 			target.decl = (VariableDeclaration) decl.Clone (clonectx);
 			target.statement = statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="34" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5162" endline="5169">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Using target = (Using) t;
 
 			target.decl = (VariableDeclaration) decl.Clone (clonectx);
 			target.stmt = stmt.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="35" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="502" endline="517">
<![CDATA[
 			}
 		}
 
 		//
 		// Keep resolved value because field initializers have their own rules
 		//
 		ExpressionStatement resolved;
 		IMemberContext mc;
 
 		public FieldInitializer (FieldSpec spec, Expression expression, IMemberContext mc)
 			
 		{
 			this.mc = mc;
 			if (!spec.IsStatic)
 				((FieldExpr)target).InstanceExpression = CompilerGeneratedThis.Instance;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="36" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8406" endline="8417">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, arguments,
 				InstanceExpression.CreateExpressionTree (ec),
 				new TypeOfMethod (Getter, loc));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="37" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4335" endline="4341">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unsafe target = (Unsafe) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="38" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="155" endline="164">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CompletionMemberAccess target = (CompletionMemberAccess) t;
 
 			if (targs != null)
 				target.targs = targs.Clone ();
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="39" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4745" endline="4754">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Catch target = (Catch) t;
 
 			if (type_expr != null)
 				target.type_expr = (FullNamedExpression) type_expr.Clone (clonectx);
 
 			target.block = clonectx.LookupBlock (block);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="40" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="382" endline="393">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var ms = (MethodSpec) base.InflateMember (inflator);
 			ms.inflatedMetaInfo = null;
 			ms.returnType = inflator.Inflate (returnType);
 			ms.parameters = parameters.Inflate (inflator);
 			if (IsGeneric)
 				ms.constraints = TypeParameterSpec.InflateConstraints (inflator, Constraints);
 
 			return ms;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="41" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="339" endline="347">
<![CDATA[
 
 		public void SetNestedStoryParent (AnonymousMethodStorey parentStorey)
 		{
 			Parent = parentStorey;
 			type_params = null;
 			spec.IsGeneric = false;
 			spec.DeclaringType = parentStorey.CurrentType;
 			MemberName.TypeArguments = null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="42" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5107" endline="5120">
<![CDATA[
 
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance = mg.IsInstance ?
 				mg.InstanceExpression.CreateExpressionTree (ec) 
 				new NullLiteral (loc);
 
 			var args = Arguments.CreateForExpressionTree (ec, arguments,
 				instance,
 				mg.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="43" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7056" endline="7067">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 			type = InternalType.Arglist;
 			if (Arguments != null) {
 				bool dynamic;	// Can be ignored as there is always only 1 overload
 				Arguments.Resolve (ec, out dynamic);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="44" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8080" endline="8087">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, Arguments,
 				Expr.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "ArrayIndex", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="45" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7356" endline="7364">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = ec.Module.PredefinedTypes.FieldInfo.Resolve (loc);
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="46" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="48" endline="59">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (expr_tree != null)
 				return expr_tree (ec, new TypeOfMethod (oper, loc));
 
 			Arguments args = Arguments.CreateForExpressionTree (ec, arguments,
 				new NullLiteral (loc),
 				new TypeOfMethod (oper, loc));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="47" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="811" endline="820">
<![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Emit (ec);
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temporary = new LocalTemporary (expr.Type);
 				temporary.Store (ec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="48" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4718" endline="4729">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			ResolveInstanceExpression (rc, null);
 			DoBestMemberChecks (rc, constant);
 
 			var c = constant.GetConstant (rc);
 
 			// Creates reference expression to the constant value
 			return Constant.CreateConstant (rc, constant.MemberType, c.GetValue (), loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="49" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="582" endline="594">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			For target = (For) t;
 
 			if (InitStatement != null)
 				target.InitStatement = InitStatement.Clone (clonectx);
 			if (Test != null)
 				target.Test = Test.Clone (clonectx);
 			if (Increment != null)
 				target.Increment = Increment.Clone (clonectx);
 			target.Statement = Statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="50" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="262" endline="268">
<![CDATA[
 		}
 
 		FieldSpec CreateSiteField (EmitContext ec, FullNamedExpression type)
 		{
 			var site_container = ec.CreateDynamicSite ();
 			return site_container.CreateCallSiteField (type, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="51" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2758" endline="2764">
<![CDATA[
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			TypeExpr[] ifaces = base.ResolveBaseTypes (out base_class);
 			base_type = TypeManager.value_type;
 			return ifaces;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="52" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8547" endline="8554">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			IndexerExpr target = (IndexerExpr) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="53" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="709" endline="716">
<![CDATA[
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, this.arguments,
 				InstanceExpr.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Invoke", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="54" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2004" endline="2015">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr != null) {
 				type = expr.Type;
 				eclass = expr.eclass;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="55" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1301" endline="1309">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeIs", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="56" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1469" endline="1477">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeAs", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="57" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2143" endline="2149">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			Constant new_value = value.ConvertExplicitly (in_checked_context, target_type);
 			return new_value == null ? null 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="58" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9537" endline="9549">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression e = base.DoResolve (ec);
 			if (type == null)
 				return null;
 
 			Expression previous = ec.CurrentInitializerVariable;
 			ec.CurrentInitializerVariable = new InitializerTargetExpression (this);
 			initializers.Resolve (ec);
 			ec.CurrentInitializerVariable = previous;
 			return e;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="59" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="275" endline="282">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (DoResolveCore (ec))
 				binder_expr = binder.CreateCallSiteBinder (ec, arguments);
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="60" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1846" endline="1866">
<![CDATA[
 
 		protected override TypeExpr DoResolveAsTypeStep (IMemberContext ec)
 		{
 			if (!args.Resolve (ec))
 				return null;
 
 			TypeSpec[] atypes = args.Arguments;
 
 			//
 			// Now bind the parameters
 			//
 			type = open_type.MakeGenericType (atypes);
 
 			//
 			// Check constraints when context is not method/base type
 			//
 			if (!ec.HasUnresolvedConstraints)
 				CheckConstraints (ec);
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="61" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="576" endline="586">
<![CDATA[
 
 		public static bool ImplicitStandardConversionExists (ResolveContext ec, MethodGroupExpr mg, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.delegate_type || target_type == TypeManager.multicast_delegate_type)
 				return false;
 
 			var invoke = Delegate.GetInvokeMethod (ec.Compiler, target_type);
 
 			Arguments arguments = CreateDelegateMethodArguments (invoke.Parameters, invoke.Parameters.Types, mg.Location);
 			return mg.OverloadResolve (ec, ref arguments, null, OverloadResolver.Restrictions.CovariantDelegate | OverloadResolver.Restrictions.ProbingOnly) != null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="62" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="300" endline="310">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			TypeCast child_cast = child as TypeCast;
 			if (child_cast != null) {
 				child.Type = type;
 				return child_cast.CreateExpressionTree (ec);
 			}
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="63" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="197" endline="213">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec)
 		{
 			var type = Expr.Type;
 			if (IsByRef) {
 				var ml = (IMemoryLocation) Expr;
 				ml.AddressOf (ec, AddressOp.Load);
 				type = ReferenceContainer.MakeType (type);
 			} else {
 				Expr.Emit (ec);
 			}
 
 			variable = new LocalTemporary (type);
 			variable.Store (ec);
 
 			Expr = variable;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="64" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1367" endline="1382">
<![CDATA[
 		}
 
 		public TypeSpec MemberType { get; private set; }
 
 		#endregion
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var es = (EventSpec) base.InflateMember (inflator);
 			es.MemberType = inflator.Inflate (MemberType);
 
 			if (backing_field != null)
 				es.backing_field = (FieldSpec) backing_field.InflateMember (inflator);
 
 			return es;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="65" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8418" endline="8432">
<![CDATA[
 
 		public override void Emit (EmitContext ec, bool leave_copy)
 		{
 			if (prepared) {
 				prepared_value.Emit (ec);
 			} else {
 				Invocation.EmitCall (ec, InstanceExpression, Getter, arguments, loc);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temp = new LocalTemporary (Type);
 				temp.Store (ec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="66" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="187" endline="194">
<![CDATA[
 
 		public void Load (EmitContext ec)
 		{
 			if (expr is VariableReference)
 				expr.Emit (ec);
 			else
 				LocalVariable.Emit (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="67" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="485" endline="492">
<![CDATA[
 
 		protected override bool AddMemberType (TypeContainer ds)
 		{
 			if (!AddToContainer (ds, ds.Name))
 				return false;
 			ds.NamespaceEntry.NS.AddType (ds.Definition);
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="68" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1300" endline="1308">
<![CDATA[
 
 		public override void EmitBranchable (EmitContext ec, Label label, bool on_true)
 		{
 			child.EmitBranchable (ec, label, on_true);
 
 			// Only to make verifier happy
 			if (TypeManager.IsGenericParameter (type) && child.IsNull)
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="69" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1978" endline="1989">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (type == InternalType.Null || type == TypeManager.object_type) {
 				// Optimized version, also avoids referencing literal internal type
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (this));
 				return CreateExpressionFactoryCall (ec, "Constant", args);
 			}
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="70" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5667" endline="5681">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.EventAccess;
 			type = spec.MemberType;
 
 			ResolveInstanceExpression (ec, null);
 
 			if (!ec.HasSet (ResolveContext.Options.CompoundAssignmentScope)) {
 				Error_AssignmentEventOnly (ec);
 			}
 
 			DoBestMemberChecks (ec, spec);
 			return this;
 		}		
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="71" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7228" endline="7241">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (member.IsConstructor) {
 				type = ec.Module.PredefinedTypes.ConstructorInfo.Resolve (loc);
 			} else {
 				type = ec.Module.PredefinedTypes.MethodInfo.Resolve (loc);
 			}
 
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="72" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="291" endline="306">
<![CDATA[
 
 		public void CaptureParameter (ResolveContext ec, ParameterReference param_ref)
 		{
 			ec.CurrentBlock.Explicit.HasCapturedVariable = true;
 			AddReferenceFromChildrenBlock (ec.CurrentBlock.Explicit);
 
 			if (param_ref.GetHoistedVariable (ec) != null)
 				return;
 
 			if (hoisted_params == null)
 				hoisted_params = new List<HoistedParameter> (2);
 
 			var expr = new HoistedParameter (this, param_ref);
 			param_ref.Parameter.HoistedVariant = expr;
 			hoisted_params.Add (expr);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="73" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="501" endline="507">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			var rc = new ResolveContext (ec.MemberContext);
 			var expr = new Conditional (new BooleanExpression (condition), invoke, assign, loc).Resolve (rc);
 			expr.Emit (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="74" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1258" endline="1269">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				child.CreateExpressionTree (ec),
 				new TypeOf (new TypeExpression (type, loc), loc));
 
 			if (type.IsPointer)
 				Error_PointerInsideExpressionTree (ec);
 
 			return CreateExpressionFactoryCall (ec, "Convert", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="75" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4765" endline="4786">
<![CDATA[
 
 		void DoResolveBase (ResolveContext ec)
 		{
 			VerifyAssigned (ec);
 
 			//
 			// If we are referencing a variable from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (local_info)) {
 				if (local_info.AddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (ec.IsVariableCapturingRequired) {
 					AnonymousMethodStorey storey = local_info.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureLocalVariable (ec, local_info);
 				}
 			}
 
 			eclass = ExprClass.Variable;
 			type = local_info.Type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="76" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="821" endline="844">
<![CDATA[
 		
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			prepared = prepare_for_load;
 			
 			expr.Emit (ec);
 
 			if (prepare_for_load)
 				ec.Emit (OpCodes.Dup);
 			
 			source.Emit (ec);
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temporary = new LocalTemporary (expr.Type);
 				temporary.Store (ec);
 			}
 			
 			ec.EmitStoreFromPtr (type);
 			
 			if (temporary != null) {
 				temporary.Emit (ec);
 				temporary.Release (ec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="77" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="228" endline="234">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source,
 					bool leave_copy, bool prepare_for_load)
 		{
 			InternalWrap wrap = new InternalWrap (source, expr.Type, loc);
 			((IAssignMethod) expr).EmitAssign (ec, wrap, leave_copy, false);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="78" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1333" endline="1343">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// It can be null for static initializers
 			if (base_ctor == null)
 				return;
 			
 			ec.Mark (loc);
 
 			Invocation.EmitCall (ec, new CompilerGeneratedThis (type, loc), base_ctor, argument_list, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="79" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2895" endline="2913">
<![CDATA[
 		}
 
 		// <summary>
 		//   This is used by non-static `struct' constructors which do not have an
 		//   initializer - in this case, the constructor must initialize all of the
 		//   struct's fields.  To do this, we add a "this" variable and use the flow
 		//   analysis code to ensure that it's been fully initialized before control
 		//   leaves the constructor.
 		// </summary>
 		public LocalVariable AddThisVariable (BlockContext bc, TypeContainer ds, Location l)
 		{
 			if (this_variable == null) {
 				this_variable = new LocalVariable (this, "this", LocalVariable.Flags.IsThis | LocalVariable.Flags.Used, l);
 				this_variable.Type = ds.CurrentType;
 				this_variable.PrepareForFlowAnalysis (bc);
 			}
 
 			return this_variable;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="80" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1682" endline="1692">
<![CDATA[
 
 		public bool IsThisAssigned (BlockContext ec, Block block)
 		{
 			if (VariableInfo == null)
 				throw new Exception ();
 
 			if (!ec.DoFlowAnalysis || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			return VariableInfo.TypeInfo.IsFullyInitialized (ec, VariableInfo, block.StartLocation);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="81" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="771" endline="790">
<![CDATA[
 		
 		//
 		// According to section 16.3.1 (using-alias-directive), the namespace-or-type-name is
 		// resolved as if the immediately containing namespace body has no using-directives.
 		//
 		// Section 16.3.2 says that the same rule is applied when resolving the namespace-name
 		// in the using-namespace-directive.
 		//
 		// To implement these rules, the expressions in the using directives are resolved using 
 		// the "doppelganger" (ghostly bodiless duplicate).
 		//
 		NamespaceEntry doppelganger;
 		NamespaceEntry Doppelganger {
 			get {
 				if (!IsImplicit && doppelganger == null) {
 					doppelganger = new NamespaceEntry (ctx, ImplicitParent, file, ns, true);
 					doppelganger.using_aliases = using_aliases;
 				}
 				return doppelganger;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="82" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="154" endline="175">
<![CDATA[
 
 		public string Name { get; set; }
 
 		protected override Expression DoResolve (ResolveContext unused)
 		{
 			if (type != null)
 				return expr;
 
 			var opt = ResolveContext.Options.ConstantScope;
 			if (field is EnumMember)
 				opt |= ResolveContext.Options.EnumScope;
 
 			//
 			// Use a context in which the constant was declared and
 			// not the one in which is referenced
 			//
 			var rc = new ResolveContext (field, opt);
 			expr = DoResolveInitializer (rc);
 			type = expr.Type;
 
 			return expr;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="83" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="799" endline="811">
<![CDATA[
 		}
 
 		public NamespaceEntry ImplicitParent {
 			get {
 				if (parent == null)
 					return null;
 				if (implicit_parent == null) {
 					implicit_parent = (parent.NS == ns.Parent)
 						? parent
 						
 				}
 				return implicit_parent;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="84" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5600" endline="5613">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args;
 			if (method == null) {
 				args = new Arguments (1);
 				args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			} else {
 				args = Arguments.CreateForExpressionTree (ec,
 					arguments, new TypeOfMethod (method, loc));
 			}
 
 			return CreateExpressionFactoryCall (ec, "New", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="85" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4942" endline="4969">
<![CDATA[
 
 		bool DoResolveBase (ResolveContext ec)
 		{
 			type = pi.ParameterType;
 			eclass = ExprClass.Variable;
 
 			//
 			// If we are referencing a parameter from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (pi)) {
 				if (Parameter.HasAddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (IsRef) {
 					ec.Report.Error (1628, loc,
 						"Parameter `{0}' cannot be used inside `{1}' when using `ref' or `out' modifier",
 						Name, ec.CurrentAnonymousMethod.ContainerType);
 				}
 
 				if (ec.IsVariableCapturingRequired && !pi.Block.ParametersBlock.IsExpressionTree) {
 					AnonymousMethodStorey storey = pi.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureParameter (ec, this);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="86" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="276" endline="285">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			base.DoResolve (rc);
 
 			if (type != null)
 				type = NullableInfo.GetUnderlyingType (type);
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="87" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="89" endline="102">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant) {
 				method.Compiler.Report.Warning (3023, 1, a.Location,
 					"CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead");
 			}
 
 			// This occurs after Warning -28
 			if (builder == null)
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="88" nfragments="2" Csharpe_files="1" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6051" endline="6066">
<![CDATA[
 
 void push_current_class (TypeContainer tc, object partial_token)
 {
 	if (RootContext.EvalMode){
 		tc.ModFlags = (tc.ModFlags & ~(Modifiers.PRIVATE|Modifiers.INTERNAL)) | Modifiers.PUBLIC;
 		undo.AddTypeContainer (current_container, tc);
 	}
 
 	if (partial_token != null)
 		current_container = current_container.AddPartial (tc);
 	else
 		current_container = current_container.AddTypeContainer (tc);
 
 	++lexer.parsing_declaration;
 	current_class = tc;
 }
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="89" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="39" endline="49">
<![CDATA[
 
 		protected override TypeExpr DoResolveAsTypeStep (IMemberContext ec)
 		{
 			var type = ec.Module.PredefinedTypes.Nullable.Resolve (loc);
 			if (type == null)
 				return null;
 
 			TypeArguments args = new TypeArguments (underlying);
 			GenericTypeExpr ctype = new GenericTypeExpr (type, args, loc);
 			return ctype.ResolveAsTypeTerminal (ec, false);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="90" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8088" endline="8101">
<![CDATA[
 
 		Expression MakePointerAccess (ResolveContext ec, TypeSpec type)
 		{
 			if (Arguments.Count != 1){
 				ec.Report.Error (196, loc, "A pointer must be indexed by only one value");
 				return null;
 			}
 
 			if (Arguments [0] is NamedArgument)
 				Error_NamedArgument ((NamedArgument) Arguments[0], ec.Report);
 
 			Expression p = new PointerArithmetic (Binary.Operator.Addition, Expr, Arguments [0].Expr.Resolve (ec), type, loc);
 			return new Indirection (p, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="91" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="167" endline="179">
<![CDATA[
 
 		// <summary>
 		//   Ends a code branching.  Merges the state of locals and parameters
 		//   from all the children of the ending branching.
 		// </summary>
 		public bool EndFlowBranching ()
 		{
 			FlowBranching old = current_flow_branching;
 			current_flow_branching = current_flow_branching.Parent;
 
 			FlowBranching.UsageVector vector = current_flow_branching.MergeChild (old);
 			return vector.IsUnreachable;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="92" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="570" endline="584">
<![CDATA[
 		}
 
 		//
 		// Resolves all type parameter constraints
 		//
 		public bool ResolveConstraints (IMemberContext context)
 		{
 			if (constraints != null)
 				return constraints.Resolve (context, this);
 
 			if (spec.BaseType == null)
 				spec.BaseType = TypeManager.object_type;
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="93" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5793" endline="5809">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 
 			//
 			// Don't capture temporary variables except when using
 			// iterator redirection
 			//
 			if (ec.CurrentAnonymousMethod != null && ec.CurrentAnonymousMethod.IsIterator && ec.IsVariableCapturingRequired) {
 				AnonymousMethodStorey storey = li.Block.Explicit.CreateAnonymousMethodStorey (ec);
 				storey.CaptureLocalVariable (ec, li);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="94" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="617" endline="632">
<![CDATA[
 
 		/// <summary>
 		/// Returns custom name of indexer
 		/// </summary>
 		public string GetIndexerAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments [0].Expr).GetValue () as string;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="95" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="633" endline="648">
<![CDATA[
 
 		/// <summary>
 		/// Returns condition of ConditionalAttribute
 		/// </summary>
 		public string GetConditionalAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments[0].Expr).GetValue () as string;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="96" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="612" endline="623">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			if (goto_stmt.Target != stmt.Name)
 				return Parent.AddGotoOrigin (vector, goto_stmt);
 
 			// backward jump
 			goto_stmt.SetResolvedTarget (stmt);
 			actual.MergeOrigins (vector.Clone ());
 
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="97" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2157" endline="2189">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// Creates anonymous method storey in current block
 		//
 		public AnonymousMethodStorey CreateAnonymousMethodStorey (ResolveContext ec)
 		{
 			//
 			// An iterator has only 1 storey block
 			//
 			if (ec.CurrentIterator != null)
 			    return ec.CurrentIterator.Storey;
 
 			//
 			// When referencing a variable in iterator storey from children anonymous method
 			//
 			if (ParametersBlock.am_storey is IteratorStorey) {
 				return ParametersBlock.am_storey;
 			}
 
 			if (am_storey == null) {
 				MemberBase mc = ec.MemberContext as MemberBase;
 
 				//
 				// Creates anonymous method storey for this block
 				//
 				am_storey = new AnonymousMethodStorey (this, ec.CurrentMemberDefinition.Parent.PartialContainer, mc, ec.CurrentTypeParameters, "AnonStorey");
 			}
 
 			return am_storey;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="98" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1693" endline="1700">
<![CDATA[
 
 		public bool IsAssigned (BlockContext ec)
 		{
 			if (VariableInfo == null)
 				throw new Exception ();
 
 			return !ec.DoFlowAnalysis || ec.CurrentBranching.IsAssigned (VariableInfo);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="99" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="469" endline="484">
<![CDATA[
 
 		//
 		// Makes const data field inside internal type container
 		//
 		public FieldSpec MakeStaticData (byte[] data, Location loc)
 		{
 			if (static_data == null) {
 				static_data = new StaticDataContainer (this);
 				static_data.CreateType ();
 				static_data.DefineType ();
 
 				AddCompilerGeneratedClass (static_data);
 			}
 
 			return static_data.DefineInitializedData (data, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="100" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="469" endline="479">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (user_operator != null)
 				return user_operator.CreateExpressionTree (ec);
 
 			if (Oper == Operator.UnaryPlus)
 				return Expr.CreateExpressionTree (ec);
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="101" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3058" endline="3074">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// When best candidate is already know this factory can be used
 		// to avoid expensive overload resolution to be called
 		//
 		// NOTE
 		//
 		public static MethodGroupExpr CreatePredefined (MethodSpec best, TypeSpec queriedType, Location loc)
 		{
 			return new MethodGroupExpr (best, queriedType, loc) {
 				best_candidate = best,
 				best_candidate_return = best.ReturnType
 			};
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="102" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4001" endline="4011">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			// System.Reflection.Emit automatically emits a 'leave' at the end of a try clause
 			// So, ensure there's some IL code after this statement.
 			if (!code_follows && resume_points == null && ec.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				ec.NeedReturnLabel ();
 
 			iter = ec.CurrentIterator;
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="103" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1379" endline="1387">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (Value >= 0 && type == TypeManager.uint64_type) {
 				return new ULongConstant ((ulong) Value, loc).Resolve (rc);
 			}
 
 			return base.ConvertImplicitly (rc, type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="104" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4554" endline="4562">
<![CDATA[
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.AddressOf (ec, mode);
 				return;
 			}
 
 			Variable.EmitAddressOf (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="105" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="97" endline="104">
<![CDATA[
 
 		public virtual Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (ArgType == AType.Default)
 				ec.Report.Error (854, Expr.Location, "An expression tree cannot contain an invocation which uses optional parameter");
 
 			return Expr.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="106" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="408" endline="415">
<![CDATA[
 
 		public TypeSpec Resolve (Location loc)
 		{
 			if (type == null)
 				type = Resolve (module, kind, ns, name, arity, loc);
 
 			return type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="107" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9525" endline="9536">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (base.CreateExpressionTree (ec)));
 			if (!initializers.IsEmpty)
 				args.Add (new Argument (initializers.CreateExpressionTree (ec)));
 
 			return CreateExpressionFactoryCall (ec,
 				initializers.IsCollectionInitializer ? "ListInit" 
 				args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="108" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="445" endline="458">
<![CDATA[
 		
 		public void AddMethod (MethodOrOperator method)
 		{
 			if (!AddToContainer (method, method.MemberName.Basename))
 				return;
 			
 			if (methods == null)
 				methods = new List<MemberCore> ();
 
 			if (method.MemberName.Left != null) 
 				AddMemberToList (method, methods, true);
 			else 
 				AddMemberToList (method, methods, false);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="109" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="128" endline="148">
<![CDATA[
 
 		void AddModuleCharSet (ResolveContext rc)
 		{
 			const string dll_import_char_set = "CharSet";
 
 			//
 			// Only when not customized by user
 			//
 			if (HasField (dll_import_char_set))
 				return;
 
 			if (!rc.Module.PredefinedTypes.CharSet.IsDefined) {
 				return;
 			}
 
 			if (NamedArguments == null)
 				NamedArguments = new Arguments (1);
 
 			var value = Constant.CreateConstant (rc, rc.Module.PredefinedTypes.CharSet.TypeSpec, rc.Module.DefaultCharSet, Location);
 			NamedArguments.Add (new NamedArgument (dll_import_char_set, loc, value));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="110" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1052" endline="1072">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			if (expr == null) {
 				ec.CurrentBranching.CurrentUsageVector.Goto ();
 				return ec.CurrentBranching.CheckRethrow (loc);
 			}
 
 			expr = expr.Resolve (ec, ResolveFlags.Type | ResolveFlags.VariableOrValue);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			if (expr == null)
 				return false;
 
 			if (Convert.ImplicitConversionExists (ec, expr, TypeManager.exception_type))
 				expr = Convert.ImplicitConversion (ec, expr, TypeManager.exception_type, loc);
 			else
 				ec.Report.Error (155, expr.Location, "The type caught or thrown must be derived from System.Exception");
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="111" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="149" endline="156">
<![CDATA[
 
 		public Attribute Clone ()
 		{
 			Attribute a = new Attribute (ExplicitTarget, expression, null, loc, nameEscaped);
 			a.PosArguments = PosArguments;
 			a.NamedArguments = NamedArguments;
 			return a;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="112" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="338" endline="347">
<![CDATA[
 
 		public TypeParameter (TypeParameterSpec spec, DeclSpace parent, TypeSpec parentSpec, MemberName name, Attributes attrs)
 			
 		{
 			this.spec = new TypeParameterSpec (parentSpec, spec.DeclaredPosition, spec.MemberDefinition, spec.SpecialConstraint, spec.Variance, null) {
 				BaseType = spec.BaseType,
 				InterfacesDefined = spec.InterfacesDefined,
 				TypeArguments = spec.TypeArguments
 			};
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="113" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6994" endline="7007">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 			type = ec.Module.PredefinedTypes.RuntimeArgumentHandle.Resolve (loc);
 
 			if (ec.HasSet (ResolveContext.Options.FieldInitializerScope) || !ec.CurrentBlock.ParametersBlock.Parameters.HasArglist) {
 				ec.Report.Error (190, loc,
 					"The __arglist construct is valid only within a variable argument method");
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="114" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="521" endline="532">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			LabeledStatement stmt = Block == null ? null 
 			if (stmt == null)
 				return Parent.AddGotoOrigin (vector, goto_stmt);
 
 			// forward jump
 			goto_stmt.SetResolvedTarget (stmt);
 			stmt.AddUsageVector (vector);
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="115" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4160" endline="4177">
<![CDATA[
 		
 		protected override void EmitPreTryBody (EmitContext ec)
 		{
 			expr_copy.EmitAssign (ec, expr);
 
 			if (lock_taken != null) {
 				//
 				// Initialize ref variable
 				//
 				lock_taken.EmitAssign (ec, new BoolLiteral (false, loc));
 			} else {
 				//
 				// Monitor.Enter (expr_copy)
 				//
 				expr_copy.Emit (ec);
 				ec.Emit (OpCodes.Call, TypeManager.void_monitor_enter_object);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="116" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="952" endline="967">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement exit_stmt)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddReturnOrigin (vector, exit_stmt);
 				if (errors == Report.Errors)
 					exit_stmt.Error_FinallyClause (Report);
 			} else {
 				saved_origins = new ReturnOrigin (saved_origins, vector, exit_stmt);
 			}
 
 			// sets ec.NeedReturnLabel()
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="117" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="283" endline="304">
<![CDATA[
 
 		protected bool DoResolveCore (ResolveContext rc)
 		{
 			int errors = rc.Report.Errors;
 			var pt = rc.Module.PredefinedTypes;
 
 			binder_type = pt.Binder.Resolve (loc);
 			pt.CallSite.Resolve (loc);
 			pt.CallSiteGeneric.Resolve (loc);
 
 			eclass = ExprClass.Value;
 
 			if (type == null)
 				type = InternalType.Dynamic;
 
 			if (rc.Report.Errors == errors)
 				return true;
 
 			rc.Report.Error (1969, loc,
 				"Dynamic operation cannot be compiled without `Microsoft.CSharp.dll' assembly reference");
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="118" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="796" endline="815">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			IteratorHost = (IteratorStorey) block.TopBlock.AnonymousMethodStorey;
 
 			BlockContext ctx = new BlockContext (ec, block, ReturnType);
 			ctx.CurrentAnonymousMethod = this;
 
 			ctx.StartFlowBranching (this, ec.CurrentBranching);
 			Block.Resolve (ctx);
 			ctx.EndFlowBranching ();
 
 			var move_next = new IteratorMethod (IteratorHost, new TypeExpression (TypeManager.bool_type, loc),
 				Modifiers.PUBLIC, new MemberName ("MoveNext", Location));
 			move_next.Block.AddStatement (new MoveNextMethodStatement (this));
 			IteratorHost.AddMethod (move_next);
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="119" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="598" endline="613">
<![CDATA[
 
 		public ExpressionStatement CreateExpressionTreeVariable (BlockContext ec)
 		{
 			if ((modFlags & Modifier.ISBYREF) != 0)
 				ec.Report.Error (1951, Location, "An expression tree parameter cannot use `ref' or `out' modifier");
 
 			expr_tree_variable = TemporaryVariableReference.Create (ResolveParameterExpressionType (ec, Location).Type, ec.CurrentBlock.ParametersBlock, Location);
 			expr_tree_variable = (TemporaryVariableReference) expr_tree_variable.Resolve (ec);
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (new TypeOf (
 				new TypeExpression (parameter_type, Location), Location)));
 			arguments.Add (new Argument (new StringConstant (Name, Location)));
 			return new SimpleAssign (ExpressionTreeVariableReference (),
 				Expression.CreateExpressionFactoryCall (ec, "Parameter", null, arguments, Location));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="120" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7935" endline="7950">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, true))
 				Expr = Expr.Resolve (ec);
 			
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="121" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7871" endline="7889">
<![CDATA[
 
 		protected virtual void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			var nested = MemberCache.FindNestedType (expr_type, Name, -System.Math.Max (1, Arity));
 
 			if (nested != null) {
 				Error_TypeArgumentsCannotBeUsed (rc.Compiler.Report, expr.Location, nested, Arity);
 				return;
 			}
 
 			var any_other_member = MemberLookup (null, rc.CurrentType, expr_type, Name, 0, MemberLookupRestrictions.None, loc);
 			if (any_other_member != null) {
 				any_other_member.Error_UnexpectedKind (rc.Compiler.Report, null, "type", loc);
 				return;
 			}
 
 			rc.Compiler.Report.Error (426, loc, "The nested type `{0}' does not exist in the type `{1}'",
 				Name, expr_type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="122" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6689" endline="6723">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (type != null)
 				return this;
 
 			dimensions = rank.Dimension;
 
 			best_type_inference = new InferenceContext ();
 
 			if (!ResolveInitializers (ec))
 				return null;
 
 			best_type_inference.FixAllTypes (ec);
 			array_element_type = best_type_inference.InferredTypeArguments[0];
 			best_type_inference = null;
 
 			if (array_element_type == null || array_element_type == InternalType.MethodGroup || array_element_type == InternalType.AnonymousMethod ||
 				arguments.Count != rank.Dimension) {
 				ec.Report.Error (826, loc,
 					"The type of an implicitly typed array cannot be inferred from the initializer. Try specifying array type explicitly");
 				return null;
 			}
 
 			//
 			// At this point we found common base type for all initializer elements
 			// but we have to be sure that all static initializer elements are of
 			// same type
 			//
 			UnifyInitializerElement (ec);
 
 			type = ArrayContainer.MakeType (array_element_type, dimensions);
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="123" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8223" endline="8231">
<![CDATA[
 
 		//
 		// Load the array arguments into the stack.
 		//
 		void LoadArrayAndArguments (EmitContext ec)
 		{
 			ea.Expr.Emit (ec);
 			ea.Arguments.Emit (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="124" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9235" endline="9242">
<![CDATA[
 	
 		public override void EmitStatement (EmitContext ec)
 		{
 			if (source is CollectionOrObjectInitializers)
 				source.Emit (ec);
 			else
 				base.EmitStatement (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="125" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5694" endline="5704">
<![CDATA[
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			if (leave_copy || !prepare_for_load)
 				throw new NotImplementedException ("EventExpr
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (source));
 			Invocation.EmitCall (ec, InstanceExpression, op, args, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="126" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4165" endline="4180">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label end_target = ec.DefineLabel ();
 
 			//
 			// Emit and duplicate left argument
 			//
 			arguments [0].Expr.Emit (ec);
 			ec.Emit (OpCodes.Dup);
 			arguments.RemoveAt (0);
 
 			oper_expr.EmitBranchable (ec, end_target, true);
 			base.Emit (ec);
 			ec.MarkLabel (end_target);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="127" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="841" endline="852">
<![CDATA[
 	
 		protected void Error_CannotModifyIntermediateExpressionValue (ResolveContext ec)
 		{
 			ec.Report.SymbolRelatedToPreviousError (type);
 			if (ec.CurrentInitializerVariable != null) {
 				ec.Report.Error (1918, loc, "Members of value type `{0}' cannot be assigned using a property `{1}' object initializer",
 					TypeManager.CSharpName (type), GetSignatureForError ());
 			} else {
 				ec.Report.Error (1612, loc, "Cannot modify a value type return value of `{0}'. Consider storing the value in a temporary variable",
 					GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="128" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="83" endline="97">
<![CDATA[
 
 		/// <summary>
 		///  Emits the field value by evaluating the expression
 		/// </summary>
 		public override void Emit ()
 		{
 			var c = ((ConstSpec) spec).Value as Constant;
 			if (c.Type == TypeManager.decimal_type) {
 				Module.PredefinedAttributes.DecimalConstant.EmitAttribute (FieldBuilder, (decimal) c.GetValue (), c.Location);
 			} else {
 				FieldBuilder.SetConstant (c.GetValue ());
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="129" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2041" endline="2055">
<![CDATA[
 
 		public override bool ResolveUnreachable (BlockContext ec, bool warn)
 		{
 			unreachable_shown = true;
 			unreachable = true;
 
 			if (warn)
 				ec.Report.Warning (162, 2, loc, "Unreachable code detected");
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Block, loc);
 			bool ok = Resolve (ec);
 			ec.KillFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="130" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="35" endline="59">
<![CDATA[
 
 		/// <summary>
 		///   We already know that the statement is unreachable, but we still
 		///   need to resolve it to catch errors.
 		/// </summary>
 		public virtual bool ResolveUnreachable (BlockContext ec, bool warn)
 		{
 			//
 			// This conflicts with csc's way of doing this, but IMHO it's
 			// the right thing to do.
 			//
 			// If something is unreachable, we still check whether it's
 			// correct.  This means that you cannot use unassigned variables
 			// in unreachable code, for instance.
 			//
 
 			if (warn)
 				ec.Report.Warning (162, 2, loc, "Unreachable code detected");
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Block, loc);
 			bool ok = Resolve (ec);
 			ec.KillFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="131" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="856" endline="868">
<![CDATA[
 
 		protected override void EmitOperator (EmitContext ec, TypeSpec l)
 		{
 			if (user_operator != null) {
 				user_operator.Emit (ec);
 				return;
 			}
 
 			if (TypeManager.IsNullableType (l))
 				l = TypeManager.GetTypeArguments (l) [0];
 
 			base.EmitOperator (ec, l);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="132" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1476" endline="1491">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.IndexerName) {
 				if (IsExplicitImpl) {
 					Report.Error (415, a.Location,
 						"The `{0}' attribute is valid only on an indexer that is not an explicit interface member declaration",
 						TypeManager.CSharpName (a.Type));
 				}
 
 				// Attribute was copied to container
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="133" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8102" endline="8117">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			type = Expr.Type;
 
 			// TODO
 			var res = CreateAccessExpression (ec);
 			if (res == null)
 				return null;
 
 			return res.Resolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="134" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="816" endline="838">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// Load Iterator storey instance
 			//
 			IteratorHost.Instance.Emit (ec);
 
 			//
 			// Initialize iterator PC when it's unitialized
 			//
 			if (IsEnumerable) {
 				ec.Emit (OpCodes.Dup);
 				ec.EmitInt ((int)State.Uninitialized);
 
 				var field = IteratorHost.PC.Spec;
 				if (Storey.MemberName.IsGeneric) {
 					field = MemberCache.GetMember (Storey.Instance.Type, field);
 				}
 
 				ec.Emit (OpCodes.Stfld, field);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="135" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1482" endline="1492">
<![CDATA[
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			// boxing is side-effectful, since it involves runtime checks, except when boxing to Object or ValueType
 			// so, we need to emit the box+pop instructions in most cases
 			if (TypeManager.IsStruct (child.Type) &&
 			    (type == TypeManager.object_type || type == TypeManager.value_type))
 				child.EmitSideEffect (ec);
 			else
 				base.EmitSideEffect (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="136" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="96" endline="105">
<![CDATA[
 
 		public BlockContext (ResolveContext rc, ExplicitBlock block, TypeSpec returnType)
 			
 		{
 			if (rc.IsUnsafe)
 				flags |= ResolveContext.Options.UnsafeScope;
 
 			if (rc.HasSet (ResolveContext.Options.CheckedScope))
 				flags |= ResolveContext.Options.CheckedScope;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="137" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1624" endline="1640">
<![CDATA[
 
 		void EmitIndexerName ()
 		{
 			if (!seen_normal_indexers)
 				return;
 
 			PredefinedAttribute pa = Module.PredefinedAttributes.DefaultMember;
 			if (pa.Constructor == null &&
 				!pa.ResolveConstructor (Location, TypeManager.string_type))
 				return;
 
 			var encoder = new AttributeEncoder ();
 			encoder.Encode (GetAttributeDefaultMember ());
 			encoder.EncodeEmptyNamedArguments ();
 
 			pa.EmitAttribute (TypeBuilder, encoder);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="138" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5871" endline="5887">
<![CDATA[
 
 		public bool InferType (ResolveContext ec, Expression right_side)
 		{
 			if (type != null)
 				throw new InternalErrorException ("An implicitly typed local variable could not be redefined");
 			
 			type = right_side.Type;
 			if (type == InternalType.Null || type == TypeManager.void_type || type == InternalType.AnonymousMethod || type == InternalType.MethodGroup) {
 				ec.Report.Error (815, loc,
 					"An implicitly typed local variable declaration cannot be initialized with `{0}'",
 					type.GetSignatureForError ());
 				return false;
 			}
 
 			eclass = ExprClass.Variable;
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="139" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1247" endline="1268">
<![CDATA[
 
 		void DoEmit (EmitContext ec, bool is_expr)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			if (is_expr) {
 				underlying.Emit (ec);
 				ec.Emit (OpCodes.Br_S, end_label);
 			} else {
 				underlying.EmitStatement (ec);
 			}
 
 			ec.MarkLabel (is_null_label);
 			if (is_expr)
 				LiftedNull.Create (type, loc).Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="140" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2843" endline="2853">
<![CDATA[
 
 		public virtual MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			if (left != null && left.IsNull && TypeManager.IsReferenceType (left.Type)) {
 				ec.Report.Warning (1720, 1, left.Location,
 					"Expression will always cause a `{0}'", "System.NullReferenceException");
 			}
 
 			InstanceExpression = left;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="141" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="875" endline="895">
<![CDATA[
 
 		public override TypeSpec AddDelegate (Delegate d)
 		{
 			TypeSpec inflated;
 
 			base.AddDelegate (d);
 
 			// Inflated type instance has to be updated manually
 			if (instance_type is InflatedTypeSpec) {
 				var inflator = new TypeParameterInflator (instance_type, TypeParameterSpec.EmptyTypes, TypeSpec.EmptyTypes);
 				inflated = (TypeSpec) d.CurrentType.InflateMember (inflator);
 				instance_type.MemberCache.AddMember (inflated);
 
 				//inflator = new TypeParameterInflator (d.Parent.CurrentType, TypeParameterSpec.EmptyTypes, TypeSpec.EmptyTypes);
 				//d.Parent.CurrentType.MemberCache.AddMember (d.CurrentType.InflateMember (inflator));
 			} else {
 				inflated = d.CurrentType;
 			}
 
 			return inflated;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="142" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="380" endline="409">
<![CDATA[
 
 		//
 		// Initializes all hoisted variables
 		//
 		public void EmitStoreyInstantiation (EmitContext ec, ExplicitBlock block)
 		{
 			// There can be only one instance variable for each storey type
 			if (Instance != null)
 				throw new InternalErrorException ();
 
 			SymbolWriter.OpenCompilerGeneratedBlock (ec);
 
 			//
 			// Create an instance of a storey
 			//
 			var storey_type_expr = CreateStoreyTypeExpression (ec);
 
 			ResolveContext rc = new ResolveContext (ec.MemberContext);
 			rc.CurrentBlock = block;
 			Expression e = new New (storey_type_expr, null, Location).Resolve (rc);
 			e.Emit (ec);
 
 			Instance = new LocalTemporary (storey_type_expr.Type);
 			Instance.Store (ec);
 
 			EmitHoistedFieldsInitialization (rc, ec);
 
 			SymbolWriter.DefineScopeVariable (ID, Instance.Builder);
 			SymbolWriter.CloseCompilerGeneratedBlock (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="143" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2012" endline="2031">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			// Check this name against other containers
 			NamespaceEntry.NS.VerifyClsCompliance ();
 
 			// Check all container names for user classes
 			if (Kind != MemberKind.Delegate)
 				MemberCache.VerifyClsCompliance (Definition, Report);
 
 			if (BaseType != null && !BaseType.IsCLSCompliant ()) {
 				Report.Warning (3009, 1, Location, "`{0}'
 					GetSignatureForError (), BaseType.GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="144" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="738" endline="746">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// Invocation on delegates call the virtual Invoke member
 			// so we are always `instance' calls
 			//
 			Invocation.EmitCall (ec, InstanceExpr, method, arguments, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="145" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="756" endline="762">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddBreakOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="146" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1172" endline="1186">
<![CDATA[
 	}
 
 	/// <summary>
 	/// 	This is an explicit numeric cast from a Decimal
 	/// </summary>
 	public class CastFromDecimal 
 	{
 		static Dictionary<TypeSpec, MethodSpec> operators;
 
 		public CastFromDecimal (Expression child, TypeSpec return_type)
 			
 		{
 			if (child.Type != TypeManager.decimal_type)
 				throw new ArgumentException ("Expected decimal child " + child.Type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="147" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4321" endline="4329">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			if (ec.CurrentIterator != null)
 				ec.Report.Error (1629, loc, "Unsafe code may not appear in iterators");
 
 			using (ec.Set (ResolveContext.Options.UnsafeScope))
 				return Block.Resolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="148" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4178" endline="4192">
<![CDATA[
 
 		protected override void EmitTryBody (EmitContext ec)
 		{
 			//
 			// Monitor.Enter (expr_copy, ref lock_taken)
 			//
 			if (lock_taken != null) {
 				expr_copy.Emit (ec);
 				lock_taken.LocalInfo.CreateBuilder (ec);
 				lock_taken.AddressOf (ec, AddressOp.Load);
 				ec.Emit (OpCodes.Call, TypeManager.void_monitor_enter_object);
 			}
 
 			Statement.Emit (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="149" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="732" endline="746">
<![CDATA[
 
 		public void EmitHoistingAssignment (EmitContext ec)
 		{
 			//
 			// Remove hoisted redirection to emit assignment from original parameter
 			//
 			HoistedVariable temp = parameter.Parameter.HoistedVariant;
 			parameter.Parameter.HoistedVariant = null;
 
 			Assign a = new HoistedFieldAssign (GetFieldExpression (ec), parameter);
 			if (a.Resolve (new ResolveContext (ec.MemberContext)) != null)
 				a.EmitStatement (ec);
 
 			parameter.Parameter.HoistedVariant = temp;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="150" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="920" endline="935">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddBreakOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new BreakOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="151" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="573" endline="589">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.DefaultMember) {
 				if (Indexers != null) {
 					Report.Error (646, a.Location, "Cannot specify the `DefaultMember' attribute on type containing an indexer");
 					return;
 				}
 			}
 
 			if (a.Type == pa.Required) {
 				Report.Error (1608, a.Location, "The RequiredAttribute attribute is not permitted on C# types");
 				return;
 			}
 
 			TypeBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		} 
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="152" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4765" endline="4787">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			ec.StartFlowBranching (this);
 
 			if (!stmt.Resolve (ec))
 				ok = false;
 
 			if (ok)
 				ec.CurrentBranching.CreateSibling (fini, FlowBranching.SiblingType.Finally);
 			using (ec.With (ResolveContext.Options.FinallyScope, true)) {
 				if (!fini.Resolve (ec))
 					ok = false;
 			}
 
 			ec.EndFlowBranching ();
 
 			ok &= base.Resolve (ec);
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="153" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6893" endline="6914">
<![CDATA[
 
 		public virtual void ResolveBase (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 			type = ec.CurrentType;
 
 			if (!IsThisAvailable (ec, false)) {
 				Error_ThisNotAvailable (ec);
 				return;
 			}
 
 			var block = ec.CurrentBlock;
 			if (block != null) {
 				if (block.ParametersBlock.TopBlock.ThisVariable != null)
 					variable_info = block.ParametersBlock.TopBlock.ThisVariable.VariableInfo;
 
 				AnonymousExpression am = ec.CurrentAnonymousMethod;
 				if (am != null && ec.IsVariableCapturingRequired) {
 					am.SetHasThisAccess ();
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="154" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6936" endline="6954">
<![CDATA[
 
 		override public Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			ResolveBase (ec);
 
 			if (variable_info != null)
 				variable_info.SetAssigned (ec);
 
 			if (type.IsClass){
 				if (right_side == EmptyExpression.UnaryAddress)
 					ec.Report.Error (459, loc, "Cannot take the address of `this' because it is read-only");
 				else if (right_side == EmptyExpression.OutAccess.Instance)
 					ec.Report.Error (1605, loc, "Cannot pass `this' as a ref or out argument because it is read-only");
 				else
 					ec.Report.Error (1604, loc, "Cannot assign to `this' because it is read-only");
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="155" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3229" endline="3251">
<![CDATA[
 
 		//
 		// Extension methods lookup after ordinary methods candidates failed to apply
 		//
 		public virtual MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			if (InstanceExpression == null)
 				return null;
 
 			InstanceExpression = InstanceExpression.Resolve (rc);
 			if (!IsExtensionMethodArgument (InstanceExpression))
 				return null;
 
 			int arity = type_arguments == null ? 0 
 			NamespaceEntry methods_scope = null;
 			var methods = rc.LookupExtensionMethod (InstanceExpression.Type, Methods[0].Name, arity, ref methods_scope);
 			if (methods == null)
 				return null;
 
 			var emg = new ExtensionMethodGroupExpr (methods, methods_scope, InstanceExpression, loc);
 			emg.SetTypeArguments (rc, type_arguments);
 			return emg;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="156" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2188" endline="2238">
<![CDATA[
 
 		protected virtual void Error_TypeOrNamespaceNotFound (IMemberContext ec)
 		{
 			if (ec.CurrentType != null) {
 				if (ec.CurrentMemberDefinition != null) {
 					MemberCore mc = ec.CurrentMemberDefinition.Parent.GetDefinition (Name);
 					if (mc != null) {
 						Error_UnexpectedKind (ec.Compiler.Report, mc, "type", GetMemberType (mc), loc);
 						return;
 					}
 				}
 
 				/*
 								// TODO MemberCache
  
 								string ns = ec.CurrentType.Namespace;
 								string fullname = (ns.Length > 0) ? ns + "." + Name 
 								foreach (Assembly a in GlobalRootNamespace.Instance.Assemblies) {
 									var type = a.GetType (fullname);
 									if (type != null) {
 										ec.Compiler.Report.SymbolRelatedToPreviousError (type);
 										Expression.ErrorIsInaccesible (loc, TypeManager.CSharpName (type), ec.Compiler.Report);
 										return;
 									}
 								}
 
 								if (ec.CurrentTypeDefinition != null) {
 									TypeSpec t = ec.CurrentTypeDefinition.LookupAnyGeneric (Name);
 									if (t != null) {
 										Namespace.Error_InvalidNumberOfTypeArguments (ec.Compiler.Report, t, loc);
 										return;
 									}
 								}
 				*/
 			}
 
 			FullNamedExpression retval = ec.LookupNamespaceOrType (Name, -System.Math.Max (1, Arity), loc, true);
 			if (retval != null) {
 				Error_TypeArgumentsCannotBeUsed (ec.Compiler.Report, loc, retval.Type, Arity);
 /*
 				var te = retval as TypeExpr;
 				if (HasTypeArguments && te != null && !te.Type.IsGeneric)
 					retval.Error_TypeArgumentsCannotBeUsed (ec.Compiler.Report, loc);
 				else
 					Namespace.Error_InvalidNumberOfTypeArguments (ec.Compiler.Report, retval.Type, loc);
 */
 				return;
 			}
 
 			NamespaceEntry.Error_NamespaceNotFound (loc, Name, ec.Compiler.Report);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="157" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="450" endline="463">
<![CDATA[
 
 		protected override void CreateArguments (ResolveContext ec, Parameter parameter, ref Arguments args)
 		{
 			base.CreateArguments (ec, parameter, ref args);
 
 			if (element_selector != null) {
 				LambdaExpression lambda = new LambdaExpression (element_selector.Location);
 
 				element_block.SetParameter (parameter.Clone ());
 				lambda.Block = element_block;
 				lambda.Block.AddStatement (new ContextualReturn (element_selector));
 				args.Add (new Argument (lambda));
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="158" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="907" endline="919">
<![CDATA[
 
 		public override bool AddResumePoint (ResumableStatement stmt, Location loc, out int pc)
 		{
 			int errors = Report.Errors;
 			Parent.AddResumePoint (this.stmt, loc, out pc);
 			if (errors == Report.Errors) {
 				if (finally_vector == null)
 					this.stmt.AddResumePoint (stmt, pc);
 				else
 					Report.Error (1625, loc, "Cannot yield in the body of a finally clause");
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="159" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="936" endline="951">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddContinueOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new ContinueOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="160" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5577" endline="5599">
<![CDATA[
 
 		//
 		// Checks whether the type is an interface that has the
 		// [ComImport, CoClass] attributes and must be treated
 		// specially
 		//
 		public Expression CheckComImport (ResolveContext ec)
 		{
 			if (!type.IsInterface)
 				return null;
 
 			//
 			// Turn the call into
 			// (the-interface-stated) (new class-referenced-in-coclassattribute ())
 			//
 			var real_class = type.MemberDefinition.GetAttributeCoClass ();
 			if (real_class == null)
 				return null;
 
 			New proxy = new New (new TypeExpression (real_class, loc), arguments, loc);
 			Cast cast = new Cast (new TypeExpression (type, loc), proxy, loc);
 			return cast.Resolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="161" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1142" endline="1173">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (ec.HasSet (ResolveContext.Options.ConstantScope)) {
 				ec.Report.Error (1706, loc, "Anonymous methods and lambda expressions cannot be used in the current context");
 				return null;
 			}
 
 			//
 			// Set class type, set type
 			//
 
 			eclass = ExprClass.Value;
 
 			//
 			// This hack means `The type is not accessible
 			// anywhere', we depend on special conversion
 			// rules.
 			// 
 			type = InternalType.AnonymousMethod;
 
 			if (!DoResolveParameters (ec))
 				return null;
 
 			// FIXME
 			// so, ensure we have a 'ret' at the end
 			BlockContext bc = ec as BlockContext;
 			if (bc != null && bc.CurrentBranching != null && bc.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				bc.NeedReturnLabel ();
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="162" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="273" endline="290">
<![CDATA[
 
 		public void CaptureLocalVariable (ResolveContext ec, LocalVariable local_info)
 		{
 			ec.CurrentBlock.Explicit.HasCapturedVariable = true;
 			if (ec.CurrentBlock.Explicit != local_info.Block.Explicit)
 				AddReferenceFromChildrenBlock (ec.CurrentBlock.Explicit);
 
 			if (local_info.HoistedVariant != null)
 				return;
 
 			HoistedVariable var = new HoistedLocalVariable (this, local_info, GetVariableMangledName (local_info));
 			local_info.HoistedVariant = var;
 
 			if (hoisted_locals == null)
 				hoisted_locals = new List<HoistedVariable> ();
 
 			hoisted_locals.Add (var);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="163" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="204" endline="220">
<![CDATA[
 
 		public void AddCapturedThisField (EmitContext ec)
 		{
 			TypeExpr type_expr = new TypeExpression (ec.CurrentType, Location);
 			Field f = AddCompilerGeneratedField ("<>f__this", type_expr);
 			f.Define ();
 			hoisted_this = new HoistedThis (this, f);
 
 			// Inflated type instance has to be updated manually
 			if (Instance.Type is InflatedTypeSpec) {
 				var inflator = new TypeParameterInflator (Instance.Type, TypeParameterSpec.EmptyTypes, TypeSpec.EmptyTypes);
 				Instance.Type.MemberCache.AddMember (f.Spec.InflateMember (inflator));
 
 				inflator = new TypeParameterInflator (f.Parent.CurrentType, TypeParameterSpec.EmptyTypes, TypeSpec.EmptyTypes);
 				f.Parent.CurrentType.MemberCache.AddMember (f.Spec.InflateMember (inflator));
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="164" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="491" endline="512">
<![CDATA[
 
 		protected override void CreateArguments (ResolveContext ec, Parameter parameter, ref Arguments args)
 		{
 			args = new Arguments (4);
 
 			if (IdentifierType != null)
 				expr = CreateCastExpression (expr);
 
 			args.Add (new Argument (expr));
 
 			outer_selector.SetParameter (parameter.Clone ());
 			var lambda = new LambdaExpression (outer_selector.StartLocation);
 			lambda.Block = outer_selector;
 			args.Add (new Argument (lambda));
 
 			inner_selector.SetParameter (new ImplicitLambdaParameter (identifier.Name, identifier.Location));
 			lambda = new LambdaExpression (inner_selector.StartLocation);
 			lambda.Block = inner_selector;
 			args.Add (new Argument (lambda));
 
 			base.CreateArguments (ec, parameter, ref args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="165" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5381" endline="5402">
<![CDATA[
 
 		protected override Expression OverloadResolve (ResolveContext rc, Expression right_side)
 		{
 			eclass = ExprClass.PropertyAccess;
 
 			if (best_candidate.IsNotRealProperty) {
 				Error_PropertyNotValid (rc);
 			}
 
 			ResolveInstanceExpression (rc, right_side);
 
 			if ((best_candidate.Modifiers & (Modifiers.ABSTRACT | Modifiers.VIRTUAL)) != 0 && best_candidate.DeclaringType != InstanceExpression.Type) {
 				var filter = new MemberFilter (best_candidate.Name, 0, MemberKind.Property, null, null);
 				var p = MemberCache.FindMember (InstanceExpression.Type, filter, BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as PropertySpec;
 				if (p != null) {
 					type = p.MemberType;
 				}
 			}
 
 			DoBestMemberChecks (rc, best_candidate);
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="166" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1232" endline="1252">
<![CDATA[
 
 		public void SetPartialDefinition (Method methodDefinition)
 		{
 			caching_flags |= Flags.PartialDefinitionExists;
 			methodDefinition.partialMethodImplementation = this;
 
 			// Ensure we are always using method declaration parameters
 			for (int i = 0; i < methodDefinition.parameters.Count; ++i ) {
 				parameters [i].Name = methodDefinition.parameters [i].Name;
 				parameters [i].DefaultValue = methodDefinition.parameters [i].DefaultValue;
 			}
 			for (int i = 0; i < methodDefinition.parameters.Count; ++i ) {
 				parameters [i].Name = methodDefinition.parameters [i].Name;
 				parameters [i].DefaultValue = methodDefinition.parameters [i].DefaultValue;
 			}
 
 			if (methodDefinition.attributes == null)
 				return;
 
 			if (attributes == null) {
 				attributes = methodDefinition.attributes;
 			} else {
 				attributes.Attrs.AddRange (methodDefinition.attributes.Attrs);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="167" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7119" endline="7147">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			TypeExpr texpr;
 
 			//
 			// Pointer types are allowed without explicit unsafe, they are just tokens
 			//
 			using (ec.Set (ResolveContext.Options.UnsafeScope)) {
 				texpr = QueriedType.ResolveAsTypeTerminal (ec, false);
 			}
 
 			if (texpr == null)
 				return null;
 
 			typearg = texpr.Type;
 
 			if (typearg == TypeManager.void_type && !(QueriedType is TypeExpression)) {
 				ec.Report.Error (673, loc, "System.Void cannot be used from C#. Use typeof (void) to get the void type object");
 			} else if (texpr is DynamicTypeExpr) {
 				ec.Report.Error (1962, QueriedType.Location,
 					"The typeof operator cannot be used on the dynamic type");
 			}
 
 			type = TypeManager.type_type;
 			QueriedType = texpr;
 
 			return DoResolveBase ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="168" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="410" endline="446">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// This is called for each part of a partial generic type definition.
 		//
 		// If partial type parameters constraints are not null and we don't
 		// already have constraints they become our constraints. If we already
 		// have constraints, we must check that they're the same.
 		//
 		public bool AddPartialConstraints (TypeContainer part, TypeParameter tp)
 		{
 			if (builder == null)
 				throw new InvalidOperationException ();
 
 			var new_constraints = tp.constraints;
 			if (new_constraints == null)
 				return true;
 
 			// TODO
 			//tp.Define (null, -1, part.Definition);
 			tp.spec.DeclaringType = part.Definition;
 			if (!tp.ResolveConstraints (part))
 				return false;
 
 			if (constraints != null)
 				return spec.HasSameConstraintsDefinition (tp.Type);
 
 			// Copy constraint from resolved part to partial container
 			spec.SpecialConstraint = tp.spec.SpecialConstraint;
 			spec.InterfacesDefined = tp.spec.InterfacesDefined;
 			spec.TypeArguments = tp.spec.TypeArguments;
 			spec.BaseType = tp.spec.BaseType;
 			
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="169" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="290" endline="309">
<![CDATA[
 
 		protected static Expression CreateRangeVariableType (ResolveContext rc, Parameter parameter, RangeVariable name, Expression init)
 		{
 			var args = new List<AnonymousTypeParameter> (2);
 
 			//
 			// The first argument is the reference to the parameter
 			//
 			args.Add (new AnonymousTypeParameter (new RangeParameterReference (parameter), parameter.Name, parameter.Location));
 
 			//
 			// The second argument is the linq expression
 			//
 			args.Add (new RangeAnonymousTypeParameter (init, name));
 
 			//
 			// Create unique anonymous type
 			//
 			return new NewAnonymousType (args, rc.MemberContext.CurrentMemberDefinition.Parent, name.Location);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="170" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4204" endline="4216">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 
 			var pc = left.Type as PointerContainer;
 			if (pc != null && pc.Element.BuildinType == BuildinTypeSpec.Type.Void) {
 				Error_VoidPointerOperation (ec);
 				return null;
 			}
 			
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="171" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1303" endline="1317">
<![CDATA[
 
 		public override void Emit ()
 		{
 			CheckReservedNameConflict (null, add.Spec);
 			CheckReservedNameConflict (null, remove.Spec);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			Add.Emit (Parent);
 			Remove.Emit (Parent);
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="172" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3083" endline="3096">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (best_candidate == null) {
 				ec.Report.Error (1953, loc, "An expression tree cannot contain an expression with method group");
 				return null;
 			}
 
 			if (best_candidate.IsConditionallyExcluded (loc))
 				ec.Report.Error (765, loc,
 					"Partial methods with only a defining declaration or removed conditional methods cannot be used in an expression tree");
 			
 			return new TypeOfMethod (best_candidate, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="173" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2499" endline="2510">
<![CDATA[
 
 		public override void Emit ()
 		{
 			base.Emit ();
 
 			if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 				Module.PredefinedAttributes.Extension.EmitAttribute (TypeBuilder);
 
 			if (base_type != null && base_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (TypeBuilder, base_type, Location);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="174" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9157" endline="9171">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			FieldExpr fe = target as FieldExpr;
 			if (fe != null)
 				args.Add (new Argument (fe.CreateTypeOfExpression ()));
 			else
 				args.Add (new Argument (((PropertyExpr)target).CreateSetterTypeOfExpression ()));
 
 			args.Add (new Argument (source.CreateExpressionTree (ec)));
 			return CreateExpressionFactoryCall (ec,
 				source is CollectionOrObjectInitializers ? "ListBind" 
 				args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="175" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="151" endline="166">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			BlockContext bc = new BlockContext (ec.MemberContext, Block, ReturnType);
 			Expression args = parameters.CreateExpressionTree (bc, loc);
 			Expression expr = Block.CreateExpressionTree (ec);
 			if (expr == null)
 				return null;
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (expr));
 			arguments.Add (new Argument (args));
 			return CreateExpressionFactoryCall (ec, "Lambda",
 				new TypeArguments (new TypeExpression (type, loc)),
 				arguments);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="176" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5962" endline="5981">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			var current_field = rc.CurrentMemberDefinition as FieldBase;
 			TypeExpression type;
 			if (current_field != null) {
 				type = new TypeExpression (current_field.MemberType, current_field.Location);
 			} else if (variable != null) {
 				if (variable.TypeExpression is VarExpr) {
 					rc.Report.Error (820, loc, "An implicitly typed local variable declarator cannot use an array initializer");
 					return EmptyExpression.Null;
 				}
 
 				type = new TypeExpression (variable.Variable.Type, variable.Variable.Location);
 			} else {
 				throw new NotImplementedException ("Unexpected array initializer context");
 			}
 
 			return new ArrayCreation (type, this).Resolve (rc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="177" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="649" endline="677">
<![CDATA[
 
 		/// <summary>
 		/// Creates the instance of ObsoleteAttribute from this attribute instance
 		/// </summary>
 		public ObsoleteAttribute GetObsoleteAttribute ()
 		{
 			if (!arg_resolved) {
 				// corlib only case when obsolete is used before is resolved
 				var c = type.MemberDefinition as Class;
 				if (c != null && !c.HasMembersDefined)
 					c.Define ();
 				
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 			}
 
 			if (resolve_error)
 				return null;
 
 			if (PosArguments == null)
 				return new ObsoleteAttribute ();
 
 			string msg = ((Constant) PosArguments[0].Expr).GetValue () as string;
 			if (PosArguments.Count == 1)
 				return new ObsoleteAttribute (msg);
 
 			return new ObsoleteAttribute (msg, ((BoolConstant) PosArguments[1].Expr).Value);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="178" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="259" endline="281">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Assembly) {
 				assembly.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				Attribute cls = DeclaringAssembly.CLSCompliantAttribute;
 				if (cls == null) {
 					Report.Warning (3012, 1, a.Location,
 						"You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking");
 				} else if (DeclaringAssembly.IsCLSCompliant != a.GetBoolean ()) {
 					Report.SymbolRelatedToPreviousError (cls.Location, cls.GetSignatureForError ());
 					Report.Warning (3017, 1, a.Location,
 						"You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly");
 					return;
 				}
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="179" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2009" endline="2038">
<![CDATA[
 
 		public override void Emit()
 		{
 			var base_type = Parent.PartialContainer.BaseType;
 			if (base_type != null && Block != null) {
 				var base_dtor = MemberCache.FindMember (base_type,
 					new MemberFilter (MetadataName, 0, MemberKind.Destructor, null, null), BindingRestriction.InstanceOnly) as MethodSpec;
 
 				if (base_dtor == null)
 					throw new NotImplementedException ();
 
 				MethodGroupExpr method_expr = MethodGroupExpr.CreatePredefined (base_dtor, base_type, Location);
 				method_expr.InstanceExpression = new BaseThis (base_type, Location);
 
 				var try_block = new ExplicitBlock (block, block.StartLocation, block.EndLocation);
 				var finaly_block = new ExplicitBlock (block, Location, Location);
 
 				//
 				// 0-size arguments to avoid CS0250 error
 				// TODO
 				// debugger scope
 				//
 				finaly_block.AddStatement (new StatementExpression (new Invocation (method_expr, new Arguments (0))));
 
 				var tf = new TryFinally (try_block, finaly_block, Location);
 				block.WrapIntoDestructor (tf, try_block);
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="180" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="896" endline="915">
<![CDATA[
 
 		public FieldSpec CreateCallSiteField (FullNamedExpression type, Location loc)
 		{
 			int index = fields == null ? 0 
 			Field f = new HoistedField (this, type, Modifiers.PUBLIC | Modifiers.STATIC, "Site" + index.ToString ("X"), null, loc);
 			f.Define ();
 
 			AddField (f);
 
 			var fs = f.Spec;
 			if (mutator != null) {
 				//
 				// Inflate the field, no need to keep it in MemberCache as it's accessed only once
 				//
 				var inflator = new TypeParameterInflator (instance_type, spec.MemberDefinition.TypeParameters, instance_type.TypeArguments);
 				fs = (FieldSpec) fs.InflateMember (inflator);
 			}
 
 			return fs;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="181" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1394" endline="1410">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement target)
 		{
 			BlockVariableDeclaration t = (BlockVariableDeclaration) target;
 
 			if (type_expr != null)
 				t.type_expr = (FullNamedExpression) type_expr.Clone (clonectx);
 
 			if (initializer != null)
 				t.initializer = initializer.Clone (clonectx);
 
 			if (declarators != null) {
 				t.declarators = null;
 				foreach (var d in declarators)
 					t.AddDeclarator (new Declarator (d, d.Initializer == null ? null 
 				foreach (var d in declarators)
 					t.AddDeclarator (new Declarator (d, d.Initializer == null ? null 
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="182" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="855" endline="881">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			if (!ec.IsUnsafe)
 				UnsafeError (ec, loc);
 
 			var pc = expr.Type as PointerContainer;
 
 			if (pc == null) {
 				ec.Report.Error (193, loc, "The * or -> operator must be applied to a pointer");
 				return null;
 			}
 
 			type = pc.Element;
 
 			if (type.BuildinType == BuildinTypeSpec.Type.Void) {
 				Error_VoidPointerOperation (ec);
 				return null;
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="183" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="135" endline="153">
<![CDATA[
 
 		public ATypeNameExpression GetTypeExpression ()
 		{
 			if (Left == null) {
 				if (TypeArguments != null)
 					return new SimpleName (Name, TypeArguments, Location);
 				
 				return new SimpleName (Name, Location);
 			}
 
 			if (is_double_colon) {
 				if (Left.Left != null)
 					throw new InternalErrorException ("The left side of a 
 				return new QualifiedAliasMember (Left.Name, Name, TypeArguments, Location);
 			}
 
 			Expression lexpr = Left.GetTypeExpression ();
 			return new MemberAccess (lexpr, Name, TypeArguments, Location);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="184" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7423" endline="7452">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			TypeExpr texpr = QueriedType.ResolveAsTypeTerminal (ec, false);
 			if (texpr == null)
 				return null;
 
 			type_queried = texpr.Type;
 			if (TypeManager.IsEnumType (type_queried))
 				type_queried = EnumSpec.GetUnderlyingType (type_queried);
 
 			int size_of = GetTypeSize (type_queried);
 			if (size_of > 0) {
 				return new IntConstant (size_of, loc).Resolve (ec);
 			}
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, type_queried, loc)){
 				return null;
 			}
 
 			if (!ec.IsUnsafe) {
 				ec.Report.Error (233, loc,
 					"`{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf)",
 					TypeManager.CSharpName (type_queried));
 			}
 			
 			type = TypeManager.int32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="185" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="108" endline="114">
<![CDATA[
 		}
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			iterator = ec.CurrentIterator;
 			return Yield.CheckContext (ec, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="186" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="382" endline="397">
<![CDATA[
 
 		public abstract UsageVector CurrentUsageVector {
 			get;
 		}				
 
 		// <summary>
 		//   Creates a sibling of the current usage vector.
 		// </summary>
 		public virtual void CreateSibling (Block block, SiblingType type)
 		{
 			UsageVector vector = new UsageVector (
 				type, Parent.CurrentUsageVector, block, Location);
 			AddSibling (vector);
 
 			Report.Debug (1, "  CREATED SIBLING", CurrentUsageVector);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="187" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1463" endline="1474">
<![CDATA[
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// Only boxing to object type is supported
 			if (targetType != TypeManager.object_type) {
 				base.EncodeAttributeValue (rc, enc, targetType);
 				return;
 			}
 
 			enc.Encode (child.Type);
 			child.EncodeAttributeValue (rc, enc, child.Type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="188" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="525" endline="536">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			flags |= ec.HasSet (ResolveContext.Options.CheckedScope) ? CSharpBinderFlags.CheckedContext 
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			return new Invocation (GetBinder ("Convert", loc), binder_args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="189" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="198" endline="217">
<![CDATA[
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			//
 			// When delegate returns void, only expression statements can be used
 			//
 			if (ec.ReturnType == TypeManager.void_type) {
 				Expr = Expr.Resolve (ec);
 				if (Expr == null)
 					return false;
 
 				statement = Expr as ExpressionStatement;
 				if (statement == null)
 					Expr.Error_InvalidExpressionStatement (ec);
 
 				return true;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="190" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2260" endline="2280">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Type == pa.StructLayout) {
 				PartialContainer.HasStructLayout = true;
 				if (a.IsExplicitLayoutKind ())
 					PartialContainer.HasExplicitLayout = true;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="191" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4680" endline="4715">
<![CDATA[
 		}
 
 		#endregion
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (IsGeneral)
 				ec.BeginCatchBlock (TypeManager.object_type);
 			else
 				ec.BeginCatchBlock (CatchType);
 
 			if (li != null) {
 				li.CreateBuilder (ec);
 
 				//
 				// Special case hoisted catch variable, we have to use a temporary variable
 				// to pass via anonymous storey initialization with the value still on top
 				// of the stack
 				//
 				if (li.HoistedVariant != null) {
 					LocalTemporary lt = new LocalTemporary (li.Type);
 					SymbolWriter.OpenCompilerGeneratedBlock (ec);
 					lt.Store (ec);
 					SymbolWriter.CloseCompilerGeneratedBlock (ec);
 
 					// switch to assigning from the temporary variable and not from top of the stack
 					assign.UpdateSource (lt);
 				}
 			} else {
 				SymbolWriter.OpenCompilerGeneratedBlock (ec);
 				ec.Emit (OpCodes.Pop);
 				SymbolWriter.CloseCompilerGeneratedBlock (ec);
 			}
 
 			Block.Emit (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="192" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2854" endline="2877">
<![CDATA[
 
 		protected void EmitInstance (EmitContext ec, bool prepare_for_load)
 		{
 			TypeSpec instance_type = InstanceExpression.Type;
 			if (TypeManager.IsValueType (instance_type)) {
 				if (InstanceExpression is IMemoryLocation) {
 					((IMemoryLocation) InstanceExpression).AddressOf (ec, AddressOp.LoadStore);
 				} else {
 					LocalTemporary t = new LocalTemporary (instance_type);
 					InstanceExpression.Emit (ec);
 					t.Store (ec);
 					t.AddressOf (ec, AddressOp.Store);
 				}
 			} else {
 				InstanceExpression.Emit (ec);
 
 				// Only to make verifier happy
 				if (instance_type.IsGenericParameter && !(InstanceExpression is This) && TypeManager.IsReferenceType (instance_type))
 					ec.Emit (OpCodes.Box, instance_type);
 			}
 
 			if (prepare_for_load)
 				ec.Emit (OpCodes.Dup);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="193" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="51" endline="76">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
 			Report.Debug (64, "RESOLVE YIELD #1", this, ec, expr, expr.GetType (),
 				      ec.CurrentAnonymousMethod, ec.CurrentIterator);
 
 			if (!CheckContext (ec, loc))
 				return false;
 
 			iterator = ec.CurrentIterator;
 			if (expr.Type != iterator.OriginalIteratorType) {
 				expr = Convert.ImplicitConversionRequired (
 					ec, expr, iterator.OriginalIteratorType, loc);
 				if (expr == null)
 					return false;
 			}
 
 			if (!ec.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				unwind_protect = ec.CurrentBranching.AddResumePoint (this, loc, out resume_pc);
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="194" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1533" endline="1544">
<![CDATA[
 
 		//
 		// Encodes single property named argument per call
 		//
 		public void EncodeNamedPropertyArgument (PropertySpec property, Constant value)
 		{
 			Encode ((ushort) 1);	// length
 			Encode ((byte) 0x54); // property
 			Encode (property.MemberType);
 			Encode (property.Name);
 			value.EncodeAttributeValue (null, this, property.MemberType);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="195" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="159" endline="167">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="196" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1655" endline="1662">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="197" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7108" endline="7118">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="198" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7293" endline="7300">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="199" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1068" endline="1084">
<![CDATA[
 
 		private TypeInfo (TypeSpec type)
 		{
 			this.Type = type;
 
 			struct_info = StructInfo.GetStructInfo (type);
 			if (struct_info != null) {
 				Length = struct_info.Length;
 				TotalLength = struct_info.TotalLength;
 				SubStructInfo = struct_info.StructFields;
 				IsStruct = true;
 			} else {
 				Length = 0;
 				TotalLength = 1;
 				IsStruct = false;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="200" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5888" endline="5895">
<![CDATA[
 
 		protected override void Error_TypeOrNamespaceNotFound (IMemberContext ec)
 		{
 			if (RootContext.Version < LanguageVersion.V_3)
 				base.Error_TypeOrNamespaceNotFound (ec);
 			else
 				ec.Compiler.Report.Error (825, loc, "The contextual keyword `var' may only appear within a local variable declaration");
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="201" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="503" endline="516">
<![CDATA[
 	}
 
 	class IteratorMethod 
 	{
 		readonly IteratorStorey host;
 
 		public IteratorMethod (IteratorStorey host, FullNamedExpression returnType, Modifiers mod, MemberName name)
 			
 			  name, ParametersCompiled.EmptyReadOnlyParameters, null)
 		{
 			this.host = host;
 
 			Block = new ToplevelBlock (host.Compiler, ParametersCompiled.EmptyReadOnlyParameters, Location);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="202" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2953" endline="2968">
<![CDATA[
 
 		bool OverloadResolver.IErrorHandler.ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument arg, int index)
 		{
 			rc.Report.SymbolRelatedToPreviousError (best);
 			rc.Report.Error (1928, loc,
 				"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' has some invalid arguments",
 				queried_type.GetSignatureForError (), Name, best.GetSignatureForError ());
 
 			if (index == 0) {
 				rc.Report.Error (1929, loc,
 					"Extension method instance type `{0}' cannot be converted to `{1}'",
 					arg.Type.GetSignatureForError (), ((MethodSpec)best).Parameters.ExtensionMethodType.GetSignatureForError ());
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="203" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6838" endline="6848">
<![CDATA[
 		}
 
 		#endregion
 
 		public void CheckStructThisDefiniteAssignment (ResolveContext rc)
 		{
 			if (variable_info != null && !variable_info.IsAssigned (rc)) {
 				rc.Report.Error (188, loc,
 					"The `this' object cannot be used before all of its fields are assigned to");
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="204" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2063" endline="2074">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (scope_initializers != null)
 				EmitScopeInitializers (ec);
 
 			ec.Mark (StartLocation);
 			DoEmit (ec);
 
 			if (SymbolWriter.HasSymbolWriter)
 				EmitSymbolInfo (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="205" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4595" endline="4624">
<![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="206" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="803" endline="810">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (!prepared)
 				expr.Emit (ec);
 			
 			ec.EmitLoadFromPtr (Type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="207" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="364" endline="372">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp Mode)
 		{
 			LocalTemporary value_target = new LocalTemporary (type);
 				
 			value_target.AddressOf (ec, AddressOp.Store);
 			ec.Emit (OpCodes.Initobj, type);
 			((IMemoryLocation) value_target).AddressOf (ec, Mode);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="208" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1121" endline="1128">
<![CDATA[
 
 		public OperatorCast (Expression child, TypeSpec target_type, bool find_explicit)
 			
 		{
 			conversion_operator = GetConversionOperator (find_explicit);
 			if (conversion_operator == null)
 				throw new InternalErrorException ("Outer conversion routine is out of sync");
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="209" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4102" endline="4110">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			var members = CreateConcatMethodCandidates ();
 			var res = new OverloadResolver (members, OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var method = res.ResolveMember<MethodSpec> (new ResolveContext (ec.MemberContext), ref arguments);
 			if (method != null)
 				Invocation.EmitCall (ec, null, method, arguments, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="210" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="199" endline="211">
<![CDATA[
 
 		protected virtual void CreateArguments (ResolveContext ec, Parameter parameter, ref Arguments args)
 		{
 			args = new Arguments (2);
 
 			LambdaExpression selector = new LambdaExpression (loc);
 
 			block.SetParameter (parameter);
 			selector.Block = block;
 			selector.Block.AddStatement (new ContextualReturn (expr));
 
 			args.Add (new Argument (selector));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="211" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5320" endline="5343">
<![CDATA[
 
 		public override void Emit (EmitContext ec, bool leave_copy)
 		{
 			//
 			// Special case
 			//
 			if (IsSingleDimensionalArrayLength ()) {
 				if (!prepared)
 					EmitInstance (ec, false);
 				ec.Emit (OpCodes.Ldlen);
 				ec.Emit (OpCodes.Conv_I4);
 				return;
 			}
 
 			Invocation.EmitCall (ec, InstanceExpression, Getter, null, loc, prepared, false);
 			
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (!IsStatic) {
 					temp = new LocalTemporary (this.Type);
 					temp.Store (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="212" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="30" endline="51">
<![CDATA[
 
 		protected override Expression CreateExpressionTree (ResolveContext ec, TypeSpec delegate_type)
 		{
 			if (ec.IsInProbingMode)
 				return this;
 
 			BlockContext bc = new BlockContext (ec.MemberContext, ec.ConstructorBlock, TypeManager.void_type) {
 				CurrentAnonymousMethod = ec.CurrentAnonymousMethod
 			};
 
 			Expression args = Parameters.CreateExpressionTree (bc, loc);
 			Expression expr = Block.CreateExpressionTree (ec);
 			if (expr == null)
 				return null;
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (expr));
 			arguments.Add (new Argument (args));
 			return CreateExpressionFactoryCall (ec, "Lambda",
 				new TypeArguments (new TypeExpression (delegate_type, loc)),
 				arguments);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="213" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1334" endline="1345">
<![CDATA[
 		
 		Expression CreateConstantResult (ResolveContext ec, bool result)
 		{
 			if (result)
 				ec.Report.Warning (183, 1, loc, "The given expression is always of the provided (`{0}') type",
 					TypeManager.CSharpName (probe_type_expr.Type));
 			else
 				ec.Report.Warning (184, 1, loc, "The given expression is never of the provided (`{0}') type",
 					TypeManager.CSharpName (probe_type_expr.Type));
 
 			return ReducedExpression.Create (new BoolConstant (result, loc).Resolve (ec), this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="214" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2281" endline="2305">
<![CDATA[
 
 		/// <summary>
 		/// Defines the default constructors 
 		/// </summary>
 		protected void DefineDefaultConstructor (bool is_static)
 		{
 			// The default instance constructor is public
 			// If the class is abstract, the default constructor is protected
 			// The default static constructor is private
 
 			Modifiers mods;
 			if (is_static) {
 				mods = Modifiers.STATIC | Modifiers.PRIVATE;
 			} else {
 				mods = ((ModFlags & Modifiers.ABSTRACT) != 0) ? Modifiers.PROTECTED 
 			}
 
 			Constructor c = new Constructor (this, MemberName.Name, mods,
 				null, ParametersCompiled.EmptyReadOnlyParameters,
 				new GeneratedBaseInitializer (Location),
 				Location);
 			
 			AddConstructor (c);
 			c.Block = new ToplevelBlock (Compiler, ParametersCompiled.EmptyReadOnlyParameters, Location);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="215" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9289" endline="9302">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (mg.CreateExpressionTree (ec)));
 
 			var expr_initializers = new ArrayInitializer (arguments.Count, loc);
 			foreach (Argument a in arguments)
 				expr_initializers.Add (a.CreateExpressionTree (ec));
 			foreach (Argument a in arguments)
 				expr_initializers.Add (a.CreateExpressionTree (ec));
 
 			args.Add (new Argument (new ArrayCreation (
 				CreateExpressionTypeExpression (ec, loc), expr_initializers, loc)));
 			return CreateExpressionFactoryCall (ec, "ElementInit", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="216" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="579" endline="587">
<![CDATA[
 
 		public void SetDefinition (TypeSpec ts)
 		{
 			this.definition = ts.MemberDefinition;
 			this.info = ts.GetMetaInfo ();
 			this.BaseType = ts.BaseType;
 			this.Interfaces = ts.Interfaces;
 			this.modifiers = ts.Modifiers;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="217" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="202" endline="214">
<![CDATA[
 
 		protected override bool DefineNestedTypes ()
 		{
 			((EnumSpec) spec).UnderlyingType = base_type_expr == null ? TypeManager.int32_type 
 
 			TypeBuilder.DefineField (UnderlyingValueField, UnderlyingType.GetMetaInfo (),
 				FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
 
 			if (!RootContext.StdLib)
 				Module.hack_corlib_enums.Add (this);
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="218" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7997" endline="8012">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, false))
 				Expr = Expr.Resolve (ec);
 
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="219" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="950" endline="966">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			if (ec.Switch == null) {
 				ec.Report.Error (153, loc, "A goto case is only valid inside a switch statement");
 				return false;
 			}
 
 			if (!ec.Switch.GotDefault) {
 				FlowBranchingBlock.Error_UnknownLabel (loc, "default", ec.Report);
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="220" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1375" endline="1393">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (li.IsConstant)
 				return;
 
 			li.CreateBuilder (ec);
 
 			if (Initializer != null)
 				((ExpressionStatement) Initializer).EmitStatement (ec);
 
 			if (declarators != null) {
 				foreach (var d in declarators) {
 					d.Variable.CreateBuilder (ec);
 					if (d.Initializer != null)
 						((ExpressionStatement) d.Initializer).EmitStatement (ec);
 				}
 				foreach (var d in declarators) {
 					d.Variable.CreateBuilder (ec);
 					if (d.Initializer != null)
 						((ExpressionStatement) d.Initializer).EmitStatement (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="221" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="680" endline="687">
<![CDATA[
 
 		public bool IsComImport {
 			get {
 				if (OptAttributes == null)
 					return false;
 
 				return OptAttributes.Contains (Module.PredefinedAttributes.ComImport);
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="222" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="780" endline="786">
<![CDATA[
 
 		public void EmitHoistingAssignment (EmitContext ec)
 		{
 			SimpleAssign a = new SimpleAssign (GetFieldExpression (ec), new CompilerGeneratedThis (ec.CurrentType, field.Location));
 			if (a.Resolve (new ResolveContext (ec.MemberContext)) != null)
 				a.EmitStatement (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="223" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="778" endline="788">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if ((AccessorFirst.ModFlags & (Modifiers.STATIC | Modifiers.COMPILER_GENERATED)) == Modifiers.COMPILER_GENERATED && Parent.PartialContainer.HasExplicitLayout) {
 				Report.Error (842, Location,
 					"Automatically implemented property `{0}' cannot be used inside a type with an explicit StructLayout attribute",
 					GetSignatureForError ());
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="224" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1033" endline="1045">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (child.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			if (type.IsPointer || child.Type.IsPointer)
 				Error_PointerInsideExpressionTree (ec);
 
 			return CreateExpressionFactoryCall (ec, ec.HasSet (ResolveContext.Options.CheckedScope) ? "ConvertChecked" 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="225" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3231" endline="3247">
<![CDATA[
 
 		protected void Error_CannotChangeAccessModifiers (MemberCore member, MemberSpec base_member)
 		{
 			var base_modifiers = base_member.Modifiers;
 
 			// Remove internal modifier from types which are not internally accessible
 			if ((base_modifiers & Modifiers.AccessibilityMask) == (Modifiers.PROTECTED | Modifiers.INTERNAL) &&
 				!base_member.DeclaringType.MemberDefinition.IsInternalAsPublic (member.Module.DeclaringAssembly))
 				base_modifiers = Modifiers.PROTECTED;
 
 			Report.SymbolRelatedToPreviousError (base_member);
 			Report.Error (507, member.Location,
 				"`{0}'
 				member.GetSignatureForError (),
 				ModifiersExtensions.AccessibilityName (base_modifiers),
 				base_member.GetSignatureForError ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="226" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8786" endline="8795">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (source.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			args.Add (new Argument (new TypeOfMethod (method, loc)));
 			return CreateExpressionFactoryCall (ec, "Convert", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="227" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="604" endline="624">
<![CDATA[
 
 		//
 		// CSC 2 has this behavior, it allows structs to be compared
 		// with the null literal *outside* of a generics context and
 		// inlines that as true or false.
 		//
 		Constant CreateNullConstant (ResolveContext ec, Expression expr)
 		{
 			// FIXME
 			Constant c = new BoolConstant (Oper == Operator.Inequality, loc).Resolve (ec);
 
 			if ((Oper & Operator.EqualityMask) != 0) {
 				ec.Report.Warning (472, 2, loc, "The result of comparing value type `{0}' with null is `{1}'",
 					TypeManager.CSharpName (expr.Type), c.AsString ());
 			} else {
 				ec.Report.Warning (464, 2, loc, "The result of comparing type `{0}' with null is always `{1}'",
 					TypeManager.CSharpName (expr.Type), c.AsString ());
 			}
 
 			return ReducedExpression.Create (c, this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="228" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="693" endline="711">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			string name = goto_stmt.Target;
 			LabeledStatement s = Block.LookupLabel (name);
 			if (s != null)
 				throw new InternalErrorException ("Shouldn't get here");
 
 			if (Parent == null) {
 				Error_UnknownLabel (goto_stmt.loc, name, Report);
 				return false;
 			}
 
 			int errors = Report.Errors;
 			Parent.AddGotoOrigin (vector, goto_stmt);
 			if (errors == Report.Errors)
 				Report.Error (1632, goto_stmt.loc, "Control cannot leave the body of an anonymous method");
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="229" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1637" endline="1644">
<![CDATA[
 
 		public Expression CreateReferenceExpression (ResolveContext rc, Location loc)
 		{
 			if (IsConstant && const_value != null)
 				return Constant.CreateConstantFromValue (Type, const_value.GetValue (), loc).Resolve (rc);
 
 			return new LocalVariableReference (this, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="230" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5808" endline="5819">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			LocalTemporary v = null;
 			if (method == null && TypeManager.IsValueType (type)) {
 				// TODO
 				v = new LocalTemporary (type);
 			}
 
 			if (!Emit (ec, v))
 				v.Emit (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="231" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7148" endline="7160">
<![CDATA[
 
 		protected Expression DoResolveBase ()
 		{
 			if (TypeManager.system_type_get_type_from_handle == null) {
 				TypeManager.system_type_get_type_from_handle = TypeManager.GetPredefinedMethod (
 					TypeManager.type_type, "GetTypeFromHandle", loc, TypeManager.runtime_handle_type);
 			}
 
 			// Even though what is returned is a type object, it's treated as a value by the compiler.
 			// In particular, 'typeof (Foo).X' is something totally different from 'Foo.X'.
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="232" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="341" endline="357">
<![CDATA[
 		}
 
 		//TODO
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			parameters.VerifyClsCompliance (this);
 
 			if (!ReturnType.Type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="233" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="770" endline="776">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement exit_stmt)
 		{
 			Parent.AddReturnOrigin (vector, exit_stmt);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="234" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1122" endline="1129">
<![CDATA[
 
 		private Expression GetValue () 
 		{
 			if (PosArguments == null || PosArguments.Count < 1)
 				return null;
 
 			return PosArguments [0].Expr;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="235" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1413" endline="1426">
<![CDATA[
 		}
 
 		//
 		// Returns true if this is a default constructor
 		//
 		public bool IsDefault ()
 		{
 			if ((ModFlags & Modifiers.STATIC) != 0)
 				return parameters.IsEmpty;
 
 			return parameters.IsEmpty &&
 					(Initializer is ConstructorBaseInitializer) &&
 					(Initializer.Arguments == null);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="236" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="433" endline="446">
<![CDATA[
 		}
 
 		public bool MustCaptureVariable (INamedBlockVariable local)
 		{
 			if (CurrentAnonymousMethod == null)
 				return false;
 
 			// FIXME
 			// block contains yield
 			if (CurrentAnonymousMethod.IsIterator)
 				return true;
 
 			return local.Block.ParametersBlock != CurrentBlock.ParametersBlock.Original;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="237" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="985" endline="997">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = try_vector.Clone ();
 
 			if (finally_vector != null)
 				vector.MergeChild (finally_vector, false);
 
 			for (SavedOrigin origin = saved_origins; origin != null; origin = origin.Next)
 				origin.PropagateFinally (finally_vector, Parent);
 			for (SavedOrigin origin = saved_origins; origin != null; origin = origin.Next)
 				origin.PropagateFinally (finally_vector, Parent);
 
 			return vector;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="238" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="968" endline="984">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			LabeledStatement s = current_vector.Block == null ? null 
 			if (s != null)
 				throw new InternalErrorException ("Shouldn't get here");
 
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddGotoOrigin (vector, goto_stmt);
 				if (errors == Report.Errors)
 					Report.Error (157, goto_stmt.loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new GotoOrigin (saved_origins, vector, goto_stmt);
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="239" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="486" endline="512">
<![CDATA[
 
 		public bool AddField (FieldBase field)
 		{
 			if (!AddMember (field))
 				return false;
 
 			if (fields == null)
 				fields = new List<FieldBase> ();
 
 			fields.Add (field);
 
 			if ((field.ModFlags & Modifiers.STATIC) != 0)
 				return true;
 
 			if (first_nonstatic_field == null) {
 				first_nonstatic_field = field;
 				return true;
 			}
 
 			if (Kind == MemberKind.Struct && first_nonstatic_field.Parent != field.Parent) {
 				Report.SymbolRelatedToPreviousError (first_nonstatic_field.Parent);
 				Report.Warning (282, 3, field.Location,
 					"struct instance field `{0}' found in different declaration from instance field `{1}'",
 					field.GetSignatureForError (), first_nonstatic_field.GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="240" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="377" endline="385">
<![CDATA[
 #endif
 		protected virtual Expression ResolveConversions (ResolveContext ec)
 		{
 			source = Convert.ImplicitConversionRequired (ec, source, target.Type, loc);
 			if (source == null)
 				return null;
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="241" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="948" endline="956">
<![CDATA[
 
 		protected static TypeExpr CreateExpressionTypeExpression (ResolveContext ec, Location loc)
 		{
 			var t = ec.Module.PredefinedTypes.Expression.Resolve (loc);
 			if (t == null)
 				return null;
 
 			return new TypeExpression (t, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="242" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="105" endline="112">
<![CDATA[
 
 		public string GetSignatureForError ()
 		{
 			if (Expr.eclass == ExprClass.MethodGroup)
 				return Expr.ExprClassName;
 
 			return TypeManager.CSharpName (Expr.Type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="243" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="512" endline="520">
<![CDATA[
 		}
 
 		protected override void AddSibling (UsageVector sibling)
 		{
 			if (sibling_list != null && sibling_list.Type == SiblingType.Block)
 				throw new InternalErrorException ("Blocks don't have sibling flow paths");
 			sibling.Next = sibling_list;
 			sibling_list = sibling;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="244" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="723" endline="735">
<![CDATA[
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new StringLiteral (name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetMember" 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="245" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5255" endline="5275">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args;
 			if (IsSingleDimensionalArrayLength ()) {
 				args = new Arguments (1);
 				args.Add (new Argument (InstanceExpression.CreateExpressionTree (ec)));
 				return CreateExpressionFactoryCall (ec, "ArrayLength", args);
 			}
 
 			args = new Arguments (2);
 			if (InstanceExpression == null)
 				args.Add (new Argument (new NullLiteral (loc)));
 			else
 				args.Add (new Argument (InstanceExpression.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOfMethod (Getter, loc)));
 			return CreateExpressionFactoryCall (ec, "Property", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="246" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1260" endline="1274">
<![CDATA[
 
 		void CreateEvaluatorVariable (BlockContext bc, LocalVariable li)
 		{
 			var container = bc.CurrentMemberDefinition.Parent;
 
 			Field f = new Field (container, new TypeExpression (li.Type, li.Location), Modifiers.PUBLIC | Modifiers.STATIC,
 				new MemberName (li.Name, li.Location), null);
 
 			container.AddField (f);
 			f.Define ();
 			Evaluator.QueueField (f);
 
 			li.HoistedVariant = new HoistedEvaluatorVariable (f);
 			li.SetIsUsed ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="247" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="485" endline="502">
<![CDATA[
 
 		void Define_Reset ()
 		{
 			Method reset = new Method (
 				this, null, new TypeExpression (TypeManager.void_type, Location),
 				Modifiers.PUBLIC | Modifiers.DEBUGGER_HIDDEN,
 				new MemberName ("Reset", Location),
 				ParametersCompiled.EmptyReadOnlyParameters, null);
 			AddMethod (reset);
 
 			reset.Block = new ToplevelBlock (Compiler, Location);
 
 			TypeSpec ex_type = Module.PredefinedTypes.NotSupportedException.Resolve (Location);
 			if (ex_type == null)
 				return;
 
 			reset.Block.AddStatement (new Throw (new New (new TypeExpression (ex_type, Location), null, Location), Location));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="248" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="580" endline="591">
<![CDATA[
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetIndex" 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="249" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="727" endline="750">
<![CDATA[
 
 		void CreateAutomaticProperty ()
 		{
 			// Create backing field
 			Field field = new BackingField (this);
 			if (!field.Define ())
 				return;
 
 			Parent.PartialContainer.AddField (field);
 
 			FieldExpr fe = new FieldExpr (field, Location);
 			if ((field.ModFlags & Modifiers.STATIC) == 0)
 				fe.InstanceExpression = new CompilerGeneratedThis (fe.Type, Location);
 
 			// Create get block
 			Get.Block = new ToplevelBlock (Compiler, ParametersCompiled.EmptyReadOnlyParameters, Location);
 			Return r = new Return (fe, Location);
 			Get.Block.AddStatement (r);
 
 			// Create set block
 			Set.Block = new ToplevelBlock (Compiler, Set.ParameterInfo, Location);
 			Assign a = new SimpleAssign (fe, new SimpleName ("value", Location));
 			Set.Block.AddStatement (new StatementExpression (a));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="250" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="167" endline="185">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (parameters.HasArglist) {
 				Report.Warning (3000, 1, Location, "Methods with variable arguments are not CLS-compliant");
 			}
 
 			if (member_type != null && !member_type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 
 			parameters.VerifyClsCompliance (this);
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="251" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1545" endline="1556">
<![CDATA[
 
 		//
 		// Encodes single field named argument per call
 		//
 		public void EncodeNamedFieldArgument (FieldSpec field, Constant value)
 		{
 			Encode ((ushort) 1);	// length
 			Encode ((byte) 0x53); // field
 			Encode (field.MemberType);
 			Encode (field.Name);
 			value.EncodeAttributeValue (null, this, field.MemberType);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="252" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="187" endline="205">
<![CDATA[
 
 		//
 		// Creates a nested container in this context for all dynamic compiler generated stuff
 		//
 		public DynamicSiteClass CreateDynamicSite ()
 		{
 			if (dynamic_site_container == null) {
 				var mc = MemberContext.CurrentMemberDefinition as MemberBase;
 				dynamic_site_container = new DynamicSiteClass (CurrentTypeDefinition.Parent.PartialContainer, mc, CurrentTypeParameters);
 
 				CurrentTypeDefinition.Module.AddCompilerGeneratedClass (dynamic_site_container);
 				dynamic_site_container.CreateType ();
 				dynamic_site_container.DefineType ();
 				dynamic_site_container.ResolveTypeParameters ();
 				dynamic_site_container.Define ();
 			}
 
 			return dynamic_site_container;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="253" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6208" endline="6224">
<![CDATA[
 
 		protected virtual Expression ResolveArrayElement (ResolveContext ec, Expression element)
 		{
 			element = element.Resolve (ec);
 			if (element == null)
 				return null;
 
 			if (element is CompoundAssign.TargetExpression) {
 				if (first_emit != null)
 					throw new InternalErrorException ("Can only handle one mutator at a time");
 				first_emit = element;
 				element = first_emit_temp = new LocalTemporary (element.Type);
 			}
 
 			return Convert.ImplicitConversionRequired (
 				ec, element, array_element_type, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="254" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="161" endline="179">
<![CDATA[
 
 		public virtual void Error_NamespaceDoesNotExist (Location loc, string name, int arity, IMemberContext ctx)
 		{
 			FullNamedExpression retval = Lookup (ctx.Compiler, name, -System.Math.Max (1, arity), loc);
 			if (retval != null) {
 				Error_TypeArgumentsCannotBeUsed (ctx.Compiler.Report, loc, retval.Type, arity);
 				return;
 			}
 
 			Namespace ns;
 			if (arity > 0 && namespaces.TryGetValue (name, out ns)) {
 				ns.Error_TypeArgumentsCannotBeUsed (ctx.Compiler.Report, loc, null, arity);
 				return;
 			}
 
 			ctx.Compiler.Report.Error (234, loc,
 				"The type or namespace name `{0}' does not exist in the namespace `{1}'. Are you missing an assembly reference?",
 				name, GetSignatureForError ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="255" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="54" endline="73">
<![CDATA[
 
 		public override Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			if (expr is EnumConstant)
 				expr = ((EnumConstant) expr).Child;
 
 			var underlying = ((Enum) Parent).UnderlyingType;
 			if (expr != null) {
 				expr = expr.ImplicitConversionRequired (rc, underlying, Location);
 				if (expr != null && !IsValidEnumType (expr.Type)) {
 					Enum.Error_1008 (Location, Report);
 					expr = null;
 				}
 			}
 
 			if (expr == null)
 				expr = New.Constantify (underlying, Location);
 
 			return new EnumConstant (expr, MemberType).Resolve (rc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="256" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="259" endline="274">
<![CDATA[
 
 		TypeSpec ResolvePossibleAttributeType (ATypeNameExpression expr, ref bool is_attr)
 		{
 			TypeExpr te = ResolveAsTypeTerminal (expr, context);
 			if (te == null)
 				return null;
 
 			TypeSpec t = te.Type;
 			if (t.IsAttribute) {
 				is_attr = true;
 			} else {
 				Report.SymbolRelatedToPreviousError (t);
 				Report.Error (616, Location, "`{0}'
 			}
 			return t;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="257" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="595" endline="611">
<![CDATA[
 	}
 
 	public class FlowBranchingLabeled 
 	{
 		LabeledStatement stmt;
 		UsageVector actual;
 
 		public FlowBranchingLabeled (FlowBranching parent, LabeledStatement stmt)
 			
 		{
 			this.stmt = stmt;
 			CurrentUsageVector.MergeOrigins (stmt.JumpOrigins);
 			actual = CurrentUsageVector.Clone ();
 
 			// stand-in for backward jumps
 			CurrentUsageVector.ResetBarrier ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="258" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="300" endline="318">
<![CDATA[
 
 		//
 		// Creates alias global namespace
 		//
 		public RootNamespace CreateRootNamespace (string alias)
 		{
 			if (alias == global_ns.Alias) {
 				NamespaceEntry.Error_GlobalNamespaceRedefined (Location.Null, Report);
 				return global_ns;
 			}
 
 			RootNamespace rn;
 			if (!alias_ns.TryGetValue (alias, out rn)) {
 				rn = new RootNamespace (alias);
 				alias_ns.Add (alias, rn);
 			}
 
 			return rn;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="259" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="74" endline="86">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!ResolveMemberType ())
 				return false;
 
 			const FieldAttributes attr = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal;
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, MemberType.GetMetaInfo (), attr);
 			spec = new ConstSpec (Parent.Definition, this, MemberType, FieldBuilder, ModFlags, initializer);
 
 			Parent.MemberCache.AddMember (spec);
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="260" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="128" endline="146">
<![CDATA[
 
 		public void Resolve (ResolveContext ec)
 		{
 			if (Expr == EmptyExpression.Null)
 				return;
 
 //			using (ec.With (ResolveContext.Options.DoFlowAnalysis, true)) {
 				// Verify that the argument is readable
 				if (ArgType != AType.Out)
 					Expr = Expr.Resolve (ec);
 
 				// Verify that the argument is writeable
 				if (Expr != null && IsByRef)
 					Expr = Expr.ResolveLValue (ec, EmptyExpression.OutAccess.Instance);
 
 				if (Expr == null)
 					Expr = EmptyExpression.Null;
 //			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="261" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1145" endline="1163">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			left = left.Resolve (ec);
 			right = right.Resolve (ec);
 
 			if (left == null || right == null)
 				return null;
 
 			eclass = ExprClass.Value;
 
 			Expression e = ConvertExpression (ec);
 			if (e == null) {
 				Binary.Error_OperatorCannotBeApplied (ec, left, right, "??", loc);
 				return null;
 			}
 
 			return e;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="262" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9272" endline="9279">
<![CDATA[
 		}
 
 		public CollectionElementInitializer (Expression argument)
 			
 		{
 			base.arguments.Add (new ElementInitializerArgument (argument));
 			this.loc = argument.Location;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="263" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="769" endline="784">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				right_side.DoResolveLValue (rc, this);
 				return null;
 			}
 
 			if (DoResolveCore (rc)) {
 				setter_args = CreateSetterArguments (rc, right_side);
 				setter = CreateCallSiteBinder (rc, setter_args, true);
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="264" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="187" endline="197">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (statement != null) {
 				statement.EmitStatement (ec);
 				ec.Emit (OpCodes.Ret);
 				return;
 			}
 
 			base.Emit (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="265" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1880" endline="1898">
<![CDATA[
 
 		public virtual void Error_AlreadyDeclared (string name, INamedBlockVariable variable)
 		{
 			var pi = variable as ParametersBlock.ParameterInfo;
 			if (pi != null) {
 				var p = pi.Parameter;
 				if (p is AnonymousTypeClass.GeneratedParameter) {
 					ParametersBlock.TopBlock.Report.Error (833, p.Location, "`{0}'
 						p.Name);
 				} else {
 					ParametersBlock.TopBlock.Report.Error (100, p.Location, "The parameter name `{0}' is a duplicate", p.Name);
 				}
 
 				return;
 			}
 
 			ParametersBlock.TopBlock.Report.Error (128, variable.Location,
 				"A local variable named `{0}' is already defined in this scope", name);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="266" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5304" endline="5310">
<![CDATA[
 
 		void Error_PropertyNotValid (ResolveContext ec)
 		{
 			ec.Report.SymbolRelatedToPreviousError (best_candidate);
 			ec.Report.Error (1546, loc, "Property or event `{0}' is not supported by the C# language",
 				GetSignatureForError ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="267" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="531" endline="539">
<![CDATA[
 
 		public void IsClsCompliant (IMemberContext ctx)
 		{
 			if (parameter_type.IsCLSCompliant ())
 				return;
 
 			ctx.Compiler.Report.Warning (3001, 1, Location,
 				"Argument type `{0}' is not CLS-compliant", parameter_type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="268" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="360" endline="379">
<![CDATA[
 		}
 
 		#endregion
 
 		public bool Define ()
 		{
 			if (type != null)
 				return true;
 
 			Namespace type_ns = module.GlobalRootNamespace.GetNamespace (ns, true);
 			var te = type_ns.LookupType (module.Compiler, name, arity, true, Location.Null);
 			if (te == null)
 				return false;
 
 			if (te.Type.Kind != kind)
 				return false;
 
 			type = te.Type;
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="269" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="763" endline="769">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddContinueOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="270" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1369" endline="1379">
<![CDATA[
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			if (IsAssigned (ec))
 				return true;
 
 			ec.Report.Error (165, loc,
 				      "Use of unassigned local variable `" + Name + "'");
 			ec.CurrentBranching.SetAssigned (this);
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="271" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5311" endline="5319">
<![CDATA[
 
 		bool IsSingleDimensionalArrayLength ()
 		{
 			if (best_candidate.DeclaringType != TypeManager.array_type || !best_candidate.HasGet || Name != "Length")
 				return false;
 
 			ArrayContainer ac = InstanceExpression.Type as ArrayContainer;
 			return ac != null && ac.Rank == 1;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="272" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9725" endline="9745">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression e = expr.Resolve (ec);
 			if (e == null)
 				return null;
 
 			if (e.eclass == ExprClass.MethodGroup) {
 				Error_InvalidInitializer (ec, e.ExprClassName);
 				return null;
 			}
 
 			type = e.Type;
 			if (type == TypeManager.void_type || type == InternalType.Null ||
 				type == InternalType.AnonymousMethod || type.IsPointer) {
 				Error_InvalidInitializer (ec, e.GetSignatureForError ());
 				return null;
 			}
 
 			return e;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="273" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="919" endline="927">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (!HasBeenReferenced)
 				ec.Report.Warning (164, 2, loc, "This label has not been referenced");
 
 			LabelTarget (ec);
 			ec.MarkLabel (label);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="274" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5837" endline="5872">
<![CDATA[
 
 		protected virtual IMemoryLocation EmitAddressOf (EmitContext ec, AddressOp mode)
 		{
 			LocalTemporary value_target = new LocalTemporary (type);
 
 			if (type is TypeParameterSpec) {
 				DoEmitTypeParameter (ec);
 				value_target.Store (ec);
 				value_target.AddressOf (ec, mode);
 				return value_target;
 			}
 
 			if (!TypeManager.IsStruct (type)){
 				//
 				// We throw an exception.  So far, I believe we only need to support
 				// value types
 				// foreach (int j in new StructType ())
 				// see bug 42390
 				//
 				throw new Exception ("AddressOf should not be used for classes");
 			}
 
 			value_target.AddressOf (ec, AddressOp.Store);
 
 			if (method == null) {
 				ec.Emit (OpCodes.Initobj, type);
 			} else {
 				if (arguments != null)
 					arguments.Emit (ec);
 
 				ec.Emit (OpCodes.Call, method);
 			}
 			
 			value_target.AddressOf (ec, mode);
 			return value_target;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="275" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="137" endline="145">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Store (ec);
 			if (useDefaultValue)
 				Invocation.EmitCall (ec, this, NullableInfo.GetGetValueOrDefault (expr.Type), null, loc);
 			else
 				Invocation.EmitCall (ec, this, NullableInfo.GetValue (expr.Type), null, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="276" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="243" endline="256">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (UnderlyingType == TypeManager.uint32_type ||
 				UnderlyingType == TypeManager.uint64_type ||
 				UnderlyingType == TypeManager.ushort_type) {
 				Report.Warning (3009, 1, Location, "`{0}'
 			}
 
 			return true;
 		}	
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="277" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1689" endline="1697">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			LocalTemporary temp_storage = new LocalTemporary(type);
 
 			temp_storage.AddressOf(ec, AddressOp.LoadStore);
 			ec.Emit(OpCodes.Initobj, type);
 			temp_storage.Emit(ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="278" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5705" endline="5719">
<![CDATA[
 
 		#endregion
 
 		void Error_AssignmentEventOnly (ResolveContext ec)
 		{
 			if (spec.DeclaringType == ec.CurrentType || TypeManager.IsNestedChildOf (ec.CurrentType, spec.DeclaringType.MemberDefinition)) {
 				ec.Report.Error (79, loc,
 					"The event `{0}' can only appear on the left hand side of `+=' or `-=' operator",
 					GetSignatureForError ());
 			} else {
 				ec.Report.Error (70, loc,
 					"The event `{0}' can only appear on the left hand side of += or -= when used outside of the type `{1}'",
 					GetSignatureForError (), spec.DeclaringType.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="279" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7179" endline="7206">
<![CDATA[
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// Target type is not System.Type therefore must be object
 			// and we need to use different encoding sequence
 			if (targetType != type)
 				enc.Encode (type);
 
 			if (!(QueriedType is GenericOpenTypeExpr)) {
 				var gt = typearg;
 				while (gt != null) {
 					if (InflatedTypeSpec.ContainsTypeParameter (gt)) {
 						rc.Compiler.Report.Error (416, loc, "`{0}'
 							typearg.GetSignatureForError ());
 						return;
 					}
 
 					gt = gt.DeclaringType;
 				}
 				while (gt != null) {
 					if (InflatedTypeSpec.ContainsTypeParameter (gt)) {
 						rc.Compiler.Report.Error (416, loc, "`{0}'
 							typearg.GetSignatureForError ());
 						return;
 					}
 
 					gt = gt.DeclaringType;
 				}
 
 				if (ContainsDynamicType (typearg)) {
 					Attribute.Error_AttributeArgumentIsDynamic (rc, loc);
 					return;
 				}
 			}
 
 			enc.EncodeTypeName (typearg);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="280" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8333" endline="8340">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			var ac = (ArrayContainer) ea.Expr.Type;
 
 			LoadArrayAndArguments (ec);
 			ec.EmitArrayAddress (ac);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="281" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="812" endline="836">
<![CDATA[
 		}
 
 		/// <summary>
 		///   Records a new namespace for resolving name references
 		/// </summary>
 		public void AddUsing (MemberName name, Location loc)
 		{
 			if (DeclarationFound){
 				Compiler.Report.Error (1529, loc, "A using clause must precede all other namespace elements except extern alias declarations");
 			}
 
 			if (using_clauses == null) {
 				using_clauses = new List<UsingEntry> ();
 			} else {
 				foreach (UsingEntry old_entry in using_clauses) {
 					if (name.Equals (old_entry.MemberName)) {
 						Compiler.Report.SymbolRelatedToPreviousError (old_entry.Location, old_entry.GetSignatureForError ());
 						Compiler.Report.Warning (105, 3, loc, "The using directive for `{0}' appeared previously in this namespace", name.GetSignatureForError ());
 						return;
 					}
 				}
 				foreach (UsingEntry old_entry in using_clauses) {
 					if (name.Equals (old_entry.MemberName)) {
 						Compiler.Report.SymbolRelatedToPreviousError (old_entry.Location, old_entry.GetSignatureForError ());
 						Compiler.Report.Warning (105, 3, loc, "The using directive for `{0}' appeared previously in this namespace", name.GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			using_clauses.Add (new UsingEntry (name));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="282" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2578" endline="2589">
<![CDATA[
 
 		// 
 		// Used together with AddCommonTypeBound fo implement
 		// 7.4.2.13 Finding the best common type of a set of expressions
 		//
 		public TypeInferenceContext ()
 		{
 			fixed_types = new TypeSpec [1];
 			tp_args = new TypeSpec [1];
 			tp_args[0] = InternalType.Arglist; // it can be any internal type
 			bounds = new List<BoundInfo> [1];
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="283" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9707" endline="9713">
<![CDATA[
 		
 		public AnonymousTypeParameter (Parameter parameter)
 			
 		{
 			this.Name = parameter.Name;
 			this.loc = parameter.Location;
 		}		
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="284" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="354" endline="363">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// TODO
 			LocalTemporary value_target = new LocalTemporary (type);
 
 			value_target.AddressOf (ec, AddressOp.Store);
 			ec.Emit (OpCodes.Initobj, type);
 			value_target.Emit (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="285" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4427" endline="4436">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (expr.CreateExpressionTree (ec)));
 			args.Add (new Argument (true_expr.CreateExpressionTree (ec)));
 			args.Add (new Argument (false_expr.CreateExpressionTree (ec)));
 			return CreateExpressionFactoryCall (ec, "Condition", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="286" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3220" endline="3228">
<![CDATA[
 
 		public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			return MemberCache.FindMember (queried_type, new MemberFilter ((MethodSpec) member),
 				BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="287" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1663" endline="1688">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			TypeExpr texpr = expr.ResolveAsTypeTerminal (ec, false);
 			if (texpr == null)
 				return null;
 
 			type = texpr.Type;
 
 			if (type.IsStatic) {
 				ec.Report.Error (-244, loc, "The `default value' operator cannot be applied to an operand of a static type");
 			}
 
 			if (type.IsPointer)
 				return new NullLiteral (Location).ConvertImplicitly (ec, type);
 
 			if (TypeManager.IsReferenceType (type))
 				return new NullConstant (type, loc);
 
 			Constant c = New.Constantify (type, expr.Location);
 			if (c != null)
 				return c.Resolve (ec);
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="288" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1163" endline="1181">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// We use recurse to allow ourselfs to be the source
 			// of an assignment. This little hack prevents us from
 			// having to allocate another expression
 			//
 			if (recurse) {
 				((IAssignMethod) expr).Emit (ec, is_expr && (mode == Mode.PostIncrement || mode == Mode.PostDecrement));
 
 				operation.Emit (ec);
 
 				recurse = false;
 				return;
 			}
 
 			EmitCode (ec, true);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="289" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="547" endline="557">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (0, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			return new Invocation (GetBinder ("InvokeConstructor", loc), binder_args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="290" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="624" endline="634">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 
 			if (actual.IsUnreachable)
 				Report.Warning (162, 2, stmt.loc, "Unreachable code detected");
 
 			actual.MergeChild (vector, false);
 			return actual;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="291" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="445" endline="464">
<![CDATA[
 
 		//
 		// We import any types but in the situation there are same types
 		// but one has better visibility (either public or internal with friend)
 		// the less visible type is removed from the namespace cache
 		//
 		public static TypeSpec IsImportedTypeOverride (TypeSpec ts, TypeSpec found)
 		{
 			var ts_accessible = (ts.Modifiers & Modifiers.PUBLIC) != 0 || ts.MemberDefinition.IsInternalAsPublic (RootContext.ToplevelTypes.DeclaringAssembly);
 			var found_accessible = (found.Modifiers & Modifiers.PUBLIC) != 0 || found.MemberDefinition.IsInternalAsPublic (RootContext.ToplevelTypes.DeclaringAssembly);
 
 			if (ts_accessible && !found_accessible)
 				return ts;
 
 			// found is better always better for accessible or inaccessible ts
 			if (!ts_accessible)
 				return found;
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="292" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2219" endline="2240">
<![CDATA[
 
 		protected override bool AddToContainer (MemberCore symbol, string name)
 		{
 			if (!(symbol is Constructor) && symbol.MemberName.Name == MemberName.Name) {
 				if (symbol is TypeParameter) {
 					Report.Error (694, symbol.Location,
 						"Type parameter `{0}' has same name as containing type, or method",
 						symbol.GetSignatureForError ());
 					return false;
 				}
 			
 				InterfaceMemberBase imb = symbol as InterfaceMemberBase;
 				if (imb == null || !imb.IsExplicitImpl) {
 					Report.SymbolRelatedToPreviousError (this);
 					Report.Error (542, symbol.Location, "`{0}'
 						symbol.GetSignatureForError ());
 					return false;
 				}
 			}
 
 			return base.AddToContainer (symbol, name);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="293" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="743" endline="755">
<![CDATA[
 
 		public override bool AddResumePoint (ResumableStatement stmt, Location loc, out int pc)
 		{
 			int errors = Report.Errors;
 			Parent.AddResumePoint (stmt, loc, out pc);
 			if (errors == Report.Errors) {
 				if (CurrentUsageVector.Next == null)
 					Report.Error (1626, loc, "Cannot yield a value in the body of a try block with a catch clause");
 				else
 					Report.Error (1631, loc, "Cannot yield a value in the body of a catch clause");
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="294" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1436" endline="1452">
<![CDATA[
 
 		Expression ResolveGenericParameter (ResolveContext ec, TypeSpec d, TypeParameterSpec t)
 		{
 			if (t.IsReferenceType) {
 				if (TypeManager.IsStruct (d))
 					return CreateConstantResult (ec, false);
 			}
 
 			if (TypeManager.IsGenericParameter (expr.Type)) {
 				if (t.IsValueType && expr.Type == d)
 					return CreateConstantResult (ec, true);
 
 				expr = new BoxedCast (expr, d);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="295" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1100" endline="1108">
<![CDATA[
 
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddBreakOrigin (ec.CurrentBranching.CurrentUsageVector, loc);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="296" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1057" endline="1067">
<![CDATA[
 
 		public static TypeInfo GetTypeInfo (TypeSpec type)
 		{
 			TypeInfo info;
 			if (type_hash.TryGetValue (type, out info))
 				return info;
 
 			info = new TypeInfo (type);
 			type_hash.Add (type, info);
 			return info;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="297" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="96" endline="381">
<![CDATA[
 
 		// <summary>
 		//   The type of this flow branching.
 		// </summary>
 		public readonly BranchingType Type;
 
 		// <summary>
 		//   The block this branching is contained in.  This may be null if it's not
 		//   a top-level block and it doesn't declare any local variables.
 		// </summary>
 		public readonly Block Block;
 
 		// <summary>
 		//   The parent of this branching or null if this is the top-block.
 		// </summary>
 		public readonly FlowBranching Parent;
 
 		// <summary>
 		//   Start-Location of this flow branching.
 		// </summary>
 		public readonly Location Location;
 
 		static int next_id = 0;
 		int id;
 
 		// <summary>
 		//   The vector contains a BitArray with information about which local variables
 		//   and parameters are already initialized at the current code position.
 		// </summary>
 		public class UsageVector {
 			// <summary>
 			//   The type of this branching.
 			// </summary>
 			public readonly SiblingType Type;
 
 			// <summary>
 			//   Start location of this branching.
 			// </summary>
 			public Location Location;
 
 			// <summary>
 			//   This is only valid for SwitchSection, Try, Catch and Finally.
 			// </summary>
 			public readonly Block Block;
 
 			// <summary>
 			//   The number of locals in this block.
 			// </summary>
 			public readonly int CountLocals;
 
 			// <summary>
 			//   If not null, then we inherit our state from this vector and do a
 			//   copy-on-write.  If null, then we're the first sibling in a top-level
 			//   block and inherit from the empty vector.
 			// </summary>
 			public readonly UsageVector InheritsFrom;
 
 			// <summary>
 			//   This is used to construct a list of UsageVector's.
 			// </summary>
 			public UsageVector Next;
 
 			//
 			// Private.
 			//
 			MyBitVector locals;
 			bool is_unreachable;
 
 			static int next_id = 0;
 			int id;
 
 			//
 			// Normally, you should not use any of these constructors.
 			//
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc, int num_locals)
 			{
 				this.Type = type;
 				this.Block = block;
 				this.Location = loc;
 				this.InheritsFrom = parent;
 				this.CountLocals = num_locals;
 
 				locals = num_locals == 0 
 					? MyBitVector.Empty
 					
 
 				if (parent != null)
 					is_unreachable = parent.is_unreachable;
 
 				id = ++next_id;
 
 			}
 
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc)
 				
 			{ }
 
 			private UsageVector (MyBitVector locals, bool is_unreachable, Block block, Location loc)
 			{
 				this.Type = SiblingType.Block;
 				this.Location = loc;
 				this.Block = block;
 
 				this.is_unreachable = is_unreachable;
 
 				this.locals = locals;
 
 				id = ++next_id;
 
 			}
 
 			// <summary>
 			//   This does a deep copy of the usage vector.
 			// </summary>
 			public UsageVector Clone ()
 			{
 				UsageVector retval = new UsageVector (Type, null, Block, Location, CountLocals);
 
 				retval.locals = locals.Clone ();
 				retval.is_unreachable = is_unreachable;
 
 				return retval;
 			}
 
 			public bool IsAssigned (VariableInfo var, bool ignoreReachability)
 			{
 				if (!ignoreReachability && !var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsAssigned (locals);
 			}
 
 			public void SetAssigned (VariableInfo var)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetAssigned (locals);
 			}
 
 			public bool IsFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsFieldAssigned (locals, name);
 			}
 
 			public void SetFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetFieldAssigned (locals, name);
 			}
 
 			public bool IsUnreachable {
 				get { return is_unreachable; }
 			}
 
 			public void ResetBarrier ()
 			{
 				is_unreachable = false;
 			}
 
 			public void Goto ()
 			{
 				is_unreachable = true;
 			}
 
 			public static UsageVector MergeSiblings (UsageVector sibling_list, Location loc)
 			{
 				if (sibling_list.Next == null)
 					return sibling_list;
 
 				MyBitVector locals = null;
 				bool is_unreachable = sibling_list.is_unreachable;
 
 				if (!sibling_list.IsUnreachable)
 					locals &= sibling_list.locals;
 
 				for (UsageVector child = sibling_list.Next; child != null; child = child.Next) {
 					is_unreachable &= child.is_unreachable;
 
 					if (!child.IsUnreachable)
 						locals &= child.locals;
 				}
 
 				return new UsageVector (locals, is_unreachable, null, loc);
 			}
 
 			// <summary>
 			//   Merges a child branching.
 			// </summary>
 			public UsageVector MergeChild (UsageVector child, bool overwrite)
 			{
 				Report.Debug (2, "    MERGING CHILD EFFECTS", this, child, Type);
 
 				bool new_isunr = child.is_unreachable;
 
 				//
 				// We've now either reached the point after the branching or we will
 				// never get there since we always return or always throw an exception.
 				//
 				// If we can reach the point after the branching, mark all locals and
 				// parameters as initialized which have been initialized in all branches
 				// we need to look at (see above).
 				//
 
 				if ((Type == SiblingType.SwitchSection) && !new_isunr) {
 					Report.Error (163, Location,
 						      "Control cannot fall through from one " +
 						      "case label to another");
 					return child;
 				}
 
 				locals |= child.locals;
 
 				// throw away un-necessary information about variables in child blocks
 				if (locals.Count != CountLocals)
 					locals = new MyBitVector (locals, CountLocals);
 
 				if (overwrite)
 					is_unreachable = new_isunr;
 				else
 					is_unreachable |= new_isunr;
 
 				return child;
 			}
 
 			public void MergeOrigins (UsageVector o_vectors)
 			{
 				Report.Debug (1, "  MERGING BREAK ORIGINS", this);
 
 				if (o_vectors == null)
 					return;
 
 				if (IsUnreachable && locals != null)
 					locals.SetAll (true);
 
 				for (UsageVector vector = o_vectors; vector != null; vector = vector.Next) {
 					Report.Debug (1, "    MERGING BREAK ORIGIN", vector);
 					if (vector.IsUnreachable)
 						continue;
 					locals &= vector.locals;
 					is_unreachable &= vector.is_unreachable;
 				}
 
 				Report.Debug (1, "  MERGING BREAK ORIGINS DONE", this);
 			}
 
 			//
 			// Debugging stuff.
 			//
 
 			public override string ToString ()
 			{
 				return String.Format ("Vector ({0},{1},{2}-{3})", Type, id, is_unreachable, locals);
 			}
 		}
 
 		// <summary>
 		//   Creates a new flow branching which is contained in `parent'.
 		//   You should only pass non-null for the `block' argument if this block
 		//   introduces any new variables - in this case, we need to create a new
 		//   usage vector with a different size than our parent's one.
 		// </summary>
 		protected FlowBranching (FlowBranching parent, BranchingType type, SiblingType stype,
 					 Block block, Location loc)
 		{
 			Parent = parent;
 			Block = block;
 			Location = loc;
 			Type = type;
 			id = ++next_id;
 
 			UsageVector vector;
 			if (Block != null) {
 				UsageVector parent_vector = parent != null ? parent.CurrentUsageVector 
 				vector = new UsageVector (stype, parent_vector, Block, loc, Block.AssignableSlots);
 			} else {
 				vector = new UsageVector (stype, Parent.CurrentUsageVector, null, loc);
 			}
 
 			AddSibling (vector);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="298" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1156" endline="1162">
<![CDATA[
 
 		void EmitCode (EmitContext ec, bool is_expr)
 		{
 			recurse = true;
 			this.is_expr = is_expr;
 			((IAssignMethod) expr).EmitAssign (ec, this, is_expr && (mode == Mode.PreIncrement || mode == Mode.PreDecrement), true);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="299" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3077" endline="3090">
<![CDATA[
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="300" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1127" endline="1135">
<![CDATA[
 
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddContinueOrigin (ec.CurrentBranching.CurrentUsageVector, loc);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="301" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1441" endline="1453">
<![CDATA[
 
 		bool Define (ResolveContext ec)
 		{
 			if (!Block.Resolved && Compatible (ec) == null)
 				return false;
 
 			if (block_name == null) {
 				MemberCore mc = (MemberCore) ec.MemberContext;
 				block_name = mc.MemberName.Basename;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="302" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="148" endline="161">
<![CDATA[
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (base.Resolve (ec, index) == null)
 				return null;
 
 			var ac = parameter_type as ArrayContainer;
 			if (ac == null || ac.Rank != 1) {
 				ec.Compiler.Report.Error (225, Location, "The params parameter must be a single dimensional array");
 				return null;
 			}
 
 			return parameter_type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="303" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2190" endline="2206">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (am_storey != null) {
 				DefineAnonymousStorey (ec);
 				am_storey.EmitStoreyInstantiation (ec, this);
 			}
 
 			bool emit_debug_info = SymbolWriter.HasSymbolWriter && Parent != null && !(am_storey is IteratorStorey);
 			if (emit_debug_info)
 				ec.BeginScope ();
 
 			base.Emit (ec);
 
 			if (emit_debug_info)
 				ec.EndScope ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="304" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1227" endline="1246">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			unwrap = Unwrap.Create (expr, false);
 			if (unwrap == null)
 				return null;
 
 			underlying = (UnaryMutator) new UnaryMutator (Mode, unwrap, loc).Resolve (ec);
 			if (underlying == null)
 				return null;
 
 
 			eclass = ExprClass.Value;
 			type = expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="305" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8953" endline="8960">
<![CDATA[
 
 		void MakeArray (ComposedTypeSpecifier spec)
 		{
 			if (spec.Next != null)
 				MakeArray (spec.Next);
 
 			type = ArrayContainer.MakeType (type, spec.Dimension);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="306" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1478" endline="1487">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			expr.Emit (ec);
 
 			ec.Emit (OpCodes.Isinst, type);
 
 			if (TypeManager.IsGenericParameter (type) || TypeManager.IsNullableType (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="307" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3324" endline="3335">
<![CDATA[
 		protected MemberBase (DeclSpace parent, GenericMethod generic,
 				      FullNamedExpression type, Modifiers mod, Modifiers allowed_mod, Modifiers def_mod,
 				      MemberName name, Attributes attrs)
 			
 		{
 			this.ds = generic != null ? generic 
 			this.type_expr = type;
 			ModFlags = ModifiersExtensions.Check (allowed_mod, mod, def_mod, Location, Report);
 			GenericMethod = generic;
 			if (GenericMethod != null)
 				GenericMethod.ModFlags = ModFlags;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="308" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="304" endline="318">
<![CDATA[
 
 		public void VerifyClsCompliance (Report report)
 		{
 			foreach (var c in constraints)
 			{
 				if (c == null)
 					continue;
 
 				if (!c.Type.IsCLSCompliant ()) {
 					report.SymbolRelatedToPreviousError (c.Type);
 					report.Warning (3024, 1, loc, "Constraint type `{0}' is not CLS-compliant",
 						c.Type.GetSignatureForError ());
 				}
 			}
 			foreach (var c in constraints)
 			{
 				if (c == null)
 					continue;
 
 				if (!c.Type.IsCLSCompliant ()) {
 					report.SymbolRelatedToPreviousError (c.Type);
 					report.Warning (3024, 1, loc, "Constraint type `{0}' is not CLS-compliant",
 						c.Type.GetSignatureForError ());
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="309" nfragments="2" Csharpe_files="1" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6012" endline="6018">
<![CDATA[
 {
 	if (expr is Invocation){
 		Report.Error (1002, expr.Location, "Expecting `;'");
 	} else {
 		Expression.Error_InvalidExpressionStatement (Report, expr.Location);
 	}
 }
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="310" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5288" endline="5302">
<![CDATA[
 
 		public static bool IsSpecialMethodInvocation (ResolveContext ec, MethodSpec method, Location loc)
 		{
 			if (!method.IsReservedMethod)
 				return false;
 
 			if (ec.HasSet (ResolveContext.Options.InvokeSpecialName) || ec.CurrentMemberDefinition.IsCompilerGenerated)
 				return false;
 
 			ec.Report.SymbolRelatedToPreviousError (method);
 			ec.Report.Error (571, loc, "`{0}'
 				method.GetSignatureForError ());
 	
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="311" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="415" endline="427">
<![CDATA[
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			if (!IsUnsafe)
 				Expression.UnsafeError (Report, Location);
 
 			if (Parent.PartialContainer.Kind != MemberKind.Struct) {
 				Report.Error (1642, Location, "`{0}'
 					GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="312" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="869" endline="888">
<![CDATA[
 
 		TypeSpec CompatibleChecks (ResolveContext ec, TypeSpec delegate_type)
 		{
 			if (delegate_type.IsDelegate)
 				return delegate_type;
 
 			if (delegate_type.IsGeneric && delegate_type.GetDefinition () == TypeManager.expression_type) {
 				delegate_type = delegate_type.TypeArguments [0];
 				if (delegate_type.IsDelegate)
 					return delegate_type;
 
 				ec.Report.Error (835, loc, "Cannot convert `{0}' to an expression tree of non-delegate type `{1}'",
 					GetSignatureForError (), TypeManager.CSharpName (delegate_type));
 				return null;
 			}
 
 			ec.Report.Error (1660, loc, "Cannot convert `{0}' to non-delegate type `{1}'",
 				      GetSignatureForError (), TypeManager.CSharpName (delegate_type));
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="313" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="839" endline="855">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			MemberAccess sle = new MemberAccess (new MemberAccess (
 				new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Linq", loc), "Expressions", loc);
 
 			var flags = ec.HasSet (ResolveContext.Options.CheckedScope) ? CSharpBinderFlags.CheckedContext 
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new MemberAccess (new MemberAccess (sle, "ExpressionType", loc), name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			return new Invocation (GetBinder ("UnaryOperation", loc), binder_args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="314" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="346" endline="353">
<![CDATA[
 
 		public static Constant CreateFromExpression (ResolveContext ec, Expression e)
 		{
 			ec.Report.Warning (458, 2, e.Location, "The result of the expression is always `null' of type `{0}'",
 				TypeManager.CSharpName (e.Type));
 
 			return ReducedExpression.Create (Create (e.Type, e.Location), e);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="315" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="793" endline="805">
<![CDATA[
 		}
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			if (OptAttributes == null)
 				return null;
 
 			Attribute a = OptAttributes.Search (Module.PredefinedAttributes.CoClass);
 			if (a == null)
 				return null;
 
 			return a.GetCoClassAttributeValue ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="316" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="678" endline="695">
<![CDATA[
 
 		/// <summary>
 		/// Returns value of CLSCompliantAttribute contructor parameter but because the method can be called
 		/// before ApplyAttribute. We need to resolve the arguments.
 		/// This situation occurs when class deps is differs from Emit order.  
 		/// </summary>
 		public bool GetClsCompliantAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return false;
 
 			return ((BoolConstant) PosArguments[0].Expr).Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="317" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="712" endline="722">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			for (UsageVector origin = return_origins; origin != null; origin = origin.Next)
 				Block.ParametersBlock.CheckOutParameters (origin, origin.Location);
 			for (UsageVector origin = return_origins; origin != null; origin = origin.Next)
 				Block.ParametersBlock.CheckOutParameters (origin, origin.Location);
 
 			UsageVector vector = base.Merge ();
 			Block.ParametersBlock.CheckOutParameters (vector, Block.loc);
 			// Note
 			return vector;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="318" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6925" endline="6935">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			ResolveBase (ec);
 
 			if (variable_info != null && type.IsStruct) {
 				CheckStructThisDefiniteAssignment (ec);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="319" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="808" endline="831">
<![CDATA[
 
 		//
 		// Finds effective base class
 		//
 		public TypeSpec GetEffectiveBase ()
 		{
 			if (HasSpecialStruct) {
 				return TypeManager.value_type;
 			}
 
 			if (BaseType != null && targs == null)
 				return BaseType;
 
 			var types = targs;
 			if (HasTypeConstraint) {
 				Array.Resize (ref types, types.Length + 1);
 				types[types.Length - 1] = BaseType;
 			}
 
 			if (types != null)
 				return Convert.FindMostEncompassedType (types.Select (l => l.BaseType));
 
 			return TypeManager.object_type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="320" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1935" endline="1949">
<![CDATA[
 
 		public bool ResolveBuilder ()
 		{
 			if (ctor != null)
 				return true;
 
 			//
 			// Handle all parameter-less attributes as optional
 			//
 			if (!IsDefined)
 				return false;
 
 			ctor = TypeManager.GetPredefinedConstructor (type, Location.Null, TypeSpec.EmptyTypes);
 			return ctor != null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="321" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="518" endline="531">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			// Field initializer can be resolved (fail) many times
 			if (source == null)
 				return null;
 
 			if (resolved == null) {
 				var ctx = new FieldInitializerContext (mc, ec);
 				resolved = base.DoResolve (ctx) as ExpressionStatement;
 			}
 
 			return resolved;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="322" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1950" endline="1961">
<![CDATA[
 
 		public bool ResolveConstructor (Location loc, params TypeSpec[] argType)
 		{
 			if (ctor != null)
 				throw new InternalErrorException ("Predefined ctor redefined");
 
 			if (Resolve (loc) == null)
 				return false;
 
 			ctor = TypeManager.GetPredefinedConstructor (type, loc, argType);
 			return ctor != null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="323" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4826" endline="4833">
<![CDATA[
 
 		public bool IsMarshalByRefAccess ()
 		{
 			// Checks possible ldflda of field access expression
 			return !spec.IsStatic && TypeManager.IsValueType (spec.MemberType) &&
 				TypeSpec.IsBaseClass (spec.DeclaringType, TypeManager.mbr_type, false) &&
 				!(InstanceExpression is This);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="324" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\literal.cs" startline="117" endline="132">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			//
 			// The 0 literal can be converted to an enum value
 			//
 			if (Value == 0 && TypeManager.IsEnumType (type)) {
 				Constant c = ConvertImplicitly (rc, EnumSpec.GetUnderlyingType (type));
 				if (c == null)
 					return null;
 
 				return new EnumConstant (c, type).Resolve (rc);
 			}
 
 			return base.ConvertImplicitly (rc, type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="325" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1419" endline="1444">
<![CDATA[
 
 		protected override Expression ResolveInitializer (BlockContext bc, LocalVariable li, Expression initializer)
 		{
 			initializer = initializer.Resolve (bc);
 			if (initializer == null)
 				return null;
 
 			var c = initializer as Constant;
 			if (c == null) {
 				initializer.Error_ExpressionMustBeConstant (bc, initializer.Location, li.Name);
 				return null;
 			}
 
 			c = c.ConvertImplicitly (bc, li.Type);
 			if (c == null) {
 				if (TypeManager.IsReferenceType (li.Type))
 					initializer.Error_ConstantCanBeInitializedWithNullOnly (bc, li.Type, initializer.Location, li.Name);
 				else
 					initializer.Error_ValueCannotBeConverted (bc, initializer.Location, li.Type, false);
 
 				return null;
 			}
 
 			li.ConstantValue = c;
 			return initializer;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="326" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5820" endline="5831">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			LocalTemporary v = null;
 			if (method == null && TypeManager.IsValueType (type)) {
 				// TODO
 				v = new LocalTemporary (type);
 			}
 
 			if (Emit (ec, v))
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="327" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3323" endline="3359">
<![CDATA[
 
 
 		Expression ResolveOperatorPointer (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			//
 			// bool operator == (void* x, void* y);
 			// bool operator != (void* x, void* y);
 			// bool operator < (void* x, void* y);
 			// bool operator > (void* x, void* y);
 			// bool operator <= (void* x, void* y);
 			// bool operator >= (void* x, void* y);
 			//
 			if ((oper & Operator.ComparisonMask) != 0) {
 				Expression temp;
 				if (!l.IsPointer) {
 					temp = Convert.ImplicitConversion (ec, left, r, left.Location);
 					if (temp == null)
 						return null;
 					left = temp;
 				}
 
 				if (!r.IsPointer) {
 					temp = Convert.ImplicitConversion (ec, right, l, right.Location);
 					if (temp == null)
 						return null;
 					right = temp;
 				}
 
 				type = TypeManager.bool_type;
 				return this;
 			}
 
 			if (pointer_operators == null)
 				CreatePointerOperatorsTable ();
 
 			return ResolveOperatorPredefined (ec, pointer_operators, false, null);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="328" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="874" endline="893">
<![CDATA[
 
 	/// <summary>
 	///   Utility function that can be used to probe whether a type
 	///   is managed or not.  
 	/// </summary>
 	public static bool VerifyUnmanaged (CompilerContext ctx, TypeSpec t, Location loc)
 	{
 		while (t.IsPointer)
 			t = GetElementType (t);
 		while (t.IsPointer)
 			t = GetElementType (t);
 
 		if (IsUnmanagedType (t))
 			return true;
 
 		ctx.Report.SymbolRelatedToPreviousError (t);
 		ctx.Report.Error (208, loc,
 			"Cannot take the address of, get the size of, or declare a pointer to a managed type `{0}'",
 			CSharpName (t));
 
 		return false;	
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="329" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1362" endline="1368">
<![CDATA[
 
 		public bool IsAssigned (ResolveContext ec)
 		{
 			return !ec.DoFlowAnalysis ||
 				(ec.OmitStructFlowAnalysis && TypeInfo.Type.IsStruct) ||
 				ec.CurrentBranching.IsAssigned (this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="330" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="759" endline="768">
<![CDATA[
 
 		protected abstract Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet);
 
 		protected virtual Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			var setter_args = new Arguments (Arguments.Count + 1);
 			setter_args.AddRange (Arguments);
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="331" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8567" endline="8575">
<![CDATA[
 
 		IParametersMember OverloadResolver.IBaseMembersProvider.GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			var filter = new MemberFilter (MemberCache.IndexerNameAlias, 0, MemberKind.Indexer, ((IndexerSpec) member).Parameters, null);
 			return MemberCache.FindMember (queried_type, filter, BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="332" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2111" endline="2122">
<![CDATA[
 
 		bool ResolveTransformationCtor (Location loc)
 		{
 			if (tctor != null)
 				return true;
 
 			if (Resolve (loc) == null)
 				return false;
 
 			tctor = TypeManager.GetPredefinedConstructor (type, Location.Null, ArrayContainer.MakeType (TypeManager.bool_type));
 			return tctor != null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="333" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="281" endline="326">
<![CDATA[
 
 		protected void Error_ValueCannotBeConvertedCore (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			// The error was already reported as CS1660
 			if (type == InternalType.AnonymousMethod)
 				return;
 
 /*
 			if (TypeManager.IsGenericParameter (Type) && TypeManager.IsGenericParameter (target) && type.Name == target.Name) {
 				string sig1 = type.DeclaringMethod == null ?
 					TypeManager.CSharpName (type.DeclaringType) 
 					TypeManager.CSharpSignature (type.DeclaringMethod);
 				string sig2 = target.DeclaringMethod == null ?
 					TypeManager.CSharpName (target.DeclaringType) 
 					TypeManager.CSharpSignature (target.DeclaringMethod);
 				ec.Report.ExtraInformation (loc,
 					String.Format (
 						"The generic parameter `{0}' of `{1}' cannot be converted to the generic parameter `{0}' of `{2}' (in the previous ",
 						Type.Name, sig1, sig2));
 			} else if (Type.MetaInfo.FullName == target.MetaInfo.FullName) {
 				ec.Report.ExtraInformation (loc,
 					String.Format (
 					"The type `{0}' has two conflicting definitions, one comes from `{1}' and the other from `{2}' (in the previous ",
 					Type.MetaInfo.FullName, Type.Assembly.FullName, target.Assembly.FullName));
 			}
 */
 			if (expl) {
 				ec.Report.Error (30, loc, "Cannot convert type `{0}' to `{1}'",
 					TypeManager.CSharpName (type), TypeManager.CSharpName (target));
 				return;
 			}
 
 			ec.Report.DisableReporting ();
 			bool expl_exists = Convert.ExplicitConversion (ec, this, target, Location.Null) != null;
 			ec.Report.EnableReporting ();
 
 			if (expl_exists) {
 				ec.Report.Error (266, loc, "Cannot implicitly convert type `{0}' to `{1}'. " +
 					      "An explicit conversion exists (are you missing a cast?)",
 					TypeManager.CSharpName (Type), TypeManager.CSharpName (target));
 				return;
 			}
 
 			ec.Report.Error (29, loc, "Cannot implicitly convert type `{0}' to `{1}'",
 				type.GetSignatureForError (), target.GetSignatureForError ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="334" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="588" endline="594">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (continue_origins);
 			return vector;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="335" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="572" endline="591">
<![CDATA[
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="336" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="970" endline="977">
<![CDATA[
 
 		public Expression GetParameterDefaultValue ()
 		{
 			if (PosArguments == null)
 				return null;
 
 			return PosArguments[0].Expr;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="337" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1441" endline="1471">
<![CDATA[
 
 		protected override bool CheckBase ()
 		{
 			if ((ModFlags & Modifiers.STATIC) != 0) {
 				if (!parameters.IsEmpty) {
 					Report.Error (132, Location, "`{0}'
 						GetSignatureForError ());
 					return false;
 				}
 
 				// the rest can be ignored
 				return true;
 			}
 
 			// Check whether arguments were correct.
 			if (!DefineParameters (parameters))
 				return false;
 
 			if ((caching_flags & Flags.MethodOverloadsExist) != 0)
 				Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 
 			if (Parent.PartialContainer.Kind == MemberKind.Struct && parameters.IsEmpty) {
 				Report.Error (568, Location, 
 					"Structs cannot contain explicit parameterless constructors");
 				return false;
 			}
 
 			CheckProtectedModifier ();
 			
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="338" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8118" endline="8132">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			type = Expr.Type;
 
 			var res = CreateAccessExpression (ec);
 			if (res == null)
 				return null;
 
 			return res.ResolveLValue (ec, right_side);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="339" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1278" endline="1288">
<![CDATA[
 
 		public TypeSpec Mutate (TypeSpec ts)
 		{
 			TypeSpec value;
 			if (mutated_typespec.TryGetValue (ts, out value))
 				return value;
 
 			value = ts.Mutate (this);
 			mutated_typespec.Add (ts, value);
 			return value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="340" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="174" endline="186">
<![CDATA[
 		}
 
 		void Store (EmitContext ec)
 		{
 			if (expr is VariableReference)
 				return;
 
 			if (temp != null)
 				return;
 
 			expr.Emit (ec);
 			LocalVariable.Store (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="341" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6761" endline="6769">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 			if (type == null)
 				type = ec.CurrentType;
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="342" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="546" endline="556">
<![CDATA[
 		}
 
 		public bool IsDefaultInitializer {
 			get {
 				Constant c = source as Constant;
 				if (c == null)
 					return false;
 				
 				FieldExpr fe = (FieldExpr)target;
 				return c.IsDefaultInitializer (fe.Type);
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="343" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="218" endline="227">
<![CDATA[
 
 		public int CountTypeArguments {
 			get {
 				if (TypeArguments != null)
 					return TypeArguments.Count;
 				else if (Left != null)
 					return Left.CountTypeArguments; 
 				else
 					return 0;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="344" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1249" endline="1257">
<![CDATA[
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (child.Type == target_type)
 				return child;
 
 			// FIXME
 			return child.ConvertExplicitly (in_checked_context, target_type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="345" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1262" endline="1277">
<![CDATA[
 		}
 
 		#endregion
 
 		public static TypeSpec GetMemberDeclaringType (TypeSpec type)
 		{
 			if (type is InflatedTypeSpec) {
 				if (type.DeclaringType == null)
 					return type.GetDefinition ();
 
 				var parent = GetMemberDeclaringType (type.DeclaringType);
 				type = MemberCache.GetMember<TypeSpec> (parent, type);
 			}
 
 			return type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="346" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="114" endline="124">
<![CDATA[
 		}
 
 		public bool IsGeneric {
 			get {
 				if (TypeArguments != null)
 					return true;
 				else if (Left != null)
 					return Left.IsGeneric;
 				else
 					return false;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="347" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3438" endline="3455">
<![CDATA[
 
 		protected virtual bool ResolveMemberType ()
 		{
 			if (member_type != null)
 				throw new InternalErrorException ("Multi-resolve");
 
 			TypeExpr te = type_expr.ResolveAsTypeTerminal (this, false);
 			if (te == null)
 				return false;
 			
 			//
 			// Replace original type name, error reporting can use fully resolved name
 			//
 			type_expr = te;
 
 			member_type = te.Type;
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="348" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="113" endline="127">
<![CDATA[
 
 		public bool ResolveMethodGroup (ResolveContext ec)
 		{
 			SimpleName sn = Expr as SimpleName;
 			if (sn != null)
 				Expr = sn.GetMethodGroup ();
 
 			// FIXME
 			//        `out' in a delegate creation expression.
 			Expr = Expr.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.MethodGroup);
 			if (Expr == null)
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="349" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5649" endline="5666">
<![CDATA[
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.EventAddition) {
 				op = spec.AccessorAdd;
 			} else if (right_side == EmptyExpression.EventSubtraction) {
 				op = spec.AccessorRemove;
 			}
 
 			if (op == null) {
 				Error_AssignmentEventOnly (ec);
 				return null;
 			}
 
 			op = CandidateToBaseOverride (ec, op);
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="350" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3091" endline="3098">
<![CDATA[
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="351" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="82" endline="96">
<![CDATA[
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="352" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="547" endline="555">
<![CDATA[
 	}
 
 	public class FlowBranchingBreakable 
 	{
 		UsageVector break_origins;
 
 		public FlowBranchingBreakable (FlowBranching parent, BranchingType type, SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="571" endline="579">
<![CDATA[
 	}
 
 	public class FlowBranchingContinuable 
 	{
 		UsageVector continue_origins;
 
 		public FlowBranchingContinuable (FlowBranching parent, BranchingType type, SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="353" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="547" endline="555">
<![CDATA[
 	}
 
 	public class FlowBranchingBreakable 
 	{
 		UsageVector break_origins;
 
 		public FlowBranchingBreakable (FlowBranching parent, BranchingType type, SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="630" endline="637">
<![CDATA[
 
 		//
 		// Creates method owned type parameter
 		//
 		public TypeParameterSpec (int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="354" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="196" endline="203">
<![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="74" endline="82">
<![CDATA[
     End Property
 
     Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="355" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1461" endline="1469">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="356" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1539" endline="1547">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="357" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2103" endline="2111">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="358" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="865" endline="873">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasConstant()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="359" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1188" endline="1196">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasDeclSecurity()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="360" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1588" endline="1596">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteMethodDef()
 				.WriteHasSemantics()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="361" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2209" endline="2217">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="362" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2305" endline="2313">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteTypeOrMethodDef()
 				.WriteStringIndex()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="363" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1979" endline="1988">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(16)
 				.WriteBlobIndex()
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="364" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1847" endline="1856">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteMemberForwarded()
 				.WriteStringIndex()
 				.WriteModuleRef()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="365" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2150" endline="2159">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="366" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="645" endline="654">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.WriteParam()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="367" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="462" endline="472">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteGuidIndex()
 				.WriteGuidIndex()
 				.WriteGuidIndex()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="368" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2060" endline="2070">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(12)
 				.WriteBlobIndex()
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="369" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="563" endline="574">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.WriteField()
 				.WriteMethodDef()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="370" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="291" endline="297">
<![CDATA[
 
     Public Function CreateAndEmitNop() As Mono.Cecil.Cil.Instruction
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         CilWorker.Append(result)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="371" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="335" endline="358">
<![CDATA[
 	}
 
 	public struct CapturedVariable
 	{
 		#region This is actually written to the symbol file
 		public readonly string Name;
 		public readonly string CapturedName;
 		public readonly CapturedKind Kind;
 		#endregion
 
 		public enum CapturedKind 
 		{
 			Local,
 			Parameter,
 			This
 		}
 
 		public CapturedVariable (string name, string captured_name,
 					 CapturedKind kind)
 		{
 			this.Name = name;
 			this.CapturedName = captured_name;
 			this.Kind = kind;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="299" endline="314">
<![CDATA[
 	}
 
 	public struct LocalVariableEntry
 	{
 		#region This is actually written to the symbol file
 		public readonly int Index;
 		public readonly string Name;
 		public readonly int BlockIndex;
 		#endregion
 
 		public LocalVariableEntry (int index, string name, int block)
 		{
 			this.Index = index;
 			this.Name = name;
 			this.BlockIndex = block;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="372" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1440" endline="1454">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This kind of cast is used to encapsulate Value Types in objects.
 	///
 	///   The effect of it is to box the value type emitted by the previous
 	///   operation.
 	/// </summary>
 	public class BoxedCast 
 
 		public BoxedCast (Expression expr, TypeSpec target_type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="291" endline="299">
<![CDATA[
 	}
 
 	public class Wrap 
 	{
 		private Wrap (Expression expr, TypeSpec type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="373" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1440" endline="1454">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This kind of cast is used to encapsulate Value Types in objects.
 	///
 	///   The effect of it is to box the value type emitted by the previous
 	///   operation.
 	/// </summary>
 	public class BoxedCast 
 
 		public BoxedCast (Expression expr, TypeSpec target_type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="329" endline="340">
<![CDATA[
 	}
 
 	//
 	// Represents null literal lifted to nullable type
 	//
 	public class LiftedNull 
 	{
 		private LiftedNull (TypeSpec nullable_type, Location loc)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="374" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="757" endline="763">
<![CDATA[
 
 		public override void Error_AlreadyDeclaredTypeParameter (string name, Location loc)
 		{
 			TopBlock.Report.Error (1948, loc,
 				"A range variable `{0}' conflicts with a method type parameter",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1184" endline="1190">
<![CDATA[
 
 		public static void Error_AddressOfCapturedVar (ResolveContext ec, IVariableReference var, Location loc)
 		{
 			ec.Report.Error (1686, loc,
 				"Local variable or parameter `{0}' cannot have their address taken and be used inside an anonymous method or lambda expression",
 				var.Name);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="375" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="757" endline="763">
<![CDATA[
 
 		public override void Error_AlreadyDeclaredTypeParameter (string name, Location loc)
 		{
 			TopBlock.Report.Error (1948, loc,
 				"A range variable `{0}' conflicts with a method type parameter",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3715" endline="3721">
<![CDATA[
 
 		public static void Error_ConstructorMismatch (ResolveContext rc, TypeSpec type, int argCount, Location loc)
 		{
 			rc.Report.Error (1729, loc,
 				"The type `{0}' does not contain a constructor that takes `{1}' arguments",
 				type.GetSignatureForError (), argCount.ToString ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="376" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="757" endline="763">
<![CDATA[
 
 		public override void Error_AlreadyDeclaredTypeParameter (string name, Location loc)
 		{
 			TopBlock.Report.Error (1948, loc,
 				"A range variable `{0}' conflicts with a method type parameter",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="361" endline="367">
<![CDATA[
 
 		public static void Error_TypeDoesNotContainDefinition (ResolveContext ec, Location loc, TypeSpec type, string name)
 		{
 			ec.Report.SymbolRelatedToPreviousError (type);
 			ec.Report.Error (117, loc, "`{0}' does not contain a definition for `{1}'",
 				TypeManager.CSharpName (type), name);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="377" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="706" endline="716">
<![CDATA[
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7462" endline="7476">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the qualified-alias-member (
 	/// </summary>
 	public class QualifiedAliasMember 
 	{
 		readonly string alias;
 		public static readonly string GlobalAlias = "global";
 
 		public QualifiedAliasMember (string alias, string identifier, Location l)
 			
 		{
 			this.alias = alias;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="378" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="706" endline="716">
<![CDATA[
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9137" endline="9150">
<![CDATA[
 	}
 
 	//
 	// An object initializer expression
 	//
 	public class ElementInitializer 
 	{
 		public readonly string Name;
 
 		public ElementInitializer (string name, Expression initializer, Location loc)
 			
 		{
 			this.Name = name;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="379" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="706" endline="716">
<![CDATA[
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5078" endline="5086">
<![CDATA[
 		}
 
 		VariableDeclaration decl;
 
 		public Using (VariableDeclaration decl, Statement stmt, Location loc)
 			
 		{
 			this.decl = decl;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="380" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2380" endline="2386">
<![CDATA[
 
 		void Error_UnexpectedDirective (string extra)
 		{
 			Report.Error (
 				1028, Location,
 				"Unexpected processor directive ({0})", extra);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="233" endline="242">
<![CDATA[
 
 		/// <summary>
 		/// This is rather hack. We report many emit attribute error with same error to be compatible with
 		/// csc. But because csc has to report them this way because error came from ilasm we needn't.
 		/// </summary>
 		public void Error_AttributeEmitError (string inner)
 		{
 			Report.Error (647, Location, "Error during emitting `{0}' attribute. The reason is `{1}'",
 				      TypeManager.CSharpName (Type), inner);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="381" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2380" endline="2386">
<![CDATA[
 
 		void Error_UnexpectedDirective (string extra)
 		{
 			Report.Error (
 				1028, Location,
 				"Unexpected processor directive ({0})", extra);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3248" endline="3254">
<![CDATA[
 
 		protected void Error_StaticReturnType ()
 		{
 			Report.Error (722, Location,
 				"`{0}'
 				MemberType.GetSignatureForError ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="382" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="213" endline="219">
<![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="168" endline="174">
<![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="383" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
<![CDATA[
 		}
 
 		internal abstract int ImportTo(Emit.ModuleBuilder module);
 
 		internal virtual FieldInfo BindTypeParameters(Type type)
 		{
 			return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1999" endline="2006">
<![CDATA[
 	}
 
 	sealed class PointerType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new PointerType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="384" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
<![CDATA[
 		}
 
 		internal abstract int ImportTo(Emit.ModuleBuilder module);
 
 		internal virtual FieldInfo BindTypeParameters(Type type)
 		{
 			return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1669" endline="1680">
<![CDATA[
 
 		protected abstract string GetSuffix();
 
 		protected abstract Type Wrap(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
 	}
 
 	sealed class ArrayType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ArrayType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="385" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
<![CDATA[
 		}
 
 		internal abstract int ImportTo(Emit.ModuleBuilder module);
 
 		internal virtual FieldInfo BindTypeParameters(Type type)
 		{
 			return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1886" endline="1958">
<![CDATA[
 		}
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodInfo method;
 			private readonly Type type;
 			private readonly int pos;
 
 			internal ParameterInfoImpl(MethodInfo method, Type type, int pos)
 			{
 				this.method = method;
 				this.type = type;
 				this.pos = pos;
 			}
 
 			public override Type ParameterType
 			{
 				get { return type; }
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return pos; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { return null; }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method.IsConstructor ? (MethodBase)new ConstructorInfoImpl(method) 
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x8000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 	}
 
 	sealed class ByRefType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ByRefType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="386" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
<![CDATA[
 		}
 
 		internal abstract int ImportTo(Emit.ModuleBuilder module);
 
 		internal virtual FieldInfo BindTypeParameters(Type type)
 		{
 			return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1757" endline="1766">
<![CDATA[
 	}
 
 	sealed class MultiArrayType 
 	{
 		private readonly int rank;
 
 		internal static Type Make(Type type, int rank, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new MultiArrayType(type, rank, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="387" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
<![CDATA[
 		}
 
 		internal abstract int ImportTo(Emit.ModuleBuilder module);
 
 		internal virtual FieldInfo BindTypeParameters(Type type)
 		{
 			return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="388" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
<![CDATA[
 		}
 
 		internal abstract int ImportTo(Emit.ModuleBuilder module);
 
 		internal virtual FieldInfo BindTypeParameters(Type type)
 		{
 			return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="80" endline="87">
<![CDATA[
 
 		internal FieldSignature ExpandTypeParameters(Type declaringType)
 		{
 			return new FieldSignature(
 				fieldType.BindTypeParameters(declaringType),
 				BindTypeParameters(declaringType, optionalCustomModifiers),
 				BindTypeParameters(declaringType, requiredCustomModifiers));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="389" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
<![CDATA[
 		}
 
 		internal abstract int ImportTo(Emit.ModuleBuilder module);
 
 		internal virtual FieldInfo BindTypeParameters(Type type)
 		{
 			return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="258" endline="293">
<![CDATA[
 		}
 
 		private sealed class Binder 
 		{
 			private readonly Type declaringType;
 			private readonly Type[] methodArgs;
 
 			internal Binder(Type declaringType, Type[] methodArgs)
 			{
 				this.declaringType = declaringType;
 				this.methodArgs = methodArgs;
 			}
 
 			public Type BindTypeParameter(Type type)
 			{
 				return declaringType.GetGenericTypeArgument(type.GenericParameterPosition);
 			}
 
 			public Type BindMethodParameter(Type type)
 			{
 				if (methodArgs == null)
 				{
 					return type;
 				}
 				return methodArgs[type.GenericParameterPosition];
 			}
 		}
 
 		internal MethodSignature Bind(Type type, Type[] methodArgs)
 		{
 			Binder binder = new Binder(type, methodArgs);
 			return new MethodSignature(returnType.BindTypeParameters(binder),
 				BindTypeParameters(binder, parameterTypes),
 				BindTypeParameters(binder, modifiers),
 				callingConvention, genericParamCount);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="390" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2986" endline="3007">
<![CDATA[
 	}
 	
 	public class SwitchLabel {
 		Expression label;
 		object converted;
 		Location loc;
 
 		Label il_label;
 		bool  il_label_set;
 		Label il_label_code;
 		bool  il_label_code_set;
 
 		public static readonly object NullStringCase = new object ();
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="391" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="701" endline="713">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the return statement
 	/// </summary>
 	public class Return 
 	{
 		protected Expression Expr;
 		public Return (Expression expr, Location l)
 		{
 			Expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="392" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4689" endline="4867">
<![CDATA[
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return local_info.VariableInfo; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return local_info.HoistedVariant;
 		}
 
 		#region Properties
 
 		//		
 		// A local variable is always fixed
 		//
 		public override bool IsFixed {
 			get {
 				return true;
 			}
 		}
 
 		public override bool IsLockedByStatement {
 			get {
 				return local_info.IsLocked;
 			}
 			set {
 				local_info.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return false; }
 		}
 
 		public override string Name {
 			get { return local_info.Name; }
 		}
 
 		#endregion
 
 		public bool VerifyAssigned (ResolveContext ec)
 		{
 			VariableInfo variable_info = local_info.VariableInfo;
 			return variable_info == null || variable_info.IsAssigned (ec, loc);
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			local_info.AddressTaken = true;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			Arguments arg = new Arguments (1);
 			arg.Add (new Argument (this));
 			return CreateExpressionFactoryCall (ec, "Constant", arg);
 		}
 
 		void DoResolveBase (ResolveContext ec)
 		{
 			VerifyAssigned (ec);
 
 			//
 			// If we are referencing a variable from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (local_info)) {
 				if (local_info.AddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (ec.IsVariableCapturingRequired) {
 					AnonymousMethodStorey storey = local_info.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureLocalVariable (ec, local_info);
 				}
 			}
 
 			eclass = ExprClass.Variable;
 			type = local_info.Type;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			local_info.SetIsUsed ();
 
 			DoResolveBase (ec);
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			// is out param
 			if (right_side == EmptyExpression.OutAccess.Instance)
 				local_info.SetIsUsed ();
 
 			if (local_info.IsReadonly && !ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.UsingInitializerScope)) {
 				int code;
 				string msg;
 				if (right_side == EmptyExpression.OutAccess.Instance) {
 					code = 1657; msg = "Cannot pass `{0}' as a ref or out argument because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberAccess) {
 					code = 1654; msg = "Cannot assign to members of `{0}' because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberOutAccess) {
 					code = 1655; msg = "Cannot pass members of `{0}' as ref or out arguments because it is a `{1}'";
 				} else if (right_side == EmptyExpression.UnaryAddress) {
 					code = 459; msg = "Cannot take the address of {1} `{0}'";
 				} else {
 					code = 1656; msg = "Cannot assign to `{0}' because it is a `{1}'";
 				}
 				ec.Report.Error (code, loc, msg, Name, local_info.GetReadOnlyContext ());
 			} else if (VariableInfo != null) {
 				VariableInfo.SetAssigned (ec);
 			}
 
 			DoResolveBase (ec);
 
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		public override int GetHashCode ()
 		{
 			return local_info.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			LocalVariableReference lvr = obj as LocalVariableReference;
 			if (lvr == null)
 				return false;
 
 			return local_info == lvr.local_info;
 		}
 
 		protected override ILocalVariable Variable {
 			get { return local_info; }
 		}
 
 		public override string ToString ()
 		{
 			return String.Format ("{0} ({1}
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing
 		}
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="393" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="972" endline="985">
<![CDATA[
 	}
 
 	/// <summary>
 	///   `goto case' statement
 	/// </summary>
 	public class GotoCase 
 		Expression expr;
 		SwitchLabel sl;
 		
 		public GotoCase (Expression e, Location l)
 		{
 			expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="394" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3921" endline="3938">
<![CDATA[
 	}
 
 	// Base class for statements that are implemented in terms of try...finally
 	public abstract class ExceptionStatement 
 	{
 		bool code_follows;
 		Iterator iter;
 		List<ResumableStatement> resume_points;
 		int first_resume_pc;
 		protected Statement stmt;
 		Label dispose_try_block;
 		bool prepared_for_dispose, emitted_dispose;
 
 		protected ExceptionStatement (Statement stmt, Location loc)
 		{
 			this.stmt = stmt;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="395" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4628" endline="4642">
<![CDATA[
 	}
 
 	public class Catch 
 	{
 		Block block;
 		LocalVariable li;
 		FullNamedExpression type_expr;
 		CompilerAssign assign;
 		TypeSpec type;
 		
 		public Catch (Block block, Location loc)
 		{
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="396" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7402" endline="7416">
<![CDATA[
 		}
 	}
 
 	/// <summary>
 	///   Implements the sizeof expression
 	/// </summary>
 	public class SizeOf 
 		readonly Expression QueriedType;
 		TypeSpec type_queried;
 		
 		public SizeOf (Expression queried_type, Location l)
 		{
 			this.QueriedType = queried_type;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="397" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7471" endline="7928">
<![CDATA[
 
 		public QualifiedAliasMember (string alias, string identifier, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, TypeArguments targs, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, int arity, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			if (alias == GlobalAlias) {
 				expr = ec.Module.GlobalRootNamespace;
 				return base.ResolveAsTypeStep (ec, silent);
 			}
 
 			int errors = ec.Compiler.Report.Errors;
 			expr = ec.LookupNamespaceAlias (alias);
 			if (expr == null) {
 				if (errors == ec.Compiler.Report.Errors)
 					ec.Compiler.Report.Error (432, loc, "Alias `{0}' not found", alias);
 				return null;
 			}
 
 			FullNamedExpression fne = base.ResolveAsTypeStep (ec, silent);
 			if (fne == null)
 				return null;
 
 			if (expr.eclass == ExprClass.Type) {
 				if (!silent) {
 					ec.Compiler.Report.Error (431, loc,
 						"Alias `{0}' cannot be used with '
 				}
 				return null;
 			}
 
 			return fne;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return ResolveAsTypeStep (ec, false);
 		}
 
 		protected override void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			rc.Compiler.Report.Error (687, loc,
 				"A namespace alias qualifier `{0}' did not resolve to a namespace or a type",
 				GetSignatureForError ());
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string name = Name;
 			if (targs != null) {
 				name = Name + "<" + targs.GetSignatureForError () + ">";
 			}
 
 			return alias + "
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			return DoResolve (rc);
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing 
 		}
 	}
 
 	/// <summary>
 	///   Implements the member access expression
 	/// </summary>
 	public class MemberAccess 
 	{
 		protected Expression expr;
 
 		public MemberAccess (Expression expr, string id)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, TypeArguments args, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, int arity, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public Expression LeftExpression {
 			get {
 				return expr;
 			}
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return DoResolveName (ec, null);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			return DoResolveName (ec, right_side);
 		}
 
 		Expression DoResolveName (ResolveContext rc, Expression right_side)
 		{
 			Expression e = LookupNameExpression (rc, right_side == null ? MemberLookupRestrictions.ReadAccess 
 			if (e == null)
 				return null;
 
 			if (right_side != null) {
 				if (e is TypeExpr) {
 					e.Error_UnexpectedKind (rc, ResolveFlags.VariableOrValue, loc);
 					return null;
 				}
 
 				e = e.ResolveLValue (rc, right_side);
 			} else {
 				e = e.Resolve (rc, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 			}
 
 			return e;
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			var sn = expr as SimpleName;
 			const ResolveFlags flags = ResolveFlags.VariableOrValue | ResolveFlags.Type;
 
 			//
 			// Resolve the expression with flow analysis turned off, we'll do the definite
 			// assignment checks later.  This is because we don't know yet what the expression
 			// will resolve to - it may resolve to a FieldExpr and in this case we must do the
 			// definite assignment check on the actual field and not on the whole struct.
 			//
 			using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 				if (sn != null) {
 					expr = sn.LookupNameExpression (rc, MemberLookupRestrictions.ReadAccess | MemberLookupRestrictions.ExactArity);
 
 					// Call resolve on expression which does have type set as we need expression type
 					// TODO
 					if (expr is VariableReference || expr is ConstantExpr || expr is Linq.TransparentMemberAccess) {
 						using (rc.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 							expr = expr.Resolve (rc);
 						}
 					} else if (expr is TypeParameterExpr) {
 						expr.Error_UnexpectedKind (rc, flags, sn.Location);
 						expr = null;
 					}
 				} else {
 					expr = expr.Resolve (rc, flags);
 				}
 			}
 
 			if (expr == null)
 				return null;
 
 			Namespace ns = expr as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 					return null;
 				}
 
 				if (HasTypeArguments)
 					return new GenericTypeExpr (retval.Type, targs, loc);
 
 				return retval;
 			}
 
 			MemberExpr me;
 			TypeSpec expr_type = expr.Type;
 			if (expr_type == InternalType.Dynamic) {
 				me = expr as MemberExpr;
 				if (me != null)
 					me.ResolveInstanceExpression (rc, null);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new DynamicMemberBinder (Name, args, loc);
 			}
 
 			const MemberKind dot_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.Delegate | MemberKind.Enum |
 				MemberKind.Interface | MemberKind.TypeParameter | MemberKind.ArrayType;
 
 			if ((expr_type.Kind & dot_kinds) == 0 || expr_type == TypeManager.void_type) {
 				if (expr_type == InternalType.Null && rc.Compiler.IsRuntimeBinder)
 					rc.Report.Error (Report.RuntimeErrorId, loc, "Cannot perform member binding on `null' value");
 				else
 					Unary.Error_OperatorCannotBeApplied (rc, loc, ".", expr_type);
 				return null;
 			}
 
 			var current_type = rc.CurrentType;
 			var lookup_arity = Arity;
 			bool errorMode = false;
 			Expression member_lookup;
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 
 			TypeExpr texpr = member_lookup as TypeExpr;
 			if (texpr != null) {
 				if (!(expr is TypeExpr)) {
 					me = expr as MemberExpr;
 					if (me == null || me.ProbeIdenticalTypeName (rc, expr, sn) == expr) {
 						rc.Report.Error (572, loc, "`{0}'
 							Name, member_lookup.GetSignatureForError ());
 						return null;
 					}
 				}
 
 				if (!texpr.Type.IsAccessible (rc.CurrentType)) {
 					rc.Report.SymbolRelatedToPreviousError (member_lookup.Type);
 					ErrorIsInaccesible (rc, member_lookup.Type.GetSignatureForError (), loc);
 					return null;
 				}
 
 				if (HasTypeArguments) {
 					return new GenericTypeExpr (member_lookup.Type, targs, loc);
 				}
 
 				return member_lookup;
 			}
 
 			me = member_lookup as MemberExpr;
 
 			if (sn != null && me.IsStatic)
 				expr = me.ProbeIdenticalTypeName (rc, expr, sn);
 
 			me = me.ResolveMemberAccess (rc, expr, sn);
 
 			if (Arity > 0) {
 				if (!targs.Resolve (rc))
 					return null;
 
 				me.SetTypeArguments (rc, targs);
 			}
 
 			if (sn != null && (!TypeManager.IsValueType (expr_type) || me is PropertyExpr)) {
 				if (me.IsInstance) {
 					LocalVariableReference var = expr as LocalVariableReference;
 					if (var != null && !var.VerifyAssigned (rc))
 						return null;
 				}
 			}
 
 			return me;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			return ResolveNamespaceOrType (ec, silent);
 		}
 
 		public FullNamedExpression ResolveNamespaceOrType (IMemberContext rc, bool silent)
 		{
 			FullNamedExpression expr_resolved = expr.ResolveAsTypeStep (rc, silent);
 
 			if (expr_resolved == null)
 				return null;
 
 			Namespace ns = expr_resolved as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					if (!silent)
 						ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 				} else if (HasTypeArguments) {
 					retval = new GenericTypeExpr (retval.Type, targs, loc).ResolveAsTypeStep (rc, silent);
 				}
 
 				return retval;
 			}
 
 			TypeExpr tnew_expr = expr_resolved.ResolveAsTypeTerminal (rc, false);
 			if (tnew_expr == null)
 				return null;
 
 			TypeSpec expr_type = tnew_expr.Type;
 			if (TypeManager.IsGenericParameter (expr_type)) {
 				rc.Compiler.Report.Error (704, loc, "A nested type cannot be specified through a type parameter `{0}'",
 					tnew_expr.GetSignatureForError ());
 				return null;
 			}
 
 			TypeSpec nested = null;
 			while (expr_type != null) {
 				nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 				if (nested == null) {
 					if (silent)
 						return null;
 
 					if (expr_type == tnew_expr.Type) {
 						Error_IdentifierNotFound (rc, expr_type, Name);
 						return null;
 					}
 
 					expr_type = tnew_expr.Type;
 					nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 					ErrorIsInaccesible (rc, nested.GetSignatureForError (), loc);
 					break;
 				}
 
 				if (nested.IsAccessible (rc.CurrentType))
 					break;
 
 				// Keep looking after inaccessible candidate
 				expr_type = nested.DeclaringType.BaseType;
 			}
 			
 			TypeExpr texpr;
 			if (Arity > 0) {
 				if (HasTypeArguments) {
 					texpr = new GenericTypeExpr (nested, targs, loc);
 				} else {
 					texpr = new GenericOpenTypeExpr (nested, loc);
 				}
 			} else {
 				texpr = new TypeExpression (nested, loc);
 			}
 
 			return texpr.ResolveAsTypeStep (rc, false);
 		}
 
 		protected virtual void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			var nested = MemberCache.FindNestedType (expr_type, Name, -System.Math.Max (1, Arity));
 
 			if (nested != null) {
 				Error_TypeArgumentsCannotBeUsed (rc.Compiler.Report, expr.Location, nested, Arity);
 				return;
 			}
 
 			var any_other_member = MemberLookup (null, rc.CurrentType, expr_type, Name, 0, MemberLookupRestrictions.None, loc);
 			if (any_other_member != null) {
 				any_other_member.Error_UnexpectedKind (rc.Compiler.Report, null, "type", loc);
 				return;
 			}
 
 			rc.Compiler.Report.Error (426, loc, "The nested type `{0}' does not exist in the type `{1}'",
 				Name, expr_type.GetSignatureForError ());
 		}
 
 		protected override void Error_TypeDoesNotContainDefinition (ResolveContext ec, TypeSpec type, string name)
 		{
 			if (RootContext.Version > LanguageVersion.ISO_2 && !ec.Compiler.IsRuntimeBinder && MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (1061, loc,
 					"Type `{0}' does not contain a definition for `{1}' and no extension method `{1}' of type `{0}' could be found (are you missing a using directive or an assembly reference?)",
 					type.GetSignatureForError (), name);
 				return;
 			}
 
 			base.Error_TypeDoesNotContainDefinition (ec, type, name);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return expr.GetSignatureForError () + "." + base.GetSignatureForError ();
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
 	}
 
 	/// <summary>
 	///   Implements checked expressions
 	/// </summary>
 	public class CheckedExpr 
 
 		public Expression Expr;
 
 		public CheckedExpr (Expression e, Location l)
 		{
 			Expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="398" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7977" endline="7990">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the unchecked expression
 	/// </summary>
 	public class UnCheckedExpr 
 
 		public Expression Expr;
 
 		public UnCheckedExpr (Expression e, Location l)
 		{
 			Expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="399" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9317" endline="9334">
<![CDATA[
 	}
 	
 	//
 	// A block of object or collection initializers
 	//
 	public class CollectionOrObjectInitializers 
 	{
 		IList<Expression> initializers;
 		bool is_collection_initialization;
 		
 		public static readonly CollectionOrObjectInitializers Empty = 
 			new CollectionOrObjectInitializers (Array.AsReadOnly (new Expression [0]), Location.Null);
 
 		public CollectionOrObjectInitializers (IList<Expression> initializers, Location loc)
 		{
 			this.initializers = initializers;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="400" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1042" endline="1051">
<![CDATA[
 	}
 	
 	public class Throw 
 		Expression expr;
 		
 		public Throw (Expression expr, Location l)
 		{
 			this.expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="401" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="106" endline="790">
<![CDATA[
 	}
 	
 	//
 	//   Unary implements unary expressions.
 	//
 	public class Unary 
 	{
 		public enum Operator 
 			UnaryPlus, UnaryNegation, LogicalNot, OnesComplement,
 			AddressOf,  TOP
 		}
 
 		static TypeSpec[][] predefined_operators;
 
 		public readonly Operator Oper;
 		public Expression Expr;
 		Expression enum_conversion;
 
 		public Unary (Operator op, Expression expr, Location loc)
 		{
 			Oper = op;
 			Expr = expr;
 			this.loc = loc;
 		}
 
 		// <summary>
 		//   This routine will attempt to simplify the unary expression when the
 		//   argument is a constant.
 		// </summary>
 		Constant TryReduceConstant (ResolveContext ec, Constant e)
 		{
 			if (e is EmptyConstantCast)
 				return TryReduceConstant (ec, ((EmptyConstantCast) e).child);
 			
 			if (e is SideEffectConstant) {
 				Constant r = TryReduceConstant (ec, ((SideEffectConstant) e).value);
 				return r == null ? null 
 			}
 
 			TypeSpec expr_type = e.Type;
 			
 			switch (Oper){
 			case Operator.UnaryPlus
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type || expr_type == TypeManager.uint32_type ||
 				    expr_type == TypeManager.int64_type || expr_type == TypeManager.uint64_type ||
 				    expr_type == TypeManager.float_type || expr_type == TypeManager.double_type ||
 				    expr_type == TypeManager.decimal_type) {
 					return e;
 				}
 				
 				return null;
 				
 			case Operator.UnaryNegation
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (-((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (-((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (-((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (-((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (-((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type) {
 					int value = ((IntConstant)e).Value;
 					if (value == int.MinValue) {
 						if (ec.ConstantCheckState) {
 							ConstantFold.Error_CompileTimeOverflow (ec, loc);
 							return null;
 						}
 						return e;
 					}
 					return new IntConstant (-value, e.Location);
 				}
 				if (expr_type == TypeManager.int64_type) {
 					long value = ((LongConstant)e).Value;
 					if (value == long.MinValue) {
 						if (ec.ConstantCheckState) {
 							ConstantFold.Error_CompileTimeOverflow (ec, loc);
 							return null;
 						}
 						return e;
 					}
 					return new LongConstant (-value, e.Location);
 				}
 				
 				if (expr_type == TypeManager.uint32_type) {
 					UIntLiteral uil = e as UIntLiteral;
 					if (uil != null) {
 						if (uil.Value == int.MaxValue + (uint) 1)
 							return new IntLiteral (int.MinValue, e.Location);
 						return new LongLiteral (-uil.Value, e.Location);
 					}
 					return new LongConstant (-((UIntConstant)e).Value, e.Location);
 				}
 				
 				if (expr_type == TypeManager.uint64_type) {
 					ULongLiteral ull = e as ULongLiteral;
 					if (ull != null && ull.Value == 9223372036854775808)
 						return new LongLiteral (long.MinValue, e.Location);
 					return null;
 				}
 				
 				if (expr_type == TypeManager.float_type) {
 					FloatLiteral fl = e as FloatLiteral;
 					// For better error reporting
 					if (fl != null)
 						return new FloatLiteral (-fl.Value, e.Location);
 
 					return new FloatConstant (-((FloatConstant)e).Value, e.Location);
 				}
 				if (expr_type == TypeManager.double_type) {
 					DoubleLiteral dl = e as DoubleLiteral;
 					// For better error reporting
 					if (dl != null)
 						return new DoubleLiteral (-dl.Value, e.Location);
 
 					return new DoubleConstant (-((DoubleConstant)e).Value, e.Location);
 				}
 				if (expr_type == TypeManager.decimal_type)
 					return new DecimalConstant (-((DecimalConstant)e).Value, e.Location);
 				
 				return null;
 				
 			case Operator.LogicalNot
 				if (expr_type != TypeManager.bool_type)
 					return null;
 				
 				bool b = (bool)e.GetValue ();
 				return new BoolConstant (!b, e.Location);
 				
 			case Operator.OnesComplement
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (~((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (~((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (~((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (~((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (~((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type)
 					return new IntConstant (~((IntConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.uint32_type)
 					return new UIntConstant (~((UIntConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.int64_type)
 					return new LongConstant (~((LongConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.uint64_type){
 					return new ULongConstant (~((ULongConstant)e).Value, e.Location);
 				}
 				if (e is EnumConstant) {
 					e = TryReduceConstant (ec, ((EnumConstant)e).Child);
 					if (e != null)
 						e = new EnumConstant (e, expr_type);
 					return e;
 				}
 				return null;
 			}
 			throw new Exception ("Can not constant fold
 		}
 		
 		protected virtual Expression ResolveOperator (ResolveContext ec, Expression expr)
 		{
 			eclass = ExprClass.Value;
 
 			if (predefined_operators == null)
 				CreatePredefinedOperatorsTable ();
 
 			TypeSpec expr_type = expr.Type;
 			Expression best_expr;
 
 			//
 			// Primitive types first
 			//
 			if (TypeManager.IsPrimitiveType (expr_type)) {
 				best_expr = ResolvePrimitivePredefinedType (expr);
 				if (best_expr == null)
 					return null;
 
 				type = best_expr.Type;
 				Expr = best_expr;
 				return this;
 			}
 
 			//
 			// E operator ~(E x);
 			//
 			if (Oper == Operator.OnesComplement && TypeManager.IsEnumType (expr_type))
 				return ResolveEnumOperator (ec, expr);
 
 			return ResolveUserType (ec, expr);
 		}
 
 		protected virtual Expression ResolveEnumOperator (ResolveContext ec, Expression expr)
 		{
 			TypeSpec underlying_type = EnumSpec.GetUnderlyingType (expr.Type);
 			Expression best_expr = ResolvePrimitivePredefinedType (EmptyCast.Create (expr, underlying_type));
 			if (best_expr == null)
 				return null;
 
 			Expr = best_expr;
 			enum_conversion = Convert.ExplicitNumericConversion (new EmptyExpression (best_expr.Type), underlying_type);
 			type = expr.Type;
 			return EmptyCast.Create (this, type);
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return CreateExpressionTree (ec, null);
 		}
 
 		Expression CreateExpressionTree (ResolveContext ec, Expression user_op)
 		{
 			string method_name;
 			switch (Oper) {
 			case Operator.AddressOf
 				Error_PointerInsideExpressionTree (ec);
 				return null;
 			case Operator.UnaryNegation
 				if (ec.HasSet (ResolveContext.Options.CheckedScope) && user_op == null && !IsFloat (type))
 					method_name = "NegateChecked";
 				else
 					method_name = "Negate";
 				break;
 			case Operator.OnesComplement
 			case Operator.LogicalNot
 				method_name = "Not";
 				break;
 			case Operator.UnaryPlus
 				method_name = "UnaryPlus";
 				break;
 			default
 				throw new InternalErrorException ("Unknown unary operator " + Oper.ToString ());
 			}
 
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (Expr.CreateExpressionTree (ec)));
 			if (user_op != null)
 				args.Add (new Argument (user_op));
 
 			return CreateExpressionFactoryCall (ec, method_name, args);
 		}
 
 		static void CreatePredefinedOperatorsTable ()
 		{
 			predefined_operators = new TypeSpec [(int) Operator.TOP] [];
 
 			//
 			// 7.6.1 Unary plus operator
 			//
 			predefined_operators [(int) Operator.UnaryPlus] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.2 Unary minus operator
 			//
 			predefined_operators [(int) Operator.UnaryNegation] = new TypeSpec [] {
 				TypeManager.int32_type, 
 				TypeManager.int64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.3 Logical negation operator
 			//
 			predefined_operators [(int) Operator.LogicalNot] = new TypeSpec [] {
 				TypeManager.bool_type
 			};
 
 			//
 			// 7.6.4 Bitwise complement operator
 			//
 			predefined_operators [(int) Operator.OnesComplement] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type
 			};
 		}
 
 		//
 		// Unary numeric promotions
 		//
 		static Expression DoNumericPromotion (Operator op, Expression expr)
 		{
 			TypeSpec expr_type = expr.Type;
 			if ((op == Operator.UnaryPlus || op == Operator.UnaryNegation || op == Operator.OnesComplement) &&
 				expr_type == TypeManager.byte_type || expr_type == TypeManager.sbyte_type ||
 				expr_type == TypeManager.short_type || expr_type == TypeManager.ushort_type ||
 				expr_type == TypeManager.char_type)
 				return Convert.ImplicitNumericConversion (expr, TypeManager.int32_type);
 
 			if (op == Operator.UnaryNegation && expr_type == TypeManager.uint32_type)
 				return Convert.ImplicitNumericConversion (expr, TypeManager.int64_type);
 
 			return expr;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (Oper == Operator.AddressOf) {
 				return ResolveAddressOf (ec);
 			}
 
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			if (Expr.Type == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (Expr));
 				return new DynamicUnaryConversion (GetOperatorExpressionTypeName (), args, loc).Resolve (ec);
 			}
 
 			if (TypeManager.IsNullableType (Expr.Type))
 				return new Nullable.LiftedUnaryOperator (Oper, Expr, loc).Resolve (ec);
 
 			//
 			// Attempt to use a constant folding operation.
 			//
 			Constant cexpr = Expr as Constant;
 			if (cexpr != null) {
 				cexpr = TryReduceConstant (ec, cexpr);
 				if (cexpr != null)
 					return cexpr.Resolve (ec);
 			}
 
 			Expression expr = ResolveOperator (ec, Expr);
 			if (expr == null)
 				Error_OperatorCannotBeApplied (ec, loc, OperName (Oper), Expr.Type);
 			
 			//
 			// Reduce unary operator on predefined types
 			//
 			if (expr == this && Oper == Operator.UnaryPlus)
 				return Expr;
 
 			return expr;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right)
 		{
 			return null;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			EmitOperator (ec, type);
 		}
 
 		protected void EmitOperator (EmitContext ec, TypeSpec type)
 		{
 			switch (Oper) {
 			case Operator.UnaryPlus
 				Expr.Emit (ec);
 				break;
 				
 			case Operator.UnaryNegation
 				if (ec.HasSet (EmitContext.Options.CheckedScope) && !IsFloat (type)) {
 					ec.Emit (OpCodes.Ldc_I4_0);
 					if (type == TypeManager.int64_type)
 						ec.Emit (OpCodes.Conv_U8);
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Sub_Ovf);
 				} else {
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 				}
 				
 				break;
 				
 			case Operator.LogicalNot
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				ec.Emit (OpCodes.Ceq);
 				break;
 				
 			case Operator.OnesComplement
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Not);
 				break;
 				
 			case Operator.AddressOf
 				((IMemoryLocation)Expr).AddressOf (ec, AddressOp.LoadStore);
 				break;
 				
 			default
 				throw new Exception ("This should not happen
 						     + Oper.ToString ());
 			}
 
 			//
 			// Same trick as in Binary expression
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
 
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			if (Oper == Operator.LogicalNot)
 				Expr.EmitBranchable (ec, target, !on_true);
 			else
 				base.EmitBranchable (ec, target, on_true);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			Expr.EmitSideEffect (ec);
 		}
 
 		public static void Error_OperatorCannotBeApplied (ResolveContext ec, Location loc, string oper, TypeSpec t)
 		{
 			ec.Report.Error (23, loc, "The `{0}' operator cannot be applied to operand of type `{1}'",
 				oper, TypeManager.CSharpName (t));
 		}
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (Oper) {
 			case Operator.OnesComplement
 				return "OnesComplement";
 			case Operator.LogicalNot
 				return "Not";
 			case Operator.UnaryNegation
 				return "Negate";
 			case Operator.UnaryPlus
 				return "UnaryPlus";
 			default
 				throw new NotImplementedException ("Unknown express type operator " + Oper.ToString ());
 			}
 		}
 
 		static bool IsFloat (TypeSpec t)
 		{
 			return t == TypeManager.float_type || t == TypeManager.double_type;
 		}
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			var expr = Expr.MakeExpression (ctx);
 			bool is_checked = ctx.HasSet (BuilderContext.Options.CheckedScope);
 
 			switch (Oper) {
 			case Operator.UnaryNegation
 				return is_checked ? SLE.Expression.NegateChecked (expr) 
 			case Operator.LogicalNot
 				return SLE.Expression.Not (expr);
 #if NET_4_0
 			case Operator.OnesComplement
 				return SLE.Expression.OnesComplement (expr);
 #endif
 			default
 				throw new NotImplementedException (Oper.ToString ());
 			}
 		}
 
 		public static void Reset ()
 		{
 			predefined_operators = null;
 		}
 
 		Expression ResolveAddressOf (ResolveContext ec)
 		{
 			if (!ec.IsUnsafe)
 				UnsafeError (ec, loc);
 
 			Expr = Expr.DoResolveLValue (ec, EmptyExpression.UnaryAddress);
 			if (Expr == null || Expr.eclass != ExprClass.Variable) {
 				ec.Report.Error (211, loc, "Cannot take the address of the given expression");
 				return null;
 			}
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, Expr.Type, loc)) {
 				return null;
 			}
 
 			IVariableReference vr = Expr as IVariableReference;
 			bool is_fixed;
 			if (vr != null) {
 				VariableInfo vi = vr.VariableInfo;
 				if (vi != null) {
 					if (vi.LocalInfo != null)
 						vi.LocalInfo.SetIsUsed ();
 
 					//
 					// A variable is considered definitely assigned if you take its address.
 					//
 					vi.SetAssigned (ec);
 				}
 
 				is_fixed = vr.IsFixed;
 				vr.SetHasAddressTaken ();
 
 				if (vr.IsHoisted) {
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, vr, loc);
 				}
 			} else {
 				IFixedExpression fe = Expr as IFixedExpression;
 				is_fixed = fe != null && fe.IsFixed;
 			}
 
 			if (!is_fixed && !ec.HasSet (ResolveContext.Options.FixedInitializerScope)) {
 				ec.Report.Error (212, loc, "You can only take the address of unfixed expression inside of a fixed statement initializer");
 			}
 
 			type = PointerContainer.MakeType (Expr.Type);
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		Expression ResolvePrimitivePredefinedType (Expression expr)
 		{
 			expr = DoNumericPromotion (Oper, expr);
 			TypeSpec expr_type = expr.Type;
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				if (t == expr_type)
 					return expr;
 			}
 			return null;
 		}
 
 		//
 		// Perform user-operator overload resolution
 		//
 		protected virtual Expression ResolveUserOperator (ResolveContext ec, Expression expr)
 		{
 			CSharp.Operator.OpType op_type;
 			switch (Oper) {
 			case Operator.LogicalNot
 				op_type = CSharp.Operator.OpType.LogicalNot; break;
 			case Operator.OnesComplement
 				op_type = CSharp.Operator.OpType.OnesComplement; break;
 			case Operator.UnaryNegation
 				op_type = CSharp.Operator.OpType.UnaryNegation; break;
 			case Operator.UnaryPlus
 				op_type = CSharp.Operator.OpType.UnaryPlus; break;
 			default
 				throw new InternalErrorException (Oper.ToString ());
 			}
 
 			var methods = MemberCache.GetUserOperator (expr.Type, op_type, false);
 			if (methods == null)
 				return null;
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (expr));
 
 			var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var oper = res.ResolveOperator (ec, ref args);
 
 			if (oper == null)
 				return null;
 
 			Expr = args [0].Expr;
 			return new UserOperatorCall (oper, args, CreateExpressionTree, expr.Location);
 		}
 
 		//
 		// Unary user type overload resolution
 		//
 		Expression ResolveUserType (ResolveContext ec, Expression expr)
 		{
 			Expression best_expr = ResolveUserOperator (ec, expr);
 			if (best_expr != null)
 				return best_expr;
 
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				Expression oper_expr = Convert.ImplicitUserConversion (ec, expr, t, expr.Location);
 				if (oper_expr == null)
 					continue;
 
 				//
 				// decimal type is predefined but has user-operators
 				//
 				if (oper_expr.Type == TypeManager.decimal_type)
 					oper_expr = ResolveUserType (ec, oper_expr);
 				else
 					oper_expr = ResolvePrimitivePredefinedType (oper_expr);
 
 				if (oper_expr == null)
 					continue;
 
 				if (best_expr == null) {
 					best_expr = oper_expr;
 					continue;
 				}
 
 				int result = OverloadResolver.BetterTypeConversion (ec, best_expr.Type, t);
 				if (result == 0) {
 					ec.Report.Error (35, loc, "Operator `{0}' is ambiguous on an operand of type `{1}'",
 						OperName (Oper), TypeManager.CSharpName (expr.Type));
 					break;
 				}
 
 				if (result == 2)
 					best_expr = oper_expr;
 			}
 			
 			if (best_expr == null)
 				return null;
 			
 			//
 			// HACK
 			//
 			if (best_expr.Type == TypeManager.decimal_type)
 				return best_expr;			
 
 			Expr = best_expr;
 			type = best_expr.Type;
 			return this;			
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Unary target = (Unary) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
 	}
 
 	//
 	// Unary operators are turned into Indirection expressions
 	// after semantic analysis (this is so we can take the address
 	// of an indirection).
 	//
 	public class Indirection 
 		Expression expr;
 		LocalTemporary temporary;
 		bool prepared;
 		
 		public Indirection (Expression expr, Location l)
 		{
 			this.expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="402" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1641" endline="1654">
<![CDATA[
 	}
 	
 	//
 	// C# 2.0 Default value expression
 	//
 	public class DefaultValueExpression 
 	{
 		Expression expr;
 
 		public DefaultValueExpression (Expression expr, Location loc)
 		{
 			this.expr = expr;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="403" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4527" endline="4703">
<![CDATA[
 	}
 
 	public abstract class VariableReference 
 		LocalTemporary temp;
 
 		#region Abstract
 		public abstract HoistedVariable GetHoistedVariable (AnonymousExpression ae);
 
 		public abstract bool IsLockedByStatement { get; set; }
 
 		public abstract bool IsFixed { get; }
 		public abstract bool IsRef { get; }
 		public abstract string Name { get; }
 		public abstract void SetHasAddressTaken ();
 
 		//
 		// Variable IL data, it has to be protected to encapsulate hoisted variables
 		//
 		protected abstract ILocalVariable Variable { get; }
 		
 		//
 		// Variable flow-analysis data
 		//
 		public abstract VariableInfo VariableInfo { get; }
 		#endregion
 
 		public virtual void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.AddressOf (ec, mode);
 				return;
 			}
 
 			Variable.EmitAddressOf (ec);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (IsLockedByStatement) {
 				rc.Report.Warning (728, 2, loc,
 					"Possibly incorrect assignment to `{0}' which is the argument to a using or lock statement",
 					Name);
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			// do nothing
 		}
 
 		//
 		// This method is used by parameters that are references, that are
 		// being passed as references
 		// is already stored in the parameter, not the address of the pointer,
 		// and not the value of the variable).
 		//
 		public void EmitLoad (EmitContext ec)
 		{
 			Variable.Emit (ec);
 		}
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
 
 
 		public HoistedVariable GetHoistedVariable (ResolveContext rc)
 		{
 			return GetHoistedVariable (rc.CurrentAnonymousMethod);
 		}
 
 		public HoistedVariable GetHoistedVariable (EmitContext ec)
 		{
 			return GetHoistedVariable (ec.CurrentAnonymousMethod);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Name;
 		}
 
 		public bool IsHoisted {
 			get { return GetHoistedVariable ((AnonymousExpression) null) != null; }
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="404" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="60" endline="69">
<![CDATA[
 	}
 	
 	public class CompletionSimpleName 
 		public string Prefix;
 		
 		public CompletionSimpleName (string prefix, Location l)
 		{
 			this.loc = l;
 			this.Prefix = prefix;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="405" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="150" endline="174">
<![CDATA[
 				AppendResults (results, partial_name, r);
 			}
 
 			throw new CompletionResult (partial_name == null ? "" 
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CompletionMemberAccess target = (CompletionMemberAccess) t;
 
 			if (targs != null)
 				target.targs = targs.Clone ();
 
 			target.expr = expr.Clone (clonectx);
 		}
 	}
 
 	public class CompletionElementInitializer 
 		string partial_name;
 		
 		public CompletionElementInitializer (string partial_name, Location l)
 		{
 			this.partial_name = partial_name;
 			this.loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="406" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7220" endline="7292">
<![CDATA[
 	}
 
 	class TypeOfMethod 
 	{
 		public TypeOfMethod (MethodSpec method, Location loc)
 			
 		{
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (member.IsConstructor) {
 				type = ec.Module.PredefinedTypes.ConstructorInfo.Resolve (loc);
 			} else {
 				type = ec.Module.PredefinedTypes.MethodInfo.Resolve (loc);
 			}
 
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
 
 		protected override string GetMethodName {
 			get { return "GetMethodFromHandle"; }
 		}
 
 		protected override PredefinedType GetDeclaringType (PredefinedTypes types)
 		{
 			return types.MethodBase;
 		}
 
 		protected override PredefinedType GetRuntimeHandle (PredefinedTypes types)
 		{
 			return types.RuntimeMethodHandle;
 		}
 
 		protected override MethodSpec TypeFromHandle {
 			get {
 				return TypeManager.methodbase_get_type_from_handle;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle = value;
 			}
 		}
 
 		protected override MethodSpec TypeFromHandleGeneric {
 			get {
 				return TypeManager.methodbase_get_type_from_handle_generic;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle_generic = value;
 			}
 		}
 	}
 
 	abstract class TypeOfMember<T> 
 	{
 		protected readonly T member;
 
 		protected TypeOfMember (T member, Location loc)
 		{
 			this.member = member;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="407" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5892" endline="5909">
<![CDATA[
 	}
 
 	//
 	// Array initializer expression, the expression is allowed in
 	// variable or field initialization only which makes it tricky as
 	// the type has to be infered based on the context either from field
 	// type or variable type (think of multiple declarators)
 	//
 	public class ArrayInitializer 
 	{
 		List<Expression> elements;
 		BlockVariableDeclaration variable;
 
 		public ArrayInitializer (List<Expression> init, Location loc)
 		{
 			elements = init;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="408" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7082" endline="7095">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the typeof operator
 	/// </summary>
 	public class TypeOf 
 		FullNamedExpression QueriedType;
 		TypeSpec typearg;
 
 		public TypeOf (FullNamedExpression queried_type, Location l)
 		{
 			QueriedType = queried_type;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="409" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8157" endline="8176">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements array access 
 	/// </summary>
 	public class ArrayAccess 
 		//
 		// Points to our "data" repository
 		//
 		ElementAccess ea;
 
 		LocalTemporary temp, expr_copy;
 		Expression[] prepared_arguments;
 		bool prepared;
 		
 		public ArrayAccess (ElementAccess ea_data, Location l)
 		{
 			ea = ea_data;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="410" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2979" endline="4697">
<![CDATA[
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
 
 		public MethodGroupExpr (MethodSpec m, TypeSpec type, Location loc)
 			
 		{
 		}
 
 		#region Properties
 
 		public MethodSpec BestCandidate {
 			get {
 				return best_candidate;
 			}
 		}
 
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return;
 			}
 		}
 
 		protected override TypeSpec DeclaringType {
 			get {
 				return queried_type;
 			}
 		}
 
 		public override bool IsInstance {
 			get {
 				if (best_candidate != null)
 					return !best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override bool IsStatic {
 			get {
 				if (best_candidate != null)
 					return best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override string Name {
 			get {
 				if (best_candidate != null)
 					return best_candidate.Name;
 
 				// TODO
 				return Methods.First ().Name;
 			}
 		}
 
 		#endregion
 
 		//
 		// When best candidate is already know this factory can be used
 		// to avoid expensive overload resolution to be called
 		//
 		// NOTE
 		//
 		public static MethodGroupExpr CreatePredefined (MethodSpec best, TypeSpec queriedType, Location loc)
 		{
 			return new MethodGroupExpr (best, queriedType, loc) {
 				best_candidate = best,
 				best_candidate_return = best.ReturnType
 			};
 		}
 
 		public override string GetSignatureForError ()
 		{
 			if (best_candidate != null)
 				return best_candidate.GetSignatureForError ();
 
 			return Methods.First ().GetSignatureForError ();
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (best_candidate == null) {
 				ec.Report.Error (1953, loc, "An expression tree cannot contain an expression with method group");
 				return null;
 			}
 
 			if (best_candidate.IsConditionallyExcluded (loc))
 				ec.Report.Error (765, loc,
 					"Partial methods with only a defining declaration or removed conditional methods cannot be used in an expression tree");
 			
 			return new TypeOfMethod (best_candidate, loc);
 		}
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			this.eclass = ExprClass.MethodGroup;
 
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (ec);
 				if (InstanceExpression == null)
 					return null;
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotSupportedException ();
 		}
 		
 		public void EmitCall (EmitContext ec, Arguments arguments)
 		{
 			Invocation.EmitCall (ec, InstanceExpression, best_candidate, arguments, loc);			
 		}
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			ec.Report.Error (428, loc, "Cannot convert method group `{0}' to non-delegate type `{1}'. Consider using parentheses to invoke the method",
 				Name, TypeManager.CSharpName (target));
 		}
 
 		public static bool IsExtensionMethodArgument (Expression expr)
 		{
 			//
 			// LAMESPEC
 			//
 			return !(expr is TypeExpr) && !(expr is BaseThis);
 		}
 
 		/// <summary>
 		///   Find the Applicable Function Members (7.4.2.1)
 		///
 		///   me
 		///       it might contain constructors or methods (or anything
 		///       that maps to a method).
 		///
 		///   Arguments
 		///
 		///   loc
 		///        location for "probing" purposes.
 		///
 		///   Returns
 		///            that is the best match of me on Arguments.
 		///
 		/// </summary>
 		public virtual MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments args, OverloadResolver.IErrorHandler cerrors, OverloadResolver.Restrictions restr)
 		{
 			// TODO
 			if (best_candidate != null && best_candidate.Kind == MemberKind.Destructor)
 				return this;
 
 			var r = new OverloadResolver (Methods, type_arguments, restr, loc);
 			if ((restr & OverloadResolver.Restrictions.NoBaseMembers) == 0) {
 				r.BaseMembersProvider = this;
 			}
 
 			if (cerrors != null)
 				r.CustomErrors = cerrors;
 
 			// TODO
 			best_candidate = r.ResolveMember<MethodSpec> (ec, ref args);
 			if (best_candidate == null)
 				return r.BestCandidateIsDynamic ? this 
 
 			// Overload resolver had to create a new method group, all checks bellow have already been executed
 			if (r.BestCandidateNewMethodGroup != null)
 				return r.BestCandidateNewMethodGroup;
 
 			if (best_candidate.Kind == MemberKind.Method && (restr & OverloadResolver.Restrictions.ProbingOnly) == 0) {
 				if (InstanceExpression != null) {
 					if (best_candidate.IsExtensionMethod && args[0].Expr == InstanceExpression) {
 						InstanceExpression = null;
 					} else {
 						if (best_candidate.IsStatic && simple_name != null) {
 							InstanceExpression = ProbeIdenticalTypeName (ec, InstanceExpression, simple_name);
 						}
 
 						InstanceExpression.Resolve (ec);
 					}
 				}
 
 				ResolveInstanceExpression (ec, null);
 				if (InstanceExpression != null)
 					CheckProtectedMemberAccess (ec, best_candidate);
 			}
 
 			var base_override = CandidateToBaseOverride (ec, best_candidate);
 			if (base_override == best_candidate) {
 				best_candidate_return = r.BestCandidateReturnType;
 			} else {
 				best_candidate = base_override;
 				best_candidate_return = best_candidate.ReturnType;
 			}
 
 			return this;
 		}
 
 		public override MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			simple_name = original;
 			return base.ResolveMemberAccess (ec, left, original);
 		}
 
 		public override void SetTypeArguments (ResolveContext ec, TypeArguments ta)
 		{
 			type_arguments = ta;
 		}
 
 		#region IBaseMembersProvider Members
 
 		public virtual IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
 
 		public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			return MemberCache.FindMember (queried_type, new MemberFilter ((MethodSpec) member),
 				BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
 
 		//
 		// Extension methods lookup after ordinary methods candidates failed to apply
 		//
 		public virtual MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			if (InstanceExpression == null)
 				return null;
 
 			InstanceExpression = InstanceExpression.Resolve (rc);
 			if (!IsExtensionMethodArgument (InstanceExpression))
 				return null;
 
 			int arity = type_arguments == null ? 0 
 			NamespaceEntry methods_scope = null;
 			var methods = rc.LookupExtensionMethod (InstanceExpression.Type, Methods[0].Name, arity, ref methods_scope);
 			if (methods == null)
 				return null;
 
 			var emg = new ExtensionMethodGroupExpr (methods, methods_scope, InstanceExpression, loc);
 			emg.SetTypeArguments (rc, type_arguments);
 			return emg;
 		}
 
 		#endregion
 	}
 
 	public struct OverloadResolver
 	{
 		[Flags]
 		public enum Restrictions
 		{
 			None = 0,
 			DelegateInvoke = 1,
 			ProbingOnly	= 1 << 1,
 			CovariantDelegate = 1 << 2,
 			NoBaseMembers = 1 << 3,
 			BaseMembersIncluded = 1 << 4
 		}
 
 		public interface IBaseMembersProvider
 		{
 			IList<MemberSpec> GetBaseMembers (TypeSpec baseType);
 			IParametersMember GetOverrideMemberParameters (MemberSpec member);
 			MethodGroupExpr LookupExtensionMethod (ResolveContext rc);
 		}
 
 		public interface IErrorHandler
 		{
 			bool AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous);
 			bool ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument a, int index);
 			bool NoArgumentMatch (ResolveContext rc, MemberSpec best);
 			bool TypeInferenceFailed (ResolveContext rc, MemberSpec best);
 		}
 
 		sealed class NoBaseMembers 
 		{
 			public static readonly IBaseMembersProvider Instance = new NoBaseMembers ();
 
 			public IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 			{
 				return null;
 			}
 
 			public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 			{
 				return null;
 			}
 
 			public MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 			{
 				return null;
 			}
 		}
 
 		struct AmbiguousCandidate
 		{
 			public readonly MemberSpec Member;
 			public readonly bool Expanded;
 			public readonly AParametersCollection Parameters;
 
 			public AmbiguousCandidate (MemberSpec member, AParametersCollection parameters, bool expanded)
 			{
 				Member = member;
 				Parameters = parameters;
 				Expanded = expanded;
 			}
 		}
 
 		Location loc;
 		IList<MemberSpec> members;
 		TypeArguments type_arguments;
 		IBaseMembersProvider base_provider;
 		IErrorHandler custom_errors;
 		Restrictions restrictions;
 		MethodGroupExpr best_candidate_extension_group;
 		TypeSpec best_candidate_return_type;
 
 		SessionReportPrinter lambda_conv_msgs;
 		ReportPrinter prev_recorder;
 
 		public OverloadResolver (IList<MemberSpec> members, Restrictions restrictions, Location loc)
 			
 		{
 		}
 
 		public OverloadResolver (IList<MemberSpec> members, TypeArguments targs, Restrictions restrictions, Location loc)
 			
 		{
 			if (members == null || members.Count == 0)
 				throw new ArgumentException ("empty members set");
 
 			this.members = members;
 			this.loc = loc;
 			type_arguments = targs;
 			this.restrictions = restrictions;
 			if (IsDelegateInvoke)
 				this.restrictions |= Restrictions.NoBaseMembers;
 
 			base_provider = NoBaseMembers.Instance;
 		}
 
 		#region Properties
 
 		public IBaseMembersProvider BaseMembersProvider {
 			get {
 				return base_provider;
 			}
 			set {
 				base_provider = value;
 			}
 		}
 
 		public bool BestCandidateIsDynamic { get; set; }
 
 		//
 		// Best candidate was found in newly created MethodGroupExpr, used by extension methods
 		//
 		public MethodGroupExpr BestCandidateNewMethodGroup {
 			get {
 				return best_candidate_extension_group;
 			}
 		}
 
 		//
 		// Return type can be different between best candidate and closest override
 		//
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return_type;
 			}
 		}
 
 		public IErrorHandler CustomErrors {
 			get {
 				return custom_errors;
 			}
 			set {
 				custom_errors = value;
 			}
 		}
 
 		TypeSpec DelegateType {
 			get {
 				if ((restrictions & Restrictions.DelegateInvoke) == 0)
 					throw new InternalErrorException ("Not running in delegate mode", loc);
 
 				return members [0].DeclaringType;
 			}
 		}
 
 		bool IsProbingOnly {
 			get {
 				return (restrictions & Restrictions.ProbingOnly) != 0;
 			}
 		}
 
 		bool IsDelegateInvoke {
 			get {
 				return (restrictions & Restrictions.DelegateInvoke) != 0;
 			}
 		}
 
 		#endregion
 
 		//
 		//  7.4.3.3  Better conversion from expression
 		//  Returns 
 		//              2    if a->q is better,
 		//              0 if neither is better
 		//
 		static int BetterExpressionConversion (ResolveContext ec, Argument a, TypeSpec p, TypeSpec q)
 		{
 			TypeSpec argument_type = a.Type;
 
 			//
 			// If argument is an anonymous function
 			//
 			if (argument_type == InternalType.AnonymousMethod && RootContext.Version > LanguageVersion.ISO_2) {
 				//
 				// p and q are delegate types or expression tree types
 				//
 				if (p.GetDefinition () == TypeManager.expression_type || q.GetDefinition () == TypeManager.expression_type) {
 					if (q.MemberDefinition != p.MemberDefinition) {
 						return 0;
 					}
 
 					//
 					// Uwrap delegate from Expression<T>
 					//
 					q = TypeManager.GetTypeArguments (q)[0];
 					p = TypeManager.GetTypeArguments (p)[0];
 				}
 
 				var p_m = Delegate.GetInvokeMethod (ec.Compiler, p);
 				var q_m = Delegate.GetInvokeMethod (ec.Compiler, q);
 
 				//
 				// With identical parameter lists
 				//
 				if (!TypeSpecComparer.Equals (p_m.Parameters.Types,q_m.Parameters.Types))
 					return 0;
 
 				p = p_m.ReturnType;
 				q = q_m.ReturnType;
 
 				//
 				// if p is void returning, and q has a return type Y, then C2 is the better conversion.
 				//
 				if (p == TypeManager.void_type) {
 					return q != TypeManager.void_type ? 2 
 				}
 
 				//
 				// if p has a return type Y, and q is void returning, then C1 is the better conversion.
 				//
 				if (q == TypeManager.void_type) {
 					return p != TypeManager.void_type ? 1
 				}
 			} else {
 				if (argument_type == p)
 					return 1;
 
 				if (argument_type == q)
 					return 2;
 			}
 
 			return BetterTypeConversion (ec, p, q);
 		}
 
 		//
 		// 7.4.3.4  Better conversion from type
 		//
 		public static int BetterTypeConversion (ResolveContext ec, TypeSpec p, TypeSpec q)
 		{
 			if (p == null || q == null)
 				throw new InternalErrorException ("BetterTypeConversion got a null conversion");
 
 			if (p == TypeManager.int32_type) {
 				if (q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.int64_type) {
 				if (q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.sbyte_type) {
 				if (q == TypeManager.byte_type || q == TypeManager.ushort_type ||
 					q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.short_type) {
 				if (q == TypeManager.ushort_type || q == TypeManager.uint32_type ||
 					q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 2;
 			}
 
 			if (q == TypeManager.int32_type) {
 				if (p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.int64_type) {
 				if (p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == TypeManager.sbyte_type) {
 				if (p == TypeManager.byte_type || p == TypeManager.ushort_type ||
 					p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.short_type) {
 				if (p == TypeManager.ushort_type || p == TypeManager.uint32_type ||
 					p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 1;
 			}
 
 			// FIXME
 
 			// TODO
 			Expression p_tmp = new EmptyExpression (p);
 			Expression q_tmp = new EmptyExpression (q);
 
 			bool p_to_q = Convert.ImplicitConversionExists (ec, p_tmp, q);
 			bool q_to_p = Convert.ImplicitConversionExists (ec, q_tmp, p);
 
 			if (p_to_q && !q_to_p)
 				return 1;
 
 			if (q_to_p && !p_to_q)
 				return 2;
 
 			return 0;
 		}
 
 		/// <summary>
 		///   Determines "Better function" between candidate
 		///   and the current best match
 		/// </summary>
 		/// <remarks>
 		///    Returns a boolean indicating 
 		///     false if candidate ain't better
 		///     true  if candidate is better than the current best match
 		/// </remarks>
 		static bool BetterFunction (ResolveContext ec, Arguments args, MemberSpec candidate, AParametersCollection cparam, bool candidate_params,
 			MemberSpec best, AParametersCollection bparam, bool best_params)
 		{
 			AParametersCollection candidate_pd = ((IParametersMember) candidate).Parameters;
 			AParametersCollection best_pd = ((IParametersMember) best).Parameters;
 
 			bool better_at_least_one = false;
 			bool same = true;
 			int args_count = args == null ? 0 
 			int j = 0;
 			Argument a = null;
 			TypeSpec ct, bt;
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 
 			if (better_at_least_one)
 				return true;
 
 			//
 			// This handles the case
 			//
 			//   Add (float f1, float f2, float f3);
 			//   Add (params decimal [] foo);
 			//
 			// The call Add (3, 4, 5) should be ambiguous.  Without this check, the
 			// first candidate would've chosen as better.
 			//
 			if (!same && !a.IsDefaultArgument)
 				return false;
 
 			//
 			// The two methods have equal non-optional parameter types, apply tie-breaking rules
 			//
 
 			//
 			// This handles the following cases
 			//
 			//  Foo (int i) is better than Foo (int i, long l = 0)
 			//  Foo (params int[] args) is better than Foo (int i = 0, params int[] args)
 			//
 			// Prefer non-optional version
 			//
 			// LAMESPEC
 			//
 			if (candidate_params == best_params && candidate_pd.Count != best_pd.Count) {
 				if (candidate_pd.Count >= best_pd.Count)
 					return false;
 
 				if (j < candidate_pd.Count && candidate_pd.FixedParameters[j].HasDefaultValue)
 					return false;
 
 				return true;
 			}
 
 			//
 			// One is a non-generic method and second is a generic method, then non-generic is better
 			//
 			if (best.IsGeneric != candidate.IsGeneric)
 				return best.IsGeneric;
 
 			//
 			// This handles the following cases
 			//
 			//   Trim () is better than Trim (params char[] chars)
 			//   Concat (string s1, string s2, string s3) is better than
 			//     Concat (string s1, params string [] srest)
 			//   Foo (int, params int [] rest) is better than Foo (params int [] rest)
 			//
 			// Prefer non-expanded version
 			//
 			if (candidate_params != best_params)
 				return best_params;
 
 			int candidate_param_count = candidate_pd.Count;
 			int best_param_count = best_pd.Count;
 
 			if (candidate_param_count != best_param_count)
 				// can only happen if (candidate_params && best_params)
 				return candidate_param_count > best_param_count && best_pd.HasParams;
 
 			//
 			// Both methods have the same number of parameters, and the parameters have equal types
 			// Pick the "more specific" signature using rules over original (non-inflated) types
 			//
 			var candidate_def_pd = ((IParametersMember) candidate.MemberDefinition).Parameters;
 			var best_def_pd = ((IParametersMember) best.MemberDefinition).Parameters;
 
 			bool specific_at_least_once = false;
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 
 			if (specific_at_least_once)
 				return true;
 
 			return false;
 		}
 
 		public static void Error_ConstructorMismatch (ResolveContext rc, TypeSpec type, int argCount, Location loc)
 		{
 			rc.Report.Error (1729, loc,
 				"The type `{0}' does not contain a constructor that takes `{1}' arguments",
 				type.GetSignatureForError (), argCount.ToString ());
 		}
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
 
 		//
 		// Tests argument compatibility with the parameter
 		// The possible return values are
 		// 0 - success
 		// 1 - modifier mismatch
 		// 2 - type mismatch
 		// -1 - dynamic binding required
 		//
 		int IsArgumentCompatible (ResolveContext ec, Argument argument, Parameter.Modifier param_mod, TypeSpec parameter)
 		{
 			//
 			// Types have to be identical when ref or out modifer
 			// is used and argument is not of dynamic type
 			//
 			if ((argument.Modifier | param_mod) != 0) {
 				if (argument.Type != parameter) {
 					//
 					// Do full equality check after quick path
 					//
 					if (!TypeSpecComparer.IsEqual (argument.Type, parameter)) {
 						//
 						// Using dynamic for ref/out parameter can still succeed at runtime
 						//
 						if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 							return -1;
 
 						return 2;
 					}
 				}
 
 				if (argument.Modifier != param_mod) {
 					//
 					// Using dynamic for ref/out parameter can still succeed at runtime
 					//
 					if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 						return -1;
 
 					return 1;
 				}
 
 			} else {
 				if (argument.Type == InternalType.Dynamic && (restrictions & Restrictions.CovariantDelegate) == 0)
 					return -1;
 
 				//
 				// Deploy custom error reporting for lambda methods. When probing lambda methods
 				// keep all errors reported in separate set and once we are done and no best
 				// candidate found, this set is used to report more details about what was wrong
 				// with lambda body
 				//
 				if (argument.Expr.Type == InternalType.AnonymousMethod) {
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 				}
 
 				if (!Convert.ImplicitConversionExists (ec, argument.Expr, parameter)) {
 					if (lambda_conv_msgs != null) {
 						lambda_conv_msgs.EndSession ();
 					}
 
 					return 2;
 				}
 			}
 
 			return 0;
 		}
 
 		static TypeSpec MoreSpecific (TypeSpec p, TypeSpec q)
 		{
 			if (TypeManager.IsGenericParameter (p) && !TypeManager.IsGenericParameter (q))
 				return q;
 			if (!TypeManager.IsGenericParameter (p) && TypeManager.IsGenericParameter (q))
 				return p;
 
 			var ac_p = p as ArrayContainer;
 			if (ac_p != null) {
 				var ac_q = ((ArrayContainer) q);
 				TypeSpec specific = MoreSpecific (ac_p.Element, ac_q.Element);
 				if (specific == ac_p.Element)
 					return p;
 				if (specific == ac_q.Element)
 					return q;
 			} else if (TypeManager.IsGenericType (p)) {
 				var pargs = TypeManager.GetTypeArguments (p);
 				var qargs = TypeManager.GetTypeArguments (q);
 
 				bool p_specific_at_least_once = false;
 				bool q_specific_at_least_once = false;
 
 				for (int i = 0; i < pargs.Length; i++) {
 					TypeSpec specific = MoreSpecific (pargs[i], qargs[i]);
 					if (specific == pargs[i])
 						p_specific_at_least_once = true;
 					if (specific == qargs[i])
 						q_specific_at_least_once = true;
 				}
 
 				if (p_specific_at_least_once && !q_specific_at_least_once)
 					return p;
 				if (!p_specific_at_least_once && q_specific_at_least_once)
 					return q;
 			}
 
 			return null;
 		}
 
 		//
 		// Find the best method from candidate list
 		//
 		public T ResolveMember<T> (ResolveContext rc, ref Arguments args) where T 
 		{
 			List<AmbiguousCandidate> ambiguous_candidates = null;
 
 			MemberSpec best_candidate;
 			Arguments best_candidate_args = null;
 			bool best_candidate_params = false;
 			bool best_candidate_dynamic = false;
 			int best_candidate_rate;
 			IParametersMember best_parameter_member = null;
 
 			int args_count = args != null ? args.Count 
 
 			Arguments candidate_args = args;
 			bool error_mode = false;
 			var current_type = rc.CurrentType;
 			MemberSpec invocable_member = null;
 
 			// Be careful, cannot return until error reporter is restored
 			while (true) {
 				best_candidate = null;
 				best_candidate_rate = int.MaxValue;
 
 				var type_members = members;
 				try {
 
 					do {
 						for (int i = 0; i < type_members.Count; ++i) {
 							var member = type_members[i];
 
 							//
 							// Methods in a base class are not candidates if any method in a derived
 							// class is applicable
 							//
 							if ((member.Modifiers & Modifiers.OVERRIDE) != 0)
 								continue;
 
 							if (!error_mode) {
 								if (!member.IsAccessible (current_type))
 									continue;
 
 								if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (current_type))
 									continue;
 							}
 
 							IParametersMember pm = member as IParametersMember;
 							if (pm == null) {
 								//
 								// Will use it later to report ambiguity between best method and invocable member
 								//
 								if (Invocation.IsMemberInvocable (member))
 									invocable_member = member;
 
 								continue;
 							}
 
 							//
 							// Overload resolution is looking for base member but using parameter names
 							// and default values from the closest member. That means to do expensive lookup
 							// for the closest override for virtual or abstract members
 							//
 							if ((member.Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 								var override_params = base_provider.GetOverrideMemberParameters (member);
 								if (override_params != null)
 									pm = override_params;
 							}
 
 							//
 							// Check if the member candidate is applicable
 							//
 							bool params_expanded_form = false;
 							bool dynamic_argument = false;
 							TypeSpec rt = pm.MemberType;
 							int candidate_rate = IsApplicable (rc, ref candidate_args, args_count, ref member, pm, ref params_expanded_form, ref dynamic_argument, ref rt);
 
 							//
 							// How does it score compare to others
 							//
 							if (candidate_rate < best_candidate_rate) {
 								best_candidate_rate = candidate_rate;
 								best_candidate = member;
 								best_candidate_args = candidate_args;
 								best_candidate_params = params_expanded_form;
 								best_candidate_dynamic = dynamic_argument;
 								best_parameter_member = pm;
 								best_candidate_return_type = rt;
 							} else if (candidate_rate == 0) {
 								//
 								// The member look is done per type for most operations but sometimes
 								// it's not possible like for binary operators overload because they
 								// are unioned between 2 sides
 								//
 								if ((restrictions & Restrictions.BaseMembersIncluded) != 0) {
 									if (TypeSpec.IsBaseClass (best_candidate.DeclaringType, member.DeclaringType, true))
 										continue;
 								}
 
 								bool is_better;
 								if (best_candidate.DeclaringType.IsInterface && member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 									//
 									// We pack all interface members into top level type which makes the overload resolution
 									// more complicated for interfaces. We accomodate for this by removing methods with same
 									// signature when building the cache hence this path should not really be hit often
 									//
 									// Example
 									// interface IA { void Foo (int arg); }
 									// interface IB 
 									//
 									// IB
 									//
 									is_better = true;
 									if (ambiguous_candidates != null) {
 										foreach (var amb_cand in ambiguous_candidates) {
 											if (member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 												continue;
 											}
 
 											is_better = false;
 											break;
 										}
 
 										if (is_better)
 											ambiguous_candidates = null;
 									}
 								} else {
 									// Is the new candidate better
 									is_better = BetterFunction (rc, candidate_args, member, pm.Parameters, params_expanded_form, best_candidate, best_parameter_member.Parameters, best_candidate_params);
 								}
 
 								if (is_better) {
 									best_candidate = member;
 									best_candidate_args = candidate_args;
 									best_candidate_params = params_expanded_form;
 									best_candidate_dynamic = dynamic_argument;
 									best_parameter_member = pm;
 									best_candidate_return_type = rt;
 								} else {
 									// It's not better but any other found later could be but we are not sure yet
 									if (ambiguous_candidates == null)
 										ambiguous_candidates = new List<AmbiguousCandidate> ();
 
 									ambiguous_candidates.Add (new AmbiguousCandidate (member, pm.Parameters, params_expanded_form));
 								}
 							}
 
 							// Restore expanded arguments
 							if (candidate_args != args)
 								candidate_args = args;
 						}
 					} while (best_candidate_rate != 0 && (type_members = base_provider.GetBaseMembers (type_members[0].DeclaringType.BaseType)) != null);
 				} finally {
 					if (prev_recorder != null)
 						rc.Report.SetPrinter (prev_recorder);
 				}
 
 				//
 				// We've found exact match
 				//
 				if (best_candidate_rate == 0)
 					break;
 
 				//
 				// Try extension methods lookup when no ordinary method match was found and provider enables it
 				//
 				if (!error_mode) {
 					var emg = base_provider.LookupExtensionMethod (rc);
 					if (emg != null) {
 						emg = emg.OverloadResolve (rc, ref args, null, restrictions);
 						if (emg != null) {
 							best_candidate_extension_group = emg;
 							return (T) (MemberSpec) emg.BestCandidate;
 						}
 					}
 				}
 
 				// Don't run expensive error reporting mode for probing
 				if (IsProbingOnly)
 					return null;
 
 				if (error_mode)
 					break;
 
 				lambda_conv_msgs = null;
 				error_mode = true;
 			}
 
 			//
 			// No best member match found, report an error
 			//
 			if (best_candidate_rate != 0 || error_mode) {
 				ReportOverloadError (rc, best_candidate, best_parameter_member, best_candidate_args, best_candidate_params);
 				return null;
 			}
 
 			if (best_candidate_dynamic) {
 				if (args[0].ArgType == Argument.AType.ExtensionType) {
 					rc.Report.Error (1973, loc,
 						"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' cannot be dynamically dispatched. Consider calling the method without the extension method syntax",
 						args [0].Type.GetSignatureForError (), best_candidate.Name, best_candidate.GetSignatureForError ());
 				}
 
 				BestCandidateIsDynamic = true;
 				return null;
 			}
 
 			if (ambiguous_candidates != null) {
 				//
 				// Now check that there are no ambiguities i.e the selected method
 				// should be better than all the others
 				//
 				for (int ix = 0; ix < ambiguous_candidates.Count; ix++) {
 					var candidate = ambiguous_candidates [ix];
 
 					if (!BetterFunction (rc, best_candidate_args, best_candidate, best_parameter_member.Parameters, best_candidate_params, candidate.Member, candidate.Parameters, candidate.Expanded)) {
 						var ambiguous = candidate.Member;
 						if (custom_errors == null || !custom_errors.AmbiguousCandidates (rc, best_candidate, ambiguous)) {
 							rc.Report.SymbolRelatedToPreviousError (best_candidate);
 							rc.Report.SymbolRelatedToPreviousError (ambiguous);
 							rc.Report.Error (121, loc, "The call is ambiguous between the following methods or properties
 								best_candidate.GetSignatureForError (), ambiguous.GetSignatureForError ());
 						}
 
 						return (T) best_candidate;
 					}
 				}
 			}
 
 			if (invocable_member != null) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.SymbolRelatedToPreviousError (invocable_member);
 				rc.Report.Warning (467, 2, loc, "Ambiguity between method `{0}' and invocable non-method `{1}'. Using method group",
 					best_candidate.GetSignatureForError (), invocable_member.GetSignatureForError ());
 			}
 
 			//
 			// And now check if the arguments are all
 			// compatible, perform conversions if
 			// necessary etc. and return if everything is
 			// all right
 			//
 			if (!VerifyArguments (rc, ref best_candidate_args, best_candidate, best_parameter_member, best_candidate_params))
 				return null;
 
 			if (best_candidate == null)
 				return null;
 
 			//
 			// Check ObsoleteAttribute on the best method
 			//
 			ObsoleteAttribute oa = best_candidate.GetAttributeObsolete ();
 			if (oa != null && !rc.IsObsolete)
 				AttributeTester.Report_ObsoleteMessage (oa, best_candidate.GetSignatureForError (), loc, rc.Report);
 
 			var dep = best_candidate.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (rc, dep, loc);
 			}
 
 			best_candidate.MemberDefinition.SetIsUsed ();
 
 			args = best_candidate_args;
 			return (T) best_candidate;
 		}
 
 		public MethodSpec ResolveOperator (ResolveContext rc, ref Arguments args)
 		{
 			return ResolveMember<MethodSpec> (rc, ref args);
 		}
 
 		void ReportArgumentMismatch (ResolveContext ec, int idx, MemberSpec method,
 													Argument a, AParametersCollection expected_par, TypeSpec paramType)
 		{
 			if (custom_errors != null && custom_errors.ArgumentMismatch (ec, method, a, idx))
 				return;
 
 			if (a is CollectionElementInitializer.ElementInitializerArgument) {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				if ((expected_par.FixedParameters[idx].ModFlags & Parameter.Modifier.ISBYREF) != 0) {
 					ec.Report.Error (1954, loc, "The best overloaded collection initalizer method `{0}' cannot have 'ref', or `out' modifier",
 						TypeManager.CSharpSignature (method));
 					return;
 				}
 				ec.Report.Error (1950, loc, "The best overloaded collection initalizer method `{0}' has some invalid arguments",
 					  TypeManager.CSharpSignature (method));
 			} else if (IsDelegateInvoke) {
 				ec.Report.Error (1594, loc, "Delegate `{0}' has some invalid arguments",
 					DelegateType.GetSignatureForError ());
 			} else {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				ec.Report.Error (1502, loc, "The best overloaded method match for `{0}' has some invalid arguments",
 					method.GetSignatureForError ());
 			}
 
 			Parameter.Modifier mod = idx >= expected_par.Count ? 0 
 
 			string index = (idx + 1).ToString ();
 			if (((mod & (Parameter.Modifier.REF | Parameter.Modifier.OUT)) ^
 				(a.Modifier & (Parameter.Modifier.REF | Parameter.Modifier.OUT))) != 0) {
 				if ((mod & Parameter.Modifier.ISBYREF) == 0)
 					ec.Report.Error (1615, loc, "Argument `#{0}' does not require `{1}' modifier. Consider removing `{1}' modifier",
 						index, Parameter.GetModifierSignature (a.Modifier));
 				else
 					ec.Report.Error (1620, loc, "Argument `#{0}' is missing `{1}' modifier",
 						index, Parameter.GetModifierSignature (mod));
 			} else {
 				string p1 = a.GetSignatureForError ();
 				string p2 = TypeManager.CSharpName (paramType);
 
 				if (p1 == p2) {
 					ec.Report.ExtraInformation (loc, "(equally named types possibly from different assemblies in previous ");
 					ec.Report.SymbolRelatedToPreviousError (a.Expr.Type);
 					ec.Report.SymbolRelatedToPreviousError (paramType);
 				}
 
 				ec.Report.Error (1503, loc,
 					"Argument `#{0}' cannot convert `{1}' expression to type `{2}'", index, p1, p2);
 			}
 		}
 
 		//
 		// We have failed to find exact match so we return error info about the closest match
 		//
 		void ReportOverloadError (ResolveContext rc, MemberSpec best_candidate, IParametersMember pm, Arguments args, bool params_expanded)
 		{
 			int ta_count = type_arguments == null ? 0 
 			int arg_count = args == null ? 0 
 
 			if (ta_count != best_candidate.Arity && (ta_count > 0 || ((IParametersMember) best_candidate).Parameters.IsEmpty)) {
 				var mg = new MethodGroupExpr (new [] { best_candidate }, best_candidate.DeclaringType, loc);
 				mg.Error_TypeArgumentsCannotBeUsed (rc.Report, loc, best_candidate, ta_count);
 				return;
 			}
 
 			if (lambda_conv_msgs != null) {
 				if (lambda_conv_msgs.Merge (rc.Report.Printer))
 					return;
 			}
 
 			//
 			// For candidates which match on parameters count report more details about incorrect arguments
 			//
 			if (pm != null) {
 				int unexpanded_count = ((IParametersMember) best_candidate).Parameters.HasParams ? pm.Parameters.Count - 1 
 				if (pm.Parameters.Count == arg_count || params_expanded || unexpanded_count == arg_count) {
 					// Reject any inaccessible member
 					if (!best_candidate.IsAccessible (rc.CurrentType) || !best_candidate.DeclaringType.IsAccessible (rc.CurrentType)) {
 						rc.Report.SymbolRelatedToPreviousError (best_candidate);
 						Expression.ErrorIsInaccesible (rc, best_candidate.GetSignatureForError (), loc);
 						return;
 					}
 
 					var ms = best_candidate as MethodSpec;
 					if (ms != null && ms.IsGeneric) {
 						bool constr_ok = true;
 						if (ms.TypeArguments != null)
 							constr_ok = new ConstraintChecker (rc.MemberContext).CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc);
 
 						if (ta_count == 0) {
 							if (custom_errors != null && custom_errors.TypeInferenceFailed (rc, best_candidate))
 								return;
 
 							if (constr_ok) {
 								rc.Report.Error (411, loc,
 									"The type arguments for method `{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly",
 									ms.GetGenericMethodDefinition ().GetSignatureForError ());
 							}
 
 							return;
 						}
 					}
 
 					VerifyArguments (rc, ref args, best_candidate, pm, params_expanded);
 					return;
 				}
 			}
 
 			//
 			// We failed to find any method with correct argument count, report best candidate
 			//
 			if (custom_errors != null && custom_errors.NoArgumentMatch (rc, best_candidate))
 				return;
 
 			if (best_candidate.Kind == MemberKind.Constructor) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				Error_ConstructorMismatch (rc, best_candidate.DeclaringType, arg_count, loc);
 			} else if (IsDelegateInvoke) {
 				rc.Report.SymbolRelatedToPreviousError (DelegateType);
 				rc.Report.Error (1593, loc, "Delegate `{0}' does not take `{1}' arguments",
 					DelegateType.GetSignatureForError (), arg_count.ToString ());
 			} else {
 				string name = best_candidate.Kind == MemberKind.Indexer ? "this" 
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.Error (1501, loc, "No overload for method `{0}' takes `{1}' arguments",
 					name, arg_count.ToString ());
 			}
 		}
 
 		bool VerifyArguments (ResolveContext ec, ref Arguments args, MemberSpec member, IParametersMember pm, bool chose_params_expanded)
 		{
 			var pd = pm.Parameters;
 			TypeSpec[] ptypes = ((IParametersMember) member).Parameters.Types;
 
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 			int a_idx = 0, a_pos = 0;
 			Argument a = null;
 			ArrayInitializer params_initializers = null;
 			bool has_unsafe_arg = pm.MemberType.IsPointer;
 			int arg_count = args == null ? 0 
 
 			for (; a_idx < arg_count; a_idx++, ++a_pos) {
 				a = args[a_idx];
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = pd.FixedParameters[a_idx].ModFlags;
 					pt = ptypes[a_idx];
 					has_unsafe_arg |= pt.IsPointer;
 
 					if (p_mod == Parameter.Modifier.PARAMS) {
 						if (chose_params_expanded) {
 							params_initializers = new ArrayInitializer (arg_count - a_idx, a.Expr.Location);
 							pt = TypeManager.GetElementType (pt);
 						}
 					}
 				}
 
 				//
 				// Types have to be identical when ref or out modifer is used 
 				//
 				if (a.Modifier != 0 || (p_mod & ~Parameter.Modifier.PARAMS) != 0) {
 					if ((p_mod & ~Parameter.Modifier.PARAMS) != a.Modifier)
 						break;
 
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt))
 						continue;
 
 					break;
 				}
 
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int name_index = pd.GetParameterIndexByName (na.Name);
 					if (name_index < 0 || name_index >= pd.Count) {
 						if (IsDelegateInvoke) {
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 							ec.Report.Error (1746, na.Location,
 								"The delegate `{0}' does not contain a parameter named `{1}'",
 								DelegateType.GetSignatureForError (), na.Name);
 						} else {
 							ec.Report.SymbolRelatedToPreviousError (member);
 							ec.Report.Error (1739, na.Location,
 								"The best overloaded method match for `{0}' does not contain a parameter named `{1}'",
 								TypeManager.CSharpSignature (member), na.Name);
 						}
 					} else if (args[name_index] != a) {
 						if (IsDelegateInvoke)
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 						else
 							ec.Report.SymbolRelatedToPreviousError (member);
 
 						ec.Report.Error (1744, na.Location,
 							"Named argument `{0}' cannot be used for a parameter which has positional argument specified",
 							na.Name);
 					}
 				}
 				
 				if (a.Expr.Type == InternalType.Dynamic)
 					continue;
 
 				if ((restrictions & Restrictions.CovariantDelegate) != 0 && !Delegate.IsTypeCovariant (a.Expr, pt)) {
 					custom_errors.NoArgumentMatch (ec, member);
 					return false;
 				}
 
 				Expression conv = null;
 				if (a.ArgType == Argument.AType.ExtensionType) {
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt)) {
 						conv = a.Expr;
 					} else {
 						conv = Convert.ImplicitReferenceConversion (a.Expr, pt, false);
 						if (conv == null)
 							conv = Convert.ImplicitBoxingConversion (a.Expr, a.Expr.Type, pt);
 					}
 				} else {
 					conv = Convert.ImplicitConversion (ec, a.Expr, pt, loc);
 				}
 
 				if (conv == null)
 					break;
 
 				//
 				// Convert params arguments to an array initializer
 				//
 				if (params_initializers != null) {
 					// we choose to use 'a.Expr' rather than 'conv' so that
 					// we don't hide the kind of expression we have (esp. CompoundAssign.Helper)
 					params_initializers.Add (a.Expr);
 					args.RemoveAt (a_idx--);
 					--arg_count;
 					continue;
 				}
 
 				// Update the argument with the implicit conversion
 				a.Expr = conv;
 			}
 
 			if (a_idx != arg_count) {
 				ReportArgumentMismatch (ec, a_pos, member, a, pd, pt);
 				return false;
 			}
 
 			//
 			// Fill not provided arguments required by params modifier
 			//
 			if (params_initializers == null && pd.HasParams && arg_count + 1 == pd.Count) {
 				if (args == null)
 					args = new Arguments (1);
 
 				pt = ptypes[pd.Count - 1];
 				pt = TypeManager.GetElementType (pt);
 				has_unsafe_arg |= pt.IsPointer;
 				params_initializers = new ArrayInitializer (0, loc);
 			}
 
 			//
 			// Append an array argument with all params arguments
 			//
 			if (params_initializers != null) {
 				args.Add (new Argument (
 					new ArrayCreation (new TypeExpression (pt, loc), params_initializers, loc).Resolve (ec)));
 				arg_count++;
 			}
 
 			if (has_unsafe_arg && !ec.IsUnsafe) {
 				Expression.UnsafeError (ec, loc);
 			}
 
 			//
 			// We could infer inaccesible type arguments
 			//
 			if (type_arguments == null && member.IsGeneric) {
 				var ms = (MethodSpec) member;
 				foreach (var ta in ms.TypeArguments) {
 					if (!ta.IsAccessible (ec.CurrentType)) {
 						ec.Report.SymbolRelatedToPreviousError (ta);
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						break;
 					}
 				}
 			}
 
 			return true;
 		}
 	}
 
 	public class ConstantExpr 
 	{
 		ConstSpec constant;
 
 		public ConstantExpr (ConstSpec constant, Location loc)
 		{
 			this.constant = constant;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="411" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5408" endline="5579">
<![CDATA[
 	}
 
 	abstract class PropertyOrIndexerExpr<T> 
 	{
 		// getter and setter can be different for base calls
 		MethodSpec getter, setter;
 		protected T best_candidate;
 
 		protected LocalTemporary temp;
 		protected bool prepared;
 
 		protected PropertyOrIndexerExpr (Location l)
 		{
 			loc = l;
 		}
 
 		#region Properties
 
 		public MethodSpec Getter {
 			get {
 				return getter;
 			}
 			set {
 				getter = value;
 			}
 		}
 
 		public MethodSpec Setter {
 			get {
 				return setter;
 			}
 			set {
 				setter = value;
 			}
 		}
 
 		#endregion
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, null);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.Resolve (ec);
 			}
 
 			if (!ResolveGetter (ec))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				// TODO
 				INamedBlockVariable variable = null;
 				if (best_candidate != null && ec.CurrentBlock.ParametersBlock.TopBlock.GetLocalName (best_candidate.Name, ec.CurrentBlock, ref variable) && variable is Linq.RangeVariable) {
 					ec.Report.Error (1939, loc, "A range variable `{0}' may not be passes as `ref' or `out' parameter",
 						best_candidate.Name);
 				} else {
 					right_side.DoResolveLValue (ec, this);
 				}
 				return null;
 			}
 
 			// if the property/indexer returns a value type, and we try to set a field in it
 			if (right_side == EmptyExpression.LValueMemberAccess || right_side == EmptyExpression.LValueMemberOutAccess) {
 				Error_CannotModifyIntermediateExpressionValue (ec);
 			}
 
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, right_side);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.ResolveLValue (ec, right_side);
 			}
 
 			if (!ResolveSetter (ec))
 				return null;
 
 			return this;
 		}
 
 		//
 		// Implements the IAssignMethod interface for assignments
 		//
 		public abstract void Emit (EmitContext ec, bool leave_copy);
 		public abstract void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load);
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public abstract SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source);
 
 		protected abstract Expression OverloadResolve (ResolveContext rc, Expression right_side);
 
 		bool ResolveGetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasGet) {
 				if (InstanceExpression != EmptyExpression.Null) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate);
 					rc.Report.Error (154, loc, "The property or indexer `{0}' cannot be used in this context because it lacks the `get' accessor",
 						best_candidate.GetSignatureForError ());
 					return false;
 				}
 			} else if (!best_candidate.Get.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					rc.Report.Error (271, loc, "The property or indexer `{0}' cannot be used in this context because the get accessor is inaccessible",
 						TypeManager.CSharpSignature (best_candidate));
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					ErrorIsInaccesible (rc, best_candidate.Get.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility) {
 				CheckProtectedMemberAccess (rc, best_candidate.Get);
 			}
 
 			getter = CandidateToBaseOverride (rc, best_candidate.Get);
 			return true;
 		}
 
 		bool ResolveSetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasSet) {
 				rc.Report.Error (200, loc, "Property or indexer `{0}' cannot be assigned to (it is read-only)",
 					GetSignatureForError ());
 				return false;
 			}
 
 			if (!best_candidate.Set.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					rc.Report.Error (272, loc, "The property or indexer `{0}' cannot be used in this context because the set accessor is inaccessible",
 						GetSignatureForError ());
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					ErrorIsInaccesible (rc, best_candidate.Set.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility)
 				CheckProtectedMemberAccess (rc, best_candidate.Set);
 
 			setter = CandidateToBaseOverride (rc, best_candidate.Set);
 			return true;
 		}
 	}
 
 	/// <summary>
 	///   Fully resolved expression that evaluates to an Event
 	/// </summary>
 	public class EventExpr 
 	{
 		readonly EventSpec spec;
 		MethodSpec op;
 
 		public EventExpr (EventSpec spec, Location loc)
 		{
 			this.spec = spec;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="412" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="786" endline="1264">
<![CDATA[
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
 
 		protected Method (DeclSpace parent, FullNamedExpression return_type, Modifiers mod, Modifiers amod,
 					MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 		{
 		}
 
 		#region Properties
 
 		public override TypeParameter[] CurrentTypeParameters {
 			get {
 				if (GenericMethod != null)
 					return GenericMethod.CurrentTypeParameters;
 
 				return null;
 			}
 		}
 
 		public override bool HasUnresolvedConstraints {
 			get {
 				if (CurrentTypeParameters == null)
 					return false;
 
 				// When overriding base method constraints are fetched from
 				// base method but to find it we have to resolve parameters
 				// to find exact base method match
 				if (IsExplicitImpl || (ModFlags & Modifiers.OVERRIDE) != 0)
 					return base_method == null;
 
 				// Even for non-override generic method constraints check has to be
 				// delayed after all constraints are resolved
 				return true;
 			}
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				// TODO
 				return CurrentTypeParameters.Select (l => l.Type).ToArray ();
 			}
 		}
 
 		public int TypeParametersCount {
 			get {
 				return CurrentTypeParameters == null ? 0 
 			}
 		}
 
 #endregion
 
 		public override string GetSignatureForError()
 		{
 			return base.GetSignatureForError () + parameters.GetSignatureForError ();
 		}
 
 		void Error_DuplicateEntryPoint (Method b)
 		{
 			Report.Error (17, b.Location,
 				"Program `{0}' has more than one entry point defined
 				b.Module.Builder.ScopeName, b.GetSignatureForError ());
 		}
 
 		bool IsEntryPoint ()
 		{
 			if (ReturnType != TypeManager.void_type &&
 				ReturnType != TypeManager.int32_type)
 				return false;
 
 			if (parameters.IsEmpty)
 				return true;
 
 			if (parameters.Count > 1)
 				return false;
 
 			var ac = parameters.Types [0] as ArrayContainer;
 			return ac != null && ac.Rank == 1 && ac.Element == TypeManager.string_type &&
 					(parameters[0].ModFlags & ~Parameter.Modifier.PARAMS) == Parameter.Modifier.NONE;
 		}
 
 		public override FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			if (arity == 0) {
 				TypeParameter[] tp = CurrentTypeParameters;
 				if (tp != null) {
 					TypeParameter t = TypeParameter.FindTypeParameter (tp, name);
 					if (t != null)
 						return new TypeParameterExpr (t, loc);
 				}
 			}
 
 			return base.LookupNamespaceOrType (name, arity, loc, ignore_cs0104);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				if (IsExplicitImpl) {
 					Error_ConditionalAttributeIsNotValid ();
 					return;
 				}
 
 				if ((ModFlags & Modifiers.OVERRIDE) != 0) {
 					Report.Error (243, Location, "Conditional not valid on `{0}' because it is an override method", GetSignatureForError ());
 					return;
 				}
 
 				if (ReturnType != TypeManager.void_type) {
 					Report.Error (578, Location, "Conditional not valid on `{0}' because its return type is not void", GetSignatureForError ());
 					return;
 				}
 
 				if (IsInterface) {
 					Report.Error (582, Location, "Conditional not valid on interface members");
 					return;
 				}
 
 				if (MethodData.implementing != null) {
 					Report.SymbolRelatedToPreviousError (MethodData.implementing.DeclaringType);
 					Report.Error (629, Location, "Conditional member `{0}' cannot implement interface member `{1}'",
 						GetSignatureForError (), TypeManager.CSharpSignature (MethodData.implementing));
 					return;
 				}
 
 				for (int i = 0; i < parameters.Count; ++i) {
 					if (parameters.FixedParameters [i].ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (685, Location, "Conditional method `{0}' cannot have an out parameter", GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		protected virtual void DefineTypeParameters ()
 		{
 			var tparams = CurrentTypeParameters;
 
 			TypeParameterSpec[] base_tparams = null;
 			TypeParameterSpec[] base_decl_tparams = TypeParameterSpec.EmptyTypes;
 			TypeSpec[] base_targs = TypeSpec.EmptyTypes;
 			if (((ModFlags & Modifiers.OVERRIDE) != 0 || IsExplicitImpl)) {
 				if (base_method != null) {
 					base_tparams = base_method.GenericDefinition.TypeParameters;
 				
 					if (base_method.DeclaringType.IsGeneric) {
 						base_decl_tparams = base_method.DeclaringType.MemberDefinition.TypeParameters;
 
 						var base_type_parent = CurrentType;
 						while (base_type_parent.BaseType != base_method.DeclaringType) {
 							base_type_parent = base_type_parent.BaseType;
 						}
 
 						base_targs = base_type_parent.BaseType.TypeArguments;
 					}
 
 					if (base_method.IsGeneric) {
 						ObsoleteAttribute oa;
 						foreach (var base_tp in base_tparams) {
 							oa = base_tp.BaseType.GetAttributeObsolete ();
 							if (oa != null) {
 								AttributeTester.Report_ObsoleteMessage (oa, base_tp.BaseType.GetSignatureForError (), Location, Report);
 							}
 
 							if (base_tp.InterfacesDefined != null) {
 								foreach (var iface in base_tp.InterfacesDefined) {
 									oa = iface.GetAttributeObsolete ();
 									if (oa != null) {
 										AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 									}
 								}
 							}
 						}
 
 						if (base_decl_tparams.Length != 0) {
 							base_decl_tparams = base_decl_tparams.Concat (base_tparams).ToArray ();
 							base_targs = base_targs.Concat (tparams.Select<TypeParameter, TypeSpec> (l => l.Type)).ToArray ();
 						} else {
 							base_decl_tparams = base_tparams;
 							base_targs = tparams.Select (l => l.Type).ToArray ();
 						}
 					}
 				} else if (MethodData.implementing != null) {
 					base_tparams = MethodData.implementing.GenericDefinition.TypeParameters;
 					if (MethodData.implementing.DeclaringType.IsGeneric) {
 						base_decl_tparams = MethodData.implementing.DeclaringType.MemberDefinition.TypeParameters;
 						foreach (var iface in Parent.CurrentType.Interfaces) {
 							if (iface == MethodData.implementing.DeclaringType) {
 								base_targs = iface.TypeArguments;
 								break;
 							}
 						}
 					}
 				}
 			}
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 
 				if (!tp.ResolveConstraints (this))
 					continue;
 
 				//
 				// Copy base constraints for override/explicit methods
 				//
 				if (base_tparams != null) {
 					var base_tparam = base_tparams[i];
 					var local_tparam = tp.Type;
 					local_tparam.SpecialConstraint = base_tparam.SpecialConstraint;
 
 					var inflator = new TypeParameterInflator (CurrentType, base_decl_tparams, base_targs);
 					base_tparam.InflateConstraints (inflator, local_tparam);
 
 					//
 					// Check all type argument constraints for possible collision
 					// introduced by inflating inherited constraints in this context
 					//
 					// Conflict example
 					//
 					// class A<T> { virtual void Foo<U> () where U 
 					// class B 
 					//
 					var local_tparam_targs = local_tparam.TypeArguments;
 					if (local_tparam_targs != null) {					
 						for (int ii = 0; ii < local_tparam_targs.Length; ++ii) {
 							var ta = local_tparam_targs [ii];
 							if (!ta.IsClass && !ta.IsStruct)
 								continue;
 
 							if (Constraints.CheckConflictingInheritedConstraint (local_tparam, ta, this, Location)) {
 								local_tparam.ChangeTypeArgumentToBaseType (ii);
 							}
 						}
 					}
 
 					continue;
 				}
 				
 				if (MethodData.implementing != null) {
 					var base_tp = MethodData.implementing.Constraints[i];
 					if (!tp.Type.HasSameConstraintsImplementation (base_tp)) {
 						Report.SymbolRelatedToPreviousError (MethodData.implementing);
 						Report.Error (425, Location,
 							"The constraints for type parameter `{0}' of method `{1}' must match the constraints for type parameter `{2}' of interface method `{3}'. Consider using an explicit interface implementation instead",
 							tp.GetSignatureForError (), GetSignatureForError (), base_tp.GetSignatureForError (), MethodData.implementing.GetSignatureForError ());
 					}
 				}
 			}
 		}
 
 		//
 		// Creates the type
 		//
 		public override bool Define ()
 		{
 			if (type_expr.Type == TypeManager.void_type && parameters.IsEmpty && MemberName.Arity == 0 && MemberName.Name == Destructor.MetadataName) {
 				Report.Warning (465, 1, Location, "Introducing `Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?");
 			}
 
 			if (!base.Define ())
 				return false;
 
 			if (partialMethodImplementation != null && IsPartialDefinition)
 				MethodBuilder = partialMethodImplementation.MethodBuilder;
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ReturnType)) {
 				Error1599 (Location, ReturnType, Report);
 				return false;
 			}
 
 			if (CurrentTypeParameters == null) {
 				if (base_method != null) {
 					if (parameters.Count == 1 && ParameterTypes[0] == TypeManager.object_type && Name == "Equals")
 						Parent.PartialContainer.Mark_HasEquals ();
 					else if (parameters.IsEmpty && Name == "GetHashCode")
 						Parent.PartialContainer.Mark_HasGetHashCode ();
 				}
 					
 			} else {
 				DefineTypeParameters ();
 			}
 
 			if (block != null && block.IsIterator) {
 				//
 				// Current method is turned into automatically generated
 				// wrapper which creates an instance of iterator
 				//
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 				ModFlags |= Modifiers.DEBUGGER_HIDDEN;
 			}
 
 			if ((ModFlags & Modifiers.STATIC) == 0)
 				return true;
 
 			if (parameters.HasExtensionMethodType) {
 				if (Parent.PartialContainer.IsStatic && !Parent.IsGeneric) {
 					if (!Parent.IsTopLevel)
 						Report.Error (1109, Location, "`{0}'
 							GetSignatureForError ());
 
 					PredefinedAttribute pa = Module.PredefinedAttributes.Extension;
 					if (!pa.IsDefined) {
 						Report.Error (1110, Location,
 							"`{0}'
 							GetSignatureForError ());
 					}
 
 					ModFlags |= Modifiers.METHOD_EXTENSION;
 					Parent.PartialContainer.ModFlags |= Modifiers.METHOD_EXTENSION;
 					Spec.DeclaringType.SetExtensionMethodContainer ();
 					Parent.Module.HasExtensionMethod = true;
 				} else {
 					Report.Error (1106, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			}
 
 			//
 			// This is used to track the Entry Point,
 			//
 			if (RootContext.NeedsEntryPoint &&
 				Name == "Main" &&
 				(RootContext.MainClass == null ||
 				RootContext.MainClass == Parent.TypeBuilder.FullName)){
 				if (IsEntryPoint ()) {
 
 					if (Parent.DeclaringAssembly.EntryPoint == null) {
 						if (Parent.IsGeneric || MemberName.IsGeneric) {
 							Report.Warning (402, 4, Location, "`{0}'
 								GetSignatureForError ());
 						} else {
 							SetIsUsed ();
 							Parent.DeclaringAssembly.EntryPoint = this;
 						}
 					} else {
 						Error_DuplicateEntryPoint (Parent.DeclaringAssembly.EntryPoint);
 						Error_DuplicateEntryPoint (this);
 					}
 				} else {
 					Report.Warning (28, 4, Location, "`{0}' has the wrong signature to be an entry point",
 						GetSignatureForError ());
 				}
 			}
 
 			return true;
 		}
 
 		//
 		// Emits the code
 		// 
 		public override void Emit ()
 		{
 			try {
 				if (IsPartialDefinition) {
 					//
 					// Use partial method implementation builder for partial method declaration attributes
 					//
 					if (partialMethodImplementation != null) {
 						MethodBuilder = partialMethodImplementation.MethodBuilder;
 					}
 
 					return;
 				}
 				
 				if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.PartialDefinitionExists) == 0) {
 					Report.Error (759, Location, "A partial method `{0}' implementation is missing a partial method declaration",
 						GetSignatureForError ());
 				}
 
 				if (CurrentTypeParameters != null) {
 					var ge = type_expr as GenericTypeExpr;
 					if (ge != null)
 						ge.CheckConstraints (this);
 
 					foreach (Parameter p in parameters.FixedParameters) {
 						ge = p.TypeExpression as GenericTypeExpr;
 						if (ge != null)
 							ge.CheckConstraints (this);
 					}
 
 					for (int i = 0; i < CurrentTypeParameters.Length; ++i) {
 						var tp = CurrentTypeParameters [i];
 						tp.CheckGenericConstraints ();
 						tp.Emit ();
 					}
 				}
 
 				base.Emit ();
 				
 				if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 					Module.PredefinedAttributes.Extension.EmitAttribute (MethodBuilder);
 			} catch {
 				Console.WriteLine ("Internal compiler error at {0}
 						   Location, MethodBuilder);
 				throw;
 			}
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			// TODO
 			if (overload is Operator)
 				return overload.EnableOverloadChecks (this);
 
 			if (overload is Indexer)
 				return false;
 
 			return base.EnableOverloadChecks (overload);
 		}
 
 		public static void Error1599 (Location loc, TypeSpec t, Report Report)
 		{
 			Report.Error (1599, loc, "Method or delegate cannot return type `{0}'", TypeManager.CSharpName (t));
 		}
 
 		protected override bool ResolveMemberType ()
 		{
 			if (GenericMethod != null) {
 				MethodBuilder = Parent.TypeBuilder.DefineMethod (GetFullName (MemberName), flags);
 				if (!GenericMethod.Define (this))
 					return false;
 			}
 
 			return base.ResolveMemberType ();
 		}
 
 		public void SetPartialDefinition (Method methodDefinition)
 		{
 			caching_flags |= Flags.PartialDefinitionExists;
 			methodDefinition.partialMethodImplementation = this;
 
 			// Ensure we are always using method declaration parameters
 			for (int i = 0; i < methodDefinition.parameters.Count; ++i ) {
 				parameters [i].Name = methodDefinition.parameters [i].Name;
 				parameters [i].DefaultValue = methodDefinition.parameters [i].DefaultValue;
 			}
 
 			if (methodDefinition.attributes == null)
 				return;
 
 			if (attributes == null) {
 				attributes = methodDefinition.attributes;
 			} else {
 				attributes.Attrs.AddRange (methodDefinition.attributes.Attrs);
 			}
 		}
 	}
 
 	public abstract class ConstructorInitializer 
 	{
 		Arguments argument_list;
 		MethodSpec base_ctor;
 
 		public ConstructorInitializer (Arguments argument_list, Location loc)
 		{
 			this.argument_list = argument_list;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="413" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="141" endline="153">
<![CDATA[
 	}
 
 	public class ConstInitializer 
 	{
 		bool in_transit;
 		readonly FieldBase field;
 
 		public ConstInitializer (FieldBase field, Expression value, Location loc)
 			
 		{
 			this.loc = loc;
 			this.field = field;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="414" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1550" endline="1564">
<![CDATA[
 		}
 	}
 	
 	//
 	// This represents a typecast in the source language.
 	//
 	public class Cast 
 		Expression target_type;
 
 		public Cast (Expression cast_type, Expression expr, Location loc)
 			
 		{
 			this.target_type = cast_type;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="415" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="692" endline="708">
<![CDATA[
 	}
 
 	//
 	// Invocation converted to delegate Invoke call
 	//
 	class DelegateInvocation 
 	{
 		readonly Expression InstanceExpr;
 		Arguments arguments;
 		MethodSpec method;
 		
 		public DelegateInvocation (Expression instance_expr, Arguments args, Location loc)
 		{
 			this.InstanceExpr = instance_expr;
 			this.arguments = args;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="416" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="337" endline="349">
<![CDATA[
 	}
 
 	public class While 
 		public Expression expr;
 		public Statement Statement;
 		bool infinite, empty;
 
 		public While (BooleanExpression bool_expr, Statement statement, Location l)
 		{
 			this.expr = bool_expr;
 			Statement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="417" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4853" endline="5519">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
 
 		#region Properties
 
 		public override bool IsLockedByStatement {
 			get {
 				return pi.IsLocked;
 			}
 			set	{
 				pi.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return (pi.Parameter.ModFlags & Parameter.Modifier.ISBYREF) != 0; }
 		}
 
 		bool HasOutModifier {
 			get { return pi.Parameter.ModFlags == Parameter.Modifier.OUT; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return pi.Parameter.HoistedVariant;
 		}
 
 		//
 		// A ref or out parameter is classified as a moveable variable, even 
 		// if the argument given for the parameter is a fixed variable
 		//		
 		public override bool IsFixed {
 			get { return !IsRef; }
 		}
 
 		public override string Name {
 			get { return Parameter.Name; }
 		}
 
 		public Parameter Parameter {
 			get { return pi.Parameter; }
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return pi.VariableInfo; }
 		}
 
 		protected override ILocalVariable Variable {
 			get { return Parameter; }
 		}
 
 		#endregion
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			// HACK
 			if (ec.IsInProbingMode)
 				return true;
 			
 			if (!ec.DoFlowAnalysis || !HasOutModifier || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			ec.Report.Error (269, loc, "Use of unassigned out parameter `{0}'", Name);
 			return false;
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			Parameter.HasAddressTaken = true;
 		}
 
 		void SetAssigned (ResolveContext ec)
 		{
 			if (HasOutModifier && ec.DoFlowAnalysis)
 				ec.CurrentBranching.SetAssigned (VariableInfo);
 		}
 
 		bool DoResolveBase (ResolveContext ec)
 		{
 			type = pi.ParameterType;
 			eclass = ExprClass.Variable;
 
 			//
 			// If we are referencing a parameter from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (pi)) {
 				if (Parameter.HasAddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (IsRef) {
 					ec.Report.Error (1628, loc,
 						"Parameter `{0}' cannot be used inside `{1}' when using `ref' or `out' modifier",
 						Name, ec.CurrentAnonymousMethod.ContainerType);
 				}
 
 				if (ec.IsVariableCapturingRequired && !pi.Block.ParametersBlock.IsExpressionTree) {
 					AnonymousMethodStorey storey = pi.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureParameter (ec, this);
 				}
 			}
 
 			return true;
 		}
 
 		public override int GetHashCode ()
 		{
 			return Name.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			ParameterReference pr = obj as ParameterReference;
 			if (pr == null)
 				return false;
 
 			return Name == pr.Name;
 		}
 
 		public override void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			//
 			// ParameterReferences might already be a reference
 			//
 			if (IsRef) {
 				EmitLoad (ec);
 				return;
 			}
 
 			base.AddressOf (ec, mode);
 		}
 		
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			// Nothing to clone
 			return;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			return Parameter.ExpressionTreeVariableReference ();
 		}
 
 		//
 		// Notice that for ref/out parameters, the type exposed is not the
 		// same type exposed externally.
 		//
 		// for "ref int a"
 		//   externally we expose "int&"
 		//   here we expose       "int".
 		//
 		// We record this in "is_ref".  This means that the type system can treat
 		// the type as it is expected, but when we generate the code, we generate
 		// the alternate kind of code.
 		//
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			// HACK
 			if (ec.IsInProbingMode)
 				return this;
 
 			if (HasOutModifier && ec.DoFlowAnalysis &&
 			    (!ec.OmitStructFlowAnalysis || !VariableInfo.TypeInfo.IsStruct) && !IsAssigned (ec, loc))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			SetAssigned (ec);
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		static public void EmitLdArg (EmitContext ec, int x)
 		{
 			switch (x) {
 			case 0
 			case 1
 			case 2
 			case 3
 			default
 				if (x > byte.MaxValue)
 					ec.Emit (OpCodes.Ldarg, x);
 				else
 					ec.Emit (OpCodes.Ldarg_S, (byte) x);
 				break;
 			}
 		}
 	}
 	
 	/// <summary>
 	///   Invocation of methods or delegates.
 	/// </summary>
 	public class Invocation 
 	{
 		protected Arguments arguments;
 		protected Expression expr;
 		protected MethodGroupExpr mg;
 		
 		public Invocation (Expression expr, Arguments arguments)
 		{
 			this.expr = expr;		
 			this.arguments = arguments;
 			if (expr != null)
 				loc = expr.Location;
 		}
 
 		#region Properties
 		public Arguments Arguments {
 			get {
 				return arguments;
 			}
 		}
 		
 		public Expression Expression {
 			get {
 				return expr;
 			}
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
 
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance = mg.IsInstance ?
 				mg.InstanceExpression.CreateExpressionTree (ec) 
 				new NullLiteral (loc);
 
 			var args = Arguments.CreateForExpressionTree (ec, arguments,
 				instance,
 				mg.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression member_expr;
 			var atn = expr as ATypeNameExpression;
 			if (atn != null) {
 				member_expr = atn.LookupNameExpression (ec, MemberLookupRestrictions.InvocableOnly | MemberLookupRestrictions.ReadAccess);
 				if (member_expr != null)
 					member_expr = member_expr.Resolve (ec);
 			} else {
 				member_expr = expr.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.MethodGroup);
 			}
 
 			if (member_expr == null)
 				return null;
 
 			//
 			// Next, evaluate all the expressions in the argument list
 			//
 			bool dynamic_arg = false;
 			if (arguments != null)
 				arguments.Resolve (ec, out dynamic_arg);
 
 			TypeSpec expr_type = member_expr.Type;
 			if (expr_type == InternalType.Dynamic)
 				return DoResolveDynamic (ec, member_expr);
 
 			mg = member_expr as MethodGroupExpr;
 			Expression invoke = null;
 
 			if (mg == null) {
 				if (expr_type != null && TypeManager.IsDelegateType (expr_type)) {
 					invoke = new DelegateInvocation (member_expr, arguments, loc);
 					invoke = invoke.Resolve (ec);
 					if (invoke == null || !dynamic_arg)
 						return invoke;
 				} else {
 					if (member_expr is RuntimeValueExpression) {
 						ec.Report.Error (Report.RuntimeErrorId, loc, "Cannot invoke a non-delegate type `{0}'",
 							member_expr.Type.GetSignatureForError ()); ;
 						return null;
 					}
 
 					MemberExpr me = member_expr as MemberExpr;
 					if (me == null) {
 						member_expr.Error_UnexpectedKind (ec, ResolveFlags.MethodGroup, loc);
 						return null;
 					}
 
 					ec.Report.Error (1955, loc, "The member `{0}' cannot be used as method or delegate",
 							member_expr.GetSignatureForError ());
 					return null;
 				}
 			}
 
 			if (invoke == null) {
 				mg = DoResolveOverload (ec);
 				if (mg == null)
 					return null;
 			}
 
 			if (dynamic_arg)
 				return DoResolveDynamic (ec, member_expr);
 
 			var method = mg.BestCandidate;
 			type = mg.BestCandidateReturnType;
 		
 			if (arguments == null && method.DeclaringType == TypeManager.object_type && method.Name == Destructor.MetadataName) {
 				if (mg.IsBase)
 					ec.Report.Error (250, loc, "Do not directly call your base class Finalize method. It is called automatically from your destructor");
 				else
 					ec.Report.Error (245, loc, "Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available");
 				return null;
 			}
 
 			IsSpecialMethodInvocation (ec, method, loc);
 			
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		protected virtual Expression DoResolveDynamic (ResolveContext ec, Expression memberExpr)
 		{
 			Arguments args;
 			DynamicMemberBinder dmb = memberExpr as DynamicMemberBinder;
 			if (dmb != null) {
 				args = dmb.Arguments;
 				if (arguments != null)
 					args.AddRange (arguments);
 			} else if (mg == null) {
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				args.Insert (0, new Argument (memberExpr));
 				this.expr = null;
 			} else {
 				if (mg.IsBase) {
 					ec.Report.Error (1971, loc,
 						"The base call to method `{0}' cannot be dynamically dispatched. Consider casting the dynamic arguments or eliminating the base access",
 						mg.Name);
 					return null;
 				}
 
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				MemberAccess ma = expr as MemberAccess;
 				if (ma != null) {
 					var left_type = ma.LeftExpression as TypeExpr;
 					if (left_type != null) {
 						args.Insert (0, new Argument (new TypeOf (left_type, loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						//
 						// Any value type has to be pass as by-ref to get back the same
 						// instance on which the member was called
 						//
 						var mod = TypeManager.IsValueType (ma.LeftExpression.Type) ? Argument.AType.Ref 
 						args.Insert (0, new Argument (ma.LeftExpression.Resolve (ec), mod));
 					}
 				} else {	// is SimpleName
 					if (ec.IsStatic) {
 						args.Insert (0, new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						args.Insert (0, new Argument (new This (loc).Resolve (ec)));
 					}
 				}
 			}
 
 			return new DynamicInvocation (expr as ATypeNameExpression, args, loc).Resolve (ec);
 		}
 
 		protected virtual MethodGroupExpr DoResolveOverload (ResolveContext ec)
 		{
 			return mg.OverloadResolve (ec, ref arguments, null, OverloadResolver.Restrictions.None);
 		}
 
 		static MetaType[] GetVarargsTypes (MethodSpec mb, Arguments arguments)
 		{
 			AParametersCollection pd = mb.Parameters;
 
 			Argument a = arguments[pd.Count - 1];
 			Arglist list = (Arglist) a.Expr;
 
 			return list.ArgumentTypes;
 		}
 
 		//
 		// If a member is a method or event, or if it is a constant, field or property of either a delegate type
 		// or the type dynamic, then the member is invocable
 		//
 		public static bool IsMemberInvocable (MemberSpec member)
 		{
 			switch (member.Kind) {
 			case MemberKind.Event
 				return true;
 			case MemberKind.Field
 			case MemberKind.Property
 				var m = member as IInterfaceMemberSpec;
 				return m.MemberType.IsDelegate || m.MemberType == InternalType.Dynamic;
 			default
 				return false;
 			}
 		}
 
 		public static bool IsSpecialMethodInvocation (ResolveContext ec, MethodSpec method, Location loc)
 		{
 			if (!method.IsReservedMethod)
 				return false;
 
 			if (ec.HasSet (ResolveContext.Options.InvokeSpecialName) || ec.CurrentMemberDefinition.IsCompilerGenerated)
 				return false;
 
 			ec.Report.SymbolRelatedToPreviousError (method);
 			ec.Report.Error (571, loc, "`{0}'
 				method.GetSignatureForError ());
 	
 			return true;
 		}
 
 		//
 		// Used to decide whether call or callvirt is needed
 		//
 		static bool IsVirtualCallRequired (Expression instance, MethodSpec method)
 		{
 			//
 			// There are 2 scenarious where we emit callvirt
 			//
 			// Case 1
 			// Case 2
 			// correct NRE exception when the method is called
 			//
 			var decl_type = method.DeclaringType;
 			if (decl_type.IsStruct || decl_type.IsEnum)
 				return false;
 
 			if (instance is BaseThis)
 				return false;
 
 			//
 			// It's non-virtual and will never be null
 			//
 			if (!method.IsVirtual && (instance is This || instance is New || instance is ArrayCreation || instance is DelegateCreation))
 				return false;
 
 			return true;
 		}
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
 		
 		// `dup_args' leaves an extra copy of the arguments on the stack
 		// `omit_args' does not leave any arguments at all.
 		// So, basically, you could make one call with `dup_args' set to true,
 		// and then another with `omit_args' set to true, and the two calls
 		// would have the same set of arguments. However, each argument would
 		// only have been evaluated once.
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc,
 		                             bool dup_args, bool omit_args)
 		{
 			LocalTemporary this_arg = null;
 
 			// Speed up the check by not doing it on not allowed targets
 			if (method.ReturnType == TypeManager.void_type && method.IsConditionallyExcluded (loc))
 				return;
 
 			OpCode call_op;
 			TypeSpec iexpr_type;
 
 			if (method.IsStatic) {
 				iexpr_type = null;
 				call_op = OpCodes.Call;
 			} else {
 				iexpr_type = instance_expr.Type;
 
 				if (IsVirtualCallRequired (instance_expr, method)) {
 					call_op = OpCodes.Callvirt;
 				} else {
 					call_op = OpCodes.Call;
 				}
 
 				//
 				// If this is ourselves, push "this"
 				//
 				if (!omit_args) {
 					TypeSpec t = iexpr_type;
 
 					//
 					// Push the instance expression
 					//
 					if ((iexpr_type.IsStruct && (call_op == OpCodes.Callvirt || (call_op == OpCodes.Call && method.DeclaringType == iexpr_type))) ||
 						iexpr_type.IsGenericParameter || TypeManager.IsNullableType (method.DeclaringType)) {
 						//
 						// If the expression implements IMemoryLocation, then
 						// we can optimize and use AddressOf on the
 						// return.
 						//
 						// If not we have to use some temporary storage for
 						// it.
 						var iml = instance_expr as IMemoryLocation;
 						if (iml != null) {
 							iml.AddressOf (ec, AddressOp.LoadStore);
 						} else {
 							LocalTemporary temp = new LocalTemporary (iexpr_type);
 							instance_expr.Emit (ec);
 							temp.Store (ec);
 							temp.AddressOf (ec, AddressOp.Load);
 						}
 
 						// avoid the overhead of doing this all the time.
 						if (dup_args)
 							t = ReferenceContainer.MakeType (iexpr_type);
 					} else if (iexpr_type.IsEnum || iexpr_type.IsStruct) {
 						instance_expr.Emit (ec);
 						ec.Emit (OpCodes.Box, iexpr_type);
 						t = iexpr_type = TypeManager.object_type;
 					} else {
 						instance_expr.Emit (ec);
 					}
 
 					if (dup_args) {
 						ec.Emit (OpCodes.Dup);
 						if (Arguments != null && Arguments.Count != 0) {
 							this_arg = new LocalTemporary (t);
 							this_arg.Store (ec);
 						}
 					}
 				}
 			}
 
 			if (!omit_args && Arguments != null) {
 				var dup_arg_exprs = Arguments.Emit (ec, dup_args);
 				if (dup_args) {
 					this_arg.Emit (ec);
 					LocalTemporary lt;
 					foreach (var dup in dup_arg_exprs) {
 						dup.Emit (ec);
 						lt = dup as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 				}
 			}
 
 			if (call_op == OpCodes.Callvirt && (iexpr_type.IsGenericParameter || iexpr_type.IsStruct)) {
 				ec.Emit (OpCodes.Constrained, iexpr_type);
 			}
 
 			if (method.Parameters.HasArglist) {
 				var varargs_types = GetVarargsTypes (method, Arguments);
 				ec.Emit (call_op, method, varargs_types);
 				return;
 			}
 
 			//
 			// If you have
 			// this.DoFoo ();
 			// and DoFoo is not virtual, you can omit the callvirt,
 			// because you don't need the null checking behavior.
 			//
 			ec.Emit (call_op, method);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			mg.EmitCall (ec, arguments);
 		}
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			return MakeExpression (ctx, mg.InstanceExpression, mg.BestCandidate, arguments);
 		}
 
 		public static SLE.Expression MakeExpression (BuilderContext ctx, Expression instance, MethodSpec mi, Arguments args)
 		{
 #if STATIC
 			throw new NotSupportedException ();
 #else
 			var instance_expr = instance == null ? null 
 			return SLE.Expression.Call (instance_expr, (MethodInfo) mi.GetMetaInfo (), Arguments.MakeExpression (args, ctx));
 #endif
 		}
 	}
 
 	//
 	// Implements simple new expression 
 	//
 	public class New 
 	{
 		protected Arguments arguments;
 
 		//
 		// During bootstrap, it contains the RequestedType,
 		// but if `type' is not null, it *might* contain a NewDelegate
 		// (because of field multi-initialization)
 		//
 		protected Expression RequestedType;
 
 		protected MethodSpec method;
 
 		public New (Expression requested_type, Arguments arguments, Location l)
 		{
 			RequestedType = requested_type;
 			this.arguments = arguments;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="418" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="611" endline="625">
<![CDATA[
 
 		#endregion
 	}
 
 	//
 	// Created from the conversion code
 	//
 	public class ImplicitDelegateCreation 
 	{
 		ImplicitDelegateCreation (TypeSpec t, MethodGroupExpr mg, Location l)
 		{
 			type = t;
 			this.method_group = mg;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="419" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="633" endline="650">
<![CDATA[
 	}
 	
 	//
 	// A delegate-creation-expression, invoked from the `New' class 
 	//
 	public class NewDelegate 
 	{
 		public Arguments Arguments;
 
 		//
 		// This constructor is invoked from the `New' expression
 		//
 		public NewDelegate (TypeSpec type, Arguments Arguments, Location loc)
 		{
 			this.type = type;
 			this.Arguments = Arguments;
 			this.loc  = loc; 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="420" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="851" endline="867">
<![CDATA[
 	}
 
 	public class LabeledStatement 
 		string name;
 		bool defined;
 		bool referenced;
 		Label label;
 		Block block;
 
 		FlowBranching.UsageVector vectors;
 		
 		public LabeledStatement (string name, Block block, Location l)
 		{
 			this.name = name;
 			this.block = block;
 			this.loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="421" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="968" endline="998">
<![CDATA[
 		}
 
 		[Flags]
 		public enum Mode 
 			IsIncrement    = 0,
 			IsDecrement    = 1,
 			IsPre          = 0,
 			IsPost         = 2,
 			
 			PreIncrement   = 0,
 			PreDecrement   = IsDecrement,
 			PostIncrement  = IsPost,
 			PostDecrement  = IsPost | IsDecrement
 		}
 
 		Mode mode;
 		bool is_expr, recurse;
 
 		Expression expr;
 
 		// Holds the real operation
 		Expression operation;
 
 		static TypeSpec[] predefined;
 
 		public UnaryMutator (Mode m, Expression e, Location loc)
 		{
 			mode = m;
 			this.loc = loc;
 			expr = e;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="422" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4549" endline="4561">
<![CDATA[
 		}
 
 
 		VariableDeclaration decl;
 		Statement statement;
 		bool has_ret;
 
 		public Fixed (VariableDeclaration decl, Statement stmt, Location l)
 		{
 			this.decl = decl;
 			statement = stmt;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="423" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1814" endline="1836">
<![CDATA[
 		}
 	}
 
 	//
 	// A type expression of generic type with type arguments
 	//
 	class GenericTypeExpr 
 	{
 		TypeArguments args;
 		TypeSpec open_type;
 		bool constraints_checked;
 
 		/// <summary>
 		///   Instantiate the generic type `t' with the type arguments `args'.
 		///   Use this constructor if you already know the fully resolved
 		///   generic type.
 		/// </summary>		
 		public GenericTypeExpr (TypeSpec open_type, TypeArguments args, Location l)
 		{
 			this.open_type = open_type;
 			loc = l;
 			this.args = args;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="424" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1296" endline="1309">
<![CDATA[
 		}
 
 		protected ParametersBlock block;
 
 		public TypeSpec ReturnType;
 
 		object return_label;
 
 		protected AnonymousExpression (ParametersBlock block, TypeSpec return_type, Location loc)
 		{
 			this.ReturnType = return_type;
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="425" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8032" endline="8049">
<![CDATA[
 	}
 
 	/// <summary>
 	///   An Element Access expression.
 	///
 	///   During semantic analysis these are transformed into 
 	///   IndexerAccess, ArrayAccess or a PointerArithmetic.
 	/// </summary>
 	public class ElementAccess 
 		public Arguments Arguments;
 		public Expression Expr;
 
 		public ElementAccess (Expression e, Arguments args, Location loc)
 		{
 			Expr = e;
 			this.loc = loc;
 			this.Arguments = args;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="426" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2076" endline="2082">
<![CDATA[
 
 		protected ATypeNameExpression (string name, TypeArguments targs, Location l)
 		{
 			this.name = name;
 			this.targs = targs;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="427" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="240" endline="256">
<![CDATA[
 		}
 
 		readonly Arguments arguments;
 		protected IDynamicBinder binder;
 		protected Expression binder_expr;
 
 		// Used by BinderFlags
 		protected CSharpBinderFlags flags;
 
 		TypeSpec binder_type;
 
 		public DynamicExpressionStatement (IDynamicBinder binder, Arguments args, Location loc)
 		{
 			this.binder = binder;
 			this.arguments = args;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="428" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="28" endline="34">
<![CDATA[
 		public NullableType (TypeExpr underlying, Location l)
 		{
 			this.underlying = underlying;
 			loc = l;
 
 			eclass = ExprClass.Type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="429" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="922" endline="928">
<![CDATA[
 
 		public ParametersImported (IParameterData[] param, TypeSpec[] types, bool hasParams)
 		{
 			this.parameters = param;
 			this.types = types;
 			this.has_params = hasParams;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="430" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="256" endline="267">
<![CDATA[
 	}
 
 	public class Do 
 		public Expression expr;
 		public Statement  EmbeddedStatement;
 
 		public Do (Statement statement, BooleanExpression bool_expr, Location l)
 		{
 			expr = bool_expr;
 			EmbeddedStatement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="431" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="86" endline="98">
<![CDATA[
 	}
 	
 	public class CompletionMemberAccess 
 		Expression expr;
 		string partial_name;
 		TypeArguments targs;
 		
 		public CompletionMemberAccess (Expression e, string partial_name, Location l)
 		{
 			this.expr = e;
 			this.loc = l;
 			this.partial_name = partial_name;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="432" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="373" endline="389">
<![CDATA[
 	}
 
 	//
 	// Generic lifting expression, supports all S/S? -> T/T? cases
 	//
 	public class Lifted 
 	{
 		Expression expr, null_value;
 		Unwrap unwrap;
 
 		public Lifted (Expression expr, Unwrap unwrap, TypeSpec type)
 		{
 			this.expr = expr;
 			this.unwrap = unwrap;
 			this.loc = expr.Location;
 			this.type = type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="433" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="142" endline="154">
<![CDATA[
 
 			#endregion
 		}
 
 		public AQueryClause next;
 		public QueryBlock block;
 
 		protected AQueryClause (QueryBlock block, Expression expr, Location loc)
 			 
 		{
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="434" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1614" endline="1626">
<![CDATA[
 	}
 
 	public class ImplicitCast 
 	{
 		bool arrayAccess;
 
 		public ImplicitCast (Expression expr, TypeSpec target, bool arrayAccess)
 			
 		{
 			this.loc = expr.Location;
 			this.type = target;
 			this.arrayAccess = arrayAccess;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="435" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="135" endline="145">
<![CDATA[
 
 		public If (Expression bool_expr,
 			   Statement true_statement,
 			   Statement false_statement,
 			   Location l)
 		{
 			this.expr = bool_expr;
 			TrueStatement = true_statement;
 			FalseStatement = false_statement;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="436" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="99" endline="106">
<![CDATA[
 
 		public CompletionMemberAccess (Expression e, string partial_name, TypeArguments targs, Location l)
 		{
 			this.expr = e;
 			this.loc = l;
 			this.partial_name = partial_name;
 			this.targs = targs;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="437" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2070" endline="2077">
<![CDATA[
 
 		public Binary (Operator oper, Expression left, Expression right, Location loc)
 		{
 			this.oper = oper;
 			this.left = left;
 			this.right = right;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="438" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="451" endline="471">
<![CDATA[
 	}
 
 	public class For 
 		Expression Test;
 		Statement InitStatement;
 		Statement Increment;
 		public Statement Statement;
 		bool infinite, empty;
 		
 		public For (Statement init_statement,
 			    BooleanExpression test,
 			    Statement increment,
 			    Statement statement,
 			    Location l)
 		{
 			InitStatement = init_statement;
 			Test = test;
 			Increment = increment;
 			Statement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="439" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8966" endline="8978">
<![CDATA[
 	}
 
 	public class FixedBufferPtr 
 		Expression array;
 
 		public FixedBufferPtr (Expression array, TypeSpec array_type, Location l)
 		{
 			this.array = array;
 			this.loc = l;
 
 			type = PointerContainer.MakeType (array_type);
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="440" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="69" endline="246">
<![CDATA[
 	}
 
 	/// <summary>
 	/// Class for applying custom attributes on the return type
 	/// </summary>
 	public class ReturnParameter 
 	{
 		MemberCore method;
 
 		// TODO
 		public ReturnParameter (MemberCore method, MethodBuilder mb, Location location)
 		{
 			this.method = method;
 			try {
 				builder = mb.DefineParameter (0, ParameterAttributes.None, "");			
 			}
 			catch (ArgumentOutOfRangeException) {
 				method.Compiler.Report.RuntimeMissingSupport (location, "custom attributes on the return type");
 			}
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant) {
 				method.Compiler.Report.Warning (3023, 1, a.Location,
 					"CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead");
 			}
 
 			// This occurs after Warning -28
 			if (builder == null)
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.ReturnValue;
 			}
 		}
 
 		/// <summary>
 		/// Is never called
 		/// </summary>
 		public override string[] ValidAttributeTargets {
 			get {
 				return null;
 			}
 		}
 	}
 
 	public class ImplicitLambdaParameter 
 	{
 		public ImplicitLambdaParameter (string name, Location loc)
 			
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (parameter_type == null)
 				throw new InternalErrorException ("A type of implicit lambda parameter `{0}' is not set",
 					Name);
 
 			base.idx = index;
 			return parameter_type;
 		}
 
 		public void SetParameterType (TypeSpec type)
 		{
 			parameter_type = type;
 		}
 	}
 
 	public class ParamsParameter 
 		public ParamsParameter (FullNamedExpression type, string name, Attributes attrs, Location loc)
 			base (type, name, Parameter.Modifier.PARAMS, attrs, loc)
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (base.Resolve (ec, index) == null)
 				return null;
 
 			var ac = parameter_type as ArrayContainer;
 			if (ac == null || ac.Rank != 1) {
 				ec.Compiler.Report.Error (225, Location, "The params parameter must be a single dimensional array");
 				return null;
 			}
 
 			return parameter_type;
 		}
 
 		public override void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			base.ApplyAttributes (mb, cb, index, pa);
 			pa.ParamArray.EmitAttribute (builder);
 		}
 	}
 
 	public class ArglistParameter 
 		// Doesn't have proper type because it's never chosen for better conversion
 		public ArglistParameter (Location loc) 
 			base (null, String.Empty, Parameter.Modifier.NONE, null, loc)
 		{
 			parameter_type = InternalType.Arglist;
 		}
 
 		public override void  ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			// Nothing to do
 		}
 
 		public override bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			return true;
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			return parameter_type;
 		}
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="441" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8594" endline="8600">
<![CDATA[
 
 		public BaseThis (TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 			eclass = ExprClass.Variable;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="442" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1311" endline="1323">
<![CDATA[
 	}
 
 	/// <summary>
 	///   A TypeExpr which already resolved to a type parameter.
 	/// </summary>
 	public class TypeParameterExpr 
 		
 		public TypeParameterExpr (TypeParameter type_parameter, Location loc)
 		{
 			this.type = type_parameter.Type;
 			this.eclass = ExprClass.TypeParameter;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="443" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3159" endline="3173">
<![CDATA[
 		}
 
 		//
 		// The types allowed to be implicitly cast from
 		// on the governing type
 		//
 		static TypeSpec [] allowed_types;
 
 		public Switch (Expression e, ExplicitBlock block, List<SwitchSection> sects, Location l)
 		{
 			Expr = e;
 			this.block = block;
 			Sections = sects;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="444" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="45" endline="51">
<![CDATA[
 		public DynamicTypeExpr (Location loc)
 		{
 			this.loc = loc;
 
 			type = InternalType.Dynamic;
 			eclass = ExprClass.Type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="445" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="75" endline="81">
<![CDATA[
 		{
 			Name = name;
 			Kind = kind;
 			Parameters = null;
 			MemberType = null;
 			arity = -1;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="446" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="926" endline="937">
<![CDATA[
 		public int ID = counter++;
 #endif
 
 		protected MemberSpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition definition, Modifiers modifiers)
 		{
 			this.Kind = kind;
 			this.declaringType = declaringType;
 			this.definition = definition;
 			this.modifiers = modifiers;
 
 			state = StateFlags.Obsolete_Undetected | StateFlags.CLSCompliant_Undetected | StateFlags.MissingDependency_Undetected;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="447" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2878" endline="3005">
<![CDATA[
 
 		public abstract void SetTypeArguments (ResolveContext ec, TypeArguments ta);
 	}
 
 	// 
 	// Represents a group of extension method candidates for whole namespace
 	// 
 	class ExtensionMethodGroupExpr 
 	{
 		NamespaceEntry namespace_entry;
 		public readonly Expression ExtensionExpression;
 
 		public ExtensionMethodGroupExpr (IList<MethodSpec> list, NamespaceEntry n, Expression extensionExpr, Location l)
 			
 		{
 			this.namespace_entry = n;
 			this.ExtensionExpression = extensionExpr;
 		}
 
 		public override bool IsStatic {
 			get { return true; }
 		}
 
 		public override IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			if (namespace_entry == null)
 				return null;
 
 			//
 			// For extension methodgroup we are not looking for base members but parent
 			// namespace extension methods
 			//
 			int arity = type_arguments == null ? 0 
 			var found = namespace_entry.LookupExtensionMethod (DeclaringType, Name, arity, ref namespace_entry);
 			if (found == null)
 				return null;
 
 			return found.Cast<MemberSpec> ().ToList ();
 		}
 
 		public override MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			// We are already here
 			return null;
 		}
 
 		public override MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments arguments, OverloadResolver.IErrorHandler ehandler, OverloadResolver.Restrictions restr)
 		{
 			if (arguments == null)
 				arguments = new Arguments (1);
 
 			arguments.Insert (0, new Argument (ExtensionExpression, Argument.AType.ExtensionType));
 			var res = base.OverloadResolve (ec, ref arguments, ehandler ?? this, restr);
 
 			// Store resolved argument and restore original arguments
 			if (res == null) {
 				// Clean-up modified arguments for error reporting
 				arguments.RemoveAt (0);
 				return null;
 			}
 
 			var me = ExtensionExpression as MemberExpr;
 			if (me != null)
 				me.ResolveInstanceExpression (ec, null);
 
 			InstanceExpression = null;
 			return this;
 		}
 
 		#region IErrorHandler Members
 
 		bool OverloadResolver.IErrorHandler.AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous)
 		{
 			return false;
 		}
 
 		bool OverloadResolver.IErrorHandler.ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument arg, int index)
 		{
 			rc.Report.SymbolRelatedToPreviousError (best);
 			rc.Report.Error (1928, loc,
 				"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' has some invalid arguments",
 				queried_type.GetSignatureForError (), Name, best.GetSignatureForError ());
 
 			if (index == 0) {
 				rc.Report.Error (1929, loc,
 					"Extension method instance type `{0}' cannot be converted to `{1}'",
 					arg.Type.GetSignatureForError (), ((MethodSpec)best).Parameters.ExtensionMethodType.GetSignatureForError ());
 			}
 
 			return true;
 		}
 
 		bool OverloadResolver.IErrorHandler.NoArgumentMatch (ResolveContext rc, MemberSpec best)
 		{
 			return false;
 		}
 
 		bool OverloadResolver.IErrorHandler.TypeInferenceFailed (ResolveContext rc, MemberSpec best)
 		{
 			return false;
 		}
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="448" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1932" endline="1943">
<![CDATA[
 	}
 
 	//
 	// Generic type with unbound type arguments, used for typeof (G<,,>)
 	//
 	class GenericOpenTypeExpr 
 	{
 		public GenericOpenTypeExpr (TypeSpec type, /*UnboundTypeArguments args,*/ Location loc)
 		{
 			this.type = type.GetDefinition ();
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="449" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="476" endline="487">
<![CDATA[
 		}
 
 		Expression condition;
 		ExpressionStatement invoke, assign;
 
 		public DynamicEventCompoundAssign (string name, Arguments args, ExpressionStatement assignment, ExpressionStatement invoke, Location loc)
 		{
 			condition = new IsEvent (name, args, loc);
 			this.invoke = invoke;
 			this.assign = assignment;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="450" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8697" endline="8703">
<![CDATA[
 
 		public EmptyExpression (TypeSpec t)
 		{
 			type = t;
 			eclass = ExprClass.Value;
 			loc = Location.Null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="451" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="38" endline="47">
<![CDATA[
 		public UserOperatorCall (MethodSpec oper, Arguments args, Func<ResolveContext, Expression, Expression> expr_tree, Location loc)
 		{
 			this.oper = oper;
 			this.arguments = args;
 			this.expr_tree = expr_tree;
 
 			type = oper.ReturnType;
 			eclass = ExprClass.Value;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="452" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="95" endline="103">
<![CDATA[
 		Unwrap (Expression expr, bool useDefaultValue)
 		{
 			this.expr = expr;
 			this.loc = expr.Location;
 			this.useDefaultValue = useDefaultValue;
 
 			type = NullableInfo.GetUnderlyingType (expr.Type);
 			eclass = expr.eclass;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="453" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5759" endline="5768">
<![CDATA[
 		}
 
 		LocalVariable li;
 
 		public TemporaryVariableReference (LocalVariable li, Location loc)
 		{
 			this.li = li;
 			this.type = li.Type;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="454" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8741" endline="8780">
<![CDATA[
 
 		private EmptyExpressionStatement ()
 		{
 			loc = Location.Null;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return null;
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// Do nothing
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 			type = TypeManager.object_type;
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			// Do nothing
 		}
 	}	
 
 	public class UserCast 
 		MethodSpec method;
 		Expression source;
 		
 		public UserCast (MethodSpec method, Expression source, Location l)
 		{
 			this.method = method;
 			this.source = source;
 			type = method.ReturnType;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="455" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1200" endline="1215">
<![CDATA[
 			}
 
 			#endregion
 		}
 
 		Expression initializer;
 		protected FullNamedExpression type_expr;
 		protected LocalVariable li;
 		protected List<Declarator> declarators;
 
 		public BlockVariableDeclaration (FullNamedExpression type, LocalVariable li)
 		{
 			this.type_expr = type;
 			this.li = li;
 			this.loc = type_expr.Location;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="456" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4761" endline="4768">
<![CDATA[
 
 		public FieldExpr (FieldSpec spec, Location loc)
 		{
 			this.spec = spec;
 			this.loc = loc;
 
 			type = spec.MemberType;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="457" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="82" endline="90">
<![CDATA[
 
 		public MemberFilter (MethodSpec m)
 		{
 			Name = m.Name;
 			Kind = MemberKind.Method;
 			Parameters = m.Parameters;
 			MemberType = m.ReturnType;
 			arity = m.Arity;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="458" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1021" endline="1027">
<![CDATA[
 		protected TypeCast (Expression child, TypeSpec return_type)
 		{
 			eclass = child.eclass;
 			loc = child.Location;
 			type = return_type;
 			this.child = child;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="459" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8362" endline="8381">
<![CDATA[
 	}
 
 	//
 	// Indexer access expression
 	//
 	class IndexerExpr 
 	{
 		LocalTemporary prepared_value;
 		IList<MemberSpec> indexers;
 		Arguments arguments;
 		TypeSpec queried_type;
 		
 		public IndexerExpr (IList<MemberSpec> indexers, TypeSpec queriedType, ElementAccess ea)
 			
 		{
 			this.indexers = indexers;
 			this.queried_type = queriedType;
 			this.InstanceExpression = ea.Expr;
 			this.arguments = ea.Arguments;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="460" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5076" endline="5082">
<![CDATA[
 		public Invocation (Expression expr, Arguments arguments)
 		{
 			this.expr = expr;		
 			this.arguments = arguments;
 			if (expr != null)
 				loc = expr.Location;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="461" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2458" endline="2534">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Represents a namespace or a type.  The name of the class was inspired by
 	///   section 10.8.1 (Fully Qualified Names).
 	/// </summary>
 	public abstract class FullNamedExpression 
 	{
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			// Do nothing, most unresolved type expressions cannot be
 			// resolved to different type
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			throw new NotSupportedException ("ET");
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new InternalErrorException ("FullNamedExpression `{0}' found in resolved tree",
 				GetSignatureForError ());
 		}
 	}
 	
 	/// <summary>
 	///   Expression that evaluates to a type
 	/// </summary>
 	public abstract class TypeExpr 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			TypeExpr t = DoResolveAsTypeStep (ec);
 			if (t == null)
 				return null;
 
 			eclass = ExprClass.Type;
 			return t;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return ResolveAsTypeTerminal (ec, false);
 		}
 
 		protected abstract TypeExpr DoResolveAsTypeStep (IMemberContext ec);
 
 		public override bool Equals (object obj)
 		{
 			TypeExpr tobj = obj as TypeExpr;
 			if (tobj == null)
 				return false;
 
 			return Type == tobj.Type;
 		}
 
 		public override int GetHashCode ()
 		{
 			return Type.GetHashCode ();
 		}
 	}
 
 	/// <summary>
 	///   Fully resolved Expression that already evaluated to a type
 	/// </summary>
 	public class TypeExpression 
 		public TypeExpression (TypeSpec t, Location l)
 		{
 			Type = t;
 			eclass = ExprClass.Type;
 			loc = l;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="462" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="595" endline="604">
<![CDATA[
 	}
 	
 	public class StatementExpression 
 		ExpressionStatement expr;
 		
 		public StatementExpression (ExpressionStatement expr)
 		{
 			this.expr = expr;
 			loc = expr.Location;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="463" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1899" endline="1910">
<![CDATA[
 		}
 
 		readonly Expression expr, orig_expr;
 
 		private ReducedExpression (Expression expr, Expression orig_expr)
 		{
 			this.expr = expr;
 			this.eclass = expr.eclass;
 			this.type = expr.Type;
 			this.orig_expr = orig_expr;
 			this.loc = orig_expr.Location;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="464" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="766" endline="778">
<![CDATA[
 
 		//
 		// Our constructor
 		//
 		public Iterator (ParametersBlock block, IMethodData method, TypeContainer host, TypeSpec iterator_type, bool is_enumerable)
 			
 		{
 			this.OriginalMethod = method;
 			this.OriginalIteratorType = iterator_type;
 			this.IsEnumerable = is_enumerable;
 			this.Host = host;
 			this.type = method.ReturnType;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="465" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1982" endline="1995">
<![CDATA[
 	}
 
 	//
 	// Standard composite pattern
 	//
 	public abstract class CompositeExpression 
 	{
 		protected Expression expr;
 
 		protected CompositeExpression (Expression expr)
 		{
 			this.expr = expr;
 			this.loc = expr.Location;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="466" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8689" endline="8696">
<![CDATA[
 
 		EmptyExpression ()
 		{
 			// FIXME
 			type = TypeManager.object_type;
 			eclass = ExprClass.Value;
 			loc = Location.Null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="467" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="572" endline="578">
<![CDATA[
 
 		public void SetDefinition (ITypeDefinition td, MetaType type, Modifiers mod)
 		{
 			this.definition = td;
 			this.info = type;
 			this.modifiers |= (mod & ~Modifiers.AccessibilityMask);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="468" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="60" endline="70">
<![CDATA[
 				
 		/// <summary>
 		///   Return value indicates whether all code paths emitted return.
 		/// </summary>
 		protected abstract void DoEmit (EmitContext ec);
 
 		public virtual void Emit (EmitContext ec)
 		{
 			ec.Mark (loc);
 			DoEmit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4280" endline="4290">
<![CDATA[
 	}
 
 	public class Checked 
 		public Block Block;
 		
 		public Checked (Block b, Location loc)
 		{
 			Block = b;
 			b.Unchecked = false;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="469" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="340" endline="363">
<![CDATA[
 	}
 
 	/// <summary>
 	/// Fixed buffer implementation
 	/// </summary>
 	public class FixedField 
 	{
 		public const string FixedElementName = "FixedElementField";
 		static int GlobalCounter = 0;
 
 		TypeBuilder fixed_buffer_type;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.UNSAFE;
 
 		public FixedField (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="531" endline="556">
<![CDATA[
 		}
 	}
 
 	//
 	// The Field class is used to represents class/struct fields during parsing.
 	//
 	public class Field 
 		// <summary>
 		//   Modifiers allowed in a class declaration
 		// </summary>
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.STATIC |
 			Modifiers.VOLATILE |
 			Modifiers.UNSAFE |
 			Modifiers.READONLY;
 
 		public Field (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name,
 			      Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="470" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5150" endline="5158">
<![CDATA[
 
     ''' <summary>
     ''' EndStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEndStatement(ByVal Parent As ParsedObject) As EndStatement
         tm.AcceptIfNotInternalError(KS.End)
         Return New EndStatement(Parent)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="45" endline="51">
<![CDATA[
 
     Sub New(ByVal Parent As TypeDeclaration, ByVal Name As String, ByVal MethodAttributes As Mono.Cecil.MethodAttributes, ByVal ParameterTypes As Mono.Cecil.TypeReference())
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), New SubSignature(Me, Name, ParameterTypes))
         MyBase.MethodAttributes = MethodAttributes
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="471" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5150" endline="5158">
<![CDATA[
 
     ''' <summary>
     ''' EndStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEndStatement(ByVal Parent As ParsedObject) As EndStatement
         tm.AcceptIfNotInternalError(KS.End)
         Return New EndStatement(Parent)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="154" endline="161">
<![CDATA[
 
     Shared Sub EmitSubOrSubOvfOrSubOvfUn(ByVal Info As EmitInfo, ByVal SubType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitSubOvf(Info, SubType)
         Else
             EmitSub(Info, SubType)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="472" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5150" endline="5158">
<![CDATA[
 
     ''' <summary>
     ''' EndStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEndStatement(ByVal Parent As ParsedObject) As EndStatement
         tm.AcceptIfNotInternalError(KS.End)
         Return New EndStatement(Parent)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="272" endline="279">
<![CDATA[
 
     Shared Sub EmitMultOrMultOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitMultOvf(Info, OperandType)
         Else
             EmitMult(Info, OperandType)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="473" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5150" endline="5158">
<![CDATA[
 
     ''' <summary>
     ''' EndStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEndStatement(ByVal Parent As ParsedObject) As EndStatement
         tm.AcceptIfNotInternalError(KS.End)
         Return New EndStatement(Parent)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="249" endline="256">
<![CDATA[
 
     Shared Sub EmitAddOrAddOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitAddOvf(Info, OperandType)
         Else
             EmitAdd(Info, OperandType)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="474" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5150" endline="5158">
<![CDATA[
 
     ''' <summary>
     ''' EndStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEndStatement(ByVal Parent As ParsedObject) As EndStatement
         tm.AcceptIfNotInternalError(KS.End)
         Return New EndStatement(Parent)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="58" endline="64">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As Mono.Cecil.TypeReference)
         MyBase.Init(Modifiers, Name, VariableType)
         UpdateDefinition()
 
         Helper.Assert(FieldType IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="475" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="102" endline="108">
<![CDATA[
     End Property
 
     ReadOnly Property AsArrayTypeName() As ArrayTypeName
         Get
             Helper.Assert(IsArray)
             Return DirectCast(m_TypeName, ArrayTypeName)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="95" endline="101">
<![CDATA[
     End Property
 
     ReadOnly Property AsNonArrayTypeName() As NonArrayTypeName
         Get
             Helper.Assert(IsNotArray)
             Return DirectCast(m_TypeName, NonArrayTypeName)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="476" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1221" endline="1233">
<![CDATA[
 
   /** the generated parser, with debugging messages.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @param yydebug debug message writer implementing yyDebug, or null.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
 				 {
     this.debug = (yydebug.yyDebug)yyd;
     return yyparse(yyLex);
   }
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="477" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1136" endline="1142">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="478" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1398" endline="1404">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="479" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1515" endline="1521">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.float_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="480" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1638" endline="1644">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.double_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="481" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1892" endline="1898">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.string_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="482" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="412" endline="418">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.byte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="483" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="725" endline="731">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.short_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="484" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="340" endline="346">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.bool_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="485" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="495" endline="501">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.char_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="486" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="955" endline="961">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="487" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1766" endline="1772">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.decimal_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="488" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="619" endline="625">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.sbyte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="489" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="843" endline="849">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.ushort_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="490" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1259" endline="1265">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8756" endline="8762">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 			type = TypeManager.object_type;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="491" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2999" endline="3109">
<![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1306" endline="1318">
<![CDATA[
 	}
 
 	public class ImportedModuleDefinition
 	{
 		readonly Module module;
 		bool cls_compliant;
 		readonly MetadataImporter importer;
 		
 		public ImportedModuleDefinition (Module module, MetadataImporter importer)
 		{
 			this.module = module;
 			this.importer = importer;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="492" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2999" endline="3109">
<![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1122" endline="1248">
<![CDATA[
 
 			public AttributeUsageAttribute AttributeUsage;
 			public ObsoleteAttribute Obsolete;
 			public string[] Conditionals;
 			public string DefaultIndexerName;
 			public bool IsNotCLSCompliant;
 			public TypeSpec CoClass;
 			
 			public static AttributesBag Read (MemberInfo mi, MetadataImporter importer)
 			{
 				AttributesBag bag = null;
 				List<string> conditionals = null;
 
 				// It should not throw any loading exception
 				IList<CustomAttributeData> attrs = CustomAttributeData.GetCustomAttributes (mi);
 
 				string ns, name;
 				foreach (var a in attrs) {
 					importer.GetCustomAttributeTypeName (a, out ns, out name);
 					if (name == "ObsoleteAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						var args = a.ConstructorArguments;
 
 						if (args.Count == 1) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value);
 						} else if (args.Count == 2) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value, (bool) args[1].Value);
 						} else {
 							bag.Obsolete = new ObsoleteAttribute ();
 						}
 
 						continue;
 					}
 
 					if (name == "ConditionalAttribute") {
 						if (ns != "System.Diagnostics")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						if (conditionals == null)
 							conditionals = new List<string> (2);
 
 						conditionals.Add ((string) a.ConstructorArguments[0].Value);
 						continue;
 					}
 
 					if (name == "CLSCompliantAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						bag.IsNotCLSCompliant = !(bool) a.ConstructorArguments[0].Value;
 						continue;
 					}
 
 					// Type only attributes
 					if (mi.MemberType == MemberTypes.TypeInfo || mi.MemberType == MemberTypes.NestedType) {
 						if (name == "DefaultMemberAttribute") {
 							if (ns != "System.Reflection")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.DefaultIndexerName = (string) a.ConstructorArguments[0].Value;
 							continue;
 						}
 
 						if (name == "AttributeUsageAttribute") {
 							if (ns != "System")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.AttributeUsage = new AttributeUsageAttribute ((AttributeTargets) a.ConstructorArguments[0].Value);
 							foreach (var named in a.NamedArguments) {
 								if (named.MemberInfo.Name == "AllowMultiple")
 									bag.AttributeUsage.AllowMultiple = (bool) named.TypedValue.Value;
 								else if (named.MemberInfo.Name == "Inherited")
 									bag.AttributeUsage.Inherited = (bool) named.TypedValue.Value;
 							}
 							continue;
 						}
 
 						// Interface only attribute
 						if (name == "CoClassAttribute") {
 							if (ns != "System.Runtime.InteropServices")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.CoClass = importer.ImportType ((MetaType) a.ConstructorArguments[0].Value);
 							continue;
 						}
 					}
 				}
 
 				if (bag == null)
 					return Default;
 
 				if (conditionals != null)
 					bag.Conditionals = conditionals.ToArray ();
 				
 				return bag;
 			}
 		}
 
 		protected readonly MemberInfo provider;
 		protected AttributesBag cattrs;
 		protected readonly MetadataImporter importer;
 
 		public ImportedDefinition (MemberInfo provider, MetadataImporter importer)
 		{
 			this.provider = provider;
 			this.importer = importer;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="493" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2999" endline="3109">
<![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8826" endline="8842">
<![CDATA[
 	}
 
 	//
 	// Holds additional type specifiers like ?, *, []
 	//
 	public class ComposedTypeSpecifier
 	{
 		public static readonly ComposedTypeSpecifier SingleDimension = new ComposedTypeSpecifier (1, Location.Null);
 
 		public readonly int Dimension;
 		public readonly Location Location;
 
 		public ComposedTypeSpecifier (int specifier, Location loc)
 		{
 			this.Dimension = specifier;
 			this.Location = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="494" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2999" endline="3109">
<![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="694" endline="706">
<![CDATA[
 		}
 	}
 
 	public class MissingType 
 	{
 		readonly string full_name;
 		readonly MissingAssembly assembly;
 
 		public MissingType (string typeName, MissingAssembly assembly)
 		{
 			this.full_name = typeName;
 			this.assembly = assembly;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="495" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2999" endline="3109">
<![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="44" endline="253">
<![CDATA[
 
 		bool is_double_colon;
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    Location loc)
 		{
 			this.Name = name;
 			this.Location = loc;
 			this.is_double_colon = is_double_colon;
 			this.Left = left;
 		}
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    TypeArguments args, Location loc)
 			
 		{
 			if (args != null && args.Count > 0)
 				this.TypeArguments = args;
 		}
 
 		public MemberName (string name)
 			
 		{ }
 
 		public MemberName (string name, Location loc)
 			
 		{ }
 
 		public MemberName (string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (string alias, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right, Location loc)
 			
 		{
 			if (right.is_double_colon)
 				throw new InternalErrorException ("Cannot append double_colon member name");
 			this.Left = (right.Left == null) ? left 
 		}
 
 		// TODO
 		public string GetName ()
 		{
 			return GetName (false);
 		}
 
 		public int Arity {
 			get {
 				return TypeArguments == null ? 0 
 			}
 		}
 
 		public bool IsGeneric {
 			get {
 				if (TypeArguments != null)
 					return true;
 				else if (Left != null)
 					return Left.IsGeneric;
 				else
 					return false;
 			}
 		}
 
 		public string GetName (bool is_generic)
 		{
 			string name = is_generic ? Basename 
 			if (Left != null)
 				return Left.GetName (is_generic) + (is_double_colon ? "
 
 			return name;
 		}
 
 		public ATypeNameExpression GetTypeExpression ()
 		{
 			if (Left == null) {
 				if (TypeArguments != null)
 					return new SimpleName (Name, TypeArguments, Location);
 				
 				return new SimpleName (Name, Location);
 			}
 
 			if (is_double_colon) {
 				if (Left.Left != null)
 					throw new InternalErrorException ("The left side of a 
 				return new QualifiedAliasMember (Left.Name, Name, TypeArguments, Location);
 			}
 
 			Expression lexpr = Left.GetTypeExpression ();
 			return new MemberAccess (lexpr, Name, TypeArguments, Location);
 		}
 
 		public MemberName Clone ()
 		{
 			MemberName left_clone = Left == null ? null 
 			return new MemberName (left_clone, Name, is_double_colon, TypeArguments, Location);
 		}
 
 		public string Basename {
 			get {
 				if (TypeArguments != null)
 					return MakeName (Name, TypeArguments);
 				return Name;
 			}
 		}
 
 		public string GetSignatureForError ()
 		{
 			string append = TypeArguments == null ? "" 
 			if (Left == null)
 				return Name + append;
 			string connect = is_double_colon ? "
 			return Left.GetSignatureForError () + connect + Name + append;
 		}
 
 		public override bool Equals (object other)
 		{
 			return Equals (other as MemberName);
 		}
 
 		public bool Equals (MemberName other)
 		{
 			if (this == other)
 				return true;
 			if (other == null || Name != other.Name)
 				return false;
 			if (is_double_colon != other.is_double_colon)
 				return false;
 
 			if ((TypeArguments != null) &&
 			    (other.TypeArguments == null || TypeArguments.Count != other.TypeArguments.Count))
 				return false;
 
 			if ((TypeArguments == null) && (other.TypeArguments != null))
 				return false;
 
 			if (Left == null)
 				return other.Left == null;
 
 			return Left.Equals (other.Left);
 		}
 
 		public override int GetHashCode ()
 		{
 			int hash = Name.GetHashCode ();
 			for (MemberName n = Left; n != null; n = n.Left)
 				hash ^= n.Name.GetHashCode ();
 			if (is_double_colon)
 				hash ^= 0xbadc01d;
 
 			if (TypeArguments != null)
 				hash ^= TypeArguments.Count << 5;
 
 			return hash & 0x7FFFFFFF;
 		}
 
 		public int CountTypeArguments {
 			get {
 				if (TypeArguments != null)
 					return TypeArguments.Count;
 				else if (Left != null)
 					return Left.CountTypeArguments; 
 				else
 					return 0;
 			}
 		}
 
 		public static string MakeName (string name, TypeArguments args)
 		{
 			if (args == null)
 				return name;
 
 			return name + "`" + args.Count;
 		}
 
 		public static string MakeName (string name, int count)
 		{
 			return name + "`" + count;
 		}
 	}
 
 	public class SimpleMemberName
 	{
 		public string Value;
 		public Location Location;
 
 		public SimpleMemberName (string name, Location loc)
 		{
 			this.Value = name;
 			this.Location = loc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="496" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2999" endline="3109">
<![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="192" endline="695">
<![CDATA[
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
 
 		#region Properties
 
 		public DefaultParameterValueExpression DefaultValue {
 			get {
 				return default_expr as DefaultParameterValueExpression;
 			}
 			set {
 				default_expr = value;
 			}
 		}
 
 		Expression IParameterData.DefaultValue {
 			get {
 				var expr = default_expr as DefaultParameterValueExpression;
 				return expr == null ? default_expr 
 			}
 		}
 
 		bool HasOptionalExpression {
 			get {
 				return default_expr is DefaultParameterValueExpression;
 			}
 		}
 
 		public Location Location {
 			get {
 				return loc;
 			}
 		}
 
 		public TypeSpec Type {
 			get {
 				return parameter_type;
 			}
 		}
 
 		public FullNamedExpression TypeExpression  {
 			get {
 				return texpr;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.In && ModFlags == Modifier.OUT) {
 				a.Report.Error (36, a.Location, "An out parameter cannot have the `In' attribute");
 				return;
 			}
 
 			if (a.Type == pa.ParamArray) {
 				a.Report.Error (674, a.Location, "Do not use `System.ParamArrayAttribute'. Use the `params' keyword instead");
 				return;
 			}
 
 			if (a.Type == pa.Out && (ModFlags & Modifier.REF) == Modifier.REF &&
 			    !OptAttributes.Contains (pa.In)) {
 				a.Report.Error (662, a.Location,
 					"Cannot specify only `Out' attribute on a ref parameter. Use both `In' and `Out' attributes or neither");
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				a.Report.Warning (3022, 1, a.Location, "CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead");
 			}
 
 			if (a.Type == pa.DefaultParameterValue || a.Type == pa.OptionalParameter) {
 				if (HasOptionalExpression) {
 					a.Report.Error (1745, a.Location,
 						"Cannot specify `{0}' attribute on optional parameter `{1}'",
 						TypeManager.CSharpName (a.Type).Replace ("Attribute", ""), Name);
 				}
 
 				if (a.Type == pa.DefaultParameterValue)
 					return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 		
 		public virtual bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			if (parameter_type == null)
 				return true;
 
 			return member.IsAccessibleAs (parameter_type);
 		}
 
 		public static void Reset ()
 		{
 			parameter_expr_tree_type = null;
 		}
 
 		// <summary>
 		//   Resolve is used in method definitions
 		// </summary>
 		public virtual TypeSpec Resolve (IMemberContext rc, int index)
 		{
 			if (parameter_type != null)
 				return parameter_type;
 
 			if (attributes != null)
 				attributes.AttachTo (this, rc);
 
 			var expr = texpr.ResolveAsTypeTerminal (rc, false);
 			if (expr == null)
 				return null;
 
 			this.idx = index;
 			texpr = expr;
 			parameter_type = texpr.Type;
 	
 			if ((modFlags & Parameter.Modifier.ISBYREF) != 0 &&
 				TypeManager.IsSpecialType (parameter_type)) {
 				rc.Compiler.Report.Error (1601, Location, "Method or delegate parameter cannot be of type `{0}'",
 					GetSignatureForError ());
 				return null;
 			}
 
 			TypeManager.CheckTypeVariance (parameter_type,
 				(modFlags & Parameter.Modifier.ISBYREF) != 0 ? Variance.None 
 				rc);
 
 			if (parameter_type.IsStatic) {
 				rc.Compiler.Report.Error (721, Location, "`{0}'
 					texpr.GetSignatureForError ());
 				return parameter_type;
 			}
 
 			if ((modFlags & Modifier.This) != 0 && (parameter_type.IsPointer || parameter_type == InternalType.Dynamic)) {
 				rc.Compiler.Report.Error (1103, Location, "The extension method cannot be of type `{0}'",
 					TypeManager.CSharpName (parameter_type));
 			}
 
 			return parameter_type;
 		}
 
 		public void ResolveDefaultValue (ResolveContext rc)
 		{
 			//
 			// Default value was specified using an expression
 			//
 			if (default_expr != null) {
 				((DefaultParameterValueExpression)default_expr).Resolve (rc, this);
 				return;
 			}
 
 			if (attributes == null)
 				return;
 			
 			var opt_attr = attributes.Search (rc.Module.PredefinedAttributes.OptionalParameter);
 			var def_attr = attributes.Search (rc.Module.PredefinedAttributes.DefaultParameterValue);
 			if (def_attr != null) {
 				if (def_attr.Resolve () == null)
 					return;
 
 				var default_expr_attr = def_attr.GetParameterDefaultValue ();
 				if (default_expr_attr == null)
 					return;
 
 				var dpa_rc = def_attr.CreateResolveContext ();
 				default_expr = default_expr_attr.Resolve (dpa_rc);
 
 				if (default_expr is BoxedCast)
 					default_expr = ((BoxedCast) default_expr).Child;
 
 				Constant c = default_expr as Constant;
 				if (c == null) {
 					if (parameter_type == TypeManager.object_type) {
 						rc.Compiler.Report.Error (1910, default_expr.Location,
 							"Argument of type `{0}' is not applicable for the DefaultParameterValue attribute",
 							default_expr.Type.GetSignatureForError ());
 					} else {
 						rc.Compiler.Report.Error (1909, default_expr.Location,
 							"The DefaultParameterValue attribute is not applicable on parameters of type `{0}'",
 							default_expr.Type.GetSignatureForError ()); ;
 					}
 
 					default_expr = null;
 					return;
 				}
 
 				if (TypeSpecComparer.IsEqual (default_expr.Type, parameter_type) ||
 					(default_expr is NullConstant && TypeManager.IsReferenceType (parameter_type) && !parameter_type.IsGenericParameter) ||
 					TypeSpecComparer.IsEqual (parameter_type, TypeManager.object_type)) {
 					return;
 				}
 
 				//
 				// LAMESPEC
 				// User operators returning same type as parameter type are considered
 				// valid for this attribute only
 				//
 				// struct S { public static implicit operator S (int i) {} }
 				//
 				// void M ([DefaultParameterValue (3)]S s)
 				//
 				var expr = Convert.ImplicitUserConversion (dpa_rc, default_expr, parameter_type, loc);
 				if (expr != null && TypeSpecComparer.IsEqual (expr.Type, parameter_type)) {
 					return;
 				}
 				
 				rc.Compiler.Report.Error (1908, default_expr.Location, "The type of the default value should match the type of the parameter");
 				return;
 			}
 
 			if (opt_attr != null) {
 				default_expr = EmptyExpression.MissingValue;
 			}
 		}
 
 		public bool HasDefaultValue {
 			get { return default_expr != null; }
 		}
 
 		public bool HasExtensionMethodModifier {
 			get { return (modFlags & Modifier.This) != 0; }
 		}
 
 		//
 		// Hoisted parameter variant
 		//
 		public HoistedVariable HoistedVariant {
 			get {
 				return hoisted_variant;
 			}
 			set {
 				hoisted_variant = value;
 			}
 		}
 
 		public Modifier ModFlags {
 			get { return modFlags & ~Modifier.This; }
 		}
 
 		public string Name {
 			get { return name; }
 			set { name = value; }
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Parameter;
 			}
 		}
 
 		public virtual string GetSignatureForError ()
 		{
 			string type_name;
 			if (parameter_type != null)
 				type_name = TypeManager.CSharpName (parameter_type);
 			else
 				type_name = texpr.GetSignatureForError ();
 
 			string mod = GetModifierSignature (modFlags);
 			if (mod.Length > 0)
 				return String.Concat (mod, " ", type_name);
 
 			return type_name;
 		}
 
 		public static string GetModifierSignature (Modifier mod)
 		{
 			switch (mod) {
 			case Modifier.OUT
 				return "out";
 			case Modifier.PARAMS
 				return "params";
 			case Modifier.REF
 				return "ref";
 			case Modifier.This
 				return "this";
 			default
 				return "";
 			}
 		}
 
 		public void IsClsCompliant (IMemberContext ctx)
 		{
 			if (parameter_type.IsCLSCompliant ())
 				return;
 
 			ctx.Compiler.Report.Warning (3001, 1, Location,
 				"Argument type `{0}' is not CLS-compliant", parameter_type.GetSignatureForError ());
 		}
 
 		public virtual void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			if (builder != null)
 				throw new InternalErrorException ("builder already exists");
 
 			var pattrs = ParametersCompiled.GetParameterAttribute (modFlags);
 			if (HasOptionalExpression)
 				pattrs |= ParameterAttributes.Optional;
 
 			if (mb == null)
 				builder = cb.DefineParameter (index, pattrs, Name);
 			else
 				builder = mb.DefineParameter (index, pattrs, Name);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (HasDefaultValue) {
 				//
 				// Emit constant values for true constants only, the other
 				// constant-like expressions will rely on default value expression
 				//
 				var def_value = DefaultValue;
 				Constant c = def_value != null ? def_value.Child as Constant 
 				if (c != null) {
 					if (default_expr.Type == TypeManager.decimal_type) {
 						pa.DecimalConstant.EmitAttribute (builder, (decimal) c.GetValue (), c.Location);
 					} else {
 						builder.SetConstant (c.GetValue ());
 					}
 				} else if (default_expr.Type.IsStruct) {
 					//
 					// Handles special case where default expression is used with value-type
 					//
 					// void Foo (S s = default (S)) {}
 					//
 					builder.SetConstant (null);
 				}
 			}
 
 			if (parameter_type != null) {
 				if (parameter_type == InternalType.Dynamic) {
 					pa.Dynamic.EmitAttribute (builder);
 				} else if (parameter_type.HasDynamicElement) {
 					pa.Dynamic.EmitAttribute (builder, parameter_type, Location);
 				}
 			}
 		}
 
 		public Parameter Clone ()
 		{
 			Parameter p = (Parameter) MemberwiseClone ();
 			if (attributes != null)
 				p.attributes = attributes.Clone ();
 
 			return p;
 		}
 
 		public ExpressionStatement CreateExpressionTreeVariable (BlockContext ec)
 		{
 			if ((modFlags & Modifier.ISBYREF) != 0)
 				ec.Report.Error (1951, Location, "An expression tree parameter cannot use `ref' or `out' modifier");
 
 			expr_tree_variable = TemporaryVariableReference.Create (ResolveParameterExpressionType (ec, Location).Type, ec.CurrentBlock.ParametersBlock, Location);
 			expr_tree_variable = (TemporaryVariableReference) expr_tree_variable.Resolve (ec);
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (new TypeOf (
 				new TypeExpression (parameter_type, Location), Location)));
 			arguments.Add (new Argument (new StringConstant (Name, Location)));
 			return new SimpleAssign (ExpressionTreeVariableReference (),
 				Expression.CreateExpressionFactoryCall (ec, "Parameter", null, arguments, Location));
 		}
 
 		public void Emit (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			ParameterReference.EmitLdArg (ec, arg_idx);
 		}
 
 		public void EmitAssign (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			if (arg_idx <= 255)
 				ec.Emit (OpCodes.Starg_S, (byte) arg_idx);
 			else
 				ec.Emit (OpCodes.Starg, arg_idx);
 		}
 
 		public void EmitAddressOf (EmitContext ec)
 		{
 			int arg_idx = idx;
 
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			bool is_ref = (ModFlags & Modifier.ISBYREF) != 0;
 			if (is_ref) {
 				ParameterReference.EmitLdArg (ec, arg_idx);
 			} else {
 				if (arg_idx <= 255)
 					ec.Emit (OpCodes.Ldarga_S, (byte) arg_idx);
 				else
 					ec.Emit (OpCodes.Ldarga, arg_idx);
 			}
 		}
 
 		public TemporaryVariableReference ExpressionTreeVariableReference ()
 		{
 			return expr_tree_variable;
 		}
 
 		//
 		// System.Linq.Expressions.ParameterExpression type
 		//
 		public static TypeExpr ResolveParameterExpressionType (IMemberContext ec, Location location)
 		{
 			if (parameter_expr_tree_type != null)
 				return parameter_expr_tree_type;
 
 			TypeSpec p_type = ec.Module.PredefinedTypes.ParameterExpression.Resolve (location);
 			parameter_expr_tree_type = new TypeExpression (p_type, location).
 				ResolveAsTypeTerminal (ec, false);
 
 			return parameter_expr_tree_type;
 		}
 
 		public void Warning_UselessOptionalParameter (Report Report)
 		{
 			Report.Warning (1066, 1, Location,
 				"The default value specified for optional parameter `{0}' will never be used",
 				Name);
 		}
 	}
 
 	//
 	// Imported or resolved parameter information
 	//
 	public class ParameterData 
 	{
 		readonly string name;
 		readonly Parameter.Modifier modifiers;
 		readonly Expression default_value;
 
 		public ParameterData (string name, Parameter.Modifier modifiers)
 		{
 			this.name = name;
 			this.modifiers = modifiers;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="497" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="44" endline="50">
<![CDATA[
 
 		private FieldSignature(Type fieldType, Type[] optionalCustomModifiers, Type[] requiredCustomModifiers)
 		{
 			this.fieldType = fieldType;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="498" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ResourceModule.cs" startline="35" endline="41">
<![CDATA[
 		internal ResourceModule(Assembly assembly, string scopeName, string location)
 			
 		{
 			this.assembly = assembly;
 			this.scopeName = scopeName;
 			this.location = location;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="499" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2096" endline="2103">
<![CDATA[
 
 		private GenericTypeInstance(Type type, Type[] args, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			this.type = type;
 			this.args = args;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="500" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="41" endline="48">
<![CDATA[
 		private MethodSignature(Type returnType, Type[] parameterTypes, Type[][][] modifiers, CallingConventions callingConvention, int genericParamCount)
 		{
 			this.returnType = returnType;
 			this.parameterTypes = parameterTypes;
 			this.modifiers = modifiers;
 			this.callingConvention = callingConvention;
 			this.genericParamCount = genericParamCount;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="501" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="39" endline="45">
<![CDATA[
 		internal GenericMethodInstance(Type declaringType, MethodInfo method, Type[] methodArgs)
 		{
 			System.Diagnostics.Debug.Assert(!(method is GenericMethodInstance));
 			this.declaringType = declaringType;
 			this.method = method;
 			this.methodArgs = methodArgs;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="502" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\StandAloneMethodSig.cs" startline="39" endline="47">
<![CDATA[
 		internal __StandAloneMethodSig(bool unmanaged, CallingConvention unmanagedCallingConvention, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
 		{
 			this.unmanaged = unmanaged;
 			this.unmanagedCallingConvention = unmanagedCallingConvention;
 			this.callingConvention = callingConvention;
 			this.returnType = returnType;
 			this.parameterTypes = parameterTypes;
 			this.optionalParameterTypes = optionalParameterTypes;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="503" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="48" endline="58">
<![CDATA[
 
 		private PropertySignature(CallingConventions callingConvention, Type propertyType, Type[] optionalCustomModifiers, Type[] requiredCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeOptionalCustomModifiers, Type[][] parameterTypeRequiredCustomModifiers)
 		{
 			this.callingConvention = callingConvention;
 			this.propertyType = propertyType;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 			this.parameterTypes = parameterTypes;
 			this.parameterOptionalCustomModifiers = parameterTypeOptionalCustomModifiers;
 			this.parameterRequiredCustomModifiers = parameterTypeRequiredCustomModifiers;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="504" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="39" endline="45">
<![CDATA[
 		internal AssemblyReader(string location, ModuleReader manifestModule)
 			
 		{
 			this.location = location;
 			this.manifestModule = manifestModule;
 			externalModules = new Module[manifestModule.File.records.Length];
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="505" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="267" endline="282">
<![CDATA[
 	}
 
 	[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
 	struct SingleConverter
 	{
 		[System.Runtime.InteropServices.FieldOffset(0)]
 		private int i;
 		[System.Runtime.InteropServices.FieldOffset(0)]
 		private float f;
 
 		internal static int SingleToInt32Bits(float v)
 		{
 			SingleConverter c = new SingleConverter();
 			c.f = v;
 			return c.i;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="283" endline="289">
<![CDATA[
 
 		internal static float Int32BitsToSingle(int v)
 		{
 			SingleConverter c = new SingleConverter();
 			c.i = v;
 			return c.f;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="506" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9495" endline="9506">
<![CDATA[
 
 			#endregion
 		}
 
 		CollectionOrObjectInitializers initializers;
 		IMemoryLocation instance;
 
 		public NewInitialize (FullNamedExpression requested_type, Arguments arguments, CollectionOrObjectInitializers initializers, Location l)
 			
 		{
 			this.initializers = initializers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="736" endline="828">
<![CDATA[
 	}
 
 	//
 	// Any member binder which can be source and target of assignment
 	//
 	abstract class DynamicMemberAssignable 
 	{
 		Expression setter;
 		Arguments setter_args;
 
 		protected DynamicMemberAssignable (Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			//
 			// DoResolve always uses getter
 			//
 			return CreateCallSiteBinder (ec, args, false);
 		}
 
 		protected abstract Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet);
 
 		protected virtual Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			var setter_args = new Arguments (Arguments.Count + 1);
 			setter_args.AddRange (Arguments);
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				right_side.DoResolveLValue (rc, this);
 				return null;
 			}
 
 			if (DoResolveCore (rc)) {
 				setter_args = CreateSetterArguments (rc, right_side);
 				setter = CreateCallSiteBinder (rc, setter_args, true);
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, false);
 			else
 				base.Emit (ec);
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, true);
 			else
 				base.EmitStatement (ec);
 		}
 
 		#region IAssignMethod Members
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			EmitCall (ec, setter, setter_args, !leave_copy);
 		}
 
 		#endregion
 	}
 
 	class DynamicUnaryConversion 
 	{
 		readonly string name;
 
 		public DynamicUnaryConversion (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 			base.binder = this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="507" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9495" endline="9506">
<![CDATA[
 
 			#endregion
 		}
 
 		CollectionOrObjectInitializers initializers;
 		IMemoryLocation instance;
 
 		public NewInitialize (FullNamedExpression requested_type, Arguments arguments, CollectionOrObjectInitializers initializers, Location l)
 			
 		{
 			this.initializers = initializers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="514" endline="524">
<![CDATA[
 	}
 
 	class DynamicConversion 
 	{
 		public DynamicConversion (TypeSpec targetType, CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			type = targetType;
 			base.flags = flags;
 			base.binder = this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="508" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9495" endline="9506">
<![CDATA[
 
 			#endregion
 		}
 
 		CollectionOrObjectInitializers initializers;
 		IMemoryLocation instance;
 
 		public NewInitialize (FullNamedExpression requested_type, Arguments arguments, CollectionOrObjectInitializers initializers, Location l)
 			
 		{
 			this.initializers = initializers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="47" endline="54">
<![CDATA[
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    Location loc)
 		{
 			this.Name = name;
 			this.Location = loc;
 			this.is_double_colon = is_double_colon;
 			this.Left = left;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="509" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9495" endline="9506">
<![CDATA[
 
 			#endregion
 		}
 
 		CollectionOrObjectInitializers initializers;
 		IMemoryLocation instance;
 
 		public NewInitialize (FullNamedExpression requested_type, Arguments arguments, CollectionOrObjectInitializers initializers, Location l)
 			
 		{
 			this.initializers = initializers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9587" endline="9602">
<![CDATA[
 	}
 
 	public class NewAnonymousType 
 	{
 		static readonly AnonymousTypeParameter[] EmptyParameters = new AnonymousTypeParameter[0];
 
 		List<AnonymousTypeParameter> parameters;
 		readonly TypeContainer parent;
 		AnonymousTypeClass anonymous_type;
 
 		public NewAnonymousType (List<AnonymousTypeParameter> parameters, TypeContainer parent, Location loc)
 			 
 		{
 			this.parameters = parameters;
 			this.parent = parent;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="510" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1261" endline="1272">
<![CDATA[
 
 			#endregion
 		}
 
 		readonly int rank;
 		static Dictionary<TypeRankPair, ArrayContainer> instances = new Dictionary<TypeRankPair, ArrayContainer> ();
 
 		private ArrayContainer (TypeSpec element, int rank)
 			
 		{
 			this.rank = rank;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4787" endline="4794">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			local_info.SetIsUsed ();
 
 			DoResolveBase (ec);
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="511" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="449" endline="456">
<![CDATA[
 
 		public override MemberInfo Member
 		{
 			get
 			{
 				// return the right ConstructorInfo wrapper
 				return method.Module.ResolveMethod(method.MetadataToken);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="130" endline="136">
<![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="512" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="449" endline="456">
<![CDATA[
 
 		public override MemberInfo Member
 		{
 			get
 			{
 				// return the right ConstructorInfo wrapper
 				return method.Module.ResolveMethod(method.MetadataToken);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="148" endline="154">
<![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="513" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="449" endline="456">
<![CDATA[
 
 		public override MemberInfo Member
 		{
 			get
 			{
 				// return the right ConstructorInfo wrapper
 				return method.Module.ResolveMethod(method.MetadataToken);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="58" endline="68">
<![CDATA[
 
 		internal override PropertySignature PropertySignature
 		{
 			get
 			{
 				if (sig == null)
 				{
 					sig = PropertySignature.ReadSig(module, module.GetBlob(module.Property.records[index].Type), declaringType);
 				}
 				return sig;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="514" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5815" endline="5821">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			li.CreateBuilder (ec);
 
 			Emit (ec, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="168" endline="176">
<![CDATA[
 	}
 
 	public class ArglistParameter 
 		// Doesn't have proper type because it's never chosen for better conversion
 		public ArglistParameter (Location loc) 
 			base (null, String.Empty, Parameter.Modifier.NONE, null, loc)
 		{
 			parameter_type = InternalType.Arglist;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="515" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2165" endline="2172">
<![CDATA[
 
 		/// <summary>
 		/// Method container contains Equals method
 		/// </summary>
 		public bool HasEquals {
 			get {
 				return (cached_method & CachedMethods.Equals) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="277" endline="283">
<![CDATA[
 
 		#region Properties
 
 		public bool IsReadOnly {
 			get {
 				return (Modifiers & Modifiers.READONLY) != 0;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="516" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2165" endline="2172">
<![CDATA[
 
 		/// <summary>
 		/// Method container contains Equals method
 		/// </summary>
 		public bool HasEquals {
 			get {
 				return (cached_method & CachedMethods.Equals) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="988" endline="997">
<![CDATA[
 		}
 
 		//
 		// Return true when this member is a generic in C# terms
 		// A nested non-generic type of generic type will return false
 		//
 		public bool IsGeneric {
 			get {
 				return (state & StateFlags.IsGeneric) != 0;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="517" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2165" endline="2172">
<![CDATA[
 
 		/// <summary>
 		/// Method container contains Equals method
 		/// </summary>
 		public bool HasEquals {
 			get {
 				return (cached_method & CachedMethods.Equals) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2173" endline="2181">
<![CDATA[
 		}
  
 		/// <summary>
 		/// Method container contains GetHashCode method
 		/// </summary>
 		public bool HasGetHashCode {
 			get {
 				return (cached_method & CachedMethods.GetHashCode) != 0;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="518" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2165" endline="2172">
<![CDATA[
 
 		/// <summary>
 		/// Method container contains Equals method
 		/// </summary>
 		public bool HasEquals {
 			get {
 				return (cached_method & CachedMethods.Equals) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2078" endline="2084">
<![CDATA[
 
 		#region Properties
 
 		public bool IsCompound {
 			get {
 				return (state & State.Compound) != 0;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="519" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2165" endline="2172">
<![CDATA[
 
 		/// <summary>
 		/// Method container contains Equals method
 		/// </summary>
 		public bool HasEquals {
 			get {
 				return (cached_method & CachedMethods.Equals) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="253" endline="259">
<![CDATA[
 		}
 
 		// When is virtual or abstract
 		public bool IsVirtual {
 			get {
 				return (Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE)) != 0;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="520" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2165" endline="2172">
<![CDATA[
 
 		/// <summary>
 		/// Method container contains Equals method
 		/// </summary>
 		public bool HasEquals {
 			get {
 				return (cached_method & CachedMethods.Equals) != 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2423" endline="2432">
<![CDATA[
 
 		#region Properties
 
 		//
 		// Block has been converted to expression tree
 		//
 		public bool IsExpressionTree {
 			get {
 				return (flags & Flags.IsExpressionTree) != 0;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="521" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="160" endline="166">
<![CDATA[
 
 		public FlowBranchingToplevel StartFlowBranching (ParametersBlock stmt, FlowBranching parent)
 		{
 			FlowBranchingToplevel branching = new FlowBranchingToplevel (parent, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="153" endline="159">
<![CDATA[
 
 		public FlowBranchingIterator StartFlowBranching (Iterator iterator, FlowBranching parent)
 		{
 			FlowBranchingIterator branching = new FlowBranchingIterator (parent, iterator);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="522" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="826" endline="835">
<![CDATA[
 
     ''' <summary>
     ''' Loads Me onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadMe(ByVal Info As EmitInfo, ByVal TypeOfMe As Mono.Cecil.TypeReference)
         TypeOfMe = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeOfMe)
         Info.ILGen.Emit(OpCodes.Ldarg_0)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="222" endline="228">
<![CDATA[
 
     Shared Sub EmitLE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Cgt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="523" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="826" endline="835">
<![CDATA[
 
     ''' <summary>
     ''' Loads Me onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadMe(ByVal Info As EmitInfo, ByVal TypeOfMe As Mono.Cecil.TypeReference)
         TypeOfMe = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeOfMe)
         Info.ILGen.Emit(OpCodes.Ldarg_0)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="192" endline="198">
<![CDATA[
 
     Shared Sub EmitNotEquals(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Ceq)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="524" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="826" endline="835">
<![CDATA[
 
     ''' <summary>
     ''' Loads Me onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadMe(ByVal Info As EmitInfo, ByVal TypeOfMe As Mono.Cecil.TypeReference)
         TypeOfMe = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeOfMe)
         Info.ILGen.Emit(OpCodes.Ldarg_0)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="199" endline="205">
<![CDATA[
 
     Shared Sub EmitGE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Clt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="525" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="26" endline="33">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="26" endline="33">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New PropertyAccessClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="526" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1613" endline="1623">
<![CDATA[
 	}
 
 	class ImportedGenericMethodDefinition 
 	{
 		readonly TypeParameterSpec[] tparams;
 
 		public ImportedGenericMethodDefinition (MethodInfo provider, TypeSpec type, AParametersCollection parameters, TypeParameterSpec[] tparams, MetadataImporter importer)
 			
 		{
 			this.tparams = tparams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="96" endline="110">
<![CDATA[
 
 	}
 
 	public class PropertySpec 
 	{
 		PropertyInfo info;
 		TypeSpec memberType;
 		MethodSpec set, get;
 
 		public PropertySpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition definition, TypeSpec memberType, PropertyInfo info, Modifiers modifiers)
 			
 		{
 			this.info = info;
 			this.memberType = memberType;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="527" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1613" endline="1623">
<![CDATA[
 	}
 
 	class ImportedGenericMethodDefinition 
 	{
 		readonly TypeParameterSpec[] tparams;
 
 		public ImportedGenericMethodDefinition (MethodInfo provider, TypeSpec type, AParametersCollection parameters, TypeParameterSpec[] tparams, MetadataImporter importer)
 			
 		{
 			this.tparams = tparams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="305" endline="320">
<![CDATA[
 	}
 
 	public class PredefinedType
 	{
 		string name;
 		string ns;
 		int arity;
 		MemberKind kind;
 		ModuleContainer module;
 		protected TypeSpec type;
 
 		public PredefinedType (ModuleContainer module, MemberKind kind, string ns, string name, int arity)
 			
 		{
 			this.arity = arity;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="528" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="36" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyClassExpression.vb" startline="31" endline="39">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="529" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3640" endline="3648">
<![CDATA[
 
     Shared Function GetPropertyAccess(ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetPropertyAttributes([Property])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3649" endline="3657">
<![CDATA[
 
     Shared Function GetEventAccess(ByVal [Event] As Mono.Cecil.EventReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetEventAttributes([Event])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="530" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="626" endline="632">
<![CDATA[
 
 		static public Expression Create (ResolveContext ec, MethodGroupExpr mge,
 						 TypeSpec target_type, Location loc)
 		{
 			ImplicitDelegateCreation d = new ImplicitDelegateCreation (target_type, mge, loc);
 			return d.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5782" endline="5788">
<![CDATA[
 		}
 
 		public static TemporaryVariableReference Create (TypeSpec type, Block block, Location loc)
 		{
 			var li = LocalVariable.CreateCompilerGenerated (type, block, loc);
 			return new TemporaryVariableReference (li, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="531" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1080" endline="1086">
<![CDATA[
 
     Public Shared Function GetSetMethod(ByVal Prop As PropertyReference) As MethodReference
         Dim pD As Mono.Cecil.PropertyDefinition = FindDefinition(Prop)
         Dim result As MethodReference = pD.SetMethod
         result = GetCorrectMember(result, Prop.DeclaringType)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="532" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1073" endline="1079">
<![CDATA[
 
     Public Shared Function GetGetMethod(ByVal Prop As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodReference
         Dim pD As Mono.Cecil.PropertyDefinition = FindDefinition(Prop)
         Dim result As MethodReference = pD.GetMethod
         result = GetCorrectMember(result, Prop.DeclaringType)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="533" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="850" endline="863">
<![CDATA[
 
     Shared Function GetDefaultGenericConstructor(ByVal closedResolvedType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim candidates As Mono.Collections.Generic.Collection(Of MethodDefinition)
 
         candidates = CecilHelper.FindDefinition(closedResolvedType).Methods
         result = GetDefaultConstructor(candidates)
 
         If result IsNot Nothing Then
             result = CecilHelper.GetCorrectMember(result, closedResolvedType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="534" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2802" endline="2815">
<![CDATA[
 
     Shared Function GetEnumType(ByVal Compiler As Compiler, ByVal EnumType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim tp As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(EnumType)
         Dim fInfo As Mono.Cecil.FieldReference
 
         Helper.Assert(Helper.IsEnum(Compiler, EnumType))
 
         tp = CecilHelper.FindDefinition(EnumType)
         fInfo = CecilHelper.FindField(tp.Fields, EnumDeclaration.EnumTypeMemberName)
 
         Helper.Assert(fInfo IsNot Nothing)
 
         Return fInfo.FieldType
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="535" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="169" endline="178">
<![CDATA[
 
     Shared Function GetDateConstant(ByVal Compiler As Compiler, ByVal Field As Mono.Cecil.FieldDefinition, ByRef value As Date) As Boolean
         Dim dtAttrs As Mono.Collections.Generic.Collection(Of CustomAttribute)
         dtAttrs = CecilHelper.GetCustomAttributes(Field.CustomAttributes, Compiler.TypeCache.System_Runtime_CompilerServices_DateTimeConstantAttribute)
         If dtAttrs IsNot Nothing AndAlso dtAttrs.Count = 1 Then
             value = DirectCast(dtAttrs(0).Properties(0).Argument.Value, Date)
             Return True
         End If
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="536" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="480" endline="504">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As FieldDefinition, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         Dim elementType As Mono.Cecil.TypeDefinition
         Dim fieldType As Mono.Cecil.TypeReference
 
         If genericType Is Nothing Then
             Return Member
         End If
 
         elementType = CecilHelper.FindDefinition(genericType.ElementType)
         fieldType = CecilHelper.ResolveType(Member.FieldType, elementType.GenericParameters, genericType.GenericArguments)
 
         'If fieldType IsNot Member.FieldType Then
         fieldType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, fieldType)
 
         result = New FieldReference(Member.Name, fieldType, Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, Member.DeclaringType))
         result.Annotations.Add("MemberInReflection", New FieldReference(Member.Name, Member.FieldType, genericType))
         Return result
         'Else
         '    Return Member
         'End If
 
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="537" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="349" endline="361">
<![CDATA[
 
     Shared Function GetGenericParameters(ByVal Member As MemberReference) As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim methodReference As MethodReference
         Dim typeReference As TypeReference
 
         methodReference = TryCast(Member, MethodReference)
         If methodReference IsNot Nothing Then Return CecilHelper.FindDefinition(methodReference).GenericParameters
 
         typeReference = TryCast(Member, TypeReference)
         If typeReference IsNot Nothing Then Return CecilHelper.FindDefinition(typeReference).GenericParameters
 
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="538" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1340" endline="1353">
<![CDATA[
 
     Shared Function GetDefaultMemberAttribute(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.CustomAttribute
         Dim attribs As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim attrib As Mono.Cecil.CustomAttribute = Nothing
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
 
         attribs = CecilHelper.GetCustomAttributes(tD, Compiler.TypeCache.System_Reflection_DefaultMemberAttribute)
 
         If attribs IsNot Nothing AndAlso attribs.Count = 1 Then
             attrib = attribs(0)
         End If
 
         Return attrib
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="539" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="59" endline="68">
<![CDATA[
 
     Public Shared Function GetMembers(ByVal Type As Mono.Cecil.GenericParameter) As Mono.Collections.Generic.Collection(Of MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of MemberReference)()
 
         For i As Integer = 0 To Type.Constraints.Count - 1
             AddRange(result, GetMembers(Type.Constraints(i)))
         Next
         AddRange(result, GetMembers(BaseObject.m_Compiler.TypeCache.System_Object))
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="540" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1792" endline="1805">
<![CDATA[
 
     Private Shared Function GetFieldRef(ByVal field As Mono.Cecil.FieldReference) As Mono.Cecil.FieldReference
         Dim gFD As Mono.Cecil.FieldDefinition = TryCast(field, Mono.Cecil.FieldDefinition)
 
         If gFD IsNot Nothing AndAlso gFD.DeclaringType.GenericParameters.Count > 0 Then
             Dim declType As Mono.Cecil.GenericInstanceType
             declType = New Mono.Cecil.GenericInstanceType(gFD.DeclaringType)
             For i As Integer = 0 To gFD.DeclaringType.GenericParameters.Count - 1
                 declType.GenericArguments.Add(gFD.DeclaringType.GenericParameters(i))
             Next
             Return New Mono.Cecil.FieldReference(field.Name, field.FieldType, declType)
         End If
         Return field
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="541" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="418" endline="445">
<![CDATA[
 
     ''' <summary>
     ''' Creates a closed method of an open generic method.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="OpenMethod"></param>
     ''' <param name="TypeParameters"></param>
     ''' <param name="TypeArguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function MakeGenericMethod(ByVal Parent As ParsedObject, ByVal OpenMethod As Mono.Cecil.MethodReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim genM As Mono.Cecil.GenericInstanceMethod
 
         result = CecilHelper.GetCorrectMember(OpenMethod, TypeArguments)
 
         If OpenMethod.GenericParameters.Count = 0 Then Return result
 
         Helper.Assert(OpenMethod.GenericParameters.Count = TypeArguments.Count)
 
         genM = New Mono.Cecil.GenericInstanceMethod(result)
         genM.OriginalMethod = CecilHelper.FindDefinition(OpenMethod)
         For i As Integer = 0 To OpenMethod.GenericParameters.Count - 1
             genM.GenericArguments.Add(Helper.GetTypeOrTypeReference(Parent.Compiler, TypeArguments(i)))
         Next
 
         Return genM
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="542" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2538" endline="2547">
<![CDATA[
 
     Shared Function GetFieldOrFieldReference(ByVal Compiler As Compiler, ByVal field As Mono.Cecil.FieldReference) As Mono.Cecil.FieldReference
         If field.Annotations.Contains("MemberInReflection") Then
             Return DirectCast(field.Annotations("MemberInReflection"), Mono.Cecil.FieldReference)
         ElseIf Compiler.AssemblyBuilderCecil Is field.DeclaringType.Module.Assembly Then
             Return field
         Else
             Return Compiler.AssemblyBuilderCecil.MainModule.Import(field)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="543" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="746" endline="753">
<![CDATA[
 
     Public Shared Function GetNestedType(ByVal Type As TypeReference, ByVal Name As String) As TypeReference
         Dim tD As TypeDefinition = FindDefinition(Type)
         For i As Integer = 0 To tD.NestedTypes.Count - 1
             If Helper.CompareName(tD.NestedTypes(i).Name, Name) Then Return tD.NestedTypes(i)
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="544" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="196" endline="215">
<![CDATA[
 
     Shared Function GetSetMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         Dim methodtypes As Mono.Cecil.TypeReference() = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, ranks + 1)
 
         methodtypes(ranks) = elementType
 
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Set", ArrayType, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void), True, False, Mono.Cecil.MethodCallingConvention.Default)
 
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
         result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, elementType)))
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="545" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="137" endline="157">
<![CDATA[
 
 
     Public Shared Function GetCorrectMember(ByVal Member As TypeReference, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim tD As Mono.Cecil.TypeDefinition = TryCast(Member, Mono.Cecil.TypeDefinition)
 
         If tD IsNot Nothing Then Return GetCorrectMember(tD, Type)
 
         Dim tG As Mono.Cecil.GenericInstanceType = TryCast(Member, Mono.Cecil.GenericInstanceType)
         If tG IsNot Nothing Then
             tD = TryCast(tG.ElementType, Mono.Cecil.TypeDefinition)
             If tD IsNot Nothing Then
                 Helper.Assert(tG.GenericParameters.Count = 0)
                 Return GetCorrectMember(tD, Type)
             End If
         End If
 
         tD = FindDefinition(Member)
         Return GetCorrectMember(tD, Type)
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="546" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="313" endline="333">
<![CDATA[
 
     Shared Function FindAssembly(ByVal type As Mono.Cecil.TypeReference) As Mono.Cecil.AssemblyDefinition
         Helper.Assert(type IsNot Nothing)
 
         While type.DeclaringType IsNot Nothing
             If type.Module IsNot Nothing AndAlso type.Module.Assembly IsNot Nothing Then Return type.Module.Assembly
             type = type.DeclaringType
         End While
         While type.DeclaringType IsNot Nothing
             If type.Module IsNot Nothing AndAlso type.Module.Assembly IsNot Nothing Then Return type.Module.Assembly
             type = type.DeclaringType
         End While
         Dim tS As Mono.Cecil.TypeSpecification = TryCast(type, Mono.Cecil.TypeSpecification)
         While tS IsNot Nothing
             type = tS.ElementType
             tS = TryCast(type, Mono.Cecil.TypeSpecification)
         End While
         While tS IsNot Nothing
             type = tS.ElementType
             tS = TryCast(type, Mono.Cecil.TypeSpecification)
         End While
         'Helper.Assert(type IsNot Nothing AndAlso type.[Module] IsNot Nothing)
 
         If type Is Nothing OrElse type.Module Is Nothing Then
             Return Nothing
         Else
             Return type.Module.Assembly
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="547" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="195" endline="225">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As PropertyDefinition, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.PropertyReference
         Dim result As Mono.Cecil.PropertyDefinition
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         Dim propertyType As Mono.Cecil.TypeReference
         Dim getMethod As Mono.Cecil.MethodReference = Nothing
         Dim setMethod As Mono.Cecil.MethodReference = Nothing
 
         If genericType Is Nothing Then Return Member
 
         propertyType = CecilHelper.ResolveType(Member.PropertyType, Member.DeclaringType.GenericParameters, genericType.GenericArguments)
         propertyType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, propertyType)
 
         If Member.GetMethod IsNot Nothing Then
             getMethod = GetCorrectMember(Member.GetMethod, Type)
         End If
 
         If Member.SetMethod IsNot Nothing Then
             setMethod = GetCorrectMember(Member.SetMethod, Type)
         End If
 
         'If propertyType Is Member.PropertyType AndAlso (getMethod Is Nothing OrElse Member.GetMethod Is getMethod) AndAlso (setMethod Is Nothing OrElse Member.SetMethod Is setMethod) Then
         'Return Member
         'End If
         result = New Mono.Cecil.PropertyDefinition(Member.Name, Member.Attributes, propertyType)
         result.DeclaringType = genericType
         result.SetMethod = setMethod
         result.GetMethod = getMethod
         result.Annotations.Add("OriginalProperty", Member)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="548" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="80" endline="96">
<![CDATA[
 
     Shared Function Clone(ByVal Builder As Mono.Cecil.GenericParameter, ByVal Owner As Mono.Cecil.IGenericParameterProvider, ByVal Position As Integer) As Mono.Cecil.GenericParameter
         Dim result As New Mono.Cecil.GenericParameter(Builder.Name, Owner)
 
         For i As Integer = 0 To Builder.Constraints.Count - 1
             result.Constraints.Add(Builder.Constraints(i))
         Next
 
         result.HasDefaultConstructorConstraint = Builder.HasDefaultConstructorConstraint
         result.HasNotNullableValueTypeConstraint = Builder.HasNotNullableValueTypeConstraint
         result.HasReferenceTypeConstraint = Builder.HasReferenceTypeConstraint
         result.IsContravariant = Builder.IsContravariant
         result.IsCovariant = Builder.IsCovariant
         result.IsNonVariant = Builder.IsNonVariant
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="549" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="724" endline="733">
<![CDATA[
 
     Public Shared Function GetAssemblyRef(ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.AssemblyNameReference
         Dim modDef As ModuleDefinition = TryCast(Type.Scope, ModuleDefinition)
         If modDef IsNot Nothing Then Return modDef.Assembly.Name
 
         Dim assemblyRef As Mono.Cecil.AssemblyNameReference = TryCast(Type.Scope, AssemblyNameReference)
         If assemblyRef IsNot Nothing Then Return assemblyRef
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="550" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="410" endline="417">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2778" endline="2791">
<![CDATA[
 
     Shared Function IsSubclassOf(ByVal BaseClass As Mono.Cecil.TypeReference, ByVal DerivedClass As Mono.Cecil.TypeReference) As Boolean
         If TypeOf BaseClass Is Mono.Cecil.GenericParameter Xor TypeOf DerivedClass Is Mono.Cecil.GenericParameter Then Return False
         If TypeOf BaseClass Is Mono.Cecil.ArrayType Or TypeOf DerivedClass Is Mono.Cecil.ArrayType Then Return False
         Dim base As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(BaseClass)
         Dim derived As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(DerivedClass)
         Dim current As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(derived.BaseType)
 
         Do While current IsNot Nothing
             If Helper.CompareType(current, base) Then Return True
             current = CecilHelper.FindDefinition(CecilHelper.FindDefinition(current).BaseType)
         Loop
         Do While current IsNot Nothing
             If Helper.CompareType(current, base) Then Return True
             current = CecilHelper.FindDefinition(CecilHelper.FindDefinition(current).BaseType)
         Loop
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="551" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="310" endline="316">
<![CDATA[
 
 		public void BeginFaultBlock()
 		{
 			ExceptionBlock block = BeginFinallyFilterFaultBlock();
 			block.handlerOffset = code.Position;
 			block.exceptionType = FAULT;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="303" endline="309">
<![CDATA[
 
 		public void BeginExceptFilterBlock()
 		{
 			ExceptionBlock block = BeginFinallyFilterFaultBlock();
 			block.filterOffset = code.Position;
 			UpdateStack(1);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="552" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="310" endline="316">
<![CDATA[
 
 		public void BeginFaultBlock()
 		{
 			ExceptionBlock block = BeginFinallyFilterFaultBlock();
 			block.handlerOffset = code.Position;
 			block.exceptionType = FAULT;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="387" endline="394">
<![CDATA[
 
 		public void UsingNamespace(string usingNamespace)
 		{
 			if (moduleBuilder.symbolWriter != null)
 			{
 				moduleBuilder.symbolWriter.UsingNamespace(usingNamespace);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="553" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="84" endline="90">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal EventInfo As Mono.Cecil.EventReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.new(Classifications.EventAccess, Parent)
         m_EventInfo = EventInfo
         m_InstanceExpression = InstanceExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="169" endline="176">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Property] As Mono.Cecil.PropertyReference, ByVal InstanceExpression As Expression, ByVal Parameters As ArgumentList)
         MyBase.New(Classifications.PropertyAccess, Parent)
         m_Property = [Property]
         m_InstanceExpression = InstanceExpression
         m_Parameters = Parameters
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="554" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" startline="84" endline="90">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal EventInfo As Mono.Cecil.EventReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.new(Classifications.EventAccess, Parent)
         m_EventInfo = EventInfo
         m_InstanceExpression = InstanceExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="58" endline="65">
<![CDATA[
 
     Shadows Sub Init(ByVal Variable As Identifier, ByVal TypeName As NonArrayTypeName, ByVal [When] As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_Variable = Variable
         m_TypeName = TypeName
         m_When = [When]
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="555" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="155" endline="161">
<![CDATA[
 
 		public static void DefineCapturedLocal (int scope_id, string name,
 							string captured_name)
 		{
 			if (symwriter != null)
 				symwriter.DefineCapturedLocal (scope_id, name, captured_name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="162" endline="168">
<![CDATA[
 
 		public static void DefineCapturedParameter (int scope_id, string name,
 							    string captured_name)
 		{
 			if (symwriter != null)
 				symwriter.DefineCapturedParameter (scope_id, name, captured_name);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="556" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="141" endline="147">
<![CDATA[
 
 		public void __SetAssemblyCulture(string cultureName)
 		{
 			AssemblyName oldName = GetName();
 			this.culture = cultureName;
 			universe.RenameAssembly(this, oldName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="159" endline="166">
<![CDATA[
 
 		// this is used in combination with delay signing
 		public void __SetAssemblyPublicKey(byte[] publicKey)
 		{
 			AssemblyName oldName = GetName();
 			this.publicKey = publicKey == null ? null 
 			universe.RenameAssembly(this, oldName);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="557" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1060" endline="1070">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Ldobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1049" endline="1059">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Stobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitStoreObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Stobj, ElementType)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="558" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1060" endline="1070">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Ldobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1901" endline="1911">
<![CDATA[
 
     ''' <summary>
     ''' Emits a box instruction, no checks are done.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitBox(ByVal Info As EmitInfo, ByVal SourceType As Mono.Cecil.TypeReference)
         Dim OriginalDestinationType As Mono.Cecil.TypeReference = SourceType
         SourceType = Helper.GetTypeOrTypeBuilder(Info.Compiler, SourceType)
         Info.ILGen.Emit(OpCodes.Box, SourceType)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="559" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1060" endline="1070">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Ldobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="885" endline="893">
<![CDATA[
 
 
     Shared Sub EmitConstrained(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference)
         Dim OriginalType As Mono.Cecil.TypeReference = Type
 
         Type = Helper.GetTypeOrTypeBuilder(Info.Compiler, Type)
 
         Info.ILGen.Emit(OpCodes.Constrained, Type)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="560" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1060" endline="1070">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Ldobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1596" endline="1610">
<![CDATA[
 
     ''' <summary>
     ''' Loads the address of the parameter.
     ''' Just loads the value if it is a byref parameter.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Variable"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.ParameterDefinition)
         If CecilHelper.IsByRef(Variable.ParameterType) Then
             EmitLoadParameter(Info, Variable)
         Else
             Info.ILGen.Emit(OpCodes.Ldarga, CShort(GetParameterPosition(Info, Variable)))
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="561" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="134" endline="141">
<![CDATA[
 		}
 
 		private uint MetadataRVA
 		{
 			get
 			{
 				return (StrongNameSignatureRVA + StrongNameSignatureLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="118" endline="125">
<![CDATA[
 		}
 
 		internal uint StrongNameSignatureRVA
 		{
 			get
 			{
 				return (ResourcesRVA + ResourcesLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="562" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2637" endline="2645">
<![CDATA[
 
     Private Function ParseMeExpression(ByVal Parent As ParsedObject) As MeExpression
         Dim result As MeExpression
 
         tm.AcceptIfNotInternalError(KS.Me)
         result = New MeExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2619" endline="2627">
<![CDATA[
 
     Private Function ParseMyClassExpression(ByVal Parent As ParsedObject) As MyClassExpression
         Dim result As MyClassExpression
 
         tm.AcceptIfNotInternalError(KS.MyClass)
         result = New MyClassExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="563" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2637" endline="2645">
<![CDATA[
 
     Private Function ParseMeExpression(ByVal Parent As ParsedObject) As MeExpression
         Dim result As MeExpression
 
         tm.AcceptIfNotInternalError(KS.Me)
         result = New MeExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2628" endline="2636">
<![CDATA[
 
     Private Function ParseMyBaseExpression(ByVal Parent As ParsedObject) As MyBaseExpression
         Dim result As MyBaseExpression
 
         tm.AcceptIfNotInternalError(KS.MyBase)
         result = New MyBaseExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="564" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="253" endline="260">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="270" endline="277">
<![CDATA[
 
     ''' <summary>
     ''' Shows the multiline message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message() As Messages, ByVal Location As Span, ByVal ParamArray Parameters()() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="565" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="253" endline="260">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" startline="278" endline="285">
<![CDATA[
 
     ''' <summary>
     ''' Saves the message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function SaveMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(True, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="566" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5093" endline="5099">
<![CDATA[
 
 		#region Properties
 
 		public Expression Expression {
 			get {
 				return decl.Variable == null ? decl.Initializer 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="206" endline="213">
<![CDATA[
 
 		public LocalBuilder DeclareLocal (TypeSpec type, bool pinned)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				type = CurrentAnonymousMethod.Storey.Mutator.Mutate (type);
 
 			return ig.DeclareLocal (type.GetMetaInfo (), pinned);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="567" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5093" endline="5099">
<![CDATA[
 
 		#region Properties
 
 		public Expression Expression {
 			get {
 				return decl.Variable == null ? decl.Initializer 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="277" endline="284">
<![CDATA[
 
 		public void Emit (OpCode opcode, FieldSpec field)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				field = field.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 			ig.Emit (opcode, field.GetMetaInfo ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="568" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5093" endline="5099">
<![CDATA[
 
 		#region Properties
 
 		public Expression Expression {
 			get {
 				return decl.Variable == null ? decl.Initializer 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="269" endline="276">
<![CDATA[
 
 		public void Emit (OpCode opcode, TypeSpec type)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				type = CurrentAnonymousMethod.Storey.Mutator.Mutate (type);
 
 			ig.Emit (opcode, type.GetMetaInfo ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="569" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\StopStatement.vb" startline="30" endline="38">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ' Helper.NotImplemented()
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Diagnostics_Debugger__Break)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EndStatement.vb" startline="34" endline="41">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__EndApp)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="570" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="71" endline="83">
<![CDATA[
 
 		//
 		// This routine must be overrided in derived classes and make copies
 		// of all the data that might be modified if resolved
 		// 
 		protected abstract void CloneTo (CloneContext clonectx, Statement target);
 
 		public Statement Clone (CloneContext clonectx)
 		{
 			Statement s = (Statement) this.MemberwiseClone ();
 			CloneTo (clonectx, s);
 			return s;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1034" endline="1040">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var tps = (TypeParameterSpec) MemberwiseClone ();
 			InflateConstraints (inflator, tps);
 			return tps;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="571" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="71" endline="83">
<![CDATA[
 
 		//
 		// This routine must be overrided in derived classes and make copies
 		// of all the data that might be modified if resolved
 		// 
 		protected abstract void CloneTo (CloneContext clonectx, Statement target);
 
 		public Statement Clone (CloneContext clonectx)
 		{
 			Statement s = (Statement) this.MemberwiseClone ();
 			CloneTo (clonectx, s);
 			return s;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="906" endline="927">
<![CDATA[
 				String.Format (
 					"CloneTo not implemented for expression {0}", this.GetType ()));
 		}
 
 		//
 		// Clones an expression created by the parser.
 		//
 		// We only support expressions created by the parser so far, not
 		// expressions that have been resolved (many more classes would need
 		// to implement CloneTo).
 		//
 		// This infrastructure is here merely for Lambda expressions which
 		// compile the same code using different type values for the same
 		// arguments to find the correct overload
 		//
 		public virtual Expression Clone (CloneContext clonectx)
 		{
 			Expression cloned = (Expression) MemberwiseClone ();
 			CloneTo (clonectx, cloned);
 
 			return cloned;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="572" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4781" endline="4787">
<![CDATA[
 		}
 
 		public bool IsHoisted {
 			get {
 				IVariableReference hv = InstanceExpression as IVariableReference;
 				return hv != null && hv.IsHoisted;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4834" endline="4840">
<![CDATA[
 
 		public void SetHasAddressTaken ()
 		{
 			IVariableReference vr = InstanceExpression as IVariableReference;
 			if (vr != null)
 				vr.SetHasAddressTaken ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="573" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4781" endline="4787">
<![CDATA[
 		}
 
 		public bool IsHoisted {
 			get {
 				IVariableReference hv = InstanceExpression as IVariableReference;
 				return hv != null && hv.IsHoisted;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1146" endline="1153">
<![CDATA[
 
 		public TypeSpec GetArgumentType ()
 		{
 			TypeOf e = GetValue () as TypeOf;
 			if (e == null)
 				return null;
 			return e.TypeArgument;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="574" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="61" endline="80">
<![CDATA[
 		}
 	}
 
 	//
 	// A set of parsed constraints for a type parameter
 	//
 	public class Constraints
 	{
 		SimpleMemberName tparam;
 		List<FullNamedExpression> constraints;
 		Location loc;
 		bool resolved;
 		bool resolving;
 		
 		public Constraints (SimpleMemberName tparam, List<FullNamedExpression> constraints, Location loc)
 		{
 			this.tparam = tparam;
 			this.constraints = constraints;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="91" endline="101">
<![CDATA[
 		public EmitContext (IMemberContext rc, ILGenerator ig, TypeSpec return_type)
 		{
 			this.MemberContext = rc;
 			this.ig = ig;
 
 			this.return_type = return_type;
 
 #if STATIC
 			ig.__CleverExceptionBlockAssistance ();
 #endif
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="575" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="107" endline="115">
<![CDATA[
 End Class
 
 Public Class ValueOnStackExpression
     Inherits CompilerGeneratedExpression
 
     Sub New(ByVal Parent As ParsedObject, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.New(Parent, Nothing, ExpressionType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="51" endline="57">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
         If Arguments IsNot Nothing Then
             m_Arguments.AddRange(Arguments)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="576" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="107" endline="115">
<![CDATA[
 End Class
 
 Public Class ValueOnStackExpression
     Inherits CompilerGeneratedExpression
 
     Sub New(ByVal Parent As ParsedObject, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.New(Parent, Nothing, ExpressionType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1335" endline="1345">
<![CDATA[
 
     Private Function ParseBuiltinTypeName(ByVal Parent As ParsedObject) As BuiltInTypeName
         Dim m_Typename As KS
 
         If vbnc.BuiltInTypeName.IsBuiltInTypeName(tm) = False Then Throw New InternalException(Parent)
 
         m_Typename = tm.CurrentToken.Keyword
         tm.NextToken()
 
         Return New BuiltInTypeName(Parent, m_Typename)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="577" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="107" endline="115">
<![CDATA[
 End Class
 
 Public Class ValueOnStackExpression
     Inherits CompilerGeneratedExpression
 
     Sub New(ByVal Parent As ParsedObject, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.New(Parent, Nothing, ExpressionType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="31" endline="37">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal CodeGenerator As GenerateCodeDelegate, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         m_Delegate = CodeGenerator
         m_ExpressionType = ExpressionType
         MyBase.Classification = New ValueClassification(Me)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="578" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1593" endline="1603">
<![CDATA[
 	}
 
 	public class IndexerSpec 
 	{
 		AParametersCollection parameters;
 
 		public IndexerSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec memberType, AParametersCollection parameters, PropertyInfo info, Modifiers modifiers)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="139" endline="267">
<![CDATA[
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE;
 
 		public Enum (NamespaceEntry ns, DeclSpace parent, TypeExpression type,
 			     Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			base_type_expr = type;
 			var accmods = IsTopLevel ? Modifiers.INTERNAL 
 			ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod_flags, accmods, Location, Report);
 			spec = new EnumSpec (null, this, null, null, ModFlags);
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Enum;
 			}
 		}
 
 		public TypeExpr BaseTypeExpression {
 			get {
 				return base_type_expr;
 			}
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed | base.TypeAttr;
 			}
 		}
 
 		public TypeSpec UnderlyingType {
 			get {
 				return ((EnumSpec) spec).UnderlyingType;
 			}
 		}
 
 		#endregion
 
 		public void AddEnumMember (EnumMember em)
 		{
 			if (em.Name == UnderlyingValueField) {
 				Report.Error (76, em.Location, "An item in an enumeration cannot have an identifier `{0}'",
 					UnderlyingValueField);
 				return;
 			}
 
 			AddConstant (em);
 		}
 
 		public static void Error_1008 (Location loc, Report Report)
 		{
 			Report.Error (1008, loc,
 				"Type byte, sbyte, short, ushort, int, uint, long or ulong expected");
 		}
 
 		protected override bool DefineNestedTypes ()
 		{
 			((EnumSpec) spec).UnderlyingType = base_type_expr == null ? TypeManager.int32_type 
 
 			TypeBuilder.DefineField (UnderlyingValueField, UnderlyingType.GetMetaInfo (),
 				FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
 
 			if (!RootContext.StdLib)
 				Module.hack_corlib_enums.Add (this);
 
 			return true;
 		}
 
 		protected override bool DoDefineMembers ()
 		{
 			if (constants != null) {
 				for (int i = 0; i < constants.Count; ++i) {
 					EnumMember em = (EnumMember) constants [i];
 					if (em.Initializer == null) {
 						em.Initializer = new ImplicitInitializer (em, i == 0 ? null 
 					}
 
 					em.Define ();
 				}
 			}
 
 			return true;
 		}
 
 		public override bool IsUnmanagedType ()
 		{
 			return true;
 		}
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.enum_type;
 			base_class = base_type_expr;
 			return null;
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (UnderlyingType == TypeManager.uint32_type ||
 				UnderlyingType == TypeManager.uint64_type ||
 				UnderlyingType == TypeManager.ushort_type) {
 				Report.Warning (3009, 1, Location, "`{0}'
 			}
 
 			return true;
 		}	
 	}
 
 	class EnumSpec 
 	{
 		TypeSpec underlying;
 
 		public EnumSpec (TypeSpec declaringType, ITypeDefinition definition, TypeSpec underlyingType, MetaType info, Modifiers modifiers)
 			
 		{
 			this.underlying = underlyingType;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="579" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="117" endline="123">
<![CDATA[
 
     Sub Init(ByVal IsAssembly As Boolean, ByVal IsModule As Boolean, ByVal SimpleTypeName As SimpleTypeName, ByVal AttributeArguments As AttributeArguments)
         m_IsAssembly = IsAssembly
         m_IsModule = IsModule
         m_SimpleTypeName = SimpleTypeName
         m_AttributeArguments = AttributeArguments
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="76" endline="82">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier, ByVal TypeName As TypeName, ByVal Expression As Expression)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
         m_TypeName = TypeName
         m_Expression = Expression
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="580" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="117" endline="123">
<![CDATA[
 
     Sub Init(ByVal IsAssembly As Boolean, ByVal IsModule As Boolean, ByVal SimpleTypeName As SimpleTypeName, ByVal AttributeArguments As AttributeArguments)
         m_IsAssembly = IsAssembly
         m_IsModule = IsModule
         m_SimpleTypeName = SimpleTypeName
         m_AttributeArguments = AttributeArguments
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Resource.vb" startline="64" endline="73">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a new resource with the specified values.
     ''' </summary>
     Sub New(ByVal Filename As String, ByVal Identifier As String, Optional ByVal [Public] As Boolean = True)
         Me.m_Filename = Filename
         Me.m_Identifier = Identifier
         Me.m_Public = [Public]
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="581" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="117" endline="123">
<![CDATA[
 
     Sub Init(ByVal IsAssembly As Boolean, ByVal IsModule As Boolean, ByVal SimpleTypeName As SimpleTypeName, ByVal AttributeArguments As AttributeArguments)
         m_IsAssembly = IsAssembly
         m_IsModule = IsModule
         m_SimpleTypeName = SimpleTypeName
         m_AttributeArguments = AttributeArguments
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="60" endline="67">
<![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal InExpression As Expression, ByVal NextExpression As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_InExpression = InExpression
         m_NextExpression = NextExpression
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="582" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="202" endline="213">
<![CDATA[
 	}
 
 	sealed class UserStringHeap 
 	{
 		private List<string> list = new List<string>();
 		private Dictionary<string, int> strings = new Dictionary<string, int>();
 		private int nextOffset;
 
 		internal UserStringHeap()
 		{
 			nextOffset = 1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="162" endline="173">
<![CDATA[
 	}
 
 	sealed class StringHeap 
 	{
 		private List<string> list = new List<string>();
 		private Dictionary<string, int> strings = new Dictionary<string, int>();
 		private int nextOffset;
 
 		internal StringHeap()
 		{
 			Add("");
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="583" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="384" endline="390">
<![CDATA[
 
 		public override Type[] GetRequiredCustomModifiers()
 		{
 			Type[] modifiers = parameterInfo.GetRequiredCustomModifiers();
 			Type.InplaceBindTypeParameters(method, modifiers);
 			return modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="376" endline="383">
<![CDATA[
 		}
 
 		public override Type[] GetOptionalCustomModifiers()
 		{
 			Type[] modifiers = parameterInfo.GetOptionalCustomModifiers();
 			Type.InplaceBindTypeParameters(method, modifiers);
 			return modifiers;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="584" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="384" endline="390">
<![CDATA[
 
 		public override Type[] GetRequiredCustomModifiers()
 		{
 			Type[] modifiers = parameterInfo.GetRequiredCustomModifiers();
 			Type.InplaceBindTypeParameters(method, modifiers);
 			return modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="387" endline="399">
<![CDATA[
 
 		public abstract AssemblyName[] __GetReferencedAssemblies();
 
 		internal Type CanonicalizeType(Type type)
 		{
 			Type canon;
 			if (!universe.canonicalizedTypes.TryGetValue(type, out canon))
 			{
 				canon = type;
 				universe.canonicalizedTypes.Add(canon, canon);
 			}
 			return canon;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="585" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="384" endline="390">
<![CDATA[
 
 		public override Type[] GetRequiredCustomModifiers()
 		{
 			Type[] modifiers = parameterInfo.GetRequiredCustomModifiers();
 			Type.InplaceBindTypeParameters(method, modifiers);
 			return modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="89" endline="99">
<![CDATA[
 
 		internal Module ToModule(Assembly assembly)
 		{
 			if (module.Assembly != null)
 			{
 				throw new InvalidOperationException();
 			}
 			imported = true;
 			module.SetAssembly(assembly);
 			return module;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="586" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="169" endline="175">
<![CDATA[
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed | base.TypeAttr;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="328" endline="334">
<![CDATA[
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed |
 					base.TypeAttr;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="587" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3498" endline="3506">
<![CDATA[
 
     Shared Function IsFirstLessGeneric(ByVal Context As BaseObject) As Boolean
         'A member M is determined to be less generic than a member N using the following steps
         '-	If M has fewer method type parameters than N, then M is less generic than N.
         '-	Otherwise, if for each pair of matching parameters Mj and Nj, Mj and Nj are equally generic with respect to type parameters on the method, or Mj is less generic with respect to type parameters on the method, and at least one Mj is less generic than Nj, then M is less generic than N.
         '-	Otherwise, if for each pair of matching parameters Mj and Nj, Mj and Nj are equally generic with respect to type parameters on the type, or Mj is less generic with respect to type parameters on the type, and at least one Mj is less generic than Nj, then M is less generic than N.
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="588" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1071" endline="1082">
<![CDATA[
     ''' <summary>
     ''' Creates a new array and the new array reference is loaded at the top of the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <param name="Elements"></param>
     ''' <remarks></remarks>
     Shared Sub CreateArray(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference, ByVal Elements As Integer)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         EmitLoadValue(Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32), Elements)
         EmitNewArr(Info, ElementType)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="589" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4778" endline="4794">
<![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseTypeVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As Generic.List(Of TypeVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseTypeVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="590" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4795" endline="4811">
<![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseLocalVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="591" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2968" endline="2976">
<![CDATA[
 
     <Obsolete()> Private Function ParseExpression() As Expression
         Dim result As Expression = Nothing
 
         Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         '        result = ParseOr_OrElse_Xor(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="592" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4762" endline="4777">
<![CDATA[
 
     ''' <summary>
     ''' LocalDeclarationStatement  
     ''' </summary>
     Private Function ParseLocalDeclarationStatement(ByVal Parent As CodeBlock) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.LocalModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_Modifiers, New ParseAttributableInfo(Compiler, Nothing))
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="593" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2044" endline="2058">
<![CDATA[
 
     Private Function ParseCDblExpression(ByVal Parent As ParsedObject) As CDblExpression
         Dim result As New CDblExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDbl)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="594" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2074" endline="2088">
<![CDATA[
 
     Private Function ParseCIntExpression(ByVal Parent As ParsedObject) As CIntExpression
         Dim result As New CIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="595" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2089" endline="2103">
<![CDATA[
 
     Private Function ParseCLngExpression(ByVal Parent As ParsedObject) As CLngExpression
         Dim result As New CLngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CLng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="596" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2104" endline="2118">
<![CDATA[
 
     Private Function ParseCObjExpression(ByVal Parent As ParsedObject) As CObjExpression
         Dim result As New CObjExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CObj)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="597" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2119" endline="2133">
<![CDATA[
 
     Private Function ParseCSByteExpression(ByVal Parent As ParsedObject) As CSByteExpression
         Dim result As New CSByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="598" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2134" endline="2148">
<![CDATA[
 
     Private Function ParseCShortExpression(ByVal Parent As ParsedObject) As CShortExpression
         Dim result As New CShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="599" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2149" endline="2163">
<![CDATA[
 
     Private Function ParseCSngExpression(ByVal Parent As ParsedObject) As CSngExpression
         Dim result As New CSngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="600" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2164" endline="2178">
<![CDATA[
 
     Private Function ParseCStrExpression(ByVal Parent As ParsedObject) As CStrExpression
         Dim result As New CStrExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CStr)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="601" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2179" endline="2193">
<![CDATA[
 
     Private Function ParseCUIntExpression(ByVal Parent As ParsedObject) As CUIntExpression
         Dim result As New CUIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="602" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2194" endline="2208">
<![CDATA[
 
     Private Function ParseCULngExpression(ByVal Parent As ParsedObject) As CULngExpression
         Dim result As New CULngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CULng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="603" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2014" endline="2028">
<![CDATA[
 
     Private Function ParseCCharExpression(ByVal Parent As ParsedObject) As CCharExpression
         Dim result As New CCharExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CChar)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="604" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2029" endline="2043">
<![CDATA[
 
     Private Function ParseCDateExpression(ByVal Parent As ParsedObject) As CDateExpression
         Dim result As New CDateExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDate)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="605" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1985" endline="1998">
<![CDATA[
 
     Private Function ParseCByteExpression(ByVal Parent As ParsedObject) As CByteExpression
         Dim result As New CByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="606" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1999" endline="2013">
<![CDATA[
 
     Private Function ParseCBoolExpression(ByVal Parent As ParsedObject) As CBoolExpression
         Dim result As New CBoolExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CBool)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="607" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2059" endline="2073">
<![CDATA[
 
     Private Function ParseCDecExpression(ByVal Parent As ParsedObject) As CDecExpression
         Dim result As New CDecExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDec)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="608" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2209" endline="2223">
<![CDATA[
 
     Private Function ParseCUShortExpression(ByVal Parent As ParsedObject) As CUShortExpression
         Dim result As New CUShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="609" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1322" endline="1334">
<![CDATA[
 
     Private Function ParseIdentifier(ByVal Parent As ParsedObject) As Identifier
         Dim result As Identifier
 
         If tm.CurrentToken.IsIdentifier Then
             result = New Identifier(Parent, tm.CurrentToken.Identifier, tm.CurrentLocation, tm.CurrentTypeCharacter)
             tm.NextToken()
         Else
             result = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="610" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4081" endline="4093">
<![CDATA[
 
     Private Function ParseConstantDeclarations(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal Modifiers As Modifiers) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Do
             Dim newCD As ConstantDeclaration = Nothing
             newCD = ParseConstantDeclaration(Parent, New ParseAttributableInfo(Parent.Compiler, Attributes), Modifiers)
             If newCD Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Add(newCD)
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="611" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5110" endline="5129">
<![CDATA[
 
 
     ''' <summary>
     ''' GotoStatement  
     ''' LabelName 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseGotoStatement(ByVal Parent As ParsedObject) As GotoStatement
         Dim m_GotoWhere As Token
 
         tm.AcceptIfNotInternalError(KS.GoTo)
         If tm.CurrentToken.IsIdentifier OrElse tm.CurrentToken.IsIntegerLiteral Then
             m_GotoWhere = tm.CurrentToken
             tm.NextToken()
         Else
             Return Nothing
         End If
 
         Return New GotoStatement(Parent, m_GotoWhere)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="612" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4705" endline="4728">
<![CDATA[
 
     ''' <summary>
     ''' LibraryClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLibraryClause(ByVal Parent As ParsedObject) As LibraryClause
         Dim result As New LibraryClause(Parent)
 
         Dim m_StringLiteral As Token
 
         tm.AcceptIfNotInternalError(KS.Lib)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             m_StringLiteral = Nothing
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="613" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4529" endline="4554">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceFunctionDeclaration  
     '''	[  Attributes  ]  [  InterfaceProcedureModifier+  ] "Function" FunctionSignature  StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceFunctionDeclaration
         Dim result As New InterfaceFunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Signature = ParseFunctionSignature(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="614" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4682" endline="4704">
<![CDATA[
 
     ''' <summary>
     ''' AliasClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAliasClause(ByVal Parent As ParsedObject) As AliasClause
         Dim result As New AliasClause(Parent)
 
         Dim m_StringLiteral As Token = Nothing
 
         tm.AcceptIfNotInternalError(KS.Alias)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="615" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="45" endline="57">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SimpleTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SimpleTypeName(NewParent)
         If Me.IsBuiltInTypeName Then
             result.Init(Me.AsBuiltInTypeName.Clone(result))
         ElseIf Me.IsQualifiedIdentifier Then
             result.Init(Me.AsQualifiedIdentifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="616" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6083" endline="6103">
<![CDATA[
 
     ''' <summary>
     ''' ImportsStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsStatement(ByVal Parent As ParsedObject) As ImportsStatement
         Dim result As New ImportsStatement(Parent)
 
         Dim m_Clauses As ImportsClauses
 
         tm.AcceptIfNotInternalError(KS.Imports)
 
         m_Clauses = ParseImportsClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="617" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2322" endline="2344">
<![CDATA[
 
     ''' <summary>
     ''' ParenthesizedExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParenthesizedExpression(ByVal Parent As ParsedObject) As ParenthesizedExpression
         Dim result As New ParenthesizedExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_Expression = ParseExpression(result)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="618" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2993" endline="3012">
<![CDATA[
     ''' <summary>
     ''' GetTypeExpression 
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseGetTypeExpression(ByVal Parent As ParsedObject) As GetTypeExpression
         Dim result As New GetTypeExpression(Parent)
 
         tm.AcceptIfNotInternalError(KS.GetType)
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Dim m_TypeName As GetTypeTypeName
         m_TypeName = ParseGetTypeTypeName(result)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="619" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5159" endline="5182">
<![CDATA[
 
     ''' <summary>
     '''ContinueStatement  
     '''ContinueKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseContinueStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ContinueStatement
         Dim result As New ContinueStatement(Parent)
 
         Dim m_ContinueWhat As KS
 
         tm.AcceptIfNotInternalError(KS.Continue)
         If tm.CurrentToken.Equals(KS.Do, KS.For, KS.While) Then
             m_ContinueWhat = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30781, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_ContinueWhat)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="620" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4059" endline="4080">
<![CDATA[
 
     ''' <summary>
     ''' ConstantMemberDeclaration  
     ''' </summary>
     ''' <remarks>
     ''' </remarks>
     Private Function ParseConstantMemberDeclarations(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConstantModifiers)
 
         tm.AcceptIfNotInternalError(KS.Const)
         m_Modifiers.AddModifiers(ModifierMasks.Const)
 
         result = ParseConstantDeclarations(Parent, Info.Attributes, m_Modifiers)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="621" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1189" endline="1210">
<![CDATA[
 
     ''' <summary>
     ''' ArrayTypeModifier  
     ''' RankList  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayTypeModifier(ByVal Parent As ParsedObject) As ArrayTypeModifier
         Dim result As New ArrayTypeModifier(Parent)
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         Dim m_Ranks As Integer
         Do
             m_Ranks += 1
         Loop While tm.Accept(KS.Comma)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Ranks)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="622" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5032" endline="5059">
<![CDATA[
 
     ''' <summary>
     ''' RedimStatement  
     ''' RedimClauses  
     '''	   RedimClause  |
     '''	   RedimClauses  ","  RedimClause
     ''' RedimClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseReDimStatement(ByVal Parent As ParsedObject) As ReDimStatement
         Dim result As New ReDimStatement(Parent)
 
         Dim m_IsPreserve As Boolean
         Dim m_Clauses As RedimClauses
 
         tm.AcceptIfNotInternalError(KS.ReDim)
         If tm.CurrentToken.Equals("Preserve") Then
             m_IsPreserve = True
             tm.NextToken()
         End If
 
         m_Clauses = ParseRedimClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsPreserve, m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="623" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4994" endline="5016">
<![CDATA[
 
     ''' <summary>
     ''' ThrowStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseThrowStatement(ByVal Parent As ParsedObject) As ThrowStatement
         Dim result As New ThrowStatement(Parent)
 
         Dim m_Exception As Expression
 
         tm.AcceptIfNotInternalError(KS.Throw)
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_Exception = ParseExpression(result)
             If m_Exception Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Exception = Nothing
         End If
 
         result.Init(m_Exception)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="624" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5130" endline="5149">
<![CDATA[
 
     ''' <summary>
     ''' ExitStatement  
     ''' ExitKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExitStatement(ByVal Parent As ParsedObject) As ExitStatement
         Dim m_ExitWhat As KS
 
         tm.AcceptIfNotInternalError(KS.Exit)
         If tm.CurrentToken.Equals(KS.Sub, KS.Function, KS.Property, KS.Do, KS.For, KS.Try, KS.While, KS.Select) Then
             m_ExitWhat = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30240, tm.CurrentLocation)
             Return Nothing
         End If
 
         Return New ExitStatement(Parent, m_ExitWhat)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="625" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2391" endline="2403">
<![CDATA[
 
     Private Function ParseUnaryNotExpression(ByVal Info As ExpressionParseInfo) As UnaryNotExpression
         Dim result As New UnaryNotExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Not)
 
         m_Expression = ParseComparison(Info)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="626" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5223" endline="5230">
<![CDATA[
 
     Private Function ParseRedimClauses(ByVal Parent As ReDimStatement) As RedimClauses
         Dim result As New RedimClauses(Parent)
         If ParseList(Of RedimClause)(result, New ParseDelegate_Parent(Of RedimClause)(AddressOf ParseRedimClause), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="627" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2958" endline="2967">
<![CDATA[
 
     Private Function ParseExpressionList(ByVal Parent As ParsedObject) As ExpressionList
         Dim result As New ExpressionList(Parent)
 
         If ParseList(Of Expression)(result, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="628" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3510" endline="3525">
<![CDATA[
 
     ''' <summary>
     ''' VariableIdentifiers  
     '''	            VariableIdentifier  |
     '''	            VariableIdentifiers  ,  VariableIdentifier
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifiers(ByVal Parent As ParsedObject) As VariableIdentifiers
         Dim result As New VariableIdentifiers(Parent)
 
         If ParseList(Of VariableIdentifier)(result, New ParseDelegate_Parent(Of VariableIdentifier)(AddressOf ParseVariableIdentifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="629" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="226" endline="239">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClauses  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClauses(ByVal Parent As ImportsStatement) As ImportsClauses
         Dim result As New ImportsClauses(Parent)
 
         If ParseList(Of ImportsClause)(result, New ParseDelegate_Parent(Of ImportsClause)(AddressOf ParseImportsClause), result) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="630" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3194" endline="3206">
<![CDATA[
 
     Private Function ParseIntDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMultDiv(Info)
 
         While tm.Accept(KS.IntDivision)
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.IntDivision)
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="631" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2345" endline="2359">
<![CDATA[
 
 
     Private Function ParseUnaryMinusExpression(ByVal Info As ExpressionParseInfo) As UnaryMinusExpression
         Dim result As New UnaryMinusExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Minus)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="632" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2404" endline="2417">
<![CDATA[
 
     Private Function ParseUnaryPlusExpression(ByVal Info As ExpressionParseInfo) As UnaryPlusExpression
         Dim result As New UnaryPlusExpression(Info.Parent)
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Add)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="633" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5270" endline="5288">
<![CDATA[
 
     ''' <summary>
     ''' ErrorStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseErrorStatement(ByVal Parent As ParsedObject) As ErrorStatement
         Dim result As New ErrorStatement(Parent)
 
         Dim m_ErrNumber As Expression
 
         tm.AcceptIfNotInternalError(KS.Error)
 
         m_ErrNumber = ParseExpression(result)
         If m_ErrNumber Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_ErrNumber)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="634" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5183" endline="5204">
<![CDATA[
 
     ''' <summary>
     ''' EraseStatement  
     ''' EraseExpressions  
     '''	  Expression  |
     '''	  EraseExpressions  ,  Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEraseStatement(ByVal Parent As ParsedObject) As EraseStatement
         Dim result As New EraseStatement(Parent)
 
         Dim m_Targets As ExpressionList
 
         tm.AcceptIfNotInternalError(KS.Erase)
 
         m_Targets = ParseExpressionList(Parent)
         If m_Targets Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Targets)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="635" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4442" endline="4463">
<![CDATA[
 
     ''' <summary>
     ''' HandlesClause  
     ''' LAMESPEC
     ''' HandlesClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseHandlesClause(ByVal Parent As ParsedObject) As HandlesClause
         Dim result As New HandlesClause(Parent)
 
         Dim m_List As New EventHandlesList(result)
 
         tm.AcceptIfNotInternalError(KS.Handles)
 
         If ParseList(Of EventMemberSpecifier)(m_List, New ParseDelegate_Parent(Of EventMemberSpecifier)(AddressOf ParseEventMemberSpecifier), result) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_List)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="636" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3998" endline="4013">
<![CDATA[
 
     Private Function ParseImplementsClause(ByVal Parent As ParsedObject) As MemberImplementsClause
         Dim result As New MemberImplementsClause(Parent)
 
         Dim m_ImplementsList As New MemberImplementsList(Parent)
 
         tm.AcceptIfNotInternalError(KS.Implements)
 
         If ParseList(Of InterfaceMemberSpecifier)(m_ImplementsList, New ParseDelegate_Parent(Of InterfaceMemberSpecifier)(AddressOf ParseInterfaceMemberSpecifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_ImplementsList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="637" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="65" endline="76">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lInfo As EmitInfo = Info.Clone(Me, RSide)
 
         Helper.Assert(LSide.Classification.IsVariableClassification OrElse LSide.Classification.IsPropertyAccessClassification)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="638" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="696" endline="720">
<![CDATA[
 
     ''' <summary>
     ''' AttributeArgumentExpression  
     '''   ConstantExpression  |
     '''   GetTypeExpression  |
     '''   ArrayCreationExpression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeArgumentExpression(ByVal Parent As ParsedObject) As AttributeArgumentExpression
         Dim result As New AttributeArgumentExpression(Parent)
 
         Dim m_Expression As Expression
 
         If tm.CurrentToken = KS.GetType Then
             m_Expression = ParseGetTypeExpression(result)
         ElseIf tm.CurrentToken = KS.[New] Then
             m_Expression = ParseArrayCreationExpression(result)
         Else
             m_Expression = ParseExpression(result)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="639" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5205" endline="5222">
<![CDATA[
 
     Private Function ParseReturnStatement(ByVal Parent As ParsedObject) As ReturnStatement
         Dim result As New ReturnStatement(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Return)
         If Not tm.CurrentToken.IsEndOfStatement Then
             m_Expression = ParseExpression(result)
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression = Nothing
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="640" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1169" endline="1188">
<![CDATA[
 
     ''' <summary>
     ''' ArrayTypeModifiers  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayTypeModifiers(ByVal Parent As ParsedObject) As ArrayTypeModifiers
         Dim result As New ArrayTypeModifiers(Parent)
 
         Dim tmp As New Generic.List(Of ArrayTypeModifier)
         Do
             Dim newATM As ArrayTypeModifier
             newATM = ParseArrayTypeModifier(result)
             If newATM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             tmp.Add(newATM)
         Loop While ArrayTypeModifier.CanBeMe(tm)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="641" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="517" endline="535">
<![CDATA[
     ''' <summary>
     ''' AttributeBlock  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeBlock(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         tm.AcceptIfNotInternalError(KS.LT)
 
         If ParseAttributeList(Parent, Attributes) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result = tm.AcceptIfNotError(KS.GT) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="642" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1109" endline="1128">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeArgumentList 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeArgumentList(ByVal Parent As ParsedObject) As TypeArgumentList
         Dim result As New TypeArgumentList(Parent)
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
         tm.AcceptIfNotInternalError(KS.Of)
 
         If ParseList(Of TypeName)(result, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
             Return Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="643" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" startline="45" endline="60">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim falseLabel As Label = Emitter.DefineLabel(Info)
 
         result = m_Condition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, falseLabel)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, ParentAsIfStatement.EndLabel)
 
         Emitter.MarkLabel(Info, falseLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="644" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="656" endline="681">
<![CDATA[
 
     Private Delegate Function ParseDelegate_Parent(Of T)(ByVal Parent As ParsedObject) As T
 
     ''' <summary>
     ''' VariablePropertyInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariablePropertyInitializer(ByVal Parent As ParsedObject) As VariablePropertyInitializer
         Dim result As New VariablePropertyInitializer(Parent)
 
         Dim m_IdentifierOrKeyword As IdentifierOrKeyword
         Dim m_AttributeArgumentExpression As AttributeArgumentExpression
 
         m_IdentifierOrKeyword = ParseIdentifierOrKeyword(result)
         If m_IdentifierOrKeyword Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
 
         m_AttributeArgumentExpression = ParseAttributeArgumentExpression(result)
         If m_AttributeArgumentExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IdentifierOrKeyword, m_AttributeArgumentExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="645" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3975" endline="3997">
<![CDATA[
 
     ''' <summary>
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameterIdentifier(ByVal Parent As Parameter) As ParameterIdentifier
         Dim result As New ParameterIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="646" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="456" endline="477">
<![CDATA[
 
     Private Function ResolvePropertyGroupInvocation() As Boolean
         Dim result As Boolean = True
         Dim propGroup As PropertyGroupClassification = m_Expression.Classification.AsPropertyGroup
         Dim tmpResult As Boolean
 
         tmpResult = propGroup.ResolveGroup(m_ArgumentList)
 
         If tmpResult = False Then
             tmpResult = ResolveReclassifyToValueThenIndex()
 
             Helper.StopIfDebugging(tmpResult = False)
 
             Return tmpResult
         Else
             result = m_ArgumentList.ReplaceAndVerifyArguments(propGroup.FinalArguments, propGroup.ResolvedProperty) AndAlso result
         End If
 
         Classification = New PropertyAccessClassification(propGroup)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="647" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4213" endline="4239">
<![CDATA[
 
     ''' <summary>
     ''' Operand  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOperand(ByVal Parent As ParsedObject) As Operand
         Dim result As New Operand(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName
 
         tm.Accept(KS.ByVal)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="648" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4503" endline="4528">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceSubDeclaration  
     ''' [  Attributes  ]  [  InterfaceProcedureModifier+  ]  "Sub" SubSignature  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceSubDeclaration
         Dim result As New InterfaceSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As SubSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Signature = ParseSubSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="649" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="947" endline="971">
<![CDATA[
 
     ''' <summary>
     ''' TypeImplementsClause  
     ''' Implements  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeImplementsClauses(ByVal Parent As ParsedObject) As TypeImplementsClauses
         Dim result As New TypeImplementsClauses(Parent)
 
         Dim m_Clauses As New Generic.List(Of NonArrayTypeName)
 
         Do While tm.Accept(KS.Implements)
             Do
                 Dim newI As NonArrayTypeName
                 newI = ParseNonArrayTypeName(result)
                 If newI Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Clauses.Add(newI)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While tm.Accept(KS.Implements)
             Do
                 Dim newI As NonArrayTypeName
                 newI = ParseNonArrayTypeName(result)
                 If newI Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Clauses.Add(newI)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         result.Init(m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="650" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2646" endline="2672">
<![CDATA[
     ''' <summary>
     ''' A single identifier followed by an optional type argument list.
     ''' 
     ''' SimpleNameExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleNameExpression(ByVal Parent As ParsedObject) As SimpleNameExpression
         Dim result As New SimpleNameExpression(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeArgumentList As TypeArgumentList
 
         m_Identifier = ParseIdentifier(result)
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             m_TypeArgumentList = ParseTypeArgumentList(result)
             If m_TypeArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             'If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented()
         Else
             m_TypeArgumentList = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="651" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1709" endline="1738">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceEventMemberDeclaration  
     '''	[  Attributes  ]  [  InterfaceEventModifiers+  ]  "Event"  Identifier  ParametersOrType  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceEventMemberDeclaration
         Dim result As New InterfaceEventMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
 
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceEventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="652" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="814" endline="839">
<![CDATA[
 
     ''' <summary>
     ''' ArrayElementInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayElementInitializer(ByVal Parent As ParsedObject) As ArrayElementInitializer
         Dim result As New ArrayElementInitializer(Parent)
 
         Dim m_VariableInitializerList As VariableInitializerList
 
         m_VariableInitializerList = New VariableInitializerList(result)
 
         tm.AcceptIfNotInternalError(KS.LBrace)
         If tm.Accept(KS.RBrace) = False Then
 
             If ParseList(Of VariableInitializer)(m_VariableInitializerList, New ParseDelegate_Parent(Of VariableInitializer)(AddressOf ParseVariableInitializer), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_VariableInitializerList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="653" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5023" endline="5031">
<![CDATA[
 
     Private Function ParseResumeStatement(ByVal Parent As ParsedObject) As ResumeStatement
         Dim m_IsResumeNext As Boolean
 
         tm.AcceptIfNotInternalError(KS.Resume)
         m_IsResumeNext = tm.Accept(KS.Next)
 
         Return New ResumeStatement(Parent, m_IsResumeNext)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="654" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3380" endline="3397">
<![CDATA[
 
     ''' <summary>
     ''' AddressOfExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddressOfExpression(ByVal Parent As ParsedObject) As AddressOfExpression
         Dim result As New AddressOfExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.AddressOf)
 
         m_Expression = ParseExpression(result)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="655" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5880" endline="5891">
<![CDATA[
 
     Private Function ParseCallStatement(ByVal Parent As ParsedObject) As CallStatement
         Dim result As New CallStatement(Parent)
 
         Dim m_Target As Expression
         tm.AcceptIfNotInternalError(KS.Call)
         m_Target = ParseExpression(result)
 
         result.Init(m_Target)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="656" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="500" endline="516">
<![CDATA[
     ''' <summary>
     '''  Parses attributes (if any). Always returns something.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject) As Attributes
         Dim result As New Attributes(Parent)
 
         If Attributes.IsMe(tm) Then
             While AttributeBlock.IsMe(tm)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
             While AttributeBlock.IsMe(tm)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="657" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="76" endline="93">
<![CDATA[
 
     Sub Init(ByVal ArrayType As Mono.Cecil.TypeReference, ByVal ArrayBounds() As Expression, ByVal InitializerElements As Expression())
         m_ExpressionType = ArrayType
 
         If ArrayBounds IsNot Nothing Then
             m_ArrayNameModifier = New ArrayNameModifier(Me)
             Dim newSizes As New ArraySizeInitializationModifier(Me)
             Dim bounds As New BoundList(newSizes)
             bounds.Init(ArrayBounds)
             newSizes.Init(bounds, Nothing)
             m_ArrayNameModifier.Init(newSizes)
         End If
 
         If InitializerElements IsNot Nothing Then
             m_ArrayElementInitializer = New ArrayElementInitializer(Me)
             m_ArrayElementInitializer.Init(InitializerElements)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="658" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="37" endline="43">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As BoundList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New BoundList(NewParent)
         result.Init(Helper.CloneExpressionArray(m_Expressions, result))
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="659" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3472" endline="3491">
<![CDATA[
 
     ''' <summary>
     ''' LiteralExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLiteralExpression(ByVal Parent As ParsedObject) As LiteralExpression
         Dim result As LiteralExpression
 
         Dim m_Value As Token
         m_Value = tm.CurrentToken
         If m_Value.IsLiteral = False Then
             result = Nothing
         Else
             result = New LiteralExpression(Parent)
             result.Init(m_Value)
             tm.NextToken()
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="660" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="63" endline="75">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeName(NewParent)
         If Me.IsNonArrayTypeName Then
             result.Init(Me.AsNonArrayTypeName.clone)
         ElseIf Me.IsArrayTypeName Then
             result.Init(Me.AsArrayTypeName.clone)
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="661" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="107" endline="123">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Resolved)
 
         If Info.IsRHS Then
             result = GenerateCodeAsValue(Info) AndAlso result
         ElseIf Info.IsLHS Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="662" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="58" endline="72">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As NonArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New NonArrayTypeName(NewParent)
         result.IsNullable = IsNullable
         If Me.IsConstructedTypeName Then
             result.Init(Me.AsConstructedTypeName.Clone)
         ElseIf Me.IsSimpleTypeName Then
             result.Init(Me.AsSimpleTypeName.Clone)
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="663" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3145" endline="3157">
<![CDATA[
 
     Private Function ParseExponent(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIdentifier(Info)
 
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="664" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="62" endline="78">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
 
         Emitter.MarkLabel(Info, m_NextIteration)
         result = m_Condition.GenerateCode(Info.Clone(Me, True, , Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, EndLabel)
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, m_NextIteration)
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="665" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="220" endline="234">
<![CDATA[
 
     Private Function EmitStoreCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 Emitter.EmitStoreField(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitStoreVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="666" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="922" endline="946">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceBase   
     ''' InterfaceBases  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceBases(ByVal Parent As ParsedObject) As InterfaceBases
         Dim result As New InterfaceBases(Parent)
         Dim tmp As New Generic.List(Of NonArrayTypeName)
 
         Do While tm.Accept(KS.Inherits)
             Do
                 Dim newBase As NonArrayTypeName
                 newBase = ParseNonArrayTypeName(result)
                 tmp.Add(newBase)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While tm.Accept(KS.Inherits)
             Do
                 Dim newBase As NonArrayTypeName
                 newBase = ParseNonArrayTypeName(result)
                 tmp.Add(newBase)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         If tmp.Count <= 0 Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="667" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" startline="86" endline="105">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If Classification IsNot Nothing Then Return True
 
         result = m_Expression.ResolveExpression(New ResolveInfo(Info.Compiler, True)) AndAlso result
 
         If m_Expression.Classification.IsMethodGroupClassification Then
             Dim mpClassification As MethodPointerClassification
             mpClassification = New MethodPointerClassification(Me, m_Expression.Classification.AsMethodGroupClassification)
             Classification = mpClassification
 
             m_ExpressionType = Info.Compiler.TypeCache.DelegateUnresolvedType
         Else
             Helper.AddError(Me, Me.Location.ToString(Compiler))
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="668" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4945" endline="4966">
<![CDATA[
 
     Private Function ParseInterfacePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfacePropertyMemberDeclaration
         Dim result As New InterfacePropertyMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfacePropertyModifier)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="669" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3172" endline="3193">
<![CDATA[
 
     Private Function ParseMultDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseUnaryPlusMinus(Info)
 
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="670" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3220" endline="3242">
<![CDATA[
 
     Private Function ParsePlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMod(Info)
 
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="671" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3256" endline="3277">
<![CDATA[
 
     Private Function ParseBitshift(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseConcat(Info)
 
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="672" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3846" endline="3878">
<![CDATA[
 
     ''' <summary>
     ''' TypeParameter  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameter(ByVal Parent As ParsedObject) As TypeParameter
         Dim result As New TypeParameter(Parent)
         Dim m_Identifier As Identifier
         Dim m_TypeParameterConstraints As TypeParameterConstraints
         Dim parentList As TypeParameterList
 
         Helper.Assert(TypeOf Parent Is TypeParameterList)
 
         parentList = DirectCast(Parent, TypeParameterList)
         result.GenericParameterPosition = parentList.Count + 1
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             result.Identifier = m_Identifier
         End If
 
         If TypeParameterConstraints.CanBeMe(tm) Then
             m_TypeParameterConstraints = ParseTypeParameterConstraints(result)
             If m_TypeParameterConstraints Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.TypeParameterConstraints = m_TypeParameterConstraints
         Else
             m_TypeParameterConstraints = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="673" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2418" endline="2441">
<![CDATA[
 
     Private Function ParseArrayInitializerExpression(ByVal Parent As ParsedObject) As ArrayInitializerExpression
         Dim result As New ArrayInitializerExpression(Parent)
 
         Dim m_Initializers As New Expressions()
 
         tm.AcceptIfNotInternalError(KS.LBrace)
 
         If tm.CurrentToken <> KS.RBrace Then
             Do
                 Dim newExp As Expression
                 newExp = ParseExpression(result)
                 If newExp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
                 m_Initializers.Add(newExp)
             Loop While tm.Accept(KS.Comma)
         End If
 
         If tm.Accept(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Initializers)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="674" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4967" endline="4993">
<![CDATA[
 
 
     ''' <summary>
     ''' LabelDeclarationStatement  
     ''' LabelName  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLabelDeclarationStatement(ByVal Parent As ParsedObject) As LabelDeclarationStatement
         Dim m_Label As Token
 
         If tm.CurrentToken.IsIdentifier OrElse tm.CurrentToken.IsIntegerLiteral Then
             m_Label = tm.CurrentToken
             tm.NextToken()
         Else
             Throw New InternalException(Parent)
         End If
 
         If tm.CurrentToken.Equals(KS.Colon) = False Then
             Throw New InternalException(Parent)
         End If
 
         If tm.PeekToken.IsEndOfLineOnly Then
             tm.NextToken()
         End If
 
         Return New LabelDeclarationStatement(Parent, m_Label)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="675" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3824" endline="3845">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeParameters  
     ''' CHANGED
     ''' </summary>
     ''' <remarks></remarks>
     ''' 
     Private Function ParseTypeParameters(ByVal Parent As ParsedObject) As TypeParameters
         Dim result As New TypeParameters()
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptIfNotError(KS.Of) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseList(Of TypeParameter)(result.Parameters, New ParseDelegate_Parent(Of TypeParameter)(AddressOf ParseTypeParameter), result.Parameters) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="676" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1959" endline="1984">
<![CDATA[
 
     ''' <summary>
     ''' DictionaryAccessExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDictionaryAccessExpression(ByVal Parent As ParsedObject, ByVal FirstPart As Expression) As DictionaryAccessExpression
         Dim result As New DictionaryAccessExpression(Parent)
 
         Dim m_FirstPart As Expression
         Dim m_SecondPart As IdentifierOrKeyword
 
         m_FirstPart = FirstPart
         If m_FirstPart IsNot Nothing Then m_FirstPart.Parent = result
         tm.AcceptIfNotInternalError(KS.Exclamation)
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_SecondPart = ParseIdentifierOrKeyword(result)
             If m_SecondPart Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_FirstPart, m_SecondPart)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="677" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2224" endline="2253">
<![CDATA[
 
     ''' <summary>
     ''' VariableIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifier(ByVal Parent As ParsedObject) As VariableIdentifier
         Dim result As New VariableIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier
 
         If tm.CurrentToken.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ArrayNameModifier = Nothing
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="678" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5332" endline="5359">
<![CDATA[
     ''' <summary>
     ''' WhileStatement  
     '''	   "While" BooleanExpression  StatementTerminator
     '''	         [  Block  ]
     '''	   "End" "While" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWhileStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WhileStatement
         Dim result As New WhileStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.While)
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.While) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Condition, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="679" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5504" endline="5533">
<![CDATA[
 
     ''' <summary>
     '''SyncLockStatement  
     '''	"SyncLock" Expression  StatementTerminator
     '''	   [  Block  ]
     '''	"End" "SyncLock" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSyncLockStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SyncLockStatement
         Dim result As New SyncLockStatement(Parent)
 
         Dim m_Lock As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.SyncLock)
 
         m_Lock = ParseExpression(result)
         If m_Lock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.SyncLock) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Lock, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="680" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5360" endline="5389">
<![CDATA[
 
     ''' <summary>
     ''' WithStatement  
     '''	   "With" Expression  StatementTerminator
     '''	        [  Block  ]
     '''	   "End" "With" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWithStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WithStatement
         Dim result As New WithStatement(Parent)
 
         Dim m_WithExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.With)
 
         m_WithExpression = ParseExpression(result)
         If m_WithExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_Code = ParseCodeBlock(result, IsOneLiner)
 
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.With) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_WithExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="681" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1884" endline="1898">
<![CDATA[
 
     Private Function ParseBuiltInTypeExpression(ByVal Parent As ParsedObject) As BuiltInTypeExpression
         Dim result As New BuiltInTypeExpression(Parent)
 
         Dim m_Type As BuiltInDataTypes
 
         Helper.Assert(tm.CurrentToken.Equals(Enums.BuiltInTypeTypeNames))
 
         m_Type = CType(tm.CurrentToken.Keyword, BuiltInDataTypes)
         tm.NextToken()
 
         result.Init(m_Type)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="682" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2488" endline="2517">
<![CDATA[
 
     ''' <summary>
     ''' NewExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseNewExpression(ByVal Parent As ParsedObject) As NewExpression
         Dim result As New NewExpression(Parent)
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim bShowingErrors As Boolean
 
         Dim ace As ArrayCreationExpression
 
         bShowingErrors = Me.ShowErrors
         Me.m_ShowErrors = False
         ace = ParseArrayCreationExpression(result)
         Me.m_ShowErrors = bShowingErrors
 
         If ace IsNot Nothing Then
             tm.IgnoreRestoredPoint()
             result.Init(ace)
         Else
             tm.RestoreToPoint(iCurrent)
             Dim doce As DelegateOrObjectCreationExpression
             doce = ParseDelegateOrObjectCreationExpression(result)
             If doce Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(doce)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="683" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4418" endline="4441">
<![CDATA[
 
     ''' <summary>
     ''' HandlesOrImplements  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseHandlesOrImplements(ByVal Parent As ParsedObject) As HandlesOrImplements
         Dim result As New HandlesOrImplements(Parent)
 
         If vbnc.HandlesClause.IsMe(tm) Then
             Dim m_Clause As HandlesClause
             m_Clause = ParseHandlesClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         ElseIf vbnc.MemberImplementsClause.IsMe(tm) Then
             Dim m_Clause As MemberImplementsClause
             m_Clause = ParseImplementsClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Throw New InternalException(result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="684" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3879" endline="3905">
<![CDATA[
 
     ''' <summary>
     ''' TypeParameterConstraints  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameterConstraints(ByVal Parent As ParsedObject) As TypeParameterConstraints
         Dim result As New TypeParameterConstraints(Parent)
 
         tm.AcceptIfNotInternalError(KS.As)
 
         Dim m_ConstraintList As New ConstraintList(result)
 
         If tm.Accept(KS.LBrace) Then
             If ParseList(Of Constraint)(m_ConstraintList, New ParseDelegate_Parent(Of Constraint)(AddressOf ParseConstraint), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Dim tmpConstraint As Constraint = Nothing
             tmpConstraint = ParseConstraint(result)
             m_ConstraintList = New ConstraintList(result, tmpConstraint)
         End If
 
         result.Init(m_ConstraintList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="685" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="398" endline="429">
<![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim qi As QualifiedIdentifier
 
         qi = ParseQualifiedIdentifier(result)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result IsNot Nothing AndAlso tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             Dim ctn As ConstructedTypeName = Nothing
             tm.RestoreToPoint(iCurrent)
             ctn = ParseConstructedTypeName(result)
             If ctn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(ctn)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(qi)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="686" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4094" endline="4127">
<![CDATA[
 
     ''' <summary>
     ''' MustOverridePropertyMemberDeclaration  
     '''	[  Attributes  ]  [  MustOverridePropertyModifier+  ]  "Property" FunctionSignature  [  ImplementsClause  ]
     '''		StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseMustOverridePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As MustOverridePropertyDeclaration
         Dim result As New MustOverridePropertyDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverridePropertyModifiers)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, , , m_ImplementsClause)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="687" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5803" endline="5839">
<![CDATA[
 
     ''' <summary>
     ''' SelectStatement  
     '''	   "Select" [ "Case" ]  Expression  StatementTerminator
     '''	        [  CaseStatement+  ]
     '''	        [  CaseElseStatement  ]
     '''	   "End" "Select" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSelectStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SelectStatement
         Dim result As New SelectStatement(Parent)
 
         Dim m_Test As Expression
         Dim m_Cases As BaseObjects(Of CaseStatement)
 
         tm.AcceptIfNotInternalError(KS.Select)
 
         tm.Accept(KS.Case) '"Case" is not required
 
         m_Test = ParseExpression(result)
         If m_Test Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Cases = New BaseObjects(Of CaseStatement)(result)
         While tm.CurrentToken = KS.Case
             Dim newCase As CaseStatement
             newCase = ParseCaseStatement(result, IsOneLiner)
             m_Cases.Add(newCase)
         End While
         While tm.CurrentToken = KS.Case
             Dim newCase As CaseStatement
             newCase = ParseCaseStatement(result, IsOneLiner)
             m_Cases.Add(newCase)
         End While
 
         If tm.Accept(KS.End, KS.Select) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Test, m_Cases)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="688" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1211" endline="1243">
<![CDATA[
 
     ''' <summary>
     ''' SimpleTypeName 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleTypeName(ByVal Parent As ParsedObject) As SimpleTypeName
         Dim result As New SimpleTypeName(Parent)
 
         If BuiltInTypeName.IsBuiltInTypeName(tm) Then
             Dim m_BuiltInTypeName As BuiltInTypeName
             m_BuiltInTypeName = ParseBuiltinTypeName(result)
             If m_BuiltInTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_BuiltInTypeName)
         Else
             Dim m_QualifiedIdentifier As QualifiedIdentifier
 
             If QualifiedIdentifier.CanBeQualifiedIdentifier(tm) = False Then
                 If tm.CurrentToken.IsKeyword Then
                     Compiler.Report.ShowMessage(Messages.VBNC30180, tm.CurrentLocation)
                     tm.NextToken()
                 End If
                 Return Nothing
             End If
 
             m_QualifiedIdentifier = ParseQualifiedIdentifier(result)
             If m_QualifiedIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_QualifiedIdentifier)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="689" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6331" endline="6358">
<![CDATA[
 
     ''' <summary>
     ''' Parses enum members.
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseEnumMembers(ByVal Parent As EnumDeclaration) As Boolean
         Dim newConst As EnumMemberDeclaration
         Dim constAttributes As Attributes
 
         Do Until tm.CurrentToken.Equals(KS.End, KS.Enum)
             constAttributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, constAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             newConst = ParseEnumMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, constAttributes), Parent.Members.Count)
             If newConst Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Return False
             End If
             Parent.Members.Add(newConst)
         Loop
         Do Until tm.CurrentToken.Equals(KS.End, KS.Enum)
             constAttributes = New Attributes(Parent)
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, constAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             newConst = ParseEnumMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, constAttributes), Parent.Members.Count)
             If newConst Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Return False
             End If
             Parent.Members.Add(newConst)
         Loop
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="690" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4185" endline="4212">
<![CDATA[
 
     ''' <summary>
     ''' EnumMemberDeclaration  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal EnumIndex As Integer) As EnumMemberDeclaration
         Dim result As New EnumMemberDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ConstantExpression As Expression
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Equals) Then
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(EnumIndex, m_Identifier, m_ConstantExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="691" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2594" endline="2618">
<![CDATA[
 
     Private Function ParseNamedArgument(ByVal Parent As ParsedObject) As NamedArgument
         Dim result As New NamedArgument(Parent)
         Dim Name As String
         Dim Expression As Expression = Nothing
 
         If tm.CurrentToken.IsIdentifier Then
             Name = tm.CurrentToken.Identifier
         ElseIf tm.CurrentToken.IsKeyword Then
             Name = tm.CurrentToken.Identifier
         Else
             Throw New InternalException(result)
         End If
         tm.NextToken()
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
 
         Expression = ParseExpression(result)
         If Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.Init(Name, Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="692" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6040" endline="6072">
<![CDATA[
 
     ''' <summary>
     ''' AddHandlerStatement  
     ''' RemoveHandlerStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddOrRemoveHandlerStatement(ByVal Parent As ParsedObject) As AddOrRemoveHandlerStatement
         Dim result As New AddOrRemoveHandlerStatement(Parent)
 
         Dim m_Event As Expression
         Dim m_EventHandler As Expression
         Dim m_IsAddHandler As Boolean
 
         If tm.Accept(KS.AddHandler) Then
             m_IsAddHandler = True
         ElseIf tm.Accept(KS.RemoveHandler) Then
             m_IsAddHandler = False
         Else
             Throw New InternalException(result)
         End If
 
         m_Event = ParseExpression(result)
         If m_Event Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_EventHandler = ParseExpression(result)
         If m_EventHandler Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Event, m_EventHandler, m_IsAddHandler)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="693" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="721" endline="767">
<![CDATA[
 
 
 
     ''' <summary>
     ''' Type | QualifiedIdentifier ( Of [TypeArityList] )
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseGetTypeTypeName(ByVal Parent As GetTypeExpression) As GetTypeTypeName
         'TypeName |
         'QualifiedIdentifier (Of [TypeArityList])
         'TypeArityList 
         ' , |
         ' TypeParameterList ,
         Dim result As New GetTypeTypeName(Parent)
 
         'First try to parse as typename, if no 
         'success try as qualifiedidentifier.
         Dim m_TypeName As TypeName
         Dim iCurPos As RestorablePoint = tm.GetRestorablePoint
 
         m_TypeName = ParseTypeName(result)
         If m_TypeName Is Nothing Then
             tm.RestoreToPoint(iCurPos)
 
             Dim qn As QualifiedIdentifier
 
             qn = ParseQualifiedIdentifier(result)
             If qn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             tm.AcceptIfNotInternalError(KS.LParenthesis)
             tm.AcceptIfNotError(KS.Of)
 
             Dim typeArity As Integer = 1
             Do While tm.Accept(KS.Comma)
                 typeArity += 1
             Loop
             Do While tm.Accept(KS.Comma)
                 typeArity += 1
             Loop
 
             tm.AcceptIfNotError(KS.RParenthesis)
 
             result.Init(qn, typeArity)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(m_TypeName)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="694" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4729" endline="4761">
<![CDATA[
 
     ''' <summary>
     ''' ConstantDeclarator  
     ''' TODO
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstantDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal Modifiers As Modifiers) As ConstantDeclaration
         Dim result As New ConstantDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName = Nothing
         Dim m_ConstantExpression As Expression = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.AcceptIfNotError(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ConstantExpression = ParseExpression(result)
         If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(Modifiers, m_Identifier, m_TypeName, m_ConstantExpression)
 
         'Don't parse a StatementTerminator as the VB spec says.
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="695" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3439" endline="3471">
<![CDATA[
 
     ''' <summary>
     ''' "TypeOf" Expression "Is" TypeName
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeOfExpression(ByVal Parent As ParsedObject) As TypeOfExpression
         Dim result As New TypeOfExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_Is As Boolean
         Dim m_Type As TypeName
 
         tm.AcceptIfNotInternalError(KS.TypeOf)
 
         m_Expression = ParseExpression(New ExpressionParseInfo(result, False, True))
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Is) Then
             m_Is = True
         ElseIf tm.Accept(KS.IsNot) Then
             m_Is = False
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Type = ParseTypeName(result)
         If m_Type Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression, m_Is, m_Type)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="696" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1772" endline="1808">
<![CDATA[
 
     ''' <summary>
     ''' RegularEventMemberDeclaration  
     ''' 	[  Attributes  ]  [  EventModifiers+  ]  "Event"  Identifier  ParametersOrType  [  ImplementsClause  ] StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRegularEventDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As RegularEventDeclaration
         Dim result As New RegularEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
         Dim m_ImplementsClause As MemberImplementsClause
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ImplementsClause = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, m_ImplementsClause)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="697" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="51" endline="67">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As QualifiedIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New QualifiedIdentifier(NewParent, Me.Location)
 
         If Me.IsFirstGlobal Then
             result.Init(Me.FirstAsGlobal.Clone(result), m_Second)
         ElseIf Me.IsFirstIdentifier Then
             result.Init(Me.FirstAsIdentifier.Clone(result), m_Second)
         ElseIf Me.IsFirstQualifiedIdentifier Then
             result.Init(Me.FirstAsQualifiedIdentifier.Clone(result), m_Second)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="698" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ResumeStatement.vb" startline="32" endline="69">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim ResumeOK As Label = Emitter.DefineLabel(Info)
 
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         Dim lastblock As CodeBlock = block
         Do Until lastblock Is Nothing
             block = lastblock
             lastblock = block.FindFirstParent(Of CodeBlock)()
         Loop
         Do Until lastblock Is Nothing
             block = lastblock
             lastblock = block.FindFirstParent(Of CodeBlock)()
         Loop
 
         'Clear the error.
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
 
         'Test if the code is in an exception handler
         Emitter.EmitLoadVariable(Info, block.VB_ResumeTarget)
         Emitter.EmitBranchIfTrue(Info, ResumeOK)
 
         'If code is not in an exception handler raise an error
         Emitter.EmitLoadI4Value(Info, -2146828268)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Emitter.MarkLabel(Info, ResumeOK)
         'Load the instruction switch index
         Emitter.EmitLoadVariable(Info, block.VB_CurrentInstruction)
         'Increment the instruction pointer if it is a Resume Next statement
         If m_IsResumeNext Then
             Emitter.EmitLoadI4Value(Info, 1)
             Emitter.EmitAdd(Info, Compiler.TypeCache.System_Int32)
         End If
         'If everything is ok, jump to the instruction switch (adding one to the instruction if necessary)
         Emitter.EmitLeave(Info, block.UnstructuredResumeHandler)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="699" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ExponentExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Math__Pow_Double_Double)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ExponentObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="700" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3334" endline="3355">
<![CDATA[
 
     Private Function ParseAnd_AndAlso(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseNot(Info)
 
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="701" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2518" endline="2546">
<![CDATA[
 
     ''' <summary>
     ''' DelegateCreationExpression 
     ''' ObjectCreationExpression   
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateOrObjectCreationExpression(ByVal Parent As ParsedObject) As DelegateOrObjectCreationExpression
         Dim result As New DelegateOrObjectCreationExpression(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName = Nothing
         Dim m_ArgumentList As ArgumentList = Nothing
 
         tm.AcceptIfNotInternalError(KS.[New])
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.CurrentToken <> KS.RParenthesis Then
                 m_ArgumentList = ParseArgumentList(result)
                 If m_ArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If m_ArgumentList Is Nothing Then m_ArgumentList = New ArgumentList(result)
 
         result.Init(m_NonArrayTypeName, m_ArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="702" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="348" endline="375">
<![CDATA[
 
     ''' <summary>
     ''' ImportsAliasClause  
     '''	Identifier  =  QualifiedIdentifier  |
     '''	Identifier  =  ConstructedTypeName
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsAliasClause(ByVal Parent As ParsedObject) As ImportsAliasClause
         Dim result As New ImportsAliasClause(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_Second As ImportsNamespaceClause = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Equals)
 
         m_Second = ParseImportsNamespaceClause(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Identifier, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="703" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="192" endline="209">
<![CDATA[
 
     Private Function EmitLoadCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariable(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="704" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="94" endline="110">
<![CDATA[
 
     Public Shared Sub EmitArrayCreation(ByVal Parent As ParsedObject, ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal asim As ArraySizeInitializationModifier)
         Dim Ranks As Integer = asim.BoundList.Expressions.Length
         For i As Integer = 0 To Ranks - 1
             Dim litexp As New ConstantExpression(Parent, 1, Parent.Compiler.TypeCache.System_Int32)
             Dim exp As Expression
 
             exp = New BinaryAddExpression(Parent, asim.BoundList.Expressions(i), litexp)
             exp = New CIntExpression(Parent, exp)
 
             If exp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) = False Then Throw New InternalException(Parent)
             If exp.GenerateCode(Info.Clone(Parent, True)) = False Then Throw New InternalException(Parent)
 
             'Emitter.EmitConversion(exp.ExpressionType, Parent.Compiler.TypeCache.System_Int32, Info)
         Next
         EmitArrayConstructor(Info, ArrayType, Ranks)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="705" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="174" endline="191">
<![CDATA[
 
     Private Function EmitLoadAddressCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariableLocation(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariableLocation(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="706" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3735" endline="3771">
<![CDATA[
 
     ''' <summary>
     ''' Tries to parse a sub signature. Returns false if not successful.
     ''' SubSignature  
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="m_Identifier">Output parameter, must be nothing on entry.</param>
     ''' <param name="m_TypeParameters">Output parameter, must be nothing on entry.</param>
     ''' <param name="m_ParameterList">Input/Output parameter, must not be nothing on entry.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseSubSignature(ByVal Parent As ParsedObject, ByRef m_Identifier As Identifier, ByRef m_TypeParameters As TypeParameters, ByVal m_ParameterList As ParameterList) As Boolean
         Dim result As Boolean = True
 
         'Helper.Assert(m_Identifier Is Nothing)
         Helper.Assert(m_TypeParameters Is Nothing)
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         m_Identifier = ParseIdentifier(Parent)
         result = m_Identifier IsNot Nothing AndAlso result
 
         If vbnc.TypeParameters.IsMe(tm) Then
             m_TypeParameters = ParseTypeParameters(Parent)
         End If
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 result = tm.AcceptIfNotError(KS.RParenthesis) AndAlso result
             End If
         End If
 
         'Helper.Assert(m_Identifier IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="707" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="37" endline="56">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal [Operator] As Token, ByVal Operand As Operand, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Block As CodeBlock)
         Dim mySignature As New FunctionSignature(Me)
         Dim parameters As New ParameterList(Me)
 
         parameters.Add(New Parameter(parameters, Operand.Name, Operand.TypeName))
 
         If Modifiers.Is(ModifierMasks.Widening) Then
             mySignature.Init("op_Implicit", Nothing, parameters, ReturnTypeAttributes, TypeName, Me.Location)
         ElseIf Modifiers.Is(ModifierMasks.Narrowing) Then
             mySignature.Init("op_Explicit", Nothing, parameters, ReturnTypeAttributes, TypeName, Me.Location)
         Else
             Helper.AddError(Me)
         End If
 
         m_Operator = [Operator]
         m_Operand = Operand
 
         MyBase.Init(Modifiers, mySignature, Block)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="708" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="463" endline="480">
<![CDATA[
 
     Function ReportReclassifyToValueErrorMessage() As Boolean
 
         Select Case m_Classification.Classification
             Case ExpressionClassification.Classifications.EventAccess
                 Compiler.Report.ShowMessage(Messages.VBNC32022, Me.Location)
             Case ExpressionClassification.Classifications.Type
                 Compiler.Report.ShowMessage(Messages.VBNC30108, Me.Location)
             Case ExpressionClassification.Classifications.Namespace
                 Compiler.Report.ShowMessage(Messages.VBNC30112, Me.Location)
             Case ExpressionClassification.Classifications.Void
                 Compiler.Report.ShowMessage(Messages.VBNC30491, Me.Location)
             Case Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End Select
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="709" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="30" endline="53">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case Me.OperandTypeCode
 
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Boolean)
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitNot(Info, OperandType)
             Case TypeCode.Object
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__NotObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="710" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="121" endline="148">
<![CDATA[
     ''' <summary>
     ''' OptionCompareStatement  
     ''' CompareOption  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionCompareStatement(ByVal Parent As BaseObject) As OptionCompareStatement
         Dim result As New OptionCompareStatement(Parent)
 
         Dim m_IsBinary As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Compare")
 
         If tm.Accept("Text") Then
             m_IsBinary = False
         ElseIf tm.Accept("Binary") Then
             m_IsBinary = True
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30207, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsBinary)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="711" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3906" endline="3930">
<![CDATA[
 
     ''' <summary>
     ''' Constraint  
     ''' LAMESPEC? Using the following
     ''' Constraint  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstraint(ByVal Parent As ParsedObject) As Constraint
         Dim result As New Constraint(Parent)
 
         Dim m_Special As KS
         Dim m_TypeName As TypeName = Nothing
 
         If tm.CurrentToken.Equals(KS.[New], KS.Class, KS.Structure) Then
             m_Special = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_TypeName, m_Special)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="712" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1933" endline="1958">
<![CDATA[
 
     Private Function ParseIdentifierOrKeywordWithTypeArguments(ByVal Parent As ParsedObject) As IdentifierOrKeywordWithTypeArguments
         Dim result As New IdentifierOrKeywordWithTypeArguments(Parent)
 
         Dim m_TypeArguments As TypeArgumentList
         Dim m_Token As Token
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_Token = tm.CurrentToken
             tm.NextToken()
         Else
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Return Nothing
         End If
 
         If tm.CurrentToken.Equals(KS.LParenthesis) AndAlso tm.PeekToken.Equals(KS.Of) Then
             m_TypeArguments = ParseTypeArgumentList(result)
             If m_TypeArguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeArguments = Nothing
         End If
 
         result.Init(m_Token, m_TypeArguments)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="713" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="890" endline="921">
<![CDATA[
 
     ''' <summary>
     ''' ArraySizeInitializationModifier  
     ''' LAMESPEC this might be correct? REMOVED, CURRENTLY USING ^ SPEC!
     ''' ArraySizeInitializationModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArraySizeInitializationModifer(ByVal Parent As ParsedObject) As ArraySizeInitializationModifier
         Dim result As New ArraySizeInitializationModifier(Parent)
 
         Dim m_BoundList As BoundList = Nothing
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers = Nothing
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_BoundList = ParseBoundList(result)
         If m_BoundList Is Nothing Then
             If m_ShowErrors = False Then Return Nothing
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayTypeModifiers.CanBeMe(tm) Then
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(result)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_BoundList, m_ArrayTypeModifiers)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="714" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="863" endline="889">
<![CDATA[
 
     ''' <summary>
     ''' ArrayNameModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayNameModifier(ByVal Parent As ParsedObject) As ArrayNameModifier
         Dim result As New ArrayNameModifier(Parent)
 
         If ArrayTypeModifiers.CanBeMe(tm) Then
             Dim newATM As ArrayTypeModifiers
             newATM = ParseArrayTypeModifiers(result)
             If newATM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(newATM)
         ElseIf ArraySizeInitializationModifier.CanBeMe(tm) Then
             Dim newASIM As ArraySizeInitializationModifier
             newASIM = ParseArraySizeInitializationModifer(result)
             If newASIM Is Nothing Then
                 If m_ShowErrors = False Then Return Nothing
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             result.Init(newASIM)
         Else
             Throw New InternalException(result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="715" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="294" endline="315">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClause(ByVal Parent As ParsedObject) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(tm) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="716" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3356" endline="3379">
<![CDATA[
 
     Private Function ParseOr_OrElse_Xor(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseAnd_AndAlso(Info)
 
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="717" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2547" endline="2593">
<![CDATA[
 
     ''' <summary>
     ''' ArgumentList  
     '''                     PositionalArgumentList  |
     '''	                    NamedArgumentList
     ''' 
     ''' PositionalArgumentList  
     ''' 
     ''' NamedArgumentList  
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArgumentList(ByVal Parent As ParsedObject) As ArgumentList
         Dim result As New ArgumentList(Parent)
 
         Dim m_Arguments As New BaseObjects(Of Argument)(result)
 
         'First parse positional arguments
         Do
             'Check for named argument.
             If NamedArgument.CanBeMe(tm) Then Exit Do
 
             Dim exp As Expression
             exp = Nothing
 
             If tm.CurrentToken.Equals(KS.Comma) = False Then
                 exp = ParseExpression(result)
             End If
 
             Dim newPA As PositionalArgument
             newPA = New PositionalArgument(result, m_Arguments.Count, exp)
             m_Arguments.Add(newPA)
         Loop While tm.Accept(KS.Comma)
 
         'Then parse named arguments
         If NamedArgument.CanBeMe(tm) Then
             Do
                 Dim newArgument As NamedArgument
                 newArgument = ParseNamedArgument(result)
                 m_Arguments.Add(newArgument)
             Loop While tm.Accept(KS.Comma)
         End If
 
         result.Init(m_Arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="718" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1899" endline="1932">
<![CDATA[
 
     ''' <summary>
     ''' MemberAccessExpression 
     ''' MemberAccessBase 
     ''' 
     ''' TODO
     ''' LAMESPEC
     ''' MemberAccessExpression 
     ''' </summary>
     ''' <param name="FirstExpression"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseMemberAccessExpression(ByVal Parent As ParsedObject, ByVal FirstExpression As Expression) As MemberAccessExpression
         Dim result As New MemberAccessExpression(Parent)
 
         Dim m_First As Expression
         Dim m_Second As IdentifierOrKeywordWithTypeArguments
 
         m_First = FirstExpression 'Might be nothing.
         If m_First IsNot Nothing Then m_First.Parent = result
         'According to the language specification, the dot is optional,
         'but that doesn't seem to be correct... so let's make it 
         'required
         tm.AcceptIfNotInternalError(KS.Dot)
         'Specifically, this is not a MemberAccessExpression without the
         'dot, so it is an internal error.
 
         m_Second = ParseIdentifierOrKeywordWithTypeArguments(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="719" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="89" endline="104">
<![CDATA[
 
     Shared Function CreateDefaultConstructor(ByVal Parent As TypeDeclaration) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
         Dim modifiers As Modifiers
 
         If Parent.Modifiers.Is(ModifierMasks.MustInherit) Then
             modifiers.AddModifier(KS.Protected)
         End If
         result.Init(modifiers, New SubSignature(result, ConstructorName, New ParameterList(result)), New CodeBlock(result))
 
         If result.ResolveTypeReferences() = False Then
             Helper.ErrorRecoveryNotImplemented(Parent.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="720" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="2290" endline="2321">
<![CDATA[
 
     ''' <summary>
     ''' InvocationExpression
     ''' IndexExpression
     ''' Note that for the index expression the parenthesis are not optional.
     ''' This is reflected by the fact that m_ArgumentList is not nothing if 
     ''' parenthesis are provided.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInvocationOrIndexExpression(ByVal Parent As ParsedObject, ByVal First As Expression) As InvocationOrIndexExpression
         Dim result As New InvocationOrIndexExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_ArgumentList As ArgumentList
 
         m_Expression = First
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_ArgumentList = ParseArgumentList(result)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_ArgumentList = New ArgumentList(result)
             End If
         Else
             m_ArgumentList = Nothing
         End If
 
         result.Init(m_Expression, m_ArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="721" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="175" endline="201">
<![CDATA[
 
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionStrictStatement(ByVal Parent As BaseObject) As OptionStrictStatement
         Dim result As New OptionStrictStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Strict")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="722" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="59" endline="79">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConcatenateObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="723" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="202" endline="225">
<![CDATA[
 
     ''' <summary>
     ''' OptionExplicitStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionExplicitStatement(ByVal Parent As BaseObject) As OptionExplicitStatement
         Dim result As New OptionExplicitStatement(Parent)
 
         Dim m_Off As Boolean
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Explicit")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30640, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="724" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5534" endline="5550">
<![CDATA[
 
     Private Function ParseDoStatementCondition(ByVal Parent As ParsedObject, ByRef IsWhile As Boolean) As Expression
         Dim result As Expression = Nothing
 
         If tm.Accept(KS.While) Then
             IsWhile = True
             result = ParseExpression(Parent)
         ElseIf tm.Accept(KS.Until) Then
             IsWhile = False
             result = ParseExpression(Parent)
         Else
             Throw New InternalException(result)
         End If
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="725" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="972" endline="997">
<![CDATA[
 
     ''' <summary>
     ''' BoundList
     ''' UpperBoundList
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseBoundList(ByVal Parent As ParsedObject) As BoundList
         Dim result As New BoundList(Parent)
 
         Dim newExp As Expression = Nothing
         Dim tmp As New Generic.List(Of Expression)
 
         Do
             If tm.CurrentToken.IsIntegerLiteral AndAlso tm.CurrentToken.IntegralLiteral = 0 AndAlso tm.PeekToken.Equals(KS.To) Then tm.NextToken(2)
             newExp = ParseExpression(result)
             If newExp Is Nothing Then
                 If m_ShowErrors = False Then Return Nothing
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             tmp.Add(newExp)
         Loop While tm.Accept(KS.Comma)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="726" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="149" endline="174">
<![CDATA[
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionInferStatement(ByVal Parent As BaseObject) As OptionInferStatement
         Dim result As New OptionInferStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Infer")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="727" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="54" endline="70">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             Helper.Assert(Me.Classification.IsValueClassification)
             If Me.Classification.CanBeValueClassification Then
                 result = Me.Classification.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="728" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="50" endline="62">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayNameModifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayNameModifier(NewParent)
         If Me.IsArrayTypeModifiers Then
             result.Init(Me.AsArrayTypeModifiers.Clone(result))
         ElseIf Me.IsArraySizeInitializationModifier Then
             result.Init(Me.AsArraySizeInitializationModifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="729" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\TypeClassification.vb" startline="50" endline="72">
<![CDATA[
     End Property
 
     Function CreateAliasExpression(ByVal SharedExpression As Expression, ByRef result As Expression) As Boolean
         Dim sne As SimpleNameExpression = TryCast(SharedExpression, SimpleNameExpression)
         Dim mae As MemberAccessExpression
         Dim maeIE As MemberAccessExpression
 
         If TypeOf SharedExpression.Parent Is Is_IsNotExpression Then
             Dim fieldLoad As New LoadFieldExpression(SharedExpression, DirectCast(m_Type.Annotations(Compiler), TypeDeclaration).MyGroupField.FieldBuilder, m_Group.DefaultInstanceAlias)
             result = fieldLoad
         Else
             If sne IsNot Nothing Then
                 maeIE = New MemberAccessExpression(SharedExpression.Parent)
                 maeIE.Init(Expression, New IdentifierOrKeyword(SharedExpression.Parent, Token.CreateIdentifierToken(sne.Location, sne.Identifier.Identifier)))
             Else
                 mae = TryCast(SharedExpression, MemberAccessExpression)
                 maeIE = New MemberAccessExpression(SharedExpression.Parent)
                 maeIE.Init(Expression, mae.SecondExpression)
             End If
             result = maeIE
         End If
         Return result.ResolveExpression(ResolveInfo.Default(SharedExpression.Compiler))
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="730" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="357" endline="387">
<![CDATA[
 
     Public Shared Function EmitLateSet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateSet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
 
         '2 - Type ??? - haven't found an example where this isn't nothing yet
         Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateSet_Object_Type_String_Array_Array_Array)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="731" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Base definition returns true if ConstantValue isnot nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property IsConstant() As Boolean
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="42" endline="72">
<![CDATA[
 
     Private Function ResolveIndexedStatement(ByVal Info As ResolveInfo, ByVal InvocationExpression As InvocationOrIndexExpression) As Boolean
         Dim result As Boolean = True
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
 
         For i As Integer = 0 To InvocationExpression.ArgumentList.Count - 1
             Dim arg As Argument = InvocationExpression.ArgumentList(i)
             Dim exp As Expression = arg.Expression
             Dim newExp As VariableExpression
             Dim varDecl As LocalVariableDeclaration
             Dim stmt As AssignmentStatement
 
             varDecl = New LocalVariableDeclaration(arg)
             varDecl.Init(Nothing, "VB$tmp", exp.ExpressionType)
             block.AddVariable(varDecl)
 
             newExp = New VariableExpression(arg, varDecl)
 
             stmt = New AssignmentStatement(Me.Parent)
             stmt.Init(newExp, exp)
             block.AddStatementBefore(stmt, Me)
 
             arg.Expression = newExp
         Next
 
         If InvocationExpression.Classification.IsVariableClassification Then
             result = CheckIndexedStatement(Info, TryCast(InvocationExpression.Classification.AsVariableClassification.ArrayVariable, InvocationOrIndexExpression)) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="732" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="67" endline="73">
<![CDATA[
 
     Shared Function CreateKeywordToken(ByVal Location As Span, ByVal Keyword As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Keyword
         result.m_TokenObject = Keyword
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="130" endline="136">
<![CDATA[
 
     Shared Function CreateUInt16Token(ByVal Location As Span, ByVal Value As UShort) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="733" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="67" endline="73">
<![CDATA[
 
     Shared Function CreateKeywordToken(ByVal Location As Span, ByVal Keyword As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Keyword
         result.m_TokenObject = Keyword
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="123" endline="129">
<![CDATA[
 
     Shared Function CreateInt64Token(ByVal Location As Span, ByVal Value As Long) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="734" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="67" endline="73">
<![CDATA[
 
     Shared Function CreateKeywordToken(ByVal Location As Span, ByVal Keyword As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Keyword
         result.m_TokenObject = Keyword
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="144" endline="150">
<![CDATA[
 
     Shared Function CreateUInt64Token(ByVal Location As Span, ByVal Value As ULong) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="735" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="67" endline="73">
<![CDATA[
 
     Shared Function CreateKeywordToken(ByVal Location As Span, ByVal Keyword As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Keyword
         result.m_TokenObject = Keyword
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="137" endline="143">
<![CDATA[
 
     Shared Function CreateUInt32Token(ByVal Location As Span, ByVal Value As UInteger) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="736" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="67" endline="73">
<![CDATA[
 
     Shared Function CreateKeywordToken(ByVal Location As Span, ByVal Keyword As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Keyword
         result.m_TokenObject = Keyword
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="158" endline="164">
<![CDATA[
 
     Shared Function CreateSymbolToken(ByVal Location As Span, ByVal Symbol As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Symbol
         result.m_TokenObject = Symbol
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="737" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="205" endline="211">
<![CDATA[
 
 		public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
 		{
 			ModuleBuilder module = new ModuleBuilder(this, name, fileName, emitSymbolInfo);
 			modules.Add(module);
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="753" endline="759">
<![CDATA[
 
 		private AssemblyBuilder DefineDynamicAssemblyImpl(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 		{
 			AssemblyBuilder asm = new AssemblyBuilder(this, name, dir, requiredPermissions, optionalPermissions, refusedPermissions);
 			dynamicAssemblies.Add(asm);
 			return asm;
  		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="738" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="205" endline="211">
<![CDATA[
 
 		public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
 		{
 			ModuleBuilder module = new ModuleBuilder(this, name, fileName, emitSymbolInfo);
 			modules.Add(module);
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="369" endline="375">
<![CDATA[
 
 		public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes)
 		{
 			FieldBuilder fb = new FieldBuilder(this, fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes);
 			fields.Add(fb);
 			return fb;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="739" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="205" endline="211">
<![CDATA[
 
 		public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
 		{
 			ModuleBuilder module = new ModuleBuilder(this, name, fileName, emitSymbolInfo);
 			modules.Add(module);
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="411" endline="421">
<![CDATA[
 
 		public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype)
 		{
 			if (events == null)
 			{
 				events = new List<EventBuilder>();
 			}
 			EventBuilder eb = new EventBuilder(this, name, attributes, eventtype);
 			events.Add(eb);
 			return eb;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="740" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="205" endline="211">
<![CDATA[
 
 		public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
 		{
 			ModuleBuilder module = new ModuleBuilder(this, name, fileName, emitSymbolInfo);
 			modules.Add(module);
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="400" endline="410">
<![CDATA[
 
 		public LocalBuilder DeclareLocal(Type localType, bool pinned)
 		{
 			LocalBuilder local = new LocalBuilder(localType, locals.Count, pinned);
 			locals.Add(local);
 			if (scope != null)
 			{
 				scope.locals.Add(local);
 			}
 			return local;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="741" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="132" endline="139">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = callingConvention;
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EnumBuilder.cs" startline="59" endline="66">
<![CDATA[
 		}
 
 		public FieldBuilder DefineLiteral(string literalName, object literalValue)
 		{
 			FieldBuilder fb = typeBuilder.DefineField(literalName, typeBuilder, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
 			fb.SetConstant(literalValue);
 			return fb;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="742" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="132" endline="139">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = callingConvention;
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="123" endline="131">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.unmanaged = true;
 			sig.unmanagedCallConv = unmanagedCallConv;
 			return sig;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="743" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="132" endline="139">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = callingConvention;
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="152" endline="160">
<![CDATA[
 
 		public byte[] GetSignature()
 		{
 			if (module == null)
 			{
 				throw new NotSupportedException();
 			}
 			return GetSignature(module).ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="744" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="132" endline="139">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = callingConvention;
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="102" endline="112">
<![CDATA[
 
 		public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, Signature.PROPERTY);
 			sig.callingConvention = callingConvention;
 			sig.returnType = returnType;
 			sig.returnTypeOptionalCustomModifiers = requiredReturnTypeCustomModifiers;
 			sig.returnTypeRequiredCustomModifiers = optionalReturnTypeCustomModifiers;
 			sig.AddArguments(parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers);
 			return sig;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="745" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="124" endline="135">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="106" endline="117">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="746" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="124" endline="135">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="118" endline="129">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="747" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="124" endline="135">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="136" endline="147">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="748" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="53" endline="60">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="749" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="80" endline="88">
<![CDATA[
     End Property
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="750" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="170" endline="177">
<![CDATA[
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="751" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="42" endline="51">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         ' result = Helper.ResolveTypeReferences(m_UsingResources) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="752" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="532" endline="540">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         'Define type parameters
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="753" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="211" endline="218">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = VerifyConstraints() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="754" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" startline="125" endline="132">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="755" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="412" endline="419">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = GenerateCodeInternal(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="756" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="51" endline="59">
<![CDATA[
 
     Public Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         result = AddAttribute() AndAlso result
         result = MyBase.DefineType() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="757" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="40" endline="48">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="758" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="53" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences() AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="759" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="66" endline="88">
<![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         'Dim m_MethodAttributes As MethodAttributes
         'If m_HandlerType = KS.RaiseEvent Then
         '    m_MethodAttributes = m_MethodAttributes Or MethodAttributes.Private
         'Else
         '    m_MethodAttributes = m_MethodAttributes Or Me.Modifiers.GetMethodAttributeScope
         'End If
         'm_MethodAttributes = m_MethodAttributes Or MethodAttributes.SpecialName
         'If DeclaringType.IsInterface Then
         '    m_MethodAttributes = m_MethodAttributes Or Reflection.MethodAttributes.Abstract Or Reflection.MethodAttributes.Virtual Or MethodAttributes.CheckAccessOnOverride Or MethodAttributes.NewSlot
         'End If
         'If Me.IsShared Then
         '    m_MethodAttributes = m_MethodAttributes Or MethodAttributes.Static
         'End If
         'MyBase.Attributes = m_MethodAttributes
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="760" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="761" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" startline="47" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_List.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="762" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="181" endline="192">
<![CDATA[
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         'Helper.SetTypeOrTypeBuilder(Compiler, ParameterTypes)
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="763" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="83" endline="92">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="764" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="64" endline="72">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Initializer.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="765" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="766" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="767" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="768" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="769" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" startline="43" endline="50">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info) AndAlso result 'Helper.NotImplemented()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="770" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="46" endline="53">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="771" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="32" endline="38">
<![CDATA[
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AttributeArgumentExpression.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="772" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="105" endline="114">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="773" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="89" endline="100">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="774" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="96" endline="103">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="775" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="409" endline="416">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="776" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="120" endline="129">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="777" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="117" endline="125">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AssignStatement.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="778" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="118" endline="127">
<![CDATA[
 
 
     Public Function ResolveEarly() As Boolean
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
         result = ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="779" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="125" endline="136">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_Event.ResolveExpression(Info) AndAlso result
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Compiler.Helper.AddCheck("The result of the expression must be classified as an event access for an event defined in the class itself; ")
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="780" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="107" endline="119">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info Is Nothing Then
             Info = New EmitInfo(Me)
         End If
 
         result = DefineHandlesOrImplements() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="781" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="281" endline="288">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="782" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="67" endline="74">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="783" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="188" endline="195">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="784" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="77" endline="84">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="785" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="58" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="786" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="176" endline="184">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         If m_ConstantExpression IsNot Nothing Then result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="787" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="325" endline="332">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="788" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="68" endline="75">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="789" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="58" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="790" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" startline="90" endline="98">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Lock.ResolveExpression(INfo) AndAlso result
         result = CodeBlock.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="791" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="47" endline="56">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.ResolveExpression(info) AndAlso result
 
         Compiler.Helper.AddCheck("The expression must be classified as a value and its type must be implicitly convertible to Integer.")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="792" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="57" endline="65">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Helper.GenerateCodeCollection(m_Clauses, Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="793" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="54" endline="63">
<![CDATA[
 
     Public Function Parse(ByVal RootNamespace As String, ByVal assembly As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = ParseAssemblyDeclaration(RootNamespace, assembly) AndAlso result
 
         result = Compiler.Report.Errors = 0 AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="794" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="795" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="59" endline="66">
<![CDATA[
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="796" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="121" endline="128">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="797" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="141" endline="149">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         'vbnc.Helper.Assert(result = (Compiler.Report.Errors = 0))
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="798" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="799" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="800" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" startline="66" endline="77">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Clauses.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Each clause in the statement must be classified as a variable or a property access whose type is an array type or Object, and be followed by a list of array bounds. ")
         Compiler.Helper.AddCheck("The number of the bounds must be consistent with the type of the variable; any number of bounds is allowed for Object.")
         Compiler.Helper.AddCheck("If the Preserve keyword is specified, then the expressions must also be classifiable as a value, and the new size for each dimension except for the rightmost one must be the same as the size of the existing array. ")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="801" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="68" endline="77">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="802" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="803" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="804" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="805" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="34" endline="42">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="806" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="807" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="115" endline="124">
<![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="808" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" startline="108" endline="118">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_UsingResources.ResolveCode(Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="809" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="64" endline="71">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Targets.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="810" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" startline="79" endline="88">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_Condition, Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="811" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="30" endline="38">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Expression) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="812" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="57" endline="66">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Operand.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="813" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="129" endline="147">
<![CDATA[
 
     ''' <summary>
     ''' This creates the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Declaration IsNot Nothing Then
             result = m_Declaration.DefineLocalVariable(Info) AndAlso result
             result = m_Declaration.GenerateCode(Info) AndAlso result
         Else
             'm_LoopVariableBuilder()
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="814" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="71" endline="80">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="815" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="816" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\BlockStatement.vb" startline="47" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         '#If DEBUG Then
         '        Dim m1, m2 As MethodInfo
         '        m1 = Me.GetType.GetMethod("ResolveTypeReferences")
         '        m2 = GetType(BlockStatement).GetMethod("ResolveTypeReferences")
         '        Helper.Assert(m1 IsNot m2)
         '#End If
 
         result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="817" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="337" endline="344">
<![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="71" endline="78">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ConstraintList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="818" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="173" endline="180">
<![CDATA[
 
 		public void CloseScope (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="190" endline="197">
<![CDATA[
 
 		public void CloseCompilerGeneratedBlock (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="819" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="173" endline="180">
<![CDATA[
 
 		public void CloseScope (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="72" endline="79">
<![CDATA[
 
 		public void DefineLocalVariable (int index, string name)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.AddLocal (index, name);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="820" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="173" endline="180">
<![CDATA[
 
 		public void CloseScope (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="103" endline="110">
<![CDATA[
 
 		public void DefineScopeVariable (int scope, int index)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.AddScopeVariable (scope, index);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="821" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7242" endline="7249">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="822" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1073" endline="1083">
<![CDATA[
 			
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (expr == null)
 				ec.Emit (OpCodes.Rethrow);
 			else {
 				expr.Emit (ec);
 
 				ec.Emit (OpCodes.Throw);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="823" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4193" endline="4209">
<![CDATA[
 
 		protected override void EmitFinallyBody (EmitContext ec)
 		{
 			//
 			// if (lock_taken) Monitor.Exit (expr_copy)
 			//
 			Label skip = ec.DefineLabel ();
 
 			if (lock_taken != null) {
 				lock_taken.Emit (ec);
 				ec.Emit (OpCodes.Brfalse_S, skip);
 			}
 
 			expr_copy.Emit (ec);
 			ec.Emit (OpCodes.Call, TypeManager.void_monitor_exit_object);
 			ec.MarkLabel (skip);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="824" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8617" endline="8626">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 
 			if (ec.CurrentType.IsStruct) {
 				ec.Emit (OpCodes.Ldobj, ec.CurrentType);
 				ec.Emit (OpCodes.Box, ec.CurrentType);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="825" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4497" endline="4517">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label false_target = ec.DefineLabel ();
 			Label end_target = ec.DefineLabel ();
 
 			expr.EmitBranchable (ec, false_target, false);
 			true_expr.Emit (ec);
 
 			if (type.IsInterface) {
 				LocalBuilder temp = ec.GetTemporaryLocal (type);
 				ec.Emit (OpCodes.Stloc, temp);
 				ec.Emit (OpCodes.Ldloc, temp);
 				ec.FreeTemporaryLocal (temp, type);
 			}
 
 			ec.Emit (OpCodes.Br, end_target);
 			ec.MarkLabel (false_target);
 			false_expr.Emit (ec);
 			ec.MarkLabel (end_target);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="826" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1310" endline="1322">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (expr_unwrap != null) {
 				expr_unwrap.EmitCheck (ec);
 				return;
 			}
 
 			expr.Emit (ec);
 			ec.Emit (OpCodes.Isinst, probe_type_expr.Type);
 			ec.Emit (OpCodes.Ldnull);
 			ec.Emit (OpCodes.Cgt_Un);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="827" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1323" endline="1333">
<![CDATA[
 
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			if (expr_unwrap != null) {
 				expr_unwrap.EmitCheck (ec);
 			} else {
 				expr.Emit (ec);
 				ec.Emit (OpCodes.Isinst, probe_type_expr.Type);
 			}			
 			ec.Emit (on_true ? OpCodes.Brtrue 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="828" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="529" endline="548">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (method_group.InstanceExpression == null)
 				ec.Emit (OpCodes.Ldnull);
 			else
 				method_group.InstanceExpression.Emit (ec);
 
 			var delegate_method = method_group.BestCandidate;
 
 			// Any delegate must be sealed
 			if (!delegate_method.DeclaringType.IsDelegate && delegate_method.IsVirtual && !method_group.IsBase) {
 				ec.Emit (OpCodes.Dup);
 				ec.Emit (OpCodes.Ldvirtftn, delegate_method);
 			} else {
 				ec.Emit (OpCodes.Ldftn, delegate_method);
 			}
 
 			ec.Emit (OpCodes.Newobj, constructor_method);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="829" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1164" endline="1198">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label end_label = ec.DefineLabel ();
 
 			if (unwrap != null) {
 				Label is_null_label = ec.DefineLabel ();
 
 				unwrap.EmitCheck (ec);
 				ec.Emit (OpCodes.Brfalse, is_null_label);
 
 				left.Emit (ec);
 				ec.Emit (OpCodes.Br, end_label);
 
 				ec.MarkLabel (is_null_label);
 				right.Emit (ec);
 
 				ec.MarkLabel (end_label);
 				return;
 			}
 
 			left.Emit (ec);
 			ec.Emit (OpCodes.Dup);
 
 			// Only to make verifier happy
 			if (left.Type.IsGenericParameter)
 				ec.Emit (OpCodes.Box, left.Type);
 
 			ec.Emit (OpCodes.Brtrue, end_label);
 
 			ec.Emit (OpCodes.Pop);
 			right.Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="830" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80">
<![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="81" endline="87">
<![CDATA[
 
     Shared Function CreateCharToken(ByVal Location As Span, ByVal Value As Char) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.CharLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="831" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80">
<![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="88" endline="94">
<![CDATA[
 
     Shared Function CreateDecimalToken(ByVal Location As Span, ByVal Value As Decimal) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DecimalLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="832" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80">
<![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="116" endline="122">
<![CDATA[
 
     Shared Function CreateInt32Token(ByVal Location As Span, ByVal Value As Integer) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="833" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80">
<![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="109" endline="115">
<![CDATA[
 
     Shared Function CreateInt16Token(ByVal Location As Span, ByVal Value As Short) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="834" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80">
<![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="95" endline="101">
<![CDATA[
 
     Shared Function CreateSingleToken(ByVal Location As Span, ByVal Value As Single) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.SingleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="835" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80">
<![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="102" endline="108">
<![CDATA[
 
     Shared Function CreateDoubleToken(ByVal Location As Span, ByVal Value As Double) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DoubleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="836" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="74" endline="80">
<![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="151" endline="157">
<![CDATA[
 
     Shared Function CreateStringLiteral(ByVal Location As Span, ByVal Value As String) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.StringLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="837" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2637" endline="2645">
<![CDATA[
 
 		public ToplevelBlock (CompilerContext ctx, ParametersCompiled parameters, Location start)
 			
 		{
 			this.compiler = ctx;
 			top_block = this;
 
 			ProcessParameters ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="992" endline="1338">
<![CDATA[
 
 		Expression initializer;
 		Field backing_field;
 		List<FieldDeclarator> declarators;
 
 		public EventField (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			Add = new AddDelegateMethod (this);
 			Remove = new RemoveDelegateMethod (this);
 		}
 
 		#region Properties
 
 		bool HasBackingField {
 			get {
 				return !IsInterface && (ModFlags & Modifiers.ABSTRACT) == 0;
 			}
 		}
 
 		public Expression Initializer {
 			get {
 				return initializer;
 			}
 			set {
 				initializer = value;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return HasBackingField ? attribute_targets 
 			}
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Field) {
 				backing_field.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				int errors = Report.Errors;
 				Add.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				if (errors == Report.Errors)
 					Remove.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override bool Define()
 		{
 			var mod_flags_src = ModFlags;
 
 			if (!base.Define ())
 				return false;
 
 			if (declarators != null) {
 				if ((mod_flags_src & Modifiers.DEFAULT_ACCESS_MODIFER) != 0)
 					mod_flags_src &= ~(Modifiers.AccessibilityMask | Modifiers.DEFAULT_ACCESS_MODIFER);
 
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Events.IndexOf (this);
 				foreach (var d in declarators) {
 					var ef = new EventField (Parent, t, mod_flags_src, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 
 					if (d.Initializer != null)
 						ef.initializer = d.Initializer;
 
 					Parent.PartialContainer.Events.Insert (++index, ef);
 				}
 			}
 
 			if (!HasBackingField) {
 				SetIsUsed ();
 				return true;
 			}
 
 			if (Add.IsInterfaceImplementation)
 				SetIsUsed ();
 
 			backing_field = new Field (Parent,
 				new TypeExpression (MemberType, Location),
 				Modifiers.BACKING_FIELD | Modifiers.COMPILER_GENERATED | Modifiers.PRIVATE | (ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE)),
 				MemberName, null);
 
 			Parent.PartialContainer.AddField (backing_field);
 			backing_field.Initializer = Initializer;
 			backing_field.ModFlags &= ~Modifiers.COMPILER_GENERATED;
 
 			// Call define because we passed fields definition
 			backing_field.Define ();
 
 			// Set backing field for event fields
 			spec.BackingField = backing_field.Spec;
 
 			return true;
 		}
 	}
 
 	public abstract class Event 
 	{
 		public abstract class AEventAccessor 
 		{
 			protected readonly Event method;
 			ParametersCompiled parameters;
 
 			static readonly string[] attribute_targets = new string [] { "method", "param", "return" };
 
 			public const string AddPrefix = "add_";
 			public const string RemovePrefix = "remove_";
 
 			protected AEventAccessor (Event method, string prefix, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = method.ModFlags;
 				this.parameters = ParametersCompiled.CreateImplicitParameter (method.TypeExpression, loc);
 			}
 
 			public bool IsInterfaceImplementation {
 				get { return method_data.implementing != null; }
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 
 				method_data = new MethodData (method, method.ModFlags,
 					method.flags | MethodAttributes.HideBySig | MethodAttributes.SpecialName, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				MethodBuilder mb = method_data.MethodBuilder;
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, mb, ParameterInfo, method.ModFlags);
 				Spec.IsAccessor = true;
 
 				return mb;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 
 			public override ParametersCompiled ParameterInfo {
 				get {
 					return parameters;
 				}
 			}
 		}
 
 		AEventAccessor add, remove;
 		EventBuilder EventBuilder;
 		protected EventSpec spec;
 
 		protected Event (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Event;
 			}
 		}
 
 		public AEventAccessor Add {
 			get {
 				return this.add;
 			}
 			set {
 				add = value;
 				Parent.AddMember (value);
 			}
 		}
 
 		public AEventAccessor Remove {
 			get {
 				return this.remove;
 			}
 			set {
 				remove = value;
 				Parent.AddMember (value);
 			}
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			EventBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				ok = false;
 			}
 
 			return ok;
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsDelegateType (MemberType)) {
 				Report.Error (66, Location, "`{0}'
 			}
 
 			if (!CheckBase ())
 				return false;
 
 			//
 			// Now define the accessors
 			//
 			var AddBuilder = Add.Define (Parent);
 			if (AddBuilder == null)
 				return false;
 
 			var RemoveBuilder = remove.Define (Parent);
 			if (RemoveBuilder == null)
 				return false;
 
 			EventBuilder = Parent.TypeBuilder.DefineEvent (GetFullName (MemberName), EventAttributes.None, MemberType.GetMetaInfo ());
 			EventBuilder.SetAddOnMethod (AddBuilder);
 			EventBuilder.SetRemoveOnMethod (RemoveBuilder);
 
 			spec = new EventSpec (Parent.Definition, this, MemberType, ModFlags, Add.Spec, remove.Spec);
 
 			Parent.MemberCache.AddMember (this, Name, spec);
 			Parent.MemberCache.AddMember (this, AddBuilder.Name, Add.Spec);
 			Parent.MemberCache.AddMember (this, RemoveBuilder.Name, remove.Spec);
 
 			return true;
 		}
 
 		public override void Emit ()
 		{
 			CheckReservedNameConflict (null, add.Spec);
 			CheckReservedNameConflict (null, remove.Spec);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			Add.Emit (Parent);
 			Remove.Emit (Parent);
 
 			base.Emit ();
 		}
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { return "E
 		}
 	}
 
 	public class EventSpec 
 	{
 		MethodSpec add, remove;
 		FieldSpec backing_field;
 
 		public EventSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec eventType, Modifiers modifiers, MethodSpec add, MethodSpec remove)
 			
 		{
 			this.AccessorAdd = add;
 			this.AccessorRemove = remove;
 			this.MemberType = eventType;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="838" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="119" endline="126">
<![CDATA[
 
 		public static void CloseScope (ILGenerator ig)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ig);
 				symwriter.CloseScope (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="189" endline="196">
<![CDATA[
 
 		public static void CloseCompilerGeneratedBlock (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.CloseCompilerGeneratedBlock (offset);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="839" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="119" endline="126">
<![CDATA[
 
 		public static void CloseScope (ILGenerator ig)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ig);
 				symwriter.CloseScope (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="205" endline="212">
<![CDATA[
 
 		public static void EndIteratorBody (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.EndIteratorBody (offset);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="840" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="119" endline="126">
<![CDATA[
 
 		public static void CloseScope (ILGenerator ig)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ig);
 				symwriter.CloseScope (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="181" endline="188">
<![CDATA[
 
 		public static void OpenCompilerGeneratedBlock (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.OpenCompilerGeneratedBlock (offset);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="841" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="119" endline="126">
<![CDATA[
 
 		public static void CloseScope (ILGenerator ig)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ig);
 				symwriter.CloseScope (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="197" endline="204">
<![CDATA[
 
 		public static void StartIteratorBody (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.StartIteratorBody (offset);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="842" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="119" endline="126">
<![CDATA[
 
 		public static void CloseScope (ILGenerator ig)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ig);
 				symwriter.CloseScope (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="213" endline="220">
<![CDATA[
 
 		public static void StartIteratorDispatcher (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.StartIteratorDispatcher (offset);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="843" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="119" endline="126">
<![CDATA[
 
 		public static void CloseScope (ILGenerator ig)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ig);
 				symwriter.CloseScope (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="221" endline="228">
<![CDATA[
 
 		public static void EndIteratorDispatcher (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.EndIteratorDispatcher (offset);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="844" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="127" endline="133">
<![CDATA[
 
 		internal void WriteParamRecord(MetadataWriter mw)
 		{
 			mw.Write(flags);
 			mw.Write(sequence);
 			mw.WriteStringIndex(nameIndex);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="150" endline="156">
<![CDATA[
 
 		internal void WriteFieldRecords(MetadataWriter mw)
 		{
 			mw.Write((short)attribs);
 			mw.WriteStringIndex(nameIndex);
 			mw.WriteBlobIndex(signature);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="845" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1159" endline="1165">
<![CDATA[
 
 		internal int GetSignatureBlobIndex(Signature sig)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			sig.WriteSig(this, bb);
 			return this.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="961" endline="969">
<![CDATA[
 
 		private int WriteTinyHeaderAndCode(ByteBuffer bb)
 		{
 			int rva = bb.Position;
 			const byte CorILMethod_TinyFormat = 0x2;
 			bb.Write((byte)(CorILMethod_TinyFormat | (code.Length << 2)));
 			WriteCode(bb);
 			return rva;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="846" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1159" endline="1165">
<![CDATA[
 
 		internal int GetSignatureBlobIndex(Signature sig)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			sig.WriteSig(this, bb);
 			return this.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="520" endline="532">
<![CDATA[
 
 		public MethodToken GetMethodToken(MethodInfo method)
 		{
 			MethodBuilder mb = method as MethodBuilder;
 			if (mb != null && mb.ModuleBuilder == this)
 			{
 				return new MethodToken(mb.MetadataToken);
 			}
 			else
 			{
 				return new MethodToken(ImportMember(method));
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="847" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1159" endline="1165">
<![CDATA[
 
 		internal int GetSignatureBlobIndex(Signature sig)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			sig.WriteSig(this, bb);
 			return this.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="551" endline="562">
<![CDATA[
 
 		public MethodToken GetConstructorToken(ConstructorInfo constructor)
 		{
 			if (constructor.Module == this && constructor.GetMethodInfo() is MethodBuilder)
 			{
 				return new MethodToken(constructor.MetadataToken);
 			}
 			else
 			{
 				return new MethodToken(ImportMember(constructor));
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="848" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1159" endline="1165">
<![CDATA[
 
 		internal int GetSignatureBlobIndex(Signature sig)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			sig.WriteSig(this, bb);
 			return this.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="374" endline="389">
<![CDATA[
 		}
 
 		internal int WriteBlob(ModuleBuilder moduleBuilder)
 		{
 			ByteBuffer bb = new ByteBuffer(100);
 			if (blob != null)
 			{
 				bb.Write(blob);
 			}
 			else
 			{
 				BlobWriter bw = new BlobWriter(moduleBuilder, this, bb);
 				bw.WriteCustomAttributeBlob();
 			}
 			return moduleBuilder.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="849" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1159" endline="1165">
<![CDATA[
 
 		internal int GetSignatureBlobIndex(Signature sig)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			sig.WriteSig(this, bb);
 			return this.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="38" endline="47">
<![CDATA[
 		{
 			int pos = mw.Position;
 			WriteImpl(mw);
 			Debug.Assert(mw.Position == pos + unalignedlength);
 			int align = Length - unalignedlength;
 			for (int i = 0; i < align; i++)
 			{
 				mw.Write((byte)0);
 			}
 			for (int i = 0; i < align; i++)
 			{
 				mw.Write((byte)0);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="850" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="228" endline="237">
<![CDATA[
 
 		#region IAssignMethod Members
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Emit (ec);
 
 			if (leave_copy)
 				Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="219" endline="227">
<![CDATA[
 		}
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			if (leave_copy)
 				Load (ec);
 
 			Emit (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="851" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="61" endline="72">
<![CDATA[
 
     ''' <summary>
     ''' Returns nothing if it is not a handles clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property HandlesClause() As HandlesClause
         Get
             Helper.Assert(m_Clause IsNot Nothing)
             Return TryCast(m_Clause, HandlesClause)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="73" endline="85">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if it is not an implements clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ImplementsClause() As MemberImplementsClause
         Get
             helper.Assert(m_clause IsNot Nothing)
             Return TryCast(m_Clause, MemberImplementsClause)
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="852" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="210" endline="218">
<![CDATA[
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (this.IsGenericMethodDefinition)
 			{
 				return this;
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="270" endline="279">
<![CDATA[
 		}
 
 		public override Type GetGenericTypeDefinition()
 		{
 			if (IsGenericTypeDefinition)
 			{
 				return this;
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="853" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="196" endline="202">
<![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="83" endline="89">
<![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
         AddAttribute()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="854" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="196" endline="202">
<![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="425" endline="434">
<![CDATA[
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="855" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="196" endline="202">
<![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="355" endline="365">
<![CDATA[
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="856" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="196" endline="202">
<![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="414" endline="424">
<![CDATA[
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="857" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="196" endline="202">
<![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="34" endline="40">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_CustomAttributes IsNot Nothing Then m_CustomAttributes.Initialize(Me)
         Helper.Assert(m_Name IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="858" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="107" endline="116">
<![CDATA[
     End Property
 
     ReadOnly Property OperandTypeCode() As TypeCode
         Get
             Dim result As TypeCode
 
             result = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, LeftType, RightType)
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InstanceExpression.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim tp As TypeDeclaration
         tp = Me.FindFirstParent(Of TypeDeclaration)()
         m_ExpressionType = tp.CecilType
 
         '        Classification = New ValueClassification(Me, m_ExpressionType)
         'SPECBUG
         Classification = New VariableClassification(Me, Me, m_ExpressionType)
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="859" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="107" endline="116">
<![CDATA[
     End Property
 
     ReadOnly Property OperandTypeCode() As TypeCode
         Get
             Dim result As TypeCode
 
             result = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, LeftType, RightType)
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="54" endline="62">
<![CDATA[
 
     Public Property ConstantValue() As Object
         Get
             If m_ResolvedMember = False Then
                 'Helper.StopIfDebugging()
                 ResolveMember(ResolveInfo.Default(Compiler))
             End If
             Return m_FieldBuilderCecil.Constant
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="860" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="84" endline="93">
<![CDATA[
 		}
 
 		public static MonoSymbolWriter symwriter;
 
 		public static void DefineLocalVariable (string name, LocalBuilder builder)
 		{
 			if (symwriter != null) {
 				symwriter.DefineLocalVariable (builder.LocalIndex, name);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="142" endline="148">
<![CDATA[
 
 		public static void DefineScopeVariable (int scope, LocalBuilder builder)
 		{
 			if (symwriter != null) {
 				symwriter.DefineScopeVariable (scope, builder.LocalIndex);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="861" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="699" endline="705">
<![CDATA[
     End Property
 
     ReadOnly Property DefinedParametersTypes() As Mono.Cecil.TypeReference()
         Get
             If m_DefinedParametersTypes Is Nothing Then m_DefinedParametersTypes = Helper.GetTypes(DefinedParameters)
             Return m_DefinedParametersTypes
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="692" endline="698">
<![CDATA[
     End Property
 
     ReadOnly Property DefinedParameters() As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Get
             If m_DefinedParameters Is Nothing Then m_DefinedParameters = Helper.GetParameters(Compiler, Member)
             Return m_DefinedParameters
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="862" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="563" endline="572">
<![CDATA[
 
 		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
 			Report.Debug (64, "ADD COMPILER GENERATED CLASS", this, c);
 
 			if (compiler_generated == null)
 				compiler_generated = new List<CompilerGeneratedClass> ();
 
 			compiler_generated.Add (c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1249" endline="1259">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (Declarator decl)
 		{
 			if (declarators == null)
 				declarators = new List<Declarator> ();
 
 			declarators.Add (decl);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="863" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="563" endline="572">
<![CDATA[
 
 		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
 			Report.Debug (64, "ADD COMPILER GENERATED CLASS", this, c);
 
 			if (compiler_generated == null)
 				compiler_generated = new List<CompilerGeneratedClass> ();
 
 			compiler_generated.Add (c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="409" endline="415">
<![CDATA[
 
 		public virtual void RemoveTypeContainer (TypeContainer next_part)
 		{
 			if (types != null)
 				types.Remove (next_part);
 			RemoveMemberType (next_part);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="864" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="563" endline="572">
<![CDATA[
 
 		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
 			Report.Debug (64, "ADD COMPILER GENERATED CLASS", this, c);
 
 			if (compiler_generated == null)
 				compiler_generated = new List<CompilerGeneratedClass> ();
 
 			compiler_generated.Add (c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="338" endline="349">
<![CDATA[
 
 		public TypeContainer AddTypeContainer (TypeContainer tc)
 		{
 			if (!AddMemberType (tc))
 				return tc;
 
 			if (types == null)
 				types = new List<TypeContainer> ();
 
 			types.Add (tc);
 			return tc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="865" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="563" endline="572">
<![CDATA[
 
 		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
 			Report.Debug (64, "ADD COMPILER GENERATED CLASS", this, c);
 
 			if (compiler_generated == null)
 				compiler_generated = new List<CompilerGeneratedClass> ();
 
 			compiler_generated.Add (c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="243" endline="258">
<![CDATA[
 
 		//
 		// Creates a link between hoisted variable block and the anonymous method storey
 		//
 		// An anonymous method can reference variables from any outer block, but they are
 		// hoisted in their own ExplicitBlock. When more than one block is referenced we
 		// need to create another link between those variable storeys
 		//
 		public void AddReferenceFromChildrenBlock (ExplicitBlock block)
 		{
 			if (children_references == null)
 				children_references = new List<ExplicitBlock> ();
 
 			if (!children_references.Contains (block))
 				children_references.Add (block);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="866" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="563" endline="572">
<![CDATA[
 
 		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
 			Report.Debug (64, "ADD COMPILER GENERATED CLASS", this, c);
 
 			if (compiler_generated == null)
 				compiler_generated = new List<CompilerGeneratedClass> ();
 
 			compiler_generated.Add (c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="327" endline="337">
<![CDATA[
 
 		public void AddConstant (Const constant)
 		{
 			if (!AddMember (constant))
 				return;
 
 			if (constants == null)
 				constants = new List<MemberCore> ();
 			
 			constants.Add (constant);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="867" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="563" endline="572">
<![CDATA[
 
 		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
 			Report.Debug (64, "ADD COMPILER GENERATED CLASS", this, c);
 
 			if (compiler_generated == null)
 				compiler_generated = new List<CompilerGeneratedClass> ();
 
 			compiler_generated.Add (c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="552" endline="562">
<![CDATA[
 
 		public void AddOperator (Operator op)
 		{
 			if (!AddMember (op))
 				return;
 
 			if (operators == null)
 				operators = new List<MemberCore> ();
 
 			operators.Add (op);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="868" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="563" endline="572">
<![CDATA[
 
 		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
 			Report.Debug (64, "ADD COMPILER GENERATED CLASS", this, c);
 
 			if (compiler_generated == null)
 				compiler_generated = new List<CompilerGeneratedClass> ();
 
 			compiler_generated.Add (c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="527" endline="537">
<![CDATA[
 
 		public void AddEvent (Event e)
 		{
 			if (!AddMember (e))
 				return;
 
 			if (events == null)
 				events = new List<MemberCore> ();
 
 			events.Add (e);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="869" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1701" endline="1707">
<![CDATA[
 
 		int peek_char2 ()
 		{
 			if (putback_char != -1)
 				return putback_char;
 			return reader.Peek ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1694" endline="1700">
<![CDATA[
 
 		int peek_char ()
 		{
 			if (putback_char == -1)
 				putback_char = reader.Read ();
 			return putback_char;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="870" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1583" endline="1592">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			parameters.VerifyClsCompliance (this);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="39" endline="50">
<![CDATA[
 
 		public static bool CheckContext (ResolveContext ec, Location loc)
 		{
 			if (!ec.CurrentAnonymousMethod.IsIterator) {
 				ec.Report.Error (1621, loc,
 					      "The yield statement cannot be used inside " +
 					      "anonymous method blocks");
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="871" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1583" endline="1592">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			parameters.VerifyClsCompliance (this);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1359" endline="1368">
<![CDATA[
 
 		#region Properties
 
 		public override TypeSpec BaseType {
 			get {
 				if (cache == null || (state & StateFlags.PendingBaseTypeInflate) != 0)
 					InitializeMemberCache (true);
 
 				return base.BaseType;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="872" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1583" endline="1592">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			parameters.VerifyClsCompliance (this);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="819" endline="829">
<![CDATA[
 
 		static string GetLookupName (MemberCore mc)
 		{
 			if (mc is Indexer)
 				return IndexerNameAlias;
 
 			if (mc is Constructor)
 				return Constructor.ConstructorName;
 
 			return mc.MemberName.Name;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="873" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1222" endline="1232">
<![CDATA[
 
 		protected override MethodSpec ResolveConstructor (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveConstructor (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1233" endline="1243">
<![CDATA[
 
 		protected override bool ResolveNamedArguments (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveNamedArguments (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="874" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1222" endline="1232">
<![CDATA[
 
 		protected override MethodSpec ResolveConstructor (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveConstructor (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="827" endline="839">
<![CDATA[
 
 		//
 		// Generates xml doc comments (if any), and if required,
 		// handle warning report.
 		//
 		internal virtual void GenerateDocComment (DeclSpace ds)
 		{
 			try {
 				DocUtil.GenerateDocComment (this, ds, Report);
 			} catch (Exception e) {
 				throw new InternalErrorException (this, e);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="875" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2117" endline="2124">
<![CDATA[
 
 		public override string AssemblyQualifiedName
 		{
 			get
 			{
 				string fn = FullName;
 				return fn == null ? null 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="88" endline="101">
<![CDATA[
 
 		internal static FieldSignature ReadSig(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.ReadByte() != FIELD)
 			{
 				throw new BadImageFormatException();
 			}
 			Type fieldType;
 			Type[] optionalCustomModifiers;
 			Type[] requiredCustomModifiers;
 			ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
 			fieldType = ReadType(module, br, context);
 			return new FieldSignature(fieldType, optionalCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="876" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2117" endline="2124">
<![CDATA[
 
 		public override string AssemblyQualifiedName
 		{
 			get
 			{
 				string fn = FullName;
 				return fn == null ? null 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="201" endline="211">
<![CDATA[
 
 		public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize)
 		{
 			if (parent == null && (attr & TypeAttributes.Interface) == 0)
 			{
 				parent = universe.System_Object;
 			}
 			TypeBuilder typeBuilder = new TypeBuilder(this, name, parent, attr);
 			PostDefineType(typeBuilder, packingSize, typesize);
 			return typeBuilder;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="877" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="48" endline="55">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As Mono.Cecil.TypeReference, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_ReturnType = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="56" endline="63">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="878" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="48" endline="55">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As Mono.Cecil.TypeReference, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_ReturnType = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="64" endline="71">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="879" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="123" endline="129">
<![CDATA[
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
     Private m_FoundObjects As New Generic.List(Of Object)
 
     Private Name As ParsedObject
     Private FromWhere As BaseObject
     Private m_IsImportsResolution As Boolean
     Private m_Qualifier As TypeNameResolutionInfo
     Private m_TypeArgumentCount As Integer
     Private m_IsAttributeTypeName As Boolean
 
 
     Property IsAttributeTypeName() As Boolean
         Get
             Return m_IsAttributeTypeName
         End Get
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="45" endline="55">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="880" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="123" endline="129">
<![CDATA[
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
     Private m_FoundObjects As New Generic.List(Of Object)
 
     Private Name As ParsedObject
     Private FromWhere As BaseObject
     Private m_IsImportsResolution As Boolean
     Private m_Qualifier As TypeNameResolutionInfo
     Private m_TypeArgumentCount As Integer
     Private m_IsAttributeTypeName As Boolean
 
 
     Property IsAttributeTypeName() As Boolean
         Get
             Return m_IsAttributeTypeName
         End Get
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="56" endline="66">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="881" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="123" endline="129">
<![CDATA[
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
     Private m_FoundObjects As New Generic.List(Of Object)
 
     Private Name As ParsedObject
     Private FromWhere As BaseObject
     Private m_IsImportsResolution As Boolean
     Private m_Qualifier As TypeNameResolutionInfo
     Private m_TypeArgumentCount As Integer
     Private m_IsAttributeTypeName As Boolean
 
 
     Property IsAttributeTypeName() As Boolean
         Get
             Return m_IsAttributeTypeName
         End Get
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="67" endline="78">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), Identifier.Name)
 
         m_VariableIdentifier = New VariableIdentifier(Me, Identifier)
         m_IsNew = IsNew
         m_TypeName = New TypeName(Me, TypeName)
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="882" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="113" endline="121">
<![CDATA[
     End Property
 
     Property TypeParameterConstraints() As TypeParameterConstraints
         Get
             If m_TypeParameterConstraints Is Nothing Then
                 m_TypeParameterConstraints = New TypeParameterConstraints(Me)
             End If
             Return m_TypeParameterConstraints
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="60" endline="67">
<![CDATA[
 
     ReadOnly Property PositionalArgumentList() As AttributePositionalArgumentList
         Get
             If m_AttributePositionalArgumentList Is Nothing Then
                 m_AttributePositionalArgumentList = New AttributePositionalArgumentList(Me)
             End If
             Return m_AttributePositionalArgumentList
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="883" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="85" endline="91">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As TypeName)
         MyBase.Init(Modifiers, Name)
         m_TypeName = VariableType
 
         Helper.Assert(m_TypeName IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="47" endline="53">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal TokenReader As Scanner)
     Private m_ShowErrors As Boolean = True
 
     Private ReadOnly Property ShowErrors() As Boolean
         Get
             Return m_ShowErrors
         End Get
     End Property
 
     Public ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         tm = m_Compiler.tm
         Helper.Assert(tm IsNot Nothing)
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal TokenReader As Scanner)
         m_Compiler = Compiler
         tm = New tm(Compiler, TokenReader)
         tm.NextToken()
         Helper.Assert(tm IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="884" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="85" endline="91">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As TypeName)
         MyBase.Init(Modifiers, Name)
         m_TypeName = VariableType
 
         Helper.Assert(m_TypeName IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" startline="283" endline="290">
<![CDATA[
 
     Protected Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent)
         m_LeftExpression = LExp
         m_LeftExpression.Parent = Me
         m_RightExpression = RExp
         m_RightExpression.Parent = Me
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="885" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="85" endline="91">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String, ByVal VariableType As TypeName)
         MyBase.Init(Modifiers, Name)
         m_TypeName = VariableType
 
         Helper.Assert(m_TypeName IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetRefExpression.vb" startline="34" endline="51">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Automatically resolved.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Expression"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.new(Parent)
         m_Expression = Expression
         m_ExpressionType = Parent.Compiler.TypeManager.MakeByRefType(Parent, Expression.ExpressionType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Throw New InternalException(Me)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="886" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="39" endline="45">
<![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal IsResumeNext As Boolean, ByVal Label As Token, ByVal IsGotoMinusOne As Boolean, ByVal IsGotoZero As Boolean)
         MyBase.New(Parent)
         m_IsResumeNext = IsResumeNext
         m_Label = Label
         m_IsGotoMinusOne = IsGotoMinusOne
         m_IsGotoZero = IsGotoZero
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" startline="146" endline="152">
<![CDATA[
 
     Public Sub New(ByVal FileIndex As UShort, ByVal StartLine As UInteger, ByVal StartColumn As Byte, Optional ByVal EndColumn As Byte = 0)
         m_EndColumn = EndColumn
         m_FileIndex = FileIndex + 1US
         m_Line = StartLine
         m_Column = StartColumn
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="887" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="73" endline="81">
<![CDATA[
 
     Shadows Sub Init(ByVal Condition As Expression, ByVal FalseCode As CodeBlock, ByVal TrueCode As CodeBlock, ByVal OneLiner As Boolean, ByVal ElseIfs As BaseObjects(Of ElseIfStatement))
         MyBase.Init(TrueCode)
 
         m_Condition = Condition
         m_FalseCode = FalseCode
         m_ElseIfs = ElseIfs
         m_OneLiner = OneLiner
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="81" endline="90">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal ArgumentList As ArgumentList, ByVal VariableInitializer As VariableInitializer, ByVal IsVariableDeclaration As Boolean, ByVal VariableDeclaration As LocalVariableDeclaration)
         m_Identifier = Identifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_ArgumentList = ArgumentList
         m_VariableInitializer = VariableInitializer
         m_IsVariableDeclaration = IsVariableDeclaration
         m_VariableDeclaration = VariableDeclaration
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="888" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="73" endline="81">
<![CDATA[
 
     Shadows Sub Init(ByVal Condition As Expression, ByVal FalseCode As CodeBlock, ByVal TrueCode As CodeBlock, ByVal OneLiner As Boolean, ByVal ElseIfs As BaseObjects(Of ElseIfStatement))
         MyBase.Init(TrueCode)
 
         m_Condition = Condition
         m_FalseCode = FalseCode
         m_ElseIfs = ElseIfs
         m_OneLiner = OneLiner
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="84" endline="96">
<![CDATA[
     End Property
 
     Sub Init(ByVal Attributes As Attributes, ByVal Modifiers As Modifiers, ByVal ParameterIdentifier As ParameterIdentifier, ByVal TypeName As TypeName, ByVal ConstantExpression As Expression)
         m_CustomAttributes = Attributes
         m_Modifiers = Modifiers
         m_ParameterIdentifier = ParameterIdentifier
         m_TypeName = TypeName
         m_ConstantExpression = ConstantExpression
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
 
         UpdateDefinition()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="889" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="58" endline="66">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="59" endline="67">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="890" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="37" endline="44">
<![CDATA[
 
     Shared Function IsUnaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="891" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="892" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" startline="53" endline="60">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="893" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" startline="43" endline="50">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="894" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="64" endline="71">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="895" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" startline="72" endline="79">
<![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="896" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="103" endline="115">
<![CDATA[
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="897" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="47" endline="54">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="898" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CastExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="207" endline="223">
<![CDATA[
 
     Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_TypeName Is Nothing AndAlso Location.File(Compiler).IsOptionStrictOn Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30209, Me.Location) AndAlso result
         End If
 
         If m_ConstantExpression Is Nothing Then
             Helper.AddError(Me, "No constant expression.")
             Return False
         End If
 
         result = ResolveConstantValue(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="899" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="76" endline="88">
<![CDATA[
 
 		protected abstract int GetLength();
 	}
 
 	sealed class TableHeap 
 	{
 		internal void Freeze(MetadataWriter mw)
 		{
 			if (frozen)
 				throw new InvalidOperationException();
 			frozen = true;
 			unalignedlength = GetLength(mw);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="62" endline="75">
<![CDATA[
 		}
 
 		protected abstract void WriteImpl(MetadataWriter mw);
 	}
 
 	abstract class SimpleHeap 
 	{
 		internal void Freeze()
 		{
 			if (frozen)
 				throw new InvalidOperationException();
 			frozen = true;
 			unalignedlength = GetLength();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="900" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="47" endline="59">
<![CDATA[
     End Property
 End Class
 
 Public Class LoadLocalExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" startline="81" endline="94">
<![CDATA[
 End Class
 
 Public Class LoadElementExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     Private m_Index As Integer
 
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition, ByVal Index As Integer)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
         m_Index = Index
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="901" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="298" endline="316">
<![CDATA[
 	}
 
 	sealed class BlobHeap 
 	{
 		private Key[] map = new Key[8179];
 		private readonly ByteBuffer buf = new ByteBuffer(32);
 
 		private struct Key
 		{
 			internal Key[] next;
 			internal int len;
 			internal int hash;
 			internal int offset;
 		}
 
 		internal BlobHeap()
 		{
 			buf.Write((byte)0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="239" endline="251">
<![CDATA[
 		}
 
 		private void WriteRVA(MetadataWriter mw, uint rva)
 		{
 			if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 			{
 				mw.Write(rva);
 			}
 			else
 			{
 				mw.Write((ulong)rva);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="902" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="134" endline="141">
<![CDATA[
 
 		internal void FixupToken(int parameterToken)
 		{
 			if (lazyPseudoToken != 0)
 			{
 				moduleBuilder.RegisterTokenFixup(lazyPseudoToken, parameterToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="47" endline="58">
<![CDATA[
 
 		internal int PseudoToken
 		{
 			get
 			{
 				if (lazyPseudoToken == 0)
 				{
 					// we lazily create the token, because if we don't need it we don't want the token fixup cost
 					lazyPseudoToken = moduleBuilder.AllocPseudoToken();
 				}
 				return lazyPseudoToken;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="903" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="112" endline="119">
<![CDATA[
 
 		public void SetOffset(int iOffset)
 		{
 			FieldLayoutTable.Record rec = new FieldLayoutTable.Record();
 			rec.Offset = iOffset;
 			rec.Field = pseudoToken;
 			typeBuilder.ModuleBuilder.FieldLayout.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="221" endline="229">
<![CDATA[
 
 		private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
 		{
 			MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
 			rec.Semantics = semantics;
 			rec.Method = methodToken;
 			rec.Association = propertyToken;
 			typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="904" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="112" endline="119">
<![CDATA[
 
 		public void SetOffset(int iOffset)
 		{
 			FieldLayoutTable.Record rec = new FieldLayoutTable.Record();
 			rec.Offset = iOffset;
 			rec.Field = pseudoToken;
 			typeBuilder.ModuleBuilder.FieldLayout.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="65" endline="74">
<![CDATA[
 
 		public void __SetDataAndRVA(byte[] data)
 		{
 			attribs |= FieldAttributes.HasFieldRVA;
 			FieldRVATable.Record rec = new FieldRVATable.Record();
 			rec.RVA = typeBuilder.ModuleBuilder.initializedData.Position;
 			rec.Field = pseudoToken;
 			typeBuilder.ModuleBuilder.FieldRVA.AddRecord(rec);
 			typeBuilder.ModuleBuilder.initializedData.Write(data);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="905" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="112" endline="119">
<![CDATA[
 
 		public void SetOffset(int iOffset)
 		{
 			FieldLayoutTable.Record rec = new FieldLayoutTable.Record();
 			rec.Offset = iOffset;
 			rec.Field = pseudoToken;
 			typeBuilder.ModuleBuilder.FieldLayout.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="196" endline="204">
<![CDATA[
 
 		private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
 		{
 			MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
 			rec.Semantics = semantics;
 			rec.Method = methodToken;
 			rec.Association = propertyToken;
 			typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="906" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="112" endline="119">
<![CDATA[
 
 		public void SetOffset(int iOffset)
 		{
 			FieldLayoutTable.Record rec = new FieldLayoutTable.Record();
 			rec.Offset = iOffset;
 			rec.Field = pseudoToken;
 			typeBuilder.ModuleBuilder.FieldLayout.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1177" endline="1186">
<![CDATA[
 		}
 
 		private int AddTypeRefByName(int resolutionScope, string ns, string name)
 		{
 			TypeRefTable.Record rec = new TypeRefTable.Record();
 			rec.ResolutionScope = resolutionScope;
 			rec.TypeName = this.Strings.Add(name);
 			rec.TypeNameSpace = ns == null ? 0 
 			return 0x01000000 | this.TypeRef.AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="907" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="234" endline="241">
<![CDATA[
 
     Function Clone(ByVal Context As ParsedObject, ByVal DesiredType As Mono.Cecil.TypeReference) As EmitInfo
         Dim result As New EmitInfo(Me)
         result.m_DesiredType = DesiredType
         result.m_RHSExpression = Nothing
         result.m_Context = Context
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="198" endline="214">
<![CDATA[
 
     ''' <summary>
     ''' Clone the emitinfo for a left hand side expression.
     ''' </summary>
     ''' <param name="RHSExpression"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Clone(ByVal Context As ParsedObject, ByVal RHSExpression As Expression) As EmitInfo
         Dim result As New EmitInfo(Me)
 
         result.m_IsRHS = False
         result.m_RHSExpression = RHSExpression
         result.m_DesiredType = Nothing
         result.m_Context = Context
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="908" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="234" endline="241">
<![CDATA[
 
     Function Clone(ByVal Context As ParsedObject, ByVal DesiredType As Mono.Cecil.TypeReference) As EmitInfo
         Dim result As New EmitInfo(Me)
         result.m_DesiredType = DesiredType
         result.m_RHSExpression = Nothing
         result.m_Context = Context
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" startline="215" endline="233">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Context"></param>
     ''' <param name="IsRHS">Default = True</param>
     ''' <param name="IsExplicitConversion"></param>
     ''' <param name="DesiredType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Clone(ByVal Context As ParsedObject, ByVal IsRHS As Boolean, Optional ByVal IsExplicitConversion As Boolean = False, Optional ByVal DesiredType As Mono.Cecil.TypeReference = Nothing) As EmitInfo
         Dim result As New EmitInfo(Me)
         result.m_IsRHS = IsRHS
         result.m_IsExplicitConversion = IsExplicitConversion
         result.m_DesiredType = DesiredType
         result.m_RHSExpression = Nothing
         result.m_Context = Context
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="909" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3023" endline="3032">
<![CDATA[
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3033" endline="3041">
<![CDATA[
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="910" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3023" endline="3032">
<![CDATA[
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3897" endline="3912">
<![CDATA[
 	}
 
 	// A place where execution can restart in an iterator
 	public abstract class ResumableStatement 
 	{
 		bool prepared;
 		protected Label resume_point;
 
 		public Label PrepareForEmit (EmitContext ec)
 		{
 			if (!prepared) {
 				prepared = true;
 				resume_point = ec.DefineLabel ();
 			}
 			return resume_point;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="911" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3023" endline="3032">
<![CDATA[
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4025" endline="4033">
<![CDATA[
 
 		public override Label PrepareForDispose (EmitContext ec, Label end)
 		{
 			if (!prepared_for_dispose) {
 				prepared_for_dispose = true;
 				dispose_try_block = ec.DefineLabel ();
 			}
 			return dispose_try_block;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="912" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3023" endline="3032">
<![CDATA[
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="868" endline="877">
<![CDATA[
 
 		public Label LabelTarget (EmitContext ec)
 		{
 			if (defined)
 				return label;
 
 			label = ec.DefineLabel ();
 			defined = true;
 			return label;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="913" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="421" endline="432">
<![CDATA[
 		}
 
 		public IList<CustomAttributeTypedArgument> ConstructorArguments
 		{
 			get
 			{
 				if (lazyConstructorArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyConstructorArguments;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="433" endline="444">
<![CDATA[
 		}
 
 		public IList<CustomAttributeNamedArgument> NamedArguments
 		{
 			get
 			{
 				if (lazyNamedArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyNamedArguments;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="914" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="73" endline="82">
<![CDATA[
     End Property
 
     ReadOnly Property AddDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_AddMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_AddMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="83" endline="92">
<![CDATA[
     End Property
 
     ReadOnly Property RemoveDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RemoveMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RemoveMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="915" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="73" endline="82">
<![CDATA[
     End Property
 
     ReadOnly Property AddDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_AddMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_AddMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="93" endline="102">
<![CDATA[
     End Property
 
     ReadOnly Property RaiseDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RaiseMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RaiseMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="916" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="44" endline="51">
<![CDATA[
 		internal PropertyBuilder(TypeBuilder typeBuilder, string name, PropertyAttributes attributes, PropertySignature sig, bool patchCallingConvention)
 		{
 			this.typeBuilder = typeBuilder;
 			this.name = name;
 			this.attributes = attributes;
 			this.sig = sig;
 			this.patchCallingConvention = patchCallingConvention;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="62" endline="71">
<![CDATA[
 
 		public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, PropertyInfo[] namedProperties, object[] propertyValues, FieldInfo[] namedFields, object[] fieldValues)
 		{
 			this.con = con;
 			this.constructorArgs = constructorArgs;
 			this.namedProperties = namedProperties;
 			this.propertyValues = propertyValues;
 			this.namedFields = namedFields;
 			this.fieldValues = fieldValues;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="917" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="465" endline="473">
<![CDATA[
 
 		public void AddInterfaceImplementation(Type interfaceType)
 		{
 			if (interfaces == null)
 			{
 				interfaces = new List<Type>();
 			}
 			interfaces.Add(interfaceType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="77" endline="86">
<![CDATA[
 
 		public void AddOtherMethod(MethodBuilder mdBuilder)
 		{
 			PatchCallingConvention(mdBuilder);
 			if (otherMethods == null)
 			{
 				otherMethods = new List<MethodBuilder>();
 			}
 			otherMethods.Add(mdBuilder);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="918" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="465" endline="473">
<![CDATA[
 
 		public void AddInterfaceImplementation(Type interfaceType)
 		{
 			if (interfaces == null)
 			{
 				interfaces = new List<Type>();
 			}
 			interfaces.Add(interfaceType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="36" endline="53">
<![CDATA[
 		private readonly List<Type> args = new List<Type>();
 		private readonly List<LocalBuilder> locals = new List<LocalBuilder>();
 		private readonly List<Type[]> requiredCustomModifiers = new List<Type[]>();
 		private readonly List<Type[]> optionalCustomModifiers = new List<Type[]>();
 		private readonly List<Type> optionalArgs = new List<Type>();
 		private Type returnType;
 		private Type[] returnTypeRequiredCustomModifiers;
 		private Type[] returnTypeOptionalCustomModifiers;
 		private CallingConventions callingConvention;
 		private CallingConvention unmanagedCallConv;
 		private bool unmanaged;
 		private bool optional;
 
 		private SignatureHelper(ModuleBuilder module, byte type)
 		{
 			this.module = module;
 			this.type = type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="919" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="160" endline="166">
<![CDATA[
 
 		public string Basename {
 			get {
 				if (TypeArguments != null)
 					return MakeName (Name, TypeArguments);
 				return Name;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2150" endline="2158">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			if (targs != null) {
 				return Name + "<" + targs.GetSignatureForError () + ">";
 			}
 
 			return Name;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="920" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1096" endline="1103">
<![CDATA[
 
 		public int GetFieldIndex (string name)
 		{
 			if (struct_info == null)
 				return 0;
 
 			return struct_info [name];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="870" endline="878">
<![CDATA[
 		}
 
 		public bool IsUnsafe {
 			get {
 				if ((ModFlags & Modifiers.UNSAFE) != 0)
 					return true;
 
 				return Parent == null ? false 
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="921" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1096" endline="1103">
<![CDATA[
 
 		public int GetFieldIndex (string name)
 		{
 			if (struct_info == null)
 				return 0;
 
 			return struct_info [name];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4830" endline="4838">
<![CDATA[
 
 		public override bool Equals (object obj)
 		{
 			LocalVariableReference lvr = obj as LocalVariableReference;
 			if (lvr == null)
 				return false;
 
 			return local_info == lvr.local_info;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="922" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1096" endline="1103">
<![CDATA[
 
 		public int GetFieldIndex (string name)
 		{
 			if (struct_info == null)
 				return 0;
 
 			return struct_info [name];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5134" endline="5141">
<![CDATA[
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			bool is_volatile = (spec.Modifiers & Modifiers.VOLATILE) != 0;
 
 			if (is_volatile) // || is_marshal_by_ref ())
 				base.EmitSideEffect (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="923" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1096" endline="1103">
<![CDATA[
 
 		public int GetFieldIndex (string name)
 		{
 			if (struct_info == null)
 				return 0;
 
 			return struct_info [name];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="727" endline="737">
<![CDATA[
 
 		/// <summary>
 		/// Returns true if MemberCore is explicitly marked with CLSCompliantAttribute
 		/// </summary>
 		protected bool HasClsCompliantAttribute {
 			get {
 				if ((caching_flags & Flags.HasCompliantAttribute_Undetected) != 0)
 					IsNotCLSCompliant ();
 				
 				return (caching_flags & Flags.HasClsCompliantAttribute) != 0;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="924" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1096" endline="1103">
<![CDATA[
 
 		public int GetFieldIndex (string name)
 		{
 			if (struct_info == null)
 				return 0;
 
 			return struct_info [name];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1450" endline="1459">
<![CDATA[
 
 		public bool IsFieldAssigned (MyBitVector vector, string field_name)
 		{
 			int field_idx = TypeInfo.GetFieldIndex (field_name);
 
 			if (field_idx == 0)
 				return true;
 
 			return vector [Offset + field_idx];
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="925" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="365" endline="372">
<![CDATA[
 
     Shared Sub EmitIsInst(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         Dim toOriginal As Mono.Cecil.TypeReference = ToType
 
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Info.ILGen.Emit(OpCodes.Isinst, ToType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="358" endline="364">
<![CDATA[
 
     Shared Sub EmitCastClass(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Helper.Assert(CecilHelper.IsByRef(ToType) = False)
         Info.ILGen.Emit(OpCodes.Castclass, ToType)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="926" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="365" endline="372">
<![CDATA[
 
     Shared Sub EmitIsInst(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         Dim toOriginal As Mono.Cecil.TypeReference = ToType
 
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Info.ILGen.Emit(OpCodes.Isinst, ToType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1340" endline="1353">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadValueAddress(ByVal Info As EmitInfo, ByVal Value As Object)
         Helper.Assert(CecilHelper.IsByRef(Info.DesiredType))
         EmitLoadValue(Info.Clone(Info.Context, CecilHelper.GetElementType(Info.DesiredType)), Value)
         Dim local As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Info.Compiler, CecilHelper.GetElementType(Info.DesiredType)))
         EmitStoreVariable(Info, local)
         EmitLoadVariableLocation(Info, local)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="927" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="242" endline="250">
<![CDATA[
 
 		internal void DefineCapturedScope (int scope_id, int id, string captured_name)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedScope (id, captured_name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="232" endline="241">
<![CDATA[
 
 		internal void DefineCapturedVariable (int scope_id, string name, string captured_name,
 						      CapturedVariable.CapturedKind kind)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedVariable (name, captured_name, kind);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="928" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1153" endline="1161">
<![CDATA[
 
 		public Type __MakeGenericType(Type[] typeArguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			if (!this.IsGenericTypeDefinition)
 			{
 				throw new InvalidOperationException();
 			}
 			return GenericTypeInstance.Make(this, Util.Copy(typeArguments), Util.Copy(requiredCustomModifiers), Util.Copy(optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="689" endline="695">
<![CDATA[
 
 		public void Emit(OpCode opc, MethodInfo method)
 		{
 			Emit(opc);
 			WriteToken(moduleBuilder.GetMethodTokenForIL(method));
 			UpdateStack(opc, method.HasThis, method.ReturnType, method.ParameterCount);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="929" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="99" endline="106">
<![CDATA[
 
 		public void AddDefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="107" endline="114">
<![CDATA[
 
 		public void AddUndefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="930" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" startline="40" endline="48">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadToken(Info, m_TypeName.ResolvedType)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="79" endline="88">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_MethodGroup.Resolved)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_MethodGroup.InstanceExpression, m_MethodGroup.FinalArguments, Helper.GetMethodOrMethodReference(Compiler, m_MethodGroup.ResolvedMethod))
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="931" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1645" endline="1653">
<![CDATA[
 
 		public void Emit (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Ldloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1654" endline="1662">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Stloc, builder);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="932" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1275" endline="1282">
<![CDATA[
 
 		public ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Obsolete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1283" endline="1290">
<![CDATA[
 
 		public bool IsNotCLSCompliant ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.IsNotCLSCompliant;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="933" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1275" endline="1282">
<![CDATA[
 
 		public ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Obsolete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1724" endline="1731">
<![CDATA[
 
 		public string GetAttributeDefaultMember ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.DefaultIndexerName;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="934" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1275" endline="1282">
<![CDATA[
 
 		public ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Obsolete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1262" endline="1274">
<![CDATA[
 		}
 
 		#endregion
 
 		public abstract List<MissingType> ResolveMissingDependencies ();
 
 		public string[] ConditionalConditions ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Conditionals;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="935" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1275" endline="1282">
<![CDATA[
 
 		public ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Obsolete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1716" endline="1723">
<![CDATA[
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.CoClass;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="936" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1275" endline="1282">
<![CDATA[
 
 		public ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Obsolete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1732" endline="1739">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.AttributeUsage;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="937" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="684" endline="693">
<![CDATA[
 		}
 
 		public SourceFileEntry (MonoSymbolFile file, string file_name)
 		{
 			this.file = file;
 			this.file_name = file_name;
 			this.Index = file.AddSource (this);
 
 			creating = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="537" endline="548">
<![CDATA[
 		}
 
 		public CompileUnitEntry (MonoSymbolFile file, SourceFileEntry source)
 		{
 			this.file = file;
 			this.source = source;
 
 			this.Index = file.AddCompileUnit (this);
 
 			creating = true;
 			namespaces = new List<NamespaceEntry> ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="938" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="684" endline="693">
<![CDATA[
 		}
 
 		public SourceFileEntry (MonoSymbolFile file, string file_name)
 		{
 			this.file = file;
 			this.file_name = file_name;
 			this.Index = file.AddSource (this);
 
 			creating = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="241" endline="266">
<![CDATA[
 	}
 
 	public class SourceMethodBuilder
 	{
 		List<LocalVariableEntry> _locals;
 		List<CodeBlockEntry> _blocks;
 		List<ScopeVariable> _scope_vars;
 #if NET_2_1
 		System.Collections.Stack _block_stack;
 #else		
 		Stack<CodeBlockEntry> _block_stack;
 #endif
 		string _real_name;
 		IMethodDef _method;
 		ICompileUnit _comp_unit;
 //		MethodEntry.Flags _method_flags;
 		int _ns_id;
 
 		public SourceMethodBuilder (ICompileUnit comp_unit, int ns_id, IMethodDef method)
 		{
 			this._comp_unit = comp_unit;
 			this._method = method;
 			this._ns_id = ns_id;
 
 			method_lines = new LineNumberEntry [32];
 		}
 
 		private LineNumberEntry [] method_lines;
 		private int method_lines_pos = 0;
 		public SourceMethodBuilder (ICompileUnit comp_unit, int ns_id, IMethodDef method)
 		{
 			this._comp_unit = comp_unit;
 			this._method = method;
 			this._ns_id = ns_id;
 
 			method_lines = new LineNumberEntry [32];
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="939" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="109" endline="120">
<![CDATA[
 
 		protected override bool DoResolveParameters (ResolveContext rc)
 		{
 			//
 			// Only explicit parameters can be resolved at this point
 			//
 			if (HasExplicitParameters) {
 				return Parameters.Resolve (rc);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="861" endline="869">
<![CDATA[
 		}
 
 		public bool IsObsolete {
 			get {
 				if (GetAttributeObsolete () != null)
 					return true;
 
 				return Parent == null ? false 
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="940" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="828" endline="835">
<![CDATA[
 
     Shared Function FilterByName(ByVal Types As TypeDictionary, ByVal Name As String) As Mono.Cecil.TypeReference
         If Types.ContainsKey(Name) Then
             Return Types(Name)
         Else
             Return Nothing
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" startline="56" endline="71">
<![CDATA[
 
     ''' <summary>
     ''' Returns nothing if the specified key is not found.
     ''' </summary>
     ''' <param name="key"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal key As String) As Mono.Cecil.TypeReference
         Get
             If MyBase.ContainsKey(key) Then
                 Return MyBase.Item(key)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="941" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2012" endline="2020">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldnull);
 
 			// Only to make verifier happy
 			if (TypeManager.IsGenericParameter (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="843" endline="850">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (label == null)
 				throw new InternalErrorException ("goto emitted before target resolved");
 			Label l = label.LabelTarget (ec);
 			ec.Emit (unwind_protect ? OpCodes.Leave 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="942" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2012" endline="2020">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldnull);
 
 			// Only to make verifier happy
 			if (TypeManager.IsGenericParameter (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="320" endline="334">
<![CDATA[
 
 		public void EmitArrayAddress (ArrayContainer ac)
 		{
 			if (ac.Element.IsGenericParameter)
 				ig.Emit (OpCodes.Readonly);
 
 			if (ac.Rank > 1) {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Call, ac.GetAddressMethod ());
 			} else {
 				Emit (OpCodes.Ldelema, ac.Element);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="943" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceBases.vb" startline="44" endline="53">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Bases IsNot Nothing)
         result = Helper.ResolveTypeReferencesCollection(m_Bases)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" startline="204" endline="213">
<![CDATA[
 
     Function DefineOverrides() As Boolean
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then
             result = m_ImplementsClause.DefineImplements(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="944" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="256" endline="264">
<![CDATA[
 		}
 
 		public void Store (EmitContext ec)
 		{
 			if (builder == null)
 				builder = ec.GetTemporaryLocal (type);
 
 			ec.Emit (OpCodes.Stloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="265" endline="280">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			if (builder == null)
 				builder = ec.GetTemporaryLocal (type);
 
 			if (builder.LocalType.IsByRef) {
 				//
 				// if is_address, than this is just the address anyways,
 				// so we just return this.
 				//
 				ec.Emit (OpCodes.Ldloc, builder);
 			} else {
 				ec.Emit (OpCodes.Ldloca, builder);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="945" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="256" endline="264">
<![CDATA[
 		}
 
 		public void Store (EmitContext ec)
 		{
 			if (builder == null)
 				builder = ec.GetTemporaryLocal (type);
 
 			ec.Emit (OpCodes.Stloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1903" endline="1939">
<![CDATA[
 
 
 		/// <summary>
 		/// Create the MethodBuilder for the method 
 		/// </summary>
 		void DefineMethodBuilder (TypeContainer container, string method_name, ParametersCompiled param)
 		{
 			var return_type = method.ReturnType.GetMetaInfo ();
 			var p_types = param.GetMetaInfo ();
 
 			if (builder == null) {
 				builder = container.TypeBuilder.DefineMethod (
 					method_name, flags, method.CallingConventions,
 					return_type, p_types);
 				return;
 			}
 
 			//
 			// Generic method has been already defined to resolve method parameters
 			// correctly when they use type parameters
 			//
 			builder.SetParameters (p_types);
 			builder.SetReturnType (return_type);
 			if (builder.Attributes != flags) {
 #if STATIC
 				builder.__SetAttributes (flags);
 #else
 				try {
 					if (methodbuilder_attrs_field == null)
 						methodbuilder_attrs_field = typeof (MethodBuilder).GetField ("attrs", BindingFlags.NonPublic | BindingFlags.Instance);
 					methodbuilder_attrs_field.SetValue (builder, flags);
 				} catch {
 					container.Compiler.Report.RuntimeMissingSupport (method.Location, "Generic method MethodAttributes");
 				}
 #endif
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="946" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="150" endline="161">
<![CDATA[
 
 		internal void WriteStringIndex(int index)
 		{
 			if (bigStrings)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="947" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="499" endline="512">
<![CDATA[
 
 		internal void WriteTypeOrMethodDef(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigTypeOrMethodDef)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="948" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="174" endline="185">
<![CDATA[
 
 		internal void WriteBlobIndex(int index)
 		{
 			if (bigBlobs)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="949" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="457" endline="470">
<![CDATA[
 
 		internal void WriteHasSemantics(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasSemantics)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="950" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="214" endline="225">
<![CDATA[
 
 		internal void WriteEncodedTypeDefOrRef(int encodedToken)
 		{
 			if (bigTypeDefOrRef)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="951" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="226" endline="239">
<![CDATA[
 
 		internal void WriteHasCustomAttribute(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasCustomAttribute)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="952" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="162" endline="173">
<![CDATA[
 
 		internal void WriteGuidIndex(int index)
 		{
 			if (bigGuids)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="953" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="287" endline="298">
<![CDATA[
 
 		internal void WriteParam(int index)
 		{
 			if (bigParam)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="954" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="513" endline="526">
<![CDATA[
 
 		internal void WriteHasDeclSecurity(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasDeclSecurity)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="955" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="311" endline="322">
<![CDATA[
 
 		internal void WriteEvent(int index)
 		{
 			if (bigEvent)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="956" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="550" endline="563">
<![CDATA[
 
 		internal void WriteHasFieldMarshal(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasFieldMarshal)
 			{
 				Write(encodedToken & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="957" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="347" endline="358">
<![CDATA[
 
 		internal void WriteModuleRef(int index)
 		{
 			if (bigModuleRef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="958" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="263" endline="274">
<![CDATA[
 
 		internal void WriteField(int index)
 		{
 			if (bigField)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="959" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="335" endline="346">
<![CDATA[
 
 		internal void WriteGenericParam(int index)
 		{
 			if (bigGenericParam)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="960" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="299" endline="310">
<![CDATA[
 
 		internal void WriteTypeDef(int index)
 		{
 			if (bigTypeDef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="961" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="323" endline="334">
<![CDATA[
 
 		internal void WriteProperty(int index)
 		{
 			if (bigProperty)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="962" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="443" endline="456">
<![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="275" endline="286">
<![CDATA[
 
 		internal void WriteMethodDef(int index)
 		{
 			if (bigMethodDef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="963" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1138" endline="1145">
<![CDATA[
 
 		public bool GetBoolean () 
 		{
 			Expression e = GetValue ();
 			if (e is BoolConstant)
 				return ((BoolConstant)e).Value;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1130" endline="1137">
<![CDATA[
 
 		public string GetString () 
 		{
 			Expression e = GetValue ();
 			if (e is StringConstant)
 				return ((StringConstant)e).Value;
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="964" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2698" endline="2706">
<![CDATA[
 
 		bool CheckFieldTypeCycle (TypeSpec ts)
 		{
 			var fts = ts.MemberDefinition as Struct;
 			if (fts == null)
 				return true;
 
 			return CheckStructCycles (fts);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="572" endline="584">
<![CDATA[
 		
 		//
 		// For queries like `from a orderby a select a'
 		// the projection is transparent and select clause can be safely removed 
 		//
 		public bool IsRequired (Parameter parameter)
 		{
 			SimpleName sn = expr as SimpleName;
 			if (sn == null)
 				return true;
 
 			return sn.Name != parameter.Name;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="965" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="420" endline="432">
<![CDATA[
 
     ''' <summary>
     ''' Compares two vb-names (case-insensitive)
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, StringComparison.OrdinalIgnoreCase)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="452" endline="464">
<![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareNameOrdinal(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, System.StringComparison.Ordinal)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="966" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="63" endline="77">
<![CDATA[
 		}
 
 		internal uint ImportAddressTableLength
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return 8;
 				}
 				else
 				{
 					return 16;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="220" endline="238">
<![CDATA[
 		}
 
 		internal uint StartupStubLength
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64)
 				{
 					return 12;
 				}
 				else if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64)
 				{
 					return 48;
 				}
 				else
 				{
 					return 6;
 				}
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="967" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="63" endline="77">
<![CDATA[
 		}
 
 		internal uint ImportAddressTableLength
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return 8;
 				}
 				else
 				{
 					return 16;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="98" endline="112">
<![CDATA[
 		}
 
 		private uint ResourcesRVA
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return (MethodBodiesRVA + MethodBodiesLength + 3) & ~3U;
 				}
 				else
 				{
 					return (MethodBodiesRVA + MethodBodiesLength + 15) & ~15U;
 				}
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="968" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="478" endline="490">
<![CDATA[
 		}
 
 		internal CustomAttributeBuilder DecodeBlob(Assembly asm)
 		{
 			if (blob == null)
 			{
 				return this;
 			}
 			else
 			{
 				return ToData(asm).__ToBuilder();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="209" endline="220">
<![CDATA[
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			if (type != null)
 			{
 				return binder.BindTypeParameter(this);
 			}
 			else
 			{
 				return binder.BindMethodParameter(this);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="969" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="209" endline="215">
<![CDATA[
 
     Sub New(ByVal Classification As VariableClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="230" endline="236">
<![CDATA[
 
     Sub New(ByVal Classification As MethodPointerClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="970" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="209" endline="215">
<![CDATA[
 
     Sub New(ByVal Classification As VariableClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="244" endline="250">
<![CDATA[
 
     Sub New(ByVal Classification As PropertyAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="971" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="209" endline="215">
<![CDATA[
 
     Sub New(ByVal Classification As VariableClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="216" endline="222">
<![CDATA[
 
     Sub New(ByVal Classification As PropertyGroupClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="972" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="209" endline="215">
<![CDATA[
 
     Sub New(ByVal Classification As VariableClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="223" endline="229">
<![CDATA[
 
     Sub New(ByVal Classification As MethodGroupClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="973" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="209" endline="215">
<![CDATA[
 
     Sub New(ByVal Classification As VariableClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="237" endline="243">
<![CDATA[
 
     Sub New(ByVal Classification As LateBoundAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="974" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="824" endline="830">
<![CDATA[
     End Property
 
     ReadOnly Property ParamArrayParameter() As Mono.Cecil.ParameterDefinition
         Get
             If m_IsParamArray = False Then Return Nothing
             Return m_DefinedParameters(m_DefinedParameters.Count - 1)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1263" endline="1269">
<![CDATA[
 
     Private Shared Sub AddPropertyUnlessSignatureMatches(ByVal properties As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference), ByVal prop As Mono.Cecil.PropertyReference)
         For i As Integer = 0 To properties.Count - 1
             If Helper.CompareParameterTypes(prop.Parameters, properties(i).Parameters) = True Then Return
         Next
         properties.Add(prop)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="975" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="824" endline="830">
<![CDATA[
     End Property
 
     ReadOnly Property ParamArrayParameter() As Mono.Cecil.ParameterDefinition
         Get
             If m_IsParamArray = False Then Return Nothing
             Return m_DefinedParameters(m_DefinedParameters.Count - 1)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="203" endline="217">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference))
         MyBase.New(Classifications.PropertyGroup, Parent)
         m_InstanceExpression = InstanceExpression
 
         m_Members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)()
         m_Members.AddRange(Members)
 #If DEBUG Then
         For i As Integer = 0 To Members.Count - 1
             For j As Integer = i + 1 To Members.Count - 1
                 Helper.Assert(Members(i) IsNot Members(j))
             Next
         Next
 #End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="976" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="125" endline="134">
<![CDATA[
     End Property
 
     Public ReadOnly Property GetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Get IsNot Nothing Then
                 Return m_Get.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="141" endline="150">
<![CDATA[
     End Property
 
     Public ReadOnly Property SetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Set IsNot Nothing Then
                 Return m_Set.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="977" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="125" endline="134">
<![CDATA[
     End Property
 
     Public ReadOnly Property GetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Get IsNot Nothing Then
                 Return m_Get.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="153" endline="162">
<![CDATA[
     End Property
 
     ReadOnly Property LocalBuilder() As Mono.Cecil.Cil.VariableDefinition
         Get
             If m_LocalVariable IsNot Nothing Then
                 Return m_LocalVariable.LocalBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="978" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1418" endline="1428">
<![CDATA[
 
 		public static ReferenceContainer MakeType (TypeSpec element)
 		{
 			ReferenceContainer pc;
 			if (!instances.TryGetValue (element, out pc)) {
 				pc = new ReferenceContainer (element);
 				instances.Add (element, pc);
 			}
 
 			return pc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1460" endline="1470">
<![CDATA[
 
 		public static PointerContainer MakeType (TypeSpec element)
 		{
 			PointerContainer pc;
 			if (!instances.TryGetValue (element, out pc)) {
 				pc = new PointerContainer (element);
 				instances.Add (element, pc);
 			}
 
 			return pc;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="979" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="119" endline="129">
<![CDATA[
 		}
 
 		public override MethodBody GetMethodBody()
 		{
 			IKVM.Reflection.Reader.MethodDefImpl md = method as IKVM.Reflection.Reader.MethodDefImpl;
 			if (md != null)
 			{
 				return md.GetMethodBody(this);
 			}
 			throw new NotSupportedException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="271" endline="280">
<![CDATA[
 
 		private static Type ReadType(Module module, ByteReader br)
 		{
 			string str = ReadString(br);
 			if (str == "")
 			{
 				return null;
 			}
 			return module.Assembly.GetType(str) ?? module.universe.GetType(str, true);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="980" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="119" endline="129">
<![CDATA[
 		}
 
 		public override MethodBody GetMethodBody()
 		{
 			IKVM.Reflection.Reader.MethodDefImpl md = method as IKVM.Reflection.Reader.MethodDefImpl;
 			if (md != null)
 			{
 				return md.GetMethodBody(this);
 			}
 			throw new NotSupportedException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1340" endline="1353">
<![CDATA[
 
 		public bool IsSubclassOf(Type type)
 		{
 			Type thisType = this.BaseType;
 			while (thisType != null)
 			{
 				if (thisType.Equals(type))
 				{
 					return true;
 				}
 				thisType = thisType.BaseType;
 			}
 			while (thisType != null)
 			{
 				if (thisType.Equals(type))
 				{
 					return true;
 				}
 				thisType = thisType.BaseType;
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="982" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="779" endline="788">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1)
         If chr = "X"c Then
             Return Nothing
         Else
             Return GetTypeCodeOfChar(chr)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="311" endline="323">
<![CDATA[
 
     Function ResolveAddressOfExpression(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Dim aoe As AddressOfExpression = TryCast(Me, AddressOfExpression)
 
         If aoe Is Nothing Then
             result = False
         Else
             result = aoe.Resolve(DelegateType) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="984" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" startline="54" endline="65">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_ExpressionType = m_PropertyAccess.Type
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="985" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="68" endline="81">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveTypeReferences AndAlso result
         'Not necessary.'result = m_ArrayTypeModifiers.ResolveCode AndAlso result
 
         Dim tp As Mono.Cecil.TypeReference = m_TypeName.ResolvedType
         tp = m_ArrayTypeModifiers.CreateArrayType(tp)
         m_ResolvedType = tp
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="986" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="102" endline="115">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_IsVariableDeclaration Then
             result = m_VariableDeclaration.GenerateCode(Info.Clone(Me, True, False, UsingVariableType)) AndAlso result
             UsingVariable = m_VariableDeclaration.LocalBuilder
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="987" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="26" endline="38">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_DestinationType IsNot Nothing Then
             result = m_DestinationType.ResolveTypeReferences AndAlso result
             m_ResolvedDestinationType = m_DestinationType.ResolvedType
             Helper.Assert(CecilHelper.IsByRef(m_ResolvedDestinationType) = False)
         End If
 
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="988" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="171" endline="182">
<![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         BaseType = Compiler.TypeCache.System_MulticastDelegate
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences(False) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="989" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="23" endline="44">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitIntDiv(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__IntDivideObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="990" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" startline="53" endline="72">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_PropertyGroup.IsResolved = False OrElse m_PropertyGroup.ResolvedProperty Is Nothing Then
             result = m_PropertyGroup.ResolveGroup(New ArgumentList(Me)) AndAlso result
         End If
 
         If result = False Then
             Return False
         End If
 
         m_ExpressionType = m_PropertyGroup.ResolvedProperty.PropertyType
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="991" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="54" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Type IsNot Nothing Then
             result = m_Type.ResolveTypeReferences AndAlso result
             EventType = m_Type.ResolvedType
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="992" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="45" endline="59">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Expression As Expression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             result = Expression.GenerateCode(Info.Clone(Expression, True, False, Expression.ExpressionType)) AndAlso result
             If CecilHelper.IsValueType(Expression.ExpressionType) OrElse CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
                 Emitter.EmitBox(Info, Expression.ExpressionType)
             End If
         Else
             Throw New InternalException(Expression)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="993" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="80" endline="91">
<![CDATA[
 
 		internal int ReadBlobIndex()
 		{
 			if (bigBlobs)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="994" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="446" endline="457">
<![CDATA[
 
 		internal int ReadField()
 		{
 			if (bigField)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="995" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="470" endline="481">
<![CDATA[
 
 		internal int ReadParam()
 		{
 			if (bigParam)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="996" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="494" endline="505">
<![CDATA[
 
 		internal int ReadEvent()
 		{
 			if (bigEvent)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="997" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="68" endline="79">
<![CDATA[
 
 		internal int ReadGuidIndex()
 		{
 			if (bigGuids)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="998" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="458" endline="469">
<![CDATA[
 
 		internal int ReadMethodDef()
 		{
 			if (bigMethodDef)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="999" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="482" endline="493">
<![CDATA[
 
 		internal int ReadProperty()
 		{
 			if (bigProperty)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1000" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="832" endline="840">
<![CDATA[
 		}
 
 		public bool HasExtensionMethodType {
 			get {
 				if (Count == 0)
 					return false;
 
 				return FixedParameters [0].HasExtensionMethodModifier;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="747" endline="756">
<![CDATA[
 		}
 
 		public TypeSpec ExtensionMethodType {
 			get {
 				if (Count == 0)
 					return null;
 
 				return FixedParameters [0].HasExtensionMethodModifier ?
 					types [0] 
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1001" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="832" endline="840">
<![CDATA[
 		}
 
 		public bool HasExtensionMethodType {
 			get {
 				if (Count == 0)
 					return false;
 
 				return FixedParameters [0].HasExtensionMethodModifier;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1641" endline="1650">
<![CDATA[
 
 		protected virtual void CheckEqualsAndGetHashCode ()
 		{
 			if (methods == null)
 				return;
 
 			if (HasEquals && !HasGetHashCode) {
 				Report.Warning (659, 3, this.Location, "`{0}' overrides Object.Equals(object) but does not override Object.GetHashCode()", this.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1002" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="523" endline="533">
<![CDATA[
 
 		public override Module ManifestModule
 		{
 			get
 			{
 				if (pseudoManifestModule == null)
 				{
 					pseudoManifestModule = new ManifestModule(this);
 				}
 				return pseudoManifestModule;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2362" endline="2371">
<![CDATA[
 		}
 
 		internal override int GetModuleBuilderToken()
 		{
 			if (token == 0)
 			{
 				token = ((ModuleBuilder)type.Module).ImportType(this);
 			}
 			return token;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1003" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="523" endline="533">
<![CDATA[
 
 		public override Module ManifestModule
 		{
 			get
 			{
 				if (pseudoManifestModule == null)
 				{
 					pseudoManifestModule = new ManifestModule(this);
 				}
 				return pseudoManifestModule;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1600" endline="1609">
<![CDATA[
 		}
 
 		internal sealed override int GetModuleBuilderToken()
 		{
 			if (token == 0)
 			{
 				token = ((ModuleBuilder)elementType.Module).ImportType(this);
 			}
 			return token;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1004" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2151" endline="2158">
<![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         If m_SharedCompilers.Contains(Compiler) = False Then
             m_SharedCompilers.Add(Compiler)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="44" endline="52">
<![CDATA[
 
     ReadOnly Property Constants() As Generic.List(Of EnumMemberDeclaration)
         Get
             If m_Constants Is Nothing Then
                 m_Constants = Members.GetSpecificMembers(Of EnumMemberDeclaration)()
                 Helper.Assert(m_Constants.Count = Members.Count)
             End If
             Return m_Constants
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1005" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2151" endline="2158">
<![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         If m_SharedCompilers.Contains(Compiler) = False Then
             m_SharedCompilers.Add(Compiler)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="86" endline="96">
<![CDATA[
 
     Sub Init(ByVal Attributes As Attributes)
         If m_Attributes Is Nothing Then
             m_Attributes = Attributes
         Else
             m_Attributes.AddRange(Attributes)
         End If
         m_TypeDeclarations = m_Members.GetSpecificMembers(Of TypeDeclaration).ToArray
 
         Helper.Assert(m_Members.Count = m_TypeDeclarations.Length)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1006" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="67" endline="75">
<![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="76" endline="84">
<![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.PropertyReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1007" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="162" endline="171">
<![CDATA[
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="443" endline="452">
<![CDATA[
 
     Private Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression)
         MyBase.new(Classifications.MethodGroup, Parent)
         m_InstanceExpression = InstanceExpression
         m_CallingType = Parent.FindFirstParent(Of TypeDeclaration)()
         m_Parameters = Parameters
         m_TypeArguments = TypeArguments
         'Helper.Assert(m_CallingType IsNot Nothing)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1008" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="165" endline="173">
<![CDATA[
 
 		internal static void SetMarshalAsAttribute(ModuleBuilder module, int token, CustomAttributeBuilder attribute)
 		{
 			attribute = attribute.DecodeBlob(module.Assembly);
 			FieldMarshalTable.Record rec = new FieldMarshalTable.Record();
 			rec.Parent = token;
 			rec.NativeType = WriteMarshallingDescriptor(module, attribute);
 			module.FieldMarshal.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="343" endline="352">
<![CDATA[
 
 		internal void SetCustomAttribute(int token, CustomAttributeBuilder customBuilder)
 		{
 			Debug.Assert(!customBuilder.IsPseudoCustomAttribute);
 			CustomAttributeTable.Record rec = new CustomAttributeTable.Record();
 			rec.Parent = token;
 			rec.Type = this.GetConstructorToken(customBuilder.Constructor).Token;
 			rec.Value = customBuilder.WriteBlob(this);
 			this.CustomAttribute.AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1009" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="165" endline="173">
<![CDATA[
 
 		internal static void SetMarshalAsAttribute(ModuleBuilder module, int token, CustomAttributeBuilder attribute)
 		{
 			attribute = attribute.DecodeBlob(module.Assembly);
 			FieldMarshalTable.Record rec = new FieldMarshalTable.Record();
 			rec.Parent = token;
 			rec.NativeType = WriteMarshallingDescriptor(module, attribute);
 			module.FieldMarshal.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="355" endline="363">
<![CDATA[
 
 		public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration)
 		{
 			MethodImplTable.Record rec = new MethodImplTable.Record();
 			rec.Class = token;
 			rec.MethodBody = this.ModuleBuilder.GetMethodToken(methodInfoBody).Token;
 			rec.MethodDeclaration = this.ModuleBuilder.GetMethodToken(methodInfoDeclaration).Token;
 			this.ModuleBuilder.MethodImpl.AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1010" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="165" endline="173">
<![CDATA[
 
 		internal static void SetMarshalAsAttribute(ModuleBuilder module, int token, CustomAttributeBuilder attribute)
 		{
 			attribute = attribute.DecodeBlob(module.Assembly);
 			FieldMarshalTable.Record rec = new FieldMarshalTable.Record();
 			rec.Parent = token;
 			rec.NativeType = WriteMarshallingDescriptor(module, attribute);
 			module.FieldMarshal.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="585" endline="601">
<![CDATA[
 
 		internal int ImportMethodOrField(Type declaringType, string name, Signature sig)
 		{
 			int token;
 			if (!importedMemberRefs.TryGetValue(new MemberRefKey(declaringType, name, sig), out token))
 			{
 				MemberRefTable.Record rec = new MemberRefTable.Record();
 				rec.Class = GetTypeTokenForMemberRef(declaringType);
 				rec.Name = this.Strings.Add(name);
 				ByteBuffer bb = new ByteBuffer(16);
 				sig.WriteSig(this, bb);
 				rec.Signature = this.Blobs.Add(bb);
 				token = 0x0A000000 | this.MemberRef.AddRecord(rec);
 				importedMemberRefs.Add(new MemberRefKey(declaringType, name, sig), token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1011" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="443" endline="452">
<![CDATA[
 		}
 
 		private MethodInfo Wrap(MethodInfo method)
 		{
 			if (method == null)
 			{
 				return null;
 			}
 			return new GenericMethodInstance(typeInstance, method, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="550" endline="559">
<![CDATA[
 		}
 
 		private MethodInfo Wrap(MethodInfo method)
 		{
 			if (method == null)
 			{
 				return null;
 			}
 			return new GenericMethodInstance(typeInstance, method, null);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1012" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="411" endline="418">
<![CDATA[
 
 		public Label DefineLabel()
 		{
 			Label label = new Label(labels.Count);
 			labels.Add(-1);
 			labelStackHeight.Add(-1);
 			return label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="1109" endline="1118">
<![CDATA[
 
 		private void WriteCode(ByteBuffer bb)
 		{
 			int codeOffset = bb.Position;
 			foreach (int fixup in this.tokenFixups)
 			{
 				moduleBuilder.tokenFixupOffsets.Add(fixup + codeOffset);
 			}
 			foreach (int fixup in this.tokenFixups)
 			{
 				moduleBuilder.tokenFixupOffsets.Add(fixup + codeOffset);
 			}
 			bb.Write(code);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1013" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="66" endline="78">
<![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructor() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="79" endline="91">
<![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructorCecil() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1014" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="66" endline="78">
<![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructor() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="911" endline="930">
<![CDATA[
 
     ''' <summary>
     ''' Emits a callvirt instructions. 
     ''' Throws an exception if the method is a shared method.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Shared Sub EmitCallVirt(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Dim OriginalMethod As Mono.Cecil.MethodReference = Method
         Dim mD As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then
             Method = Helper.GetMethodOrMethodReference(Info.Compiler, Method)
             Method = SwitchVersionedMethods(Info, Method)
             Method = CecilHelper.MakeEmittable(Method)
         End If
 
         Info.ILGen.EmitCall(OpCodes.Callvirt, Method, Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1015" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="66" endline="78">
<![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructor() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="510" endline="529">
<![CDATA[
 
     ''' <summary>
     ''' If the type is an enum type returns the base (integral type),
     ''' otherwise returns the same type.
     ''' </summary>
     ''' <param name="tp"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetIntegralType(ByVal Compiler As Compiler, ByVal tp As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(tp IsNot Nothing, "tp Is Nothing")
         If Helper.IsEnum(Compiler, tp) Then
             Dim field As Mono.Cecil.FieldDefinition
             field = CecilHelper.FindField(CecilHelper.FindDefinition(tp).Fields, EnumDeclaration.EnumTypeMemberName)
             Helper.Assert(field IsNot Nothing, "field '" & EnumDeclaration.EnumTypeMemberName & "' Is Nothing of Type '" & tp.FullName & "'")
             Return field.FieldType
         Else
             Helper.Assert(IsIntegralType(tp))
             Return tp
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1016" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="63" endline="77">
<![CDATA[
 		}
 
 		public Parameter.Modifier Modifier {
 			get {
 				switch (ArgType) {
 				case AType.Out
 					return Parameter.Modifier.OUT;
 
 				case AType.Ref
 					return Parameter.Modifier.REF;
 
 				default
 					return Parameter.Modifier.NONE;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2682" endline="2690">
<![CDATA[
 
 		public bool FixAllTypes (ResolveContext ec)
 		{
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (!FixType (ec, i))
 					return false;
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (!FixType (ec, i))
 					return false;
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1017" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="63" endline="77">
<![CDATA[
 		}
 
 		public Parameter.Modifier Modifier {
 			get {
 				switch (ArgType) {
 				case AType.Out
 					return Parameter.Modifier.OUT;
 
 				case AType.Ref
 					return Parameter.Modifier.REF;
 
 				default
 					return Parameter.Modifier.NONE;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="154" endline="169">
<![CDATA[
 		}
 
 		// TODO
 		// IsGenericType -- recursive
 		// HasTypeParameter -- non-recursive
 		public bool IsGenericOrParentIsGeneric {
 			get {
 				var ts = this;
 				do {
 					if (ts.IsGeneric)
 						return true;
 					ts = ts.declaringType;
 				} while (ts != null);
 
 				return false;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1018" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MyBaseExpression.vb" startline="44" endline="54">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim tpparent As IType = Me.FindFirstParent(Of IType)()
         m_ExpressionType = tpparent.BaseType
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" startline="63" endline="72">
<![CDATA[
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         If Me.IsArraySizeInitializationModifier Then
             Return Me.AsArraySizeInitializationModifier.CreateArrayType(OriginalType)
         ElseIf Me.IsArrayTypeModifiers Then
             Return Me.AsArrayTypeModifiers.CreateArrayType(OriginalType)
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1019" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="326" endline="334">
<![CDATA[
 		}
 
 		public override Type DeclaringType
 		{
 			get
 			{
 				int owner = module.GenericParam.records[index].Owner;
 				return (owner >> 24) == TypeDefTable.Index ? module.ResolveType(owner) 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="335" endline="343">
<![CDATA[
 		}
 
 		public override MethodBase DeclaringMethod
 		{
 			get
 			{
 				int owner = module.GenericParam.records[index].Owner;
 				return (owner >> 24) == MethodDefTable.Index ? module.ResolveMethod(owner) 
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1020" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1174" endline="1183">
<![CDATA[
 
 		/// <summary>
 		///   Used to validate that all the using clauses are correct
 		///   after we are finished parsing all the files.  
 		/// </summary>
 		static public void VerifyAllUsing ()
 		{
 			foreach (NamespaceEntry entry in entries)
 				entry.VerifyUsing ();
 			foreach (NamespaceEntry entry in entries)
 				entry.VerifyUsing ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="300" endline="310">
<![CDATA[
 
 		// <remarks>
 		//   If we're compiling with debugging support, this is called between parsing
 		//   and code generation to register all the source files with the
 		//   symbol writer.
 		// </remarks>
 		static public void DefineSymbolDocuments (MonoSymbolWriter symwriter)
 		{
 			foreach (CompilationUnit unit in compile_units)
 				unit.DefineSymbolInfo (symwriter);
 			foreach (CompilationUnit unit in compile_units)
 				unit.DefineSymbolInfo (symwriter);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1021" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1174" endline="1183">
<![CDATA[
 
 		/// <summary>
 		///   Used to validate that all the using clauses are correct
 		///   after we are finished parsing all the files.  
 		/// </summary>
 		static public void VerifyAllUsing ()
 		{
 			foreach (NamespaceEntry entry in entries)
 				entry.VerifyUsing ();
 			foreach (NamespaceEntry entry in entries)
 				entry.VerifyUsing ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="124" endline="132">
<![CDATA[
 
 		public void CheckGenericConstraints (IMemberContext context)
 		{
 			foreach (var c in constraints) {
 				var ge = c as GenericTypeExpr;
 				if (ge != null)
 					ge.CheckConstraints (context);
 			}
 			foreach (var c in constraints) {
 				var ge = c as GenericTypeExpr;
 				if (ge != null)
 					ge.CheckConstraints (context);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1022" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="147" endline="156">
<![CDATA[
 		}
 
 		public EventToken GetEventToken()
 		{
 			if (lazyPseudoToken == 0)
 			{
 				lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 			}
 			return new EventToken(lazyPseudoToken);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="670" endline="686">
<![CDATA[
 		}
 
 		internal override int ImportTo(ModuleBuilder other)
 		{
 			if (typeBuilder.IsGenericTypeDefinition)
 			{
 				return other.ImportMember(TypeBuilder.GetMethod(typeBuilder, this));
 			}
 			else if (other == typeBuilder.ModuleBuilder)
 			{
 				return pseudoToken;
 			}
 			else
 			{
 				return other.ImportMethodOrField(typeBuilder, name, this.MethodSignature);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1023" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="147" endline="156">
<![CDATA[
 		}
 
 		public EventToken GetEventToken()
 		{
 			if (lazyPseudoToken == 0)
 			{
 				lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 			}
 			return new EventToken(lazyPseudoToken);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="77" endline="85">
<![CDATA[
 
 		public ILGenerator GetILGenerator(int streamSize)
 		{
 			if (ilgen == null)
 			{
 				ilgen = new ILGenerator(typeBuilder.ModuleBuilder, streamSize);
 			}
 			return ilgen;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1024" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="147" endline="156">
<![CDATA[
 		}
 
 		public EventToken GetEventToken()
 		{
 			if (lazyPseudoToken == 0)
 			{
 				lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 			}
 			return new EventToken(lazyPseudoToken);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="659" endline="669">
<![CDATA[
 
 		internal override MethodSignature MethodSignature
 		{
 			get
 			{
 				if (methodSignature == null)
 				{
 					methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, modifiers, callingConvention, gtpb == null ? 0 
 				}
 				return methodSignature;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1025" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="147" endline="156">
<![CDATA[
 		}
 
 		public EventToken GetEventToken()
 		{
 			if (lazyPseudoToken == 0)
 			{
 				lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 			}
 			return new EventToken(lazyPseudoToken);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1319" endline="1330">
<![CDATA[
 		}
 
 		internal override MethodSignature MethodSignature
 		{
 			get
 			{
 				if (methodSignature == null)
 				{
 					methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, null, callingConvention, 0);
 				}
 				return methodSignature;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1026" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="467" endline="474">
<![CDATA[
 
 		public bool IsCompilerGenerated {
 			get	{
 				if ((mod_flags & Modifiers.COMPILER_GENERATED) != 0)
 					return true;
 
 				return Parent == null ? false 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="700" endline="710">
<![CDATA[
 
 	//
 	// Null is considered to be a reference type
 	//			
 	public static bool IsReferenceType (TypeSpec t)
 	{
 		if (t.IsGenericParameter)
 			return ((TypeParameterSpec) t).IsReferenceType;
 
 		return !t.IsStruct && !IsEnumType (t);
 	}			
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1027" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="467" endline="474">
<![CDATA[
 
 		public bool IsCompilerGenerated {
 			get	{
 				if ((mod_flags & Modifiers.COMPILER_GENERATED) != 0)
 					return true;
 
 				return Parent == null ? false 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1297" endline="1316">
<![CDATA[
 
 		public override void DefineType ()
 		{
 			if (error)
 				return;
 			if (type_defined)
 				return;
 
 			type_defined = true;
 
 			if (!DefineBaseTypes ()) {
 				error = true;
 				return;
 			}
 
 			if (!DefineNestedTypes ()) {
 				error = true;
 				return;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1028" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="97" endline="112">
<![CDATA[
 		}
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			bool res = base.CheckOverrideAgainstBase (base_member);
 
 			//
 			// Check that the permissions are not being changed
 			//
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				res = false;
 			}
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1255" endline="1266">
<![CDATA[
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				ok = false;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1029" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="32" endline="38">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New BooleanLiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" startline="85" endline="91">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New LiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1030" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="764" endline="771">
<![CDATA[
 
 		public void SetParameter (Parameter parameter)
 		{
 			base.parameters = new ParametersCompiled (parameter);
 			base.parameter_info = new ParameterInfo[] {
 				new ParameterInfo (this, 0)
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="772" endline="780">
<![CDATA[
 
 		public void SetParameters (Parameter first, Parameter second)
 		{
 			base.parameters = new ParametersCompiled (first, second);
 			base.parameter_info = new ParameterInfo[] {
 				new ParameterInfo (this, 0),
 				new ParameterInfo (this, 1)
 			};
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1031" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="458" endline="466">
<![CDATA[
 		}
 
 		public CompilationUnit CompilationUnit {
 			get {
 				int index = CompilationUnitIndex;
 				if (index == 0)
 					return null;
 				return (CompilationUnit) source_list [index - 1];
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="437" endline="457">
<![CDATA[
 		}
 
 		// The ISymbolDocumentWriter interface is used by the symbol writer to
 		// describe a single source file - for each source file there's exactly
 		// one corresponding ISymbolDocumentWriter instance.
 		//
 		// This class has an internal hash table mapping source document names
 		// to such ISymbolDocumentWriter instances - so there's exactly one
 		// instance per document.
 		//
 		// This property returns the ISymbolDocumentWriter instance which belongs
 		// to the location's source file.
 		//
 		// If we don't have a symbol writer, this property is always null.
 		public SourceFile SourceFile {
 			get {
 				int index = File;
 				if (index == 0)
 					return null;
 				return (SourceFile) source_list [index - 1];
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1032" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="458" endline="466">
<![CDATA[
 		}
 
 		public CompilationUnit CompilationUnit {
 			get {
 				int index = CompilationUnitIndex;
 				if (index == 0)
 					return null;
 				return (CompilationUnit) source_list [index - 1];
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="381" endline="391">
<![CDATA[
 		}
 
 		public string Name {
 			get {
 				int index = File;
 				if (token == 0 || index == 0)
 					return "Internal";
 
 				SourceFile file = (SourceFile) source_list [index - 1];
 				return file.Name;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1033" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="458" endline="466">
<![CDATA[
 		}
 
 		public CompilationUnit CompilationUnit {
 			get {
 				int index = CompilationUnitIndex;
 				if (index == 0)
 					return null;
 				return (CompilationUnit) source_list [index - 1];
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2691" endline="2713">
<![CDATA[
 
 		//
 		// All unfixed type variables Xi are fixed for which all of the following hold
 		// a, There is at least one type variable Xj that depends on Xi
 		// b, Xi has a non-empty set of bounds
 		// 
 		public bool FixDependentTypes (ResolveContext ec, ref bool fixed_any)
 		{
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (fixed_types[i] != null)
 					continue;
 
 				if (bounds[i] == null)
 					continue;
 
 				if (!FixType (ec, i))
 					return false;
 				
 				fixed_any = true;
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (fixed_types[i] != null)
 					continue;
 
 				if (bounds[i] == null)
 					continue;
 
 				if (!FixType (ec, i))
 					return false;
 				
 				fixed_any = true;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1034" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1759" endline="1766">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1367" endline="1374">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1035" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1759" endline="1766">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1799" endline="1806">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1036" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1759" endline="1766">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2369" endline="2381">
<![CDATA[
 
 		internal int FindFirstByOwner(int token)
 		{
 			// TODO use binary search (if sorted)
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Owner == token)
 				{
 					return i;
 				}
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Owner == token)
 				{
 					return i;
 				}
 			}
 			return -1;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1037" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="269" endline="278">
<![CDATA[
 
 		public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes)
 		{
 			ConstructorBuilder cb = DefineConstructor(attributes, CallingConventions.Standard, Type.EmptyTypes);
 			ILGenerator ilgen = cb.GetILGenerator();
 			ilgen.Emit(OpCodes.Ldarg_0);
 			ilgen.Emit(OpCodes.Call, baseType.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null));
 			ilgen.Emit(OpCodes.Ret);
 			return cb;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1038" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="792" endline="798">
<![CDATA[
 
 		public void EmitWriteLine(string text)
 		{
 			Universe u = moduleBuilder.universe;
 			Emit(OpCodes.Ldstr, text);
 			Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("WriteLine", new Type[] { u.System_String }));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1039" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="719" endline="731">
<![CDATA[
 
 		public void Emit(OpCode opc, Type type)
 		{
 			Emit(opc);
 			if (opc == OpCodes.Ldtoken)
 			{
 				code.Write(moduleBuilder.GetTypeToken(type).Token);
 			}
 			else
 			{
 				code.Write(moduleBuilder.GetTypeTokenForMemberRef(type));
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1040" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="80" endline="96">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= EventAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1041" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="92" endline="108">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= PropertyAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1042" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="799" endline="814">
<![CDATA[
 
 		public void EmitWriteLine(FieldInfo field)
 		{
 			Universe u = moduleBuilder.universe;
 			Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("get_Out"));
 			if (field.IsStatic)
 			{
 				Emit(OpCodes.Ldsfld, field);
 			}
 			else
 			{
 				Emit(OpCodes.Ldarg_0);
 				Emit(OpCodes.Ldfld, field);
 			}
 			Emit(OpCodes.Callvirt, u.Import(typeof(System.IO.TextWriter)).GetMethod("WriteLine", new Type[] { field.FieldType }));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1043" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="732" endline="738">
<![CDATA[
 
 		public void Emit(OpCode opcode, SignatureHelper signature)
 		{
 			Emit(opcode);
 			UpdateStack(opcode, signature.HasThis, signature.ReturnType, signature.ParameterCount);
 			code.Write(0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(signature.GetSignature(moduleBuilder))));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1044" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="180" endline="190">
<![CDATA[
 		}
 
 		public void SetConstant(object defaultValue)
 		{
 			if (lazyPseudoToken == 0)
 			{
 				lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 			}
 			attributes |= PropertyAttributes.HasDefault;
 			typeBuilder.ModuleBuilder.AddConstant(lazyPseudoToken, defaultValue);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1045" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="41" endline="53">
<![CDATA[
 		internal FieldBuilder(TypeBuilder type, string name, Type fieldType, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attribs)
 		{
 			this.typeBuilder = type;
 			this.name = name;
 			this.pseudoToken = type.ModuleBuilder.AllocPseudoToken();
 			this.nameIndex = type.ModuleBuilder.Strings.Add(name);
 			this.fieldSig = FieldSignature.Create(fieldType, optionalCustomModifiers, requiredCustomModifiers);
 			ByteBuffer sig = new ByteBuffer(5);
 			fieldSig.WriteSig(this.typeBuilder.ModuleBuilder, sig);
 			this.signature = this.typeBuilder.ModuleBuilder.Blobs.Add(sig);
 			this.attribs = attribs;
 			this.typeBuilder.ModuleBuilder.Field.AddVirtualRecord();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1046" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="771" endline="780">
<![CDATA[
 
 		public void EmitCalli(OpCode opc, CallingConvention callingConvention, Type returnType, Type[] parameterTypes)
 		{
 			returnType = returnType ?? moduleBuilder.universe.System_Void;
 			Emit(opc);
 			UpdateStack(opc, false, returnType, parameterTypes.Length);
 			ByteBuffer sig = new ByteBuffer(16);
 			Signature.WriteStandAloneMethodSig(moduleBuilder, sig, callingConvention, returnType, parameterTypes);
 			code.Write(0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(sig)));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1047" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="570" endline="581">
<![CDATA[
 
 		public static IList<CustomAttributeData> __GetDeclarativeSecurity(Type type)
 		{
 			if ((type.Attributes & TypeAttributes.HasSecurity) != 0)
 			{
 				return type.Module.GetDeclarativeSecurity(type.MetadataToken);
 			}
 			else
 			{
 				return EmptyList;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="582" endline="593">
<![CDATA[
 
 		public static IList<CustomAttributeData> __GetDeclarativeSecurity(MethodBase method)
 		{
 			if ((method.Attributes & MethodAttributes.HasSecurity) != 0)
 			{
 				return method.Module.GetDeclarativeSecurity(method.MetadataToken);
 			}
 			else
 			{
 				return EmptyList;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1048" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2643" endline="2652">
<![CDATA[
 
 		private int consume_identifier (int s)
 		{
 			int res = consume_identifier (s, false);
 
 			if (doc_state == XmlCommentState.Allowed)
 				doc_state = XmlCommentState.NotAllowed;
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="480" endline="499">
<![CDATA[
 
 		//
 		// For named arguments when the order of execution is different
 		// to order of invocation
 		//
 		public Arguments MarkOrderedArgument (NamedArgument a)
 		{
 			//
 			// Constant expression have no effect on left-to-right execution
 			//
 			if (a.Expr is Constant)
 				return this;
 
 			ArgumentsOrdered ra = this as ArgumentsOrdered;
 			if (ra == null)
 				ra = new ArgumentsOrdered (this);
 
 			ra.AddOrdered (a);
 			return ra;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1049" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2643" endline="2652">
<![CDATA[
 
 		private int consume_identifier (int s)
 		{
 			int res = consume_identifier (s, false);
 
 			if (doc_state == XmlCommentState.Allowed)
 				doc_state = XmlCommentState.NotAllowed;
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="978" endline="986">
<![CDATA[
 
 		public override bool Equals (object obj)
 		{
 			Attribute a = obj as Attribute;
 			if (a == null)
 				return false;
 
 			return Type == a.Type && Target == a.Target;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1050" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1446" endline="1454">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakePointerType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1409" endline="1417">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakeByRefType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1051" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="646" endline="654">
<![CDATA[
 
 		private void WriteToken(FieldToken token)
 		{
 			if (token.IsPseudoToken)
 			{
 				tokenFixups.Add(code.Position);
 			}
 			code.Write(token.Token);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="655" endline="663">
<![CDATA[
 
 		private void WriteToken(MethodToken token)
 		{
 			if (token.IsPseudoToken)
 			{
 				tokenFixups.Add(code.Position);
 			}
 			code.Write(token.Token);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1052" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="75" endline="81">
<![CDATA[
 
 		internal void Write(short value)
 		{
 			buffer[0] = (byte)value;
 			buffer[1] = (byte)(value >> 8);
 			stream.Write(buffer, 0, 2);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="86" endline="93">
<![CDATA[
 
 		internal void Write(byte[] value)
 		{
 			if (pos + value.Length > buffer.Length)
 				Grow(value.Length);
 			Buffer.BlockCopy(value, 0, buffer, pos, value.Length);
 			pos += value.Length;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1053" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="35" endline="43">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         MyBase.BaseType = Compiler.TypeCache.System_ValueType
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="64" endline="74">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         MyBase.BaseType = Compiler.TypeCache.System_Object
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Me.FindDefaultConstructors()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1054" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="35" endline="43">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         MyBase.BaseType = Compiler.TypeCache.System_ValueType
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="142" endline="155">
<![CDATA[
     End Property
 
     Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim constant As Object = Nothing 'm_ResolvedProperty.GetConstantValue
         If constant IsNot Nothing Then
             Emitter.EmitLoadValue(Info, constant)
         Else
             Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, m_Parameters, CecilHelper.GetGetMethod(m_ResolvedProperty))
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1055" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="305" endline="316">
<![CDATA[
 
 		protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="290" endline="304">
<![CDATA[
 
 		protected static Type ReadRetType(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_VOID
 					br.ReadByte();
 					return module.universe.System_Void;
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1056" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="305" endline="316">
<![CDATA[
 
 		protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="273" endline="289">
<![CDATA[
 
 		private static Type ReadTypeOrByRef(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.PeekByte() == ELEMENT_TYPE_BYREF)
 			{
 				br.ReadByte();
 				// LAMESPEC it is allowed (by C++/CLI, ilasm and peverify) to have custom modifiers after the BYREF
 				// (which makes sense, as it is analogous to pointers)
 				CustomModifiers mods = ReadCustomModifiers(module, br, context);
 				// C++/CLI generates void& local variables, so we need to use ReadTypeOrVoid here
 				return ReadTypeOrVoid(module, br, context).__MakeByRefType(mods.required, mods.optional);
 			}
 			else
 			{
 				return ReadType(module, br, context);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1057" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="305" endline="316">
<![CDATA[
 
 		protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="228" endline="239">
<![CDATA[
 		}
 
 		internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
 		{
 			List<CustomAttributeData> list = module.GetCustomAttributes(this.MetadataToken, attributeType);
 			if ((this.Attributes & MethodAttributes.PinvokeImpl) != 0
 				&& (attributeType == null || attributeType.IsAssignableFrom(module.universe.System_Runtime_InteropServices_DllImportAttribute)))
 			{
 				CreateDllImportPseudoCustomAttribute(list);
 			}
 			return list;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1058" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="305" endline="316">
<![CDATA[
 
 		protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="237" endline="250">
<![CDATA[
 
 		private void PostDefineType(TypeBuilder typeBuilder, PackingSize packingSize, int typesize)
 		{
 			types.Add(typeBuilder);
 			fullNameToType.Add(typeBuilder.FullName, typeBuilder);
 			if (packingSize != PackingSize.Unspecified || typesize != 0)
 			{
 				ClassLayoutTable.Record rec = new ClassLayoutTable.Record();
 				rec.PackingSize = (short)packingSize;
 				rec.ClassSize = typesize;
 				rec.Parent = typeBuilder.MetadataToken;
 				this.ClassLayout.AddRecord(rec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1059" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="305" endline="316">
<![CDATA[
 
 		protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="219" endline="236">
<![CDATA[
 
 		internal TypeBuilder DefineNestedTypeHelper(TypeBuilder enclosingType, string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize)
 		{
 			if (parent == null && (attr & TypeAttributes.Interface) == 0)
 			{
 				parent = universe.System_Object;
 			}
 			TypeBuilder typeBuilder = new TypeBuilder(enclosingType, name, parent, attr);
 			PostDefineType(typeBuilder, packingSize, typesize);
 			if (enclosingType != null)
 			{
 				NestedClassTable.Record rec = new NestedClassTable.Record();
 				rec.NestedClass = typeBuilder.MetadataToken;
 				rec.EnclosingClass = enclosingType.MetadataToken;
 				this.NestedClass.AddRecord(rec);
 			}
 			return typeBuilder;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1060" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="305" endline="316">
<![CDATA[
 
 		protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="226" endline="250">
<![CDATA[
 
 		internal override int ImportTo(Emit.ModuleBuilder module)
 		{
 			if (methodArgs == null)
 			{
 				return module.ImportMethodOrField(declaringType, method.Name, method.MethodSignature);
 			}
 			else
 			{
 				Writer.ByteBuffer spec = new Writer.ByteBuffer(10);
 				Signature.WriteMethodSpec(module, spec, methodArgs);
 				Metadata.MethodSpecTable.Record rec = new Metadata.MethodSpecTable.Record();
 				Emit.MethodBuilder mb = method as Emit.MethodBuilder;
 				if (mb != null && mb.ModuleBuilder == module && !declaringType.IsGenericType)
 				{
 					rec.Method = mb.MetadataToken;
 				}
 				else
 				{
 					rec.Method = module.ImportMember(GetGenericMethodDefinition());
 				}
 				rec.Instantiation = module.Blobs.Add(spec);
 				return 0x2B000000 | module.MethodSpec.FindOrAddRecord(rec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1061" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1116" endline="1215">
<![CDATA[
 
 			public const string AddPrefix = "add_";
 			public const string RemovePrefix = "remove_";
 
 			protected AEventAccessor (Event method, string prefix, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = method.ModFlags;
 				this.parameters = ParametersCompiled.CreateImplicitParameter (method.TypeExpression, loc);
 			}
 
 			public bool IsInterfaceImplementation {
 				get { return method_data.implementing != null; }
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 
 				method_data = new MethodData (method, method.ModFlags,
 					method.flags | MethodAttributes.HideBySig | MethodAttributes.SpecialName, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				MethodBuilder mb = method_data.MethodBuilder;
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, mb, ParameterInfo, method.ModFlags);
 				Spec.IsAccessor = true;
 
 				return mb;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 
 			public override ParametersCompiled ParameterInfo {
 				get {
 					return parameters;
 				}
 			}
 		}
 
 		AEventAccessor add, remove;
 		EventBuilder EventBuilder;
 		protected EventSpec spec;
 
 		protected Event (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="469" endline="801">
<![CDATA[
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Method; 
 			}
 		}
 
 		protected override bool CheckForDuplications ()
 		{
 			return Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 		}
 
 		public virtual EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, MemberType);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsStatic) {
 				Error_StaticReturnType ();
 			}
 		}
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
 
 		public bool IsPartialDefinition {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block == null;
 			}
 		}
 
 		public bool IsPartialImplementation {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block != null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#region IMethodData Members
 
 		public TypeSpec ReturnType {
 			get {
 				return MemberType;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return GenericMethod;
 			}
 		}
 
 		public virtual void EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 
 		#endregion
 
 	}
 
 	public class SourceMethod 
 	{
 		MethodBase method;
 		SourceMethodBuilder builder;
 
 		protected SourceMethod (DeclSpace parent, MethodBase method, ICompileUnit file)
 		{
 			this.method = method;
 			
 			builder = SymbolWriter.OpenMethod (file, parent.NamespaceEntry.SymbolFileID, this);
 		}
 
 		public string Name {
 			get { return method.Name; }
 		}
 
 		public int Token {
 			get {
 				MethodToken token;
 				var mb = method as MethodBuilder;
 				if (mb != null)
 					token = mb.GetToken ();
 				else
 					token = ((ConstructorBuilder) method).GetToken ();
 #if STATIC
 				if (token.IsPseudoToken)
 					return ((ModuleBuilder) method.Module).ResolvePseudoToken (token.Token);
 #endif
 				return token.Token;
 			}
 		}
 
 		public void CloseMethod ()
 		{
 			SymbolWriter.CloseMethod ();
 		}
 
 		public void SetRealMethodName (string name)
 		{
 			if (builder != null)
 				builder.SetRealMethodName (name);
 		}
 
 		public static SourceMethod Create (DeclSpace parent, MethodBase method, Block block)
 		{
 			if (!SymbolWriter.HasSymbolWriter)
 				return null;
 			if (block == null)
 				return null;
 
 			Location start_loc = block.StartLocation;
 			if (start_loc.IsNull)
 				return null;
 
 			ICompileUnit compile_unit = start_loc.CompilationUnit;
 			if (compile_unit == null)
 				return null;
 
 			return new SourceMethod (parent, method, compile_unit);
 		}
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1062" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Operand.vb" startline="55" endline="62">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1063" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="311" endline="320">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.CustomAttributes IsNot Nothing Then
             result = Me.CustomAttributes.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1064" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="407" endline="416">
<![CDATA[
 
     Function EmitAttributes() As Boolean
         Dim result As Boolean = True
 
         If m_Attributes IsNot Nothing Then
             result = m_Attributes.GenerateCode(Nothing) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1065" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="52" endline="60">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then result = m_ParameterList.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1066" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="41" endline="49">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_FirstPart IsNot Nothing Then result = m_FirstPart.ResolveTypeReferences AndAlso result
         If m_SecondPart IsNot Nothing Then result = m_SecondPart.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1067" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="31" endline="37">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_VariableInitializerList IsNot Nothing Then result = m_VariableInitializerList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1068" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1069" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveTypeReferences AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1070" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" startline="54" endline="63">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression1 IsNot Nothing Then result = m_Expression1.ResolveTypeReferences AndAlso result
         If m_Expression2 IsNot Nothing Then result = m_Expression2.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1071" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" startline="35" endline="42">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_Arguments IsNot Nothing Then result = m_Arguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1072" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="58" endline="69">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_First IsNot Nothing Then result = m_First.ResolveTypeReferences AndAlso result
         If m_Second IsNot Nothing Then result = m_Second.ResolveTypeReferences AndAlso result
 
         ' If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1073" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="61" endline="73">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then
             result = m_ParameterList.ResolveTypeReferences AndAlso result
         End If
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1074" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="113" endline="128">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             result = m_TypeName.ResolveTypeReferences AndAlso result
         End If
 
         If m_When IsNot Nothing Then
             result = m_When.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1075" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" startline="155" endline="166">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_GeneratedCode = False Then
             If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.GenerateCode(Info) AndAlso result
 
             m_GeneratedCode = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1076" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="41" endline="52">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameters IsNot Nothing Then
             result = m_TypeParameters.ResolveTypeReferences AndAlso result
         End If
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1077" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" startline="53" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Test IsNot Nothing Then result = m_Test.ResolveTypeReferences AndAlso result
         If m_Cases IsNot Nothing Then result = m_Cases.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1078" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_EventHandler IsNot Nothing Then result = m_EventHandler.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1079" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="51" endline="58">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArraySizeInitModifier IsNot Nothing Then result = m_ArraySizeInitModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1080" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="186" endline="197">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_LoopControlVariable IsNot Nothing Then result = m_LoopControlVariable.ResolveTypeReferences AndAlso result
         If m_InExpression IsNot Nothing Then result = m_InExpression.ResolveTypeReferences AndAlso result
         If m_NextExpression IsNot Nothing Then result = m_NextExpression.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1081" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="44" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Target IsNot Nothing Then result = m_Target.ResolveTypeReferences AndAlso result
         If m_Start IsNot Nothing Then result = m_Start.ResolveTypeReferences AndAlso result
         If m_Length IsNot Nothing Then result = m_Length.ResolveTypeReferences AndAlso result
         If m_Source IsNot Nothing Then result = m_Source.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1082" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="299" endline="314">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences AndAlso result
         If result = False Then Return result
 
         ReturnType = m_Signature.ReturnType
 
         If m_Code IsNot Nothing Then result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1083" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="160" endline="173">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_Signature IsNot Nothing Then result = m_Signature.ResolveTypeReferences AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveTypeReferences AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveTypeReferences AndAlso result
 
         If m_MemberImplementsClause IsNot Nothing Then result = m_MemberImplementsClause.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1084" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="49" endline="59">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_ArrayElementInitializer IsNot Nothing Then result = m_ArrayElementInitializer.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1085" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="111" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="59" endline="71">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
 
         If m_Declaration IsNot Nothing Then result = m_Declaration.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1086" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1465" endline="1472">
<![CDATA[
 
 		internal static void InplaceBindTypeParameters(IGenericBinder binder, Type[] types)
 		{
 			for (int i = 0; i < types.Length; i++)
 			{
 				types[i] = types[i].BindTypeParameters(binder);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				types[i] = types[i].BindTypeParameters(binder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="230" endline="237">
<![CDATA[
 
 		public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			for (int i = 0; i < arguments.Length; i++)
 			{
 				AddArgument(arguments[i], false, requiredCustomModifiers[i], optionalCustomModifiers[i]);
 			}
 			for (int i = 0; i < arguments.Length; i++)
 			{
 				AddArgument(arguments[i], false, requiredCustomModifiers[i], optionalCustomModifiers[i]);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1087" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="267" endline="276">
<![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attributes |= MethodAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="591" endline="600">
<![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attribs |= TypeAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1088" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="52" endline="61">
<![CDATA[
 
 		public override string ToString()
 		{
 			string str = name.ToString();
 			if (culture != null)
 			{
 				str = str.Replace("Culture=neutral", "Culture=" + culture);
 			}
 			return str;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="148" endline="160">
<![CDATA[
 		}
 
 		public string FullName
 		{
 			get
 			{
 				string str = name.FullName;
 				if (culture != null)
 				{
 					str = str.Replace("Culture=neutral", "Culture=" + culture);
 				}
 				return str;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1089" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1466" endline="1476">
<![CDATA[
 
 		public void SetFieldAssigned (MyBitVector vector, string field_name)
 		{
 			int field_idx = TypeInfo.GetFieldIndex (field_name);
 
 			if (field_idx == 0)
 				return;
 
 			vector [Offset + field_idx] = true;
 			is_ever_assigned = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1428" endline="1436">
<![CDATA[
 
 		public void SetAssigned (MyBitVector vector)
 		{
 			if (Length == 1)
 				vector [Offset] = true;
 			else
 				vector.SetRange (Offset, Length);
 			is_ever_assigned = true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1090" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1466" endline="1476">
<![CDATA[
 
 		public void SetFieldAssigned (MyBitVector vector, string field_name)
 		{
 			int field_idx = TypeInfo.GetFieldIndex (field_name);
 
 			if (field_idx == 0)
 				return;
 
 			vector [Offset + field_idx] = true;
 			is_ever_assigned = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1670" endline="1685">
<![CDATA[
 
 		int get_char ()
 		{
 			int x;
 			if (putback_char != -1) {
 				x = putback_char;
 				putback_char = -1;
 			} else
 				x = reader.Read ();
 			if (x == '\n') {
 				advance_line ();
 			} else {
 				col++;
 			}
 			return x;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1091" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="559" endline="583">
<![CDATA[
 
     Function GenerateMyRequest() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Request"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Request As Global.System.Web.HttpRequest" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Request" & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="590" endline="614">
<![CDATA[
 
     Function GenerateMyResponse() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Response"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Response As Global.System.Web.HttpResponse" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Response    " & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1092" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="559" endline="583">
<![CDATA[
 
     Function GenerateMyRequest() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Request"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Request As Global.System.Web.HttpRequest" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Request" & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="486" endline="507">
<![CDATA[
 
     Function GenerateMyLog() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        Private Shared ReadOnly m_LogObjectProvider As ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog) = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)" & VB.vbNewLine & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Application.Log"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Log As Global.Microsoft.VisualBasic.Logging.AspLog" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Return MyProject.m_LogObjectProvider.GetInstance" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         'ProjectCodeCctor.AppendLine("            m_LogObjectProvider = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1093" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="391" endline="401">
<![CDATA[
 
     Shared Function IsKeyword(ByVal str As Char(), ByVal length As Integer, ByRef Keyword As KS) As Boolean
         Dim special As KS
         special = Enums.GetKS(str, length)
         If special <> KS.None Then
             Keyword = special
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="242" endline="261">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Compare one CodeFile to another based on filename.
     ''' </summary>
     ''' <param name="value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Overrides Function Equals(ByVal value As Object) As Boolean
         Dim file As CodeFile = TryCast(value, CodeFile)
         If file IsNot Nothing Then
             If file Is Me Then
                 Return True
             Else
                 Return Microsoft.VisualBasic.Strings.StrComp(m_FileName, file.FileName, Microsoft.VisualBasic.CompareMethod.Text) = 0
             End If
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1094" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ConstructorInfo.cs" startline="49" endline="59">
<![CDATA[
 		}
 
 		public sealed override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = GetMethodInfo().GetParameters();
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1095" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2185" endline="2194">
<![CDATA[
 
 		public override FieldInfo[] __GetDeclaredFields()
 		{
 			FieldInfo[] fields = type.__GetDeclaredFields();
 			for (int i = 0; i < fields.Length; i++)
 			{
 				fields[i] = fields[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < fields.Length; i++)
 			{
 				fields[i] = fields[i].BindTypeParameters(this);
 			}
 			return fields;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1096" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2205" endline="2214">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			MethodBase[] methods = type.__GetDeclaredMethods();
 			for (int i = 0; i < methods.Length; i++)
 			{
 				methods[i] = methods[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < methods.Length; i++)
 			{
 				methods[i] = methods[i].BindTypeParameters(this);
 			}
 			return methods;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1097" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertyInfo.cs" startline="33" endline="116">
<![CDATA[
 		}
 
 		public abstract PropertyAttributes Attributes { get; }
 		public abstract bool CanRead { get; }
 		public abstract bool CanWrite { get; }
 		public abstract MethodInfo GetGetMethod(bool nonPublic);
 		public abstract MethodInfo GetSetMethod(bool nonPublic);
 		public abstract MethodInfo[] GetAccessors(bool nonPublic);
 		public abstract object GetRawConstantValue();
 		internal abstract bool IsPublic { get; }
 		internal abstract bool IsStatic { get; }
 		internal abstract PropertySignature PropertySignature { get; }
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly PropertyInfo property;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(PropertyInfo property, int parameter)
 			{
 				this.property = property;
 				this.parameter = parameter;
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override Type ParameterType
 			{
 				get { return property.PropertySignature.GetParameter(parameter); }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return property.PropertySignature.GetOptionalCustomModifiers(parameter);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return property.PropertySignature.GetRequiredCustomModifiers(parameter);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return property; }
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x08000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return property.Module; }
 			}
 		}
 
 		public ParameterInfo[] GetIndexParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[this.PropertySignature.ParameterCount];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1098" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2195" endline="2204">
<![CDATA[
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			Type[] interfaces = type.__GetDeclaredInterfaces();
 			for (int i = 0; i < interfaces.Length; i++)
 			{
 				interfaces[i] = interfaces[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < interfaces.Length; i++)
 			{
 				interfaces[i] = interfaces[i].BindTypeParameters(this);
 			}
 			return interfaces;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1099" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2230" endline="2239">
<![CDATA[
 
 		public override PropertyInfo[] __GetDeclaredProperties()
 		{
 			PropertyInfo[] properties = type.__GetDeclaredProperties();
 			for (int i = 0; i < properties.Length; i++)
 			{
 				properties[i] = properties[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < properties.Length; i++)
 			{
 				properties[i] = properties[i].BindTypeParameters(this);
 			}
 			return properties;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1100" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="69" endline="79">
<![CDATA[
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = method.GetParameters();
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1101" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2220" endline="2229">
<![CDATA[
 
 		public override EventInfo[] __GetDeclaredEvents()
 		{
 			EventInfo[] events = type.__GetDeclaredEvents();
 			for (int i = 0; i < events.Length; i++)
 			{
 				events[i] = events[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < events.Length; i++)
 			{
 				events[i] = events[i].BindTypeParameters(this);
 			}
 			return events;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1102" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="575" endline="584">
<![CDATA[
 
 		public override MethodInfo[] GetOtherMethods(bool nonPublic)
 		{
 			MethodInfo[] others = eventInfo.GetOtherMethods(nonPublic);
 			for (int i = 0; i < others.Length; i++)
 			{
 				others[i] = Wrap(others[i]);
 			}
 			for (int i = 0; i < others.Length; i++)
 			{
 				others[i] = Wrap(others[i]);
 			}
 			return others;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1103" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1872" endline="1881">
<![CDATA[
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameterInfos = new ParameterInfo[parameterTypes.Length];
 			for (int i = 0; i < parameterInfos.Length; i++)
 			{
 				parameterInfos[i] = new ParameterInfoImpl(this, parameterTypes[i], i);
 			}
 			for (int i = 0; i < parameterInfos.Length; i++)
 			{
 				parameterInfos[i] = new ParameterInfoImpl(this, parameterTypes[i], i);
 			}
 			return parameterInfos;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1104" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="463" endline="472">
<![CDATA[
 
 		public override MethodInfo[] GetAccessors(bool nonPublic)
 		{
 			MethodInfo[] accessors = property.GetAccessors(nonPublic);
 			for (int i = 0; i < accessors.Length; i++)
 			{
 				accessors[i] = Wrap(accessors[i]);
 			}
 			for (int i = 0; i < accessors.Length; i++)
 			{
 				accessors[i] = Wrap(accessors[i]);
 			}
 			return accessors;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1105" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="137" endline="150">
<![CDATA[
 
 		internal static Type[] ReadMethodSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.ReadByte() != GENERICINST)
 			{
 				throw new BadImageFormatException();
 			}
 			Type[] args = new Type[br.ReadCompressedInt()];
 			for (int i = 0; i < args.Length; i++)
 			{
 				args[i] = ReadType(module, br, context);
 			}
 			for (int i = 0; i < args.Length; i++)
 			{
 				args[i] = ReadType(module, br, context);
 			}
 			return args;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1106" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="773" endline="790">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			MethodBase[] methods = new MethodBase[this.methods.Count];
 			for (int i = 0; i < methods.Length; i++)
 			{
 				MethodBuilder mb = this.methods[i];
 				if (mb.IsConstructor)
 				{
 					methods[i] = new ConstructorInfoImpl(mb);
 				}
 				else
 				{
 					methods[i] = mb;
 				}
 			}
 			for (int i = 0; i < methods.Length; i++)
 			{
 				MethodBuilder mb = this.methods[i];
 				if (mb.IsConstructor)
 				{
 					methods[i] = new ConstructorInfoImpl(mb);
 				}
 				else
 				{
 					methods[i] = mb;
 				}
 			}
 			return methods;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1107" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="199" endline="212">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1108" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="172" endline="184">
<![CDATA[
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1109" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="213" endline="222">
<![CDATA[
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1110" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="96" endline="107">
<![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             ElseIf Me.IsSimpleTypeName Then
                 Return AsSimpleTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1111" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="191" endline="200">
<![CDATA[
 
     Overrides Function ToString() As String
         If IsConstructedTypeName Then
             Return AsConstructedTypeName.Name
         ElseIf IsSimpleTypeName Then
             Return AsSimpleTypeName.Name
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1112" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsNamespaceClause.vb" startline="136" endline="153">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The namespace or type that is imported.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Name() As String
         Get
             If IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             ElseIf IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1113" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="124" endline="135">
<![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsBuiltInTypeName Then
                 Return AsBuiltInTypeName.Name
             ElseIf IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1114" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Function
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1115" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" startline="75" endline="82">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Get
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1116" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="63" endline="74">
<![CDATA[
 
     ''' <summary>
     ''' Checks for the following grammar
     ''' ConstantMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Const
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1117" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="276" endline="287">
<![CDATA[
 
     ''' <summary>
     ''' Checks for this grammar
     ''' VariableMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.VariableModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.VariableModifiers)
             i += 1
         End While
         Return i > 0 AndAlso tm.PeekToken(i).IsIdentifier
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1118" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="145" endline="153">
<![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Sub AndAlso tm.PeekToken(i + 1).IsIdentifier
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1119" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" startline="75" endline="82">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Module)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1120" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Enum)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1121" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularPropertyDeclaration.vb" startline="35" endline="42">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1122" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MustOverridePropertyDeclaration.vb" startline="32" endline="39">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1123" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceFunctionDeclaration.vb" startline="36" endline="43">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Function)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1124" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfacePropertyMemberDeclaration.vb" startline="33" endline="40">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1125" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1126" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="541" endline="548">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Class)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1127" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="183" endline="190">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Delegate)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1128" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="44" endline="51">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Structure)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1129" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceEventMemberDeclaration.vb" startline="31" endline="38">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1130" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="72" endline="79">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Interface)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1131" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="41" endline="48">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals("Custom") AndAlso tm.PeekToken(i + 1).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1132" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="111" endline="118">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceSubDeclaration.vb" startline="31" endline="38">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Sub)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1133" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3296" endline="3307">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			if (GenericMethod != null)
 				GenericMethod.VerifyClsCompliance ();
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1238" endline="1245">
<![CDATA[
 			get {
 				if (is_generic)
 					return true;
 				else if (Parent != null)
 					return Parent.IsGeneric;
 				else
 					return false;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1134" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1746" endline="1758">
<![CDATA[
 	}
 
 	sealed class ModuleRefTable 
 	{
 		internal const int Index = 0x1A;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1354" endline="1366">
<![CDATA[
 	}
 
 	sealed class StandAloneSigTable 
 	{
 		internal const int Index = 0x11;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1135" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1746" endline="1758">
<![CDATA[
 	}
 
 	sealed class ModuleRefTable 
 	{
 		internal const int Index = 0x1A;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1786" endline="1798">
<![CDATA[
 	}
 
 	sealed class TypeSpecTable 
 	{
 		internal const int Index = 0x1B;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1136" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="313" endline="324">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="296" endline="302">
<![CDATA[
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1137" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1150" endline="1157">
<![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As Boolean)
         If I Then
             EmitLoadI4Value(Info, -1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1326" endline="1339">
<![CDATA[
 
     ''' <summary>
     ''' Loads the boolean value onto the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Overloads Shared Sub EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Boolean)
         If Value Then
             EmitLoadI4Value(Info, 1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1138" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="563" endline="573">
<![CDATA[
 
 		internal int ImportMember(MethodBase member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="574" endline="584">
<![CDATA[
 
 		internal int ImportMember(FieldInfo member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1139" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="563" endline="573">
<![CDATA[
 
 		internal int ImportMember(MethodBase member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="444" endline="458">
<![CDATA[
 		}
 
 		public Type Import(System.Type type)
 		{
 			Type imported;
 			if (!importedTypes.TryGetValue(type, out imported))
 			{
 				imported = ImportImpl(type);
 				if (imported != null)
 				{
 					importedTypes.Add(type, imported);
 				}
 			}
 			return imported;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1140" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2056" endline="2062">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			for (int ix = 0; ix < statements.Count; ix++){
 				statements [ix].Emit (ec);
 			}
 			for (int ix = 0; ix < statements.Count; ix++){
 				statements [ix].Emit (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="668" endline="676">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement target)
 		{
 			StatementList t = (StatementList) target;
 
 			t.statements = new List<Statement> (statements.Count);
 			foreach (Statement s in statements)
 				t.statements.Add (s.Clone (clonectx));
 			foreach (Statement s in statements)
 				t.statements.Add (s.Clone (clonectx));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1141" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="145" endline="152">
<![CDATA[
 
 		internal void WriteParamTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1142" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="929" endline="936">
<![CDATA[
 
 		internal void WriteFieldRecords(MetadataWriter mw)
 		{
 			foreach (FieldBuilder fb in fields)
 			{
 				fb.WriteFieldRecords(mw);
 			}
 			foreach (FieldBuilder fb in fields)
 			{
 				fb.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1143" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="921" endline="928">
<![CDATA[
 
 		internal void WriteParamRecords(MetadataWriter mw)
 		{
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteParamRecords(mw);
 			}
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteParamRecords(mw);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1144" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="115" endline="125">
<![CDATA[
 
 		internal void PopulatePropertyAndEventTables()
 		{
 			// LAMESPEC the PropertyMap and EventMap tables are not required to be sorted by the CLI spec,
 			// but .NET sorts them and Mono requires them to be sorted, so we have to populate the
 			// tables in the right order
 			foreach (TypeBuilder type in types)
 			{
 				type.PopulatePropertyAndEventTables();
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.PopulatePropertyAndEventTables();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1145" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="901" endline="908">
<![CDATA[
 
 		internal void WriteMethodDefRecords(int baseRVA, MetadataWriter mw, ref int paramList)
 		{
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteMethodDefRecord(baseRVA, mw, ref paramList);
 			}
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteMethodDefRecord(baseRVA, mw, ref paramList);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1146" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="126" endline="135">
<![CDATA[
 
 		internal void WriteTypeDefTable(MetadataWriter mw)
 		{
 			int fieldList = 1;
 			int methodList = 1;
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteTypeDefRecord(mw, ref fieldList, ref methodList);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteTypeDefRecord(mw, ref fieldList, ref methodList);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1147" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="136" endline="144">
<![CDATA[
 
 		internal void WriteMethodDefTable(int baseRVA, MetadataWriter mw)
 		{
 			int paramList = 1;
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteMethodDefRecords(baseRVA, mw, ref paramList);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteMethodDefRecords(baseRVA, mw, ref paramList);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1148" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="441" endline="451">
<![CDATA[
 
 		internal override void GetTypesImpl(List<Type> list)
 		{
 			foreach (Type type in types)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in types)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1149" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="610" endline="623">
<![CDATA[
 		}
 
 		internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
 		{
 			List<CustomAttributeData> list = new List<CustomAttributeData>();
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				if (attributeType == null || attributeType.IsAssignableFrom(cab.Constructor.DeclaringType))
 				{
 					list.Add(cab.ToData(this));
 				}
 			}
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				if (attributeType == null || attributeType.IsAssignableFrom(cab.Constructor.DeclaringType))
 				{
 					list.Add(cab.ToData(this));
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1150" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="647" endline="658">
<![CDATA[
 
 		internal void FixupToken(int token, ref int parameterToken)
 		{
 			typeBuilder.ModuleBuilder.RegisterTokenFixup(this.pseudoToken, token);
 			if (parameters != null)
 			{
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.FixupToken(parameterToken++);
 				}
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.FixupToken(parameterToken++);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1151" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1494" endline="1504">
<![CDATA[
 
     ''' <summary>
     ''' Load a constant date value on the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadDateValue(ByVal Info As EmitInfo, ByVal DateValue As Date)
         Dim emitLong As EmitInfo = Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Int64)
         EmitLoadI8Value(emitLong, DateValue.Ticks)
         Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_DateTime__ctor_Int64))
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="89" endline="95">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             Return m_LeftExpression.IsConstant AndAlso (Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_String) OrElse Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_Char)) _
               AndAlso m_RightExpression.IsConstant AndAlso (Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_String) OrElse Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_Char))
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1152" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="62" endline="72">
<![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         Me.ParameterType = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         m_TypeName = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="152" endline="159">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal EnumVariable As EnumMemberDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(EnumVariable IsNot Nothing)
         m_EnumVariable = EnumVariable
         m_Type = m_EnumVariable.FindFirstParent(Of EnumDeclaration).EnumConstantType
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1153" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="62" endline="72">
<![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         Me.ParameterType = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         m_TypeName = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="175" endline="182">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Constant As ConstantDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Constant IsNot Nothing)
         m_Constant = Constant
         m_Type = Constant.FieldType
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1154" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="54" endline="62">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeName(NewParent)
 
         result.Init(m_TypeName.Clone(result), m_ArrayTypeModifiers.Clone(result))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" startline="68" endline="76">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializer
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializer(NewParent)
         If m_IdentifierOrKeyword IsNot Nothing Then result.m_IdentifierOrKeyword = m_IdentifierOrKeyword.Clone(result)
         If m_AttributeArgumentExpression IsNot Nothing Then result.m_AttributeArgumentExpression = m_AttributeArgumentExpression.Clone(result)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1155" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" startline="54" endline="62">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeName(NewParent)
 
         result.Init(m_TypeName.Clone(result), m_ArrayTypeModifiers.Clone(result))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="71" endline="79">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameter
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameter(NewParent)
         result.m_Identifier = m_Identifier
         If m_TypeParameterConstraints IsNot Nothing Then result.m_TypeParameterConstraints = m_TypeParameterConstraints.Clone(result)
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1156" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="142" endline="157">
<![CDATA[
 		}
 
 		public override GenericParameterAttributes GenericParameterAttributes
 		{
 			get
 			{
 				if (type != null)
 				{
 					type.CheckBaked();
 				}
 				else
 				{
 					method.CheckBaked();
 				}
 				return attr;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="177" endline="189">
<![CDATA[
 
 		public override AssemblyName GetName()
 		{
 			AssemblyName n = new AssemblyName();
 			n.Name = name;
 			n.Version = new Version(majorVersion, minorVersion, buildVersion, revisionVersion);
 			n.Culture = culture;
 			n.HashAlgorithm = hashAlgorithm;
 			n.Flags = flags;
 			n.SetPublicKey(publicKey != null ? (byte[])publicKey.Clone() 
 			n.KeyPair = keyPair;
 			return n;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1157" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="51" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			FieldSignature other = obj as FieldSignature;
 			return other != null
 				&& other.fieldType.Equals(fieldType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="46" endline="54">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			GenericMethodInstance other = obj as GenericMethodInstance;
 			return other != null
 				&& other.method.Equals(method)
 				&& other.declaringType.Equals(declaringType)
 				&& Util.ArrayEquals(other.methodArgs, methodArgs);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1158" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="51" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			FieldSignature other = obj as FieldSignature;
 			return other != null
 				&& other.fieldType.Equals(fieldType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="49" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			MethodSignature other = obj as MethodSignature;
 			return other != null
 				&& other.callingConvention == callingConvention
 				&& other.genericParamCount == genericParamCount
 				&& other.returnType.Equals(returnType)
 				&& Util.ArrayEquals(other.parameterTypes, parameterTypes)
 				&& Util.ArrayEquals(other.modifiers, modifiers);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1159" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="51" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			FieldSignature other = obj as FieldSignature;
 			return other != null
 				&& other.fieldType.Equals(fieldType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2104" endline="2111">
<![CDATA[
 
 		public override bool Equals(object o)
 		{
 			GenericTypeInstance gt = o as GenericTypeInstance;
 			return gt != null && gt.type.Equals(type) && Util.ArrayEquals(gt.args, args)
 				&& Util.ArrayEquals(gt.requiredCustomModifiers, requiredCustomModifiers)
 				&& Util.ArrayEquals(gt.optionalCustomModifiers, optionalCustomModifiers);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1160" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="51" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			FieldSignature other = obj as FieldSignature;
 			return other != null
 				&& other.fieldType.Equals(fieldType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="59" endline="67">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			PropertySignature other = obj as PropertySignature;
 			return other != null
 				&& other.propertyType.Equals(propertyType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1161" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="135" endline="143">
<![CDATA[
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6879" endline="6892">
<![CDATA[
 
 		public static bool IsThisAvailable (ResolveContext ec, bool ignoreAnonymous)
 		{
 			if (ec.IsStatic || ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.BaseInitializer | ResolveContext.Options.ConstantScope))
 				return false;
 
 			if (ignoreAnonymous || ec.CurrentAnonymousMethod == null)
 				return true;
 
 			if (TypeManager.IsStruct (ec.CurrentType) && ec.CurrentIterator == null)
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1162" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="135" endline="143">
<![CDATA[
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="747" endline="762">
<![CDATA[
 
 	//
 	// Checks whether `type' is a subclass or nested child of `base_type'.
 	//
 	public static bool IsNestedFamilyAccessible (TypeSpec type, TypeSpec base_type)
 	{
 		do {
 			if (IsFamilyAccessible (type, base_type))
 				return true;
 
 			// Handle nested types.
 			type = type.DeclaringType;
 		} while (type != null);
 
 		return false;
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1163" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="135" endline="143">
<![CDATA[
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="799" endline="811">
<![CDATA[
 
 		//
 		// Returns the parameter information based on the name
 		//
 		public int GetParameterIndexByName (string name)
 		{
 			for (int idx = 0; idx < Count; ++idx) {
 				if (parameters [idx].Name == name)
 					return idx;
 			}
 			for (int idx = 0; idx < Count; ++idx) {
 				if (parameters [idx].Name == name)
 					return idx;
 			}
 
 			return -1;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1164" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="135" endline="143">
<![CDATA[
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="763" endline="784">
<![CDATA[
 
 	//
 	// Checks whether `type' is a nested child of `parent'.
 	//
 	public static bool IsNestedChildOf (TypeSpec type, ITypeDefinition parent)
 	{
 		if (type == null)
 			return false;
 
 		if (type.MemberDefinition == parent)
 			return false;
 
 		type = type.DeclaringType;
 		while (type != null) {
 			if (type.MemberDefinition == parent)
 				return true;
 
 			type = type.DeclaringType;
 		}
 		while (type != null) {
 			if (type.MemberDefinition == parent)
 				return true;
 
 			type = type.DeclaringType;
 		}
 
 		return false;
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1165" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="135" endline="143">
<![CDATA[
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="669" endline="685">
<![CDATA[
 
 		/// <summary>
 		/// Returns true when MemberCore is exposed from assembly.
 		/// </summary>
 		public bool IsExposedFromAssembly ()
 		{
 			if ((ModFlags & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 				return false;
 			
 			DeclSpace parentContainer = Parent.PartialContainer;
 			while (parentContainer != null && parentContainer.ModFlags != 0) {
 				if ((parentContainer.ModFlags & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 					return false;
 				parentContainer = parentContainer.Parent;
 			}
 			while (parentContainer != null && parentContainer.ModFlags != 0) {
 				if ((parentContainer.ModFlags & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 					return false;
 				parentContainer = parentContainer.Parent;
 			}
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1166" nfragments="2" Csharpe_files="0" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6295" endline="6312">
<![CDATA[
 
 /*
  * Completes the anonymous method processing, if lambda_expr is null, this
  * means that we have a Statement instead of an Expression embedded 
  */
 AnonymousMethodExpression end_anonymous (ParametersBlock anon_block)
 {
 	AnonymousMethodExpression retval;
 
 	current_anonymous_method.Block = anon_block;
 	retval = current_anonymous_method;
 
 	current_variable = (BlockVariableDeclaration) oob_stack.Pop ();
 	current_local_parameters = (ParametersCompiled) oob_stack.Pop ();
 	current_anonymous_method = (AnonymousMethodExpression) oob_stack.Pop ();
 
 	return retval;
 }
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6275" endline="6294">
<![CDATA[
 
 void start_anonymous (bool lambda, ParametersCompiled parameters, Location loc)
 {
 	if (RootContext.Version == LanguageVersion.ISO_1){
 		Report.FeatureIsNotAvailable (loc, "anonymous methods");
 	}
 
 	oob_stack.Push (current_anonymous_method);
 	oob_stack.Push (current_local_parameters);
 	oob_stack.Push (current_variable);
 
 	current_local_parameters = parameters;
 
 	current_anonymous_method = lambda 
 		? new LambdaExpression (loc) 
 		
 
 	// Force the next block to be created as a ToplevelBlock
 	parsing_anonymous_method = true;
 }
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1167" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="36" endline="43">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="228" endline="236">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1168" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="100" endline="113">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1025" endline="1038">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1169" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="702" endline="712">
<![CDATA[
 
 		static public byte[] ToCapiKeyBlob (DSA dsa, bool includePrivateKey)
 		{
 			if (dsa == null)
 				throw new ArgumentNullException ("dsa");
 
 			if (includePrivateKey)
 				return ToCapiPrivateKeyBlob (dsa);
 			else
 				return ToCapiPublicKeyBlob (dsa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="691" endline="701">
<![CDATA[
 
 		static public byte[] ToCapiKeyBlob (RSA rsa, bool includePrivateKey) 
 		{
 			if (rsa == null)
 				throw new ArgumentNullException ("rsa");
 
 			if (includePrivateKey)
 				return ToCapiPrivateKeyBlob (rsa);
 			else
 				return ToCapiPublicKeyBlob (rsa);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1170" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="507" endline="519">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     Function Accept(ByVal Identifier As String, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Identifier) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="472" endline="488">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1171" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="507" endline="519">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     Function Accept(ByVal Identifier As String, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Identifier) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="429" endline="445">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if the current token is an identifier
     ''' and advances to the next token.
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIdentifier(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIdentifier Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1172" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="507" endline="519">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     Function Accept(ByVal Identifier As String, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Identifier) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="446" endline="455">
<![CDATA[
 
     Function AcceptStringLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsStringLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1173" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="507" endline="519">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     Function Accept(ByVal Identifier As String, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Identifier) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="456" endline="471">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIntegerLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIntegerLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1174" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="94" endline="100">
<![CDATA[
 
 		internal void Write(byte value)
 		{
 			if (pos == buffer.Length)
 				Grow(1);
 			buffer[pos++] = value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="111" endline="118">
<![CDATA[
 
 		internal void Write(short value)
 		{
 			if (pos + 2 > buffer.Length)
 				Grow(2);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1175" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="94" endline="100">
<![CDATA[
 
 		internal void Write(byte value)
 		{
 			if (pos == buffer.Length)
 				Grow(1);
 			buffer[pos++] = value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="216" endline="224">
<![CDATA[
 
 		internal void Align(int alignment)
 		{
 			if (pos + alignment > buffer.Length)
 				Grow(alignment);
 			int newpos = (pos + alignment - 1) & ~(alignment - 1);
 			while (pos < newpos)
 				buffer[pos++] = 0;
 			while (pos < newpos)
 				buffer[pos++] = 0;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1176" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="654" endline="661">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			foreach (var s in statements)
 				s.Resolve (ec);
 			foreach (var s in statements)
 				s.Resolve (ec);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="712" endline="721">
<![CDATA[
 
 		public void ResolveFieldInitializers (BlockContext ec)
 		{
 			if (partial_parts != null) {
 				foreach (TypeContainer part in partial_parts) {
 					part.DoResolveFieldInitializers (ec);
 				}
 				foreach (TypeContainer part in partial_parts) {
 					part.DoResolveFieldInitializers (ec);
 				}
 			}
 			DoResolveFieldInitializers (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1177" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="654" endline="661">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			foreach (var s in statements)
 				s.Resolve (ec);
 			foreach (var s in statements)
 				s.Resolve (ec);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="446" endline="457">
<![CDATA[
 
 		void HackCorlibEnums ()
 		{
 			if (RootContext.StdLib)
 				return;
 
 			// Another Mono corlib HACK
 			// mono_class_layout_fields requires to have enums created
 			// before creating a class which used the enum for any of its fields
 			foreach (var e in hack_corlib_enums)
 				e.CloseType ();
 			foreach (var e in hack_corlib_enums)
 				e.CloseType ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1178" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1391" endline="1398">
<![CDATA[
 
 		public void Encode (byte value)
 		{
 			if (pos == buffer.Length)
 				Grow (1);
 
 			buffer [pos++] = value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1404" endline="1412">
<![CDATA[
 
 		public void Encode (short value)
 		{
 			if (pos + 2 > buffer.Length)
 				Grow (2);
 
 			buffer[pos++] = (byte) value;
 			buffer[pos++] = (byte) (value >> 8);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1179" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="225" endline="238">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns the resolved method.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethod() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If m_Group.Count = 0 Then Return Nothing
             Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="192" endline="207">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a methodinfo.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethodInfo() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1180" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="225" endline="238">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns the resolved method.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethod() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If m_Group.Count = 0 Then Return Nothing
             Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="208" endline="224">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a constructorinfo.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedConstructor() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1181" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="300" endline="308">
<![CDATA[
 	
 	void OutlineConstructor (ConstructorInfo ci)
 	{
 		o.Write (GetMethodVisibility (ci));
 		o.Write (RemoveGenericArity (t.Name));
 		o.Write (" (");
 		OutlineParams (ci.GetParameters ());
 		o.Write (");");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="288" endline="299">
<![CDATA[
 
 	void OutlineEvent (EventInfo ei)
 	{
 		MethodBase accessor = ei.GetAddMethod (true);
 		
 		o.Write (GetMethodVisibility (accessor));
 		o.Write ("event ");
 		o.Write (FormatType (ei.EventHandlerType));
 		o.Write (" ");
 		o.Write (ei.Name);
 		o.Write (";");
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1182" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="300" endline="308">
<![CDATA[
 	
 	void OutlineConstructor (ConstructorInfo ci)
 	{
 		o.Write (GetMethodVisibility (ci));
 		o.Write (RemoveGenericArity (t.Name));
 		o.Write (" (");
 		OutlineParams (ci.GetParameters ());
 		o.Write (");");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="367" endline="395">
<![CDATA[
 	
 	void OutlineMethod (MethodInfo mi)
 	{
 		if (MethodIsExplicitIfaceImpl (mi)) {
 			o.Write (FormatType (mi.ReturnType));
 			o.Write (" ");
 			// MSFT has no way to get the method that we are overriding
 			// from the interface. this would allow us to pretty print
 			// the type name (and be more correct if there compiler
 			// were to do some strange naming thing).
 		} else {
 			o.Write (GetMethodVisibility (mi));
 			o.Write (GetMethodModifiers  (mi));
 			o.Write (FormatType (mi.ReturnType));
 			o.Write (" ");
 		}
 
 		o.Write (mi.Name);
 #if NET_2_0
 		o.Write (FormatGenericParams (mi.GetGenericArguments ()));
 #endif
 		o.Write (" (");
 		OutlineParams (mi.GetParameters ());
 		o.Write (")");
 #if NET_2_0
 		WriteGenericConstraints (mi.GetGenericArguments ());
 #endif
 		o.Write (";");
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1183" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="300" endline="308">
<![CDATA[
 	
 	void OutlineConstructor (ConstructorInfo ci)
 	{
 		o.Write (GetMethodVisibility (ci));
 		o.Write (RemoveGenericArity (t.Name));
 		o.Write (" (");
 		OutlineParams (ci.GetParameters ());
 		o.Write (");");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="396" endline="413">
<![CDATA[
 	
 	void OutlineOperator (MethodInfo mi)
 	{
 		o.Write (GetMethodVisibility (mi));
 		o.Write (GetMethodModifiers  (mi));
 		if (mi.Name == "op_Explicit" || mi.Name == "op_Implicit") {
 			o.Write (mi.Name.Substring (3).ToLower ());
 			o.Write (" operator ");
 			o.Write (FormatType (mi.ReturnType));
 		} else {
 			o.Write (FormatType (mi.ReturnType));
 			o.Write (" operator ");
 			o.Write (OperatorFromName (mi.Name));
 		}
 		o.Write (" (");
 		OutlineParams (mi.GetParameters ());
 		o.Write (");");
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1184" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2020" endline="2027">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2028" endline="2035">
<![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1185" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2020" endline="2027">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2036" endline="2043">
<![CDATA[
 
 		public void EmitAttribute (PropertyBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1186" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2020" endline="2027">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2044" endline="2051">
<![CDATA[
 
 		public void EmitAttribute (TypeBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1187" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="84" endline="96">
<![CDATA[
 		}
 
 		public CallingConventions CallingConventions {
 			get {
 				CallingConventions cc = parameters.CallingConvention;
 				if (!IsInterface)
 					if ((ModFlags & Modifiers.STATIC) == 0)
 						cc |= CallingConventions.HasThis;
 
 				// FIXME
 			
 				return cc;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2053" endline="2073">
<![CDATA[
 
 		//
 		// Used for visiblity checks to tests whether this definition shares
 		// base type baseType, it does member-definition search
 		//
 		public bool IsBaseTypeDefinition (TypeSpec baseType)
 		{
 			// RootContext check
 			if (TypeBuilder == null)
 				return false;
 
 			var type = spec;
 			do {
 				if (type.MemberDefinition == baseType.MemberDefinition)
 					return true;
 
 				type = type.BaseType;
 			} while (type != null);
 
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1188" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="290" endline="297">
<![CDATA[
 
 		protected override void WriteImpl(MetadataWriter mw)
 		{
 			foreach (Guid guid in list)
 			{
 				mw.Write(guid.ToByteArray());
 			}
 			foreach (Guid guid in list)
 			{
 				mw.Write(guid.ToByteArray());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="193" endline="201">
<![CDATA[
 
 		protected override void WriteImpl(MetadataWriter mw)
 		{
 			foreach (string str in list)
 			{
 				mw.Write(System.Text.Encoding.UTF8.GetBytes(str));
 				mw.Write((byte)0);
 			}
 			foreach (string str in list)
 			{
 				mw.Write(System.Text.Encoding.UTF8.GetBytes(str));
 				mw.Write((byte)0);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1189" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="177" endline="184">
<![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="165" endline="174">
<![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If m_LocalBuilder IsNot Nothing Then
             Emitter.EmitStoreVariable(Info, m_LocalBuilder)
         ElseIf FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1190" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="177" endline="184">
<![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1562" endline="1573">
<![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitLoadVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1191" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="62" endline="71">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As ParameterList)
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = Parameters
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="72" endline="81">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As Mono.Cecil.TypeReference())
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = New ParameterList(Me, Parameters)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1192" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="715" endline="723">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1193" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1894" endline="1902">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1194" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1093" endline="1112">
<![CDATA[
 	}
 
 	sealed class FieldMarshalTable 
 	{
 		internal const int Index = 0x0D;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int NativeType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1195" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1874" endline="1893">
<![CDATA[
 	}
 
 	sealed class FieldRVATable 
 	{
 		internal const int Index = 0x1D;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1196" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1303" endline="1322">
<![CDATA[
 	}
 
 	sealed class FieldLayoutTable 
 	{
 		internal const int Index = 0x10;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1197" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1323" endline="1331">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1198" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1470" endline="1489">
<![CDATA[
 	}
 
 	sealed class PropertyMapTable 
 	{
 		internal const int Index = 0x15;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int PropertyList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1199" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2402" endline="2410">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMethodDefOrRef(records[i].Method);
 				mw.WriteBlobIndex(records[i].Instantiation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMethodDefOrRef(records[i].Method);
 				mw.WriteBlobIndex(records[i].Instantiation);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1200" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2443" endline="2462">
<![CDATA[
 	}
 
 	sealed class GenericParamConstraintTable 
 	{
 		internal const int Index = 0x2C;
 
 		internal struct Record
 		{
 			internal int Owner;
 			internal int Constraint;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1201" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2382" endline="2401">
<![CDATA[
 	}
 
 	sealed class MethodSpecTable 
 	{
 		internal const int Index = 0x2B;
 
 		internal struct Record
 		{
 			internal int Method;
 			internal int Instantiation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1202" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1113" endline="1121">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1203" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1451" endline="1460">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1204" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1429" endline="1450">
<![CDATA[
 	}
 
 	sealed class EventTable 
 	{
 		internal const int Index = 0x14;
 
 		internal struct Record
 		{
 			internal short EventFlags;
 			internal int Name;
 			internal int EventType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1205" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1548" endline="1577">
<![CDATA[
 	}
 
 	sealed class MethodSemanticsTable 
 	{
 		internal const int Index = 0x18;
 
 		// semantics
 		internal const short Setter = 0x0001;
 		internal const short Getter = 0x0002;
 		internal const short Other = 0x0004;
 		internal const short AddOn = 0x0008;
 		internal const short RemoveOn = 0x0010;
 		internal const short Fire = 0x0020;
 
 		internal struct Record
 		{
 			internal short Semantics;
 			internal int Method;
 			internal int Association;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1206" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2294" endline="2304">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Number);
 				mw.Write(records[i].Flags);
 				mw.WriteTypeOrMethodDef(records[i].Owner);
 				mw.WriteStringIndex(records[i].Name);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Number);
 				mw.Write(records[i].Flags);
 				mw.WriteTypeOrMethodDef(records[i].Owner);
 				mw.WriteStringIndex(records[i].Name);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1207" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2238" endline="2246">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].NestedClass);
 				mw.WriteTypeDef(records[i].EnclosingClass);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].NestedClass);
 				mw.WriteTypeDef(records[i].EnclosingClass);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1208" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1412" endline="1420">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1209" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1529" endline="1538">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1210" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1578" endline="1587">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Semantics);
 				mw.WriteMethodDef(records[i].Method);
 				mw.WriteHasSemantics(records[i].Association);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Semantics);
 				mw.WriteMethodDef(records[i].Method);
 				mw.WriteHasSemantics(records[i].Association);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1211" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2432" endline="2442">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1212" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1812" endline="1835">
<![CDATA[
 	}
 
 	sealed class ImplMapTable 
 	{
 		internal const int Index = 0x1C;
 
 		internal struct Record
 		{
 			internal short MappingFlags;
 			internal int MemberForwarded;
 			internal int ImportName;
 			internal int ImportScope;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1213" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2268" endline="2293">
<![CDATA[
 	}
 
 	sealed class GenericParamTable 
 	{
 		internal const int Index = 0x2A;
 
 		internal struct Record
 		{
 			internal short Number;
 			internal short Flags;
 			internal int Owner;
 			internal int Name;
 			// not part of the table, we use it to be able to fixup the GenericParamConstraint table
 			internal int unsortedIndex;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1214" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2463" endline="2471">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteGenericParam(records[i].Owner);
 				mw.WriteTypeDefOrRef(records[i].Constraint);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteGenericParam(records[i].Owner);
 				mw.WriteTypeDefOrRef(records[i].Constraint);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1215" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="767" endline="788">
<![CDATA[
 	}
 
 	sealed class MemberRefTable 
 	{
 		internal const int Index = 0x0A;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1216" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1156" endline="1177">
<![CDATA[
 	}
 
 	sealed class DeclSecurityTable 
 	{
 		internal const int Index = 0x0E;
 
 		internal struct Record
 		{
 			internal short Action;
 			internal int Parent;
 			internal int PermissionSet;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1217" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1178" endline="1187">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Action);
 				mw.WriteHasDeclSecurity(records[i].Parent);
 				mw.WriteBlobIndex(records[i].PermissionSet);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Action);
 				mw.WriteHasDeclSecurity(records[i].Parent);
 				mw.WriteBlobIndex(records[i].PermissionSet);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1218" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="965" endline="986">
<![CDATA[
 	}
 
 	sealed class CustomAttributeTable 
 	{
 		internal const int Index = 0x0C;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int Type;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1219" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1507" endline="1528">
<![CDATA[
 	}
 
 	sealed class PropertyTable 
 	{
 		internal const int Index = 0x17;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Type;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1220" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1266" endline="1276">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			Array.Sort(records, 0, rowCount, this);
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].PackingSize);
 				mw.Write(records[i].ClassSize);
 				mw.WriteTypeDef(records[i].Parent);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].PackingSize);
 				mw.Write(records[i].ClassSize);
 				mw.WriteTypeDef(records[i].Parent);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1221" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2112" endline="2137">
<![CDATA[
 	}
 
 	sealed class ExportedTypeTable 
 	{
 		internal const int Index = 0x27;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int TypeDefId;
 			internal int TypeName;
 			internal int TypeNamespace;
 			internal int Implementation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeDefId = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeDefId = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1222" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1392" endline="1411">
<![CDATA[
 	}
 
 	sealed class EventMapTable 
 	{
 		internal const int Index = 0x12;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int EventList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1223" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1340" endline="1348">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1224" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="575" endline="596">
<![CDATA[
 	}
 
 	sealed class FieldTable 
 	{
 		internal const int Index = 0x04;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1225" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="833" endline="854">
<![CDATA[
 	}
 
 	sealed class ConstantTable 
 	{
 		internal const int Index = 0x0B;
 
 		internal struct Record
 		{
 			internal short Type;
 			internal int Parent;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1226" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1256" endline="1265">
<![CDATA[
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].PackingSize = mr.ReadInt16();
 				records[i].ClassSize = mr.ReadInt32();
 				records[i].Parent = mr.ReadTypeDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].PackingSize = mr.ReadInt16();
 				records[i].ClassSize = mr.ReadInt32();
 				records[i].Parent = mr.ReadTypeDef();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1227" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="474" endline="487">
<![CDATA[
 
 		public int Size
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				return 0;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1228" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="488" endline="502">
<![CDATA[
 		}
 
 		public PackingSize PackingSize
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				return PackingSize.Unspecified;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1229" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2218" endline="2237">
<![CDATA[
 	}
 
 	sealed class NestedClassTable 
 	{
 		internal const int Index = 0x29;
 
 		internal struct Record
 		{
 			internal int NestedClass;
 			internal int EnclosingClass;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1230" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2138" endline="2149">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.Write(records[i].TypeDefId);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNamespace);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.Write(records[i].TypeDefId);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNamespace);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1231" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="789" endline="798">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1232" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1857" endline="1868">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MemberForwarded))
 				{
 					records[i].MemberForwarded = moduleBuilder.ResolvePseudoToken(records[i].MemberForwarded);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MemberForwarded))
 				{
 					records[i].MemberForwarded = moduleBuilder.ResolvePseudoToken(records[i].MemberForwarded);
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1233" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="855" endline="864">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1234" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2071" endline="2092">
<![CDATA[
 	}
 
 	sealed class FileTable 
 	{
 		internal const int Index = 0x26;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int Name;
 			internal int HashValue;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1235" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1684" endline="1705">
<![CDATA[
 	}
 
 	sealed class MethodImplTable 
 	{
 		internal const int Index = 0x19;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int MethodBody;
 			internal int MethodDeclaration;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1236" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2174" endline="2197">
<![CDATA[
 	}
 
 	sealed class ManifestResourceTable 
 	{
 		internal const int Index = 0x28;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Flags;
 			internal int Name;
 			internal int Implementation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1237" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1490" endline="1498">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1238" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="987" endline="996">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasCustomAttribute(records[i].Parent);
 				mw.WriteCustomAttributeType(records[i].Type);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasCustomAttribute(records[i].Parent);
 				mw.WriteCustomAttributeType(records[i].Type);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1239" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1706" endline="1715">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1240" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="660" endline="681">
<![CDATA[
 	}
 
 	sealed class ParamTable 
 	{
 		internal const int Index = 0x08;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal short Sequence;
 			internal int Name;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1241" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="506" endline="515">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteResolutionScope(records[i].ResolutionScope);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNameSpace);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteResolutionScope(records[i].ResolutionScope);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNameSpace);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1242" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="484" endline="505">
<![CDATA[
 	}
 
 	sealed class TypeRefTable 
 	{
 		internal const int Index = 0x01;
 
 		internal struct Record
 		{
 			internal int ResolutionScope;
 			internal int TypeName;
 			internal int TypeNameSpace;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1243" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="611" endline="639">
<![CDATA[
 	}
 
 	sealed class MethodDefTable 
 	{
 		internal const int Index = 0x06;
 		private int baseRVA;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal short ImplFlags;
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 			internal int ParamList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1244" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1836" endline="1846">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MappingFlags);
 				mw.WriteMemberForwarded(records[i].MemberForwarded);
 				mw.WriteStringIndex(records[i].ImportName);
 				mw.WriteModuleRef(records[i].ImportScope);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MappingFlags);
 				mw.WriteMemberForwarded(records[i].MemberForwarded);
 				mw.WriteStringIndex(records[i].ImportName);
 				mw.WriteModuleRef(records[i].ImportScope);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1245" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="450" endline="461">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Generation);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteGuidIndex(records[i].Mvid);
 				mw.WriteGuidIndex(records[i].EncId);
 				mw.WriteGuidIndex(records[i].EncBaseId);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Generation);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteGuidIndex(records[i].Mvid);
 				mw.WriteGuidIndex(records[i].EncId);
 				mw.WriteGuidIndex(records[i].EncBaseId);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1246" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2093" endline="2102">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1247" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="822" endline="832">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1248" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2028" endline="2043">
<![CDATA[
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKeyOrToken = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKeyOrToken = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1249" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="86" endline="97">
<![CDATA[
 
 		public override FieldInfo[] __GetDeclaredFields()
 		{
 			int field = module.TypeDef.records[index].FieldList - 1;
 			int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records[index + 1].FieldList - 1 
 			FieldInfo[] fields = new FieldInfo[end - field];
 			for (int i = 0; field < end; i++, field++)
 			{
 				fields[i] = module.GetFieldAt(this, field);
 			}
 			for (int i = 0; field < end; i++, field++)
 			{
 				fields[i] = module.GetFieldAt(this, field);
 			}
 			return fields;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1250" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="52" endline="62">
<![CDATA[
 
 		internal MethodBody GetMethodBody(IGenericContext context)
 		{
 			if ((GetMethodImplementationFlags() & MethodImplAttributes.CodeTypeMask) != MethodImplAttributes.IL)
 			{
 				// method is not IL
 				return null;
 			}
 			int rva = module.MethodDef.records[index].RVA;
 			return rva == 0 ? null 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1251" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="390" endline="449">
<![CDATA[
 		protected int rowCount;
 
 		internal sealed override int RowCount
 		{
 			get { return rowCount; }
 			set { rowCount = value; records = new T[value]; }
 		}
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			throw new InvalidOperationException();
 		}
 
 		internal int AddRecord(T newRecord)
 		{
 			if (rowCount == records.Length)
 			{
 				T[] newarr = new T[records.Length * 2];
 				Array.Copy(records, newarr, records.Length);
 				records = newarr;
 			}
 			records[rowCount++] = newRecord;
 			return rowCount;
 		}
 
 		internal int AddVirtualRecord()
 		{
 			return ++rowCount;
 		}
 
 		internal override void Write(MetadataWriter mw)
 		{
 			throw new InvalidOperationException();
 		}
 	}
 
 	sealed class ModuleTable 
 	{
 		internal const int Index = 0x00;
 
 		internal struct Record
 		{
 			internal short Generation;
 			internal int Name; // -> StringHeap
 			internal int Mvid; // -> GuidHeap
 			internal int EncId; // -> GuidHeap
 			internal int EncBaseId; // -> GuidHeap
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Generation = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Mvid = mr.ReadGuidIndex();
 				records[i].EncId = mr.ReadGuidIndex();
 				records[i].EncBaseId = mr.ReadGuidIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Generation = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Mvid = mr.ReadGuidIndex();
 				records[i].EncId = mr.ReadGuidIndex();
 				records[i].EncBaseId = mr.ReadGuidIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1252" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1725" endline="1740">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MethodBody))
 				{
 					records[i].MethodBody = moduleBuilder.ResolvePseudoToken(records[i].MethodBody);
 				}
 				if (moduleBuilder.IsPseudoToken(records[i].MethodDeclaration))
 				{
 					records[i].MethodDeclaration = moduleBuilder.ResolvePseudoToken(records[i].MethodDeclaration);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MethodBody))
 				{
 					records[i].MethodBody = moduleBuilder.ResolvePseudoToken(records[i].MethodBody);
 				}
 				if (moduleBuilder.IsPseudoToken(records[i].MethodDeclaration))
 				{
 					records[i].MethodDeclaration = moduleBuilder.ResolvePseudoToken(records[i].MethodDeclaration);
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1253" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="113" endline="124">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			int method = module.TypeDef.records[index].MethodList - 1;
 			int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records[index + 1].MethodList - 1 
 			MethodBase[] methods = new MethodBase[end - method];
 			for (int i = 0; method < end; method++, i++)
 			{
 				methods[i] = module.GetMethodAt(this, method);
 			}
 			for (int i = 0; method < end; method++, i++)
 			{
 				methods[i] = module.GetMethodAt(this, method);
 			}
 			return methods;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1254" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1929" endline="1962">
<![CDATA[
 	}
 
 	sealed class AssemblyTable 
 	{
 		internal const int Index = 0x20;
 
 		internal struct Record
 		{
 			internal int HashAlgId;
 			internal ushort MajorVersion;
 			internal ushort MinorVersion;
 			internal ushort BuildNumber;
 			internal ushort RevisionNumber;
 			internal int Flags;
 			internal int PublicKey;
 			internal int Name;
 			internal int Culture;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].HashAlgId = mr.ReadInt32();
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKey = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].HashAlgId = mr.ReadInt32();
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKey = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1255" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ManifestResourceInfo.cs" startline="69" endline="88">
<![CDATA[
 		}
 
 		public string FileName
 		{
 			get
 			{
 				int implementation = module.ManifestResource.records[index].Implementation;
 				if ((implementation >> 24) == FileTable.Index)
 				{
 					if ((implementation & 0xFFFFFF) == 0)
 					{
 						return null;
 					}
 					else
 					{
 						return module.GetString(module.File.records[(implementation & 0xFFFFFF) - 1].Name);
 					}
 				}
 				throw new NotImplementedException();
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1256" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="525" endline="552">
<![CDATA[
 	}
 
 	sealed class TypeDefTable 
 	{
 		internal const int Index = 0x02;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int TypeName;
 			internal int TypeNamespace;
 			internal int Extends;
 			internal int FieldList;
 			internal int MethodList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1257" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="47" endline="58">
<![CDATA[
 
 		public override Type BaseType
 		{
 			get
 			{
 				int extends = module.TypeDef.records[index].Extends;
 				if ((extends & 0xFFFFFF) == 0)
 				{
 					return null;
 				}
 				return module.ResolveType(extends, this);
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1258" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="724" endline="740">
<![CDATA[
 		}
 
 		private TypeDefImpl FindMethodOwner(int methodIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1259" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="624" endline="639">
<![CDATA[
 
 		private TypeDefImpl FindFieldOwner(int fieldIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1260" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="297" endline="317">
<![CDATA[
 
 		public override Type DeclaringType
 		{
 			get
 			{
 				// note that we cannot use Type.IsNested for this, because that calls DeclaringType
 				if ((this.Attributes & TypeAttributes.VisibilityMask & ~TypeAttributes.Public) == 0)
 				{
 					return null;
 				}
 				// TODO use binary search (if sorted)
 				int token = this.MetadataToken;
 				for (int i = 0; i < module.NestedClass.records.Length; i++)
 				{
 					if (module.NestedClass.records[i].NestedClass == token)
 					{
 						return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
 					}
 				}
 				for (int i = 0; i < module.NestedClass.records.Length; i++)
 				{
 					if (module.NestedClass.records[i].NestedClass == token)
 					{
 						return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
 					}
 				}
 				throw new InvalidOperationException();
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1261" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2198" endline="2208">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1262" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2044" endline="2059">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1263" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3369" endline="3380">
<![CDATA[
 
 		//
 		// Any type_name independent checks
 		//
 		protected virtual void DoMemberTypeIndependentChecks ()
 		{
 			if ((Parent.ModFlags & Modifiers.SEALED) != 0 &&
 				(ModFlags & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 				Report.Error (549, Location, "New virtual member `{0}' is declared in a sealed class `{1}'",
 					GetSignatureForError (), Parent.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3196" endline="3213">
<![CDATA[
 
 		public override void Emit()
 		{
 			// for extern static method must be specified either DllImport attribute or MethodImplAttribute.
 			// We are more strict than csc and report this as an error because SRE does not allow emit that
 			if ((ModFlags & Modifiers.EXTERN) != 0 && !is_external_implementation) {
 				if (this is Constructor) {
 					Report.Error (824, Location,
 						"Constructor `{0}' is marked `external' but has no external implementation specified", GetSignatureForError ());
 				} else {
 					Report.Error (626, Location,
 						"`{0}' is marked as an external but has no DllImport attribute. Consider adding a DllImport attribute to specify the external implementation",
 						GetSignatureForError ());
 				}
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1264" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3369" endline="3380">
<![CDATA[
 
 		//
 		// Any type_name independent checks
 		//
 		protected virtual void DoMemberTypeIndependentChecks ()
 		{
 			if ((Parent.ModFlags & Modifiers.SEALED) != 0 &&
 				(ModFlags & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 				Report.Error (549, Location, "New virtual member `{0}' is declared in a sealed class `{1}'",
 					GetSignatureForError (), Parent.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="618" endline="637">
<![CDATA[
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			if ((ModFlags & Modifiers.BACKING_FIELD) != 0)
 				return;
 
 			base.DoMemberTypeDependentChecks ();
 
 			if ((ModFlags & Modifiers.VOLATILE) != 0) {
 				if (!CanBeVolatile ()) {
 					Report.Error (677, Location, "`{0}'
 						GetSignatureForError (), TypeManager.CSharpName (MemberType));
 				}
 
 				if ((ModFlags & Modifiers.READONLY) != 0) {
 					Report.Error (678, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1265" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3369" endline="3380">
<![CDATA[
 
 		//
 		// Any type_name independent checks
 		//
 		protected virtual void DoMemberTypeIndependentChecks ()
 		{
 			if ((Parent.ModFlags & Modifiers.SEALED) != 0 &&
 				(ModFlags & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 				Report.Error (549, Location, "New virtual member `{0}' is declared in a sealed class `{1}'",
 					GetSignatureForError (), Parent.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="569" endline="589">
<![CDATA[
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			//
 			// Accessors modifiers check
 			//
 			if (AccessorSecond != null) {
 				if ((Get.ModFlags & Modifiers.AccessibilityMask) != 0 && (Set.ModFlags & Modifiers.AccessibilityMask) != 0) {
 					Report.Error (274, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			} else if ((ModFlags & Modifiers.OVERRIDE) == 0 && 
 				(Get == null && (Set.ModFlags & Modifiers.AccessibilityMask) != 0) ||
 				(Set == null && (Get.ModFlags & Modifiers.AccessibilityMask) != 0)) {
 				Report.Error (276, Location, 
 					      "`{0}'
 					      GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1266" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3369" endline="3380">
<![CDATA[
 
 		//
 		// Any type_name independent checks
 		//
 		protected virtual void DoMemberTypeIndependentChecks ()
 		{
 			if ((Parent.ModFlags & Modifiers.SEALED) != 0 &&
 				(ModFlags & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 				Report.Error (549, Location, "New virtual member `{0}' is declared in a sealed class `{1}'",
 					GetSignatureForError (), Parent.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2483" endline="2498">
<![CDATA[
 
 		protected override bool DoDefineMembers ()
 		{
 			if ((ModFlags & Modifiers.ABSTRACT) == Modifiers.ABSTRACT && (ModFlags & (Modifiers.SEALED | Modifiers.STATIC)) != 0) {
 				Report.Error (418, Location, "`{0}'
 			}
 
 			if ((ModFlags & (Modifiers.SEALED | Modifiers.STATIC)) == (Modifiers.SEALED | Modifiers.STATIC)) {
 				Report.Error (441, Location, "`{0}'
 			}
 
 			if (InstanceConstructors == null && !IsStatic)
 				DefineDefaultConstructor (false);
 
 			return base.DoDefineMembers ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1267" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="331" endline="342">
<![CDATA[
 
 		public override void AddPermissionRequests (PermissionSet[] permissions)
 		{
 			try {
 				if (add_permission == null)
 					add_permission = typeof (AssemblyBuilder).GetMethod ("AddPermissionRequests", BindingFlags.Instance | BindingFlags.NonPublic);
 
 				add_permission.Invoke (builder, permissions);
 			} catch {
 				base.AddPermissionRequests (permissions);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="392" endline="403">
<![CDATA[
 
 		public override void SetFlags (uint flags, Location loc)
 		{
 			try {
 				if (assembly_flags == null)
 					assembly_flags = typeof (AssemblyBuilder).GetField ("flags", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_flags.SetValue (builder, flags);
 			} catch {
 				base.SetFlags (flags, loc);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1268" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="331" endline="342">
<![CDATA[
 
 		public override void AddPermissionRequests (PermissionSet[] permissions)
 		{
 			try {
 				if (add_permission == null)
 					add_permission = typeof (AssemblyBuilder).GetMethod ("AddPermissionRequests", BindingFlags.Instance | BindingFlags.NonPublic);
 
 				add_permission.Invoke (builder, permissions);
 			} catch {
 				base.AddPermissionRequests (permissions);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="368" endline="379">
<![CDATA[
 
 		public override void SetAlgorithmId (uint value, Location loc)
 		{
 			try {
 				if (assembly_algorithm == null)
 					assembly_algorithm = typeof (AssemblyBuilder).GetField ("algid", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_algorithm.SetValue (builder, value);
 			} catch {
 				base.SetAlgorithmId (value, loc);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1269" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="331" endline="342">
<![CDATA[
 
 		public override void AddPermissionRequests (PermissionSet[] permissions)
 		{
 			try {
 				if (add_permission == null)
 					add_permission = typeof (AssemblyBuilder).GetMethod ("AddPermissionRequests", BindingFlags.Instance | BindingFlags.NonPublic);
 
 				add_permission.Invoke (builder, permissions);
 			} catch {
 				base.AddPermissionRequests (permissions);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="380" endline="391">
<![CDATA[
 
 		public override void SetCulture (string culture, Location loc)
 		{
 			try {
 				if (assembly_culture == null)
 					assembly_culture = typeof (AssemblyBuilder).GetField ("culture", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_culture.SetValue (builder, culture);
 			} catch {
 				base.SetCulture (culture, loc);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1270" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="331" endline="342">
<![CDATA[
 
 		public override void AddPermissionRequests (PermissionSet[] permissions)
 		{
 			try {
 				if (add_permission == null)
 					add_permission = typeof (AssemblyBuilder).GetMethod ("AddPermissionRequests", BindingFlags.Instance | BindingFlags.NonPublic);
 
 				add_permission.Invoke (builder, permissions);
 			} catch {
 				base.AddPermissionRequests (permissions);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="404" endline="415">
<![CDATA[
 
 		public override void SetVersion (Version version, Location loc)
 		{
 			try {
 				if (assembly_version == null)
 					assembly_version = typeof (AssemblyBuilder).GetField ("version", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_version.SetValue (builder, version.ToString (4));
 			} catch {
 				base.SetVersion (version, loc);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1271" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="893" endline="900">
<![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of GenericParameter)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="901" endline="908">
<![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1272" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="336" endline="350">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Compares this token to any of the specified tokens. 
     ''' Returns true if any token matches.
     ''' </summary>
     ''' <param name="AnySpecial"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Overloads Function Equals(ByVal AnySpecial() As KS) As Boolean
         For i As Integer = 0 To VB.UBound(AnySpecial)
             If Equals(AnySpecial(i)) = True Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="169" endline="176">
<![CDATA[
 
     Function IsNamespaceExact(ByVal A As String, ByVal B As String) As Boolean
         For i As Integer = 0 To Me.Count - 1
             Dim ns As [Namespace] = Me.Item(i)
             If ns.Equals(A, B) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1273" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" startline="336" endline="350">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Compares this token to any of the specified tokens. 
     ''' Returns true if any token matches.
     ''' </summary>
     ''' <param name="AnySpecial"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Overloads Function Equals(ByVal AnySpecial() As KS) As Boolean
         For i As Integer = 0 To VB.UBound(AnySpecial)
             If Equals(AnySpecial(i)) = True Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="55" endline="62">
<![CDATA[
     End Property
 
     Function FindNamespace(ByVal A As String, ByVal B As String) As [Namespace]
         For i As Integer = 0 To Count - 1
             If Item(i).Equals(A, B) Then Return Item(i)
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1274" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="155" endline="164">
<![CDATA[
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="175" endline="186">
<![CDATA[
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1275" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1276" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="720" endline="733">
<![CDATA[
 
     Shared Function IsPrivate(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="734" endline="747">
<![CDATA[
 
     Shared Function IsFamilyOrAssembly(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1277" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="720" endline="733">
<![CDATA[
 
     Shared Function IsPrivate(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1046" endline="1053">
<![CDATA[
 
     Public Shared Function GetElementType(ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim rT As ByReferenceType = TryCast(Type, ByReferenceType)
         If rT IsNot Nothing Then Return rT.ElementType
         Dim aT As Mono.Cecil.ArrayType = TryCast(Type, Mono.Cecil.ArrayType)
         If aT IsNot Nothing Then Return aT.ElementType
         Throw New InternalException
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1278" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1765" endline="1779">
<![CDATA[
 
     Shared Sub EmitRetOrLeave(ByVal Info As EmitInfo, ByVal CurrentStatement As Statement, ByVal HasReturnValue As Boolean)
         Dim emitLeave As Boolean
 
         emitLeave = IsLeaveNecessary(CurrentStatement, Nothing)
 
         If emitLeave Then
             If HasReturnValue Then
                 Emitter.EmitStoreVariable(Info, Info.Method.DefaultReturnVariable)
             End If
             Emitter.EmitLeave(Info, CurrentStatement.FindParentCodeBlock.UpmostBlock.EndOfMethodLabel)
         Else
             Emitter.EmitRet(Info)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="32" endline="45">
<![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.new(Parent)
 
         Dim refType As ByReferenceType = TryCast(Expression.ExpressionType, ByReferenceType)
 
         If refType Is Nothing Then Throw New InternalException
 
         m_Expression = Expression
         m_ExpressionType = refType.ElementType
 
         Classification = New VariableClassification(Me, Expression, m_ExpressionType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then Helper.ErrorRecoveryNotImplemented(Me.Location)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1279" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1765" endline="1779">
<![CDATA[
 
     Shared Sub EmitRetOrLeave(ByVal Info As EmitInfo, ByVal CurrentStatement As Statement, ByVal HasReturnValue As Boolean)
         Dim emitLeave As Boolean
 
         emitLeave = IsLeaveNecessary(CurrentStatement, Nothing)
 
         If emitLeave Then
             If HasReturnValue Then
                 Emitter.EmitStoreVariable(Info, Info.Method.DefaultReturnVariable)
             End If
             Emitter.EmitLeave(Info, CurrentStatement.FindParentCodeBlock.UpmostBlock.EndOfMethodLabel)
         Else
             Emitter.EmitRet(Info)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" startline="54" endline="72">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
         If CecilHelper.IsGenericParameter(m_Expression.ExpressionType) Then
             Emitter.EmitBox(Info, m_Expression.ExpressionType)
         End If
         Emitter.EmitIsInst(Info, m_Expression.ExpressionType, m_Type.ResolvedType)
 
         Emitter.EmitLoadNull(Info.Clone(Me, True, False, Compiler.TypeCache.System_Object))
         If m_Is Then
             Emitter.EmitNotEquals(Info, m_Type.ResolvedType)
         Else
             Emitter.EmitEquals(Info, m_Type.ResolvedType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1280" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="398" endline="520">
<![CDATA[
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodBuilder method;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(MethodBuilder method, int parameter)
 			{
 				this.method = method;
 				this.parameter = parameter;
 			}
 
 			private ParameterBuilder ParameterBuilder
 			{
 				get
 				{
 					if (method.parameters != null)
 					{
 						foreach (ParameterBuilder pb in method.parameters)
 						{
 							if (pb.Position == parameter)
 							{
 								return pb;
 							}
 						}
 					}
 					return null;
 				}
 			}
 
 			public override string Name
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.Name 
 				}
 			}
 
 			public override Type ParameterType
 			{
 				get { return parameter == -1 ? method.returnType 
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? (ParameterAttributes)pb.Attributes 
 				}
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.HasDefault) != 0)
 					{
 						return method.ModuleBuilder.Constant.GetRawConstantValue(method.ModuleBuilder, pb.PseudoToken);
 					}
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.Optional) != 0)
 					{
 						return Missing.Value;
 					}
 					return null;
 				}
 			}
 
 			private Type[] GetCustomModifiers(int optOrReq)
 			{
 				if (method.modifiers == null || method.modifiers[parameter + 1] == null)
 				{
 					return Type.EmptyTypes;
 				}
 				return Util.Copy(method.modifiers[parameter + 1][optOrReq]);
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return GetCustomModifiers(0);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return GetCustomModifiers(1);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method; }
 			}
 
 			public override int MetadataToken
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.PseudoToken 
 				}
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[parameterTypes.Length];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="140" endline="151">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = CallingConventions.Standard;
 			foreach (Type type in parameterTypes)
 			{
 				sig.AddArgument(type);
 			}
 			foreach (Type type in parameterTypes)
 			{
 				sig.AddArgument(type);
 			}
 			return sig;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1281" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="398" endline="520">
<![CDATA[
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodBuilder method;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(MethodBuilder method, int parameter)
 			{
 				this.method = method;
 				this.parameter = parameter;
 			}
 
 			private ParameterBuilder ParameterBuilder
 			{
 				get
 				{
 					if (method.parameters != null)
 					{
 						foreach (ParameterBuilder pb in method.parameters)
 						{
 							if (pb.Position == parameter)
 							{
 								return pb;
 							}
 						}
 					}
 					return null;
 				}
 			}
 
 			public override string Name
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.Name 
 				}
 			}
 
 			public override Type ParameterType
 			{
 				get { return parameter == -1 ? method.returnType 
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? (ParameterAttributes)pb.Attributes 
 				}
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.HasDefault) != 0)
 					{
 						return method.ModuleBuilder.Constant.GetRawConstantValue(method.ModuleBuilder, pb.PseudoToken);
 					}
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.Optional) != 0)
 					{
 						return Missing.Value;
 					}
 					return null;
 				}
 			}
 
 			private Type[] GetCustomModifiers(int optOrReq)
 			{
 				if (method.modifiers == null || method.modifiers[parameter + 1] == null)
 				{
 					return Type.EmptyTypes;
 				}
 				return Util.Copy(method.modifiers[parameter + 1][optOrReq]);
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return GetCustomModifiers(0);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return GetCustomModifiers(1);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method; }
 			}
 
 			public override int MetadataToken
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.PseudoToken 
 				}
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[parameterTypes.Length];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="746" endline="759">
<![CDATA[
 
 		protected static Type[] BindTypeParameters(IGenericBinder binder, Type[] types)
 		{
 			if (types == null || types.Length == 0)
 			{
 				return Type.EmptyTypes;
 			}
 			Type[] expanded = new Type[types.Length];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = types[i].BindTypeParameters(binder);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = types[i].BindTypeParameters(binder);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1282" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="121" endline="130">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         result = Helper.ResolveTypeReferences(m_ConstantExpression) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" startline="52" endline="61">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_PreCondition, m_PostCondition) AndAlso result
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1283" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="121" endline="130">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         result = Helper.ResolveTypeReferences(m_ConstantExpression) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="116" endline="123">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_TypeName, m_ArgumentList, m_VariableInitializer) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1284" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="145" endline="157">
<![CDATA[
     End Property
 
     Private Function IsNegativeStep() As Boolean
         Dim constant As Object
 
         constant = m_LoopStepExpression.ConstantValue
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) < 0
         Else
             Return CDbl(constant) < 0
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" startline="158" endline="169">
<![CDATA[
 
     Private Function IsPositiveStep() As Boolean
         Dim constant As Object
 
         constant = m_LoopStepExpression.ConstantValue
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) > 0
         Else
             Return CDbl(constant) > 0
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1285" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="467" endline="473">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="460" endline="466">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1286" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="51" endline="61">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
 
         Emitter.EmitLoadIndirect(Info, m_Expression.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="30" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Local Is Nothing Then
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
             m_Local = Emitter.DeclareLocal(Info, m_Expression.ExpressionType)
             Emitter.EmitStoreVariable(Info, m_Local)
         End If
 
         Emitter.EmitLoadVariable(Info, m_Local)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1287" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="51" endline="61">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
 
         Emitter.EmitLoadIndirect(Info, m_Expression.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="36" endline="46">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
         Emitter.EmitConversion(m_ErrNumber.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1288" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" startline="51" endline="61">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
 
         Emitter.EmitLoadIndirect(Info, m_Expression.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" startline="58" endline="74">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_WithExpression Is m_WithVariableExpression = False Then
             m_WithVariable = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, m_WithExpression.ExpressionType), "WithVariable" & Me.ObjectID.ToString)
             result = m_WithExpression.GenerateCode(Info.Clone(Me, True, False, m_WithVariable.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_WithVariable)
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         Emitter.FreeLocal(m_WithVariable)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1289" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1668" endline="1683">
<![CDATA[
 
 		/// <summary>
 		///  Returns whether an explicit reference conversion can be performed
 		///  from source_type to target_type
 		/// </summary>
 		public static bool ExplicitReferenceConversionExists (TypeSpec source_type, TypeSpec target_type)
 		{
 			Expression e = ExplicitReferenceConversion (null, source_type, target_type);
 			if (e == null)
 				return false;
 
 			if (e == EmptyExpression.Null)
 				return true;
 
 			throw new InternalErrorException ("Invalid probing conversion result");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="979" endline="989">
<![CDATA[
 		{
 			Expression e = Resolve (ec);
 			if (e == null)
 				return null;
 
 			ExpressionStatement es = e as ExpressionStatement;
 			if (es == null)
 				Error_InvalidExpressionStatement (ec);
 
 			return es;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1290" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2927" endline="2936">
<![CDATA[
 		public InterfaceMemberBase (DeclSpace parent, GenericMethod generic,
 				   FullNamedExpression type, Modifiers mod, Modifiers allowed_mod,
 				   MemberName name, Attributes attrs)
 			
 				name, attrs)
 		{
 			IsInterface = parent.PartialContainer.Kind == MemberKind.Interface;
 			IsExplicitImpl = (MemberName.Left != null);
 			explicit_mod_flags = mod;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="122" endline="244">
<![CDATA[
 
 			#endregion
 		}
 
 		[Flags]
 		enum CachedMethods
 		{
 			Equals				= 1,
 			GetHashCode			= 1 << 1,
 			HasStaticFieldInitializer	= 1 << 2
 		}
 
 
 		// Whether this is a struct, class or interface
 		public readonly MemberKind Kind;
 
 		// Holds a list of classes and structures
 		protected List<TypeContainer> types;
 
 		List<MemberCore> ordered_explicit_member_list;
 		List<MemberCore> ordered_member_list;
 
 		// Holds the list of properties
 		List<MemberCore> properties;
 
 		// Holds the list of constructors
 		protected List<Constructor> instance_constructors;
 
 		// Holds the list of fields
 		protected List<FieldBase> fields;
 
 		// Holds a list of fields that have initializers
 		protected List<FieldInitializer> initialized_fields;
 
 		// Holds a list of static fields that have initializers
 		protected List<FieldInitializer> initialized_static_fields;
 
 		// Holds the list of constants
 		protected List<MemberCore> constants;
 
 		// Holds the methods.
 		List<MemberCore> methods;
 
 		// Holds the events
 		protected List<MemberCore> events;
 
 		// Holds the indexers
 		List<MemberCore> indexers;
 
 		// Holds the operators
 		List<MemberCore> operators;
 
 		// Holds the compiler generated classes
 		protected List<CompilerGeneratedClass> compiler_generated;
 
 		Dictionary<MethodSpec, Method> hoisted_base_call_proxies;
 
 		Dictionary<string, FullNamedExpression> Cache = new Dictionary<string, FullNamedExpression> ();
 
 		//
 		// Pointers to the default constructor and the default static constructor
 		//
 		protected Constructor default_constructor;
 		protected Constructor default_static_constructor;
 
 		//
 		// Points to the first non-static field added to the container.
 		//
 		// This is an arbitrary choice.  We are interested in looking at _some_ non-static field,
 		// and the first one's as good as any.
 		//
 		FieldBase first_nonstatic_field;
 
 		//
 		// This one is computed after we can distinguish interfaces
 		// from classes from the arraylist `type_bases' 
 		//
 		protected TypeSpec base_type;
 		protected TypeExpr base_type_expr;
 		protected TypeExpr[] iface_exprs;
 
 		protected List<FullNamedExpression> type_bases;
 
 		bool members_defined;
 		bool members_defined_ok;
 		bool type_defined;
 
 		TypeContainer InTransit;
 
 		GenericTypeParameterBuilder[] all_tp_builders;
 
 		public const string DefaultIndexerName = "Item";
 
 		private bool seen_normal_indexers = false;
 		private string indexer_name = DefaultIndexerName;
 		protected bool requires_delayed_unmanagedtype_check;
 		bool error;
 
 		private CachedMethods cached_method;
 
 		protected TypeSpec spec;
 		TypeSpec current_type;
 
 		List<TypeContainer> partial_parts;
 
 		public int DynamicSitesCounter;
 
 		/// <remarks>
 		///  The pending methods that need to be implemented
 		//   (interfaces or abstract methods)
 		/// </remarks>
 		PendingImplementation pending;
 
 		public TypeContainer (NamespaceEntry ns, DeclSpace parent, MemberName name,
 				      Attributes attrs, MemberKind kind)
 			
 		{
 			if (parent != null && parent.NamespaceEntry != ns)
 				throw new InternalErrorException ("A nested type should be in the same NamespaceEntry as its enclosing class");
 
 			this.Kind = kind;
 			this.PartialContainer = this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1291" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1890" endline="1900">
<![CDATA[
 
     Shared Sub EmitStoreField(ByVal Info As EmitInfo, ByVal Field As Mono.Cecil.FieldReference)
         Dim Field2 As Mono.Cecil.FieldReference = Field
         Field2 = Emitter.GetFieldRef(Field2)
         Field2 = Helper.GetFieldOrFieldBuilder(Info.Compiler, Field2)
         If CecilHelper.IsStatic(Field) Then
             Info.ILGen.Emit(OpCodes.Stsfld, Field2)
         Else
             Info.ILGen.Emit(OpCodes.Stfld, Field2)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="314" endline="335">
<![CDATA[
 
     ''' <summary>
     ''' Loads a pointer to the specified method onto the stack.
     ''' Loads either a Lftfn or Ldvirtftn, according to the static 
     ''' state of the method.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadVftn(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Dim methodinf As Mono.Cecil.MethodReference = Method '= TryCast(Method, Mono.Cecil.MethodReference)
         If methodinf IsNot Nothing Then
             methodinf = Helper.GetMethodOrMethodReference(Info.Compiler, methodinf)
             If CecilHelper.FindDefinition(methodinf).IsStatic Then
                 Info.ILGen.Emit(OpCodes.Ldftn, methodinf)
             Else
                 Info.ILGen.Emit(OpCodes.Ldvirtftn, methodinf)
             End If
         Else
             Helper.Stop()
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1292" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1890" endline="1900">
<![CDATA[
 
     Shared Sub EmitStoreField(ByVal Info As EmitInfo, ByVal Field As Mono.Cecil.FieldReference)
         Dim Field2 As Mono.Cecil.FieldReference = Field
         Field2 = Emitter.GetFieldRef(Field2)
         Field2 = Helper.GetFieldOrFieldBuilder(Info.Compiler, Field2)
         If CecilHelper.IsStatic(Field) Then
             Info.ILGen.Emit(OpCodes.Stsfld, Field2)
         Else
             Info.ILGen.Emit(OpCodes.Stfld, Field2)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1578" endline="1595">
<![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Field As Mono.Cecil.FieldReference)
         Dim emittableField As Mono.Cecil.FieldReference
         Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(Field)
 
         emittableField = Emitter.GetFieldRef(Field)
         emittableField = Helper.GetFieldOrFieldBuilder(Info.Compiler, emittableField)
 
         If fD.IsLiteral Then
             EmitLoadValueAddress(Info, fD.Constant)
         Else
             If fD.IsStatic Then
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             Else
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             End If
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1293" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1890" endline="1900">
<![CDATA[
 
     Shared Sub EmitStoreField(ByVal Info As EmitInfo, ByVal Field As Mono.Cecil.FieldReference)
         Dim Field2 As Mono.Cecil.FieldReference = Field
         Field2 = Emitter.GetFieldRef(Field2)
         Field2 = Helper.GetFieldOrFieldBuilder(Info.Compiler, Field2)
         If CecilHelper.IsStatic(Field) Then
             Info.ILGen.Emit(OpCodes.Stsfld, Field2)
         Else
             Info.ILGen.Emit(OpCodes.Stfld, Field2)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1806" endline="1821">
<![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.FieldReference)
         Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(Variable)
 
         Variable = Emitter.GetFieldRef(Variable)
         Variable = Helper.GetFieldOrFieldReference(Info.Compiler, Variable)
         If fD.IsStatic Then
             If fD.IsLiteral Then
                 Emitter.EmitLoadValue(Info.Clone(Info.Context, True, False, Variable.FieldType), fD.Constant)
             Else
                 Info.ILGen.Emit(OpCodes.Ldsfld, Variable)
             End If
         Else
             Info.ILGen.Emit(OpCodes.Ldfld, Variable)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1294" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1200" endline="1210">
<![CDATA[
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1174" endline="1184">
<![CDATA[
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1295" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1943" endline="1959">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if CallerType is a nested class of CalledType.
     ''' Returns false if both types are equal.
     ''' </summary>
     ''' <param name="CalledType"></param>
     ''' <param name="CallerType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsNested(ByVal CalledType As Mono.Cecil.TypeReference, ByVal CallerType As Mono.Cecil.TypeReference) As Boolean
         Dim tmp As Mono.Cecil.TypeReference = CecilHelper.FindDefinition(CallerType).DeclaringType
         Do Until tmp Is Nothing
             If CompareType(CalledType, tmp) Then Return True
             tmp = CecilHelper.FindDefinition(tmp).DeclaringType
         Loop
         Do Until tmp Is Nothing
             If CompareType(CalledType, tmp) Then Return True
             tmp = CecilHelper.FindDefinition(tmp).DeclaringType
         Loop
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3541" endline="3551">
<![CDATA[
 
     Shared Function GetMethodAttributes(ByVal Member As Mono.Cecil.MemberReference) As Mono.Cecil.MethodAttributes
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).Attributes
             Case MemberTypes.Property
                 Return GetPropertyAttributes(DirectCast(Member, Mono.Cecil.PropertyReference))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1296" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="177" endline="185">
<![CDATA[
 
 		internal ByteReader Slice(int length)
 		{
 			if (end - pos < length)
 				throw new BadImageFormatException();
 			ByteReader br = new ByteReader(buffer, pos, length);
 			pos += length;
 			return br;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="102" endline="114">
<![CDATA[
 
 		internal string ReadString()
 		{
 			if (PeekByte() == 0xFF)
 			{
 				pos++;
 				return null;
 			}
 			int length = ReadCompressedInt();
 			string str = Encoding.UTF8.GetString(buffer, pos, length);
 			pos += length;
 			return str;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1297" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="177" endline="185">
<![CDATA[
 
 		internal ByteReader Slice(int length)
 		{
 			if (end - pos < length)
 				throw new BadImageFormatException();
 			ByteReader br = new ByteReader(buffer, pos, length);
 			pos += length;
 			return br;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="69" endline="80">
<![CDATA[
 
 		internal byte[] ReadBytes(int count)
 		{
 			if (count < 0)
 				throw new BadImageFormatException();
 			if (end - pos < count)
 				throw new BadImageFormatException();
 			byte[] buf = new byte[count];
 			Buffer.BlockCopy(buffer, pos, buf, 0, count);
 			pos += count;
 			return buf;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1298" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="280" endline="290">
<![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MethodReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="257" endline="268">
<![CDATA[
     End Property
 
     Private Sub SetMethods(ByVal lst As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1299" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="280" endline="290">
<![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MethodReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="269" endline="279">
<![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1300" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="496" endline="502">
<![CDATA[
 
     Function IsSignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_SByte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int64)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="503" endline="509">
<![CDATA[
 
     Function IsUnsignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_Byte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt64)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1301" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\Statement.vb" startline="24" endline="32">
<![CDATA[
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="529" endline="540">
<![CDATA[
     End Property
 
     Overridable ReadOnly Property IsOneLiner() As Boolean
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Return False
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1302" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\Statement.vb" startline="24" endline="32">
<![CDATA[
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="97" endline="117">
<![CDATA[
 
     ''' <summary>
     ''' Get the parent code block. Might be nothing!
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindParentCodeBlock() As CodeBlock
         If TypeOf Parent Is CodeBlock Then
             Return DirectCast(Parent, CodeBlock)
         Else
             If TypeOf Parent Is Expression Then
                 Return DirectCast(Parent, Expression).FindParentCodeBlock
             ElseIf TypeOf Parent Is BlockStatement Then
                 Return DirectCast(Parent, BlockStatement).CodeBlock
             ElseIf TypeOf Parent Is Statement Then
                 Return DirectCast(Parent, Statement).FindParentCodeBlock
             Else
                 Return Nothing
             End If
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1303" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4811" endline="4832">
<![CDATA[
 	}
 
 	public class TryCatch 
 		public Block Block;
 		public List<Catch> Specific;
 		public Catch General;
 		bool inside_try_finally, code_follows;
 
 		public TryCatch (Block block, List<Catch> catch_clauses, Location l, bool inside_try_finally)
 		{
 			this.Block = block;
 			this.Specific = catch_clauses;
 			this.inside_try_finally = inside_try_finally;
 
 			Catch c = catch_clauses [0];
 			if (c.IsGeneral) {
 				this.General = c;			
 				catch_clauses.RemoveAt (0);
 			}
 
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="117" endline="127">
<![CDATA[
 		public Attribute (string target, ATypeNameExpression expr, Arguments[] args, Location loc, bool nameEscaped)
 		{
 			this.expression = expr;
 			if (args != null) {
 				PosArguments = args [0];
 				NamedArguments = args [1];				
 			}
 			this.loc = loc;
 			ExplicitTarget = target;
 			this.nameEscaped = nameEscaped;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1304" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="367" endline="375">
<![CDATA[
 
 		public Arguments Clone (CloneContext ctx)
 		{
 			Arguments cloned = new Arguments (args.Count);
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 
 			return cloned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1756" endline="1764">
<![CDATA[
 
 		public TypeArguments Clone ()
 		{
 			TypeArguments copy = new TypeArguments ();
 			foreach (var ta in args)
 				copy.args.Add (ta);
 			foreach (var ta in args)
 				copy.args.Add (ta);
 
 			return copy;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1305" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="367" endline="375">
<![CDATA[
 
 		public Arguments Clone (CloneContext ctx)
 		{
 			Arguments cloned = new Arguments (args.Count);
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 
 			return cloned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="242" endline="253">
<![CDATA[
 
 		public void AddAttributes (List<Attribute> attrs, IMemberContext context)
 		{
 			foreach (Attribute a in attrs)
 				a.AttachTo (this, context);
 			foreach (Attribute a in attrs)
 				a.AttachTo (this, context);
 
 			if (attributes == null) {
 				attributes = new Attributes (attrs);
 				return;
 			}
 			attributes.AddAttributes (attrs);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1306" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="367" endline="375">
<![CDATA[
 
 		public Arguments Clone (CloneContext ctx)
 		{
 			Arguments cloned = new Arguments (args.Count);
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 
 			return cloned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="355" endline="366">
<![CDATA[
 
 		public void CheckArrayAsAttribute (CompilerContext ctx)
 		{
 			foreach (Argument arg in args) {
 				// Type is undefined (was error 246)
 				if (arg.Type == null)
 					continue;
 
 				if (arg.Type.IsArray)
 					ctx.Report.Warning (3016, 1, arg.Expr.Location, "Arrays as attribute arguments are not CLS-compliant");
 			}
 			foreach (Argument arg in args) {
 				// Type is undefined (was error 246)
 				if (arg.Type == null)
 					continue;
 
 				if (arg.Type.IsArray)
 					ctx.Report.Warning (3016, 1, arg.Expr.Location, "Arrays as attribute arguments are not CLS-compliant");
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1307" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="367" endline="375">
<![CDATA[
 
 		public Arguments Clone (CloneContext ctx)
 		{
 			Arguments cloned = new Arguments (args.Count);
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 
 			return cloned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="500" endline="512">
<![CDATA[
 
 		//
 		// Returns dynamic when at least one argument is of dynamic type
 		//
 		public void Resolve (ResolveContext ec, out bool dynamic)
 		{
 			dynamic = false;
 			foreach (Argument a in args) {
 				a.Resolve (ec);
 				if (a.Type == InternalType.Dynamic && !a.IsByRef)
 					dynamic = true;
 			}
 			foreach (Argument a in args) {
 				a.Resolve (ec);
 				if (a.Type == InternalType.Dynamic && !a.IsByRef)
 					dynamic = true;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1308" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="367" endline="375">
<![CDATA[
 
 		public Arguments Clone (CloneContext ctx)
 		{
 			Arguments cloned = new Arguments (args.Count);
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 
 			return cloned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="241" endline="261">
<![CDATA[
 		}
 
 		#endregion
 
 		public bool AddInterface (TypeSpec iface)
 		{
 			if ((state & StateFlags.InterfacesExpanded) != 0)
 				throw new InternalErrorException ("Modifying expanded interface list");
 
 			if (ifaces == null) {
 				ifaces = new List<TypeSpec> () { iface };
 				return true;
 			}
 
 			if (!ifaces.Contains (iface)) {
 				ifaces.Add (iface);
 				return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1309" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="367" endline="375">
<![CDATA[
 
 		public Arguments Clone (CloneContext ctx)
 		{
 			Arguments cloned = new Arguments (args.Count);
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 
 			return cloned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2032" endline="2052">
<![CDATA[
 
 		/// <summary>
 		///   Performs checks for an explicit interface implementation.  First it
 		///   checks whether the `interface_type' is a base inteface implementation.
 		///   Then it checks whether `name' exists in the interface type.
 		/// </summary>
 		public bool VerifyImplements (InterfaceMemberBase mb)
 		{
 			var ifaces = spec.Interfaces;
 			if (ifaces != null) {
 				foreach (TypeSpec t in ifaces){
 					if (t == mb.InterfaceType)
 						return true;
 				}
 				foreach (TypeSpec t in ifaces){
 					if (t == mb.InterfaceType)
 						return true;
 				}
 			}
 			
 			Report.SymbolRelatedToPreviousError (mb.InterfaceType);
 			Report.Error (540, mb.Location, "`{0}'
 				mb.GetSignatureForError (), TypeManager.CSharpName (mb.InterfaceType));
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1310" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="62" endline="71">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As Parameter = Nothing) As ParameterIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterIdentifier(NewParent)
         result.m_Identifier = m_Identifier
         If m_ArrayNameModifier IsNot Nothing Then
             result.m_ArrayNameModifier = m_ArrayNameModifier.clone(result)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="42" endline="50">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributeArguments
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributeArguments(NewParent)
         If m_AttributePositionalArgumentList IsNot Nothing Then result.m_AttributePositionalArgumentList = m_AttributePositionalArgumentList.clone(result)
         If m_VariablePropertyInitializerList IsNot Nothing Then result.m_VariablePropertyInitializerList = m_VariablePropertyInitializerList.clone(result)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1311" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="62" endline="71">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As Parameter = Nothing) As ParameterIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterIdentifier(NewParent)
         result.m_Identifier = m_Identifier
         If m_ArrayNameModifier IsNot Nothing Then
             result.m_ArrayNameModifier = m_ArrayNameModifier.clone(result)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="124" endline="136">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Attribute
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New Attribute(NewParent)
         result.m_IsAssembly = m_IsAssembly
         result.m_IsModule = m_IsModule
         If m_SimpleTypeName IsNot Nothing Then result.m_SimpleTypeName = m_SimpleTypeName.Clone(result)
         If m_AttributeArguments IsNot Nothing Then result.m_AttributeArguments = m_AttributeArguments.Clone(result)
         result.m_ResolvedType = m_ResolvedType
         result.m_ResolvedTypeConstructor = m_ResolvedTypeConstructor
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1312" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="62" endline="71">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As Parameter = Nothing) As ParameterIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterIdentifier(NewParent)
         result.m_Identifier = m_Identifier
         If m_ArrayNameModifier IsNot Nothing Then
             result.m_ArrayNameModifier = m_ArrayNameModifier.clone(result)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="97" endline="108">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParameterList = Nothing) As Parameter
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParameterList)
         Dim result As New Parameter(NewParent)
         result.m_CustomAttributes = m_CustomAttributes
         result.m_Modifiers = m_Modifiers
         result.m_ParameterIdentifier = m_ParameterIdentifier.Clone(result)
         If m_TypeName IsNot Nothing Then result.m_TypeName = m_TypeName.Clone(result)
         If m_ConstantExpression IsNot Nothing Then result.m_ConstantExpression = m_ConstantExpression.Clone(result)
         result.UpdateDefinition()
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1313" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" startline="62" endline="71">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As Parameter = Nothing) As ParameterIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterIdentifier(NewParent)
         result.m_Identifier = m_Identifier
         If m_ArrayNameModifier IsNot Nothing Then
             result.m_ArrayNameModifier = m_ArrayNameModifier.clone(result)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\Constraint.vb" startline="40" endline="47">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Constraint
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New Constraint(NewParent)
         If m_TypeName IsNot Nothing Then result.m_TypeName = m_TypeName.Clone(result)
         result.m_Special = m_Special
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1314" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2675" endline="2688">
<![CDATA[
 
 		static bool IsSameOrBaseQualifier (TypeSpec type, TypeSpec qtype)
 		{
 			do {
 				type = type.GetDefinition ();
 
 				if (type == qtype || TypeManager.IsFamilyAccessible (qtype, type))
 					return true;
 
 				type = type.DeclaringType;
 			} while (type != null);
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="349" endline="379">
<![CDATA[
 
 		//
 		// Is @baseClass base implementation of @type. With enabled @dynamicIsEqual the slower
 		// comparison is used to hide differences between `object' and `dynamic' for generic
 		// types. Should not be used for comparisons where G<object> != G<dynamic>
 		//
 		public static bool IsBaseClass (TypeSpec type, TypeSpec baseClass, bool dynamicIsObject)
 		{
 			if (dynamicIsObject && baseClass.IsGeneric) {
 				//
 				// Returns true for a hierarchies like this when passing baseClass of A<dynamic>
 				//
 				// class B 
 				//
 				while (type != null) {
 					type = type.BaseType;
 					if (TypeSpecComparer.IsEqual (type, baseClass))
 						return true;
 				}
 				while (type != null) {
 					type = type.BaseType;
 					if (TypeSpecComparer.IsEqual (type, baseClass))
 						return true;
 				}
 
 				return false;
 			}
 
 			while (type != null) {
 				type = type.BaseType;
 				if (type == baseClass)
 					return true;
 			}
 			while (type != null) {
 				type = type.BaseType;
 				if (type == baseClass)
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1315" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="285" endline="302">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" startline="96" endline="110">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If HandlesClause IsNot Nothing Then
             result = HandlesClause.ResolveTypeReferences AndAlso result
         ElseIf ImplementsClause IsNot Nothing Then
             result = ImplementsClause.ResolveTypeReferences AndAlso result
         Else
             Helper.Stop()
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1316" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" startline="520" endline="529">
<![CDATA[
 
     Function AcceptAny(ByVal ParamArray Keywords() As KS) As Boolean
         Dim i As Integer
         For i = 0 To Keywords.Length - 1
             If Accept(Keywords(i)) Then
                 Return True
             End If
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2021" endline="2028">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Cecil.TypeReference(), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Length - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(t, TypeToFind) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1317" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2602" endline="2614">
<![CDATA[
 
 		public void WrapIntoIterator (IMethodData method, TypeContainer host, TypeSpec iterator_type, bool is_enumerable)
 		{
 			ParametersBlock pb = new ParametersBlock (this, ParametersCompiled.EmptyReadOnlyParameters, StartLocation);
 			pb.EndLocation = EndLocation;
 			pb.statements = statements;
 
 			var iterator = new Iterator (pb, method, host, iterator_type, is_enumerable);
 			am_storey = new IteratorStorey (iterator);
 
 			statements = new List<Statement> (1);
 			AddStatement (new Return (iterator, iterator.Location));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="111" endline="148">
<![CDATA[
 		}
 
 		public CharSet DefaultCharSet = CharSet.Ansi;
 		public TypeAttributes DefaultCharSetType = TypeAttributes.AnsiClass;
 
 		Dictionary<int, List<AnonymousTypeClass>> anonymous_types;
 		StaticDataContainer static_data;
 
 		AssemblyDefinition assembly;
 		readonly CompilerContext context;
 		readonly RootNamespace global_ns;
 		Dictionary<string, RootNamespace> alias_ns;
 
 		ModuleBuilder builder;
 
 		// HACK
 		public List<Enum> hack_corlib_enums = new List<Enum> ();
 
 		bool has_default_charset;
 		bool has_extenstion_method;
 
 		PredefinedAttributes predefined_attributes;
 		PredefinedTypes predefined_types;
 
 		static readonly string[] attribute_targets = new string[] { "assembly", "module" };
 
 		public ModuleContainer (CompilerContext context)
 			
 		{
 			this.context = context;
 
 			caching_flags &= ~(Flags.Obsolete_Undetected | Flags.Excluded_Undetected);
 
 			types = new List<TypeContainer> ();
 			anonymous_types = new Dictionary<int, List<AnonymousTypeClass>> ();
 			global_ns = new GlobalRootNamespace ();
 			alias_ns = new Dictionary<string, RootNamespace> ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1318" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2602" endline="2614">
<![CDATA[
 
 		public void WrapIntoIterator (IMethodData method, TypeContainer host, TypeSpec iterator_type, bool is_enumerable)
 		{
 			ParametersBlock pb = new ParametersBlock (this, ParametersCompiled.EmptyReadOnlyParameters, StartLocation);
 			pb.EndLocation = EndLocation;
 			pb.statements = statements;
 
 			var iterator = new Iterator (pb, method, host, iterator_type, is_enumerable);
 			am_storey = new IteratorStorey (iterator);
 
 			statements = new List<Statement> (1);
 			AddStatement (new Return (iterator, iterator.Location));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="1409" endline="1424">
<![CDATA[
 
 		void AddResource (AssemblyResource res)
 		{
 			if (RootContext.Resources == null) {
 				RootContext.Resources = new List<AssemblyResource> ();
 				RootContext.Resources.Add (res);
 				return;
 			}
 
 			if (RootContext.Resources.Contains (res)) {
 				ctx.Report.Error (1508, "The resource identifier `{0}' has already been used in this assembly", res.Name);
 				return;
 			}
 
 			RootContext.Resources.Add (res);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1319" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="852" endline="859">
<![CDATA[
 
     Public Shared Function IsDefined(ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal Type As TypeReference) As Boolean
         For i As Integer = 0 To CustomAttributes.Count - 1
             Dim Attribute As CustomAttribute = CustomAttributes(i)
             If Helper.CompareType(Attribute.Constructor.DeclaringType, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1148" endline="1158">
<![CDATA[
 
     Public Shared Function FindProperties(ByVal properties As Mono.Collections.Generic.Collection(Of PropertyDefinition), ByVal name As String) As Mono.Collections.Generic.Collection(Of PropertyDefinition)
         Dim result As Mono.Collections.Generic.Collection(Of PropertyDefinition) = Nothing
         For i As Integer = 0 To properties.Count - 1
             If Helper.CompareNameOrdinal(properties(i).Name, name) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of PropertyDefinition)
                 result.Add(properties(i))
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1320" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="852" endline="859">
<![CDATA[
 
     Public Shared Function IsDefined(ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal Type As TypeReference) As Boolean
         For i As Integer = 0 To CustomAttributes.Count - 1
             Dim Attribute As CustomAttribute = CustomAttributes(i)
             If Helper.CompareType(Attribute.Constructor.DeclaringType, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="879" endline="897">
<![CDATA[
 
     ''' <summary>
     ''' Finds a non-private, non-shared constructor with no parameters in the array.
     ''' If nothing found, returns nothing.
     ''' </summary>
     ''' <param name="Constructors"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetDefaultConstructor(ByVal Constructors As Mono.Collections.Generic.Collection(Of MethodDefinition)) As Mono.Cecil.MethodDefinition
         For i As Integer = 0 To Constructors.Count - 1
             If Not Constructors(i).IsConstructor Then Continue For
             If HasParameters(Constructors(i)) = False OrElse HasOnlyOptionalParameters(Constructors(i)) Then
                 If CecilHelper.IsStatic(Constructors(i)) = False AndAlso Helper.IsPrivate(Constructors(i)) = False Then
                     Return Constructors(i)
                 End If
             End If
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1321" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5952" endline="5961">
<![CDATA[
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			var target = (ArrayInitializer) t;
 
 			target.elements = new List<Expression> (elements.Count);
 			foreach (var element in elements)
 				target.elements.Add (element.Clone (clonectx));
 			foreach (var element in elements)
 				target.elements.Add (element.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9346" endline="9355">
<![CDATA[
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			CollectionOrObjectInitializers t = (CollectionOrObjectInitializers) target;
 
 			t.initializers = new List<Expression> (initializers.Count);
 			foreach (var e in initializers)
 				t.initializers.Add (e.Clone (clonectx));
 			foreach (var e in initializers)
 				t.initializers.Add (e.Clone (clonectx));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1322" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="266" endline="275">
<![CDATA[
 
     ReadOnly Property HasNamedArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is NamedArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="276" endline="286">
<![CDATA[
     End Property
 
     ReadOnly Property HasPositionalArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is PositionalArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1323" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="34" endline="46">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.LateBoundAccess.Name Is Nothing Then
             result = EmitLateIndexGet(Info) AndAlso result
         Else
             result = EmitLateGet(Info) AndAlso result
         End If
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="34" endline="53">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsLHS Then
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateindexSet(Info) AndAlso result
             Else
                 result = EmitLateSet(Info) AndAlso result
             End If
         Else
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateIndexGet(Info) AndAlso result
             Else
                 result = EmitLateGet(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1324" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="150" endline="163">
<![CDATA[
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			if (overload is MethodCore) {
 				caching_flags |= Flags.MethodOverloadsExist;
 				return true;
 			}
 
 			if (overload is AbstractPropertyEventMethod)
 				return true;
 
 			return base.EnableOverloadChecks (overload);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2209" endline="2223">
<![CDATA[
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			if (overload is MethodCore) {
 				caching_flags |= Flags.MethodOverloadsExist;
 				return true;
 			}
 
 			// This can only happen with indexers and it will
 			// be catched as indexer difference
 			if (overload is AbstractPropertyEventMethod)
 				return true;
 
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1325" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1625" endline="1641">
<![CDATA[
 
 		//
 		// Look for the best storey for this anonymous method
 		//
 		AnonymousMethodStorey FindBestMethodStorey ()
 		{
 			//
 			// Use the nearest parent block which has a storey
 			//
 			for (Block b = Block.Parent; b != null; b = b.Parent) {
 				AnonymousMethodStorey s = b.Explicit.AnonymousMethodStorey;
 				if (s != null)
 					return s;
 			}
 			for (Block b = Block.Parent; b != null; b = b.Parent) {
 				AnonymousMethodStorey s = b.Explicit.AnonymousMethodStorey;
 				if (s != null)
 					return s;
 			}
 					
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="566" endline="585">
<![CDATA[
 
 	static MemberSpec GetPredefinedMember (TypeSpec t, MemberFilter filter, bool optional, Location loc)
 	{
 		var member = MemberCache.FindMember (t, filter, BindingRestriction.DeclaredOnly);
 
 		if (member != null && member.IsAccessible (InternalType.FakeInternalType))
 			return member;
 
 		if (optional)
 			return member;
 
 		string method_args = null;
 		if (filter.Parameters != null)
 			method_args = filter.Parameters.GetSignatureForError ();
 
 		RootContext.ToplevelTypes.Compiler.Report.Error (656, loc, "The compiler required member `{0}.{1}{2}' could not be found or is inaccessible",
 			TypeManager.CSharpName (t), filter.Name, method_args);
 
 		return null;
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1326" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1625" endline="1641">
<![CDATA[
 
 		//
 		// Look for the best storey for this anonymous method
 		//
 		AnonymousMethodStorey FindBestMethodStorey ()
 		{
 			//
 			// Use the nearest parent block which has a storey
 			//
 			for (Block b = Block.Parent; b != null; b = b.Parent) {
 				AnonymousMethodStorey s = b.Explicit.AnonymousMethodStorey;
 				if (s != null)
 					return s;
 			}
 			for (Block b = Block.Parent; b != null; b = b.Parent) {
 				AnonymousMethodStorey s = b.Explicit.AnonymousMethodStorey;
 				if (s != null)
 					return s;
 			}
 					
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="700" endline="718">
<![CDATA[
 
 		static Expression GetOperatorTrueOrFalse (ResolveContext ec, Expression e, bool is_true, Location loc)
 		{
 			var op = is_true ? Operator.OpType.True 
 			var methods = MemberCache.GetUserOperator (e.type, op, false);
 			if (methods == null)
 				return null;
 
 			Arguments arguments = new Arguments (1);
 			arguments.Add (new Argument (e));
 
 			var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var oper = res.ResolveOperator (ec, ref arguments);
 
 			if (oper == null)
 				return null;
 
 			return new UserOperatorCall (oper, arguments, null, loc);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1327" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1625" endline="1641">
<![CDATA[
 
 		//
 		// Look for the best storey for this anonymous method
 		//
 		AnonymousMethodStorey FindBestMethodStorey ()
 		{
 			//
 			// Use the nearest parent block which has a storey
 			//
 			for (Block b = Block.Parent; b != null; b = b.Parent) {
 				AnonymousMethodStorey s = b.Explicit.AnonymousMethodStorey;
 				if (s != null)
 					return s;
 			}
 			for (Block b = Block.Parent; b != null; b = b.Parent) {
 				AnonymousMethodStorey s = b.Explicit.AnonymousMethodStorey;
 				if (s != null)
 					return s;
 			}
 					
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1619" endline="1648">
<![CDATA[
 
 		public override TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			var targs = TypeArguments;
 			if (targs != null)
 				targs = mutator.Mutate (targs);
 
 			var decl = DeclaringType;
 			if (IsNested && DeclaringType.IsGenericOrParentIsGeneric)
 				decl = mutator.Mutate (decl);
 
 			if (targs == TypeArguments && decl == DeclaringType)
 				return this;
 
 			var mutated = (InflatedTypeSpec) MemberwiseClone ();
 			if (decl != DeclaringType) {
 				// Gets back MethodInfo in case of metaInfo was inflated
 				//mutated.info = MemberCache.GetMember<TypeSpec> (DeclaringType.GetDefinition (), this).info;
 
 				mutated.declaringType = decl;
 				mutated.state |= StateFlags.PendingMetaInflate;
 			}
 
 			if (targs != null) {
 				mutated.targs = targs;
 				mutated.info = null;
 			}
 
 			return mutated;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1328" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="471" endline="477">
<![CDATA[
 
     Function IsNumericType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In NumericTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="478" endline="484">
<![CDATA[
 
     Function IsIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In IntegralTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1329" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="471" endline="477">
<![CDATA[
 
     Function IsNumericType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In NumericTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="485" endline="491">
<![CDATA[
 
     Function IsIntegralType(ByVal Type As TypeCode) As Boolean
         For Each t As Mono.Cecil.TypeReference In IntegralTypes
             If Helper.GetTypeCode(Compiler, t) = Type Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1330" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="466" endline="483">
<![CDATA[
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			PropertyBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="36" endline="57">
<![CDATA[
 		{
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					builder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1332" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="288" endline="299">
<![CDATA[
 
 		internal int Hash()
 		{
 			int hash = 0;
 			int len = this.Length;
 			for (int i = 0; i < len; i++)
 			{
 				hash *= 37;
 				hash ^= buffer[i];
 			}
 			for (int i = 0; i < len; i++)
 			{
 				hash *= 37;
 				hash ^= buffer[i];
 			}
 			return hash;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="265" endline="283">
<![CDATA[
 		}
 
 		public virtual bool ContainsGenericParameters
 		{
 			get
 			{
 				if (this.IsGenericParameter)
 				{
 					return true;
 				}
 				foreach (Type arg in this.GetGenericArguments())
 				{
 					if (arg.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type arg in this.GetGenericArguments())
 				{
 					if (arg.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1333" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2529" endline="2538">
<![CDATA[
 
 		public static OpType? GetType (string metadata_name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2506" endline="2514">
<![CDATA[
 
 		public static string GetName (string metadata_name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [1] == metadata_name)
 					return names [i] [0];
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [1] == metadata_name)
 					return names [i] [0];
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1334" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2529" endline="2538">
<![CDATA[
 
 		public static OpType? GetType (string metadata_name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2520" endline="2528">
<![CDATA[
 
 		public static string GetMetadataName (string name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [0] == name)
 					return names [i] [1];
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names [i] [0] == name)
 					return names [i] [1];
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1335" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1728" endline="1741">
<![CDATA[
 
 		void initialize_vector ()
 		{
 			// Post-condition
 			if (shared == null) {
 				vector = new System.Collections.BitArray (Count, true);
 				return;
 			}
 
 			vector = new System.Collections.BitArray (shared);
 			if (Count != vector.Count)
 				vector.Length = Count;
 			shared = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1522" endline="1539">
<![CDATA[
 
 		System.Collections.BitArray MakeShared (int new_count)
 		{
 			// Post-condition
 
 			// ensure we don't leak out dirty bits from the BitVector we inherited from
 			if (new_count > Count &&
 			    ((shared != null && shared.Count > Count) ||
 			     (shared == null && vector == null)))
 				initialize_vector ();
 
 			if (vector != null) {
 				shared = vector;
 				vector = null;
 			}
 
 			return shared;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1336" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="621" endline="633">
<![CDATA[
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="606" endline="620">
<![CDATA[
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1337" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="79" endline="87">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Operator) = False Then Return False
         Return IsOverloadableConversionOperator(tm.PeekToken(i + 1))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="84" endline="94">
<![CDATA[
     End Property
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         If tm.PeekToken(i) <> KS.Declare Then Return False
         If tm.PeekToken(i + 1).Equals(ModifierMasks.CharSetModifiers) Then i += 1
         Return tm.PeekToken(i + 1) = KS.Sub AndAlso tm.PeekToken(i + 2).IsIdentifier
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1338" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyAccessClassification.vb" startline="157" endline="168">
<![CDATA[
     End Property
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             If m_Property Is Nothing Then
                 Helper.Assert(m_Classification IsNot Nothing)
                 Helper.Assert(m_Classification.IsResolved)
                 m_Property = m_Classification.ResolvedProperty
             End If
             Helper.Assert(m_Property IsNot Nothing)
             Return m_Property.PropertyType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" startline="324" endline="347">
<![CDATA[
 
     Function GetObjectReference() As Expression
         Dim result As Expression
         If TypeOf Me Is GetRefExpression Then
             Return Me
         ElseIf TypeOf Me Is InstanceExpression Then
             Return Me
         ElseIf CecilHelper.IsValueType(ExpressionType) Then
             If TypeOf Me Is DeRefExpression Then
                 Dim derefExp As DeRefExpression = DirectCast(Me, DeRefExpression)
                 result = derefExp.Expression
             ElseIf Helper.CompareType(CecilHelper.FindDefinition(Me.ExpressionType).BaseType, Compiler.TypeCache.System_Enum) Then
                 result = New BoxExpression(Me, Me, CecilHelper.MakeByRefType(Me.ExpressionType))
                 'ElseIf Me.ExpressionType.IsValueType AndAlso Helper.IsNullableType(Compiler, Me.ExpressionType) = False Then
                 '    result = New BoxExpression(Me, Me, Me.ExpressionType)
             Else
                 result = New GetRefExpression(Me, Me)
             End If
         Else
             result = Me
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1339" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1542" endline="1548">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     Private m_Peeked As Token
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentTokenType As TokenType
     Private m_CurrentData As Object
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="1549" endline="1558">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     Private m_Peeked As Token
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentTokenType As TokenType
     Private m_CurrentData As Object
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)()
         Dim cf As New CodeFile("<Internal>", "", Compiler, Code)
         m_Files.Enqueue(cf)
         Compiler.CommandLine.Files.Add(cf)
         NextFile()
         LoadProjectConstants()
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1340" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="921" endline="932">
<![CDATA[
 
 		//
 		// Fixes full type name of each documented types/members up.
 		//
 		public void GenerateDocComment (Report r)
 		{
 			TypeContainer root = RootContext.ToplevelTypes;
 
 			if (root.Types != null)
 				foreach (TypeContainer tc in root.Types)
 					DocUtil.GenerateTypeDocComment (tc, null, r);
 				foreach (TypeContainer tc in root.Types)
 					DocUtil.GenerateTypeDocComment (tc, null, r);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1409" endline="1418">
<![CDATA[
 
 		protected virtual bool DefineNestedTypes ()
 		{
 			if (Types != null) {
 				foreach (TypeContainer tc in Types)
 					tc.DefineType ();
 				foreach (TypeContainer tc in Types)
 					tc.DefineType ();
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1341" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="921" endline="932">
<![CDATA[
 
 		//
 		// Fixes full type name of each documented types/members up.
 		//
 		public void GenerateDocComment (Report r)
 		{
 			TypeContainer root = RootContext.ToplevelTypes;
 
 			if (root.Types != null)
 				foreach (TypeContainer tc in root.Types)
 					DocUtil.GenerateTypeDocComment (tc, null, r);
 				foreach (TypeContainer tc in root.Types)
 					DocUtil.GenerateTypeDocComment (tc, null, r);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="969" endline="984">
<![CDATA[
 		
 		// Looks-up a alias named @name in this and surrounding namespace declarations
 		public FullNamedExpression LookupNamespaceAlias (string name)
 		{
 			for (NamespaceEntry n = this; n != null; n = n.ImplicitParent) {
 				if (n.using_aliases == null)
 					continue;
 
 				foreach (UsingAliasEntry ue in n.using_aliases) {
 					if (ue.Alias == name)
 						return ue.Resolve (Doppelganger ?? this, Doppelganger == null);
 				}
 				foreach (UsingAliasEntry ue in n.using_aliases) {
 					if (ue.Alias == name)
 						return ue.Resolve (Doppelganger ?? this, Doppelganger == null);
 				}
 			}
 			for (NamespaceEntry n = this; n != null; n = n.ImplicitParent) {
 				if (n.using_aliases == null)
 					continue;
 
 				foreach (UsingAliasEntry ue in n.using_aliases) {
 					if (ue.Alias == name)
 						return ue.Resolve (Doppelganger ?? this, Doppelganger == null);
 				}
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1342" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="921" endline="932">
<![CDATA[
 
 		//
 		// Fixes full type name of each documented types/members up.
 		//
 		public void GenerateDocComment (Report r)
 		{
 			TypeContainer root = RootContext.ToplevelTypes;
 
 			if (root.Types != null)
 				foreach (TypeContainer tc in root.Types)
 					DocUtil.GenerateTypeDocComment (tc, null, r);
 				foreach (TypeContainer tc in root.Types)
 					DocUtil.GenerateTypeDocComment (tc, null, r);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="682" endline="708">
<![CDATA[
 
 		//
 		// Returns members of @iface only, base members are ignored
 		//
 		public static IList<MethodSpec> GetInterfaceMethods (TypeSpec iface)
 		{
 			//
 			// MemberCache flatten interfaces, therefore in cases like this one
 			// 
 			// interface IA 
 			// interface IB { void Foo () }
 			//
 			// we would return Foo inside IA which is not expected in this case
 			//
 			var methods = new List<MethodSpec> ();
 			foreach (var entry in iface.MemberCache.member_hash.Values) {
 				foreach (var name_entry in entry) {
 					if (iface == name_entry.DeclaringType) {
 						if (name_entry.Kind == MemberKind.Method) {
 							methods.Add ((MethodSpec) name_entry);
 						}
 					}
 				}
 				foreach (var name_entry in entry) {
 					if (iface == name_entry.DeclaringType) {
 						if (name_entry.Kind == MemberKind.Method) {
 							methods.Add ((MethodSpec) name_entry);
 						}
 					}
 				}
 			}
 			foreach (var entry in iface.MemberCache.member_hash.Values) {
 				foreach (var name_entry in entry) {
 					if (iface == name_entry.DeclaringType) {
 						if (name_entry.Kind == MemberKind.Method) {
 							methods.Add ((MethodSpec) name_entry);
 						}
 					}
 				}
 			}
 
 			return methods;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1343" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1214" endline="1220">
<![CDATA[
   protected string[] yyExpecting (int state) {
     int [] tokens = yyExpectingTokens (state);
     string [] result = new string[tokens.Length];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n];
     return result;
   }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1299" endline="1310">
<![CDATA[
 
 		public TypeSpec[] Mutate (TypeSpec[] targs)
 		{
 			TypeSpec[] mutated = new TypeSpec[targs.Length];
 			bool changed = false;
 			for (int i = 0; i < targs.Length; ++i) {
 				mutated[i] = Mutate (targs[i]);
 				changed |= targs[i] != mutated[i];
 			}
 			for (int i = 0; i < targs.Length; ++i) {
 				mutated[i] = Mutate (targs[i]);
 				changed |= targs[i] != mutated[i];
 			}
 
 			return changed ? mutated 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1344" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1214" endline="1220">
<![CDATA[
   protected string[] yyExpecting (int state) {
     int [] tokens = yyExpectingTokens (state);
     string [] result = new string[tokens.Length];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n];
     return result;
   }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="274" endline="286">
<![CDATA[
 
 		TypeParameterSpec[] CreateGenericParameters (int first, MetaType[] tparams)
 		{
 			var tspec = new TypeParameterSpec[tparams.Length - first];
 			for (int pos = first; pos < tparams.Length; ++pos) {
 				var type = tparams[pos];
 				int index = pos - first;
 
 				tspec [index] = (TypeParameterSpec) CreateType (type, new DynamicTypeReader (), false);
 			}
 			for (int pos = first; pos < tparams.Length; ++pos) {
 				var type = tparams[pos];
 				int index = pos - first;
 
 				tspec [index] = (TypeParameterSpec) CreateType (type, new DynamicTypeReader (), false);
 			}
 
 			return tspec;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1345" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="437" endline="461">
<![CDATA[
 		}
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (8);
 
 			default_references.Add ("System");
 			default_references.Add ("System.Xml");
 #if NET_2_1
 			default_references.Add ("System.Net");
 			default_references.Add ("System.Windows");
 			default_references.Add ("System.Windows.Browser");
 #endif
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp");
 
 			return default_references.ToArray ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="294" endline="312">
<![CDATA[
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (4);
 
 			default_references.Add ("System.dll");
 			default_references.Add ("System.Xml.dll");
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core.dll");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp.dll");
 
 			return default_references.ToArray ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1346" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="743" endline="754">
<![CDATA[
 
 		public virtual Type GetNestedType(string name, BindingFlags bindingAttr)
 		{
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1347" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="462" endline="473">
<![CDATA[
 
 		public EventInfo GetEvent(string name, BindingFlags bindingAttr)
 		{
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1348" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="515" endline="526">
<![CDATA[
 
 		public FieldInfo GetField(string name, BindingFlags bindingAttr)
 		{
 			foreach (FieldInfo field in GetFields(bindingAttr))
 			{
 				if (field.Name == name)
 				{
 					return field;
 				}
 			}
 			foreach (FieldInfo field in GetFields(bindingAttr))
 			{
 				if (field.Name == name)
 				{
 					return field;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1349" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="815" endline="826">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
 		{
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name)
 				{
 					return prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name)
 				{
 					return prop;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1350" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="311" endline="323">
<![CDATA[
 
 		internal Type GetEnumUnderlyingTypeImpl()
 		{
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (!field.IsStatic)
 				{
 					// the CLR assumes that an enum has only one instance field, so we can do the same
 					return field.FieldType;
 				}
 			}
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (!field.IsStatic)
 				{
 					// the CLR assumes that an enum has only one instance field, so we can do the same
 					return field.FieldType;
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1351" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1354" endline="1367">
<![CDATA[
 
 		// This returns true if this type directly (i.e. not inherited from the base class) implements the interface.
 		// Note that a complicating factor is that the interface itself can be implemented by an interface that extends it.
 		private bool IsDirectlyImplementedInterface(Type interfaceType)
 		{
 			foreach (Type iface in __GetDeclaredInterfaces())
 			{
 				if (interfaceType.IsAssignableFrom(iface))
 				{
 					return true;
 				}
 			}
 			foreach (Type iface in __GetDeclaredInterfaces())
 			{
 				if (interfaceType.IsAssignableFrom(iface))
 				{
 					return true;
 				}
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1352" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="720" endline="731">
<![CDATA[
 
 		public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
 		{
 			foreach (ConstructorInfo constructor in GetConstructors(bindingAttr))
 			{
 				if (constructor.MethodSignature.MatchParameterTypes(types))
 				{
 					return constructor;
 				}
 			}
 			foreach (ConstructorInfo constructor in GetConstructors(bindingAttr))
 			{
 				if (constructor.MethodSignature.MatchParameterTypes(types))
 				{
 					return constructor;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1353" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="416" endline="426">
<![CDATA[
 
 		private static void AddMembers(List<MemberInfo> list, MemberFilter filter, object filterCriteria, MemberInfo[] members)
 		{
 			foreach (MemberInfo member in members)
 			{
 				if (filter == null || filter(member, filterCriteria))
 				{
 					list.Add(member);
 				}
 			}
 			foreach (MemberInfo member in members)
 			{
 				if (filter == null || filter(member, filterCriteria))
 				{
 					list.Add(member);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1354" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="454" endline="463">
<![CDATA[
 
     Sub SetAdditionalAttributes()
         Dim cab As Mono.Cecil.CustomAttribute
 
         If Compiler.CommandLine.Define.IsDefined("DEBUG") Then
             cab = New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Diagnostics_DebuggableAttribute__ctor_DebuggingModes))
             cab.ConstructorArguments.Add(New CustomAttributeArgument(Compiler.TypeCache.System_Diagnostics_DebuggableAttribute, System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations Or Diagnostics.DebuggableAttribute.DebuggingModes.Default))
             Me.Compiler.AssemblyBuilderCecil.CustomAttributes.Add(cab)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="106" endline="122">
<![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
         BaseType = Compiler.TypeCache.System_Enum
 
         If m_ValueField Is Nothing AndAlso m_QualifiedName <> KS.None Then
             m_ValueField = New Mono.Cecil.FieldDefinition(EnumTypeMemberName, Mono.Cecil.FieldAttributes.Public Or Mono.Cecil.FieldAttributes.SpecialName Or Mono.Cecil.FieldAttributes.RTSpecialName, Helper.GetTypeOrTypeReference(Compiler, EnumConstantType))
             CecilType.Fields.Add(m_ValueField)
         End If
 
         If m_ValueField IsNot Nothing Then
             m_ValueField.FieldType = Helper.GetTypeOrTypeReference(Compiler, EnumConstantType)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1355" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="454" endline="463">
<![CDATA[
 
     Sub SetAdditionalAttributes()
         Dim cab As Mono.Cecil.CustomAttribute
 
         If Compiler.CommandLine.Define.IsDefined("DEBUG") Then
             cab = New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Diagnostics_DebuggableAttribute__ctor_DebuggingModes))
             cab.ConstructorArguments.Add(New CustomAttributeArgument(Compiler.TypeCache.System_Diagnostics_DebuggableAttribute, System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations Or Diagnostics.DebuggableAttribute.DebuggingModes.Default))
             Me.Compiler.AssemblyBuilderCecil.CustomAttributes.Add(cab)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="152" endline="165">
<![CDATA[
 
     Friend Function DefineStaticMember() As Boolean
         Dim result As Boolean = True
 
         If FieldBuilder Is Nothing Then
 
             Dim staticName As String
             staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name
             m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(staticName, Helper.GetAttributes(Compiler, Me), Helper.GetTypeOrTypeReference(Compiler, FieldType))
             DeclaringType.CecilType.Fields.Add(m_FieldBuilderCecil)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1356" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="543" endline="553">
<![CDATA[
 
 		public SourceFileEntry[] Sources {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				SourceFileEntry[] retval = new SourceFileEntry [SourceCount];
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="579" endline="589">
<![CDATA[
 
 		public CompileUnitEntry[] CompileUnits {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				CompileUnitEntry[] retval = new CompileUnitEntry [CompileUnitCount];
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				return retval;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1357" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="82" endline="98">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a string array with all the namespaces.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property NamespacesAsString() As String()
         Get
             Dim result(Count - 1) As String
             Dim tmp() As [Namespace] = Me.ToArray
             For i As Integer = 0 To Count - 1
                 result(i) = tmp(i).Name
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BaseList~1.vb" startline="37" endline="44">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_List.Count - 1
             result = m_List(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1358" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" startline="82" endline="98">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a string array with all the namespaces.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property NamespacesAsString() As String()
         Get
             Dim result(Count - 1) As String
             Dim tmp() As [Namespace] = Me.ToArray
             For i As Integer = 0 To Count - 1
                 result(i) = tmp(i).Name
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="240" endline="251">
<![CDATA[
 
     Private Sub Flatten(ByVal Name As String, ByVal Visibility As MemberVisibility)
         Dim bases As List(Of MemberCache) = GetBaseCache()
 
         If bases.Count = 0 Then
             Flatten(Name, Nothing, Visibility)
         Else
             For i As Integer = 0 To bases.Count - 1
                 Flatten(Name, bases(i), Visibility)
             Next
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1359" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="233" endline="251">
<![CDATA[
 
 		public void RemoveWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_only == null)
 				warnings_only = new List<int> ();
 
 			warnings_only.Add (id);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="214" endline="232">
<![CDATA[
 
 		public void AddWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_as_error == null)
 				warnings_as_error = new List<int> ();
 			
 			warnings_as_error.Add (id);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1360" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="334" endline="343">
<![CDATA[
 
 		public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
 		{
 			gtpb = new GenericTypeParameterBuilder[names.Length];
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
 			}
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
 			}
 			return (GenericTypeParameterBuilder[])gtpb.Clone();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="607" endline="617">
<![CDATA[
 
 		public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
 		{
 			typeFlags |= TypeFlags.IsGenericTypeDefinition;
 			gtpb = new GenericTypeParameterBuilder[names.Length];
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
 			}
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
 			}
 			return (GenericTypeParameterBuilder[])gtpb.Clone();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1361" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="956" endline="969">
<![CDATA[
 		}
 
 		// helper for ModuleBuilder.ResolveMethod()
 		internal MethodBase LookupMethod(int token)
 		{
 			foreach (MethodBuilder method in methods)
 			{
 				if (method.MetadataToken == token)
 				{
 					return method;
 				}
 			}
 			foreach (MethodBuilder method in methods)
 			{
 				if (method.MetadataToken == token)
 				{
 					return method;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="621" endline="632">
<![CDATA[
 
 		private static bool FindMethod(List<MethodInfo> methods, MethodInfo method)
 		{
 			foreach (MethodInfo m in methods)
 			{
 				if (m.Name == method.Name && m.MethodSignature.Equals(method.MethodSignature))
 				{
 					return true;
 				}
 			}
 			foreach (MethodInfo m in methods)
 			{
 				if (m.Name == method.Name && m.MethodSignature.Equals(method.MethodSignature))
 				{
 					return true;
 				}
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1362" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="956" endline="969">
<![CDATA[
 		}
 
 		// helper for ModuleBuilder.ResolveMethod()
 		internal MethodBase LookupMethod(int token)
 		{
 			foreach (MethodBuilder method in methods)
 			{
 				if (method.MetadataToken == token)
 				{
 					return method;
 				}
 			}
 			foreach (MethodBuilder method in methods)
 			{
 				if (method.MetadataToken == token)
 				{
 					return method;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="117" endline="132">
<![CDATA[
 
 		public override MethodInfo[] GetOtherMethods(bool nonPublic)
 		{
 			List<MethodInfo> list = new List<MethodInfo>();
 			if (otherMethods != null)
 			{
 				foreach (MethodInfo method in otherMethods)
 				{
 					if (nonPublic || method.IsPublic)
 					{
 						list.Add(method);
 					}
 				}
 				foreach (MethodInfo method in otherMethods)
 				{
 					if (nonPublic || method.IsPublic)
 					{
 						list.Add(method);
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1363" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1311" endline="1326">
<![CDATA[
 
 		public MethodInfo GetGetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var get = mb.GetArrayMethod (
 				GetMetaInfo (), "Get",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				Element.GetMetaInfo (), arg_types);
 
 			return get;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1278" endline="1294">
<![CDATA[
 		}
 
 		public MethodInfo GetConstructor ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var ctor = mb.GetArrayMethod (
 				GetMetaInfo (), Constructor.ConstructorName,
 				CallingConventions.HasThis,
 				null, arg_types);
 
 			return ctor;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1364" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1311" endline="1326">
<![CDATA[
 
 		public MethodInfo GetGetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var get = mb.GetArrayMethod (
 				GetMetaInfo (), "Get",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				Element.GetMetaInfo (), arg_types);
 
 			return get;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1327" endline="1344">
<![CDATA[
 
 		public MethodInfo GetSetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank + 1];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			arg_types[rank] = Element.GetMetaInfo ();
 
 			var set = mb.GetArrayMethod (
 				GetMetaInfo (), "Set",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				TypeManager.void_type.GetMetaInfo (), arg_types);
 
 			return set;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1365" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1458" endline="1469">
<![CDATA[
 
 		protected TypeParameter[] TypeParameters {
 			get {
 				if (!IsGeneric)
 					throw new InvalidOperationException ();
 				if ((PartialContainer != null) && (PartialContainer != this))
 					return PartialContainer.TypeParameters;
 				if (type_param_list == null)
 					initialize_type_params ();
 
 				return type_param_list;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="887" endline="902">
<![CDATA[
 
 		public string ParameterDesc (int pos)
 		{
 			if (types == null || types [pos] == null)
 				return ((Parameter)FixedParameters [pos]).GetSignatureForError ();
 
 			string type = TypeManager.CSharpName (types [pos]);
 			if (FixedParameters [pos].HasExtensionMethodModifier)
 				return "this " + type;
 
 			Parameter.Modifier mod = FixedParameters [pos].ModFlags;
 			if (mod == 0)
 				return type;
 
 			return Parameter.GetModifierSignature (mod) + " " + type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1366" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="338" endline="356">
<![CDATA[
 
     Public Shared Function EmitLateIndexGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexGet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
         '2 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="73" endline="90">
<![CDATA[
 
     Public NotOverridable Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveStatement(Info) AndAlso result
 
         If result = False Then Return result
 
         result = CheckIndexedStatement(Info, TryCast(LSide, InvocationOrIndexExpression)) AndAlso result
 
         m_CompoundExpression = ResolveStatement(LSide, RSide)
 
         result = m_CompoundExpression.ResolveExpression(Info) AndAlso result
 
         m_CompoundExpression = Helper.CreateTypeConversion(Me, m_CompoundExpression, LSide.ExpressionType, result)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1367" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="296" endline="310">
<![CDATA[
 
     Function ResolveMembers() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveMembers " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveMembers(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="417" endline="453">
<![CDATA[
 
     ''' <summary>
     ''' - All code is emitted for fields with initializers.
     ''' - All the code is emitted for each and every method, constructor, operator and property.
     ''' - Classes, modules, structures, methods, constructors, properties, events, operators should implement IEmittable.Emit(Info as EmitInfo)
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Emit() As Boolean
         Dim result As Boolean = True
 
         result = EmitAttributes() AndAlso result
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Yellow
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Emit " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = Emit(type) AndAlso result
         Next
 
         SetFileVersion()
         SetAdditionalAttributes()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1368" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="37" endline="46">
<![CDATA[
 
     Function AsTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
 
         For i As Integer = 0 To Me.Count - 1
             result(i) = Item(i).CecilBuilder
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="71" endline="79">
<![CDATA[
     End Property
 
     Function ToTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
         For i As Integer = 0 To Me.Count - 1
             result(i) = Me.Item(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1369" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="37" endline="46">
<![CDATA[
 
     Function AsTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
 
         For i As Integer = 0 To Me.Count - 1
             result(i) = Item(i).CecilBuilder
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="904" endline="913">
<![CDATA[
 
     Shared Function GetParameterTypes(ByVal Parameters As Mono.Cecil.ParameterReference()) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         Helper.Assert(Parameters IsNot Nothing)
         ReDim result(Parameters.Length - 1)
         For i As Integer = 0 To Parameters.GetUpperBound(0)
             result(i) = Parameters(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1370" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="87" endline="95">
<![CDATA[
 
 		internal void Write(int value)
 		{
 			buffer[0] = (byte)value;
 			buffer[1] = (byte)(value >> 8);
 			buffer[2] = (byte)(value >> 16);
 			buffer[3] = (byte)(value >> 24);
 			stream.Write(buffer, 0, 4);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="101" endline="113">
<![CDATA[
 
 		internal void Write(long value)
 		{
 			buffer[0] = (byte)value;
 			buffer[1] = (byte)(value >> 8);
 			buffer[2] = (byte)(value >> 16);
 			buffer[3] = (byte)(value >> 24);
 			buffer[4] = (byte)(value >> 32);
 			buffer[5] = (byte)(value >> 40);
 			buffer[6] = (byte)(value >> 48);
 			buffer[7] = (byte)(value >> 56);
 			stream.Write(buffer, 0, 8);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1371" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="432" endline="441">
<![CDATA[
 
 		public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineNestedType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="191" endline="200">
<![CDATA[
 
 		public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1372" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="207" endline="218">
<![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsString
                 sep = ", "
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="219" endline="231">
<![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsTypeString
                 sep = ", "
             Next
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1373" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="836" endline="849">
<![CDATA[
 
     ''' <summary>
     ''' Returns a list of type descriptors that only are modules.
     ''' </summary>
     ''' <param name="Types"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterToModules(ByVal Compiler As Compiler, ByVal Types As TypeDictionary) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         For Each t As Mono.Cecil.TypeReference In Types.Values
             If IsModule(Compiler, t) Then result.Add(t)
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="820" endline="827">
<![CDATA[
 
     Shared Function FilterByName(ByVal Types As TypeList, ByVal Name As String) As TypeList
         Dim result As New TypeList
         For Each obj As Mono.Cecil.TypeReference In Types
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1374" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="836" endline="849">
<![CDATA[
 
     ''' <summary>
     ''' Returns a list of type descriptors that only are modules.
     ''' </summary>
     ''' <param name="Types"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterToModules(ByVal Compiler As Compiler, ByVal Types As TypeDictionary) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         For Each t As Mono.Cecil.TypeReference In Types.Values
             If IsModule(Compiler, t) Then result.Add(t)
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="543" endline="564">
<![CDATA[
 
     ''' <summary>
     ''' Returns all the members in the types with the specified name.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetMembersOfTypes(ByVal Compiler As Compiler, ByVal Types As TypeList, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
 
         If Types Is Nothing Then Return Nothing
 
         For Each type As Mono.Cecil.TypeReference In Types
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             members = Compiler.TypeManager.GetCache(type).LookupFlattenedMembers(Name)
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
                 result.AddRange(members)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1375" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="88" endline="95">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_Handlers.Length - 1
             result = m_Handlers(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" startline="55" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeParameters.Length - 1
             If m_TypeParameters(i) IsNot Nothing Then
                 result = m_TypeParameters(i).ResolveTypeReferences() AndAlso result
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1376" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="434" endline="445">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression e = base.DoResolve (ec);
 			if (e == null || e != this)
 				return e;
 
 			if (CheckEqualAssign (target))
 				ec.Report.Warning (1717, 3, loc, "Assignment made to same variable; did you mean to assign something else?");
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1334" endline="1358">
<![CDATA[
 	}
 
 	public class InflatedTypeSpec 
 	{
 		TypeSpec[] targs;
 		TypeParameterSpec[] constraints;
 		readonly TypeSpec open_type;
 
 		public InflatedTypeSpec (TypeSpec openType, TypeSpec declaringType, TypeSpec[] targs)
 			
 		{
 			if (targs == null)
 				throw new ArgumentNullException ("targs");
 
 //			this.state = openType.state;
 			this.open_type = openType;
 			this.targs = targs;
 
 			foreach (var arg in targs) {
 				if (arg.HasDynamicElement || arg == InternalType.Dynamic) {
 					state |= StateFlags.HasDynamicElement;
 					break;
 				}
 			}
 			foreach (var arg in targs) {
 				if (arg.HasDynamicElement || arg == InternalType.Dynamic) {
 					state |= StateFlags.HasDynamicElement;
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1377" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="434" endline="445">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression e = base.DoResolve (ec);
 			if (e == null || e != this)
 				return e;
 
 			if (CheckEqualAssign (target))
 				ec.Report.Warning (1717, 3, loc, "Assignment made to same variable; did you mean to assign something else?");
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2923" endline="2945">
<![CDATA[
 
 		public override MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments arguments, OverloadResolver.IErrorHandler ehandler, OverloadResolver.Restrictions restr)
 		{
 			if (arguments == null)
 				arguments = new Arguments (1);
 
 			arguments.Insert (0, new Argument (ExtensionExpression, Argument.AType.ExtensionType));
 			var res = base.OverloadResolve (ec, ref arguments, ehandler ?? this, restr);
 
 			// Store resolved argument and restore original arguments
 			if (res == null) {
 				// Clean-up modified arguments for error reporting
 				arguments.RemoveAt (0);
 				return null;
 			}
 
 			var me = ExtensionExpression as MemberExpr;
 			if (me != null)
 				me.ResolveInstanceExpression (ec, null);
 
 			InstanceExpression = null;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1378" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="434" endline="445">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression e = base.DoResolve (ec);
 			if (e == null || e != this)
 				return e;
 
 			if (CheckEqualAssign (target))
 				ec.Report.Warning (1717, 3, loc, "Assignment made to same variable; did you mean to assign something else?");
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="183" endline="219">
<![CDATA[
 
 		public static Expression ImplicitReferenceConversion (Expression expr, TypeSpec target_type, bool explicit_cast)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			if (expr_type == null && expr.eclass == ExprClass.MethodGroup){
 				// if we are a method group, emit a warning
 
 				expr.Emit (null);
 			}
 
 			if (expr_type == TypeManager.void_type)
 				return null;
 
 			if (expr_type.Kind == MemberKind.TypeParameter)
 				return ImplicitTypeParameterConversion (expr, target_type);
 
 			//
 			// from the null type to any reference-type.
 			//
 			NullLiteral nl = expr as NullLiteral;
 			if (nl != null) {
 				return nl.ConvertImplicitly (null, target_type);
 			}
 
 			if (ImplicitReferenceConversionExists (expr, target_type)) {
 				// 
 				// Avoid wrapping implicitly convertible reference type
 				//
 				if (!explicit_cast)
 					return expr;
 
 				return EmptyCast.Create (expr, target_type);
 			}
 
 			return ImplicitBoxingConversion (expr, expr_type, target_type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1379" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1380" endline="1391">
<![CDATA[
 
 		internal int FindOrAddRecord(int blob)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(blob);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1774" endline="1785">
<![CDATA[
 
 		internal int FindOrAddRecord(int str)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(str);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1380" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="331" endline="353">
<![CDATA[
 
 
     ''' <summary>
     ''' - Types are defined with the reflection.emit namespace. 
     ''' - Only classes, modules, structures, interfaces, enums, delegates and eventnos (not a type by itself, bu an event might declare a new delegate). They are only defined, nothing else.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineType()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypes() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypes " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineType(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2087" endline="2094">
<![CDATA[
 
     Shared Function ResolveTypeReferences(ByVal ParamArray Collection As ParsedObject()) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             If obj IsNot Nothing Then result = obj.ResolveTypeReferences AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1382" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="548" endline="560">
<![CDATA[
 
     Shared Function GetUnaryResultType(ByVal op As KS, ByVal op1 As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(op1)
             Case KS.Minus
                 Return GetUnaryMinusResultType(op1)
             Case KS.Not
                 Return GetUnaryNotResultType(op1)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="612" endline="624">
<![CDATA[
 
     Shared Function GetUnaryOperandType(ByVal op As KS, ByVal operand As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(operand)
             Case KS.Minus
                 Return GetUnaryMinusResultType(operand)
             Case KS.Not
                 Return GetUnaryNotResultType(operand)
             Case Else
                 Throw New NotImplementedException
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1383" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2064" endline="2071">
<![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlesList.vb" startline="30" endline="39">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each Item As EventMemberSpecifier In Me
             result = Item.ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1384" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2064" endline="2071">
<![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2095" endline="2102">
<![CDATA[
 
     Shared Function ResolveStatementCollection(ByVal Collection As IEnumerable, ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As Statement In Collection
             result = obj.ResolveStatement(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1385" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2064" endline="2071">
<![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2103" endline="2110">
<![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IEnumerable, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.GenerateCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1386" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2064" endline="2071">
<![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2056" endline="2063">
<![CDATA[
 
     Shared Function DefineCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.Define AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1387" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2064" endline="2071">
<![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2078" endline="2086">
<![CDATA[
 
     Shared Function ResolveTypeReferencesCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             result = obj.ResolveTypeReferences AndAlso result
             'vbnc.Helper.Assert(result = (obj.Compiler.Report.Errors = 0))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1388" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2064" endline="2071">
<![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="47" endline="57">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For Each exp As Expression In m_Initializers
             result = exp.ResolveExpression(Info) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1389" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="613" endline="625">
<![CDATA[
 
 		public MethodEntry GetMethodByToken (int token)
 		{
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				read_methods ();
 				MethodEntry me;
 				method_token_hash.TryGetValue (token, out me);
 				return me;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="639" endline="651">
<![CDATA[
 
 		public MethodEntry[] Methods {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				lock (this) {
 					read_methods ();
 					MethodEntry[] retval = new MethodEntry [MethodCount];
 					method_list.CopyTo (retval, 0);
 					return retval;
 				}
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1390" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="613" endline="625">
<![CDATA[
 
 		public MethodEntry GetMethodByToken (int token)
 		{
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				read_methods ();
 				MethodEntry me;
 				method_token_hash.TryGetValue (token, out me);
 				return me;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="626" endline="638">
<![CDATA[
 
 		public MethodEntry GetMethod (int index)
 		{
 			if ((index < 1) || (index > ot.MethodCount))
 				throw new ArgumentException ();
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				read_methods ();
 				return (MethodEntry) method_list [index - 1];
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1391" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" startline="73" endline="87">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
 
         Classification = New ValueClassification(Me, Me.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" startline="126" endline="141">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression.IsResolved = False Then
             result = m_Expression.ResolveExpression(Info) AndAlso result
         End If
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
         Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1392" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="175" endline="186">
<![CDATA[
     End Property
 
     ReadOnly Property FieldInfo() As Mono.Cecil.FieldReference
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return m_FieldInfo
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="163" endline="174">
<![CDATA[
     End Property
 
     ReadOnly Property FieldDefinition() As Mono.Cecil.FieldDefinition
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return CecilHelper.FindDefinition(m_FieldInfo)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1393" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="56" endline="69">
<![CDATA[
 		}
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1394" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="125" endline="139">
<![CDATA[
 		}
 
 		public override Module[] GetLoadedModules(bool getResourceModules)
 		{
 			List<Module> list = new List<Module>();
 			list.Add(manifestModule);
 			foreach (Module m in externalModules)
 			{
 				if (m != null)
 				{
 					list.Add(m);
 				}
 			}
 			foreach (Module m in externalModules)
 			{
 				if (m != null)
 				{
 					list.Add(m);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1395" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="334" endline="346">
<![CDATA[
 
 		public Type[] FindTypes(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1396" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="925" endline="937">
<![CDATA[
 
 		public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1397" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="760" endline="773">
<![CDATA[
 
 		public Type[] GetNestedTypes(BindingFlags bindingAttr)
 		{
 			CheckBaked();
 			List<Type> list = new List<Type>();
 			foreach (Type type in __GetDeclaredTypes())
 			{
 				if (BindingFlagsMatch(type.IsNestedPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in __GetDeclaredTypes())
 			{
 				if (BindingFlagsMatch(type.IsNestedPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1398" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1473" endline="1484">
<![CDATA[
 
 		internal MethodBase FindMethod(string name, MethodSignature signature)
 		{
 			foreach (MethodBase method in __GetDeclaredMethods())
 			{
 				if (method.Name == name && method.MethodSignature.Equals(signature))
 				{
 					return method;
 				}
 			}
 			foreach (MethodBase method in __GetDeclaredMethods())
 			{
 				if (method.Name == name && method.MethodSignature.Equals(signature))
 				{
 					return method;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1399" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="698" endline="714">
<![CDATA[
 
 		public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
 		{
 			CheckBaked();
 			List<ConstructorInfo> list = new List<ConstructorInfo>();
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				ConstructorInfo constructor = mb as ConstructorInfo;
 				if (constructor != null
 					&& BindingFlagsMatch(constructor.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(constructor.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(constructor);
 				}
 			}
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				ConstructorInfo constructor = mb as ConstructorInfo;
 				if (constructor != null
 					&& BindingFlagsMatch(constructor.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(constructor.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(constructor);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1400" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1293" endline="1299">
<![CDATA[
 
     Public Shared Function GetMethod(ByVal type As ICollection, ByVal reference As MethodReference) As MethodDefinition
         For Each item As Mono.Cecil.MethodDefinition In type
             If CecilHelper.AreSame(reference, item) Then Return item
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Defines.vb" startline="56" endline="65">
<![CDATA[
 
     Default Shadows ReadOnly Property Item(ByVal Name As String) As Define
         Get
             For Each def As Define In Me
                 If Helper.CompareName(def.Symbol, Name) Then
                     Return def
                 End If
             Next
             Return Nothing
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1401" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1293" endline="1299">
<![CDATA[
 
     Public Shared Function GetMethod(ByVal type As ICollection, ByVal reference As MethodReference) As MethodDefinition
         For Each item As Mono.Cecil.MethodDefinition In type
             If CecilHelper.AreSame(reference, item) Then Return item
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1218" endline="1227">
<![CDATA[
 
     Public Shared Function GetField(ByVal collection As ICollection, ByVal reference As FieldReference) As FieldDefinition
         For Each field As FieldDefinition In collection
             If Not Helper.CompareNameOrdinal(field.Name, reference.Name) Then
                 Continue For
             End If
             Return field
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1402" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1293" endline="1299">
<![CDATA[
 
     Public Shared Function GetMethod(ByVal type As ICollection, ByVal reference As MethodReference) As MethodDefinition
         For Each item As Mono.Cecil.MethodDefinition In type
             If CecilHelper.AreSame(reference, item) Then Return item
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1283" endline="1292">
<![CDATA[
 
     Public Shared Function GetEvent(ByVal collection As ICollection, ByVal reference As EventReference) As EventDefinition
         For Each meth As EventDefinition In collection
             If Helper.CompareNameOrdinal(meth.Name, reference.Name) = False Then
                 Continue For
             End If
             Return meth
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1403" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="423" endline="433">
<![CDATA[
 
 		bool CheckEqualAssign (Expression t)
 		{
 			if (source is Assign) {
 				Assign a = (Assign) source;
 				if (t.Equals (a.Target))
 					return true;
 				return a is SimpleAssign && ((SimpleAssign) a).CheckEqualAssign (t);
 			}
 			return t.Equals (source);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6225" endline="6249">
<![CDATA[
 
 		protected bool ResolveInitializers (ResolveContext ec)
 		{
 			only_constant_initializers = true;
 
 			if (arguments != null) {
 				bool res = true;
 				for (int i = 0; i < arguments.Count; ++i) {
 					res &= CheckIndices (ec, initializers, i, true, dimensions);
 					if (initializers != null)
 						break;
 				}
 				for (int i = 0; i < arguments.Count; ++i) {
 					res &= CheckIndices (ec, initializers, i, true, dimensions);
 					if (initializers != null)
 						break;
 				}
 
 				return res;
 			}
 
 			arguments = new List<Expression> ();
 
 			if (!CheckIndices (ec, initializers, 0, false, dimensions))
 				return false;
 				
 			UpdateIndices ();
 				
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1404" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="423" endline="433">
<![CDATA[
 
 		bool CheckEqualAssign (Expression t)
 		{
 			if (source is Assign) {
 				Assign a = (Assign) source;
 				if (t.Equals (a.Target))
 					return true;
 				return a is SimpleAssign && ((SimpleAssign) a).CheckEqualAssign (t);
 			}
 			return t.Equals (source);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="671" endline="699">
<![CDATA[
 
 	//
 	// Whether a type is unmanaged.  This is used by the unsafe code (25.2)
 	//
 	public static bool IsUnmanagedType (TypeSpec t)
 	{
 		var ds = t.MemberDefinition as DeclSpace;
 		if (ds != null)
 			return ds.IsUnmanagedType ();
 
 		// some builtins that are not unmanaged types
 		if (t == TypeManager.object_type || t == TypeManager.string_type)
 			return false;
 
 		if (IsBuiltinOrEnum (t))
 			return true;
 
 		// Someone did the work of checking if the ElementType of t is unmanaged.  Let's not repeat it.
 		if (t.IsPointer)
 			return IsUnmanagedType (GetElementType (t));
 
 		if (!IsValueType (t))
 			return false;
 
 		if (t.IsNested && t.DeclaringType.IsGenericOrParentIsGeneric)
 			return false;
 
 		return true;
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1405" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="423" endline="433">
<![CDATA[
 
 		bool CheckEqualAssign (Expression t)
 		{
 			if (source is Assign) {
 				Assign a = (Assign) source;
 				if (t.Equals (a.Target))
 					return true;
 				return a is SimpleAssign && ((SimpleAssign) a).CheckEqualAssign (t);
 			}
 			return t.Equals (source);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1618" endline="1636">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance () || !IsExposedFromAssembly ()) {
 				return false;
 			}
 
 			if (!parameters.IsEmpty && Parent.Definition.IsAttribute) {
 				foreach (TypeSpec param in parameters.Types) {
 					if (param.IsArray) {
 						return true;
 					}
 				}
 				foreach (TypeSpec param in parameters.Types) {
 					if (param.IsArray) {
 						return true;
 					}
 				}
 			}
 
 			has_compliant_args = true;
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1406" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="47" endline="55">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterList(NewParent)
         For i As Integer = 0 To Me.Count - 1
             result.Add(Me.Item(i).Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" startline="162" endline="174">
<![CDATA[
 
     ReadOnly Property GenericParameterAttributes() As Mono.Cecil.GenericParameterAttributes
         Get
             Dim result As Mono.Cecil.GenericParameterAttributes
 
             If m_TypeParameterConstraints IsNot Nothing Then
                 For i As Integer = 0 To m_TypeParameterConstraints.Constraints.Count - 1
                     result = result Or m_TypeParameterConstraints.Constraints(i).SpecialConstraintAttribute
                 Next
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1407" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="47" endline="55">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterList(NewParent)
         For i As Integer = 0 To Me.Count - 1
             result.Add(Me.Item(i).Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="187" endline="201">
<![CDATA[
     End Property
 
     Public Function VerifyParameterNamesDoesntMatchFunctionName() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Parameters.Count - 1
             Dim p As Parameter = Parameters(i)
 
             If Helper.CompareName(p.Name, Name) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30530, Me.Location)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1408" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" startline="47" endline="55">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterList(NewParent)
         For i As Integer = 0 To Me.Count - 1
             result.Add(Me.Item(i).Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="57" endline="78">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.EmitBeginExceptionBlock(Info)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         For i As Integer = 0 To m_Catches.Count - 1
             Dim catchstmt As CatchStatement = m_Catches(i)
             result = catchstmt.GenerateCode(Info) AndAlso result
         Next
 
         If m_FinallyBlock IsNot Nothing Then
             Info.ILGen.BeginFinallyBlock()
             result = m_FinallyBlock.GenerateCode(Info) AndAlso result
         End If
 
         Info.ILGen.EndExceptionBlock()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1409" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3886" endline="3896">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Switch target = (Switch) t;
 
 			target.Expr = Expr.Clone (clonectx);
 			target.Sections = new List<SwitchSection> ();
 			foreach (SwitchSection ss in Sections){
 				target.Sections.Add (ss.Clone (clonectx));
 			}
 			foreach (SwitchSection ss in Sections){
 				target.Sections.Add (ss.Clone (clonectx));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="175" endline="191">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			var members = MemberCache.GetCompletitionMembers (ec.CurrentInitializerVariable.Type, partial_name);
 
 // TODO
 //			if (partial_name != null && results.Count > 0 && result [0] == "")
 //				throw new CompletionResult ("", new string [] { "=" });
 
 			var results = members.Where (l => (l.Kind & (MemberKind.Field | MemberKind.Property)) != 0).Select (l => l.Name).ToList ();
 			if (partial_name != null) {
 				var temp = new List<string> ();
 				AppendResults (temp, partial_name, results);
 				results = temp;
 			}
 
 			throw new CompletionResult (partial_name == null ? "" 
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1410" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="488" endline="499">
<![CDATA[
 
 		protected static void WriteCustomModifiers(ModuleBuilder module, ByteBuffer bb, byte mod, Type[] modifiers)
 		{
 			if (modifiers != null)
 			{
 				foreach (Type type in modifiers)
 				{
 					bb.Write(mod);
 					bb.WriteTypeDefOrRefEncoded(module.GetTypeTokenForMemberRef(type));
 				}
 				foreach (Type type in modifiers)
 				{
 					bb.Write(mod);
 					bb.WriteTypeDefOrRefEncoded(module.GetTypeTokenForMemberRef(type));
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="357" endline="369">
<![CDATA[
 
 		internal void WriteMethodRefSig(ModuleBuilder module, ByteBuffer bb, Type[] optionalParameterTypes)
 		{
 			WriteSigImpl(module, bb, parameterTypes.Length + optionalParameterTypes.Length);
 			if (optionalParameterTypes.Length > 0)
 			{
 				bb.Write(SENTINEL);
 				foreach (Type type in optionalParameterTypes)
 				{
 					WriteType(module, bb, type);
 				}
 				foreach (Type type in optionalParameterTypes)
 				{
 					WriteType(module, bb, type);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1411" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="999" endline="1014">
<![CDATA[
 	
 	static int CompareEventInfo (object a, object b)
 	{
 		EventInfo aa = (EventInfo) a, bb = (EventInfo) b;
 		
 		bool astatic = aa.GetAddMethod (true).IsStatic;
 		bool bstatic = bb.GetAddMethod (true).IsStatic;
 		
 		if (astatic == bstatic)
 			return CompareMemberInfo (a, b);
 		
 		if (astatic)
 			return -1;
 		
 		return 1;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="975" endline="990">
<![CDATA[
 	
 	static int ComparePropertyInfo (object a, object b)
 	{
 		PropertyInfo aa = (PropertyInfo) a, bb = (PropertyInfo) b;
 		
 		bool astatic = (aa.CanRead ? aa.GetGetMethod (true) 
 		bool bstatic = (bb.CanRead ? bb.GetGetMethod (true) 
 		
 		if (astatic == bstatic)
 			return CompareMemberInfo (a, b);
 		
 		if (astatic)
 			return -1;
 		
 		return 1;
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1412" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2029" endline="2036">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypeToSearch As Mono.Cecil.TypeReference, ByVal TypesToFind As Mono.Collections.Generic.Collection(Of TypeReference)) As Boolean
         For i As Integer = 0 To TypesToFind.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToFind(i)
             If Helper.CompareType(t, TypeToSearch) OrElse Helper.IsSubclassOf(TypeToSearch, t) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2037" endline="2044">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(TypeToFind, t) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1413" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2029" endline="2036">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypeToSearch As Mono.Cecil.TypeReference, ByVal TypesToFind As Mono.Collections.Generic.Collection(Of TypeReference)) As Boolean
         For i As Integer = 0 To TypesToFind.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToFind(i)
             If Helper.CompareType(t, TypeToSearch) OrElse Helper.IsSubclassOf(TypeToSearch, t) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1397" endline="1407">
<![CDATA[
 
     Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference = Nothing
 
         If Params Is Nothing Then Return result
         ReDim result(Params.Count - 1)
         For i As Integer = 0 To Params.Count - 1
             result(i) = Params(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1414" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2029" endline="2036">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypeToSearch As Mono.Cecil.TypeReference, ByVal TypesToFind As Mono.Collections.Generic.Collection(Of TypeReference)) As Boolean
         For i As Integer = 0 To TypesToFind.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToFind(i)
             If Helper.CompareType(t, TypeToSearch) OrElse Helper.IsSubclassOf(TypeToSearch, t) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="262" endline="270">
<![CDATA[
 
     Private Function IsMatch(ByVal Types As Mono.Cecil.TypeReference(), ByVal Parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If Parameters.Count = 0 AndAlso (Types Is Nothing OrElse Types.Length = 0) Then Return True
         If Parameters.Count <> Types.Length Then Return False
         For j As Integer = 0 To Parameters.Count - 1
             If Helper.CompareType(Parameters(j).ParameterType, Types(j)) = False Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1415" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="124" endline="136">
<![CDATA[
     End Property
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal where As String)
         'Console.WriteLine("Verifying consistency
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, where & "
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="137" endline="147">
<![CDATA[
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal Location As Span)
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, Location.AsString(Compiler) & " No errors, but compilation failed? ")
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1416" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="924" endline="940">
<![CDATA[
 
     ''' <summary>
     ''' Checks if the specified type is a VB Module.
     ''' </summary>
     ''' <param name="type"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsModule(ByVal Compiler As Compiler, ByVal type As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean
         Dim annotation As Object = type.Annotations(Compiler)
 
         If annotation IsNot Nothing AndAlso TypeOf annotation Is ModuleDeclaration Then Return True
 
         result = CecilHelper.IsClass(type) AndAlso Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute IsNot Nothing AndAlso CecilHelper.IsDefined(CecilHelper.FindDefinition(type).CustomAttributes, Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" startline="130" endline="150">
<![CDATA[
 
     ''' <summary>
     ''' Emits the array constructor.
     ''' The number of elements for each rank must be emitted already.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ArrayType"></param>
     ''' <param name="Ranks"></param>
     ''' <remarks></remarks>
     Public Shared Sub EmitArrayConstructor(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal Ranks As Integer)
         If Ranks <= 1 Then
             Emitter.EmitNewArr(Info, CecilHelper.GetElementType(ArrayType))
         Else
             Dim minfo As Mono.Cecil.MethodReference
             minfo = New Mono.Cecil.MethodReference(".ctor", ArrayType, Info.Compiler.TypeCache.System_Void, True, False, Mono.Cecil.MethodCallingConvention.Default)
             For i As Integer = 1 To Ranks
                 minfo.Parameters.Add(New Mono.Cecil.ParameterDefinition(Info.Compiler.TypeCache.System_Int32))
             Next
             Emitter.EmitNew(Info, minfo)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1417" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="241" endline="253">
<![CDATA[
 
 		internal static int GetHashCode(Type[][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="223" endline="240">
<![CDATA[
 
 		internal static int GetHashCode(Type[] types)
 		{
 			if (types == null)
 			{
 				return 0;
 			}
 			int h = 0;
 			foreach (Type t in types)
 			{
 				if (t != null)
 				{
 					h *= 3;
 					h ^= t.GetHashCode();
 				}
 			}
 			foreach (Type t in types)
 			{
 				if (t != null)
 				{
 					h *= 3;
 					h ^= t.GetHashCode();
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1418" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="241" endline="253">
<![CDATA[
 
 		internal static int GetHashCode(Type[][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="461" endline="481">
<![CDATA[
 
 		private static Type[] NormalizeAndCopy(Type[] array)
 		{
 			if (array == null || array.Length == 0)
 			{
 				return null;
 			}
 			Type[] copy = null;
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			return copy;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1419" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="831" endline="844">
<![CDATA[
 
     Public Shared Function GetCustomAttributes(ByVal Attributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal AttributeType As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim result As Mono.Collections.Generic.Collection(Of CustomAttribute) = Nothing
 
         For i As Integer = 0 To Attributes.Count - 1
             Dim attrib As CustomAttribute = Attributes(i)
             If Helper.CompareType(AttributeType, attrib.Constructor.DeclaringType) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of CustomAttribute)()
                 result.Add(attrib)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="577" endline="596">
<![CDATA[
 
     ''' <summary>
     ''' Removes private members if they are from an external assembly.
     ''' </summary>
     ''' <param name="Members"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterExternalInaccessible(ByVal Compiler As Compiler, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
         For i As Integer = 0 To Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = Members(i)
             If (IsPrivate(member) OrElse IsFriend(member)) AndAlso Compiler.Assembly.IsDefinedHere(CecilHelper.FindDefinition(member.DeclaringType)) = False Then
                 Continue For
             End If
             result.Add(member)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1420" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="112" endline="128">
<![CDATA[
 
     ''' <summary>
     ''' Loads the loop control variable onto the stack
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitLoadVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             Emitter.EmitLoadVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False)) AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" startline="92" endline="111">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Store the stack value into the loop control variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitStoreVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Info.RHSExpression IsNot Nothing)
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             result = Info.RHSExpression.Classification.GenerateCode(Info.Clone(Me, True, False, m_Declaration.LocalBuilder.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info) AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1421" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="125" endline="133">
<![CDATA[
 
 		internal short ReadInt16()
 		{
 			if (end - pos < 2)
 				throw new BadImageFormatException();
 			byte b1 = buffer[pos++];
 			byte b2 = buffer[pos++];
 			return (short)(b1 | (b2 << 8));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="139" endline="149">
<![CDATA[
 
 		internal int ReadInt32()
 		{
 			if (end - pos < 4)
 				throw new BadImageFormatException();
 			byte b1 = buffer[pos++];
 			byte b2 = buffer[pos++];
 			byte b3 = buffer[pos++];
 			byte b4 = buffer[pos++];
 			return (int)(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1422" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="227" endline="243">
<![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveTypeReferences " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveTypeReferences(type) AndAlso result
         Next
 
         result = m_Attributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" startline="143" endline="161">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim atn As ArrayTypeName
         Dim natn As NonArrayTypeName
 
         atn = TryCast(m_TypeName, ArrayTypeName)
         If atn IsNot Nothing Then
             result = atn.ResolveCode(Info) AndAlso result
         Else
             natn = TryCast(m_TypeName, NonArrayTypeName)
             If natn IsNot Nothing Then
                 result = natn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1423" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="227" endline="243">
<![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveTypeReferences " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveTypeReferences(type) AndAlso result
         Next
 
         result = m_Attributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1733" endline="1764">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if a leave instruction is necessary to jump from one statement to the other.
     ''' If ToStatement is nothing then it is assumed a ret instruction is about to be emitted.
     ''' </summary>
     ''' <param name="FromStatement"></param>
     ''' <param name="ToStatement"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsLeaveNecessary(ByVal FromStatement As Statement, ByVal ToStatement As Statement) As Boolean
         Dim result As Boolean
 
         If ToStatement Is Nothing Then
             result = FromStatement.FindParentCodeBlock.UpmostBlock.HasUnstructuredExceptionHandling
         End If
 
         If result = False Then
             Dim parentStmt As Statement = FromStatement
             Do Until parentStmt Is ToStatement OrElse parentStmt Is Nothing
                 result = result OrElse TypeOf parentStmt Is TryStatement
                 result = result OrElse TypeOf parentStmt Is SyncLockStatement
                 result = result OrElse TypeOf parentStmt Is ForEachStatement
                 result = result OrElse TypeOf parentStmt Is UsingStatement
                 result = result OrElse TypeOf parentStmt Is CatchStatement
 
                 If result Then Exit Do
 
                 parentStmt = parentStmt.Parent.FindFirstParent(Of Statement)()
             Loop
             Do Until parentStmt Is ToStatement OrElse parentStmt Is Nothing
                 result = result OrElse TypeOf parentStmt Is TryStatement
                 result = result OrElse TypeOf parentStmt Is SyncLockStatement
                 result = result OrElse TypeOf parentStmt Is ForEachStatement
                 result = result OrElse TypeOf parentStmt Is UsingStatement
                 result = result OrElse TypeOf parentStmt Is CatchStatement
 
                 If result Then Exit Do
 
                 parentStmt = parentStmt.Parent.FindFirstParent(Of Statement)()
             Loop
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1424" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="369" endline="384">
<![CDATA[
 
 		private static bool IsEqual(byte[] b1, byte[] b2)
 		{
 			if (b1.Length != b2.Length)
 			{
 				return false;
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="888" endline="903">
<![CDATA[
 		}
 
 		public static bool Equals (TypeSpec[] x, TypeSpec[] y)
 		{
 			if (x == y)
 				return true;
 
 			if (x.Length != y.Length)
 				return false;
 
 			for (int i = 0; i < x.Length; ++i)
 				if (!IsEqual (x[i], y[i]))
 					return false;
 			for (int i = 0; i < x.Length; ++i)
 				if (!IsEqual (x[i], y[i]))
 					return false;
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1425" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="369" endline="384">
<![CDATA[
 
 		private static bool IsEqual(byte[] b1, byte[] b2)
 		{
 			if (b1.Length != b2.Length)
 			{
 				return false;
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="125" endline="153">
<![CDATA[
 
 		// note that an empty array matches a null reference
 		internal static bool ArrayEquals(Type[] t1, Type[] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1426" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="369" endline="384">
<![CDATA[
 
 		private static bool IsEqual(byte[] b1, byte[] b2)
 		{
 			if (b1.Length != b2.Length)
 			{
 				return false;
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="154" endline="181">
<![CDATA[
 
 		internal static bool ArrayEquals(Type[][] t1, Type[][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1427" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="369" endline="384">
<![CDATA[
 
 		private static bool IsEqual(byte[] b1, byte[] b2)
 		{
 			if (b1.Length != b2.Length)
 			{
 				return false;
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="182" endline="209">
<![CDATA[
 
 		internal static bool ArrayEquals(Type[][][] t1, Type[][][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1428" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="702" endline="719">
<![CDATA[
 
 		public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
 		{
 			if ((metadataToken >> 24) == MemberRefTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				int sig = MemberRef.records[index].Signature;
 				return Signature.ReadOptionalParameterTypes(this, GetBlob(sig));
 			}
 			else if ((metadataToken >> 24) == MethodDefTable.Index)
 			{
 				// for convenience, we support passing a MethodDef token as well, because in some places
 				// it makes sense to have a vararg method that is referred to by its methoddef (e.g. ldftn).
 				// Note that MethodSpec doesn't make sense, because generic methods cannot be vararg.
 				return Type.EmptyTypes;
 			}
 			throw new ArgumentOutOfRangeException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="732" endline="757">
<![CDATA[
 
 		internal void Fixup()
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Interface;
 				switch (token >> 24)
 				{
 					case 0
 						break;
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case TypeRefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case TypeSpecTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Interface = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Interface;
 				switch (token >> 24)
 				{
 					case 0
 						break;
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case TypeRefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case TypeSpecTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Interface = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1429" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="702" endline="719">
<![CDATA[
 
 		public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
 		{
 			if ((metadataToken >> 24) == MemberRefTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				int sig = MemberRef.records[index].Signature;
 				return Signature.ReadOptionalParameterTypes(this, GetBlob(sig));
 			}
 			else if ((metadataToken >> 24) == MethodDefTable.Index)
 			{
 				// for convenience, we support passing a MethodDef token as well, because in some places
 				// it makes sense to have a vararg method that is referred to by its methoddef (e.g. ldftn).
 				// Note that MethodSpec doesn't make sense, because generic methods cannot be vararg.
 				return Type.EmptyTypes;
 			}
 			throw new ArgumentOutOfRangeException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2314" endline="2339">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Owner;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the TypeOrMethodDef encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case MethodDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].unsortedIndex = i;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Owner;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the TypeOrMethodDef encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case MethodDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].unsortedIndex = i;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1430" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="702" endline="719">
<![CDATA[
 
 		public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
 		{
 			if ((metadataToken >> 24) == MemberRefTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				int sig = MemberRef.records[index].Signature;
 				return Signature.ReadOptionalParameterTypes(this, GetBlob(sig));
 			}
 			else if ((metadataToken >> 24) == MethodDefTable.Index)
 			{
 				// for convenience, we support passing a MethodDef token as well, because in some places
 				// it makes sense to have a vararg method that is referred to by its methoddef (e.g. ldftn).
 				// Note that MethodSpec doesn't make sense, because generic methods cannot be vararg.
 				return Type.EmptyTypes;
 			}
 			throw new ArgumentOutOfRangeException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="874" endline="901">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasConstant encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case FieldTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case ParamTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case PropertyTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasConstant encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case FieldTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case ParamTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case PropertyTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1431" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="229" endline="244">
<![CDATA[
 
 		private void WriteData(ByteBuffer bb)
 		{
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="166" endline="185">
<![CDATA[
 		}
 
 		private int DirectoryLength
 		{
 			get
 			{
 				if (Data != null)
 				{
 					return 16;
 				}
 				else
 				{
 					int length = 16 + entries.Count * 8;
 					foreach (ResourceDirectoryEntry entry in entries)
 					{
 						length += entry.DirectoryLength;
 					}
 					foreach (ResourceDirectoryEntry entry in entries)
 					{
 						length += entry.DirectoryLength;
 					}
 					return length;
 				}
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1432" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="229" endline="244">
<![CDATA[
 
 		private void WriteData(ByteBuffer bb)
 		{
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="209" endline="228">
<![CDATA[
 
 		private void WriteResourceDataEntries(ByteBuffer bb, List<int> linkOffsets, ref int offset)
 		{
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					linkOffsets.Add(bb.Position);
 					bb.Write(offset);
 					bb.Write(entry.Data.Length);
 					bb.Write(0);	// code page
 					bb.Write(0);	// reserved
 					offset += (entry.Data.Length + 3) & ~3;
 				}
 				else
 				{
 					entry.WriteResourceDataEntries(bb, linkOffsets, ref offset);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					linkOffsets.Add(bb.Position);
 					bb.Write(offset);
 					bb.Write(entry.Data.Length);
 					bb.Write(0);	// code page
 					bb.Write(0);	// reserved
 					offset += (entry.Data.Length + 3) & ~3;
 				}
 				else
 				{
 					entry.WriteResourceDataEntries(bb, linkOffsets, ref offset);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1433" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3109" endline="3121">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Type()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         For Each t As Type In Types
             Helper.Assert(t IsNot Nothing)
             result &= sep & t.ToString
             sep = ", "
         Next
 
         Return "{" & result & "}"
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3094" endline="3108">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Mono.Cecil.TypeReference()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         If Types IsNot Nothing Then
             For Each t As Mono.Cecil.TypeReference In Types
                 Helper.Assert(t IsNot Nothing)
                 result &= sep & t.ToString
                 sep = ", "
             Next
         End If
 
         Return "{" & result & "}"
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1434" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="97" endline="108">
<![CDATA[
 
     Private Function DefineType(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineType AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineType(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="109" endline="120">
<![CDATA[
 
     Private Function DefineTypeHierarchy(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineTypeHierarchy AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineTypeHierarchy(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1435" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="97" endline="108">
<![CDATA[
 
     Private Function DefineType(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineType AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineType(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="205" endline="218">
<![CDATA[
 
     Private Function CreateImplicitTypes(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = CreateImplicitTypes(NestedType) AndAlso result
         Next
 
         For Each Member As IHasImplicitTypes In Type.Members.GetSpecificMembers(Of IHasImplicitTypes)()
             result = Member.CreateImplicitTypes() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1436" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="228" endline="249">
<![CDATA[
 
 		internal int ReadCustomAttributeType()
 		{
 			int codedIndex;
 			if (bigCustomAttributeType)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 2
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MemberRefTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="118" endline="141">
<![CDATA[
 
 		internal int ReadTypeDefOrRef()
 		{
 			int codedIndex;
 			if (bigTypeDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (TypeRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (TypeSpecTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1437" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="228" endline="249">
<![CDATA[
 
 		internal int ReadCustomAttributeType()
 		{
 			int codedIndex;
 			if (bigCustomAttributeType)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 2
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MemberRefTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="272" endline="295">
<![CDATA[
 
 		internal int ReadHasConstant()
 		{
 			int codedIndex;
 			if (bigHasConstant)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (PropertyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1438" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="228" endline="249">
<![CDATA[
 
 		internal int ReadCustomAttributeType()
 		{
 			int codedIndex;
 			if (bigCustomAttributeType)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 2
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MemberRefTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="408" endline="431">
<![CDATA[
 
 		internal int ReadImplementation()
 		{
 			int codedIndex;
 			if (bigImplementation)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FileTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (ExportedTypeTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1439" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="228" endline="249">
<![CDATA[
 
 		internal int ReadCustomAttributeType()
 		{
 			int codedIndex;
 			if (bigCustomAttributeType)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 2
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MemberRefTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="340" endline="363">
<![CDATA[
 
 		internal int ReadHasDeclSecurity()
 		{
 			int codedIndex;
 			if (bigHasDeclSecurity)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (AssemblyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1440" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="228" endline="249">
<![CDATA[
 
 		internal int ReadCustomAttributeType()
 		{
 			int codedIndex;
 			if (bigCustomAttributeType)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 2
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MemberRefTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="92" endline="117">
<![CDATA[
 
 		internal int ReadResolutionScope()
 		{
 			int codedIndex;
 			if (bigResolutionScope)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (ModuleTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (ModuleRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
 				case 3
 					return (TypeRefTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1441" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="228" endline="249">
<![CDATA[
 
 		internal int ReadCustomAttributeType()
 		{
 			int codedIndex;
 			if (bigCustomAttributeType)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 2
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MemberRefTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="142" endline="169">
<![CDATA[
 
 		internal int ReadMemberRefParent()
 		{
 			int codedIndex;
 			if (bigMemberRefParent)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 3);
 				case 1
 					return (TypeRefTable.Index << 24) + (codedIndex >> 3);
 				case 2
 					return (ModuleRefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 4
 					return (TypeSpecTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1442" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="491" endline="503">
<![CDATA[
 
 		private Assembly ResolveAssemblyRef(int index)
 		{
 			if (assemblyRefs == null)
 			{
 				assemblyRefs = new Assembly[AssemblyRef.RowCount];
 			}
 			if (assemblyRefs[index] == null)
 			{
 				assemblyRefs[index] = ResolveAssemblyRefImpl(ref AssemblyRef.records[index]);
 			}
 			return assemblyRefs[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="593" endline="605">
<![CDATA[
 
 		internal FieldInfo GetFieldAt(TypeDefImpl owner, int index)
 		{
 			if (fields == null)
 			{
 				fields = new FieldInfo[Field.records.Length];
 			}
 			if (fields[index] == null)
 			{
 				fields[index] = new FieldDefImpl(this, owner ?? FindFieldOwner(index), index);
 			}
 			return fields[index];
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1443" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="66" endline="79">
<![CDATA[
     End Property
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If m_FieldBuilderCecil Is Nothing Then
             m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(Name, Mono.Cecil.FieldAttributes.Public Or Mono.Cecil.FieldAttributes.Static Or Mono.Cecil.FieldAttributes.Literal Or Mono.Cecil.FieldAttributes.HasDefault, Parent.CecilType)
             m_FieldBuilderCecil.Annotations.Add(Compiler, Me)
             Parent.CecilType.Fields.Add(m_FieldBuilderCecil)
         End If
 
         m_FieldBuilderCecil.Name = Name
         m_FieldBuilderCecil.IsLiteral = True
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="180" endline="198">
<![CDATA[
 
     Public Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If m_CecilBuilder Is Nothing Then
             m_CecilBuilder = New Mono.Cecil.PropertyDefinition(Name, 0, Helper.GetTypeOrTypeReference(Compiler, Me.Signature.ReturnType))
             m_CecilBuilder.Annotations.Add(Compiler, Me)
             DeclaringType.CecilType.Properties.Add(m_CecilBuilder)
         End If
         m_CecilBuilder.Name = Me.Name
         m_CecilBuilder.PropertyType = Helper.GetTypeOrTypeReference(Compiler, Me.Signature.ReturnType)
 
         If m_Get IsNot Nothing Then
             m_CecilBuilder.GetMethod = m_Get.CecilBuilder
         End If
         If m_Set IsNot Nothing Then
             m_CecilBuilder.SetMethod = m_Set.CecilBuilder
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1444" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1130" endline="1145">
<![CDATA[
 
 		// Define each type attribute (in/out/ref) and
 		// the argument names.
 		public void ApplyAttributes (IMemberContext mc, MethodBase builder)
 		{
 			if (Count == 0)
 				return;
 
 			MethodBuilder mb = builder as MethodBuilder;
 			ConstructorBuilder cb = builder as ConstructorBuilder;
 			var pa = mc.Module.PredefinedAttributes;
 
 			for (int i = 0; i < Count; i++) {
 				this [i].ApplyAttributes (mb, cb, i + 1, pa);
 			}
 			for (int i = 0; i < Count; i++) {
 				this [i].ApplyAttributes (mb, cb, i + 1, pa);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="466" endline="479">
<![CDATA[
 
 		public static System.Linq.Expressions.Expression[] MakeExpression (Arguments args, BuilderContext ctx)
 		{
 			if (args == null || args.Count == 0)
 				return null;
 
 			var exprs = new System.Linq.Expressions.Expression [args.Count];
 			for (int i = 0; i < exprs.Length; ++i) {
 				Argument a = args.args [i];
 				exprs[i] = a.Expr.MakeExpression (ctx);
 			}
 			for (int i = 0; i < exprs.Length; ++i) {
 				Argument a = args.args [i];
 				exprs[i] = a.Expr.MakeExpression (ctx);
 			}
 
 			return exprs;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1445" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="975" endline="983">
<![CDATA[
 
     Function FindTypeWithName(ByVal Name As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.Name, Name) Then Return tD
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="984" endline="992">
<![CDATA[
 
     Function FindTypeWithFullname(ByVal Fullname As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.FullName, Fullname) Then Return tD
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1446" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="760" endline="773">
<![CDATA[
 
 		protected static Type[][] BindTypeParameters(IGenericBinder binder, Type[][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][] expanded = new Type[types.Length][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="774" endline="787">
<![CDATA[
 
 		protected static Type[][][] BindTypeParameters(IGenericBinder binder, Type[][][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][][] expanded = new Type[types.Length][][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1447" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstraintList.vb" startline="30" endline="38">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstraintList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstraintList(NewParent)
         For Each item As Constraint In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="47" endline="55">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameterList(NewParent)
         For Each item As TypeParameter In Me
             result.Add(item.clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1448" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstraintList.vb" startline="30" endline="38">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstraintList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstraintList(NewParent)
         For Each item As Constraint In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" startline="407" endline="430">
<![CDATA[
 
     Private Function CheckCurrentFunctionForTypeParameters(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         Dim signature As SubSignature = Nothing
         Dim method As MethodBaseDeclaration = FromWhere.FindFirstParent(Of MethodBaseDeclaration)()
 
         If method IsNot Nothing Then
             signature = method.Signature
         Else
             Dim del As DelegateDeclaration = FromWhere.FindFirstParent(Of DelegateDeclaration)()
             If del IsNot Nothing Then
                 signature = del.Signature
             End If
         End If
 
         If signature IsNot Nothing AndAlso signature.TypeParameters IsNot Nothing Then
             Dim item As TypeParameter = signature.TypeParameters.Parameters.Item(R)
             If item IsNot Nothing Then
                 m_FoundObjects.Add(item)
                 Return True
             End If
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1449" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="929" endline="941">
<![CDATA[
 
 		public bool HasField (string fieldName)
 		{
 			if (named_values == null)
 				return false;
 
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="911" endline="923">
<![CDATA[
 
 		public Constant GetNamedValue (string name)
 		{
 			if (named_values == null)
 				return null;
 
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1450" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="79" endline="95">
<![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New MemberAccessExpression(NewParent)
 
         Dim m_First As Expression = Nothing
         Dim m_Second As IdentifierOrKeyword = Nothing
         '  Dim m_TypeArguments As TypeParameters
 
         If Me.m_First IsNot Nothing Then m_First = Me.m_First.Clone(result)
         If Me.m_Second IsNot Nothing Then m_Second = Me.m_Second.Clone(result)
         '  If Me.m_TypeArguments IsNot Nothing Then m_TypeArguments = Me.m_TypeArguments.Clone(result)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6257" endline="6280">
<![CDATA[
 
     Private Function FindTypeInParent(ByVal Parent As ParsedObject, ByVal CompleteName As String) As TypeDeclaration
         Dim assemblyParent As AssemblyDeclaration = TryCast(Parent, AssemblyDeclaration)
         Dim typeParent As TypeDeclaration = TryCast(Parent, TypeDeclaration)
         Dim partialType As TypeDeclaration = Nothing
         Dim partialTypes As Generic.List(Of INameable)
 
         If assemblyParent IsNot Nothing Then
             partialType = assemblyParent.FindTypeWithFullname(CompleteName)
         ElseIf typeParent IsNot Nothing Then
             partialTypes = typeParent.Members.Index.Item(CompleteName)
             If partialTypes IsNot Nothing Then
                 If partialTypes.Count = 1 Then
                     partialType = TryCast(partialTypes(0), TypeDeclaration)
                     If partialType Is Nothing Then
                         Helper.AddError(Compiler, tm.CurrentLocation, "Already a member with the name " & CompleteName)
                     End If
                 ElseIf partialTypes.Count > 1 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Already a member with the name " & CompleteName)
                 End If
             End If
         End If
         Return partialType
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1451" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" startline="89" endline="99">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Catches IsNot Nothing Then result = m_Catches.ResolveTypeReferences() AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="345" endline="366">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = DefineOverrides() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Me.IsPropertyHandlesHandler Then
             result = GeneratePropertyHandlers() AndAlso result
         ElseIf Me.HasMethodBody Then
             Helper.Assert(m_Code IsNot Nothing)
 
             'Create the default return variable
             If Me.HasReturnValue Then
                 m_DefaultReturnVariable = Emitter.DeclareLocal(Info, ReturnType)
             End If
 
             result = m_Code.GenerateCode(Me) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1452" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="167" endline="192">
<![CDATA[
 
 		//
 		// When the same attribute is attached to multiple fiels
 		// we use @target field as a list of targets. The attribute
 		// has to be resolved only once but emitted for each target.
 		//
 		public void AttachTo (Attributable target, IMemberContext context)
 		{
 			if (this.targets == null) {
 				this.targets = new Attributable[] { target };
 				this.context = context;
 				return;
 			}
 
 			// Resize target array
 			Attributable[] new_array = new Attributable [this.targets.Length + 1];
 			targets.CopyTo (new_array, 0);
 			new_array [targets.Length] = target;
 			this.targets = new_array;
 
 			// No need to update context, different targets cannot have
 			// different contexts, it's enough to remove same attributes
 			// from secondary members.
 
 			target.OptAttributes = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="784" endline="801">
<![CDATA[
 		}
 
 		#endregion
 
 		public void ChangeTypeArgumentToBaseType (int index)
 		{
 			BaseType = targs [index];
 			if (targs.Length == 1) {
 				targs = null;
 			} else {
 				var copy = new TypeSpec[targs.Length - 1];
 				if (index > 0)
 					Array.Copy (targs, copy, index);
 
 				Array.Copy (targs, index + 1, copy, index, targs.Length - index - 1);
 				targs = copy;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1453" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="94" endline="109">
<![CDATA[
 		}
 
 		#endregion
 
 		public static bool CheckConflictingInheritedConstraint (TypeParameterSpec spec, TypeSpec bb, IMemberContext context, Location loc)
 		{
 			if (spec.HasSpecialClass && bb.IsStruct) {
 				context.Compiler.Report.Error (455, loc,
 					"Type parameter `{0}' inherits conflicting constraints `{1}' and `{2}'",
 					spec.Name, "class", bb.GetSignatureForError ());
 
 				return false;
 			}
 
 			return CheckConflictingInheritedConstraint (spec, spec.BaseType, bb, context, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="110" endline="123">
<![CDATA[
 
 		static bool CheckConflictingInheritedConstraint (TypeParameterSpec spec, TypeSpec ba, TypeSpec bb, IMemberContext context, Location loc)
 		{
 			if (ba == bb)
 				return true;
 
 			if (TypeSpec.IsBaseClass (ba, bb, false) || TypeSpec.IsBaseClass (bb, ba, false))
 				return true;
 
 			context.Compiler.Report.Error (455, loc,
 				"Type parameter `{0}' inherits conflicting constraints `{1}' and `{2}'",
 				spec.Name, ba.GetSignatureForError (), bb.GetSignatureForError ());
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1454" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1255" endline="1262">
<![CDATA[
 
     Public Shared Function CompareParameterTypes(ByVal a As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal b As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If a.Count <> b.Count Then Return False
         For i As Integer = 0 To a.Count - 1
             If Helper.CompareType(a(i).ParameterType, b(i).ParameterType) = False Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1334" endline="1342">
<![CDATA[
 
     Public Shared Function AreSame(ByVal a As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal b As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If a.Count <> b.Count Then Return False
         If a.Count = 0 Then Return True
         For i As Integer = 0 To a.Count - 1
             If Not AreSame(a(i).ParameterType, b(i).ParameterType) Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1455" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="768" endline="785">
<![CDATA[
 
 		public static SourceMethod Create (DeclSpace parent, MethodBase method, Block block)
 		{
 			if (!SymbolWriter.HasSymbolWriter)
 				return null;
 			if (block == null)
 				return null;
 
 			Location start_loc = block.StartLocation;
 			if (start_loc.IsNull)
 				return null;
 
 			ICompileUnit compile_unit = start_loc.CompilationUnit;
 			if (compile_unit == null)
 				return null;
 
 			return new SourceMethod (parent, method, compile_unit);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="262" endline="282">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (Kind != MemberKind.Class)
 				throw new InternalErrorException ();
 
 			if (!pa.IsDefined)
 				return Attribute.DefaultUsageAttribute;
 
 			AttributeUsageAttribute aua = null;
 			var type = this;
 			while (type != null) {
 				aua = type.MemberDefinition.GetAttributeUsage (pa);
 				if (aua != null)
 					break;
 
 				type = type.BaseType;
 			}
 			while (type != null) {
 				aua = type.MemberDefinition.GetAttributeUsage (pa);
 				if (aua != null)
 					break;
 
 				type = type.BaseType;
 			}
 
 			return aua;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1456" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="768" endline="785">
<![CDATA[
 
 		public static SourceMethod Create (DeclSpace parent, MethodBase method, Block block)
 		{
 			if (!SymbolWriter.HasSymbolWriter)
 				return null;
 			if (block == null)
 				return null;
 
 			Location start_loc = block.StartLocation;
 			if (start_loc.IsNull)
 				return null;
 
 			ICompileUnit compile_unit = start_loc.CompilationUnit;
 			if (compile_unit == null)
 				return null;
 
 			return new SourceMethod (parent, method, compile_unit);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="151" endline="182">
<![CDATA[
 
 		static Expression ExplicitTypeParameterConversion (Expression source, TypeSpec source_type, TypeSpec target_type)
 		{
 			var target_tp = target_type as TypeParameterSpec;
 			if (target_tp != null) {
 				if (target_tp.TypeArguments != null) {
 					foreach (var targ in target_tp.TypeArguments) {
 						if (!TypeSpecComparer.Override.IsEqual (source_type, targ))
 							continue;
 
 						return source == null ? EmptyExpression.Null 
 					foreach (var targ in target_tp.TypeArguments) {
 						if (!TypeSpecComparer.Override.IsEqual (source_type, targ))
 							continue;
 
 						return source == null ? EmptyExpression.Null 
 					}
 				}
 /*
 				if (target_tp.Interfaces != null) {
 					foreach (TypeSpec iface in target_tp.Interfaces) {
 						if (!TypeManager.IsGenericParameter (iface))
 							continue;
 
 						if (TypeManager.IsSubclassOf (source_type, iface))
 							return source == null ? EmptyExpression.Null 
 					}
 				}
 */
 				return null;
 			}
 
 			if (target_type.IsInterface)
 				return source == null ? EmptyExpression.Null 
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1457" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="768" endline="785">
<![CDATA[
 
 		public static SourceMethod Create (DeclSpace parent, MethodBase method, Block block)
 		{
 			if (!SymbolWriter.HasSymbolWriter)
 				return null;
 			if (block == null)
 				return null;
 
 			Location start_loc = block.StartLocation;
 			if (start_loc.IsNull)
 				return null;
 
 			ICompileUnit compile_unit = start_loc.CompilationUnit;
 			if (compile_unit == null)
 				return null;
 
 			return new SourceMethod (parent, method, compile_unit);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1089" endline="1111">
<![CDATA[
 
 		public bool Resolve (IMemberContext ec)
 		{
 			if (types != null)
 				return true;
 			
 			types = new TypeSpec [Count];
 			
 			bool ok = true;
 			Parameter p;
 			for (int i = 0; i < FixedParameters.Length; ++i) {
 				p = this [i];
 				TypeSpec t = p.Resolve (ec, i);
 				if (t == null) {
 					ok = false;
 					continue;
 				}
 
 				types [i] = t;
 			}
 			for (int i = 0; i < FixedParameters.Length; ++i) {
 				p = this [i];
 				TypeSpec t = p.Resolve (ec, i);
 				if (t == null) {
 					ok = false;
 					continue;
 				}
 
 				types [i] = t;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1458" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1502" endline="1514">
<![CDATA[
 
 		protected override bool IsNotCLSCompliant ()
 		{
 			if (base.IsNotCLSCompliant ())
 				return true;
 
 			foreach (var ta in TypeArguments) {
 				if (ta.MemberDefinition.IsNotCLSCompliant ())
 					return true;
 			}
 			foreach (var ta in TypeArguments) {
 				if (ta.MemberDefinition.IsNotCLSCompliant ())
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1480" endline="1495">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			if (type_params != null) {
 				foreach (TypeParameter tp in type_params) {
 					tp.VerifyClsCompliance ();
 				}
 				foreach (TypeParameter tp in type_params) {
 					tp.VerifyClsCompliance ();
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1459" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializerList.vb" startline="45" endline="53">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializerList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializerList(NewParent)
         For Each item As VariablePropertyInitializer In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="44" endline="52">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributePositionalArgumentList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributePositionalArgumentList(NewParent)
         For Each item As AttributeArgumentExpression In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1460" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArgumentList.vb" startline="43" endline="52">
<![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeArgumentList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeArgumentList(NewParent)
         For Each item As TypeName In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="242" endline="256">
<![CDATA[
     End Property
 
     Function FindLabel(ByVal Name As Token) As LabelDeclarationStatement
         Dim cb As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         If cb IsNot Nothing Then
             Return cb.FindLabel(Name)
         Else
             For Each l As LabelDeclarationStatement In m_Labels
                 If l.Label.Equals(Name) Then
                     Return l
                 End If
             Next
         End If
         Return Nothing
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1461" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2419" endline="2431">
<![CDATA[
 
 		internal int FindOrAddRecord(Record record)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Method == record.Method
 					&& records[i].Instantiation == record.Instantiation)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Method == record.Method
 					&& records[i].Instantiation == record.Instantiation)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(record);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2160" endline="2173">
<![CDATA[
 
 		internal int FindOrAddRecord(Record rec)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Implementation == rec.Implementation
 					&& records[i].TypeName == rec.TypeName
 					&& records[i].TypeNamespace == rec.TypeNamespace)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Implementation == rec.Implementation
 					&& records[i].TypeName == rec.TypeName
 					&& records[i].TypeNamespace == rec.TypeNamespace)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(rec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1462" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="527" endline="549">
<![CDATA[
 
 		internal void WriteMemberForwarded(int token)
 		{
 			switch (token >> 24)
 			{
 				case FieldTable.Index
 					token = (token & 0xFFFFFF) << 1 | 0;
 				    break;
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 1;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMemberForwarded)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="420" endline="442">
<![CDATA[
 
 		internal void WriteMethodDefOrRef(int token)
 		{
 			switch (token >> 24)
 			{
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 0;
 					break;
 				case MemberRefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 1;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMethodDefOrRef)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1463" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" startline="44" endline="54">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = m_NonArrayTypeName.ResolvedType
         End If
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" startline="49" endline="61">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Expressions.Length - 1
             result = m_Expressions(i).ResolveExpression(Info) AndAlso result
             If result Then
                 m_Expressions(i) = Helper.CreateTypeConversion(Me, m_Expressions(i), Compiler.TypeCache.System_Int32, result)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1464" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3139" endline="3158">
<![CDATA[
 
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.FieldAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.FieldAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.FieldAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.FieldAttributes.Public
                 Return "Public"
             Case Mono.Cecil.FieldAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3159" endline="3177">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.MethodAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.MethodAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.MethodAttributes.Public
                 Return "Public"
             Case Mono.Cecil.MethodAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1465" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\NamedBaseList.vb" startline="38" endline="55">
<![CDATA[
 
     ''' <summary>
     ''' Finds the list item with the specified name.
     ''' Returns nothing if nothing found.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal Name As String) As T
         Get
             For Each tp As T In Me
                 Dim t As INameable = CType(CObj(tp), INameable)
                 If Helper.CompareName(t.Name, Name) Then
                     Return tp
                 End If
             Next
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ImportsClauses.vb" startline="40" endline="66">
<![CDATA[
 
     ''' <summary>
     ''' Looks up all the modules imported by all the imports clauses.
     ''' </summary>
     ''' <param name="FromWhere"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetModules(ByVal FromWhere As BaseObject) As TypeList
         Dim result As TypeList = Nothing
         For Each imp As ImportsClause In Me
             If imp.IsNamespaceClause Then
                 Dim ns As ImportsNamespaceClause = imp.AsNamespaceClause
                 If ns.IsTypeImport Then
                     'A type cannot contain a module, nothing to do here.
                 ElseIf ns.IsNamespaceImport Then
                     Dim modules As TypeDictionary = FromWhere.Compiler.TypeManager.GetModulesByNamespace(ns.NamespaceImported.ToString)
                     If modules IsNot Nothing AndAlso modules.Count > 0 Then
                         If result Is Nothing Then result = New TypeList
                         result.AddRange(modules.TypesAsArray)
                     End If
                 Else
                     Continue For 'This import was not resolved correctly, don't use it.
                 End If
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1466" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="111" endline="124">
<![CDATA[
 
 		internal static T[] ToArray<T, V>(List<V> list, T[] empty) where V 
 		{
 			if (list == null || list.Count == 0)
 			{
 				return empty;
 			}
 			T[] array = new T[list.Count];
 			for (int i = 0; i < array.Length; i++)
 			{
 				array[i] = list[i];
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				array[i] = list[i];
 			}
 			return array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="72" endline="90">
<![CDATA[
 	}
 
 	static class ArrayComparer
 	{
 		public static bool IsEqual<T> (T[] array1, T[] array2)
 		{
 			if (array1 == null || array2 == null)
 				return array1 == array2;
 
 			var eq = EqualityComparer<T>.Default;
 
 			for (int i = 0; i < array1.Length; ++i) {
 				if (!eq.Equals (array1[i], array2[i])) {
 					return false;
 				}
 			}
 			for (int i = 0; i < array1.Length; ++i) {
 				if (!eq.Equals (array1[i], array2[i])) {
 					return false;
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1467" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CallStatement.vb" startline="84" endline="100">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Target.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_Target.Classification.IsMethodGroupClassification Then
             Dim tmp As New InvocationOrIndexExpression(Me)
             tmp.Init(m_Target, New ArgumentList(tmp))
             result = tmp.ResolveExpression(Info) AndAlso result
             m_Target = tmp
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="316" endline="347">
<![CDATA[
 
     ''' <summary>
     ''' ImportsAliasClause  
     '''	Identifier  =  QualifiedIdentifier  |
     '''	Identifier  =  ConstructedTypeName
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     ''' 
     ''' This overload is used when parsing commandline imports.
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsAliasClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsAliasClause
         Dim result As New ImportsAliasClause(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_Second As ImportsNamespaceClause = Nothing
 
         Dim values() As String = str.Split("="c)
         If values.Length <> 2 Then Return Nothing
 
         m_Identifier = New Identifier(result, values(0), Span.CommandLineSpan, TypeCharacters.Characters.None)
 
         m_Second = ParseImportsNamespaceClause(result, values(1))
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
 
         result.Init(m_Identifier, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1468" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="560" endline="574">
<![CDATA[
 
 		public void LoadModules (AssemblyDefinitionDynamic assembly, RootNamespace targetNamespace)
 		{
 			if (RootContext.Modules.Count == 0)
 				return;
 
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (assembly, moduleName);
 				if (m == null)
 					continue;
 
 				var md = importer.ImportModule (m, targetNamespace);
 				assembly.AddModule (md);
 			}
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (assembly, moduleName);
 				if (m == null)
 					continue;
 
 				var md = importer.ImportModule (m, targetNamespace);
 				assembly.AddModule (md);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="459" endline="478">
<![CDATA[
 
 		public void LoadModules (AssemblyDefinitionStatic assembly, RootNamespace targetNamespace)
 		{
 			if (RootContext.Modules.Count == 0)
 				return;
 
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (moduleName);
 				if (m == null)
 					continue;
 
 				if (m.IsManifestModule) {
 					Error_FileCorrupted (moduleName);
 					continue;
 				}
 
 				var md = importer.ImportModule (assembly.IncludeModule (m), targetNamespace);
 				assembly.AddModule (md);
 			}
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (moduleName);
 				if (m == null)
 					continue;
 
 				if (m.IsManifestModule) {
 					Error_FileCorrupted (moduleName);
 					continue;
 				}
 
 				var md = importer.ImportModule (assembly.IncludeModule (m), targetNamespace);
 				assembly.AddModule (md);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1469" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9356" endline="9367">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			var expr_initializers = new ArrayInitializer (initializers.Count, loc);
 			foreach (Expression e in initializers) {
 				Expression expr = e.CreateExpressionTree (ec);
 				if (expr != null)
 					expr_initializers.Add (expr);
 			}
 			foreach (Expression e in initializers) {
 				Expression expr = e.CreateExpressionTree (ec);
 				if (expr != null)
 					expr_initializers.Add (expr);
 			}
 
 			return new ImplicitlyTypedArrayCreation (expr_initializers, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1296" endline="1307">
<![CDATA[
 
 		public Attribute Search (string explicitTarget, PredefinedAttribute t)
 		{
 			foreach (Attribute a in Attrs) {
 				if (explicitTarget != null && a.ExplicitTarget != explicitTarget)
 					continue;
 
 				if (a.ResolveType () == t)
 					return a;
 			}
 			foreach (Attribute a in Attrs) {
 				if (explicitTarget != null && a.ExplicitTarget != explicitTarget)
 					continue;
 
 				if (a.ResolveType () == t)
 					return a;
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1470" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9356" endline="9367">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			var expr_initializers = new ArrayInitializer (initializers.Count, loc);
 			foreach (Expression e in initializers) {
 				Expression expr = e.CreateExpressionTree (ec);
 				if (expr != null)
 					expr_initializers.Add (expr);
 			}
 			foreach (Expression e in initializers) {
 				Expression expr = e.CreateExpressionTree (ec);
 				if (expr != null)
 					expr_initializers.Add (expr);
 			}
 
 			return new ImplicitlyTypedArrayCreation (expr_initializers, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3593" endline="3604">
<![CDATA[
 
 		SwitchSection FindSection (SwitchLabel label)
 		{
 			foreach (SwitchSection ss in Sections){
 				foreach (SwitchLabel sl in ss.Labels){
 					if (label == sl)
 						return ss;
 				}
 				foreach (SwitchLabel sl in ss.Labels){
 					if (label == sl)
 						return ss;
 				}
 			}
 			foreach (SwitchSection ss in Sections){
 				foreach (SwitchLabel sl in ss.Labels){
 					if (label == sl)
 						return ss;
 				}
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1471" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9356" endline="9367">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			var expr_initializers = new ArrayInitializer (initializers.Count, loc);
 			foreach (Expression e in initializers) {
 				Expression expr = e.CreateExpressionTree (ec);
 				if (expr != null)
 					expr_initializers.Add (expr);
 			}
 			foreach (Expression e in initializers) {
 				Expression expr = e.CreateExpressionTree (ec);
 				if (expr != null)
 					expr_initializers.Add (expr);
 			}
 
 			return new ImplicitlyTypedArrayCreation (expr_initializers, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1308" endline="1325">
<![CDATA[
 
 		/// <summary>
 		/// Returns all attributes of type 't'. Use it when attribute is AllowMultiple = true
 		/// </summary>
 		public Attribute[] SearchMulti (PredefinedAttribute t)
 		{
 			List<Attribute> ar = null;
 
 			foreach (Attribute a in Attrs) {
 				if (a.ResolveType () == t) {
 					if (ar == null)
 						ar = new List<Attribute> (Attrs.Count);
 					ar.Add (a);
 				}
 			}
 			foreach (Attribute a in Attrs) {
 				if (a.ResolveType () == t) {
 					if (ar == null)
 						ar = new List<Attribute> (Attrs.Count);
 					ar.Add (a);
 				}
 			}
 
 			return ar == null ? null 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1472" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" startline="82" endline="91">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         Helper.Assert(TypeOf Parent Is ClassDeclaration = False)
 
         If m_Identifier IsNot Nothing Then m_Identifier.Initialize(Me)
         If m_TypeParameters IsNot Nothing Then m_TypeParameters.Initialize(Me)
         If m_ParameterList IsNot Nothing Then m_ParameterList.Initialize(Me)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="71" endline="88">
<![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1473" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="89" endline="102">
<![CDATA[
 
 		internal void ExtractResources(byte[] buf)
 		{
 			ByteReader br = new ByteReader(buf, 0, buf.Length);
 			while (br.Length >= 32)
 			{
 				br.Align(4);
 				RESOURCEHEADER hdr = new RESOURCEHEADER(br);
 				if (hdr.DataSize != 0)
 				{
 					root[hdr.TYPE][hdr.NAME][new OrdinalOrName(hdr.LanguageId)].Data = ByteBuffer.Wrap(br.ReadBytes(hdr.DataSize));
 				}
 			}
 			while (br.Length >= 32)
 			{
 				br.Align(4);
 				RESOURCEHEADER hdr = new RESOURCEHEADER(br);
 				if (hdr.DataSize != 0)
 				{
 					root[hdr.TYPE][hdr.NAME][new OrdinalOrName(hdr.LanguageId)].Data = ByteBuffer.Wrap(br.ReadBytes(hdr.DataSize));
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="220" endline="242">
<![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1474" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="89" endline="102">
<![CDATA[
 
 		internal void ExtractResources(byte[] buf)
 		{
 			ByteReader br = new ByteReader(buf, 0, buf.Length);
 			while (br.Length >= 32)
 			{
 				br.Align(4);
 				RESOURCEHEADER hdr = new RESOURCEHEADER(br);
 				if (hdr.DataSize != 0)
 				{
 					root[hdr.TYPE][hdr.NAME][new OrdinalOrName(hdr.LanguageId)].Data = ByteBuffer.Wrap(br.ReadBytes(hdr.DataSize));
 				}
 			}
 			while (br.Length >= 32)
 			{
 				br.Align(4);
 				RESOURCEHEADER hdr = new RESOURCEHEADER(br);
 				if (hdr.DataSize != 0)
 				{
 					root[hdr.TYPE][hdr.NAME][new OrdinalOrName(hdr.LanguageId)].Data = ByteBuffer.Wrap(br.ReadBytes(hdr.DataSize));
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="175" endline="197">
<![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1475" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1698" endline="1713">
<![CDATA[
 		}
 
 		public string GetSignatureForError()
 		{
 			StringBuilder sb = new StringBuilder ();
 			for (int i = 0; i < Count; ++i) {
 				var expr = args[i];
 				if (expr != null)
 					sb.Append (expr.GetSignatureForError ());
 
 				if (i + 1 < Count)
 					sb.Append (',');
 			}
 			for (int i = 0; i < Count; ++i) {
 				var expr = args[i];
 				if (expr != null)
 					sb.Append (expr.GetSignatureForError ());
 
 				if (i + 1 < Count)
 					sb.Append (',');
 			}
 
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="633" endline="657">
<![CDATA[
 
 		static string GetParametersFormatted (MemberSpec mi)
 		{
 			var pm = mi as IParametersMember;
 			if (pm == null || pm.Parameters.IsEmpty)
 				return string.Empty;
 
 			AParametersCollection parameters = pm.Parameters;
 /*
 			if (parameters == null || parameters.Count == 0)
 				return String.Empty;
 */
 			StringBuilder sb = new StringBuilder ();
 			sb.Append ('(');
 			for (int i = 0; i < parameters.Count; i++) {
 //				if (is_setter && i + 1 == parameters.Count)
 //					break; // skip "value".
 				if (i > 0)
 					sb.Append (',');
 				TypeSpec t = parameters.Types [i];
 				sb.Append (GetSignatureForDoc (t));
 			}
 			for (int i = 0; i < parameters.Count; i++) {
 //				if (is_setter && i + 1 == parameters.Count)
 //					break; // skip "value".
 				if (i > 0)
 					sb.Append (',');
 				TypeSpec t = parameters.Types [i];
 				sb.Append (GetSignatureForDoc (t));
 			}
 			sb.Append (')');
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1476" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="477" endline="490">
<![CDATA[
 
 		public override Type[] GetTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (ModuleBuilder module in modules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (Module module in addedModules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (Module module in addedModules)
 			{
 				module.GetTypesImpl(list);
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="550" endline="569">
<![CDATA[
 
 		public override Module[] GetModules(bool getResourceModules)
 		{
 			List<Module> list = new List<Module>();
 			foreach (ModuleBuilder module in modules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1477" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="477" endline="490">
<![CDATA[
 
 		public override Type[] GetTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (ModuleBuilder module in modules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (Module module in addedModules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (Module module in addedModules)
 			{
 				module.GetTypesImpl(list);
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="570" endline="588">
<![CDATA[
 
 		public override Module GetModule(string name)
 		{
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1478" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1995" endline="2011">
<![CDATA[
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// Type it as string cast
 			if (targetType == TypeManager.object_type || targetType == InternalType.Null)
 				enc.Encode (TypeManager.string_type);
 
 			var ac = targetType as ArrayContainer;
 			if (ac != null) {
 				if (ac.Rank != 1 || ac.Element.IsArray)
 					base.EncodeAttributeValue (rc, enc, targetType);
 				else
 					enc.Encode (uint.MaxValue);
 			} else {
 				enc.Encode (byte.MaxValue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1112" endline="1142">
<![CDATA[
 
 		// <summary>
 		//   A struct's constructor must always assign all fields.
 		//   This method checks whether it actually does so.
 		// </summary>
 		public bool IsFullyInitialized (BlockContext ec, VariableInfo vi, Location loc)
 		{
 			if (struct_info == null)
 				return true;
 
 			bool ok = true;
 			FlowBranching branching = ec.CurrentBranching;
 			for (int i = 0; i < struct_info.Count; i++) {
 				var field = struct_info.Fields [i];
 
 				if (!branching.IsFieldAssigned (vi, field.Name)) {
 					if (field.MemberDefinition is Property.BackingField) {
 						ec.Report.Error (843, loc,
 							"An automatically implemented property `{0}' must be fully assigned before control leaves the constructor. Consider calling the default struct contructor from a constructor initializer",
 							field.GetSignatureForError ());
 					} else {
 						ec.Report.Error (171, loc,
 							"Field `{0}' must be fully assigned before control leaves the constructor",
 							field.GetSignatureForError ());
 					}
 					ok = false;
 				}
 			}
 			for (int i = 0; i < struct_info.Count; i++) {
 				var field = struct_info.Fields [i];
 
 				if (!branching.IsFieldAssigned (vi, field.Name)) {
 					if (field.MemberDefinition is Property.BackingField) {
 						ec.Report.Error (843, loc,
 							"An automatically implemented property `{0}' must be fully assigned before control leaves the constructor. Consider calling the default struct contructor from a constructor initializer",
 							field.GetSignatureForError ());
 					} else {
 						ec.Report.Error (171, loc,
 							"Field `{0}' must be fully assigned before control leaves the constructor",
 							field.GetSignatureForError ());
 					}
 					ok = false;
 				}
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1479" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2623" endline="2638">
<![CDATA[
 		
 		bool AllTypesAreFixed (TypeSpec[] types)
 		{
 			foreach (TypeSpec t in types) {
 				if (t.IsGenericParameter) {
 					if (!IsFixed (t))
 						return false;
 					continue;
 				}
 
 				if (TypeManager.IsGenericType (t))
 					return AllTypesAreFixed (TypeManager.GetTypeArguments (t));
 			}
 			foreach (TypeSpec t in types) {
 				if (t.IsGenericParameter) {
 					if (!IsFixed (t))
 						return false;
 					continue;
 				}
 
 				if (TypeManager.IsGenericType (t))
 					return AllTypesAreFixed (TypeManager.GetTypeArguments (t));
 			}
 			
 			return true;
 		}		
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1891" endline="1914">
<![CDATA[
 
 		static bool HasDynamicArguments (TypeSpec[] args)
 		{
 			for (int i = 0; i < args.Length; ++i) {
 				var item = args[i];
 
 				if (item == InternalType.Dynamic)
 					return true;
 
 				if (TypeManager.IsGenericType (item))
 					return HasDynamicArguments (TypeManager.GetTypeArguments (item));
 
 				if (item.IsArray) {
 					while (item.IsArray) {
 						item = ((ArrayContainer) item).Element;
 					}
 					while (item.IsArray) {
 						item = ((ArrayContainer) item).Element;
 					}
 
 					if (item == InternalType.Dynamic)
 						return true;
 				}
 			}
 			for (int i = 0; i < args.Length; ++i) {
 				var item = args[i];
 
 				if (item == InternalType.Dynamic)
 					return true;
 
 				if (TypeManager.IsGenericType (item))
 					return HasDynamicArguments (TypeManager.GetTypeArguments (item));
 
 				if (item.IsArray) {
 					while (item.IsArray) {
 						item = ((ArrayContainer) item).Element;
 					}
 
 					if (item == InternalType.Dynamic)
 						return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1480" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" startline="53" endline="70">
<![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject)
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1245" endline="1274">
<![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As ULong) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Dim tmp As EmitInfo = Info
 
         'If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
         '    Helper.NotImplemented() 'Return EmitLoadValue(Info, CInt(Value))
         'ElseIf Value <= Long.MaxValue AndAlso Value >= Long.MinValue Then
         '    Return EmitLoadValue(Info, CLng(Value))
         'End If
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
             Case TypeCode.Int64, TypeCode.UInt64
                 EmitLoadI8Value(Info, Value)
                 Return True
         End Select
         Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1481" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="413" endline="428">
<![CDATA[
 
 		public void DefineManifestResource(string name, Stream stream, ResourceAttributes attribute)
 		{
 			ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
 			rec.Offset = manifestResources.Position;
 			rec.Flags = (int)attribute;
 			rec.Name = this.Strings.Add(name);
 			rec.Implementation = 0;
 			this.ManifestResource.AddRecord(rec);
 			manifestResources.Write(0);	// placeholder for the length
 			manifestResources.Write(stream);
 			int savePosition = manifestResources.Position;
 			manifestResources.Position = rec.Offset;
 			manifestResources.Write(savePosition - (manifestResources.Position + 4));
 			manifestResources.Position = savePosition;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="445" endline="465">
<![CDATA[
 		}
 
 		private void LazyParseArguments()
 		{
 			ByteReader br = module.GetBlob(module.CustomAttribute.records[index].Value);
 			if (br.Length == 0)
 			{
 				// it's legal to have an empty blob
 				lazyConstructorArguments = Empty<CustomAttributeTypedArgument>.Array;
 				lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
 			}
 			else
 			{
 				if (br.ReadUInt16() != 1)
 				{
 					throw new BadImageFormatException();
 				}
 				lazyConstructorArguments = ReadConstructorArguments(module.Assembly, br, Constructor);
 				lazyNamedArguments = ReadNamedArguments(module.Assembly, br, br.ReadUInt16(), Constructor.DeclaringType);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1482" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="264" endline="281">
<![CDATA[
 
     Function CreateImplicitMembers() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitMembers " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitMembers = TryCast(Type, IHasImplicitMembers)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitMembers AndAlso result
 
             result = CreateImplicitMembers(Type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" startline="187" endline="204">
<![CDATA[
 
     Function CreateImplicitTypes() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitTypes " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitTypes = TryCast(Type, IHasImplicitTypes)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitTypes AndAlso result
 
             result = CreateImplicitTypes(Type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1483" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" startline="102" endline="111">
<![CDATA[
 
     Private Function GenerateCodeForPreserve(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_ArrayType)) AndAlso result
         Emitter.EmitCastClass(Info, m_Expression.ExpressionType, Compiler.TypeCache.System_Array)
         result = GenerateCodeForNewArray(Info) AndAlso result
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Utils__CopyArray_Array_Array)
         Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Array, m_ArrayType)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="373" endline="393">
<![CDATA[
 
     Shared Sub EmitValueTypeToObjectConversion(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         'Dim FromType As Type = Info.Stack.Peek
         Dim FromTP, ToTP As TypeCode
 
         FromTP = Helper.GetTypeCode(Info.Compiler, FromType)
         ToTP = Helper.GetTypeCode(Info.Compiler, ToType)
 
         Helper.Assert(ToTP = TypeCode.Object)
 
         If CecilHelper.IsByRef(ToType) AndAlso Helper.CompareType(CecilHelper.GetElementType(ToType), FromType) Then
             Dim localvar As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, FromType)
             Emitter.EmitStoreVariable(Info, localvar)
             Emitter.EmitLoadVariableLocation(Info, localvar)
         ElseIf Helper.IsEnum(Info.Compiler, CecilHelper.FindDefinition(FromType).BaseType) AndAlso Helper.CompareType(ToType, Info.Compiler.TypeCache.System_Enum) Then
 
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1484" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1159" endline="1172">
<![CDATA[
 
     Public Shared Function FindConstructor(ByVal Methods As Mono.Collections.Generic.Collection(Of MethodDefinition), ByVal [Shared] As Boolean, ByVal parameters() As TypeReference) As MethodReference
         For i As Integer = 0 To Methods.Count - 1
             Dim mr As MethodDefinition = Methods(i)
 
             If mr.IsConstructor = False Then Continue For
             If mr.IsStatic Then
                 If [Shared] Then Return mr
                 Continue For
             End If
             If Helper.CompareTypes(Helper.GetParameterTypes(Compiler.CurrentCompiler, mr), parameters) Then Return mr
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" startline="176" endline="195">
<![CDATA[
 
     Overloads Function [GetType](ByVal Name As String, ByVal InList As IEnumerable, ByVal OnlyCreatedTypes As Boolean) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         For Each tp As Mono.Cecil.TypeReference In InList
             Dim tpD As Mono.Cecil.TypeDefinition = TryCast(tp, Mono.Cecil.TypeDefinition)
             If OnlyCreatedTypes AndAlso tpD Is Nothing Then Continue For
             If Helper.CompareName(tp.Name, Name) OrElse Helper.CompareName(tp.FullName, Name) Then
 #If EXTENDEDDEBUG Then
                 Compiler.Report.WriteLine("Found type
 #End If
                 result.Add(tp)
             Else
 #If EXTENDEDDEBUG Then
                 Compiler.Report.WriteLine("Discarded type
 #End If
             End If
             result.AddRange(Me.GetType(Name, CecilHelper.GetNestedTypes(tp), OnlyCreatedTypes))
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1485" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="45" endline="57">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim nullExp As New NothingConstantExpression(Me)
         result = nullExp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
         For i As Integer = 0 To m_Targets.Count - 1
             Dim exp As Expression = DirectCast(m_Targets.Item(i), Expression)
             result = exp.GenerateCode(Info.Clone(Me, nullExp)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="941" endline="979">
<![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As Expression()) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Length}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Length - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1486" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" startline="45" endline="57">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim nullExp As New NothingConstantExpression(Me)
         result = nullExp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
         For i As Integer = 0 To m_Targets.Count - 1
             Dim exp As Expression = DirectCast(m_Targets.Item(i), Expression)
             result = exp.GenerateCode(Info.Clone(Me, nullExp)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="128" endline="146">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
 
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Char, TypeCode.String
                     Return CStr(originalValue)
                 Case TypeCode.DBNull
                     Return DBNull.Value
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1487" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="519" endline="533">
<![CDATA[
 
     Sub RemoveNarrowingExceptObject()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowingExceptObject Then
                 Log("NARROWING (EXCEPT OBJECT)    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING (EXCEPT OBJECT)
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="534" endline="548">
<![CDATA[
 
     Sub RemoveNarrowing()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowing Then
                 Log("NARROWING    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1488" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="519" endline="533">
<![CDATA[
 
     Sub RemoveNarrowingExceptObject()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowingExceptObject Then
                 Log("NARROWING (EXCEPT OBJECT)    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING (EXCEPT OBJECT)
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="459" endline="473">
<![CDATA[
 
     Sub RemoveInaccessible()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsAccessible = False Then
                 Log("NOT ACCESSIBLE
                 m_Candidates(i) = Nothing
             Else
                 Log("ACCESSIBLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1489" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="519" endline="533">
<![CDATA[
 
     Sub RemoveNarrowingExceptObject()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowingExceptObject Then
                 Log("NARROWING (EXCEPT OBJECT)    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING (EXCEPT OBJECT)
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="504" endline="518">
<![CDATA[
 
     Sub RemoveInapplicable()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.DefineApplicability = False Then
                 Log("NOT APPLICABLE
                 m_Candidates(i) = Nothing
             Else
                 Log("APPLICABLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1490" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="519" endline="533">
<![CDATA[
 
     Sub RemoveNarrowingExceptObject()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowingExceptObject Then
                 Log("NARROWING (EXCEPT OBJECT)    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING (EXCEPT OBJECT)
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="474" endline="493">
<![CDATA[
 
     Sub InferTypeArguments()
         If m_TypeArguments IsNot Nothing AndAlso m_TypeArguments.Count > 0 Then
             Log("Type arguments specified, not inferring them")
             Return
         End If
 
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.InferTypeArguments = False Then
                 Log("TYPE INFERENCE FAILED
                 m_Candidates(i) = Nothing
             Else
                 Log("TYPE INFERENCE PASSED
             End If
         Next
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1491" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7161" endline="7178">
<![CDATA[
 
 		static bool ContainsDynamicType (TypeSpec type)
 		{
 			if (type == InternalType.Dynamic)
 				return true;
 
 			var element_container = type as ElementTypeSpec;
 			if (element_container != null)
 				return ContainsDynamicType (element_container.Element);
 
 			foreach (var t in type.TypeArguments) {
 				if (ContainsDynamicType (t)) {
 					return true;
 				}
 			}
 			foreach (var t in type.TypeArguments) {
 				if (ContainsDynamicType (t)) {
 					return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1400" endline="1420">
<![CDATA[
 		}
 
 		#endregion
 
 		public static bool ContainsTypeParameter (TypeSpec type)
 		{
 			if (type.Kind == MemberKind.TypeParameter)
 				return true;
 
 			var element_container = type as ElementTypeSpec;
 			if (element_container != null)
 				return ContainsTypeParameter (element_container.Element);
 
 			foreach (var t in type.TypeArguments) {
 				if (ContainsTypeParameter (t)) {
 					return true;
 				}
 			}
 			foreach (var t in type.TypeArguments) {
 				if (ContainsTypeParameter (t)) {
 					return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1492" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="496" endline="509">
<![CDATA[
 		}
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			bw.WriteLeb128 (ID);
 
 			bw.WriteLeb128 (captured_vars.Count);
 			foreach (CapturedVariable cv in captured_vars)
 				cv.Write (bw);
 			foreach (CapturedVariable cv in captured_vars)
 				cv.Write (bw);
 
 			bw.WriteLeb128 (captured_scopes.Count);
 			foreach (CapturedScope cs in captured_scopes)
 				cs.Write (bw);
 			foreach (CapturedScope cs in captured_scopes)
 				cs.Write (bw);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="581" endline="597">
<![CDATA[
 
 		internal void WriteData (MyBinaryWriter bw)
 		{
 			DataOffset = (int) bw.BaseStream.Position;
 			bw.WriteLeb128 (source.Index);
 
 			int count_includes = include_files != null ? include_files.Count 
 			bw.WriteLeb128 (count_includes);
 			if (include_files != null) {
 				foreach (SourceFileEntry entry in include_files)
 					bw.WriteLeb128 (entry.Index);
 				foreach (SourceFileEntry entry in include_files)
 					bw.WriteLeb128 (entry.Index);
 			}
 
 			bw.WriteLeb128 (namespaces.Count);
 			foreach (NamespaceEntry ns in namespaces)
 				ns.Write (file, bw);
 			foreach (NamespaceEntry ns in namespaces)
 				ns.Write (file, bw);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1493" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="496" endline="509">
<![CDATA[
 		}
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			bw.WriteLeb128 (ID);
 
 			bw.WriteLeb128 (captured_vars.Count);
 			foreach (CapturedVariable cv in captured_vars)
 				cv.Write (bw);
 			foreach (CapturedVariable cv in captured_vars)
 				cv.Write (bw);
 
 			bw.WriteLeb128 (captured_scopes.Count);
 			foreach (CapturedScope cs in captured_scopes)
 				cs.Write (bw);
 			foreach (CapturedScope cs in captured_scopes)
 				cs.Write (bw);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="225" endline="240">
<![CDATA[
 
 		public void WriteSymbolFile (Guid guid)
 		{
 			foreach (SourceMethodBuilder method in methods)
 				method.DefineMethod (file);
 			foreach (SourceMethodBuilder method in methods)
 				method.DefineMethod (file);
 
 			try {
 				// We mmap the file, so unlink the previous version since it may be in use
 				File.Delete (filename);
 			} catch {
 				// We can safely ignore
 			}
 			using (FileStream fs = new FileStream (filename, FileMode.Create, FileAccess.Write)) {
 				file.CreateSymbolFile (guid, fs);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1494" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="887" endline="903">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="670" endline="686">
<![CDATA[
 
 		public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
 		{
 			MethodInfo found = null;
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1495" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="887" endline="903">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="827" endline="843">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, Type returnType)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1496" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="549" endline="562">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             result = m_Variables(i).ResolveTypeReferences AndAlso result
         Next
 
         For i As Integer = 0 To m_Statements.Count - 1
             result = m_Statements(i).ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="563" endline="586">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             result = m_Variables(i).ResolveCode(Info) AndAlso result
         Next
 
         'We may add statements as we go.
         Dim counter As Integer = 0
         Dim count As Integer = m_Statements.Count
         While counter < m_Statements.Count
             Dim obj As Statement = m_Statements(counter)
             result = obj.ResolveStatement(Info) AndAlso result
             If count <> m_Statements.Count Then
             	'A statement has been added somewhere.
             	'Find the correct index of the current statement.
                 counter = m_Statements.IndexOf(obj)
             End If
             counter += 1
         End While
         While counter < m_Statements.Count
             Dim obj As Statement = m_Statements(counter)
             result = obj.ResolveStatement(Info) AndAlso result
             If count <> m_Statements.Count Then
             	'A statement has been added somewhere.
             	'Find the correct index of the current statement.
                 counter = m_Statements.IndexOf(obj)
             End If
             counter += 1
         End While
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1497" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="37" endline="45">
<![CDATA[
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If ThirdPart Is Nothing AndAlso TypeOf Condition Is NothingConstantExpression AndAlso TypeOf SecondPart Is NothingConstantExpression Then Return True
             If Not Condition.IsConstant Then Return False
             If Not SecondPart.IsConstant Then Return False
             If ThirdPart IsNot Nothing AndAlso Not ThirdPart.IsConstant Then Return False
             Return True
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="49" endline="71">
<![CDATA[
 
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.ResolveExpression(info) AndAlso result
             If result AndAlso m_Expression.Classification.IsValueClassification = False Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If result = False Then Return result
 
         If m_Expression IsNot Nothing Then
             Dim method As IMethod
             method = Me.FindFirstParent(Of IMethod)()
             m_Expression = Helper.CreateTypeConversion(Me, m_Expression, method.Signature.ReturnType, result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1498" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="185" endline="209">
<![CDATA[
 		
 		public Namespace GetNamespace (string name, bool create)
 		{
 			int pos = name.IndexOf ('.');
 
 			Namespace ns;
 			string first;
 			if (pos >= 0)
 				first = name.Substring (0, pos);
 			else
 				first = name;
 
 			if (!namespaces.TryGetValue (first, out ns)) {
 				if (!create)
 					return null;
 
 				ns = new Namespace (this, first);
 				namespaces.Add (first, ns);
 			}
 
 			if (pos >= 0)
 				ns = ns.GetNamespace (name.Substring (pos + 1), create);
 
 			return ns;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="246" endline="269">
<![CDATA[
 
 		static readonly char [] wsChars =
 			new char [] {' ', '\t', '\n', '\r'};
 
 		//
 		// returns a full runtime type name from a name which might
 		// be C# specific type name.
 		//
 		private static TypeSpec FindDocumentedType (MemberCore mc, string name, DeclSpace ds, string cref, Report r)
 		{
 			bool is_array = false;
 			string identifier = name;
 			if (name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				if (tmp [tmp.Length - 1] == '[') {
 					identifier = tmp.Substring (0, tmp.Length - 1).Trim (wsChars);
 					is_array = true;
 				}
 			}
 			TypeSpec t = FindDocumentedTypeNonArray (mc, identifier, ds, cref, r);
 			if (t != null && is_array)
 				t = ArrayContainer.MakeType (t);
 			return t;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1499" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" startline="83" endline="99">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             ElseIf TypeOf lvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             ElseIf TypeOf rvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             Else
                 Return CBool(lvalue) OrElse CBool(rvalue)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" startline="86" endline="102">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             ElseIf TypeOf lvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             ElseIf TypeOf rvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             Else
                 Return CBool(lvalue) AndAlso CBool(rvalue)
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1500" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="88" endline="101">
<![CDATA[
 
     Function SetElements() As Boolean
         Dim result As Boolean = True
         m_Elements = New Generic.List(Of Integer)
         If m_VariableInitializerList IsNot Nothing Then
             If m_VariableInitializerList.List.ToArray.Length > 0 Then
                 If m_VariableInitializerList.List.ToArray()(0).IsArrayElementInitializer Then
                     m_Elements.AddRange(m_VariableInitializerList.List.ToArray()(0).AsArrayElementInitializer.Elements)
                 End If
                 m_Elements.Insert(0, m_VariableInitializerList.List.ToArray.Length)
             End If
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" startline="233" endline="251">
<![CDATA[
 
     Private Function GetRegularInitializer(ByVal indices As Generic.List(Of Integer)) As Expression
         Dim ai As ArrayElementInitializer = Me
         Dim result As Expression
 
         Dim index As Integer
         For i As Integer = 0 To indices.Count - 2
             index = indices(i)
             Helper.Assert(ai.m_VariableInitializerList.List.ToArray.Length > index)
             Helper.Assert(ai.m_VariableInitializerList.List.ToArray()(index).IsArrayElementInitializer)
             ai = ai.m_VariableInitializerList.List.ToArray()(index).AsArrayElementInitializer
         Next
         index = indices(indices.Count - 1)
         Helper.Assert(ai.m_VariableInitializerList.List.ToArray.Length > index)
         Helper.Assert(ai.m_VariableInitializerList.List.ToArray()(index).IsRegularInitializer)
         result = ai.m_VariableInitializerList.List.ToArray()(index).AsRegularInitializer
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1501" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="227" endline="239">
<![CDATA[
 
     Protected Overloads Function [GetType](ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String) As Mono.Cecil.TypeDefinition
         If Type Is Nothing Then Return Nothing
         Dim result As Mono.Cecil.TypeDefinition = Nothing
         For Each item As Mono.Cecil.TypeDefinition In Type.NestedTypes
             If Helper.CompareNameOrdinal(item.Name, Name) Then
                 result = item
                 Exit For
             End If
         Next
         If result Is Nothing Then Compiler.Report.WriteLine(String.Format("Could not load the nested type '{0}' from the type '{1}'", Name, Type.FullName))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3688" endline="3712">
<![CDATA[
 
     ''' <summary>
     ''' Gets the parameters in the definition (not inflated)
     ''' </summary>
     ''' <param name="Member"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function GetOriginalParameters(ByVal Member As Mono.Cecil.MemberReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim mR As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If mR IsNot Nothing Then Return CecilHelper.FindDefinition(mR).Parameters
 
         Dim pR As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
         If pR IsNot Nothing Then Return CecilHelper.FindDefinition(pR).Parameters
 
         Dim tR As Mono.Cecil.TypeReference = TryCast(Member, Mono.Cecil.TypeReference)
         If tR IsNot Nothing Then Return Nothing
 
         Dim fR As Mono.Cecil.FieldReference = TryCast(Member, Mono.Cecil.FieldReference)
         If fR IsNot Nothing Then Return Nothing
 
         Dim eR As Mono.Cecil.EventReference = TryCast(Member, Mono.Cecil.EventReference)
         If eR IsNot Nothing Then Return CecilHelper.FindDefinition(eR).InvokeMethod.Parameters()
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1502" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="227" endline="239">
<![CDATA[
 
     Protected Overloads Function [GetType](ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String) As Mono.Cecil.TypeDefinition
         If Type Is Nothing Then Return Nothing
         Dim result As Mono.Cecil.TypeDefinition = Nothing
         For Each item As Mono.Cecil.TypeDefinition In Type.NestedTypes
             If Helper.CompareNameOrdinal(item.Name, Name) Then
                 result = item
                 Exit For
             End If
         Next
         If result Is Nothing Then Compiler.Report.WriteLine(String.Format("Could not load the nested type '{0}' from the type '{1}'", Name, Type.FullName))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3669" endline="3687">
<![CDATA[
 
     Overloads Shared Function GetParameters(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim mR As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If mR IsNot Nothing Then Return mR.ResolvedParameters
 
         Dim pR As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
         If pR IsNot Nothing Then Return CecilHelper.FindDefinition(pR).Parameters
 
         Dim tR As Mono.Cecil.TypeReference = TryCast(Member, Mono.Cecil.TypeReference)
         If tR IsNot Nothing Then Return Nothing
 
         Dim fR As Mono.Cecil.FieldReference = TryCast(Member, Mono.Cecil.FieldReference)
         If fR IsNot Nothing Then Return Nothing
 
         Dim eR As Mono.Cecil.EventReference = TryCast(Member, Mono.Cecil.EventReference)
         If eR IsNot Nothing Then Return CecilHelper.FindDefinition(eR).InvokeMethod.Parameters()
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1503" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2310" endline="2329">
<![CDATA[
 		
 		bool pp_and (ref string s)
 		{
 			bool va = pp_eq (ref s);
 
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				if (s [0] == '&'){
 					if (len > 2 && s [1] == '&'){
 						s = s.Substring (2);
 						return (va & pp_and (ref s));
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				} 
 			}
 			return va;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2262" endline="2282">
<![CDATA[
 		
 		bool pp_unary (ref string s)
 		{
 			s = s.Trim ();
 			int len = s.Length;
 
 			if (len > 0){
 				if (s [0] == '!'){
 					if (len > 1 && s [1] == '='){
 						Error_InvalidDirective ();
 						return false;
 					}
 					s = s.Substring (1);
 					return ! pp_primary (ref s);
 				} else
 					return pp_primary (ref s);
 			} else {
 				Error_InvalidDirective ();
 				return false;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1504" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="267" endline="292">
<![CDATA[
 
 		// <remarks>
 		//   This is used when we encounter a #line preprocessing directive.
 		// </remarks>
 		static public SourceFile LookupFile (CompilationUnit comp_unit, string name)
 		{
 			string path;
 			if (!Path.IsPathRooted (name)) {
 				string root = Path.GetDirectoryName (comp_unit.Path);
 				path = Path.Combine (root, name);
 			} else
 				path = name;
 
 			if (!source_files.ContainsKey (path)) {
 				if (source_count >= (1 << checkpoint_bits))
 					return new SourceFile (name, path, 0, true);
 
 				source_files.Add (path, ++source_count);
 				SourceFile retval = new SourceFile (name, path, source_count, true);
 				source_list.Add (retval);
 				return retval;
 			}
 
 			int index = (int) source_files [path];
 			return (SourceFile) source_list [index - 1];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="219" endline="240">
<![CDATA[
 
 		// <summary>
 		//   This must be called before parsing/tokenizing any files.
 		// </summary>
 		static public void AddFile (Report r, string name)
 		{
 			string path = Path.GetFullPath (name);
 			int id;
 			if (source_files.TryGetValue (path, out id)){
 				string other_name = source_list [id - 1].Name;
 				if (name.Equals (other_name))
 					r.Warning (2002, 1, "Source file `{0}' specified multiple times", other_name);
 				else
 					r.Warning (2002, 1, "Source filenames `{0}' and `{1}' both refer to the same file
 				return;
 			}
 
 			source_files.Add (path, ++source_count);
 			CompilationUnit unit = new CompilationUnit (name, path, source_count);
 			source_list.Add (unit);
 			compile_units.Add (unit);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1505" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3722" endline="4022">
<![CDATA[
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6066" endline="6155">
<![CDATA[
 
 		bool CheckIndices (ResolveContext ec, ArrayInitializer probe, int idx, bool specified_dims, int child_bounds)
 		{
 			if (initializers != null && bounds == null) {
 				//
 				// We use this to store all the date values in the order in which we
 				// will need to store them in the byte blob later
 				//
 				array_data = new List<Expression> ();
 				bounds = new Dictionary<int, int> ();
 			}
 
 			if (specified_dims) { 
 				Expression a = arguments [idx];
 				a = a.Resolve (ec);
 				if (a == null)
 					return false;
 
 				a = ConvertExpressionToArrayIndex (ec, a);
 				if (a == null)
 					return false;
 
 				arguments[idx] = a;
 
 				if (initializers != null) {
 					Constant c = a as Constant;
 					if (c == null && a is ArrayIndexCast)
 						c = ((ArrayIndexCast) a).Child as Constant;
 
 					if (c == null) {
 						ec.Report.Error (150, a.Location, "A constant value is expected");
 						return false;
 					}
 
 					int value;
 					try {
 						value = System.Convert.ToInt32 (c.GetValue ());
 					} catch {
 						ec.Report.Error (150, a.Location, "A constant value is expected");
 						return false;
 					}
 
 					// TODO
 					if (value != probe.Count) {
 						ec.Report.Error (847, loc, "An array initializer of length `{0}' was expected", value.ToString ());
 						return false;
 					}
 
 					bounds[idx] = value;
 				}
 			}
 
 			if (initializers == null)
 				return true;
 
 			for (int i = 0; i < probe.Count; ++i) {
 				var o = probe [i];
 				if (o is ArrayInitializer) {
 					var sub_probe = o as ArrayInitializer;
 					if (idx + 1 >= dimensions){
 						ec.Report.Error (623, loc, "Array initializers can only be used in a variable or field initializer. Try using a new expression instead");
 						return false;
 					}
 					
 					bool ret = CheckIndices (ec, sub_probe, idx + 1, specified_dims, child_bounds - 1);
 					if (!ret)
 						return false;
 				} else if (child_bounds > 1) {
 					ec.Report.Error (846, o.Location, "A nested array initializer was expected");
 				} else {
 					Expression element = ResolveArrayElement (ec, o);
 					if (element == null)
 						continue;
 
 					// Initializers with the default values can be ignored
 					Constant c = element as Constant;
 					if (c != null) {
 						if (!c.IsDefaultInitializer (array_element_type)) {
 							++const_initializers_count;
 						}
 					} else {
 						only_constant_initializers = false;
 					}
 					
 					array_data.Add (element);
 				}
 			}
 			for (int i = 0; i < probe.Count; ++i) {
 				var o = probe [i];
 				if (o is ArrayInitializer) {
 					var sub_probe = o as ArrayInitializer;
 					if (idx + 1 >= dimensions){
 						ec.Report.Error (623, loc, "Array initializers can only be used in a variable or field initializer. Try using a new expression instead");
 						return false;
 					}
 					
 					bool ret = CheckIndices (ec, sub_probe, idx + 1, specified_dims, child_bounds - 1);
 					if (!ret)
 						return false;
 				} else if (child_bounds > 1) {
 					ec.Report.Error (846, o.Location, "A nested array initializer was expected");
 				} else {
 					Expression element = ResolveArrayElement (ec, o);
 					if (element == null)
 						continue;
 
 					// Initializers with the default values can be ignored
 					Constant c = element as Constant;
 					if (c != null) {
 						if (!c.IsDefaultInitializer (array_element_type)) {
 							++const_initializers_count;
 						}
 					} else {
 						only_constant_initializers = false;
 					}
 					
 					array_data.Add (element);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1506" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3722" endline="4022">
<![CDATA[
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2291" endline="2435">
<![CDATA[
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			int lookup_arity = Arity;
 			bool errorMode = false;
 			Expression e;
 			Block current_block = rc.CurrentBlock;
 			INamedBlockVariable variable = null;
 			bool variable_found = false;
 
 			while (true) {
 				//
 				// Stage 1
 				//
 				// LAMESPEC
 				//
 				if (current_block != null && lookup_arity == 0) {
 					if (current_block.ParametersBlock.TopBlock.GetLocalName (Name, current_block.Original, ref variable)) {
 						if (!variable.IsDeclared) {
 							// We found local name in accessible block but it's not
 							// initialized yet, maybe the user wanted to bind to something else
 							errorMode = true;
 							variable_found = true;
 						} else {
 							e = variable.CreateReferenceExpression (rc, loc);
 							if (e != null) {
 								if (Arity > 0)
 									Error_TypeArgumentsCannotBeUsed (rc.Report, "variable", Name, loc);
 
 								return e;
 							}
 						}
 					}
 				}
 
 				//
 				// Stage 2
 				//
 				TypeSpec member_type = rc.CurrentType;
 				TypeSpec current_type = member_type;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				}
 
 				//
 				// Stage 3
 				//
 				if ((restrictions & MemberLookupRestrictions.InvocableOnly) == 0 && !variable_found) {
 					e = ResolveAsTypeStep (rc, lookup_arity == 0 || !errorMode);
 					if (e != null) {
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						return e;
 					}
 				}
 
 				if (errorMode) {
 					if (variable_found) {
 						rc.Report.Error (841, loc, "A local variable `{0}' cannot be used before it is declared", Name);
 					} else {
 						rc.Report.Error (103, loc, "The name `{0}' does not exist in the current context", Name);
 					}
 
 					return null;
 				}
 
 				if (RootContext.EvalMode) {
 					var fi = Evaluator.LookupField (Name);
 					if (fi != null)
 						return new FieldExpr (fi.Item1, loc);
 				}
 
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 			while (true) {
 				//
 				// Stage 1
 				//
 				// LAMESPEC
 				//
 				if (current_block != null && lookup_arity == 0) {
 					if (current_block.ParametersBlock.TopBlock.GetLocalName (Name, current_block.Original, ref variable)) {
 						if (!variable.IsDeclared) {
 							// We found local name in accessible block but it's not
 							// initialized yet, maybe the user wanted to bind to something else
 							errorMode = true;
 							variable_found = true;
 						} else {
 							e = variable.CreateReferenceExpression (rc, loc);
 							if (e != null) {
 								if (Arity > 0)
 									Error_TypeArgumentsCannotBeUsed (rc.Report, "variable", Name, loc);
 
 								return e;
 							}
 						}
 					}
 				}
 
 				//
 				// Stage 2
 				//
 				TypeSpec member_type = rc.CurrentType;
 				TypeSpec current_type = member_type;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				}
 
 				//
 				// Stage 3
 				//
 				if ((restrictions & MemberLookupRestrictions.InvocableOnly) == 0 && !variable_found) {
 					e = ResolveAsTypeStep (rc, lookup_arity == 0 || !errorMode);
 					if (e != null) {
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						return e;
 					}
 				}
 
 				if (errorMode) {
 					if (variable_found) {
 						rc.Report.Error (841, loc, "A local variable `{0}' cannot be used before it is declared", Name);
 					} else {
 						rc.Report.Error (103, loc, "The name `{0}' does not exist in the current context", Name);
 					}
 
 					return null;
 				}
 
 				if (RootContext.EvalMode) {
 					var fi = Evaluator.LookupField (Name);
 					if (fi != null)
 						return new FieldExpr (fi.Item1, loc);
 				}
 
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1507" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3611" endline="3639">
<![CDATA[
 
     Shared Function GetEventAttributes(ByVal [Event] As Mono.Cecil.EventReference) As Mono.Cecil.MethodAttributes
         Dim ev As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition([Event])
         Dim result As Mono.Cecil.MethodAttributes
         Dim getA, setA, raiseA As Mono.Cecil.MethodAttributes
         Dim getM, setM, raiseM As Mono.Cecil.MethodDefinition
 
         getM = ev.AddMethod
         setM = ev.RemoveMethod
         raiseM = ev.InvokeMethod
 
         Helper.Assert(getM IsNot Nothing OrElse setM IsNot Nothing OrElse raiseM IsNot Nothing)
 
         If getM IsNot Nothing Then
             getA = getM.Attributes
         End If
 
         If setM IsNot Nothing Then
             setA = setM.Attributes
         End If
 
         If raiseM IsNot Nothing Then
             raiseA = raiseM.Attributes
         End If
 
         result = setA Or getA Or raiseA
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3580" endline="3610">
<![CDATA[
 
     Shared Function GetPropertyAttributes(ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
         Dim getA, setA As Mono.Cecil.MethodAttributes
         Dim getM, setM As Mono.Cecil.MethodDefinition
         Dim prop As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition([Property])
 
         getM = CecilHelper.FindDefinition(prop.GetMethod)
         setM = CecilHelper.FindDefinition(prop.SetMethod)
 
         Helper.Assert(getM IsNot Nothing OrElse setM IsNot Nothing)
 
         If getM IsNot Nothing Then
             getA = getM.Attributes
         End If
 
         If setM IsNot Nothing Then
             setA = setM.Attributes
         End If
 
         result = setA Or getA
 
         Dim visibility As Mono.Cecil.MethodAttributes
         visibility = result And Mono.Cecil.MethodAttributes.MemberAccessMask
         If visibility = Mono.Cecil.MethodAttributes.MemberAccessMask Then
             visibility = Mono.Cecil.MethodAttributes.Public
             result = (result And (Not Mono.Cecil.MethodAttributes.MemberAccessMask)) Or visibility
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1508" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="67" endline="86">
<![CDATA[
 
 		internal static string Unescape(string name)
 		{
 			int pos = name.IndexOf('\\');
 			if (pos == -1)
 			{
 				return name;
 			}
 			StringBuilder sb = new StringBuilder(name, 0, pos, name.Length - 1);
 			for (; pos < name.Length; pos++)
 			{
 				char c = name[pos];
 				if (c == '\\')
 				{
 					c = name[++pos];
 				}
 				sb.Append(c);
 			}
 			for (; pos < name.Length; pos++)
 			{
 				char c = name[pos];
 				if (c == '\\')
 				{
 					c = name[++pos];
 				}
 				sb.Append(c);
 			}
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="634" endline="656">
<![CDATA[
 
 	public static string RemoveGenericArity (string name)
 	{
 		int start = 0;
 		StringBuilder sb = new StringBuilder ();
 		while (start < name.Length) {
 			int pos = name.IndexOf ('`', start);
 			if (pos < 0) {
 				sb.Append (name.Substring (start));
 				break;
 			}
 			sb.Append (name.Substring (start, pos-start));
 
 			pos++;
 
 			while ((pos < name.Length) && Char.IsNumber (name [pos]))
 				pos++;
 			while ((pos < name.Length) && Char.IsNumber (name [pos]))
 				pos++;
 
 			start = pos;
 		}
 		while (start < name.Length) {
 			int pos = name.IndexOf ('`', start);
 			if (pos < 0) {
 				sb.Append (name.Substring (start));
 				break;
 			}
 			sb.Append (name.Substring (start, pos-start));
 
 			pos++;
 
 			while ((pos < name.Length) && Char.IsNumber (name [pos]))
 				pos++;
 
 			start = pos;
 		}
 
 		return sb.ToString ();
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1509" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="67" endline="86">
<![CDATA[
 
 		internal static string Unescape(string name)
 		{
 			int pos = name.IndexOf('\\');
 			if (pos == -1)
 			{
 				return name;
 			}
 			StringBuilder sb = new StringBuilder(name, 0, pos, name.Length - 1);
 			for (; pos < name.Length; pos++)
 			{
 				char c = name[pos];
 				if (c == '\\')
 				{
 					c = name[++pos];
 				}
 				sb.Append(c);
 			}
 			for (; pos < name.Length; pos++)
 			{
 				char c = name[pos];
 				if (c == '\\')
 				{
 					c = name[++pos];
 				}
 				sb.Append(c);
 			}
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="43" endline="66">
<![CDATA[
 		{
 			if (name == null)
 			{
 				return null;
 			}
 			StringBuilder sb = null;
 			for (int pos = 0; pos < name.Length; pos++)
 			{
 				char c = name[pos];
 				if (SpecialChars.IndexOf(c) != -1)
 				{
 					if (sb == null)
 					{
 						sb = new StringBuilder(name, 0, pos, name.Length + 3);
 					}
 					sb.Append('\\').Append(c);
 				}
 				else if (sb != null)
 				{
 					sb.Append(c);
 				}
 			}
 			for (int pos = 0; pos < name.Length; pos++)
 			{
 				char c = name[pos];
 				if (SpecialChars.IndexOf(c) != -1)
 				{
 					if (sb == null)
 					{
 						sb = new StringBuilder(name, 0, pos, name.Length + 3);
 					}
 					sb.Append('\\').Append(c);
 				}
 				else if (sb != null)
 				{
 					sb.Append(c);
 				}
 			}
 			return sb != null ? sb.ToString() 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1510" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="594" endline="610">
<![CDATA[
 
 		private static bool IsInheritableAttribute(Type attribute)
 		{
 			Type attributeUsageAttribute = attribute.Module.universe.System_AttributeUsageAttribute;
 			IList<CustomAttributeData> attr = attribute.GetCustomAttributesData(attributeUsageAttribute);
 			if (attr.Count != 0)
 			{
 				foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
 				{
 					if (named.MemberInfo.Name == "Inherited")
 					{
 						return (bool)named.TypedValue.Value;
 					}
 				}
 				foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
 				{
 					if (named.MemberInfo.Name == "Inherited")
 					{
 						return (bool)named.TypedValue.Value;
 					}
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1497" endline="1514">
<![CDATA[
 
 		internal bool IsAllowMultipleCustomAttribute
 		{
 			get
 			{
 				IList<CustomAttributeData> cad = GetCustomAttributesData(this.Module.universe.System_AttributeUsageAttribute);
 				if (cad.Count == 1)
 				{
 					foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
 					{
 						if (arg.MemberInfo.Name == "AllowMultiple")
 						{
 							return (bool)arg.TypedValue.Value;
 						}
 					}
 					foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
 					{
 						if (arg.MemberInfo.Name == "AllowMultiple")
 						{
 							return (bool)arg.TypedValue.Value;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1511" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1033" endline="1069">
<![CDATA[
 		}
 
 		[Flags]
 		public enum Flags
 		{
 			LocalNamesAmbiguous	= 1
 		}
 
 		public const int Size = 12;
 
 		internal MethodEntry (MonoSymbolFile file, MyBinaryReader reader, int index)
 		{
 			this.SymbolFile = file;
 			this.index = index;
 
 			Token = reader.ReadInt32 ();
 			DataOffset = reader.ReadInt32 ();
 			LineNumberTableOffset = reader.ReadInt32 ();
 
 			long old_pos = reader.BaseStream.Position;
 			reader.BaseStream.Position = DataOffset;
 
 			CompileUnitIndex = reader.ReadLeb128 ();
 			LocalVariableTableOffset = reader.ReadLeb128 ();
 			NamespaceID = reader.ReadLeb128 ();
 
 			CodeBlockTableOffset = reader.ReadLeb128 ();
 			ScopeVariableTableOffset = reader.ReadLeb128 ();
 
 			RealNameOffset = reader.ReadLeb128 ();
 
 			flags = (Flags) reader.ReadLeb128 ();
 
 			reader.BaseStream.Position = old_pos;
 
 			CompileUnit = file.GetCompileUnit (CompileUnitIndex);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="106" endline="116">
<![CDATA[
 		public int LineNumberTable_LineBase = LineNumberTable.Default_LineBase;
 		public int LineNumberTable_LineRange = LineNumberTable.Default_LineRange;
 		public int LineNumberTable_OpcodeBase = LineNumberTable.Default_OpcodeBase;
 		#endregion
 
 		internal OffsetTable ()
 		{
 			int platform = (int) Environment.OSVersion.Platform;
 			if ((platform != 4) && (platform != 128))
 				FileFlags |= Flags.WindowsFileNames;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1512" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="361" endline="378">
<![CDATA[
 
 		public void EndExceptionBlock()
 		{
 			ExceptionBlock block = exceptionStack.Pop();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				if (block.filterOffset != 0 || (block.exceptionType != null && block.exceptionType != FAULT))
 				{
 					Emit(OpCodes.Leave, block.labelEnd);
 				}
 				else
 				{
 					Emit(OpCodes.Endfinally);
 				}
 			}
 			MarkLabel(block.labelEnd);
 			block.handlerLength = code.Position - block.handlerOffset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="205" endline="225">
<![CDATA[
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if ((addOnMethod != null && addOnMethod.IsPublic) || (removeOnMethod != null && removeOnMethod.IsPublic) || (fireMethod != null && fireMethod.IsPublic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1513" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="361" endline="378">
<![CDATA[
 
 		public void EndExceptionBlock()
 		{
 			ExceptionBlock block = exceptionStack.Pop();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				if (block.filterOffset != 0 || (block.exceptionType != null && block.exceptionType != FAULT))
 				{
 					Emit(OpCodes.Leave, block.labelEnd);
 				}
 				else
 				{
 					Emit(OpCodes.Endfinally);
 				}
 			}
 			MarkLabel(block.labelEnd);
 			block.handlerLength = code.Position - block.handlerOffset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="226" endline="247">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if ((addOnMethod != null && addOnMethod.IsStatic) || (removeOnMethod != null && removeOnMethod.IsStatic) || (fireMethod != null && fireMethod.IsStatic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1514" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1515" endline="1536">
<![CDATA[
 		}
 
 		internal bool IsPseudoCustomAttribute
 		{
 			get
 			{
 				Universe u = this.Module.universe;
 				return this == u.System_NonSerializedAttribute
 					|| this == u.System_SerializableAttribute
 					|| this == u.System_Runtime_InteropServices_DllImportAttribute
 					|| this == u.System_Runtime_InteropServices_FieldOffsetAttribute
 					|| this == u.System_Runtime_InteropServices_InAttribute
 					|| this == u.System_Runtime_InteropServices_MarshalAsAttribute
 					|| this == u.System_Runtime_InteropServices_OutAttribute
 					|| this == u.System_Runtime_InteropServices_StructLayoutAttribute
 					|| this == u.System_Runtime_InteropServices_OptionalAttribute
 					|| this == u.System_Runtime_InteropServices_PreserveSigAttribute
 					|| this == u.System_Runtime_InteropServices_ComImportAttribute
 					|| this == u.System_Runtime_CompilerServices_SpecialNameAttribute
 					|| this == u.System_Runtime_CompilerServices_MethodImplAttribute
 					;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="942" endline="964">
<![CDATA[
 		}
 
 		public bool IsPrimitive
 		{
 			get
 			{
 				Universe u = this.Module.universe;
 				return this == u.System_Boolean
 					|| this == u.System_Byte
 					|| this == u.System_SByte
 					|| this == u.System_Int16
 					|| this == u.System_UInt16
 					|| this == u.System_Int32
 					|| this == u.System_UInt32
 					|| this == u.System_Int64
 					|| this == u.System_UInt64
 					|| this == u.System_IntPtr
 					|| this == u.System_UIntPtr
 					|| this == u.System_Char
 					|| this == u.System_Double
 					|| this == u.System_Single
 					;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1515" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1070" endline="1093">
<![CDATA[
 
 		Namespace [] GetUsingTable ()
 		{
 			if (namespace_using_table != null)
 				return namespace_using_table;
 
 			if (using_clauses == null) {
 				namespace_using_table = empty_namespaces;
 				return namespace_using_table;
 			}
 
 			var list = new List<Namespace> (using_clauses.Count);
 
 			foreach (UsingEntry ue in using_clauses) {
 				Namespace using_ns = ue.Resolve (Doppelganger);
 				if (using_ns == null)
 					continue;
 
 				list.Add (using_ns);
 			}
 			foreach (UsingEntry ue in using_clauses) {
 				Namespace using_ns = ue.Resolve (Doppelganger);
 				if (using_ns == null)
 					continue;
 
 				list.Add (using_ns);
 			}
 
 			namespace_using_table = list.ToArray ();
 			return namespace_using_table;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="710" endline="730">
<![CDATA[
 
 		//
 		// Populates the Namespace with some using declarations, used by the
 		// eval mode. 
 		//
 		public void Populate (List<UsingAliasEntry> source_using_aliases, List<UsingEntry> source_using_clauses)
 		{
 			foreach (UsingAliasEntry uae in source_using_aliases){
 				if (using_aliases == null)
 					using_aliases = new List<UsingAliasEntry> ();
 				
 				using_aliases.Add (uae);
 			}
 			foreach (UsingAliasEntry uae in source_using_aliases){
 				if (using_aliases == null)
 					using_aliases = new List<UsingAliasEntry> ();
 				
 				using_aliases.Add (uae);
 			}
 
 			foreach (UsingEntry ue in source_using_clauses){
 				if (using_clauses == null)
 					using_clauses = new List<UsingEntry> ();
 				
 				using_clauses.Add (ue);
 			}
 			foreach (UsingEntry ue in source_using_clauses){
 				if (using_clauses == null)
 					using_clauses = new List<UsingEntry> ();
 				
 				using_clauses.Add (ue);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1516" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="415" endline="443">
<![CDATA[
 
 		//
 		// Optimized default assembly loader version
 		//
 		public override Assembly LoadAssemblyDefault (string assembly)
 		{
 			foreach (var path in paths) {
 				var file = Path.Combine (path, assembly);
 				if (!File.Exists (file))
 					continue;
 
 				try {
 					if (Report.DebugFlags > 0)
 						Console.WriteLine ("Loading default assembly `{0}'", file);
 
 					var a = domain.LoadFile (file);
 					if (a != null) {
 						loaded_names.Add (Tuple.Create (a.GetName (), assembly));
 					}
 
 					return a;
 				} catch {
 					// Default assemblies can fail to load without error
 					return null;
 			foreach (var path in paths) {
 				var file = Path.Combine (path, assembly);
 				if (!File.Exists (file))
 					continue;
 
 				try {
 					if (Report.DebugFlags > 0)
 						Console.WriteLine ("Loading default assembly `{0}'", file);
 
 					var a = domain.LoadFile (file);
 					if (a != null) {
 						loaded_names.Add (Tuple.Create (a.GetName (), assembly));
 					}
 
 					return a;
 				} catch {
 					// Default assemblies can fail to load without error
 					return null;
 				}
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="390" endline="414">
<![CDATA[
 
 		public RawModule LoadModuleFile (string moduleName)
 		{
 			foreach (var path in paths) {
 				var file = Path.Combine (path, moduleName);
 				if (!File.Exists (file)) {
 					if (moduleName.EndsWith (".netmodule", StringComparison.Ordinal))
 						continue;
 
 					file += ".netmodule";
 					if (!File.Exists (file))
 						continue;
 				}
 
 				try {
 					return domain.OpenRawModule (file);
 				} catch {
 					Error_FileCorrupted (file);
 					return null;
 			foreach (var path in paths) {
 				var file = Path.Combine (path, moduleName);
 				if (!File.Exists (file)) {
 					if (moduleName.EndsWith (".netmodule", StringComparison.Ordinal))
 						continue;
 
 					file += ".netmodule";
 					if (!File.Exists (file))
 						continue;
 				}
 
 				try {
 					return domain.OpenRawModule (file);
 				} catch {
 					Error_FileCorrupted (file);
 					return null;
 				}
 			}
 
 			Error_FileNotFound (moduleName);
 			return null;				
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1517" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="230" endline="250">
<![CDATA[
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if ((getter != null && getter.IsPublic) || (setter != null && setter.IsPublic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="251" endline="272">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if ((getter != null && getter.IsStatic) || (setter != null && setter.IsStatic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1518" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="136" endline="158">
<![CDATA[
 
     Function RuleUnaryNegation(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Minus) Then
             NextToken()
             RuleUnaryNegation = RuleExponent(LSide)
 
             Dim op1 As Double
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 LSide = 0
             Else
                 LSide = -op1
             End If
         Else
             If RuleExponent(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="424" endline="446">
<![CDATA[
 
     Function RuleNot(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Not) Then
             NextToken()
             RuleNot = RuleRelational(LSide)
 
             Dim op1 As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 LSide = 0
             Else
                 LSide = Not op1
             End If
         Else
             If RuleRelational(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1519" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="851" endline="874">
<![CDATA[
 
 		public void AddUsingExternalAlias (string alias, Location loc, Report Report)
 		{
 			// TODO
 			bool not_first = using_clauses != null || DeclarationFound;
 			if (using_aliases != null && !not_first) {
 				foreach (UsingAliasEntry uae in using_aliases) {
 					if (uae is LocalUsingAliasEntry) {
 						not_first = true;
 						break;
 					}
 				}
 				foreach (UsingAliasEntry uae in using_aliases) {
 					if (uae is LocalUsingAliasEntry) {
 						not_first = true;
 						break;
 					}
 				}
 			}
 
 			if (not_first)
 				Report.Error (439, loc, "An extern alias declaration must precede all other elements");
 
 			if (alias == "global") {
 				Error_GlobalNamespaceRedefined (loc, Report);
 				return;
 			}
 
 			AddUsingAlias (new UsingAliasEntry (alias, loc));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1588" endline="1623">
<![CDATA[
 		
 		protected virtual void ComputeIndexerName ()
 		{
 			if (indexers == null)
 				return;
 
 			string class_indexer_name = null;
 
 			//
 			// If there's both an explicit and an implicit interface implementation, the
 			// explicit one actually implements the interface while the other one is just
 			// a normal indexer.  See bug #37714.
 			//
 
 			// Invariant maintained by AddIndexer()
 			foreach (Indexer i in indexers) {
 				if (i.InterfaceType != null) {
 					if (seen_normal_indexers)
 						throw new Exception ("Internal Error
 					continue;
 				}
 
 				seen_normal_indexers = true;
 
 				if (class_indexer_name == null) {
 					class_indexer_name = i.ShortName;
 					continue;
 				}
 
 				if (i.ShortName != class_indexer_name)
 					Report.Error (668, i.Location, "Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type");
 			}
 			foreach (Indexer i in indexers) {
 				if (i.InterfaceType != null) {
 					if (seen_normal_indexers)
 						throw new Exception ("Internal Error
 					continue;
 				}
 
 				seen_normal_indexers = true;
 
 				if (class_indexer_name == null) {
 					class_indexer_name = i.ShortName;
 					continue;
 				}
 
 				if (i.ShortName != class_indexer_name)
 					Report.Error (668, i.Location, "Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type");
 			}
 
 			if (class_indexer_name != null)
 				indexer_name = class_indexer_name;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1520" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8050" endline="8079">
<![CDATA[
 
 		//
 		// We perform some simple tests, and then to "split" the emit and store
 		// code we create an instance of a different class, and return that.
 		//
 		Expression CreateAccessExpression (ResolveContext ec)
 		{
 			if (type.IsArray)
 				return (new ArrayAccess (this, loc));
 
 			if (type.IsPointer)
 				return MakePointerAccess (ec, type);
 
 			FieldExpr fe = Expr as FieldExpr;
 			if (fe != null) {
 				var ff = fe.Spec as FixedFieldSpec;
 				if (ff != null) {
 					return MakePointerAccess (ec, ff.ElementType);
 				}
 			}
 
 			var indexers = MemberCache.FindMembers (type, MemberCache.IndexerNameAlias, false);
 			if (indexers != null || type == InternalType.Dynamic) {
 				return new IndexerExpr (indexers, type, this);
 			}
 
 			ec.Report.Error (21, loc, "Cannot apply indexing with [] to an expression of type `{0}'",
 				type.GetSignatureForError ());
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1521" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2097" endline="2119">
<![CDATA[
 #endif
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Block target = (Block) t;
 #if DEBUG
 			target.clone_id = clone_id_counter++;
 #endif
 
 			clonectx.AddBlockMap (this, target);
 			if (original != this)
 				clonectx.AddBlockMap (original, target);
 
 			target.ParametersBlock = (ParametersBlock) (ParametersBlock == this ? target 
 			target.Explicit = (ExplicitBlock) (Explicit == this ? target 
 
 			if (Parent != null)
 				target.Parent = clonectx.RemapBlockCopy (Parent);
 
 			target.statements = new List<Statement> (statements.Count);
 			foreach (Statement s in statements)
 				target.statements.Add (s.Clone (clonectx));
 			foreach (Statement s in statements)
 				target.statements.Add (s.Clone (clonectx));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1522" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1032" endline="1056">
<![CDATA[
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (left is NullLiteral)
 				ec.Report.Error (845, loc, "An expression tree cannot contain a coalescing operator with null left side");
 
 			UserCast uc = left as UserCast;
 			Expression conversion = null;
 			if (uc != null) {
 				left = uc.Source;
 
 				Arguments c_args = new Arguments (2);
 				c_args.Add (new Argument (uc.CreateExpressionTree (ec)));
 				c_args.Add (new Argument (left.CreateExpressionTree (ec)));
 				conversion = CreateExpressionFactoryCall (ec, "Lambda", c_args);
 			}
 
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (left.CreateExpressionTree (ec)));
 			args.Add (new Argument (right.CreateExpressionTree (ec)));
 			if (conversion != null)
 				args.Add (new Argument (conversion));
 			
 			return CreateExpressionFactoryCall (ec, "Coalesce", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1523" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="457" endline="484">
<![CDATA[
 
 		void Define_Current (bool is_generic)
 		{
 			TypeExpr type;
 
 			MemberName name = new MemberName (QualifiedAliasMember.GlobalAlias, "System", null, Location);
 			name = new MemberName (name, "Collections", Location);
 
 			if (is_generic) {
 				name = new MemberName (name, "Generic", Location);
 				name = new MemberName (name, "IEnumerator", generic_args, Location);
 				type = iterator_type_expr;
 			} else {
 				name = new MemberName (name, "IEnumerator");
 				type = new TypeExpression (TypeManager.object_type, Location);
 			}
 
 			name = new MemberName (name, "Current", Location);
 
 			ToplevelBlock get_block = new ToplevelBlock (Compiler, Location);
 			get_block.AddStatement (new Return (new DynamicFieldExpr (CurrentField, Location), Location));
 				
 			Property current = new Property (this, type, Modifiers.DEBUGGER_HIDDEN, name, null);
 			current.Get = new Property.GetMethod (current, 0, null, Location);
 			current.Get.Block = get_block;
 
 			AddProperty (current);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1524" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5611" endline="5644">
<![CDATA[
 		}
 
 		#endregion
 
 		public override MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			//
 			// If the event is local to this class and we are not lhs of +=/-= we transform ourselves into a FieldExpr
 			//
 			if (!ec.HasSet (ResolveContext.Options.CompoundAssignmentScope)) {
 				if (spec.BackingField != null &&
 					(spec.DeclaringType == ec.CurrentType || TypeManager.IsNestedChildOf (ec.CurrentType, spec.DeclaringType.MemberDefinition))) {
 
 					spec.MemberDefinition.SetIsUsed ();
 
 					if (!ec.IsObsolete) {
 						ObsoleteAttribute oa = spec.GetAttributeObsolete ();
 						if (oa != null)
 							AttributeTester.Report_ObsoleteMessage (oa, spec.GetSignatureForError (), loc, ec.Report);
 					}
 
 					if ((spec.Modifiers & (Modifiers.ABSTRACT | Modifiers.EXTERN)) != 0)
 						Error_AssignmentEventOnly (ec);
 
 					FieldExpr ml = new FieldExpr (spec.BackingField, loc);
 
 					InstanceExpression = null;
 
 					return ml.ResolveMemberAccess (ec, left, original);
 				}
 			}
 
 			return base.ResolveMemberAccess (ec, left, original);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1525" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="268" endline="297">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 
 			bool was_unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!EmbeddedStatement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			if (ec.CurrentBranching.CurrentUsageVector.IsUnreachable && !was_unreachable)
 				ec.Report.Warning (162, 2, expr.Location, "Unreachable code detected");
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				ok = false;
 			else if (expr is Constant){
 				bool infinite = !((Constant) expr).IsDefaultValue;
 				if (infinite)
 					ec.CurrentBranching.CurrentUsageVector.Goto ();
 			}
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1526" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="448" endline="471">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			MemberAccess ma = new MemberAccess (new MemberAccess (new QualifiedAliasMember ("global", "System", loc), "Delegate", loc), "CreateDelegate", loc);
 
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			if (method_group.InstanceExpression == null)
 				args.Add (new Argument (new NullLiteral (loc)));
 			else
 				args.Add (new Argument (method_group.InstanceExpression));
 
 			args.Add (new Argument (method_group.CreateExpressionTree (ec)));
 			Expression e = new Invocation (ma, args).Resolve (ec);
 			if (e == null)
 				return null;
 
 			e = Convert.ExplicitConversion (ec, e, type, loc);
 			if (e == null)
 				return null;
 
 			return e.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1527" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="597" endline="635">
<![CDATA[
 
 		protected override void CreateArguments (ResolveContext ec, Parameter parameter, ref Arguments args)
 		{
 			if (args == null) {
 				if (IdentifierType != null)
 					expr = CreateCastExpression (expr);
 
 				base.CreateArguments (ec, parameter.Clone (), ref args);
 			}
 
 			Expression result_selector_expr;
 			QueryBlock result_block;
 
 			var target = GetIntoVariable ();
 			var target_param = new ImplicitLambdaParameter (target.Name, target.Location);
 
 			//
 			// When select follows use it as a result selector
 			//
 			if (next is Select) {
 				result_selector_expr = next.Expr;
 
 				result_block = next.block;
 				result_block.SetParameters (parameter, target_param);
 
 				next = next.next;
 			} else {
 				result_selector_expr = CreateRangeVariableType (ec, parameter, target, new SimpleName (target.Name, target.Location));
 
 				result_block = new QueryBlock (ec.Compiler, block.Parent, block.StartLocation);
 				result_block.SetParameters (parameter, target_param);
 			}
 
 			LambdaExpression result_selector = new LambdaExpression (Location);
 			result_selector.Block = result_block;
 			result_selector.Block.AddStatement (new ContextualReturn (result_selector_expr));
 
 			args.Add (new Argument (result_selector));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1528" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="592" endline="623">
<![CDATA[
 
 		protected override Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			//
 			// Indexer has arguments which complicates things as the setter and getter
 			// are called in two steps when unary mutator is used. We have to make a
 			// copy of all variable arguments to not duplicate any side effect.
 			//
 			// ++d[++arg, Foo ()]
 			//
 
 			if (!can_be_mutator)
 				return base.CreateSetterArguments (rc, rhs);
 
 			var setter_args = new Arguments (Arguments.Count + 1);
 			for (int i = 0; i < Arguments.Count; ++i) {
 				var expr = Arguments[i].Expr;
 
 				if (expr is Constant || expr is VariableReference || expr is This) {
 					setter_args.Add (Arguments [i]);
 					continue;
 				}
 
 				LocalVariable temp = LocalVariable.CreateCompilerGenerated (expr.Type, rc.CurrentBlock, loc);
 				expr = new SimpleAssign (temp.CreateReferenceExpression (rc, expr.Location), expr).Resolve (rc);
 				Arguments[i].Expr = temp.CreateReferenceExpression (rc, expr.Location).Resolve (rc);
 				setter_args.Add (Arguments [i].Clone (expr));
 			}
 			for (int i = 0; i < Arguments.Count; ++i) {
 				var expr = Arguments[i].Expr;
 
 				if (expr is Constant || expr is VariableReference || expr is This) {
 					setter_args.Add (Arguments [i]);
 					continue;
 				}
 
 				LocalVariable temp = LocalVariable.CreateCompilerGenerated (expr.Type, rc.CurrentBlock, loc);
 				expr = new SimpleAssign (temp.CreateReferenceExpression (rc, expr.Location), expr).Resolve (rc);
 				Arguments[i].Expr = temp.CreateReferenceExpression (rc, expr.Location).Resolve (rc);
 				setter_args.Add (Arguments [i].Clone (expr));
 			}
 
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1529" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4025" endline="4057">
<![CDATA[
 
 		//
 		// Creates nested calls tree from an array of arguments used for IL emit
 		//
 		Expression CreateExpressionAddCall (ResolveContext ec, Argument left, Expression left_etree, int pos)
 		{
 			Arguments concat_args = new Arguments (2);
 			Arguments add_args = new Arguments (3);
 
 			concat_args.Add (left);
 			add_args.Add (new Argument (left_etree));
 
 			concat_args.Add (arguments [pos]);
 			add_args.Add (new Argument (arguments [pos].CreateExpressionTree (ec)));
 
 			var methods = CreateConcatMethodCandidates ();
 			if (methods == null)
 				return null;
 
 			var res = new OverloadResolver (methods, OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var method = res.ResolveMember<MethodSpec> (ec, ref concat_args);
 			if (method == null)
 				return null;
 
 			add_args.Add (new Argument (new TypeOfMethod (method, loc)));
 
 			Expression expr = CreateExpressionFactoryCall (ec, "Add", add_args);
 			if (++pos == arguments.Count)
 				return expr;
 
 			left = new Argument (new EmptyExpression (method.ReturnType));
 			return CreateExpressionAddCall (ec, left, expr, pos);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1530" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3870" endline="3891">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			MemberAccess sle = new MemberAccess (new MemberAccess (
 				new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Linq", loc), "Expressions", loc);
 
 			CSharpBinderFlags flags = 0;
 			if (ec.HasSet (ResolveContext.Options.CheckedScope))
 				flags = CSharpBinderFlags.CheckedContext;
 
 			if ((oper & Operator.LogicalMask) != 0)
 				flags |= CSharpBinderFlags.BinaryOperationLogical;
 
 			binder_args.Add (new Argument (new EnumConstant (new IntLiteral ((int) flags, loc), ec.Module.PredefinedTypes.BinderFlags.Resolve (loc))));
 			binder_args.Add (new Argument (new MemberAccess (new MemberAccess (sle, "ExpressionType", loc), GetOperatorExpressionTypeName (), loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));									
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			return new Invocation (new MemberAccess (new TypeExpression (ec.Module.PredefinedTypes.Binder.TypeSpec, loc), "BinaryOperation", loc), binder_args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1531" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7301" endline="7327">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			bool is_generic = member.DeclaringType.IsGenericOrParentIsGeneric;
 			var mi = is_generic ? TypeFromHandleGeneric 
 
 			if (mi == null) {
 				TypeSpec declaring_type = GetDeclaringType (ec.Module.PredefinedTypes).Resolve (loc);
 				TypeSpec handle_type = GetRuntimeHandle (ec.Module.PredefinedTypes).Resolve (loc);
 
 				if (handle_type == null || declaring_type == null)
 					return null;
 
 				mi = TypeManager.GetPredefinedMethod (declaring_type, GetMethodName, loc,
 					is_generic ?
 					new TypeSpec[] { handle_type, TypeManager.runtime_handle_type } 
 					new TypeSpec[] { handle_type } );
 
 				if (is_generic)
 					TypeFromHandleGeneric = mi;
 				else
 					TypeFromHandle = mi;
 			}
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1532" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="549" endline="575">
<![CDATA[
 
 		void Error_ConversionFailed (ResolveContext ec, MethodSpec method, Expression return_type)
 		{
 			var invoke_method = Delegate.GetInvokeMethod (ec.Compiler, type);
 			string member_name = method_group.InstanceExpression != null ?
 				Delegate.FullDelegateDesc (method) 
 				TypeManager.GetFullNameSignature (method);
 
 			ec.Report.SymbolRelatedToPreviousError (type);
 			ec.Report.SymbolRelatedToPreviousError (method);
 			if (RootContext.Version == LanguageVersion.ISO_1) {
 				ec.Report.Error (410, loc, "A method or delegate `{0} {1}' parameters and return type must be same as delegate `{2} {3}' parameters and return type",
 					TypeManager.CSharpName (method.ReturnType), member_name,
 					TypeManager.CSharpName (invoke_method.ReturnType), Delegate.FullDelegateDesc (invoke_method));
 				return;
 			}
 
 			if (return_type == null) {
 				ec.Report.Error (123, loc, "A method or delegate `{0}' parameters do not match delegate `{1}' parameters",
 					member_name, Delegate.FullDelegateDesc (invoke_method));
 				return;
 			}
 
 			ec.Report.Error (407, loc, "A method or delegate `{0} {1}' return type does not match delegate `{2} {3}' return type",
 				return_type.GetSignatureForError (), member_name,
 				TypeManager.CSharpName (invoke_method.ReturnType), Delegate.FullDelegateDesc (invoke_method));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1533" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8187" endline="8217">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			// dynamic is used per argument in ConvertExpressionToArrayIndex case
 			bool dynamic;
 			ea.Arguments.Resolve (ec, out dynamic);
 
 			var ac = ea.Expr.Type as ArrayContainer;
 			int rank = ea.Arguments.Count;
 			if (ac.Rank != rank) {
 				ec.Report.Error (22, ea.Location, "Wrong number of indexes `{0}' inside [], expected `{1}'",
 					  rank.ToString (), ac.Rank.ToString ());
 				return null;
 			}
 
 			type = ac.Element;
 			if (type.IsPointer && !ec.IsUnsafe) {
 				UnsafeError (ec, ea.Location);
 			}
 
 			foreach (Argument a in ea.Arguments) {
 				if (a is NamedArgument)
 					ElementAccess.Error_NamedArgument ((NamedArgument) a, ec.Report);
 
 				a.Expr = ConvertExpressionToArrayIndex (ec, a.Expr);
 			}
 			foreach (Argument a in ea.Arguments) {
 				if (a is NamedArgument)
 					ElementAccess.Error_NamedArgument ((NamedArgument) a, ec.Report);
 
 				a.Expr = ConvertExpressionToArrayIndex (ec, a.Expr);
 			}
 			
 			eclass = ExprClass.Variable;
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1534" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5714" endline="5742">
<![CDATA[
 		}
 
 		public override bool Resolve (BlockContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
 			if (expr.IsNull) {
 				ec.Report.Error (186, loc, "Use of null is not valid in this context");
 				return false;
 			}
 
 			if (expr.Type == TypeManager.string_type) {
 				statement = new ArrayForeach (this, 1);
 			} else if (expr.Type is ArrayContainer) {
 				statement = new ArrayForeach (this, ((ArrayContainer) expr.Type).Rank);
 			} else {
 				if (expr.eclass == ExprClass.MethodGroup || expr is AnonymousMethodExpression) {
 					ec.Report.Error (446, expr.Location, "Foreach statement cannot operate on a `{0}'",
 						expr.ExprClassName);
 					return false;
 				}
 
 				statement = new CollectionForeach (type, variable, expr, statement, loc);
 			}
 
 			return statement.Resolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1535" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="66" endline="97">
<![CDATA[
 		PendingImplementation (TypeContainer container, MissingInterfacesInfo[] missing_ifaces, MethodSpec[] abstract_methods, int total)
 		{
 			var type_builder = container.Definition;
 			
 			this.container = container;
 			pending_implementations = new TypeAndMethods [total];
 
 			int i = 0;
 			if (abstract_methods != null) {
 				int count = abstract_methods.Length;
 				pending_implementations [i].methods = new MethodSpec [count];
 				pending_implementations [i].need_proxy = new MethodSpec [count];
 
 				pending_implementations [i].methods = abstract_methods;
 				pending_implementations [i].found = new MethodData [count];
 				pending_implementations [i].type = type_builder;
 				++i;
 			}
 
 			foreach (MissingInterfacesInfo missing in missing_ifaces) {
 				var iface = missing.Type;
 				var mi = MemberCache.GetInterfaceMethods (iface);
 
 				int count = mi.Count;
 				pending_implementations [i].type = iface;
 				pending_implementations [i].optional = missing.Optional;
 				pending_implementations [i].methods = mi;
 				pending_implementations [i].found = new MethodData [count];
 				pending_implementations [i].need_proxy = new MethodSpec [count];
 				i++;
 			}
 			foreach (MissingInterfacesInfo missing in missing_ifaces) {
 				var iface = missing.Type;
 				var mi = MemberCache.GetInterfaceMethods (iface);
 
 				int count = mi.Count;
 				pending_implementations [i].type = iface;
 				pending_implementations [i].optional = missing.Optional;
 				pending_implementations [i].methods = mi;
 				pending_implementations [i].found = new MethodData [count];
 				pending_implementations [i].need_proxy = new MethodSpec [count];
 				i++;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1536" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3119" endline="3161">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (IsInterface) {
 				ModFlags = Modifiers.PUBLIC | Modifiers.ABSTRACT |
 					Modifiers.VIRTUAL | (ModFlags & (Modifiers.UNSAFE | Modifiers.NEW));
 
 				flags = MethodAttributes.Public |
 					MethodAttributes.Abstract |
 					MethodAttributes.HideBySig |
 					MethodAttributes.NewSlot |
 					MethodAttributes.Virtual;
 			} else {
 				Parent.PartialContainer.MethodModifiersValid (this);
 
 				flags = ModifiersExtensions.MethodAttr (ModFlags);
 			}
 
 			if (IsExplicitImpl) {
 				TypeExpr iface_texpr = MemberName.Left.GetTypeExpression ().ResolveAsTypeTerminal (Parent, false);
 				if (iface_texpr == null)
 					return false;
 
 				if ((ModFlags & Modifiers.PARTIAL) != 0) {
 					Report.Error (754, Location, "A partial method `{0}' cannot explicitly implement an interface",
 						GetSignatureForError ());
 				}
 
 				InterfaceType = iface_texpr.Type;
 
 				if (!InterfaceType.IsInterface) {
 					Report.SymbolRelatedToPreviousError (InterfaceType);
 					Report.Error (538, Location, "The type `{0}' in explicit interface declaration is not an interface",
 						TypeManager.CSharpName (InterfaceType));
 				} else {
 					Parent.PartialContainer.VerifyImplements (this);
 				}
 
 				ModifiersExtensions.Check (Modifiers.AllowedExplicitImplFlags, explicit_mod_flags, 0, Location, Report);
 			}
 
 			return base.Define ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1537" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9078" endline="9114">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			count = count.Resolve (ec);
 			if (count == null)
 				return null;
 			
 			if (count.Type != TypeManager.uint32_type){
 				count = Convert.ImplicitConversionRequired (ec, count, TypeManager.int32_type, loc);
 				if (count == null)
 					return null;
 			}
 
 			Constant c = count as Constant;
 			if (c != null && c.IsNegative) {
 				ec.Report.Error (247, loc, "Cannot use a negative size with stackalloc");
 			}
 
 			if (ec.HasAny (ResolveContext.Options.CatchScope | ResolveContext.Options.FinallyScope)) {
 				ec.Report.Error (255, loc, "Cannot use stackalloc in finally or catch");
 			}
 
 			TypeExpr texpr = t.ResolveAsTypeTerminal (ec, false);
 			if (texpr == null)
 				return null;
 
 			otype = texpr.Type;
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, otype, loc))
 				return null;
 
 			type = PointerContainer.MakeType (otype);
 			eclass = ExprClass.Value;
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1538" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4106" endline="4159">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
 			if (!TypeManager.IsReferenceType (expr.Type)){
 				ec.Report.Error (185, loc,
 					"`{0}' is not a reference type as required by the lock statement",
 					expr.Type.GetSignatureForError ());
 			}
 
 			if (expr.Type.IsGenericParameter) {
 				expr = Convert.ImplicitTypeParameterConversion (expr, TypeManager.object_type);
 			}
 
 			VariableReference lv = expr as VariableReference;
 			bool locked;
 			if (lv != null) {
 				locked = lv.IsLockedByStatement;
 				lv.IsLockedByStatement = true;
 			} else {
 				lv = null;
 				locked = false;
 			}
 
 			ec.StartFlowBranching (this);
 			Statement.Resolve (ec);
 			ec.EndFlowBranching ();
 
 			if (lv != null) {
 				lv.IsLockedByStatement = locked;
 			}
 
 			base.Resolve (ec);
 
 			//
 			// Have to keep original lock value around to unlock same location
 			// in the case the original has changed or is null
 			//
 			expr_copy = TemporaryVariableReference.Create (TypeManager.object_type, ec.CurrentBlock.Parent, loc);
 			expr_copy.Resolve (ec);
 
 			//
 			// Ensure Monitor methods are available
 			//
 			if (ResolvePredefinedMethods (ec) > 1) {
 				lock_taken = TemporaryVariableReference.Create (TypeManager.bool_type, ec.CurrentBlock.Parent, loc);
 				lock_taken.Resolve (ec);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1539" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4340" endline="4381">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			// A boolean-expression is required to be of a type
 			// that can be implicitly converted to bool or of
 			// a type that implements operator true
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			Assign ass = expr as Assign;
 			if (ass != null && ass.Source is Constant) {
 				ec.Report.Warning (665, 3, loc,
 					"Assignment in conditional expression is always constant. Did you mean to use `==' instead ?");
 			}
 
 			if (expr.Type == TypeManager.bool_type)
 				return expr;
 
 			if (expr.Type == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return DynamicUnaryConversion.CreateIsTrue (args, loc).Resolve (ec);
 			}
 
 			type = TypeManager.bool_type;
 			Expression converted = Convert.ImplicitConversion (ec, expr, type, loc);
 			if (converted != null)
 				return converted;
 
 			//
 			// If no implicit conversion to bool exists, try using `operator true'
 			//
 			converted = GetOperatorTrue (ec, expr, loc);
 			if (converted == null) {
 				expr.Error_ValueCannotBeConverted (ec, loc, type, false);
 				return null;
 			}
 
 			return converted;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1540" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="638" endline="685">
<![CDATA[
 
 		//
 		// Creates field access expression for hoisted variable
 		//
 		protected virtual FieldExpr GetFieldExpression (EmitContext ec)
 		{
 			if (ec.CurrentAnonymousMethod == null || ec.CurrentAnonymousMethod.Storey == null) {
 				if (cached_outer_access != null)
 					return cached_outer_access;
 
 				//
 				// When setting top-level hoisted variable in generic storey
 				// change storey generic types to method generic types (VAR -> MVAR)
 				//
 				if (storey.Instance.Type.IsGenericOrParentIsGeneric) {
 					var fs = MemberCache.GetMember (storey.Instance.Type, field.Spec);
 					cached_outer_access = new FieldExpr (fs, field.Location);
 				} else {
 					cached_outer_access = new FieldExpr (field, field.Location);
 				}
 
 				cached_outer_access.InstanceExpression = storey.GetStoreyInstanceExpression (ec);
 				return cached_outer_access;
 			}
 
 			FieldExpr inner_access;
 			if (cached_inner_access != null) {
 				if (!cached_inner_access.TryGetValue (ec.CurrentAnonymousMethod, out inner_access))
 					inner_access = null;
 			} else {
 				inner_access = null;
 				cached_inner_access = new Dictionary<AnonymousExpression, FieldExpr> (4);
 			}
 
 			if (inner_access == null) {
 				if (field.Parent.IsGeneric) {
 					var fs = MemberCache.GetMember (field.Parent.CurrentType, field.Spec);
 					inner_access = new FieldExpr (fs, field.Location);
 				} else {
 					inner_access = new FieldExpr (field, field.Location);
 				}
 
 				inner_access.InstanceExpression = storey.GetStoreyInstanceExpression (ec);
 				cached_inner_access.Add (ec.CurrentAnonymousMethod, inner_access);
 			}
 
 			return inner_access;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1541" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="426" endline="467">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (Oper == Operator.AddressOf) {
 				return ResolveAddressOf (ec);
 			}
 
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			if (Expr.Type == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (Expr));
 				return new DynamicUnaryConversion (GetOperatorExpressionTypeName (), args, loc).Resolve (ec);
 			}
 
 			if (TypeManager.IsNullableType (Expr.Type))
 				return new Nullable.LiftedUnaryOperator (Oper, Expr, loc).Resolve (ec);
 
 			//
 			// Attempt to use a constant folding operation.
 			//
 			Constant cexpr = Expr as Constant;
 			if (cexpr != null) {
 				cexpr = TryReduceConstant (ec, cexpr);
 				if (cexpr != null)
 					return cexpr.Resolve (ec);
 			}
 
 			Expression expr = ResolveOperator (ec, Expr);
 			if (expr == null)
 				Error_OperatorCannotBeApplied (ec, loc, OperName (Oper), Expr.Type);
 			
 			//
 			// Reduce unary operator on predefined types
 			//
 			if (expr == this && Oper == Operator.UnaryPlus)
 				return Expr;
 
 			return expr;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1542" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3772" endline="3826">
<![CDATA[
 
 		void DoEmitStringSwitch (LocalTemporary value, EmitContext ec)
 		{
 			Label l_initialized = ec.DefineLabel ();
 
 			//
 			// Skip initialization when value is null
 			//
 			value.EmitBranchable (ec, null_target, false);
 
 			//
 			// Check if string dictionary is initialized and initialize
 			//
 			switch_cache_field.EmitBranchable (ec, l_initialized, true);
 			string_dictionary.EmitStatement (ec);
 			ec.MarkLabel (l_initialized);
 
 			LocalTemporary string_switch_variable = new LocalTemporary (TypeManager.int32_type);
 
 			ResolveContext rc = new ResolveContext (ec.MemberContext);
 
 			if (TypeManager.generic_ienumerable_type != null) {
 				Arguments get_value_args = new Arguments (2);
 				get_value_args.Add (new Argument (value));
 				get_value_args.Add (new Argument (string_switch_variable, Argument.AType.Out));
 				Expression get_item = new Invocation (new MemberAccess (switch_cache_field, "TryGetValue", loc), get_value_args).Resolve (rc);
 				if (get_item == null)
 					return;
 
 				//
 				// A value was not found, go to default case
 				//
 				get_item.EmitBranchable (ec, default_target, false);
 			} else {
 				Arguments get_value_args = new Arguments (1);
 				get_value_args.Add (new Argument (value));
 
 				Expression get_item = new ElementAccess (switch_cache_field, get_value_args, loc).Resolve (rc);
 				if (get_item == null)
 					return;
 
 				LocalTemporary get_item_object = new LocalTemporary (TypeManager.object_type);
 				get_item_object.EmitAssign (ec, get_item, true, false);
 				ec.Emit (OpCodes.Brfalse, default_target);
 
 				ExpressionStatement get_item_int = (ExpressionStatement) new SimpleAssign (string_switch_variable,
 					new Cast (new TypeExpression (TypeManager.int32_type, loc), get_item_object, loc)).Resolve (rc);
 
 				get_item_int.EmitStatement (ec);
 				get_item_object.Release (ec);
 			}
 
 			TableSwitchEmit (ec, string_switch_variable);
 			string_switch_variable.Release (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1543" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="315" endline="354">
<![CDATA[
 
 		protected void EmitCall (EmitContext ec, Expression binder, Arguments arguments, bool isStatement)
 		{
 			int dyn_args_count = arguments == null ? 0 
 			TypeExpr site_type = CreateSiteType (ec, arguments, dyn_args_count, isStatement);
 
 			FieldExpr site_field_expr = new FieldExpr (CreateSiteField (ec, site_type), loc);
 
 			SymbolWriter.OpenCompilerGeneratedBlock (ec);
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (binder));
 			StatementExpression s = new StatementExpression (new SimpleAssign (site_field_expr, new Invocation (new MemberAccess (site_type, "Create"), args)));
 			
 			BlockContext bc = new BlockContext (ec.MemberContext, null, TypeManager.void_type);		
 			if (s.Resolve (bc)) {
 				Statement init = new If (new Binary (Binary.Operator.Equality, site_field_expr, new NullLiteral (loc), loc), s, loc);
 				init.Emit (ec);
 			}
 
 			args = new Arguments (1 + dyn_args_count);
 			args.Add (new Argument (site_field_expr));
 			if (arguments != null) {
 				foreach (Argument a in arguments) {
 					if (a is NamedArgument) {
 						// Name is not valid in this context
 						args.Add (new Argument (a.Expr, a.ArgType));
 						continue;
 					}
 
 					args.Add (a);
 				}
 				foreach (Argument a in arguments) {
 					if (a is NamedArgument) {
 						// Name is not valid in this context
 						args.Add (new Argument (a.Expr, a.ArgType));
 						continue;
 					}
 
 					args.Add (a);
 				}
 			}
 
 			Expression target = new DelegateInvocation (new MemberAccess (site_field_expr, "Target", loc).Resolve (bc), args, loc).Resolve (bc);
 			if (target != null)
 				target.Emit (ec);
 
 			SymbolWriter.CloseCompilerGeneratedBlock (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1544" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="614" endline="662">
<![CDATA[
 
 		Expression ResolveAddressOf (ResolveContext ec)
 		{
 			if (!ec.IsUnsafe)
 				UnsafeError (ec, loc);
 
 			Expr = Expr.DoResolveLValue (ec, EmptyExpression.UnaryAddress);
 			if (Expr == null || Expr.eclass != ExprClass.Variable) {
 				ec.Report.Error (211, loc, "Cannot take the address of the given expression");
 				return null;
 			}
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, Expr.Type, loc)) {
 				return null;
 			}
 
 			IVariableReference vr = Expr as IVariableReference;
 			bool is_fixed;
 			if (vr != null) {
 				VariableInfo vi = vr.VariableInfo;
 				if (vi != null) {
 					if (vi.LocalInfo != null)
 						vi.LocalInfo.SetIsUsed ();
 
 					//
 					// A variable is considered definitely assigned if you take its address.
 					//
 					vi.SetAssigned (ec);
 				}
 
 				is_fixed = vr.IsFixed;
 				vr.SetHasAddressTaken ();
 
 				if (vr.IsHoisted) {
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, vr, loc);
 				}
 			} else {
 				IFixedExpression fe = Expr as IFixedExpression;
 				is_fixed = fe != null && fe.IsFixed;
 			}
 
 			if (!is_fixed && !ec.HasSet (ResolveContext.Options.FixedInitializerScope)) {
 				ec.Report.Error (212, loc, "You can only take the address of unfixed expression inside of a fixed statement initializer");
 			}
 
 			type = PointerContainer.MakeType (Expr.Type);
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1545" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1057" endline="1105">
<![CDATA[
 
 		public override bool Define()
 		{
 			var mod_flags_src = ModFlags;
 
 			if (!base.Define ())
 				return false;
 
 			if (declarators != null) {
 				if ((mod_flags_src & Modifiers.DEFAULT_ACCESS_MODIFER) != 0)
 					mod_flags_src &= ~(Modifiers.AccessibilityMask | Modifiers.DEFAULT_ACCESS_MODIFER);
 
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Events.IndexOf (this);
 				foreach (var d in declarators) {
 					var ef = new EventField (Parent, t, mod_flags_src, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 
 					if (d.Initializer != null)
 						ef.initializer = d.Initializer;
 
 					Parent.PartialContainer.Events.Insert (++index, ef);
 				}
 				foreach (var d in declarators) {
 					var ef = new EventField (Parent, t, mod_flags_src, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 
 					if (d.Initializer != null)
 						ef.initializer = d.Initializer;
 
 					Parent.PartialContainer.Events.Insert (++index, ef);
 				}
 			}
 
 			if (!HasBackingField) {
 				SetIsUsed ();
 				return true;
 			}
 
 			if (Add.IsInterfaceImplementation)
 				SetIsUsed ();
 
 			backing_field = new Field (Parent,
 				new TypeExpression (MemberType, Location),
 				Modifiers.BACKING_FIELD | Modifiers.COMPILER_GENERATED | Modifiers.PRIVATE | (ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE)),
 				MemberName, null);
 
 			Parent.PartialContainer.AddField (backing_field);
 			backing_field.Initializer = Initializer;
 			backing_field.ModFlags &= ~Modifiers.COMPILER_GENERATED;
 
 			// Call define because we passed fields definition
 			backing_field.Define ();
 
 			// Set backing field for event fields
 			spec.BackingField = backing_field.Spec;
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1546" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="459" endline="505">
<![CDATA[
 
 		void EmitFieldSize (int buffer_size)
 		{
 			PredefinedAttribute pa;
 			AttributeEncoder encoder;
 
 			pa = Module.PredefinedAttributes.StructLayout;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.short_type))
 				return;
 
 			var char_set_type = Module.PredefinedTypes.CharSet.Resolve (Location);
 			if (char_set_type == null)
 				return;
 
 			var field_size = pa.GetField ("Size", TypeManager.int32_type, Location);
 			var field_charset = pa.GetField ("CharSet", char_set_type, Location);
 			if (field_size == null || field_charset == null)
 				return;
 
 			var char_set = CharSet ?? Module.DefaultCharSet;
 
 			encoder = new AttributeEncoder ();
 			encoder.Encode ((short)LayoutKind.Sequential);
 			encoder.EncodeNamedArguments (
 				new [] { field_size, field_charset },
 				new Constant [] { new IntConstant (buffer_size, Location), new IntConstant ((int) char_set, Location) }
 			);
 
 			pa.EmitAttribute (fixed_buffer_type, encoder);
 
 			//
 			// Don't emit FixedBufferAttribute attribute for private types
 			//
 			if ((ModFlags & Modifiers.PRIVATE) != 0)
 				return;
 
 			pa = Module.PredefinedAttributes.FixedBuffer;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.type_type, TypeManager.int32_type))
 				return;
 
 			encoder = new AttributeEncoder ();
 			encoder.EncodeTypeName (MemberType);
 			encoder.Encode (buffer_size);
 			encoder.EncodeEmptyNamedArguments ();
 
 			pa.EmitAttribute (FieldBuilder, encoder);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1547" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1454" endline="1510">
<![CDATA[
 
 		//
 		// Creates a host for the anonymous method
 		//
 		AnonymousMethodMethod DoCreateMethodHost (EmitContext ec)
 		{
 			//
 			// Anonymous method body can be converted to
 			//
 			// 1, an instance method in current scope when only `this' is hoisted
 			// 2, a static method in current scope when neither `this' nor any variable is hoisted
 			// 3, an instance method in compiler generated storey when any hoisted variable exists
 			//
 
 			Modifiers modifiers;
 			if (Block.HasCapturedVariable || Block.HasCapturedThis) {
 				storey = FindBestMethodStorey ();
 				modifiers = storey != null ? Modifiers.INTERNAL 
 			} else {
 				if (ec.CurrentAnonymousMethod != null)
 					storey = ec.CurrentAnonymousMethod.Storey;
 
 				modifiers = Modifiers.STATIC | Modifiers.PRIVATE;
 			}
 
 			TypeContainer parent = storey != null ? storey 
 
 			MemberCore mc = ec.MemberContext as MemberCore;
 			string name = CompilerGeneratedClass.MakeName (parent != storey ? block_name 
 				"m", null, unique_id++);
 
 			MemberName member_name;
 			GenericMethod generic_method;
 			if (storey == null && mc.MemberName.TypeArguments != null) {
 				member_name = new MemberName (name, mc.MemberName.TypeArguments.Clone (), Location);
 
 				var hoisted_tparams = ec.CurrentTypeParameters;
 				var type_params = new TypeParameter[hoisted_tparams.Length];
 				for (int i = 0; i < type_params.Length; ++i) {
 					type_params[i] = hoisted_tparams[i].CreateHoistedCopy (null, null);
 				}
 				for (int i = 0; i < type_params.Length; ++i) {
 					type_params[i] = hoisted_tparams[i].CreateHoistedCopy (null, null);
 				}
 
 				generic_method = new GenericMethod (parent.NamespaceEntry, parent, member_name, type_params,
 					new TypeExpression (ReturnType, Location), parameters);
 			} else {
 				member_name = new MemberName (name, Location);
 				generic_method = null;
 			}
 
 			string real_name = String.Format (
 				"{0}~{1}{2}", mc.GetSignatureForError (), GetSignatureForError (),
 				parameters.GetSignatureForError ());
 
 			return new AnonymousMethodMethod (parent,
 				this, storey, generic_method, new TypeExpression (ReturnType, Location), modifiers,
 				real_name, member_name, parameters);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1548" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8267" endline="8320">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			var ac = (ArrayContainer) ea.Expr.Type;
 			TypeSpec t = source.Type;
 
 			//
 			// When we are dealing with a struct, get the address of it to avoid value copy
 			// Same cannot be done for reference type because array covariance and the
 			// check in ldelema requires to specify the type of array element stored at the index
 			//
 			if (t.IsStruct && ((prepare_for_load && !(source is DynamicExpressionStatement)) || !TypeManager.IsPrimitiveType (t))) {
 				LoadArrayAndArguments (ec);
 				ec.EmitArrayAddress (ac);
 
 				if (prepare_for_load) {
 					ec.Emit (OpCodes.Dup);
 				}
 
 				prepared = true;
 			} else if (prepare_for_load) {
 				ea.Expr.Emit (ec);
 				ec.Emit (OpCodes.Dup);
 
 				expr_copy = new LocalTemporary (ea.Expr.Type);
 				expr_copy.Store (ec);
 				prepared_arguments = ea.Arguments.Emit (ec, true);
 			} else {
 				LoadArrayAndArguments (ec);
 			}
 
 			source.Emit (ec);
 
 			if (expr_copy != null) {
 				expr_copy.Release (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temp = new LocalTemporary (this.type);
 				temp.Store (ec);
 			}
 
 			if (prepared) {
 				ec.EmitStoreFromPtr (t);
 			} else {
 				ec.EmitArrayStore (ac);
 			}
 			
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1549" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="625" endline="671">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if ((Oper & Operator.LogicalMask) != 0) {
 				Error_OperatorCannotBeApplied (ec, left, right);
 				return null;
 			}
 
 			bool use_default_call = (Oper & (Operator.BitwiseMask | Operator.EqualityMask)) != 0;
 			left_orig = left;
 			if (TypeManager.IsNullableType (left.Type)) {
 				left = left_unwrap = Unwrap.Create (left, use_default_call);
 				if (left == null)
 					return null;
 			}
 
 			right_orig = right;
 			if (TypeManager.IsNullableType (right.Type)) {
 				right = right_unwrap = Unwrap.Create (right, use_default_call);
 				if (right == null)
 					return null;
 			}
 
 			//
 			// Some details are in 6.4.2, 7.2.7
 			// Arguments can be lifted for equal operators when the return type is bool and both
 			// arguments are of same type
 			//	
 			if (left_orig is NullLiteral) {
 				left = right;
 				state |= State.LeftNullLifted;
 				type = TypeManager.bool_type;
 			}
 
 			if (right_orig.IsNull) {
 				if ((Oper & Operator.ShiftMask) != 0)
 					right = new EmptyExpression (TypeManager.int32_type);
 				else
 					right = left;
 
 				state |= State.RightNullLifted;
 				type = TypeManager.bool_type;
 			}
 
 			eclass = ExprClass.Value;
 			return DoResolveCore (ec, left_orig, right_orig);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1550" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="380" endline="414">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsPrimitiveType (MemberType)) {
 				Report.Error (1663, Location,
 					"`{0}'
 					GetSignatureForError ());
 			} else if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Fields.IndexOf (this);
 				foreach (var d in declarators) {
 					var f = new FixedField (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					f.initializer = d.Initializer;
 					((ConstInitializer) f.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 				foreach (var d in declarators) {
 					var f = new FixedField (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					f.initializer = d.Initializer;
 					((ConstInitializer) f.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 			}
 			
 			// Create nested fixed buffer container
 			string name = String.Format ("<{0}>__FixedBuffer{1}", Name, GlobalCounter++);
 			fixed_buffer_type = Parent.TypeBuilder.DefineNestedType (name, Parent.Module.DefaultCharSetType |
 				TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit, TypeManager.value_type.GetMetaInfo ());
 
 			fixed_buffer_type.DefineField (FixedElementName, MemberType.GetMetaInfo (), FieldAttributes.Public);
 			
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, fixed_buffer_type, ModifiersExtensions.FieldAttr (ModFlags));
 			var element_spec = new FieldSpec (null, this, MemberType, FieldBuilder, ModFlags);
 			spec = new FixedFieldSpec (Parent.Definition, this, FieldBuilder, element_spec, ModFlags);
 
 			Parent.MemberCache.AddMember (spec);
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1551" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="34" endline="76">
<![CDATA[
 
 		/// <summary>
 		///   Defines the constant in the @parent
 		/// </summary>
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!member_type.IsConstantCompatible) {
 				Error_InvalidConstantType (member_type, Location, Report);
 			}
 
 			FieldAttributes field_attr = FieldAttributes.Static | ModifiersExtensions.FieldAttr (ModFlags);
 			// Decimals cannot be emitted into the constant blob.  So, convert to 'readonly'.
 			if (member_type == TypeManager.decimal_type) {
 				field_attr |= FieldAttributes.InitOnly;
 			} else {
 				field_attr |= FieldAttributes.Literal;
 			}
 
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, MemberType.GetMetaInfo (), field_attr);
 			spec = new ConstSpec (Parent.Definition, this, MemberType, FieldBuilder, ModFlags, initializer);
 
 			Parent.MemberCache.AddMember (spec);
 
 			if ((field_attr & FieldAttributes.InitOnly) != 0)
 				Parent.PartialContainer.RegisterFieldForInitialization (this,
 					new FieldInitializer (spec, initializer, this));
 
 			if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Constants.IndexOf (this);
 				foreach (var d in declarators) {
 					var c = new Const (Parent, t, ModFlags & ~Modifiers.STATIC, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					c.initializer = d.Initializer;
 					((ConstInitializer) c.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Constants.Insert (++index, c);
 				}
 				foreach (var d in declarators) {
 					var c = new Const (Parent, t, ModFlags & ~Modifiers.STATIC, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					c.initializer = d.Initializer;
 					((ConstInitializer) c.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Constants.Insert (++index, c);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1552" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4972" endline="5018">
<![CDATA[
 		
 		override public Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			Expression e = DoResolve (ec, right_side);
 
 			if (e == null)
 				return null;
 
 			spec.MemberDefinition.SetIsAssigned ();
 
 			if ((right_side == EmptyExpression.UnaryAddress || right_side == EmptyExpression.OutAccess.Instance) &&
 					(spec.Modifiers & Modifiers.VOLATILE) != 0) {
 				ec.Report.Warning (420, 1, loc,
 					"`{0}'
 					spec.GetSignatureForError ());
 			}
 
 			if (spec.IsReadOnly) {
 				// InitOnly fields can only be assigned in constructors or initializers
 				if (!ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.ConstructorScope))
 					return Report_AssignToReadonly (ec, right_side);
 
 				if (ec.HasSet (ResolveContext.Options.ConstructorScope)) {
 
 					// InitOnly fields cannot be assigned-to in a different constructor from their declaring type
 					if (ec.CurrentMemberDefinition.Parent.Definition != spec.DeclaringType.GetDefinition ())
 						return Report_AssignToReadonly (ec, right_side);
 					// static InitOnly fields cannot be assigned-to in an instance constructor
 					if (IsStatic && !ec.IsStatic)
 						return Report_AssignToReadonly (ec, right_side);
 					// instance constructors can't modify InitOnly fields of other instances of the same type
 					if (!IsStatic && !(InstanceExpression is This))
 						return Report_AssignToReadonly (ec, right_side);
 				}
 			}
 
 			if (right_side == EmptyExpression.OutAccess.Instance &&
 				!IsStatic && !(InstanceExpression is This) && TypeManager.mbr_type != null && TypeSpec.IsBaseClass (spec.DeclaringType, TypeManager.mbr_type, false)) {
 				ec.Report.SymbolRelatedToPreviousError (spec.DeclaringType);
 				ec.Report.Warning (197, 1, loc,
 						"Passing `{0}' as ref or out or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class",
 						GetSignatureForError ());
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1553" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2402" endline="2430">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.AttributeUsage) {
 				if (!BaseType.IsAttribute && spec != TypeManager.attribute_type) {
 					Report.Error (641, a.Location, "Attribute `{0}' is only valid on classes derived from System.Attribute", a.GetSignatureForError ());
 				}
 			}
 
 			if (a.Type == pa.Conditional && !BaseType.IsAttribute) {
 				Report.Error (1689, a.Location, "Attribute `System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes");
 				return;
 			}
 
 			if (a.Type == pa.ComImport && !attributes.Contains (pa.Guid)) {
 				a.Error_MissingGuidAttribute ();
 				return;
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			if (a.Type.IsConditionallyExcluded (Location))
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1554" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8433" endline="8468">
<![CDATA[
 		
 		public override void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			prepared = prepare_for_load;
 			Expression value = source;
 
 			if (prepared) {
 				Invocation.EmitCall (ec, InstanceExpression, Getter, arguments, loc, true, false);
 
 				prepared_value = new LocalTemporary (type);
 				prepared_value.Store (ec);
 				source.Emit (ec);
 				prepared_value.Release (ec);
 
 				if (leave_copy) {
 					ec.Emit (OpCodes.Dup);
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			} else if (leave_copy) {
 				temp = new LocalTemporary (Type);
 				source.Emit (ec);
 				temp.Store (ec);
 				value = temp;
 			}
 			
 			if (!prepared)
 				arguments.Add (new Argument (value));
 
 			Invocation.EmitCall (ec, InstanceExpression, Setter, arguments, loc, false, prepared);
 			
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1555" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1568" endline="1605">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			TypeExpr target = target_type.ResolveAsTypeTerminal (ec, false);
 			if (target == null)
 				return null;
 
 			type = target.Type;
 
 			if (type.IsStatic) {
 				ec.Report.Error (716, loc, "Cannot convert to static type `{0}'", TypeManager.CSharpName (type));
 				return null;
 			}
 
 			eclass = ExprClass.Value;
 
 			Constant c = expr as Constant;
 			if (c != null) {
 				c = c.TryReduce (ec, type, loc);
 				if (c != null)
 					return c;
 			}
 
 			if (type.IsPointer && !ec.IsUnsafe) {
 				UnsafeError (ec, loc);
 			}
 
 			var res = Convert.ExplicitConversion (ec, expr, type, loc);
 			if (res == expr)
 				return EmptyCast.Create (res, type);
 
 			return res;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1556" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="345" endline="385">
<![CDATA[
 		}
 
 		protected override TypeExpr [] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			var mtype = Iterator.OriginalIteratorType;
 			if (Mutator != null)
 				mtype = Mutator.Mutate (mtype);
 
 			iterator_type_expr = new TypeExpression (mtype, Location);
 			generic_args = new TypeArguments (iterator_type_expr);
 
 			var list = new List<FullNamedExpression> ();
 			if (Iterator.IsEnumerable) {
 				enumerable_type = new TypeExpression (
 					TypeManager.ienumerable_type, Location);
 				list.Add (enumerable_type);
 
 				if (TypeManager.generic_ienumerable_type != null) {
 					generic_enumerable_type = new GenericTypeExpr (
 						TypeManager.generic_ienumerable_type,
 						generic_args, Location);
 					list.Add (generic_enumerable_type);
 				}
 			}
 
 			enumerator_type = new TypeExpression (
 				TypeManager.ienumerator_type, Location);
 			list.Add (enumerator_type);
 
 			list.Add (new TypeExpression (TypeManager.idisposable_type, Location));
 
 			var ienumerator_generic = Module.PredefinedTypes.IEnumeratorGeneric;
 			if (ienumerator_generic.Define ()) {
 				generic_enumerator_type = new GenericTypeExpr (ienumerator_generic.TypeSpec, generic_args, Location);
 				list.Add (generic_enumerator_type);
 			}
 
 			type_bases = list;
 
 			return base.ResolveBaseTypes (out base_class);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1557" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4716" endline="4744">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			using (ec.With (ResolveContext.Options.CatchScope, true)) {
 				if (type_expr != null) {
 					TypeExpr te = type_expr.ResolveAsTypeTerminal (ec, false);
 					if (te == null)
 						return false;
 
 					type = te.Type;
 					if (type != TypeManager.exception_type && !TypeSpec.IsBaseClass (type, TypeManager.exception_type, false)) {
 						ec.Report.Error (155, loc, "The type caught or thrown must be derived from System.Exception");
 					} else if (li != null) {
 						li.Type = type;
 						li.PrepareForFlowAnalysis (ec);
 
 						// source variable is at the top of the stack
 						Expression source = new EmptyExpression (li.Type);
 						if (li.Type.IsGenericParameter)
 							source = new UnboxCast (source, li.Type);
 
 						assign = new CompilerAssign (new LocalVariableReference (li, loc), source, loc);
 						Block.AddScopeStatement (new StatementExpression (assign));
 					}
 				}
 
 				return Block.Resolve (ec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1558" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="99" endline="159">
<![CDATA[
 
 		/// <summary>
 		///   Optional initialization for the Evaluator.
 		/// </summary>
 		/// <remarks>
 		///  Initializes the Evaluator with the command line
 		///  options that would be processed by the command
 		///  line compiler.  Only the first call to
 		///  InitAndGetStartupFiles or Init will work, any future
 		///  invocations are ignored.
 		///
 		///  You can safely avoid calling this method if your application
 		///  does not need any of the features exposed by the command line
 		///  interface.
 		///
 		///  This method return an array of strings that contains any
 		///  files that were specified in `args'.
 		///
 		///  If the unknownOptionParser is not null, this function is invoked
 		///  with the current args array and the index of the option that is not
 		///  known.  A value of true means that the value was processed, otherwise
 		///  it will be reported as an error
 		/// </remarks>
 		public static string [] InitAndGetStartupFiles (string [] args, Func<string [], int, int> unknownOptionParser)
 		{
 			lock (evaluator_lock){
 				if (inited)
 					return new string [0];
 
 				CompilerCallableEntryPoint.Reset ();
 				var crp = new ConsoleReportPrinter ();
 				driver = Driver.Create (args, false, unknownOptionParser, crp);
 				if (driver == null)
 					throw new Exception ("Failed to create compiler driver with the given arguments");
 
 				crp.Fatal = driver.fatal_errors;
 				ctx = driver.ctx;
 
 				RootContext.ToplevelTypes = new ModuleContainer (ctx);
 				
 				var startup_files = new List<string> ();
 				foreach (CompilationUnit file in Location.SourceFiles)
 					startup_files.Add (file.Path);
 				foreach (CompilationUnit file in Location.SourceFiles)
 					startup_files.Add (file.Path);
 				
 				CompilerCallableEntryPoint.PartialReset ();
 
 				var importer = new ReflectionImporter (ctx.BuildinTypes);
 				loader = new DynamicLoader (importer, ctx);
 
 				RootContext.ToplevelTypes.SetDeclaringAssembly (new AssemblyDefinitionDynamic (RootContext.ToplevelTypes, "temp"));
 
 				loader.LoadReferences (RootContext.ToplevelTypes);
 				ctx.BuildinTypes.CheckDefinitions (RootContext.ToplevelTypes);
 				RootContext.ToplevelTypes.InitializePredefinedTypes ();
 
 				RootContext.EvalMode = true;
 				inited = true;
 
 				return startup_files.ToArray ();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1559" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="410" endline="454">
<![CDATA[
 
 		void EmitHoistedFieldsInitialization (ResolveContext rc, EmitContext ec)
 		{
 			//
 			// Initialize all storey reference fields by using local or hoisted variables
 			//
 			if (used_parent_storeys != null) {
 				foreach (StoreyFieldPair sf in used_parent_storeys) {
 					//
 					// Get instance expression of storey field
 					//
 					Expression instace_expr = GetStoreyInstanceExpression (ec);
 					var fs = sf.Field.Spec;
 					if (TypeManager.IsGenericType (instace_expr.Type))
 						fs = MemberCache.GetMember (instace_expr.Type, fs);
 
 					FieldExpr f_set_expr = new FieldExpr (fs, Location);
 					f_set_expr.InstanceExpression = instace_expr;
 
 					SimpleAssign a = new SimpleAssign (f_set_expr, sf.Storey.GetStoreyInstanceExpression (ec));
 					if (a.Resolve (rc) != null)
 						a.EmitStatement (ec);
 				}
 				foreach (StoreyFieldPair sf in used_parent_storeys) {
 					//
 					// Get instance expression of storey field
 					//
 					Expression instace_expr = GetStoreyInstanceExpression (ec);
 					var fs = sf.Field.Spec;
 					if (TypeManager.IsGenericType (instace_expr.Type))
 						fs = MemberCache.GetMember (instace_expr.Type, fs);
 
 					FieldExpr f_set_expr = new FieldExpr (fs, Location);
 					f_set_expr.InstanceExpression = instace_expr;
 
 					SimpleAssign a = new SimpleAssign (f_set_expr, sf.Storey.GetStoreyInstanceExpression (ec));
 					if (a.Resolve (rc) != null)
 						a.EmitStatement (ec);
 				}
 			}
 
 			//
 			// Define hoisted `this' in top-level storey only 
 			//
 			if (OriginalSourceBlock.Explicit.HasCapturedThis && !(Parent is AnonymousMethodStorey)) {
 				AddCapturedThisField (ec);
 				rc.CurrentBlock.AddScopeStatement (new ThisInitializer (hoisted_this));
 			}
 
 			//
 			// Setting currect anonymous method to null blocks any further variable hoisting
 			//
 			AnonymousExpression ae = ec.CurrentAnonymousMethod;
 			ec.CurrentAnonymousMethod = null;
 
 			if (hoisted_params != null) {
 				EmitHoistedParameters (ec, hoisted_params);
 			}
 
 			ec.CurrentAnonymousMethod = ae;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1560" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="651" endline="691">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (Arguments == null || Arguments.Count != 1) {
 				ec.Report.Error (149, loc, "Method name expected");
 				return null;
 			}
 
 			Argument a = Arguments [0];
 			if (!a.ResolveMethodGroup (ec))
 				return null;
 
 			Expression e = a.Expr;
 
 			AnonymousMethodExpression ame = e as AnonymousMethodExpression;
 			if (ame != null && RootContext.Version != LanguageVersion.ISO_1) {
 				e = ame.Compatible (ec, type);
 				if (e == null)
 					return null;
 
 				return e.Resolve (ec);
 			}
 
 			method_group = e as MethodGroupExpr;
 			if (method_group == null) {
 				if (e.Type == InternalType.Dynamic) {
 					e = Convert.ImplicitConversionRequired (ec, e, type, loc);
 				} else if (!e.Type.IsDelegate) {
 					e.Error_UnexpectedKind (ec, ResolveFlags.MethodGroup | ResolveFlags.Type, loc);
 					return null;
 				}
 
 				//
 				// An argument is not a method but another delegate
 				//
 				method_group = new MethodGroupExpr (Delegate.GetInvokeMethod (ec.Compiler, e.Type), e.Type, loc);
 				method_group.InstanceExpression = e;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1561" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="853" endline="894">
<![CDATA[
 
 		//
 		// Converts `source' to an int, uint, long or ulong.
 		//
 		protected Expression ConvertExpressionToArrayIndex (ResolveContext ec, Expression source)
 		{
 			if (source.type == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (source));
 				return new DynamicConversion (TypeManager.int32_type, CSharpBinderFlags.ConvertArrayIndex, args, loc).Resolve (ec);
 			}
 
 			Expression converted;
 			
 			using (ec.Set (ResolveContext.Options.CheckedScope)) {
 				converted = Convert.ImplicitConversion (ec, source, TypeManager.int32_type, source.loc);
 				if (converted == null)
 					converted = Convert.ImplicitConversion (ec, source, TypeManager.uint32_type, source.loc);
 				if (converted == null)
 					converted = Convert.ImplicitConversion (ec, source, TypeManager.int64_type, source.loc);
 				if (converted == null)
 					converted = Convert.ImplicitConversion (ec, source, TypeManager.uint64_type, source.loc);
 
 				if (converted == null) {
 					source.Error_ValueCannotBeConverted (ec, source.loc, TypeManager.int32_type, false);
 					return null;
 				}
 			}
 
 			//
 			// Only positive constants are allowed at compile time
 			//
 			Constant c = converted as Constant;
 			if (c != null && c.IsNegative)
 				Error_NegativeArrayIndex (ec, source.loc);
 
 			// No conversion needed to array index
 			if (converted.Type == TypeManager.int32_type)
 				return converted;
 
 			return new ArrayIndexCast (converted).Resolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1562" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1267" endline="1302">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsDelegateType (MemberType)) {
 				Report.Error (66, Location, "`{0}'
 			}
 
 			if (!CheckBase ())
 				return false;
 
 			//
 			// Now define the accessors
 			//
 			var AddBuilder = Add.Define (Parent);
 			if (AddBuilder == null)
 				return false;
 
 			var RemoveBuilder = remove.Define (Parent);
 			if (RemoveBuilder == null)
 				return false;
 
 			EventBuilder = Parent.TypeBuilder.DefineEvent (GetFullName (MemberName), EventAttributes.None, MemberType.GetMetaInfo ());
 			EventBuilder.SetAddOnMethod (AddBuilder);
 			EventBuilder.SetRemoveOnMethod (RemoveBuilder);
 
 			spec = new EventSpec (Parent.Definition, this, MemberType, ModFlags, Add.Spec, remove.Spec);
 
 			Parent.MemberCache.AddMember (this, Name, spec);
 			Parent.MemberCache.AddMember (this, AddBuilder.Name, Add.Spec);
 			Parent.MemberCache.AddMember (this, RemoveBuilder.Name, remove.Spec);
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1563" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="288" endline="320">
<![CDATA[
 
 		public override void EmitType ()
 		{
 			if (ReturnType.Type != null) {
 				if (ReturnType.Type == InternalType.Dynamic) {
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 					Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 				} else if (ReturnType.Type.HasDynamicElement) {
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 					Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType.Type, Location);
 				}
 			}
 
 			Constructor.ParameterInfo.ApplyAttributes (this, Constructor.ConstructorBuilder);
 			Constructor.ConstructorBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 
 			parameters.ApplyAttributes (this, InvokeBuilder.MethodBuilder);
 			InvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 
 			if (BeginInvokeBuilder != null) {
 				BeginInvokeBuilder.ParameterInfo.ApplyAttributes (this, BeginInvokeBuilder.MethodBuilder);
 				EndInvokeBuilder.ParameterInfo.ApplyAttributes (this, EndInvokeBuilder.MethodBuilder);
 
 				BeginInvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 				EndInvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 			}
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1564" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2249" endline="2290">
<![CDATA[
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			int errors = ec.Compiler.Report.Errors;
 			FullNamedExpression fne = ec.LookupNamespaceOrType (Name, Arity, loc, /*ignore_cs0104=*/ false);
 
 			if (fne != null) {
 				if (fne.Type != null && Arity > 0) {
 					if (HasTypeArguments) {
 						GenericTypeExpr ct = new GenericTypeExpr (fne.Type, targs, loc);
 						return ct.ResolveAsTypeStep (ec, false);
 					}
 
 					return new GenericOpenTypeExpr (fne.Type, loc);
 				}
 
 				//
 				// dynamic namespace is ignored when dynamic is allowed (does not apply to types)
 				//
 				if (!(fne is Namespace))
 					return fne;
 			}
 
 			if (Arity == 0 && Name == "dynamic" && RootContext.Version > LanguageVersion.V_3) {
 				if (!ec.Module.PredefinedAttributes.Dynamic.IsDefined) {
 					ec.Compiler.Report.Error (1980, Location,
 						"Dynamic keyword requires `{0}' to be defined. Are you missing System.Core.dll assembly reference?",
 						ec.Module.PredefinedAttributes.Dynamic.GetSignatureForError ());
 				}
 
 				return new DynamicTypeExpr (loc);
 			}
 
 			if (fne != null)
 				return fne;
 
 			if (silent || errors != ec.Compiler.Report.Errors)
 				return null;
 
 			Error_TypeOrNamespaceNotFound (ec);
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1565" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="294" endline="333">
<![CDATA[
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.In && ModFlags == Modifier.OUT) {
 				a.Report.Error (36, a.Location, "An out parameter cannot have the `In' attribute");
 				return;
 			}
 
 			if (a.Type == pa.ParamArray) {
 				a.Report.Error (674, a.Location, "Do not use `System.ParamArrayAttribute'. Use the `params' keyword instead");
 				return;
 			}
 
 			if (a.Type == pa.Out && (ModFlags & Modifier.REF) == Modifier.REF &&
 			    !OptAttributes.Contains (pa.In)) {
 				a.Report.Error (662, a.Location,
 					"Cannot specify only `Out' attribute on a ref parameter. Use both `In' and `Out' attributes or neither");
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				a.Report.Warning (3022, 1, a.Location, "CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead");
 			}
 
 			if (a.Type == pa.DefaultParameterValue || a.Type == pa.OptionalParameter) {
 				if (HasOptionalExpression) {
 					a.Report.Error (1745, a.Location,
 						"Cannot specify `{0}' attribute on optional parameter `{1}'",
 						TypeManager.CSharpName (a.Type).Replace ("Attribute", ""), Name);
 				}
 
 				if (a.Type == pa.DefaultParameterValue)
 					return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1566" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="986" endline="1029">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			if (ec.Switch == null){
 				ec.Report.Error (153, loc, "A goto case is only valid inside a switch statement");
 				return false;
 			}
 
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
 			Constant c = expr as Constant;
 			if (c == null) {
 				ec.Report.Error (150, expr.Location, "A constant value is expected");
 				return false;
 			}
 
 			TypeSpec type = ec.Switch.SwitchType;
 			Constant res = c.TryReduce (ec, type, c.Location);
 			if (res == null) {
 				c.Error_ValueCannotBeConverted (ec, loc, type, true);
 				return false;
 			}
 
 			if (!Convert.ImplicitStandardConversionExists (c, type))
 				ec.Report.Warning (469, 2, loc,
 					"The `goto case' value is not implicitly convertible to type `{0}'",
 					TypeManager.CSharpName (type));
 
 			object val = res.GetValue ();
 			if (val == null)
 				val = SwitchLabel.NullStringCase;
 					
 			if (!ec.Switch.Elements.TryGetValue (val, out sl)) {
 				FlowBranchingBlock.Error_UnknownLabel (loc, "case " + 
 					(c.GetValue () == null ? "null" 
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1567" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="576" endline="617">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			MetaType[] required_modifier = null;
 			if ((ModFlags & Modifiers.VOLATILE) != 0) {
 				var mod = Module.PredefinedTypes.IsVolatile.Resolve (Location);
 				if (mod != null)
 					required_modifier = new MetaType[] { mod.GetMetaInfo () };
 			}
 
 			FieldBuilder = Parent.TypeBuilder.DefineField (
 				Name, member_type.GetMetaInfo (), required_modifier, null, ModifiersExtensions.FieldAttr (ModFlags));
 
 			spec = new FieldSpec (Parent.Definition, this, MemberType, FieldBuilder, ModFlags);
 
 			// Don't cache inaccessible fields
 			if ((ModFlags & Modifiers.BACKING_FIELD) == 0) {
 				Parent.MemberCache.AddMember (spec);
 			}
 
 			if (initializer != null) {
 				((TypeContainer) Parent).RegisterFieldForInitialization (this,
 					new FieldInitializer (spec, initializer, this));
 			}
 
 			if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Fields.IndexOf (this);
 				foreach (var d in declarators) {
 					var f = new Field (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					if (d.Initializer != null)
 						f.initializer = d.Initializer;
 
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 				foreach (var d in declarators) {
 					var f = new Field (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					if (d.Initializer != null)
 						f.initializer = d.Initializer;
 
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1568" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="397" endline="450">
<![CDATA[
 
 		void DefineIteratorMembers ()
 		{
 			pc_field = AddCompilerGeneratedField ("$PC", new TypeExpression (TypeManager.int32_type, Location));
 			current_field = AddCompilerGeneratedField ("$current", iterator_type_expr);
 
 			if (hoisted_params != null) {
 				//
 				// Iterators are independent, each GetEnumerator call has to
 				// create same enumerator therefore we have to keep original values
 				// around for re-initialization
 				//
 				// TODO
 				//
 				hoisted_params_copy = new List<HoistedParameter> (hoisted_params.Count);
 				foreach (HoistedParameter hp in hoisted_params) {
 					hoisted_params_copy.Add (new HoistedParameter (hp, "<$>" + hp.Field.Name));
 				}
 				foreach (HoistedParameter hp in hoisted_params) {
 					hoisted_params_copy.Add (new HoistedParameter (hp, "<$>" + hp.Field.Name));
 				}
 			}
 
 			if (generic_enumerator_type != null)
 				Define_Current (true);
 
 			Define_Current (false);
 			new DisposeMethod (this);
 			Define_Reset ();
 
 			if (Iterator.IsEnumerable) {
 				MemberName name = new MemberName (QualifiedAliasMember.GlobalAlias, "System", null, Location);
 				name = new MemberName (name, "Collections", Location);
 				name = new MemberName (name, "IEnumerable", Location);
 				name = new MemberName (name, "GetEnumerator", Location);
 
 				if (generic_enumerator_type != null) {
 					Method get_enumerator = new IteratorMethod (this, enumerator_type, 0, name);
 
 					name = new MemberName (name.Left.Left, "Generic", Location);
 					name = new MemberName (name, "IEnumerable", generic_args, Location);
 					name = new MemberName (name, "GetEnumerator", Location);
 					Method gget_enumerator = new GetEnumeratorMethod (this, generic_enumerator_type, name);
 
 					//
 					// Just call generic GetEnumerator implementation
 					//
 					get_enumerator.Block.AddStatement (
 						new Return (new Invocation (new DynamicMethodGroupExpr (gget_enumerator, Location), null), Location));
 
 					AddMethod (get_enumerator);
 					AddMethod (gget_enumerator);
 				} else {
 					AddMethod (new GetEnumeratorMethod (this, enumerator_type, name));
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1569" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9636" endline="9656">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (parameters == null)
 				return base.CreateExpressionTree (ec);
 
 			var init = new ArrayInitializer (parameters.Count, loc);
 			foreach (Property p in anonymous_type.Properties)
 				init.Add (new TypeOfMethod (MemberCache.GetMember (type, p.Get.Spec), loc));
 			foreach (Property p in anonymous_type.Properties)
 				init.Add (new TypeOfMethod (MemberCache.GetMember (type, p.Get.Spec), loc));
 
 			var ctor_args = new ArrayInitializer (arguments.Count, loc);
 			foreach (Argument a in arguments)
 				ctor_args.Add (a.CreateExpressionTree (ec));
 			foreach (Argument a in arguments)
 				ctor_args.Add (a.CreateExpressionTree (ec));
 
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (new TypeOfMethod (method, loc)));
 			args.Add (new Argument (new ArrayCreation (CreateExpressionTypeExpression (ec, loc), ctor_args, loc)));
 			args.Add (new Argument (new ImplicitlyTypedArrayCreation (init, loc)));
 
 			return CreateExpressionFactoryCall (ec, "New", args);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1570" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="1154" endline="1194">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			CloneContext cc = new CloneContext ();
 			Expression clone = source.Clone (cc);
 
 			//
 			// A useful feature for the REPL
 			// as a type, Describe the type;
 			//
 			if (Evaluator.DescribeTypeExpressions){
 				var old_printer = Evaluator.SetPrinter (new StreamReportPrinter (TextWriter.Null));
 				clone = clone.Resolve (ec);
 				if (clone == null){
 					clone = source.Clone (cc);
 					clone = clone.Resolve (ec, ResolveFlags.Type);
 					if (clone == null){
 						Evaluator.SetPrinter (old_printer);
 						clone = source.Clone (cc);
 						clone = clone.Resolve (ec);
 						return null;
 					}
 					
 					Arguments args = new Arguments (1);
 					args.Add (new Argument (new TypeOf ((TypeExpr) clone, Location)));
 					source = new Invocation (new SimpleName ("Describe", Location), args).Resolve (ec);
 				}
 				Evaluator.SetPrinter (old_printer);
 			} else {
 				clone = clone.Resolve (ec);
 				if (clone == null)
 					return null;
 			}
 	
 			// This means its really a statement.
 			if (clone.Type == TypeManager.void_type || clone is DynamicInvocation || clone is Assign) {
 				return clone;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1571" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="197" endline="243">
<![CDATA[
 
 		//
 		// This is used to resolve the expression as a type, a null
 		// value will be returned if the expression is not a type
 		// reference
 		//
 		public virtual TypeExpr ResolveAsTypeTerminal (IMemberContext ec , bool silent)
 		{
 			int errors = ec.Compiler.Report.Errors;
 
 			FullNamedExpression fne = ResolveAsTypeStep (ec, silent);
 
 			if (fne == null)
 				return null;
 				
 			TypeExpr te = fne as TypeExpr;				
 			if (te == null) {
 				if (!silent && errors == ec.Compiler.Report.Errors)
 					fne.Error_UnexpectedKind (ec.Compiler.Report, null, "type", loc);
 				return null;
 			}
 
 			if (!te.type.IsAccessible (ec.CurrentType)) {
 				ec.Compiler.Report.SymbolRelatedToPreviousError (te.Type);
 				ErrorIsInaccesible (ec, te.Type.GetSignatureForError (), loc);
 			}
 
 			te.loc = loc;
 
 			var dep = te.type.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (ec, dep, loc);
 			}
 
 			//
 			// Obsolete checks cannot be done when resolving base context as they
 			// require type dependecies to be set but we are just resolving them
 			//
 			if (!silent && !(ec is TypeContainer.BaseContext)) {
 				ObsoleteAttribute obsolete_attr = te.Type.GetAttributeObsolete ();
 				if (obsolete_attr != null && !ec.IsObsolete) {
 					AttributeTester.Report_ObsoleteMessage (obsolete_attr, te.GetSignatureForError (), Location, ec.Compiler.Report);
 				}
 			}
 
 			return te;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1572" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="710" endline="760">
<![CDATA[
 
 		protected override Expression ResolveConversions (ResolveContext ec)
 		{
 			//
 			// LAMESPEC
 			// This allows more natual dynamic behaviour but breaks compatibility
 			// with static binding
 			//
 			if (target is RuntimeValueExpression)
 				return this;
 
 			TypeSpec target_type = target.Type;
 
 			//
 			// 1. the return type is implicitly convertible to the type of target
 			//
 			if (Convert.ImplicitConversionExists (ec, source, target_type)) {
 				source = Convert.ImplicitConversion (ec, source, target_type, loc);
 				return this;
 			}
 
 			//
 			// Otherwise, if the selected operator is a predefined operator
 			//
 			Binary b = source as Binary;
 			if (b == null && source is ReducedExpression)
 				b = ((ReducedExpression) source).OriginalExpression as Binary;
 
 			if (b != null) {
 				//
 				// 2a. the operator is a shift operator
 				//
 				// 2b. the return type is explicitly convertible to the type of x, and
 				// y is implicitly convertible to the type of x
 				//
 				if ((b.Oper & Binary.Operator.ShiftMask) != 0 ||
 					Convert.ImplicitConversionExists (ec, right, target_type)) {
 					source = Convert.ExplicitConversion (ec, source, target_type, loc);
 					return this;
 				}
 			}
 
 			if (source.Type == InternalType.Dynamic) {
 				Arguments arg = new Arguments (1);
 				arg.Add (new Argument (source));
 				return new SimpleAssign (target, new DynamicConversion (target_type, CSharpBinderFlags.ConvertExplicit, arg, loc), loc).Resolve (ec);
 			}
 
 			right.Error_ValueCannotBeConverted (ec, loc, target_type, false);
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1573" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9657" endline="9694">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (ec.HasSet (ResolveContext.Options.ConstantScope)) {
 				ec.Report.Error (836, loc, "Anonymous types cannot be used in this expression");
 				return null;
 			}
 
 			if (parameters == null) {
 				anonymous_type = CreateAnonymousType (ec, EmptyParameters);
 				RequestedType = new TypeExpression (anonymous_type.Definition, loc);
 				return base.DoResolve (ec);
 			}
 
 			bool error = false;
 			arguments = new Arguments (parameters.Count);
 			TypeExpression [] t_args = new TypeExpression [parameters.Count];
 			for (int i = 0; i < parameters.Count; ++i) {
 				Expression e = ((AnonymousTypeParameter) parameters [i]).Resolve (ec);
 				if (e == null) {
 					error = true;
 					continue;
 				}
 
 				arguments.Add (new Argument (e));
 				t_args [i] = new TypeExpression (e.Type, e.Location);
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				Expression e = ((AnonymousTypeParameter) parameters [i]).Resolve (ec);
 				if (e == null) {
 					error = true;
 					continue;
 				}
 
 				arguments.Add (new Argument (e));
 				t_args [i] = new TypeExpression (e.Type, e.Location);
 			}
 
 			if (error)
 				return null;
 
 			anonymous_type = CreateAnonymousType (ec, parameters);
 			if (anonymous_type == null)
 				return null;
 
 			RequestedType = new GenericTypeExpr (anonymous_type.Definition, new TypeArguments (t_args), loc);
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1574" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="176" endline="217">
<![CDATA[
 
 		protected virtual Expression DoResolveInitializer (ResolveContext rc)
 		{
 			if (in_transit) {
 				field.Compiler.Report.Error (110, expr.Location,
 					"The evaluation of the constant value for `{0}' involves a circular definition",
 					GetSignatureForError ());
 
 				expr = null;
 			} else {
 				in_transit = true;
 				expr = expr.Resolve (rc);
 			}
 
 			in_transit = false;
 
 			if (expr != null) {
 				Constant c = expr as Constant;
 				if (c != null)
 					c = field.ConvertInitializer (rc, c);
 
 				if (c == null) {
 					if (TypeManager.IsReferenceType (field.MemberType))
 						Error_ConstantCanBeInitializedWithNullOnly (rc, field.MemberType, expr.Location, GetSignatureForError ());
 					else if (!(expr is Constant))
 						Error_ExpressionMustBeConstant (rc, expr.Location, GetSignatureForError ());
 					else
 						expr.Error_ValueCannotBeConverted (rc, expr.Location, field.MemberType, false);
 				}
 
 				expr = c;
 			}
 
 			if (expr == null) {
 				expr = New.Constantify (field.MemberType, Location);
 				if (expr == null)
 					expr = Constant.CreateConstantFromValue (field.MemberType, null, Location);
 				expr = expr.Resolve (rc);
 			}
 
 			return expr;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1575" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5539" endline="5564">
<![CDATA[
 
 		bool ResolveSetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasSet) {
 				rc.Report.Error (200, loc, "Property or indexer `{0}' cannot be assigned to (it is read-only)",
 					GetSignatureForError ());
 				return false;
 			}
 
 			if (!best_candidate.Set.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					rc.Report.Error (272, loc, "The property or indexer `{0}' cannot be used in this context because the set accessor is inaccessible",
 						GetSignatureForError ());
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					ErrorIsInaccesible (rc, best_candidate.Set.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility)
 				CheckProtectedMemberAccess (rc, best_candidate.Set);
 
 			setter = CandidateToBaseOverride (rc, best_candidate.Set);
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1576" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7489" endline="7518">
<![CDATA[
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			if (alias == GlobalAlias) {
 				expr = ec.Module.GlobalRootNamespace;
 				return base.ResolveAsTypeStep (ec, silent);
 			}
 
 			int errors = ec.Compiler.Report.Errors;
 			expr = ec.LookupNamespaceAlias (alias);
 			if (expr == null) {
 				if (errors == ec.Compiler.Report.Errors)
 					ec.Compiler.Report.Error (432, loc, "Alias `{0}' not found", alias);
 				return null;
 			}
 
 			FullNamedExpression fne = base.ResolveAsTypeStep (ec, silent);
 			if (fne == null)
 				return null;
 
 			if (expr.eclass == ExprClass.Type) {
 				if (!silent) {
 					ec.Compiler.Report.Error (431, loc,
 						"Alias `{0}' cannot be used with '
 				}
 				return null;
 			}
 
 			return fne;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1577" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="347" endline="390">
<![CDATA[
 
 		// <summary>
 		//   Resolve is used in method definitions
 		// </summary>
 		public virtual TypeSpec Resolve (IMemberContext rc, int index)
 		{
 			if (parameter_type != null)
 				return parameter_type;
 
 			if (attributes != null)
 				attributes.AttachTo (this, rc);
 
 			var expr = texpr.ResolveAsTypeTerminal (rc, false);
 			if (expr == null)
 				return null;
 
 			this.idx = index;
 			texpr = expr;
 			parameter_type = texpr.Type;
 	
 			if ((modFlags & Parameter.Modifier.ISBYREF) != 0 &&
 				TypeManager.IsSpecialType (parameter_type)) {
 				rc.Compiler.Report.Error (1601, Location, "Method or delegate parameter cannot be of type `{0}'",
 					GetSignatureForError ());
 				return null;
 			}
 
 			TypeManager.CheckTypeVariance (parameter_type,
 				(modFlags & Parameter.Modifier.ISBYREF) != 0 ? Variance.None 
 				rc);
 
 			if (parameter_type.IsStatic) {
 				rc.Compiler.Report.Error (721, Location, "`{0}'
 					texpr.GetSignatureForError ());
 				return parameter_type;
 			}
 
 			if ((modFlags & Modifier.This) != 0 && (parameter_type.IsPointer || parameter_type == InternalType.Dynamic)) {
 				rc.Compiler.Report.Error (1103, Location, "The extension method cannot be of type `{0}'",
 					TypeManager.CSharpName (parameter_type));
 			}
 
 			return parameter_type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1578" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1209" endline="1258">
<![CDATA[
 
 		public void Resolve (ResolveContext rc, Parameter p)
 		{
 			var expr = Resolve (rc);
 			if (expr == null)
 				return;
 
 			expr = Child;
 
 			if (!(expr is Constant || expr is DefaultValueExpression || (expr is New && ((New) expr).IsDefaultStruct))) {
 				rc.Compiler.Report.Error (1736, Location,
 					"The expression being assigned to optional parameter `{0}' must be a constant or default value",
 					p.Name);
 
 				return;
 			}
 
 			var parameter_type = p.Type;
 			if (type == parameter_type)
 				return;
 
 			var res = Convert.ImplicitConversionStandard (rc, expr, parameter_type, Location);
 			if (res != null) {
 				if (TypeManager.IsNullableType (parameter_type) && res is Nullable.Wrap) {
 					Nullable.Wrap wrap = (Nullable.Wrap) res;
 					res = wrap.Child;
 					if (!(res is Constant)) {
 						rc.Compiler.Report.Error (1770, Location,
 							"The expression being assigned to nullable optional parameter `{0}' must be default value",
 							p.Name);
 						return;
 					}
 				}
 
 				if (!expr.IsNull && TypeManager.IsReferenceType (parameter_type) && parameter_type != TypeManager.string_type) {
 					rc.Compiler.Report.Error (1763, Location,
 						"Optional parameter `{0}' of type `{1}' can only be initialized with `null'",
 						p.Name, parameter_type.GetSignatureForError ());
 
 					return;
 				}
 
 				this.expr = res;
 				return;
 			}
 
 			rc.Compiler.Report.Error (1750, Location,
 				"Optional parameter expression of type `{0}' cannot be converted to parameter type `{1}'",
 				type.GetSignatureForError (), parameter_type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1579" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4437" endline="4491">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			true_expr = true_expr.Resolve (ec);
 			false_expr = false_expr.Resolve (ec);
 
 			if (true_expr == null || false_expr == null || expr == null)
 				return null;
 
 			eclass = ExprClass.Value;
 			TypeSpec true_type = true_expr.Type;
 			TypeSpec false_type = false_expr.Type;
 			type = true_type;
 
 			//
 			// First, if an implicit conversion exists from true_expr
 			// to false_expr, then the result type is of type false_expr.Type
 			//
 			if (!TypeSpecComparer.IsEqual (true_type, false_type)) {
 				Expression conv = Convert.ImplicitConversion (ec, true_expr, false_type, loc);
 				if (conv != null && true_type != InternalType.Dynamic) {
 					//
 					// Check if both can convert implicitly to each other's type
 					//
 					type = false_type;
 
 					if (false_type != InternalType.Dynamic && Convert.ImplicitConversion (ec, false_expr, true_type, loc) != null) {
 						ec.Report.Error (172, true_expr.Location,
 							"Type of conditional expression cannot be determined as `{0}' and `{1}' convert implicitly to each other",
 								true_type.GetSignatureForError (), false_type.GetSignatureForError ());
 						return null;
 					}
 
 					true_expr = conv;
 				} else if ((conv = Convert.ImplicitConversion (ec, false_expr, true_type, loc)) != null) {
 					false_expr = conv;
 				} else {
 					ec.Report.Error (173, true_expr.Location,
 						"Type of conditional expression cannot be determined because there is no implicit conversion between `{0}' and `{1}'",
 						TypeManager.CSharpName (true_type), TypeManager.CSharpName (false_type));
 					return null;
 				}
 			}			
 
 			// Dead code optimalization
 			Constant c = expr as Constant;
 			if (c != null){
 				bool is_false = c.IsDefaultValue;
 				ec.Report.Warning (429, 4, is_false ? true_expr.Location 
 				return ReducedExpression.Create (is_false ? false_expr 
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1580" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="159" endline="187">
<![CDATA[
 		}
 
 		public bool CheckDefinitions (ModuleContainer module)
 		{
 			var ctx = module.Compiler;
 			foreach (var p in types) {
 				var found = PredefinedType.Resolve (module, p.Kind, p.Namespace, p.Name, p.Arity, Location.Null);
 				if (found == null || found == p)
 					continue;
 
 				if (!RootContext.StdLib) {
 					var ns = module.GlobalRootNamespace.GetNamespace (p.Namespace, false);
 					ns.ReplaceTypeWithPredefined (found, p);
 
 					var tc = found.MemberDefinition as TypeContainer;
 					tc.SetPredefinedSpec (p);
 					p.SetDefinition (found);
 				}
 			}
 			foreach (var p in types) {
 				var found = PredefinedType.Resolve (module, p.Kind, p.Namespace, p.Name, p.Arity, Location.Null);
 				if (found == null || found == p)
 					continue;
 
 				if (!RootContext.StdLib) {
 					var ns = module.GlobalRootNamespace.GetNamespace (p.Namespace, false);
 					ns.ReplaceTypeWithPredefined (found, p);
 
 					var tc = found.MemberDefinition as TypeContainer;
 					tc.SetPredefinedSpec (p);
 					p.SetDefinition (found);
 				}
 			}
 
 			if (ctx.Report.Errors != 0)
 				return false;
 
 			// Set internal build-in types
 			Dynamic.SetDefinition (Object);
 			Null.SetDefinition (Object);
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1581" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2129" endline="2164">
<![CDATA[
 		}
 
 		public abstract ParametersCompiled ParameterInfo { get ; }
 		public abstract TypeSpec ReturnType { get; }
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant || a.Type == pa.Obsolete || a.Type == pa.Conditional) {
 				Report.Error (1667, a.Location,
 					"Attribute `{0}' is not valid on property or event accessors. It is valid on `{1}' declarations only",
 					TypeManager.CSharpName (a.Type), a.GetValidTargets ());
 				return;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				method_data.MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			ApplyToExtraTarget (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1582" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1247" endline="1277">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			probe_type_expr = ProbeType.ResolveAsTypeTerminal (ec, false);
 			if (probe_type_expr == null)
 				return null;
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			if (probe_type_expr.Type.IsStatic) {
 				ec.Report.Error (-244, loc, "The `{0}' operator cannot be applied to an operand of a static type",
 					OperatorName);
 			}
 			
 			if (expr.Type.IsPointer || probe_type_expr.Type.IsPointer) {
 				ec.Report.Error (244, loc, "The `{0}' operator cannot be applied to an operand of pointer type",
 					OperatorName);
 				return null;
 			}
 
 			if (expr.Type == InternalType.AnonymousMethod) {
 				ec.Report.Error (837, loc, "The `{0}' operator cannot be applied to a lambda expression or anonymous method",
 					OperatorName);
 				return null;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1583" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1106" endline="1141">
<![CDATA[
 
 		protected virtual ParametersCompiled ResolveParameters (ResolveContext ec, TypeInferenceContext tic, TypeSpec delegate_type)
 		{
 			var delegate_parameters = Delegate.GetParameters (ec.Compiler, delegate_type);
 
 			if (Parameters == ParametersCompiled.Undefined) {
 				//
 				// We provide a set of inaccessible parameters
 				//
 				Parameter[] fixedpars = new Parameter[delegate_parameters.Count];
 
 				for (int i = 0; i < delegate_parameters.Count; i++) {
 					Parameter.Modifier i_mod = delegate_parameters.FixedParameters [i].ModFlags;
 					if (i_mod == Parameter.Modifier.OUT) {
 						if (!ec.IsInProbingMode) {
 							ec.Report.Error (1688, loc,
 								"Cannot convert anonymous method block without a parameter list to delegate type `{0}' because it has one or more `out' parameters",
 								delegate_type.GetSignatureForError ());
 						}
 
 						return null;
 					}
 					fixedpars[i] = new Parameter (
 						new TypeExpression (delegate_parameters.Types [i], loc), null,
 						delegate_parameters.FixedParameters [i].ModFlags, null, loc);
 				}
 				for (int i = 0; i < delegate_parameters.Count; i++) {
 					Parameter.Modifier i_mod = delegate_parameters.FixedParameters [i].ModFlags;
 					if (i_mod == Parameter.Modifier.OUT) {
 						if (!ec.IsInProbingMode) {
 							ec.Report.Error (1688, loc,
 								"Cannot convert anonymous method block without a parameter list to delegate type `{0}' because it has one or more `out' parameters",
 								delegate_type.GetSignatureForError ());
 						}
 
 						return null;
 					}
 					fixedpars[i] = new Parameter (
 						new TypeExpression (delegate_parameters.Types [i], loc), null,
 						delegate_parameters.FixedParameters [i].ModFlags, null, loc);
 				}
 
 				return ParametersCompiled.CreateFullyResolved (fixedpars, delegate_parameters.Types);
 			}
 
 			if (!VerifyExplicitParameters (ec, delegate_type, delegate_parameters)) {
 				return null;
 			}
 
 			return Parameters;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1584" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5344" endline="5380">
<![CDATA[
 
 		public override void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			Arguments args;
 
 			if (prepare_for_load && !(source is DynamicExpressionStatement)) {
 				args = new Arguments (0);
 				prepared = true;
 				source.Emit (ec);
 				
 				if (leave_copy) {
 					ec.Emit (OpCodes.Dup);
 					if (!IsStatic) {
 						temp = new LocalTemporary (this.Type);
 						temp.Store (ec);
 					}
 				}
 			} else {
 				args = new Arguments (1);
 
 				if (leave_copy) {
 					source.Emit (ec);
 					temp = new LocalTemporary (this.Type);
 					temp.Store (ec);
 					args.Add (new Argument (temp));
 				} else {
 					args.Add (new Argument (source));
 				}
 			}
 
 			Invocation.EmitCall (ec, InstanceExpression, Setter, args, loc, false, prepared);
 			
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1585" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3410" endline="3477">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		//  7.4.3.3  Better conversion from expression
 		//  Returns 
 		//              2    if a->q is better,
 		//              0 if neither is better
 		//
 		static int BetterExpressionConversion (ResolveContext ec, Argument a, TypeSpec p, TypeSpec q)
 		{
 			TypeSpec argument_type = a.Type;
 
 			//
 			// If argument is an anonymous function
 			//
 			if (argument_type == InternalType.AnonymousMethod && RootContext.Version > LanguageVersion.ISO_2) {
 				//
 				// p and q are delegate types or expression tree types
 				//
 				if (p.GetDefinition () == TypeManager.expression_type || q.GetDefinition () == TypeManager.expression_type) {
 					if (q.MemberDefinition != p.MemberDefinition) {
 						return 0;
 					}
 
 					//
 					// Uwrap delegate from Expression<T>
 					//
 					q = TypeManager.GetTypeArguments (q)[0];
 					p = TypeManager.GetTypeArguments (p)[0];
 				}
 
 				var p_m = Delegate.GetInvokeMethod (ec.Compiler, p);
 				var q_m = Delegate.GetInvokeMethod (ec.Compiler, q);
 
 				//
 				// With identical parameter lists
 				//
 				if (!TypeSpecComparer.Equals (p_m.Parameters.Types,q_m.Parameters.Types))
 					return 0;
 
 				p = p_m.ReturnType;
 				q = q_m.ReturnType;
 
 				//
 				// if p is void returning, and q has a return type Y, then C2 is the better conversion.
 				//
 				if (p == TypeManager.void_type) {
 					return q != TypeManager.void_type ? 2 
 				}
 
 				//
 				// if p has a return type Y, and q is void returning, then C1 is the better conversion.
 				//
 				if (q == TypeManager.void_type) {
 					return p != TypeManager.void_type ? 1
 				}
 			} else {
 				if (argument_type == p)
 					return 1;
 
 				if (argument_type == q)
 					return 2;
 			}
 
 			return BetterTypeConversion (ec, p, q);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1586" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8501" endline="8546">
<![CDATA[
 
 		protected override Expression OverloadResolve (ResolveContext rc, Expression right_side)
 		{
 			if (best_candidate != null)
 				return this;
 
 			eclass = ExprClass.IndexerAccess;
 
 			bool dynamic;
 			arguments.Resolve (rc, out dynamic);
 
 			if (indexers == null && InstanceExpression.Type == InternalType.Dynamic) {
 				dynamic = true;
 			} else {
 				var res = new OverloadResolver (indexers, OverloadResolver.Restrictions.None, loc);
 				res.BaseMembersProvider = this;
 
 				// TODO
 				best_candidate = res.ResolveMember<IndexerSpec> (rc, ref arguments);
 				if (best_candidate != null)
 					type = res.BestCandidateReturnType;
 				else if (!res.BestCandidateIsDynamic)
 					return null;
 			}
 
 			//
 			// It has dynamic arguments
 			//
 			if (dynamic) {
 				Arguments args = new Arguments (arguments.Count + 1);
 				if (IsBase) {
 					rc.Report.Error (1972, loc,
 						"The indexer base access cannot be dynamically dispatched. Consider casting the dynamic arguments or eliminating the base access");
 				} else {
 					args.Add (new Argument (InstanceExpression));
 				}
 				args.AddRange (arguments);
 
 				best_candidate = null;
 				return new DynamicIndexBinder (args, loc);
 			}
 
 			ResolveInstanceExpression (rc, right_side);
 			CheckProtectedMemberAccess (rc, best_candidate);
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1587" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2571" endline="2654">
<![CDATA[
 		}
 
 		/// <summary>
 		///   Whether this is an instance member.
 		/// </summary>
 		public abstract bool IsInstance {
 			get;
 		}
 
 		/// <summary>
 		///   Whether this is a static member.
 		/// </summary>
 		public abstract bool IsStatic {
 			get;
 		}
 
 		// TODO
 		protected abstract TypeSpec DeclaringType {
 			get;
 		}
 
 		//
 		// Converts best base candidate for virtual method starting from QueriedBaseType
 		//
 		protected MethodSpec CandidateToBaseOverride (ResolveContext rc, MethodSpec method)
 		{
 			//
 			// Only when base.member is used and method is virtual
 			//
 			if (!IsBase)
 				return method;
 
 			//
 			// Overload resulution works on virtual or non-virtual members only (no overrides). That
 			// means for base.member access we have to find the closest match after we found best candidate
 			//
 			if ((method.Modifiers & (Modifiers.ABSTRACT | Modifiers.VIRTUAL | Modifiers.STATIC)) != Modifiers.STATIC) {
 				//
 				// The method could already be what we are looking for
 				//
 				TypeSpec[] targs = null;
 				if (method.DeclaringType != InstanceExpression.Type) {
 					var base_override = MemberCache.FindMember (InstanceExpression.Type, new MemberFilter (method), BindingRestriction.InstanceOnly) as MethodSpec;
 					if (base_override != null && base_override.DeclaringType != method.DeclaringType) {
 						if (base_override.IsGeneric)
 							targs = method.TypeArguments;
 
 						method = base_override;
 					}
 				}
 
 				// TODO
 				// hoisted stories only but that requires a new expression wrapper
 				if (rc.CurrentAnonymousMethod != null) {
 					if (targs == null && method.IsGeneric) {
 						targs = method.TypeArguments;
 						method = method.GetGenericMethodDefinition ();
 					}
 
 					if (method.Parameters.HasArglist)
 						throw new NotImplementedException ("__arglist base call proxy");
 
 					method = rc.CurrentMemberDefinition.Parent.PartialContainer.CreateHoistedBaseCallProxy (rc, method);
 
 					// Ideally this should apply to any proxy rewrite but in the case of unary mutators on
 					// get/set member expressions second call would fail to proxy because left expression
 					// would be of 'this' and not 'base'
 					if (rc.CurrentType.IsStruct)
 						InstanceExpression = new This (loc).Resolve (rc);
 				}
 
 				if (targs != null)
 					method = method.MakeGenericMethod (targs);
 			}
 
 			//
 			// Only base will allow this invocation to happen.
 			//
 			if (method.IsAbstract) {
 				Error_CannotCallAbstractBase (rc, method.GetSignatureForError ());
 			}
 
 			return method;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1588" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8906" endline="8952">
<![CDATA[
 
 		protected override TypeExpr DoResolveAsTypeStep (IMemberContext ec)
 		{
 			TypeExpr lexpr = left.ResolveAsTypeTerminal (ec, false);
 			if (lexpr == null)
 				return null;
 
 			type = lexpr.Type;
 			eclass = ExprClass.Type;
 
 			var single_spec = spec;
 
 			if (single_spec.IsNullable) {
 				lexpr = new Nullable.NullableType (lexpr, loc);
 				lexpr = lexpr.ResolveAsTypeTerminal (ec, false);
 				if (lexpr != null)
 					type = lexpr.Type;
 
 				single_spec = single_spec.Next;
 			} else if (single_spec.IsPointer) {
 				if (!TypeManager.VerifyUnmanaged (ec.Compiler, type, loc))
 					return null;
 
 				if (!ec.IsUnsafe) {
 					UnsafeError (ec.Compiler.Report, loc);
 				}
 
 				do {
 					type = PointerContainer.MakeType (type);
 					single_spec = single_spec.Next;
 				} while (single_spec != null && single_spec.IsPointer);
 			}
 
 			if (single_spec != null && single_spec.Dimension > 0) {
 				if (TypeManager.IsSpecialType (type)) {
 					ec.Compiler.Report.Error (611, loc, "Array elements cannot be of type `{0}'", type.GetSignatureForError ());
 				} else if (type.IsStatic) {
 					ec.Compiler.Report.SymbolRelatedToPreviousError (type);
 					ec.Compiler.Report.Error (719, loc, "Array elements cannot be of static type `{0}'",
 						type.GetSignatureForError ());
 				} else {
 					MakeArray (single_spec);
 				}
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1589" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1488" endline="1546">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (resolved_type == null) {
 				resolved_type = base.DoResolve (ec);
 
 				if (resolved_type == null)
 					return null;
 			}
 
 			type = probe_type_expr.Type;
 			eclass = ExprClass.Value;
 			TypeSpec etype = expr.Type;
 
 			if (!TypeManager.IsReferenceType (type) && !TypeManager.IsNullableType (type)) {
 				if (TypeManager.IsGenericParameter (type)) {
 					ec.Report.Error (413, loc,
 						"The `as' operator cannot be used with a non-reference type parameter `{0}'. Consider adding `class' or a reference type constraint",
 						probe_type_expr.GetSignatureForError ());
 				} else {
 					ec.Report.Error (77, loc,
 						"The `as' operator cannot be used with a non-nullable value type `{0}'",
 						TypeManager.CSharpName (type));
 				}
 				return null;
 			}
 
 			if (expr.IsNull && TypeManager.IsNullableType (type)) {
 				return Nullable.LiftedNull.CreateFromExpression (ec, this);
 			}
 
 			// If the compile-time type of E is dynamic, unlike the cast operator the as operator is not dynamically bound
 			if (etype == InternalType.Dynamic) {
 				return this;
 			}
 			
 			Expression e = Convert.ImplicitConversionStandard (ec, expr, type, loc);
 			if (e != null) {
 				e = EmptyCast.Create (e, type);
 				return ReducedExpression.Create (e, this).Resolve (ec);
 			}
 
 			if (Convert.ExplicitReferenceConversionExists (etype, type)){
 				if (TypeManager.IsGenericParameter (etype))
 					expr = new BoxedCast (expr, etype);
 
 				return this;
 			}
 
 			if (InflatedTypeSpec.ContainsTypeParameter (etype) || InflatedTypeSpec.ContainsTypeParameter (type)) {
 				expr = new BoxedCast (expr, etype);
 				return this;
 			}
 
 			ec.Report.Error (39, loc, "Cannot convert type `{0}' to `{1}' via a built-in conversion",
 				TypeManager.CSharpName (etype), TypeManager.CSharpName (type));
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1590" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="652" endline="699">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (member != null ? 5 
 			bool is_member_access = member is MemberAccess;
 
 			CSharpBinderFlags call_flags;
 			if (!is_member_access && member is SimpleName) {
 				call_flags = CSharpBinderFlags.InvokeSimpleName;
 				is_member_access = true;
 			} else {
 				call_flags = 0;
 			}
 
 			binder_args.Add (new Argument (new BinderFlags (call_flags, this)));
 
 			if (is_member_access)
 				binder_args.Add (new Argument (new StringLiteral (member.Name, member.Location)));
 
 			if (member != null && member.HasTypeArguments) {
 				TypeArguments ta = member.TypeArguments;
 				if (ta.Resolve (ec)) {
 					var targs = new ArrayInitializer (ta.Count, loc);
 					foreach (TypeSpec t in ta.Arguments)
 						targs.Add (new TypeOf (new TypeExpression (t, loc), loc));
 					foreach (TypeSpec t in ta.Arguments)
 						targs.Add (new TypeOf (new TypeExpression (t, loc), loc));
 
 					binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (targs, loc)));
 				}
 			} else if (is_member_access) {
 				binder_args.Add (new Argument (new NullLiteral (loc)));
 			}
 
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 
 			Expression real_args;
 			if (args == null) {
 				// Cannot be null because .NET trips over
 				real_args = new ArrayCreation (
 					new MemberAccess (GetBinderNamespace (loc), "CSharpArgumentInfo", loc),
 					new ArrayInitializer (0, loc), loc);
 			} else {
 				real_args = new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc);
 			}
 
 			binder_args.Add (new Argument (real_args));
 
 			return new Invocation (GetBinder (is_member_access ? "InvokeMember" 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1591" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5201" endline="5254">
<![CDATA[
 
 		protected virtual Expression DoResolveDynamic (ResolveContext ec, Expression memberExpr)
 		{
 			Arguments args;
 			DynamicMemberBinder dmb = memberExpr as DynamicMemberBinder;
 			if (dmb != null) {
 				args = dmb.Arguments;
 				if (arguments != null)
 					args.AddRange (arguments);
 			} else if (mg == null) {
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				args.Insert (0, new Argument (memberExpr));
 				this.expr = null;
 			} else {
 				if (mg.IsBase) {
 					ec.Report.Error (1971, loc,
 						"The base call to method `{0}' cannot be dynamically dispatched. Consider casting the dynamic arguments or eliminating the base access",
 						mg.Name);
 					return null;
 				}
 
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				MemberAccess ma = expr as MemberAccess;
 				if (ma != null) {
 					var left_type = ma.LeftExpression as TypeExpr;
 					if (left_type != null) {
 						args.Insert (0, new Argument (new TypeOf (left_type, loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						//
 						// Any value type has to be pass as by-ref to get back the same
 						// instance on which the member was called
 						//
 						var mod = TypeManager.IsValueType (ma.LeftExpression.Type) ? Argument.AType.Ref 
 						args.Insert (0, new Argument (ma.LeftExpression.Resolve (ec), mod));
 					}
 				} else {	// is SimpleName
 					if (ec.IsStatic) {
 						args.Insert (0, new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						args.Insert (0, new Argument (new This (loc).Resolve (ec)));
 					}
 				}
 			}
 
 			return new DynamicInvocation (expr as ATypeNameExpression, args, loc).Resolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1592" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="472" endline="528">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			constructor_method = Delegate.GetConstructor (ec.Compiler, ec.CurrentType, type);
 
 			var invoke_method = Delegate.GetInvokeMethod (ec.Compiler, type);
 
 			Arguments arguments = CreateDelegateMethodArguments (invoke_method.Parameters, invoke_method.Parameters.Types, loc);
 			method_group = method_group.OverloadResolve (ec, ref arguments, this, OverloadResolver.Restrictions.CovariantDelegate);
 			if (method_group == null)
 				return null;
 
 			var delegate_method = method_group.BestCandidate;
 			
 			if (TypeManager.IsNullableType (delegate_method.DeclaringType)) {
 				ec.Report.Error (1728, loc, "Cannot create delegate from method `{0}' because it is a member of System.Nullable<T> type",
 					delegate_method.GetSignatureForError ());
 				return null;
 			}		
 			
 			Invocation.IsSpecialMethodInvocation (ec, delegate_method, loc);
 
 			ExtensionMethodGroupExpr emg = method_group as ExtensionMethodGroupExpr;
 			if (emg != null) {
 				method_group.InstanceExpression = emg.ExtensionExpression;
 				TypeSpec e_type = emg.ExtensionExpression.Type;
 				if (TypeManager.IsValueType (e_type)) {
 					ec.Report.Error (1113, loc, "Extension method `{0}' of value type `{1}' cannot be used to create delegates",
 						delegate_method.GetSignatureForError (), TypeManager.CSharpName (e_type));
 				}
 			}
 
 			TypeSpec rt = delegate_method.ReturnType;
 			Expression ret_expr = new TypeExpression (rt, loc);
 			if (!Delegate.IsTypeCovariant (ret_expr, invoke_method.ReturnType)) {
 				Error_ConversionFailed (ec, delegate_method, ret_expr);
 			}
 
 			if (delegate_method.IsConditionallyExcluded (loc)) {
 				ec.Report.SymbolRelatedToPreviousError (delegate_method);
 				MethodOrOperator m = delegate_method.MemberDefinition as MethodOrOperator;
 				if (m != null && m.IsPartialDefinition) {
 					ec.Report.Error (762, loc, "Cannot create delegate from partial method declaration `{0}'",
 						delegate_method.GetSignatureForError ());
 				} else {
 					ec.Report.Error (1618, loc, "Cannot create delegate with `{0}' because it has a Conditional attribute",
 						TypeManager.CSharpSignature (delegate_method));
 				}
 			}
 
 			var expr = method_group.InstanceExpression;
 			if (expr != null && (expr.Type.IsGenericParameter || !TypeManager.IsReferenceType (expr.Type)))
 				method_group.InstanceExpression = new BoxedCast (expr, TypeManager.object_type);
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1593" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9172" endline="9234">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (source == null)
 				return EmptyExpressionStatement.Instance;
 
 			var t = ec.CurrentInitializerVariable.Type;
 			if (t == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (ec.CurrentInitializerVariable));
 				target = new DynamicMemberBinder (Name, args, loc);
 			} else {
 
 				var member = MemberLookup (ec, ec.CurrentType, t, Name, 0, MemberLookupRestrictions.ExactArity, loc);
 				if (member == null) {
 					member = Expression.MemberLookup (null, ec.CurrentType, t, Name, 0, MemberLookupRestrictions.ExactArity, loc);
 
 					if (member != null) {
 						// TODO
 						ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						return null;
 					}
 				}
 
 				if (member == null) {
 					Error_TypeDoesNotContainDefinition (ec, loc, t, Name);
 					return null;
 				}
 
 				if (!(member is PropertyExpr || member is FieldExpr)) {
 					ec.Report.Error (1913, loc,
 						"Member `{0}' cannot be initialized. An object initializer may only be used for fields, or properties",
 						member.GetSignatureForError ());
 
 					return null;
 				}
 
 				var me = member as MemberExpr;
 				if (me.IsStatic) {
 					ec.Report.Error (1914, loc,
 						"Static field or property `{0}' cannot be assigned in an object initializer",
 						me.GetSignatureForError ());
 				}
 
 				target = me;
 				me.InstanceExpression = ec.CurrentInitializerVariable;
 			}
 
 			if (source is CollectionOrObjectInitializers) {
 				Expression previous = ec.CurrentInitializerVariable;
 				ec.CurrentInitializerVariable = target;
 				source = source.Resolve (ec);
 				ec.CurrentInitializerVariable = previous;
 				if (source == null)
 					return null;
 					
 				eclass = source.eclass;
 				type = source.Type;
 				return this;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1594" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2207" endline="2263">
<![CDATA[
 
 		void DefineAnonymousStorey (EmitContext ec)
 		{
 			//
 			// Creates anonymous method storey
 			//
 			if (ec.CurrentAnonymousMethod != null && ec.CurrentAnonymousMethod.Storey != null) {
 				//
 				// Creates parent storey reference when hoisted this is accessible
 				//
 				if (am_storey.OriginalSourceBlock.Explicit.HasCapturedThis) {
 					ExplicitBlock parent = am_storey.OriginalSourceBlock.Explicit.Parent.Explicit;
 
 					//
 					// Hoisted this exists in top-level parent storey only
 					//
 					while (parent.am_storey == null || parent.am_storey.Parent is AnonymousMethodStorey)
 						parent = parent.Parent.Explicit;
 					while (parent.am_storey == null || parent.am_storey.Parent is AnonymousMethodStorey)
 						parent = parent.Parent.Explicit;
 
 					am_storey.AddParentStoreyReference (ec, parent.am_storey);
 				}
 
 				am_storey.SetNestedStoryParent (ec.CurrentAnonymousMethod.Storey);
 
 				// TODO MemberCache
 				am_storey.Mutator = ec.CurrentAnonymousMethod.Storey.Mutator;
 			}
 
 			am_storey.CreateType ();
 			if (am_storey.Mutator == null && ec.CurrentTypeParameters != null)
 				am_storey.Mutator = new TypeParameterMutator (ec.CurrentTypeParameters, am_storey.CurrentTypeParameters);
 
 			am_storey.DefineType ();
 			am_storey.ResolveTypeParameters ();
 
 			var ref_blocks = am_storey.ReferencesFromChildrenBlock;
 			if (ref_blocks != null) {
 				foreach (ExplicitBlock ref_block in ref_blocks) {
 					for (ExplicitBlock b = ref_block.Explicit; b.am_storey != am_storey; b = b.Parent.Explicit) {
 						if (b.am_storey != null) {
 							b.am_storey.AddParentStoreyReference (ec, am_storey);
 
 							// Stop propagation inside same top block
 							if (b.ParametersBlock.am_storey == ParametersBlock.am_storey)
 								break;
 
 							b = b.ParametersBlock;
 						}
 
 						b.HasCapturedVariable = true;
 					}
 					for (ExplicitBlock b = ref_block.Explicit; b.am_storey != am_storey; b = b.Parent.Explicit) {
 						if (b.am_storey != null) {
 							b.am_storey.AddParentStoreyReference (ec, am_storey);
 
 							// Stop propagation inside same top block
 							if (b.ParametersBlock.am_storey == ParametersBlock.am_storey)
 								break;
 
 							b = b.ParametersBlock;
 						}
 
 						b.HasCapturedVariable = true;
 					}
 				}
 				foreach (ExplicitBlock ref_block in ref_blocks) {
 					for (ExplicitBlock b = ref_block.Explicit; b.am_storey != am_storey; b = b.Parent.Explicit) {
 						if (b.am_storey != null) {
 							b.am_storey.AddParentStoreyReference (ec, am_storey);
 
 							// Stop propagation inside same top block
 							if (b.ParametersBlock.am_storey == ParametersBlock.am_storey)
 								break;
 
 							b = b.ParametersBlock;
 						}
 
 						b.HasCapturedVariable = true;
 					}
 				}
 			}
 
 			am_storey.Define ();
 			am_storey.Parent.PartialContainer.AddCompilerGeneratedClass (am_storey);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1595" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="524" endline="571">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1596" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4593" endline="4619">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			decl.Variable.CreateBuilder (ec);
 			decl.Initializer.Emit (ec);
 			if (decl.Declarators != null) {
 				foreach (var d in decl.Declarators) {
 					d.Variable.CreateBuilder (ec);
 					d.Initializer.Emit (ec);
 				}
 				foreach (var d in decl.Declarators) {
 					d.Variable.CreateBuilder (ec);
 					d.Initializer.Emit (ec);
 				}
 			}
 
 			statement.Emit (ec);
 
 			if (has_ret)
 				return;
 
 			//
 			// Clear the pinned variable
 			//
 			((Emitter) decl.Initializer).EmitExit (ec);
 			if (decl.Declarators != null) {
 				foreach (var d in decl.Declarators) {
 					((Emitter)d.Initializer).EmitExit (ec);
 				}
 				foreach (var d in decl.Declarators) {
 					((Emitter)d.Initializer).EmitExit (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1597" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1544" endline="1618">
<![CDATA[
 
 		protected override void InitializeMemberCache (bool onlyTypes)
 		{
 			if (cache == null)
 				cache = new MemberCache (onlyTypes ? open_type.MemberCacheTypes 
 
 			var inflator = CreateLocalInflator ();
 
 			//
 			// Two stage inflate due to possible nested types recursive
 			// references
 			//
 			// class A<T> {
 			//    B b;
 			//    class B {
 			//      T Value;
 			//    }
 			// }
 			//
 			// When resolving type of `b' members of `B' cannot be 
 			// inflated because are not yet available in membercache
 			//
 			if ((state & StateFlags.PendingMemberCacheMembers) == 0) {
 				open_type.MemberCacheTypes.InflateTypes (cache, inflator);
 
 				//
 				// Inflate any implemented interfaces
 				//
 				if (open_type.Interfaces != null) {
 					ifaces = new List<TypeSpec> (open_type.Interfaces.Count);
 					foreach (var iface in open_type.Interfaces) {
 						var iface_inflated = inflator.Inflate (iface);
 						AddInterface (iface_inflated);
 					}
 					foreach (var iface in open_type.Interfaces) {
 						var iface_inflated = inflator.Inflate (iface);
 						AddInterface (iface_inflated);
 					}
 				}
 
 				//
 				// Handles the tricky case of recursive nested base generic type
 				//
 				// class A<T> 
 				//    class Nested {}
 				// }
 				//
 				// When inflating A<T>. base type is not yet known, secondary
 				// inflation is required (not common case) once base scope
 				// is known
 				//
 				if (open_type.BaseType == null) {
 					if (IsClass)
 						state |= StateFlags.PendingBaseTypeInflate;
 				} else {
 					BaseType = inflator.Inflate (open_type.BaseType);
 				}
 			} else if ((state & StateFlags.PendingBaseTypeInflate) != 0) {
 				BaseType = inflator.Inflate (open_type.BaseType);
 				state &= ~StateFlags.PendingBaseTypeInflate;
 			}
 
 			if (onlyTypes) {
 				state |= StateFlags.PendingMemberCacheMembers;
 				return;
 			}
 
 			var tc = open_type.MemberDefinition as TypeContainer;
 			if (tc != null && !tc.HasMembersDefined)
 				throw new InternalErrorException ("Inflating MemberCache with undefined members");
 
 			if ((state & StateFlags.PendingBaseTypeInflate) != 0) {
 				BaseType = inflator.Inflate (open_type.BaseType);
 				state &= ~StateFlags.PendingBaseTypeInflate;
 			}
 
 			state &= ~StateFlags.PendingMemberCacheMembers;
 			open_type.MemberCache.InflateMembers (cache, open_type, inflator);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1598" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="391" endline="464">
<![CDATA[
 
 		public void ResolveDefaultValue (ResolveContext rc)
 		{
 			//
 			// Default value was specified using an expression
 			//
 			if (default_expr != null) {
 				((DefaultParameterValueExpression)default_expr).Resolve (rc, this);
 				return;
 			}
 
 			if (attributes == null)
 				return;
 			
 			var opt_attr = attributes.Search (rc.Module.PredefinedAttributes.OptionalParameter);
 			var def_attr = attributes.Search (rc.Module.PredefinedAttributes.DefaultParameterValue);
 			if (def_attr != null) {
 				if (def_attr.Resolve () == null)
 					return;
 
 				var default_expr_attr = def_attr.GetParameterDefaultValue ();
 				if (default_expr_attr == null)
 					return;
 
 				var dpa_rc = def_attr.CreateResolveContext ();
 				default_expr = default_expr_attr.Resolve (dpa_rc);
 
 				if (default_expr is BoxedCast)
 					default_expr = ((BoxedCast) default_expr).Child;
 
 				Constant c = default_expr as Constant;
 				if (c == null) {
 					if (parameter_type == TypeManager.object_type) {
 						rc.Compiler.Report.Error (1910, default_expr.Location,
 							"Argument of type `{0}' is not applicable for the DefaultParameterValue attribute",
 							default_expr.Type.GetSignatureForError ());
 					} else {
 						rc.Compiler.Report.Error (1909, default_expr.Location,
 							"The DefaultParameterValue attribute is not applicable on parameters of type `{0}'",
 							default_expr.Type.GetSignatureForError ()); ;
 					}
 
 					default_expr = null;
 					return;
 				}
 
 				if (TypeSpecComparer.IsEqual (default_expr.Type, parameter_type) ||
 					(default_expr is NullConstant && TypeManager.IsReferenceType (parameter_type) && !parameter_type.IsGenericParameter) ||
 					TypeSpecComparer.IsEqual (parameter_type, TypeManager.object_type)) {
 					return;
 				}
 
 				//
 				// LAMESPEC
 				// User operators returning same type as parameter type are considered
 				// valid for this attribute only
 				//
 				// struct S { public static implicit operator S (int i) {} }
 				//
 				// void M ([DefaultParameterValue (3)]S s)
 				//
 				var expr = Convert.ImplicitUserConversion (dpa_rc, default_expr, parameter_type, loc);
 				if (expr != null && TypeSpecComparer.IsEqual (expr.Type, parameter_type)) {
 					return;
 				}
 				
 				rc.Compiler.Report.Error (1908, default_expr.Location, "The type of the default value should match the type of the parameter");
 				return;
 			}
 
 			if (opt_attr != null) {
 				default_expr = EmptyExpression.MissingValue;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1599" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2944" endline="2996">
<![CDATA[
 
 		//
 		// D operator + (D x, D y)
 		// D operator - (D x, D y)
 		//
 		Expression ResolveOperatorDelegate (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			if (l != r && !TypeSpecComparer.Variant.IsEqual (r, l)) {
 				Expression tmp;
 				if (right.eclass == ExprClass.MethodGroup || r == InternalType.AnonymousMethod || r == InternalType.Null) {
 					tmp = Convert.ImplicitConversionRequired (ec, right, l, loc);
 					if (tmp == null)
 						return null;
 					right = tmp;
 					r = right.Type;
 				} else if (left.eclass == ExprClass.MethodGroup || (l == InternalType.AnonymousMethod || l == InternalType.Null)) {
 					tmp = Convert.ImplicitConversionRequired (ec, left, r, loc);
 					if (tmp == null)
 						return null;
 					left = tmp;
 					l = left.Type;
 				} else {
 					return null;
 				}
 			}
 
 			MethodSpec method;
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (left));
 			args.Add (new Argument (right));
 
 			if (oper == Operator.Addition) {
 				if (TypeManager.delegate_combine_delegate_delegate == null) {
 					TypeManager.delegate_combine_delegate_delegate = TypeManager.GetPredefinedMethod (
 						TypeManager.delegate_type, "Combine", loc, TypeManager.delegate_type, TypeManager.delegate_type);
 				}
 
 				method = TypeManager.delegate_combine_delegate_delegate;
 			} else if (oper == Operator.Subtraction) {
 				if (TypeManager.delegate_remove_delegate_delegate == null) {
 					TypeManager.delegate_remove_delegate_delegate = TypeManager.GetPredefinedMethod (
 						TypeManager.delegate_type, "Remove", loc, TypeManager.delegate_type, TypeManager.delegate_type);
 				}
 
 				method = TypeManager.delegate_remove_delegate_delegate;
 			} else {
 				return new EmptyExpression (TypeManager.decimal_type);
 			}
 
 			MethodGroupExpr mg = MethodGroupExpr.CreatePredefined (method, TypeManager.delegate_type, loc);
 			Expression expr = new UserOperatorCall (mg.BestCandidate, args, CreateExpressionTree, loc);
 			return new ClassCast (expr, l);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1600" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4210" endline="4241">
<![CDATA[
 
 		int ResolvePredefinedMethods (ResolveContext rc)
 		{
 			if (TypeManager.void_monitor_enter_object == null || TypeManager.void_monitor_exit_object == null) {
 				TypeSpec monitor_type = rc.Module.PredefinedTypes.Monitor.Resolve (loc);
 
 				if (monitor_type == null)
 					return 0;
 
 				// Try 4.0 Monitor.Enter (object, ref bool) overload first
 				var filter = MemberFilter.Method ("Enter", 0, new ParametersImported (
 					new[] {
 							new ParameterData (null, Parameter.Modifier.NONE),
 							new ParameterData (null, Parameter.Modifier.REF)
 						},
 					new[] {
 							TypeManager.object_type,
 							TypeManager.bool_type
 						}, false), null);
 
 				TypeManager.void_monitor_enter_object = TypeManager.GetPredefinedMethod (monitor_type, filter, true, loc);
 				if (TypeManager.void_monitor_enter_object == null) {
 					TypeManager.void_monitor_enter_object = TypeManager.GetPredefinedMethod (
 						monitor_type, "Enter", loc, TypeManager.object_type);
 				}
 
 				TypeManager.void_monitor_exit_object = TypeManager.GetPredefinedMethod (
 					monitor_type, "Exit", loc, TypeManager.object_type);
 			}
 
 			return TypeManager.void_monitor_enter_object.Parameters.Count;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1601" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1679" endline="1756">
<![CDATA[
 
 		public static AnonymousTypeClass Create (CompilerContext ctx, TypeContainer parent, IList<AnonymousTypeParameter> parameters, Location loc)
 		{
 			string name = ClassNamePrefix + types_counter++;
 
 			ParametersCompiled all_parameters;
 			TypeParameterName[] t_params;
 			SimpleName[] t_args;
 
 			if (parameters.Count == 0) {
 				all_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 				t_params = new TypeParameterName[0];
 				t_args = null;
 			} else {
 				t_args = new SimpleName[parameters.Count];
 				t_params = new TypeParameterName[parameters.Count];
 				Parameter[] ctor_params = new Parameter[parameters.Count];
 				for (int i = 0; i < parameters.Count; ++i) {
 					AnonymousTypeParameter p = parameters[i];
 
 					t_args[i] = new SimpleName ("<" + p.Name + ">__T", p.Location);
 					t_params[i] = new TypeParameterName (t_args[i].Name, null, p.Location);
 					ctor_params[i] = new GeneratedParameter (t_args[i], p);
 				}
 				for (int i = 0; i < parameters.Count; ++i) {
 					AnonymousTypeParameter p = parameters[i];
 
 					t_args[i] = new SimpleName ("<" + p.Name + ">__T", p.Location);
 					t_params[i] = new TypeParameterName (t_args[i].Name, null, p.Location);
 					ctor_params[i] = new GeneratedParameter (t_args[i], p);
 				}
 
 				all_parameters = new ParametersCompiled (ctor_params);
 			}
 
 			//
 			// Create generic anonymous type host with generic arguments
 			// named upon properties names
 			//
 			AnonymousTypeClass a_type = new AnonymousTypeClass (parent.NamespaceEntry.SlaveDeclSpace,
 				new MemberName (name, new TypeArguments (t_params), loc), parameters, loc);
 
 			if (parameters.Count > 0)
 				a_type.SetParameterInfo (null);
 
 			Constructor c = new Constructor (a_type, name, Modifiers.PUBLIC | Modifiers.DEBUGGER_HIDDEN,
 				null, all_parameters, null, loc);
 			c.Block = new ToplevelBlock (ctx, c.ParameterInfo, loc);
 
 			// 
 			// Create fields and contructor body with field initialization
 			//
 			bool error = false;
 			for (int i = 0; i < parameters.Count; ++i) {
 				AnonymousTypeParameter p = parameters [i];
 
 				Field f = new Field (a_type, t_args [i], Modifiers.PRIVATE | Modifiers.READONLY,
 					new MemberName ("<" + p.Name + ">", p.Location), null);
 
 				if (!a_type.AddField (f)) {
 					error = true;
 					continue;
 				}
 
 				c.Block.AddStatement (new StatementExpression (
 					new SimpleAssign (new MemberAccess (new This (p.Location), f.Name),
 						c.Block.GetParameterReference (i, p.Location))));
 
 				ToplevelBlock get_block = new ToplevelBlock (ctx, p.Location);
 				get_block.AddStatement (new Return (
 					new MemberAccess (new This (p.Location), f.Name), p.Location));
 
 				Property prop = new Property (a_type, t_args [i], Modifiers.PUBLIC,
 					new MemberName (p.Name, p.Location), null);
 				prop.Get = new Property.GetMethod (prop, 0, null, p.Location);
 				prop.Get.Block = get_block;
 				a_type.AddProperty (prop);
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				AnonymousTypeParameter p = parameters [i];
 
 				Field f = new Field (a_type, t_args [i], Modifiers.PRIVATE | Modifiers.READONLY,
 					new MemberName ("<" + p.Name + ">", p.Location), null);
 
 				if (!a_type.AddField (f)) {
 					error = true;
 					continue;
 				}
 
 				c.Block.AddStatement (new StatementExpression (
 					new SimpleAssign (new MemberAccess (new This (p.Location), f.Name),
 						c.Block.GetParameterReference (i, p.Location))));
 
 				ToplevelBlock get_block = new ToplevelBlock (ctx, p.Location);
 				get_block.AddStatement (new Return (
 					new MemberAccess (new This (p.Location), f.Name), p.Location));
 
 				Property prop = new Property (a_type, t_args [i], Modifiers.PUBLIC,
 					new MemberName (p.Name, p.Location), null);
 				prop.Get = new Property.GetMethod (prop, 0, null, p.Location);
 				prop.Get.Block = get_block;
 				a_type.AddProperty (prop);
 			}
 
 			if (error)
 				return null;
 
 			a_type.AddConstructor (c);
 			return a_type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1602" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="585" endline="645">
<![CDATA[
 
 		public void Resolve ()
 		{
 			if (RootContext.Unsafe && module.PredefinedTypes.SecurityAction.Define ()) {
 				//
 				// Emits [assembly
 				// when -unsafe option was specified
 				//
 				Location loc = Location.Null;
 
 				MemberAccess system_security_permissions = new MemberAccess (new MemberAccess (
 					new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Security", loc), "Permissions", loc);
 
 				var req_min = (ConstSpec) module.PredefinedTypes.SecurityAction.GetField ("RequestMinimum", module.PredefinedTypes.SecurityAction.TypeSpec, loc);
 
 				Arguments pos = new Arguments (1);
 				pos.Add (new Argument (req_min.GetConstant (null)));
 
 				Arguments named = new Arguments (1);
 				named.Add (new NamedArgument ("SkipVerification", loc, new BoolLiteral (true, loc)));
 
 				GlobalAttribute g = new GlobalAttribute (new NamespaceEntry (module, null, null, null), "assembly",
 					new MemberAccess (system_security_permissions, "SecurityPermissionAttribute"),
 					new Arguments[] { pos, named }, loc, false);
 				g.AttachTo (module, module);
 				var ctor = g.Resolve ();
 				if (ctor != null) {
 					g.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				}
 			}
 
 			if (module.OptAttributes == null)
 				return;
 
 			// Ensure that we only have GlobalAttributes, since the Search isn't safe with other types.
 			if (!module.OptAttributes.CheckTargets())
 				return;
 
 			cls_attribute = module.ResolveAssemblyAttribute (module.PredefinedAttributes.CLSCompliant);
 
 			if (cls_attribute != null) {
 				is_cls_compliant = cls_attribute.GetClsCompliantAttributeValue ();
 			}
 
 			if (added_modules != null && RootContext.VerifyClsCompliance && is_cls_compliant) {
 				foreach (var m in added_modules) {
 					if (!m.IsCLSCompliant) {
 						Report.Error (3013,
 							"Added modules must be marked with the CLSCompliant attribute to match the assembly",
 							m.Name);
 					}
 				}
 				foreach (var m in added_modules) {
 					if (!m.IsCLSCompliant) {
 						Report.Error (3013,
 							"Added modules must be marked with the CLSCompliant attribute to match the assembly",
 							m.Name);
 					}
 				}
 			}
 
 			Attribute a = module.ResolveAssemblyAttribute (module.PredefinedAttributes.RuntimeCompatibility);
 			if (a != null) {
 				var val = a.GetNamedValue ("WrapNonExceptionThrows") as BoolConstant;
 				if (val != null)
 					wrap_non_exception_throws = val.Value;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1603" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4867" endline="4934">
<![CDATA[
 
 		Expression DoResolve (ResolveContext ec, Expression rhs)
 		{
 			bool lvalue_instance = rhs != null && IsInstance && spec.DeclaringType.IsStruct;
 
 			if (ResolveInstanceExpression (ec, rhs)) {
 				// Resolve the field's instance expression while flow analysis is turned
 				// off
 				// "a.b" is initialized, not whether the whole struct "a" is initialized.
 
 				if (lvalue_instance) {
 					using (ec.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 						bool out_access = rhs == EmptyExpression.OutAccess.Instance || rhs == EmptyExpression.LValueMemberOutAccess;
 
 						Expression right_side =
 							out_access ? EmptyExpression.LValueMemberOutAccess 
 
 						InstanceExpression = InstanceExpression.ResolveLValue (ec, right_side);
 					}
 				} else {
 					using (ec.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 						InstanceExpression = InstanceExpression.Resolve (ec, ResolveFlags.VariableOrValue);
 					}
 				}
 
 				if (InstanceExpression == null)
 					return null;
 			}
 
 			DoBestMemberChecks (ec, spec);
 
 			var fb = spec as FixedFieldSpec;
 			IVariableReference var = InstanceExpression as IVariableReference;
 
 			if (lvalue_instance && var != null && var.VariableInfo != null) {
 				var.VariableInfo.SetFieldAssigned (ec, Name);
 			}
 			
 			if (fb != null) {
 				IFixedExpression fe = InstanceExpression as IFixedExpression;
 				if (!ec.HasSet (ResolveContext.Options.FixedInitializerScope) && (fe == null || !fe.IsFixed)) {
 					ec.Report.Error (1666, loc, "You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement");
 				}
 
 				if (InstanceExpression.eclass != ExprClass.Variable) {
 					ec.Report.SymbolRelatedToPreviousError (spec);
 					ec.Report.Error (1708, loc, "`{0}'
 						TypeManager.GetFullNameSignature (spec));
 				} else if (var != null && var.IsHoisted) {
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, var, loc);
 				}
 				
 				return new FixedBufferPtr (this, fb.ElementType, loc).Resolve (ec);
 			}
 
 			eclass = ExprClass.Variable;
 
 			// If the instance expression is a local variable or parameter.
 			if (var == null || var.VariableInfo == null)
 				return this;
 
 			VariableInfo vi = var.VariableInfo;
 			if (!vi.IsFieldAssigned (ec, Name, loc))
 				return null;
 
 			variable_info = vi.GetSubStruct (Name);
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1604" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="102" endline="185">
<![CDATA[
 		}
 
 		protected override bool DoDefineMembers ()
 		{
 			var ctor_parameters = ParametersCompiled.CreateFullyResolved (
 				new [] {
 					new Parameter (new TypeExpression (TypeManager.object_type, Location), "object", Parameter.Modifier.NONE, null, Location),
 					new Parameter (new TypeExpression (TypeManager.intptr_type, Location), "method", Parameter.Modifier.NONE, null, Location)
 				},
 				new [] {
 					TypeManager.object_type,
 					TypeManager.intptr_type
 				}
 			);
 
 			Constructor = new Constructor (this, Constructor.ConstructorName,
 				Modifiers.PUBLIC, null, ctor_parameters, null, Location);
 			Constructor.Define ();
 
 			//
 			// Here the various methods like Invoke, BeginInvoke etc are defined
 			//
 			// First, call the `out of band' special method for
 			// defining recursively any types we need
 			//
 			var p = parameters;
 
 			if (!p.Resolve (this))
 				return false;
 
 			//
 			// Invoke method
 			//
 
 			// Check accessibility
 			foreach (var partype in p.Types) {
 				if (!IsAccessibleAs (partype)) {
 					Report.SymbolRelatedToPreviousError (partype);
 					Report.Error (59, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (partype), GetSignatureForError ());
 				}
 			}
 			foreach (var partype in p.Types) {
 				if (!IsAccessibleAs (partype)) {
 					Report.SymbolRelatedToPreviousError (partype);
 					Report.Error (59, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (partype), GetSignatureForError ());
 				}
 			}
 
 			ReturnType = ReturnType.ResolveAsTypeTerminal (this, false);
 			if (ReturnType == null)
 				return false;
 
 			var ret_type = ReturnType.Type;
 
 			//
 			// We don't have to check any others because they are all
 			// guaranteed to be accessible - they are standard types.
 			//
 			if (!IsAccessibleAs (ret_type)) {
 				Report.SymbolRelatedToPreviousError (ret_type);
 				Report.Error (58, Location,
 						  "Inconsistent accessibility
 						  TypeManager.CSharpName (ret_type) + "' is less " +
 						  "accessible than delegate `" + GetSignatureForError () + "'");
 				return false;
 			}
 
 			CheckProtectedModifier ();
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ret_type)) {
 				Method.Error1599 (Location, ret_type, Report);
 				return false;
 			}
 
 			TypeManager.CheckTypeVariance (ret_type, Variance.Covariant, this);
 
 			InvokeBuilder = new Method (this, null, ReturnType, MethodModifiers, new MemberName (InvokeMethodName), p, null);
 			InvokeBuilder.Define ();
 
 			//
 			// Don't emit async method for compiler generated delegates (e.g. dynamic site containers)
 			//
 			if (!IsCompilerGenerated) {
 				DefineAsyncMethods (Parameters.CallingConvention);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1605" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="747" endline="806">
<![CDATA[
 
 		/// <summary>
 		/// The main virtual method for CLS-Compliant verifications.
 		/// The method returns true if member is CLS-Compliant and false if member is not
 		/// CLS-Compliant which means that CLS-Compliant tests are not necessary. A descendants override it
 		/// and add their extra verifications.
 		/// </summary>
 		protected virtual bool VerifyClsCompliance ()
 		{
 			if (HasClsCompliantAttribute) {
 				if (!Module.DeclaringAssembly.HasCLSCompliantAttribute) {
 					Attribute a = OptAttributes.Search (Module.PredefinedAttributes.CLSCompliant);
 					if ((caching_flags & Flags.ClsCompliantAttributeFalse) != 0) {
 						Report.Warning (3021, 2, a.Location,
 							"`{0}' does not need a CLSCompliant attribute because the assembly is not marked as CLS-compliant",
 							GetSignatureForError ());
 					} else {
 						Report.Warning (3014, 1, a.Location,
 							"`{0}' cannot be marked as CLS-compliant because the assembly is not marked as CLS-compliant",
 							GetSignatureForError ());
 					}
 					return false;
 				}
 
 				if (!IsExposedFromAssembly ()) {
 					Attribute a = OptAttributes.Search (Module.PredefinedAttributes.CLSCompliant);
 					Report.Warning (3019, 2, a.Location, "CLS compliance checking will not be performed on `{0}' because it is not visible from outside this assembly", GetSignatureForError ());
 					return false;
 				}
 
 				if ((caching_flags & Flags.ClsCompliantAttributeFalse) != 0) {
 					if (Parent.Kind == MemberKind.Interface && Parent.IsClsComplianceRequired ()) {
 						Report.Warning (3010, 1, Location, "`{0}'
 					} else if (Parent.Kind == MemberKind.Class && (ModFlags & Modifiers.ABSTRACT) != 0 && Parent.IsClsComplianceRequired ()) {
 						Report.Warning (3011, 1, Location, "`{0}'
 					}
 
 					return false;
 				}
 
 				if (Parent.Parent != null && !Parent.IsClsComplianceRequired ()) {
 					Attribute a = OptAttributes.Search (Module.PredefinedAttributes.CLSCompliant);
 					Report.Warning (3018, 1, a.Location, "`{0}' cannot be marked as CLS-compliant because it is a member of non CLS-compliant type `{1}'",
 						GetSignatureForError (), Parent.GetSignatureForError ());
 					return false;
 				}
 			} else {
 				if (!IsExposedFromAssembly ())
 					return false;
 
 				if (!Parent.PartialContainer.IsClsComplianceRequired ())
 					return false;
 			}
 
 			if (member_name.Name [0] == '_') {
 				Report.Warning (3008, 1, Location, "Identifier `{0}' is not CLS-compliant", GetSignatureForError () );
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1606" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3710" endline="3771">
<![CDATA[
 
 		void ResolveStringSwitchMap (ResolveContext ec)
 		{
 			FullNamedExpression string_dictionary_type;
 			if (TypeManager.generic_ienumerable_type != null) {
 				MemberAccess system_collections_generic = new MemberAccess (new MemberAccess (
 					new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Collections", loc), "Generic", loc);
 
 				string_dictionary_type = new MemberAccess (system_collections_generic, "Dictionary",
 					new TypeArguments (
 						new TypeExpression (TypeManager.string_type, loc),
 						new TypeExpression (TypeManager.int32_type, loc)), loc);
 			} else {
 				MemberAccess system_collections_generic = new MemberAccess (
 					new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Collections", loc);
 
 				string_dictionary_type = new MemberAccess (system_collections_generic, "Hashtable", loc);
 			}
 
 			var ctype = ec.CurrentMemberDefinition.Parent.PartialContainer;
 			Field field = new Field (ctype, string_dictionary_type,
 				Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.COMPILER_GENERATED,
 				new MemberName (CompilerGeneratedClass.MakeName (null, "f", "switch$map", unique_counter++), loc), null);
 			if (!field.Define ())
 				return;
 			ctype.AddField (field);
 
 			var init = new List<Expression> ();
 			int counter = 0;
 			Elements.Clear ();
 			string value = null;
 			foreach (SwitchSection section in Sections) {
 				int last_count = init.Count;
 				foreach (SwitchLabel sl in section.Labels) {
 					if (sl.Label == null || sl.Converted == SwitchLabel.NullStringCase)
 						continue;
 
 					value = (string) sl.Converted;
 					var init_args = new List<Expression> (2);
 					init_args.Add (new StringLiteral (value, sl.Location));
 					init_args.Add (new IntConstant (counter, loc));
 					init.Add (new CollectionElementInitializer (init_args, loc));
 				}
 				foreach (SwitchLabel sl in section.Labels) {
 					if (sl.Label == null || sl.Converted == SwitchLabel.NullStringCase)
 						continue;
 
 					value = (string) sl.Converted;
 					var init_args = new List<Expression> (2);
 					init_args.Add (new StringLiteral (value, sl.Location));
 					init_args.Add (new IntConstant (counter, loc));
 					init.Add (new CollectionElementInitializer (init_args, loc));
 				}
 
 				//
 				// Don't add empty sections
 				//
 				if (last_count == init.Count)
 					continue;
 
 				Elements.Add (counter, section.Labels [0]);
 				++counter;
 			}
 			foreach (SwitchSection section in Sections) {
 				int last_count = init.Count;
 				foreach (SwitchLabel sl in section.Labels) {
 					if (sl.Label == null || sl.Converted == SwitchLabel.NullStringCase)
 						continue;
 
 					value = (string) sl.Converted;
 					var init_args = new List<Expression> (2);
 					init_args.Add (new StringLiteral (value, sl.Location));
 					init_args.Add (new IntConstant (counter, loc));
 					init.Add (new CollectionElementInitializer (init_args, loc));
 				}
 
 				//
 				// Don't add empty sections
 				//
 				if (last_count == init.Count)
 					continue;
 
 				Elements.Add (counter, section.Labels [0]);
 				++counter;
 			}
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (new IntConstant (init.Count, loc)));
 			Expression initializer = new NewInitialize (string_dictionary_type, args,
 				new CollectionOrObjectInitializers (init, loc), loc);
 
 			switch_cache_field = new FieldExpr (field, loc);
 			string_dictionary = new SimpleAssign (switch_cache_field, initializer.Resolve (ec));
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1607" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1686" endline="1800">
<![CDATA[
 	}
 
 	//
 	// Predefined attribute types
 	//
 	public class PredefinedAttributes
 	{
 		// Build-in attributes
 		public readonly PredefinedAttribute ParamArray;
 		public readonly PredefinedAttribute Out;
 
 		// Optional attributes
 		public readonly PredefinedAttribute Obsolete;
 		public readonly PredefinedAttribute DllImport;
 		public readonly PredefinedAttribute MethodImpl;
 		public readonly PredefinedAttribute MarshalAs;
 		public readonly PredefinedAttribute In;
 		public readonly PredefinedAttribute IndexerName;
 		public readonly PredefinedAttribute Conditional;
 		public readonly PredefinedAttribute CLSCompliant;
 		public readonly PredefinedAttribute Security;
 		public readonly PredefinedAttribute Required;
 		public readonly PredefinedAttribute Guid;
 		public readonly PredefinedAttribute AssemblyCulture;
 		public readonly PredefinedAttribute AssemblyVersion;
 		public readonly PredefinedAttribute AssemblyAlgorithmId;
 		public readonly PredefinedAttribute AssemblyFlags;
 		public readonly PredefinedAttribute AssemblyFileVersion;
 		public readonly PredefinedAttribute ComImport;
 		public readonly PredefinedAttribute CoClass;
 		public readonly PredefinedAttribute AttributeUsage;
 		public readonly PredefinedAttribute DefaultParameterValue;
 		public readonly PredefinedAttribute OptionalParameter;
 		public readonly PredefinedAttribute UnverifiableCode;
 
 		// New in .NET 2.0
 		//public readonly PredefinedAttribute DefaultCharset;
 		public readonly PredefinedAttribute TypeForwarder;
 		public readonly PredefinedAttribute FixedBuffer;
 		public readonly PredefinedAttribute CompilerGenerated;
 		public readonly PredefinedAttribute InternalsVisibleTo;
 		public readonly PredefinedAttribute RuntimeCompatibility;
 		public readonly PredefinedAttribute DebuggerHidden;
 		public readonly PredefinedAttribute UnsafeValueType;
 
 		// New in .NET 3.5
 		public readonly PredefinedAttribute Extension;
 
 		// New in .NET 4.0
 		public readonly PredefinedDynamicAttribute Dynamic;
 
 		//
 		// Optional types which are used as types and for member lookup
 		//
 		public readonly PredefinedAttribute DefaultMember;
 		public readonly PredefinedDecimalAttribute DecimalConstant;
 		public readonly PredefinedAttribute StructLayout;
 		public readonly PredefinedAttribute FieldOffset;
 
 		public PredefinedAttributes (ModuleContainer module)
 		{
 			ParamArray = new PredefinedAttribute (module, "System", "ParamArrayAttribute");
 			Out = new PredefinedAttribute (module, "System.Runtime.InteropServices", "OutAttribute");
 			ParamArray.Resolve (Location.Null);
 			Out.Resolve (Location.Null);
 
 			Obsolete = new PredefinedAttribute (module, "System", "ObsoleteAttribute");
 			DllImport = new PredefinedAttribute (module, "System.Runtime.InteropServices", "DllImportAttribute");
 			MethodImpl = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "MethodImplAttribute");
 			MarshalAs = new PredefinedAttribute (module, "System.Runtime.InteropServices", "MarshalAsAttribute");
 			In = new PredefinedAttribute (module, "System.Runtime.InteropServices", "InAttribute");
 			IndexerName = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "IndexerNameAttribute");
 			Conditional = new PredefinedAttribute (module, "System.Diagnostics", "ConditionalAttribute");
 			CLSCompliant = new PredefinedAttribute (module, "System", "CLSCompliantAttribute");
 			Security = new PredefinedAttribute (module, "System.Security.Permissions", "SecurityAttribute");
 			Required = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "RequiredAttributeAttribute");
 			Guid = new PredefinedAttribute (module, "System.Runtime.InteropServices", "GuidAttribute");
 			AssemblyCulture = new PredefinedAttribute (module, "System.Reflection", "AssemblyCultureAttribute");
 			AssemblyVersion = new PredefinedAttribute (module, "System.Reflection", "AssemblyVersionAttribute");
 			AssemblyAlgorithmId = new PredefinedAttribute (module, "System.Reflection", "AssemblyAlgorithmIdAttribute");
 			AssemblyFlags = new PredefinedAttribute (module, "System.Reflection", "AssemblyFlagsAttribute");
 			AssemblyFileVersion = new PredefinedAttribute (module, "System.Reflection", "AssemblyFileVersionAttribute");
 			ComImport = new PredefinedAttribute (module, "System.Runtime.InteropServices", "ComImportAttribute");
 			CoClass = new PredefinedAttribute (module, "System.Runtime.InteropServices", "CoClassAttribute");
 			AttributeUsage = new PredefinedAttribute (module, "System", "AttributeUsageAttribute");
 			DefaultParameterValue = new PredefinedAttribute (module, "System.Runtime.InteropServices", "DefaultParameterValueAttribute");
 			OptionalParameter = new PredefinedAttribute (module, "System.Runtime.InteropServices", "OptionalAttribute");
 			UnverifiableCode = new PredefinedAttribute (module, "System.Security", "UnverifiableCodeAttribute");
 
 			//DefaultCharset = new PredefinedAttribute (module, "System.Runtime.InteropServices", "DefaultCharSetAttribute");
 			TypeForwarder = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "TypeForwardedToAttribute");
 			FixedBuffer = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "FixedBufferAttribute");
 			CompilerGenerated = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "CompilerGeneratedAttribute");
 			InternalsVisibleTo = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "InternalsVisibleToAttribute");
 			RuntimeCompatibility = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "RuntimeCompatibilityAttribute");
 			DebuggerHidden = new PredefinedAttribute (module, "System.Diagnostics", "DebuggerHiddenAttribute");
 			UnsafeValueType = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "UnsafeValueTypeAttribute");
 
 			Extension = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "ExtensionAttribute");
 
 			Dynamic = new PredefinedDynamicAttribute (module, "System.Runtime.CompilerServices", "DynamicAttribute");
 
 			DefaultMember = new PredefinedAttribute (module, "System.Reflection", "DefaultMemberAttribute");
 			DecimalConstant = new PredefinedDecimalAttribute (module, "System.Runtime.CompilerServices", "DecimalConstantAttribute");
 			StructLayout = new PredefinedAttribute (module, "System.Runtime.InteropServices", "StructLayoutAttribute");
 			FieldOffset = new PredefinedAttribute (module, "System.Runtime.InteropServices", "FieldOffsetAttribute");
 
 			// TODO
 			const System.Reflection.BindingFlags all_fields = System.Reflection.BindingFlags.Public |
 				System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.DeclaredOnly;
 
 			foreach (var fi in GetType ().GetFields (all_fields)) {
 				((PredefinedAttribute) fi.GetValue (this)).Define ();
 			}
 			foreach (var fi in GetType ().GetFields (all_fields)) {
 				((PredefinedAttribute) fi.GetValue (this)).Define ();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1608" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="400" endline="430">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			//
 			// It's null when lifting non-nullable type
 			//
 			if (unwrap == null) {
 				// S -> T? is wrap only
 				if (TypeManager.IsNullableType (type))
 					return Wrap.Create (expr, type);
 
 				// S -> T can be simplified
 				return expr;
 			}
 
 			// Wrap target for T?
 			if (TypeManager.IsNullableType (type)) {
 				expr = Wrap.Create (expr, type);
 				if (expr == null)
 					return null;
 
 				null_value = LiftedNull.Create (type, loc);
 			} else if (TypeManager.IsValueType (type)) {
 				null_value = LiftedNull.Create (type, loc);
 			} else {
 				null_value = new NullConstant (type, loc);
 			}
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1609" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1051" endline="1136">
<![CDATA[
 
 		//
 		// Creates a proxy base method call inside this container for hoisted base member calls
 		//
 		public MethodSpec CreateHoistedBaseCallProxy (ResolveContext rc, MethodSpec method)
 		{
 			Method proxy_method;
 
 			//
 			// One proxy per base method is enough
 			//
 			if (hoisted_base_call_proxies == null) {
 				hoisted_base_call_proxies = new Dictionary<MethodSpec, Method> ();
 				proxy_method = null;
 			} else {
 				hoisted_base_call_proxies.TryGetValue (method, out proxy_method);
 			}
 
 			if (proxy_method == null) {
 				string name = CompilerGeneratedClass.MakeName (method.Name, null, "BaseCallProxy", hoisted_base_call_proxies.Count);
 				var base_parameters = new Parameter[method.Parameters.Count];
 				for (int i = 0; i < base_parameters.Length; ++i) {
 					var base_param = method.Parameters.FixedParameters[i];
 					base_parameters[i] = new Parameter (new TypeExpression (method.Parameters.Types[i], Location),
 						base_param.Name, base_param.ModFlags, null, Location);
 					base_parameters[i].Resolve (this, i);
 				}
 				for (int i = 0; i < base_parameters.Length; ++i) {
 					var base_param = method.Parameters.FixedParameters[i];
 					base_parameters[i] = new Parameter (new TypeExpression (method.Parameters.Types[i], Location),
 						base_param.Name, base_param.ModFlags, null, Location);
 					base_parameters[i].Resolve (this, i);
 				}
 
 				var cloned_params = ParametersCompiled.CreateFullyResolved (base_parameters, method.Parameters.Types);
 				if (method.Parameters.HasArglist) {
 					cloned_params.FixedParameters[0] = new Parameter (null, "__arglist", Parameter.Modifier.NONE, null, Location);
 					cloned_params.Types[0] = Module.PredefinedTypes.RuntimeArgumentHandle.Resolve (Location);
 				}
 
 				GenericMethod generic_method;
 				MemberName member_name;
 				if (method.IsGeneric) {
 					//
 					// Copy all base generic method type parameters info
 					//
 					var hoisted_tparams = method.GenericDefinition.TypeParameters;
 					var targs = new TypeArguments ();
 					var type_params = new TypeParameter[hoisted_tparams.Length];
 					for (int i = 0; i < type_params.Length; ++i) {
 						var tp = hoisted_tparams[i];
 						targs.Add (new TypeParameterName (tp.Name, null, Location));
 						type_params[i] = new TypeParameter (tp, null, null, new MemberName (tp.Name), null);
 					}
 					for (int i = 0; i < type_params.Length; ++i) {
 						var tp = hoisted_tparams[i];
 						targs.Add (new TypeParameterName (tp.Name, null, Location));
 						type_params[i] = new TypeParameter (tp, null, null, new MemberName (tp.Name), null);
 					}
 
 					member_name = new MemberName (name, targs, Location);
 					generic_method = new GenericMethod (NamespaceEntry, this, member_name, type_params,
 						new TypeExpression (method.ReturnType, Location), cloned_params);
 				} else {
 					member_name = new MemberName (name);
 					generic_method = null;
 				}
 
 				// Compiler generated proxy
 				proxy_method = new Method (this, generic_method, new TypeExpression (method.ReturnType, Location),
 					Modifiers.PRIVATE | Modifiers.COMPILER_GENERATED | Modifiers.DEBUGGER_HIDDEN,
 					member_name, cloned_params, null);
 
 				var block = new ToplevelBlock (Compiler, proxy_method.ParameterInfo, Location);
 
 				var mg = MethodGroupExpr.CreatePredefined (method, method.DeclaringType, Location);
 				mg.InstanceExpression = new BaseThis (method.DeclaringType, Location);
 
 				// Get all the method parameters and pass them as arguments
 				var real_base_call = new Invocation (mg, block.GetAllParametersArguments ());
 				Statement statement;
 				if (method.ReturnType == TypeManager.void_type)
 					statement = new StatementExpression (real_base_call);
 				else
 					statement = new Return (real_base_call, Location);
 
 				block.AddStatement (statement);
 				proxy_method.Block = block;
 
 				methods.Add (proxy_method);
 				proxy_method.Define ();
 
 				hoisted_base_call_proxies.Add (method, proxy_method);
 			}
 
 			return proxy_method.Spec;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1610" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="188" endline="304">
<![CDATA[
 	}
 
 	//
 	// Compiler predefined types. Usually used for compiler generated
 	// code or for comparison against well known framework type
 	//
 	class PredefinedTypes
 	{
 		// TODO
 		public readonly PredefinedType TypedReference;
 		public readonly PredefinedType ArgIterator;
 
 		public readonly PredefinedType MarshalByRefObject;
 		public readonly PredefinedType RuntimeHelpers;
 		public readonly PredefinedType IAsyncResult;
 		public readonly PredefinedType AsyncCallback;
 		public readonly PredefinedType RuntimeArgumentHandle;
 		public readonly PredefinedType CharSet;
 		public readonly PredefinedType IsVolatile;
 		public readonly PredefinedType IEnumeratorGeneric;
 		public readonly PredefinedType IListGeneric;
 		public readonly PredefinedType ICollectionGeneric;
 		public readonly PredefinedType IEnumerableGeneric;
 		public readonly PredefinedType Nullable;
 		public readonly PredefinedType Activator;
 		public readonly PredefinedType Interlocked;
 		public readonly PredefinedType Monitor;
 		public readonly PredefinedType NotSupportedException;
 		public readonly PredefinedType RuntimeFieldHandle;
 		public readonly PredefinedType RuntimeMethodHandle;
 		public readonly PredefinedType SecurityAction;
 
 		//
 		// C# 3.0
 		//
 		public readonly PredefinedType Expression;
 		public readonly PredefinedType ExpressionGeneric;
 		public readonly PredefinedType ParameterExpression;
 		public readonly PredefinedType FieldInfo;
 		public readonly PredefinedType MethodBase;
 		public readonly PredefinedType MethodInfo;
 		public readonly PredefinedType ConstructorInfo;
 
 		//
 		// C# 4.0
 		//
 		public readonly PredefinedType Binder;
 		public readonly PredefinedType CallSite;
 		public readonly PredefinedType CallSiteGeneric;
 		public readonly PredefinedType BinderFlags;
 
 		public PredefinedTypes (ModuleContainer module)
 		{
 			TypedReference = new PredefinedType (module, MemberKind.Struct, "System", "TypedReference");
 			ArgIterator = new PredefinedType (module, MemberKind.Struct, "System", "ArgIterator");
 			MarshalByRefObject = new PredefinedType (module, MemberKind.Class, "System", "MarshalByRefObject");
 			RuntimeHelpers = new PredefinedType (module, MemberKind.Class, "System.Runtime.CompilerServices", "RuntimeHelpers");
 			IAsyncResult = new PredefinedType (module, MemberKind.Interface, "System", "IAsyncResult");
 			AsyncCallback = new PredefinedType (module, MemberKind.Delegate, "System", "AsyncCallback");
 			RuntimeArgumentHandle = new PredefinedType (module, MemberKind.Struct, "System", "RuntimeArgumentHandle");
 			CharSet = new PredefinedType (module, MemberKind.Enum, "System.Runtime.InteropServices", "CharSet");
 			IsVolatile = new PredefinedType (module, MemberKind.Class, "System.Runtime.CompilerServices", "IsVolatile");
 			IEnumeratorGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "IEnumerator", 1);
 			IListGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "IList", 1);
 			ICollectionGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "ICollection", 1);
 			IEnumerableGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "IEnumerable", 1);
 			Nullable = new PredefinedType (module, MemberKind.Struct, "System", "Nullable", 1);
 			Activator = new PredefinedType (module, MemberKind.Class, "System", "Activator");
 			Interlocked = new PredefinedType (module, MemberKind.Class, "System.Threading", "Interlocked");
 			Monitor = new PredefinedType (module, MemberKind.Class, "System.Threading", "Monitor");
 			NotSupportedException = new PredefinedType (module, MemberKind.Class, "System", "NotSupportedException");
 			RuntimeFieldHandle = new PredefinedType (module, MemberKind.Struct, "System", "RuntimeFieldHandle");
 			RuntimeMethodHandle = new PredefinedType (module, MemberKind.Struct, "System", "RuntimeMethodHandle");
 			SecurityAction = new PredefinedType (module, MemberKind.Enum, "System.Security.Permissions", "SecurityAction");
 
 			Expression = new PredefinedType (module, MemberKind.Class, "System.Linq.Expressions", "Expression");
 			ExpressionGeneric = new PredefinedType (module, MemberKind.Class, "System.Linq.Expressions", "Expression", 1);
 			ParameterExpression = new PredefinedType (module, MemberKind.Class, "System.Linq.Expressions", "ParameterExpression");
 			FieldInfo = new PredefinedType (module, MemberKind.Class, "System.Reflection", "FieldInfo");
 			MethodBase = new PredefinedType (module, MemberKind.Class, "System.Reflection", "MethodBase");
 			MethodInfo = new PredefinedType (module, MemberKind.Class, "System.Reflection", "MethodInfo");
 			ConstructorInfo = new PredefinedType (module, MemberKind.Class, "System.Reflection", "ConstructorInfo");
 
 			CallSite = new PredefinedType (module, MemberKind.Class, "System.Runtime.CompilerServices", "CallSite");
 			CallSiteGeneric = new PredefinedType (module, MemberKind.Class, "System.Runtime.CompilerServices", "CallSite", 1);
 			Binder = new PredefinedType (module, MemberKind.Class, "Microsoft.CSharp.RuntimeBinder", "Binder");
 			BinderFlags = new PredefinedType (module, MemberKind.Enum, "Microsoft.CSharp.RuntimeBinder", "CSharpBinderFlags");
 
 			//
 			// Define types which are used for comparison. It does not matter
 			// if they don't exist as no error report is needed
 			//
 			TypedReference.Define ();
 			ArgIterator.Define ();
 			MarshalByRefObject.Define ();
 			CharSet.Define ();
 
 			IEnumerableGeneric.Define ();
 			IListGeneric.Define ();
 			ICollectionGeneric.Define ();
 			IEnumerableGeneric.Define ();
 			IEnumeratorGeneric.Define ();
 			Nullable.Define ();
 			ExpressionGeneric.Define ();
 
 			// Deal with obsolete static types
 			// TODO
 			TypeManager.typed_reference_type = TypedReference.TypeSpec;
 			TypeManager.arg_iterator_type = ArgIterator.TypeSpec;
 			TypeManager.mbr_type = MarshalByRefObject.TypeSpec;
 			TypeManager.generic_ilist_type = IListGeneric.TypeSpec;
 			TypeManager.generic_icollection_type = ICollectionGeneric.TypeSpec;
 			TypeManager.generic_ienumerator_type = IEnumeratorGeneric.TypeSpec;
 			TypeManager.generic_ienumerable_type = IEnumerableGeneric.TypeSpec;
 			TypeManager.generic_nullable_type = Nullable.TypeSpec;
 			TypeManager.expression_type = ExpressionGeneric.TypeSpec;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1611" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3611" endline="3709">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return false;
 
 			new_expr = SwitchGoverningType (ec, Expr);
 
 			if ((new_expr == null) && TypeManager.IsNullableType (Expr.Type)) {
 				unwrap = Nullable.Unwrap.Create (Expr, false);
 				if (unwrap == null)
 					return false;
 
 				new_expr = SwitchGoverningType (ec, unwrap);
 			}
 
 			if (new_expr == null){
 				ec.Report.Error (151, loc,
 					"A switch expression of type `{0}' cannot be converted to an integral type, bool, char, string, enum or nullable type",
 					TypeManager.CSharpName (Expr.Type));
 				return false;
 			}
 
 			// Validate switch.
 			SwitchType = new_expr.Type;
 
 			if (RootContext.Version == LanguageVersion.ISO_1 && SwitchType == TypeManager.bool_type) {
 				ec.Report.FeatureIsNotAvailable (loc, "switch expression of boolean type");
 				return false;
 			}
 
 			if (!CheckSwitch (ec))
 				return false;
 
 			if (HaveUnwrap)
 				Elements.Remove (SwitchLabel.NullStringCase);
 
 			Switch old_switch = ec.Switch;
 			ec.Switch = this;
 			ec.Switch.SwitchType = SwitchType;
 
 			Report.Debug (1, "START OF SWITCH BLOCK", loc, ec.CurrentBranching);
 			ec.StartFlowBranching (FlowBranching.BranchingType.Switch, loc);
 
 			var constant = new_expr as Constant;
 			if (constant != null) {
 				is_constant = true;
 				object key = constant.GetValue ();
 				SwitchLabel label;
 				if (Elements.TryGetValue (key, out label))
 					constant_section = FindSection (label);
 
 				if (constant_section == null)
 					constant_section = default_section;
 			}
 
 			bool first = true;
 			bool ok = true;
 			foreach (SwitchSection ss in Sections){
 				if (!first)
 					ec.CurrentBranching.CreateSibling (
 						null, FlowBranching.SiblingType.SwitchSection);
 				else
 					first = false;
 
 				if (is_constant && (ss != constant_section)) {
 					// If we're a constant switch, we're only emitting
 					// one single section - mark all the others as
 					// unreachable.
 					ec.CurrentBranching.CurrentUsageVector.Goto ();
 					if (!ss.Block.ResolveUnreachable (ec, true)) {
 						ok = false;
 					}
 				} else {
 					if (!ss.Block.Resolve (ec))
 						ok = false;
 				}
 			}
 			foreach (SwitchSection ss in Sections){
 				if (!first)
 					ec.CurrentBranching.CreateSibling (
 						null, FlowBranching.SiblingType.SwitchSection);
 				else
 					first = false;
 
 				if (is_constant && (ss != constant_section)) {
 					// If we're a constant switch, we're only emitting
 					// one single section - mark all the others as
 					// unreachable.
 					ec.CurrentBranching.CurrentUsageVector.Goto ();
 					if (!ss.Block.ResolveUnreachable (ec, true)) {
 						ok = false;
 					}
 				} else {
 					if (!ss.Block.Resolve (ec))
 						ok = false;
 				}
 			}
 
 			if (default_section == null)
 				ec.CurrentBranching.CreateSibling (
 					null, FlowBranching.SiblingType.SwitchSection);
 
 			ec.EndFlowBranching ();
 			ec.Switch = old_switch;
 
 			Report.Debug (1, "END OF SWITCH BLOCK", loc, ec.CurrentBranching);
 
 			if (!ok)
 				return false;
 
 			if (SwitchType == TypeManager.string_type && !is_constant) {
 				// TODO
 				ResolveStringSwitchMap (ec);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1612" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5614" endline="5700">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			TypeExpr texpr = RequestedType.ResolveAsTypeTerminal (ec, false);
 			if (texpr == null)
 				return null;
 
 			type = texpr.Type;
 			eclass = ExprClass.Value;
 
 			if (type.IsPointer) {
 				ec.Report.Error (1919, loc, "Unsafe type `{0}' cannot be used in an object creation expression",
 					TypeManager.CSharpName (type));
 				return null;
 			}
 
 			if (arguments == null) {
 				Constant c = Constantify (type, RequestedType.Location);
 				if (c != null)
 					return ReducedExpression.Create (c.Resolve (ec), this);
 			}
 
 			if (TypeManager.IsDelegateType (type)) {
 				return (new NewDelegate (type, arguments, loc)).Resolve (ec);
 			}
 
 			var tparam = type as TypeParameterSpec;
 			if (tparam != null) {
 				//
 				// Check whether the type of type parameter can be constructed. BaseType can be a struct for method overrides
 				// where type parameter constraint is inflated to struct
 				//
 				if ((tparam.SpecialConstraint & (SpecialConstraint.Struct | SpecialConstraint.Constructor)) == 0 && !tparam.BaseType.IsStruct) {
 					ec.Report.Error (304, loc,
 						"Cannot create an instance of the variable type `{0}' because it does not have the new() constraint",
 						TypeManager.CSharpName (type));
 				}
 
 				if ((arguments != null) && (arguments.Count != 0)) {
 					ec.Report.Error (417, loc,
 						"`{0}'
 						TypeManager.CSharpName (type));
 				}
 
 				return this;
 			}
 
 			if (type.IsStatic) {
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (712, loc, "Cannot create an instance of the static class `{0}'", TypeManager.CSharpName (type));
 				return null;
 			}
 
 			if (type.IsInterface || type.IsAbstract){
 				if (!TypeManager.IsGenericType (type)) {
 					RequestedType = CheckComImport (ec);
 					if (RequestedType != null)
 						return RequestedType;
 				}
 				
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (144, loc, "Cannot create an instance of the abstract class or interface `{0}'", TypeManager.CSharpName (type));
 				return null;
 			}
 
 			//
 			// Any struct always defines parameterless constructor
 			//
 			if (type.IsStruct && arguments == null)
 				return this;
 
 			bool dynamic;
 			if (arguments != null) {
 				arguments.Resolve (ec, out dynamic);
 			} else {
 				dynamic = false;
 			}
 
 			method = ConstructorLookup (ec, type, ref arguments, loc);
 
 			if (dynamic) {
 				arguments.Insert (0, new Argument (new TypeOf (texpr, loc).Resolve (ec), Argument.AType.DynamicTypeName));
 				return new DynamicConstructorBinder (type, arguments, loc).Resolve (ec);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1613" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="366" endline="445">
<![CDATA[
 
 		TypeExpr CreateSiteType (EmitContext ec, Arguments arguments, int dyn_args_count, bool is_statement)
 		{
 			int default_args = is_statement ? 1 
 			var module = ec.MemberContext.Module;
 
 			bool has_ref_out_argument = false;
 			var targs = new TypeExpression[dyn_args_count + default_args];
 			targs [0] = new TypeExpression (module.PredefinedTypes.CallSite.TypeSpec, loc);
 			for (int i = 0; i < dyn_args_count; ++i) {
 				Argument a = arguments [i];
 				if (a.ArgType == Argument.AType.Out || a.ArgType == Argument.AType.Ref)
 					has_ref_out_argument = true;
 
 				var t = a.Type;
 
 				// Convert any internal type like dynamic or null to object
 				if (t.Kind == MemberKind.InternalCompilerType)
 					t = TypeManager.object_type;
 
 				targs [i + 1] = new TypeExpression (t, loc);
 			}
 			for (int i = 0; i < dyn_args_count; ++i) {
 				Argument a = arguments [i];
 				if (a.ArgType == Argument.AType.Out || a.ArgType == Argument.AType.Ref)
 					has_ref_out_argument = true;
 
 				var t = a.Type;
 
 				// Convert any internal type like dynamic or null to object
 				if (t.Kind == MemberKind.InternalCompilerType)
 					t = TypeManager.object_type;
 
 				targs [i + 1] = new TypeExpression (t, loc);
 			}
 
 			TypeExpr del_type = null;
 			if (!has_ref_out_argument) {
 				string d_name = is_statement ? "Action" 
 
 				TypeExpr te = null;
 				Namespace type_ns = module.GlobalRootNamespace.GetNamespace ("System", true);
 				if (type_ns != null) {
 					te = type_ns.LookupType (module.Compiler, d_name, dyn_args_count + default_args, true, Location.Null);
 				}
 			
 				if (te != null) {
 					if (!is_statement)
 						targs [targs.Length - 1] = new TypeExpression (type, loc);
 
 					del_type = new GenericTypeExpr (te.Type, new TypeArguments (targs), loc);
 				}
 			}
 
 			//
 			// Create custom delegate when no appropriate predefined one is found
 			//
 			if (del_type == null) {
 				TypeSpec rt = is_statement ? TypeManager.void_type 
 				Parameter[] p = new Parameter [dyn_args_count + 1];
 				p[0] = new Parameter (targs [0], "p0", Parameter.Modifier.NONE, null, loc);
 
 				var site = ec.CreateDynamicSite ();
 				int index = site.Types == null ? 0 
 
 				if (site.Mutator != null)
 					rt = site.Mutator.Mutate (rt);
 
 				for (int i = 1; i < dyn_args_count + 1; ++i) {
 					var t = targs[i];
 					if (site.Mutator != null)
 						t.Type = site.Mutator.Mutate (t.Type);
 
 					p[i] = new Parameter (t, "p" + i.ToString ("X"), arguments[i - 1].Modifier, null, loc);
 				}
 				for (int i = 1; i < dyn_args_count + 1; ++i) {
 					var t = targs[i];
 					if (site.Mutator != null)
 						t.Type = site.Mutator.Mutate (t.Type);
 
 					p[i] = new Parameter (t, "p" + i.ToString ("X"), arguments[i - 1].Modifier, null, loc);
 				}
 
 				Delegate d = new Delegate (site.NamespaceEntry, site, new TypeExpression (rt, loc),
 					Modifiers.INTERNAL | Modifiers.COMPILER_GENERATED,
 					new MemberName ("Container" + index.ToString ("X")),
 					new ParametersCompiled (p), null);
 
 				d.CreateType ();
 				d.DefineType ();
 				d.Define ();
 				d.Emit ();
 
 				var inflated = site.AddDelegate (d);
 				del_type = new TypeExpression (inflated, loc);
 			}
 
 			TypeExpr site_type = new GenericTypeExpr (module.PredefinedTypes.CallSiteGeneric.TypeSpec, new TypeArguments (del_type), loc);
 			return site_type;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1614" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1714" endline="1755">
<![CDATA[
 
 		/// <summary>
 		///   Resolve the type arguments.
 		/// </summary>
 		public virtual bool Resolve (IMemberContext ec)
 		{
 			if (atypes != null)
 			    return atypes.Length != 0;
 
 			int count = args.Count;
 			bool ok = true;
 
 			atypes = new TypeSpec [count];
 
 			for (int i = 0; i < count; i++){
 				TypeExpr te = args[i].ResolveAsTypeTerminal (ec, false);
 				if (te == null) {
 					ok = false;
 					continue;
 				}
 
 				atypes[i] = te.Type;
 
 				if (te.Type.IsStatic) {
 					ec.Compiler.Report.Error (718, te.Location, "`{0}'
 						te.GetSignatureForError ());
 					ok = false;
 				}
 
 				if (te.Type.IsPointer || TypeManager.IsSpecialType (te.Type)) {
 					ec.Compiler.Report.Error (306, te.Location,
 						"The type `{0}' may not be used as a type argument",
 						te.GetSignatureForError ());
 					ok = false;
 				}
 			}
 			for (int i = 0; i < count; i++){
 				TypeExpr te = args[i].ResolveAsTypeTerminal (ec, false);
 				if (te == null) {
 					ok = false;
 					continue;
 				}
 
 				atypes[i] = te.Type;
 
 				if (te.Type.IsStatic) {
 					ec.Compiler.Report.Error (718, te.Location, "`{0}'
 						te.GetSignatureForError ());
 					ok = false;
 				}
 
 				if (te.Type.IsPointer || TypeManager.IsSpecialType (te.Type)) {
 					ec.Compiler.Report.Error (306, te.Location,
 						"The type `{0}' may not be used as a type argument",
 						te.GetSignatureForError ());
 					ok = false;
 				}
 			}
 
 			if (!ok)
 				atypes = TypeSpec.EmptyTypes;
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1615" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2743" endline="2842">
<![CDATA[
 
 		public bool ResolveInstanceExpression (ResolveContext rc, Expression rhs)
 		{
 			if (IsStatic) {
 				if (InstanceExpression != null) {
 					if (InstanceExpression is TypeExpr) {
 						var t = InstanceExpression.Type;
 						do {
 							ObsoleteAttribute oa = t.GetAttributeObsolete ();
 							if (oa != null && !rc.IsObsolete) {
 								AttributeTester.Report_ObsoleteMessage (oa, t.GetSignatureForError (), loc, rc.Report);
 							}
 
 							t = t.DeclaringType;
 						} while (t != null);
 					} else {
 						var runtime_expr = InstanceExpression as RuntimeValueExpression;
 						if (runtime_expr == null || !runtime_expr.IsSuggestionOnly) {
 							rc.Report.Error (176, loc,
 								"Static member `{0}' cannot be accessed with an instance reference, qualify it with a type name instead",
 								GetSignatureForError ());
 						}
 					}
 
 					InstanceExpression = null;
 				}
 
 				return false;
 			}
 
 			if (InstanceExpression == null || InstanceExpression is TypeExpr) {
 				if (InstanceExpression != null || !This.IsThisAvailable (rc, true)) {
 					if (rc.HasSet (ResolveContext.Options.FieldInitializerScope))
 						rc.Report.Error (236, loc,
 							"A field initializer cannot reference the nonstatic field, method, or property `{0}'",
 							GetSignatureForError ());
 					else
 						rc.Report.Error (120, loc,
 							"An object reference is required to access non-static member `{0}'",
 							GetSignatureForError ());
 
 					return false;
 				}
 
 				if (!TypeManager.IsFamilyAccessible (rc.CurrentType, DeclaringType)) {
 					rc.Report.Error (38, loc,
 						"Cannot access a nonstatic member of outer type `{0}' via nested type `{1}'",
 						DeclaringType.GetSignatureForError (), rc.CurrentType.GetSignatureForError ());
 				}
 
 				InstanceExpression = new This (loc);
 				if (this is FieldExpr && rc.CurrentType.IsStruct) {
 					using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 						InstanceExpression = InstanceExpression.Resolve (rc);
 					}
 				} else {
 					InstanceExpression = InstanceExpression.Resolve (rc);
 				}
 
 				return false;
 			}
 
 			var me = InstanceExpression as MemberExpr;
 			if (me != null) {
 				me.ResolveInstanceExpression (rc, rhs);
 
 				var fe = me as FieldExpr;
 				if (fe != null && fe.IsMarshalByRefAccess ()) {
 					rc.Report.SymbolRelatedToPreviousError (me.DeclaringType);
 					rc.Report.Warning (1690, 1, loc,
 						"Cannot call methods, properties, or indexers on `{0}' because it is a value type member of a marshal-by-reference class",
 						me.GetSignatureForError ());
 				}
 
 				return true;
 			}
 
 			//
 			// Run member-access postponed check once we know that
 			// the expression is not field expression which is the only
 			// expression which can use uninitialized this
 			//
 			if (InstanceExpression is This && !(this is FieldExpr) && rc.CurrentType.IsStruct) {
 				((This)InstanceExpression).CheckStructThisDefiniteAssignment (rc);
 			}
 
 			//
 			// Additional checks for l-value member access
 			//
 			if (rhs != null) {
 				//
 				// TODO
 				//
 				if (InstanceExpression is UnboxCast) {
 					rc.Report.Error (445, InstanceExpression.Location, "Cannot modify the result of an unboxing conversion");
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1616" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="447" endline="537">
<![CDATA[
 
 		protected virtual bool ResolveNamedArguments (ResolveContext ec)
 		{
 			int named_arg_count = NamedArguments.Count;
 			var seen_names = new List<string> (named_arg_count);
 
 			named_values = new List<KeyValuePair<MemberExpr, NamedArgument>> (named_arg_count);
 			
 			foreach (NamedArgument a in NamedArguments) {
 				string name = a.Name;
 				if (seen_names.Contains (name)) {
 					ec.Report.Error (643, a.Location, "Duplicate named attribute `{0}' argument", name);
 					continue;
 				}			
 	
 				seen_names.Add (name);
 
 				a.Resolve (ec);
 
 				Expression member = Expression.MemberLookup (ec, ec.CurrentType, Type, name, 0, MemberLookupRestrictions.ExactArity, loc);
 
 				if (member == null) {
 					member = Expression.MemberLookup (null, ec.CurrentType, Type, name, 0, MemberLookupRestrictions.ExactArity, loc);
 
 					if (member != null) {
 						// TODO
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						return false;
 					}
 				}
 
 				if (member == null){
 					Expression.Error_TypeDoesNotContainDefinition (ec, Location, Type, name);
 					return false;
 				}
 				
 				if (!(member is PropertyExpr || member is FieldExpr)) {
 					Error_InvalidNamedArgument (ec, a);
 					return false;
 				}
 
 				ObsoleteAttribute obsolete_attr;
 
 				if (member is PropertyExpr) {
 					var pi = ((PropertyExpr) member).PropertyInfo;
 
 					if (!pi.HasSet || !pi.HasGet || pi.IsStatic || !pi.Get.IsPublic || !pi.Set.IsPublic) {
 						ec.Report.SymbolRelatedToPreviousError (pi);
 						Error_InvalidNamedArgument (ec, a);
 						return false;
 					}
 
 					if (!IsValidArgumentType (member.Type)) {
 						ec.Report.SymbolRelatedToPreviousError (pi);
 						Error_InvalidNamedArgumentType (ec, a);
 						return false;
 					}
 
 					obsolete_attr = pi.GetAttributeObsolete ();
 					pi.MemberDefinition.SetIsAssigned ();
 				} else {
 					var fi = ((FieldExpr) member).Spec;
 
 					if (fi.IsReadOnly || fi.IsStatic || !fi.IsPublic) {
 						Error_InvalidNamedArgument (ec, a);
 						return false;
 					}
 
 					if (!IsValidArgumentType (member.Type)) {
 						ec.Report.SymbolRelatedToPreviousError (fi);
 						Error_InvalidNamedArgumentType (ec, a);
 						return false;
 					}
 
 					obsolete_attr = fi.GetAttributeObsolete ();
 					fi.MemberDefinition.SetIsAssigned ();
 				}
 
 				if (obsolete_attr != null && !context.IsObsolete)
 					AttributeTester.Report_ObsoleteMessage (obsolete_attr, member.GetSignatureForError (), member.Location, Report);
 
 				if (a.Type != member.Type) {
 					a.Expr = Convert.ImplicitConversionRequired (ec, a.Expr, member.Type, a.Expr.Location);
 				}
 
 				if (a.Expr != null)
 					named_values.Add (new KeyValuePair<MemberExpr, NamedArgument> ((MemberExpr) member, a));
 			}
 			foreach (NamedArgument a in NamedArguments) {
 				string name = a.Name;
 				if (seen_names.Contains (name)) {
 					ec.Report.Error (643, a.Location, "Duplicate named attribute `{0}' argument", name);
 					continue;
 				}			
 	
 				seen_names.Add (name);
 
 				a.Resolve (ec);
 
 				Expression member = Expression.MemberLookup (ec, ec.CurrentType, Type, name, 0, MemberLookupRestrictions.ExactArity, loc);
 
 				if (member == null) {
 					member = Expression.MemberLookup (null, ec.CurrentType, Type, name, 0, MemberLookupRestrictions.ExactArity, loc);
 
 					if (member != null) {
 						// TODO
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						return false;
 					}
 				}
 
 				if (member == null){
 					Expression.Error_TypeDoesNotContainDefinition (ec, Location, Type, name);
 					return false;
 				}
 				
 				if (!(member is PropertyExpr || member is FieldExpr)) {
 					Error_InvalidNamedArgument (ec, a);
 					return false;
 				}
 
 				ObsoleteAttribute obsolete_attr;
 
 				if (member is PropertyExpr) {
 					var pi = ((PropertyExpr) member).PropertyInfo;
 
 					if (!pi.HasSet || !pi.HasGet || pi.IsStatic || !pi.Get.IsPublic || !pi.Set.IsPublic) {
 						ec.Report.SymbolRelatedToPreviousError (pi);
 						Error_InvalidNamedArgument (ec, a);
 						return false;
 					}
 
 					if (!IsValidArgumentType (member.Type)) {
 						ec.Report.SymbolRelatedToPreviousError (pi);
 						Error_InvalidNamedArgumentType (ec, a);
 						return false;
 					}
 
 					obsolete_attr = pi.GetAttributeObsolete ();
 					pi.MemberDefinition.SetIsAssigned ();
 				} else {
 					var fi = ((FieldExpr) member).Spec;
 
 					if (fi.IsReadOnly || fi.IsStatic || !fi.IsPublic) {
 						Error_InvalidNamedArgument (ec, a);
 						return false;
 					}
 
 					if (!IsValidArgumentType (member.Type)) {
 						ec.Report.SymbolRelatedToPreviousError (fi);
 						Error_InvalidNamedArgumentType (ec, a);
 						return false;
 					}
 
 					obsolete_attr = fi.GetAttributeObsolete ();
 					fi.MemberDefinition.SetIsAssigned ();
 				}
 
 				if (obsolete_attr != null && !context.IsObsolete)
 					AttributeTester.Report_ObsoleteMessage (obsolete_attr, member.GetSignatureForError (), member.Location, Report);
 
 				if (a.Type != member.Type) {
 					a.Expr = Convert.ImplicitConversionRequired (ec, a.Expr, member.Type, a.Expr.Location);
 				}
 
 				if (a.Expr != null)
 					named_values.Add (new KeyValuePair<MemberExpr, NamedArgument> ((MemberExpr) member, a));
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1617" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="610" endline="709">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			right = right.Resolve (ec);
 			if (right == null)
 				return null;
 
 			MemberAccess ma = target as MemberAccess;
 			using (ec.Set (ResolveContext.Options.CompoundAssignmentScope)) {
 				target = target.Resolve (ec);
 			}
 			
 			if (target == null)
 				return null;
 
 			if (target is MethodGroupExpr){
 				ec.Report.Error (1656, loc,
 					"Cannot assign to `{0}' because it is a `{1}'",
 					((MethodGroupExpr)target).Name, target.ExprClassName);
 				return null;
 			}
 
 			var event_expr = target as EventExpr;
 			if (event_expr != null) {
 				source = Convert.ImplicitConversionRequired (ec, right, target.Type, loc);
 				if (source == null)
 					return null;
 
 				Expression rside;
 				if (op == Binary.Operator.Addition)
 					rside = EmptyExpression.EventAddition;
 				else if (op == Binary.Operator.Subtraction)
 					rside = EmptyExpression.EventSubtraction;
 				else
 					rside = null;
 
 				target = target.ResolveLValue (ec, rside);
 				if (target == null)
 					return null;
 
 				eclass = ExprClass.Value;
 				type = event_expr.Operator.ReturnType;
 				return this;
 			}
 
 			//
 			// Only now we can decouple the original source/target
 			// into a tree, to guarantee that we do not have side
 			// effects.
 			//
 			if (left == null)
 				left = new TargetExpression (target);
 
 			source = new Binary (op, left, right, true, loc);
 
 			if (target is DynamicMemberAssignable) {
 				Arguments targs = ((DynamicMemberAssignable) target).Arguments;
 				source = source.Resolve (ec);
 
 				Arguments args = new Arguments (targs.Count + 1);
 				args.AddRange (targs);
 				args.Add (new Argument (source));
 
 				var binder_flags = CSharpBinderFlags.ValueFromCompoundAssignment;
 
 				//
 				// Compound assignment does target conversion using additional method
 				// call, set checked context as the binary operation can overflow
 				//
 				if (ec.HasSet (ResolveContext.Options.CheckedScope))
 					binder_flags |= CSharpBinderFlags.CheckedContext;
 
 				if (target is DynamicMemberBinder) {
 					source = new DynamicMemberBinder (ma.Name, binder_flags, args, loc).Resolve (ec);
 
 					// Handles possible event addition/subtraction
 					if (op == Binary.Operator.Addition || op == Binary.Operator.Subtraction) {
 						args = new Arguments (targs.Count + 1);
 						args.AddRange (targs);
 						args.Add (new Argument (right));
 						string method_prefix = op == Binary.Operator.Addition ?
 							Event.AEventAccessor.AddPrefix 
 
 						var invoke = DynamicInvocation.CreateSpecialNameInvoke (
 							new MemberAccess (right, method_prefix + ma.Name, loc), args, loc).Resolve (ec);
 
 						args = new Arguments (targs.Count);
 						args.AddRange (targs);
 						source = new DynamicEventCompoundAssign (ma.Name, args,
 							(ExpressionStatement) source, (ExpressionStatement) invoke, loc).Resolve (ec);
 					}
 				} else {
 					source = new DynamicIndexBinder (binder_flags, args, loc).Resolve (ec);
 				}
 
 				return source;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1618" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1057" endline="1144">
<![CDATA[
 
 		Expression ConvertExpression (ResolveContext ec)
 		{
 			// TODO
 			if (left.eclass == ExprClass.MethodGroup)
 				return null;
 
 			TypeSpec ltype = left.Type;
 
 			//
 			// If left is a nullable type and an implicit conversion exists from right to underlying type of left,
 			// the result is underlying type of left
 			//
 			if (TypeManager.IsNullableType (ltype)) {
 				unwrap = Unwrap.Create (left, false);
 				if (unwrap == null)
 					return null;
 
 				//
 				// Reduce (left ?? null) to left
 				//
 				if (right.IsNull)
 					return ReducedExpression.Create (left, this);
 
 				if (Convert.ImplicitConversionExists (ec, right, unwrap.Type)) {
 					left = unwrap;
 					ltype = left.Type;
 
 					//
 					// If right is a dynamic expression, the result type is dynamic
 					//
 					if (right.Type == InternalType.Dynamic) {
 						type = right.Type;
 
 						// Need to box underlying value type
 						left = Convert.ImplicitBoxingConversion (left, ltype, type);
 						return this;
 					}
 
 					right = Convert.ImplicitConversion (ec, right, ltype, loc);
 					type = ltype;
 					return this;
 				}
 			} else if (TypeManager.IsReferenceType (ltype)) {
 				if (Convert.ImplicitConversionExists (ec, right, ltype)) {
 					//
 					// If right is a dynamic expression, the result type is dynamic
 					//
 					if (right.Type == InternalType.Dynamic) {
 						type = right.Type;
 						return this;
 					}
 
 					//
 					// Reduce ("foo" ?? expr) to expression
 					//
 					Constant lc = left as Constant;
 					if (lc != null && !lc.IsDefaultValue)
 						return ReducedExpression.Create (lc, this).Resolve (ec);
 
 					//
 					// Reduce (left ?? null) to left OR (null-constant ?? right) to right
 					//
 					if (right.IsNull || lc != null)
 						return ReducedExpression.Create (lc != null ? right 
 
 					right = Convert.ImplicitConversion (ec, right, ltype, loc);
 					type = ltype;
 					return this;
 				}
 			} else {
 				return null;
 			}
 
 			TypeSpec rtype = right.Type;
 			if (!Convert.ImplicitConversionExists (ec, unwrap != null ? unwrap 
 				return null;
 
 			//
 			// Reduce (null ?? right) to right
 			//
 			if (left.IsNull)
 				return ReducedExpression.Create (right, this).Resolve (ec);
 
 			left = Convert.ImplicitConversion (ec, unwrap != null ? unwrap 
 			type = rtype;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1619" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3191" endline="3261">
<![CDATA[
 		}
 
 		//
 		// Determines the governing type for a switch.  The returned
 		// expression might be the expression from the switch, or an
 		// expression that includes any potential conversions to the
 		// integral types or to string.
 		//
 		Expression SwitchGoverningType (ResolveContext ec, Expression expr)
 		{
 			TypeSpec t = expr.Type;
 
 			if (t == TypeManager.byte_type ||
 			    t == TypeManager.sbyte_type ||
 			    t == TypeManager.ushort_type ||
 			    t == TypeManager.short_type ||
 			    t == TypeManager.uint32_type ||
 			    t == TypeManager.int32_type ||
 			    t == TypeManager.uint64_type ||
 			    t == TypeManager.int64_type ||
 			    t == TypeManager.char_type ||
 			    t == TypeManager.string_type ||
 			    t == TypeManager.bool_type ||
 			    TypeManager.IsEnumType (t))
 				return expr;
 
 			if (allowed_types == null){
 				allowed_types = new TypeSpec [] {
 					TypeManager.sbyte_type,
 					TypeManager.byte_type,
 					TypeManager.short_type,
 					TypeManager.ushort_type,
 					TypeManager.int32_type,
 					TypeManager.uint32_type,
 					TypeManager.int64_type,
 					TypeManager.uint64_type,
 					TypeManager.char_type,
 					TypeManager.string_type
 				};
 			}
 
 			//
 			// Try to find a *user* defined implicit conversion.
 			//
 			// If there is no implicit conversion, or if there are multiple
 			// conversions, we have to report an error
 			//
 			Expression converted = null;
 			foreach (TypeSpec tt in allowed_types){
 				Expression e;
 				
 				e = Convert.ImplicitUserConversion (ec, expr, tt, loc);
 				if (e == null)
 					continue;
 
 				//
 				// Ignore over-worked ImplicitUserConversions that do
 				// an implicit conversion in addition to the user conversion.
 				// 
 				if (!(e is UserCast))
 					continue;
 
 				if (converted != null){
 					ec.Report.ExtraInformation (loc, "(Ambiguous implicit user defined conversion in previous ");
 					return null;
 				}
 
 				converted = e;
 			}
 			foreach (TypeSpec tt in allowed_types){
 				Expression e;
 				
 				e = Convert.ImplicitUserConversion (ec, expr, tt, loc);
 				if (e == null)
 					continue;
 
 				//
 				// Ignore over-worked ImplicitUserConversions that do
 				// an implicit conversion in addition to the user conversion.
 				// 
 				if (!(e is UserCast))
 					continue;
 
 				if (converted != null){
 					ec.Report.ExtraInformation (loc, "(Ambiguous implicit user defined conversion in previous ");
 					return null;
 				}
 
 				converted = e;
 			}
 			return converted;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1620" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1520" endline="1624">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// Use same anonymous method implementation for scenarios where same
 			// code is used from multiple blocks, e.g. field initializers
 			//
 			if (method == null) {
 				//
 				// Delay an anonymous method definition to avoid emitting unused code
 				// for unreachable blocks or expression trees
 				//
 				method = DoCreateMethodHost (ec);
 				method.Define ();
 			}
 
 			bool is_static = (method.ModFlags & Modifiers.STATIC) != 0;
 			if (is_static && am_cache == null) {
 				//
 				// Creates a field cache to store delegate instance if it's not generic
 				//
 				if (!method.MemberName.IsGeneric) {
 					TypeContainer parent = method.Parent.PartialContainer;
 					int id = parent.Fields == null ? 0 
 					var cache_type = storey != null && storey.Mutator != null ? storey.Mutator.Mutate (type) 
 
 					am_cache = new Field (parent, new TypeExpression (cache_type, loc),
 						Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.COMPILER_GENERATED,
 						new MemberName (CompilerGeneratedClass.MakeName (null, "f", "am$cache", id), loc), null);
 					am_cache.Define ();
 					parent.AddField (am_cache);
 				} else {
 					// TODO
 					//
 					// Idea
 					//
 					// Some extra class is needed to capture variable generic type
 					// arguments. Maybe we could re-use anonymous types, with a unique
 					// anonymous method id, but they are quite heavy.
 					//
 					// Consider 
 					//
 					// We need something like
 					// static class Wrap<Tn, Tm, DelegateType> {
 					//		public static DelegateType cache;
 					// }
 					//
 					// We then specialize local variable to capture all generic parameters
 					// and delegate type, e.g. "Wrap<Ta, Tb, DelegateTypeInst> cache;"
 					//
 				}
 			}
 
 			Label l_initialized = ec.DefineLabel ();
 
 			if (am_cache != null) {
 				ec.Emit (OpCodes.Ldsfld, am_cache.Spec);
 				ec.Emit (OpCodes.Brtrue_S, l_initialized);
 			}
 
 			//
 			// Load method delegate implementation
 			//
 
 			if (is_static) {
 				ec.Emit (OpCodes.Ldnull);
 			} else if (storey != null) {
 				Expression e = storey.GetStoreyInstanceExpression (ec).Resolve (new ResolveContext (ec.MemberContext));
 				if (e != null)
 					e.Emit (ec);
 			} else {
 				ec.Emit (OpCodes.Ldarg_0);
 			}
 
 			var delegate_method = method.Spec;
 			if (storey != null && storey.MemberName.IsGeneric) {
 				TypeSpec t = storey.Instance.Type;
 
 				//
 				// Mutate anonymous method instance type if we are in nested
 				// hoisted generic anonymous method storey
 				//
 				if (ec.CurrentAnonymousMethod != null &&
 					ec.CurrentAnonymousMethod.Storey != null &&
 					ec.CurrentAnonymousMethod.Storey.Mutator != null) {
 					t = storey.Mutator.Mutate (t);
 				}
 
 				ec.Emit (OpCodes.Ldftn, TypeBuilder.GetMethod (t.GetMetaInfo (), (MethodInfo) delegate_method.GetMetaInfo ()));
 			} else {
 				if (delegate_method.IsGeneric)
 					delegate_method = delegate_method.MakeGenericMethod (method.TypeParameters);
 
 				ec.Emit (OpCodes.Ldftn, delegate_method);
 			}
 
 			var constructor_method = Delegate.GetConstructor (ec.MemberContext.Compiler, ec.CurrentType, type);
 			ec.Emit (OpCodes.Newobj, constructor_method);
 
 			if (am_cache != null) {
 				ec.Emit (OpCodes.Stsfld, am_cache.Spec);
 				ec.MarkLabel (l_initialized);
 				ec.Emit (OpCodes.Ldsfld, am_cache.Spec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1621" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="393" endline="468">
<![CDATA[
 
 		/// <summary>
 		///   Verifies that any pending abstract methods or interface methods
 		///   were implemented.
 		/// </summary>
 		public bool VerifyPendingMethods (Report Report)
 		{
 			int top = pending_implementations.Length;
 			bool errors = false;
 			int i;
 			
 			for (i = 0; i < top; i++){
 				TypeSpec type = pending_implementations [i].type;
 
 				bool base_implements_type = type.IsInterface &&
 					container.BaseType != null &&
 					container.BaseType.ImplementsInterface (type, false);
 
 				for (int j = 0; j < pending_implementations [i].methods.Count; ++j) {
 					var mi = pending_implementations[i].methods[j];
 					if (mi == null)
 						continue;
 
 					if (type.IsInterface){
 						var need_proxy =
 							pending_implementations [i].need_proxy [j];
 
 						if (need_proxy != null) {
 							DefineProxy (type, need_proxy, mi);
 							continue;
 						}
 
 						if (pending_implementations [i].optional)
 							continue;
 
 						MethodSpec candidate = null;
 						if (base_implements_type || BaseImplements (type, mi, out candidate))
 							continue;
 
 						if (candidate == null) {
 							MethodData md = pending_implementations [i].found [j];
 							if (md != null)
 								candidate = md.method.Spec;
 						}
 
 						Report.SymbolRelatedToPreviousError (mi);
 						if (candidate != null) {
 							Report.SymbolRelatedToPreviousError (candidate);
 							if (candidate.IsStatic) {
 								Report.Error (736, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' is static",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate));
 							} else if ((candidate.Modifiers & Modifiers.PUBLIC) == 0) {
 								Report.Error (737, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' in not public",
 									container.GetSignatureForError (), mi.GetSignatureForError (), candidate.GetSignatureForError ());
 							} else {
 								Report.Error (738, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' return type `{3}' does not match interface member return type `{4}'",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate),
 									TypeManager.CSharpName (candidate.ReturnType), TypeManager.CSharpName (mi.ReturnType));
 							}
 						} else {
 							Report.Error (535, container.Location, "`{0}' does not implement interface member `{1}'",
 								container.GetSignatureForError (), mi.GetSignatureForError ());
 						}
 					} else {
 						Report.SymbolRelatedToPreviousError (mi);
 						Report.Error (534, container.Location, "`{0}' does not implement inherited abstract member `{1}'",
 							container.GetSignatureForError (), mi.GetSignatureForError ());
 					}
 					errors = true;
 				}
 				for (int j = 0; j < pending_implementations [i].methods.Count; ++j) {
 					var mi = pending_implementations[i].methods[j];
 					if (mi == null)
 						continue;
 
 					if (type.IsInterface){
 						var need_proxy =
 							pending_implementations [i].need_proxy [j];
 
 						if (need_proxy != null) {
 							DefineProxy (type, need_proxy, mi);
 							continue;
 						}
 
 						if (pending_implementations [i].optional)
 							continue;
 
 						MethodSpec candidate = null;
 						if (base_implements_type || BaseImplements (type, mi, out candidate))
 							continue;
 
 						if (candidate == null) {
 							MethodData md = pending_implementations [i].found [j];
 							if (md != null)
 								candidate = md.method.Spec;
 						}
 
 						Report.SymbolRelatedToPreviousError (mi);
 						if (candidate != null) {
 							Report.SymbolRelatedToPreviousError (candidate);
 							if (candidate.IsStatic) {
 								Report.Error (736, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' is static",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate));
 							} else if ((candidate.Modifiers & Modifiers.PUBLIC) == 0) {
 								Report.Error (737, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' in not public",
 									container.GetSignatureForError (), mi.GetSignatureForError (), candidate.GetSignatureForError ());
 							} else {
 								Report.Error (738, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' return type `{3}' does not match interface member return type `{4}'",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate),
 									TypeManager.CSharpName (candidate.ReturnType), TypeManager.CSharpName (mi.ReturnType));
 							}
 						} else {
 							Report.Error (535, container.Location, "`{0}' does not implement interface member `{1}'",
 								container.GetSignatureForError (), mi.GetSignatureForError ());
 						}
 					} else {
 						Report.SymbolRelatedToPreviousError (mi);
 						Report.Error (534, container.Location, "`{0}' does not implement inherited abstract member `{1}'",
 							container.GetSignatureForError (), mi.GetSignatureForError ());
 					}
 					errors = true;
 				}
 			}
 			for (i = 0; i < top; i++){
 				TypeSpec type = pending_implementations [i].type;
 
 				bool base_implements_type = type.IsInterface &&
 					container.BaseType != null &&
 					container.BaseType.ImplementsInterface (type, false);
 
 				for (int j = 0; j < pending_implementations [i].methods.Count; ++j) {
 					var mi = pending_implementations[i].methods[j];
 					if (mi == null)
 						continue;
 
 					if (type.IsInterface){
 						var need_proxy =
 							pending_implementations [i].need_proxy [j];
 
 						if (need_proxy != null) {
 							DefineProxy (type, need_proxy, mi);
 							continue;
 						}
 
 						if (pending_implementations [i].optional)
 							continue;
 
 						MethodSpec candidate = null;
 						if (base_implements_type || BaseImplements (type, mi, out candidate))
 							continue;
 
 						if (candidate == null) {
 							MethodData md = pending_implementations [i].found [j];
 							if (md != null)
 								candidate = md.method.Spec;
 						}
 
 						Report.SymbolRelatedToPreviousError (mi);
 						if (candidate != null) {
 							Report.SymbolRelatedToPreviousError (candidate);
 							if (candidate.IsStatic) {
 								Report.Error (736, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' is static",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate));
 							} else if ((candidate.Modifiers & Modifiers.PUBLIC) == 0) {
 								Report.Error (737, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' in not public",
 									container.GetSignatureForError (), mi.GetSignatureForError (), candidate.GetSignatureForError ());
 							} else {
 								Report.Error (738, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' return type `{3}' does not match interface member return type `{4}'",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate),
 									TypeManager.CSharpName (candidate.ReturnType), TypeManager.CSharpName (mi.ReturnType));
 							}
 						} else {
 							Report.Error (535, container.Location, "`{0}' does not implement interface member `{1}'",
 								container.GetSignatureForError (), mi.GetSignatureForError ());
 						}
 					} else {
 						Report.SymbolRelatedToPreviousError (mi);
 						Report.Error (534, container.Location, "`{0}' does not implement inherited abstract member `{1}'",
 							container.GetSignatureForError (), mi.GetSignatureForError ());
 					}
 					errors = true;
 				}
 			}
 			return errors;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1622" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4453" endline="4530">
<![CDATA[
 
 		//
 		// We have failed to find exact match so we return error info about the closest match
 		//
 		void ReportOverloadError (ResolveContext rc, MemberSpec best_candidate, IParametersMember pm, Arguments args, bool params_expanded)
 		{
 			int ta_count = type_arguments == null ? 0 
 			int arg_count = args == null ? 0 
 
 			if (ta_count != best_candidate.Arity && (ta_count > 0 || ((IParametersMember) best_candidate).Parameters.IsEmpty)) {
 				var mg = new MethodGroupExpr (new [] { best_candidate }, best_candidate.DeclaringType, loc);
 				mg.Error_TypeArgumentsCannotBeUsed (rc.Report, loc, best_candidate, ta_count);
 				return;
 			}
 
 			if (lambda_conv_msgs != null) {
 				if (lambda_conv_msgs.Merge (rc.Report.Printer))
 					return;
 			}
 
 			//
 			// For candidates which match on parameters count report more details about incorrect arguments
 			//
 			if (pm != null) {
 				int unexpanded_count = ((IParametersMember) best_candidate).Parameters.HasParams ? pm.Parameters.Count - 1 
 				if (pm.Parameters.Count == arg_count || params_expanded || unexpanded_count == arg_count) {
 					// Reject any inaccessible member
 					if (!best_candidate.IsAccessible (rc.CurrentType) || !best_candidate.DeclaringType.IsAccessible (rc.CurrentType)) {
 						rc.Report.SymbolRelatedToPreviousError (best_candidate);
 						Expression.ErrorIsInaccesible (rc, best_candidate.GetSignatureForError (), loc);
 						return;
 					}
 
 					var ms = best_candidate as MethodSpec;
 					if (ms != null && ms.IsGeneric) {
 						bool constr_ok = true;
 						if (ms.TypeArguments != null)
 							constr_ok = new ConstraintChecker (rc.MemberContext).CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc);
 
 						if (ta_count == 0) {
 							if (custom_errors != null && custom_errors.TypeInferenceFailed (rc, best_candidate))
 								return;
 
 							if (constr_ok) {
 								rc.Report.Error (411, loc,
 									"The type arguments for method `{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly",
 									ms.GetGenericMethodDefinition ().GetSignatureForError ());
 							}
 
 							return;
 						}
 					}
 
 					VerifyArguments (rc, ref args, best_candidate, pm, params_expanded);
 					return;
 				}
 			}
 
 			//
 			// We failed to find any method with correct argument count, report best candidate
 			//
 			if (custom_errors != null && custom_errors.NoArgumentMatch (rc, best_candidate))
 				return;
 
 			if (best_candidate.Kind == MemberKind.Constructor) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				Error_ConstructorMismatch (rc, best_candidate.DeclaringType, arg_count, loc);
 			} else if (IsDelegateInvoke) {
 				rc.Report.SymbolRelatedToPreviousError (DelegateType);
 				rc.Report.Error (1593, loc, "Delegate `{0}' does not take `{1}' arguments",
 					DelegateType.GetSignatureForError (), arg_count.ToString ());
 			} else {
 				string name = best_candidate.Kind == MemberKind.Indexer ? "this" 
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.Error (1501, loc, "No overload for method `{0}' takes `{1}' arguments",
 					name, arg_count.ToString ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1623" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="869" endline="956">
<![CDATA[
 
 		Expression LiftResult (ResolveContext ec, Expression res_expr)
 		{
 			TypeExpr lifted_type;
 
 			//
 			// Avoid double conversion
 			//
 			if (left_unwrap == null || IsLeftNullLifted || left_unwrap.Type != left.Type || (left_unwrap != null && IsRightNullLifted)) {
 				lifted_type = new NullableType (left.Type, loc);
 				lifted_type = lifted_type.ResolveAsTypeTerminal (ec, false);
 				if (lifted_type == null)
 					return null;
 
 				if (left is UserCast || left is TypeCast)
 					left.Type = lifted_type.Type;
 				else
 					left = EmptyCast.Create (left, lifted_type.Type);
 			}
 
 			if (left != right && (right_unwrap == null || IsRightNullLifted || right_unwrap.Type != right.Type || (right_unwrap != null && IsLeftNullLifted))) {
 				lifted_type = new NullableType (right.Type, loc);
 				lifted_type = lifted_type.ResolveAsTypeTerminal (ec, false);
 				if (lifted_type == null)
 					return null;
 
 				var r = right;
 				if (r is ReducedExpression)
 					r = ((ReducedExpression) r).OriginalExpression;
 
 				if (r is UserCast || r is TypeCast)
 					r.Type = lifted_type.Type;
 				else
 					right = EmptyCast.Create (right, lifted_type.Type);
 			}
 
 			if ((Oper & Operator.ComparisonMask) == 0) {
 				lifted_type = new NullableType (res_expr.Type, loc);
 				lifted_type = lifted_type.ResolveAsTypeTerminal (ec, false);
 				if (lifted_type == null)
 					return null;
 
 				wrap_ctor = NullableInfo.GetConstructor (lifted_type.Type);
 				type = res_expr.Type = lifted_type.Type;
 			}
 
 			if (IsLeftNullLifted) {
 				left = LiftedNull.Create (right.Type, left.Location);
 
 				//
 				// Special case for bool?, the result depends on both null right side and left side value
 				//
 				if ((Oper == Operator.BitwiseAnd || Oper == Operator.BitwiseOr) && NullableInfo.GetUnderlyingType (type) == TypeManager.bool_type) {
 					return res_expr;
 				}
 
 				if ((Oper & (Operator.ArithmeticMask | Operator.ShiftMask | Operator.BitwiseMask)) != 0)
 					return LiftedNull.CreateFromExpression (ec, res_expr);
 
 				//
 				// Value types and null comparison
 				//
 				if (right_unwrap == null || (Oper & Operator.RelationalMask) != 0)
 					return CreateNullConstant (ec, right_orig).Resolve (ec);
 			}
 
 			if (IsRightNullLifted) {
 				right = LiftedNull.Create (left.Type, right.Location);
 
 				//
 				// Special case for bool?, the result depends on both null right side and left side value
 				//
 				if ((Oper == Operator.BitwiseAnd || Oper == Operator.BitwiseOr) && NullableInfo.GetUnderlyingType (type) == TypeManager.bool_type) {
 					return res_expr;
 				}
 
 				if ((Oper & (Operator.ArithmeticMask | Operator.ShiftMask | Operator.BitwiseMask)) != 0)
 					return LiftedNull.CreateFromExpression (ec, res_expr);
 
 				//
 				// Value types and null comparison
 				//
 				if (left_unwrap == null || (Oper & Operator.RelationalMask) != 0)
 					return CreateNullConstant (ec, left_orig);
 			}
 
 			return res_expr;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1624" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1275" endline="1368">
<![CDATA[
 
 		public override bool Resolve (BlockContext bc)
 		{
 			if (li.Type == null) {
 				TypeSpec type = null;
 				if (type_expr is VarExpr) {
 					//
 					// C# 3.0 introduced contextual keywords (var) which behaves like a type if type with
 					// same name exists or as a keyword when no type was found
 					// 
 					var texpr = type_expr.ResolveAsTypeTerminal (bc, true);
 					if (texpr == null) {
 						if (RootContext.Version < LanguageVersion.V_3)
 							bc.Report.FeatureIsNotAvailable (loc, "implicitly typed local variable");
 
 						if (li.IsFixed) {
 							bc.Report.Error (821, loc, "A fixed statement cannot use an implicitly typed local variable");
 							return false;
 						}
 
 						if (li.IsConstant) {
 							bc.Report.Error (822, loc, "An implicitly typed local variable cannot be a constant");
 							return false;
 						}
 
 						if (Initializer == null) {
 							bc.Report.Error (818, loc, "An implicitly typed local variable declarator must include an initializer");
 							return false;
 						}
 
 						if (declarators != null) {
 							bc.Report.Error (819, loc, "An implicitly typed local variable declaration cannot include multiple declarators");
 							declarators = null;
 						}
 
 						Initializer = Initializer.Resolve (bc);
 						if (Initializer != null) {
 							((VarExpr) type_expr).InferType (bc, Initializer);
 							type = type_expr.Type;
 						}
 					}
 				}
 
 				if (type == null) {
 					var texpr = type_expr.ResolveAsTypeTerminal (bc, false);
 					if (texpr == null)
 						return false;
 
 					type = texpr.Type;
 
 					if (li.IsConstant && !type.IsConstantCompatible) {
 						Const.Error_InvalidConstantType (type, loc, bc.Report);
 					}
 				}
 
 				if (type.IsStatic)
 					FieldBase.Error_VariableOfStaticClass (loc, li.Name, type, bc.Report);
 
 				if (type.IsPointer && !bc.IsUnsafe)
 					Expression.UnsafeError (bc, loc);
 
 				li.Type = type;
 			}
 
 			bool eval_global = RootContext.StatementMode && bc.CurrentBlock is ToplevelBlock;
 			if (eval_global) {
 				CreateEvaluatorVariable (bc, li);
 			} else {
 				li.PrepareForFlowAnalysis (bc);
 			}
 
 			if (initializer != null) {
 				initializer = ResolveInitializer (bc, li, initializer);
 				// li.Variable.DefinitelyAssigned 
 			}
 
 			if (declarators != null) {
 				foreach (var d in declarators) {
 					d.Variable.Type = li.Type;
 					if (eval_global) {
 						CreateEvaluatorVariable (bc, d.Variable);
 					} else {
 						d.Variable.PrepareForFlowAnalysis (bc);
 					}
 
 					if (d.Initializer != null) {
 						d.Initializer = ResolveInitializer (bc, d.Variable, d.Initializer);
 						// d.Variable.DefinitelyAssigned 
 					}
 				}
 				foreach (var d in declarators) {
 					d.Variable.Type = li.Type;
 					if (eval_global) {
 						CreateEvaluatorVariable (bc, d.Variable);
 					} else {
 						d.Variable.PrepareForFlowAnalysis (bc);
 					}
 
 					if (d.Initializer != null) {
 						d.Initializer = ResolveInitializer (bc, d.Variable, d.Initializer);
 						// d.Variable.DefinitelyAssigned 
 					}
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1625" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1317" endline="1341">
<![CDATA[
 
 		public override void SetParameterInfo (List<Constraints> constraints_list)
 		{
 			base.SetParameterInfo (constraints_list);
 
 			if (PartialContainer.CurrentTypeParameters == null || PartialContainer == this)
 				return;
 
 			TypeParameter[] tc_names = PartialContainer.CurrentTypeParameters;
 			for (int i = 0; i < tc_names.Length; ++i) {
 				if (tc_names [i].Name != type_params [i].Name) {
 					Report.SymbolRelatedToPreviousError (PartialContainer.Location, "");
 					Report.Error (264, Location, "Partial declarations of `{0}' must have the same type parameter names in the same order",
 						GetSignatureForError ());
 					break;
 				}
 
 				if (tc_names [i].Variance != type_params [i].Variance) {
 					Report.SymbolRelatedToPreviousError (PartialContainer.Location, "");
 					Report.Error (1067, Location, "Partial declarations of `{0}' must have the same type parameter variance modifiers",
 						GetSignatureForError ());
 					break;
 				}
 			}
 			for (int i = 0; i < tc_names.Length; ++i) {
 				if (tc_names [i].Name != type_params [i].Name) {
 					Report.SymbolRelatedToPreviousError (PartialContainer.Location, "");
 					Report.Error (264, Location, "Partial declarations of `{0}' must have the same type parameter names in the same order",
 						GetSignatureForError ());
 					break;
 				}
 
 				if (tc_names [i].Variance != type_params [i].Variance) {
 					Report.SymbolRelatedToPreviousError (PartialContainer.Location, "");
 					Report.Error (1067, Location, "Partial declarations of `{0}' must have the same type parameter variance modifiers",
 						GetSignatureForError ());
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1626" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2511" endline="2563">
<![CDATA[
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			TypeExpr[] ifaces = base.ResolveBaseTypes (out base_class);
 
 			if (base_class == null) {
 				if (spec != TypeManager.object_type)
 					base_type = TypeManager.object_type;
 			} else {
 				if (base_type.IsGenericParameter){
 					Report.Error (689, base_class.Location, "`{0}'
 						GetSignatureForError (), base_type.GetSignatureForError ());
 				} else if (IsGeneric && base_type.IsAttribute) {
 					Report.Error (698, base_class.Location,
 						"A generic type cannot derive from `{0}' because it is an attribute class",
 						base_class.GetSignatureForError ());
 				} else if (base_type.IsStatic) {
 					Report.SymbolRelatedToPreviousError (base_class.Type);
 					Report.Error (709, Location, "`{0}'
 						GetSignatureForError (), base_type.GetSignatureForError ());
 				} else if (base_type.IsSealed) {
 					Report.SymbolRelatedToPreviousError (base_class.Type);
 					Report.Error (509, Location, "`{0}'
 						GetSignatureForError (), base_type.GetSignatureForError ());
 				} else if (PartialContainer.IsStatic && base_class.Type != TypeManager.object_type) {
 					Report.Error (713, Location, "Static class `{0}' cannot derive from type `{1}'. Static classes must derive from object",
 						GetSignatureForError (), base_class.GetSignatureForError ());
 				}
 
 				if (base_type is BuildinTypeSpec && !(spec is BuildinTypeSpec) &&
 					(base_type == TypeManager.enum_type || base_type == TypeManager.value_type || base_type == TypeManager.multicast_delegate_type ||
 					base_type == TypeManager.delegate_type || base_type == TypeManager.array_type)) {
 					Report.Error (644, Location, "`{0}' cannot derive from special class `{1}'",
 						GetSignatureForError (), base_type.GetSignatureForError ());
 
 					base_type = TypeManager.object_type;
 				}
 
 				if (!IsAccessibleAs (base_type)) {
 					Report.SymbolRelatedToPreviousError (base_type);
 					Report.Error (60, Location, "Inconsistent accessibility
 						base_type.GetSignatureForError (), GetSignatureForError ());
 				}
 			}
 
 			if (PartialContainer.IsStatic && ifaces != null) {
 				foreach (TypeExpr t in ifaces)
 					Report.SymbolRelatedToPreviousError (t.Type);
 				foreach (TypeExpr t in ifaces)
 					Report.SymbolRelatedToPreviousError (t.Type);
 				Report.Error (714, Location, "Static class `{0}' cannot implement interfaces", GetSignatureForError ());
 			}
 
 			return ifaces;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1627" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4833" endline="4895">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			ec.StartFlowBranching (this);
 
 			if (!Block.Resolve (ec))
 				ok = false;
 
 			TypeSpec[] prev_catches = new TypeSpec [Specific.Count];
 			int last_index = 0;
 			foreach (Catch c in Specific){
 				ec.CurrentBranching.CreateSibling (c.Block, FlowBranching.SiblingType.Catch);
 
 				if (!c.Resolve (ec)) {
 					ok = false;
 					continue;
 				}
 
 				TypeSpec resolved_type = c.CatchType;
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 
 				prev_catches [last_index++] = resolved_type;
 			}
 			foreach (Catch c in Specific){
 				ec.CurrentBranching.CreateSibling (c.Block, FlowBranching.SiblingType.Catch);
 
 				if (!c.Resolve (ec)) {
 					ok = false;
 					continue;
 				}
 
 				TypeSpec resolved_type = c.CatchType;
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 
 				prev_catches [last_index++] = resolved_type;
 			}
 
 			if (General != null) {
 				foreach (Catch c in Specific) {
 					if (c.CatchType != TypeManager.exception_type)
 						continue;
 
 					if (!ec.Module.DeclaringAssembly.WrapNonExceptionThrows)
 						continue;
 
 					if (!ec.Module.PredefinedAttributes.RuntimeCompatibility.IsDefined)
 						continue;
 
 					ec.Report.Warning (1058, 1, c.loc,
 						"A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a `System.Runtime.CompilerServices.RuntimeWrappedException'");
 				}
 				foreach (Catch c in Specific) {
 					if (c.CatchType != TypeManager.exception_type)
 						continue;
 
 					if (!ec.Module.DeclaringAssembly.WrapNonExceptionThrows)
 						continue;
 
 					if (!ec.Module.PredefinedAttributes.RuntimeCompatibility.IsDefined)
 						continue;
 
 					ec.Report.Warning (1058, 1, c.loc,
 						"A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a `System.Runtime.CompilerServices.RuntimeWrappedException'");
 				}
 
 				ec.CurrentBranching.CreateSibling (General.Block, FlowBranching.SiblingType.Catch);
 
 				if (!General.Resolve (ec))
 					ok = false;
 			}
 
 			ec.EndFlowBranching ();
 
 			// System.Reflection.Emit automatically emits a 'leave' at the end of a try/catch clause
 			// So, ensure there's some IL code after this statement
 			if (!inside_try_finally && !code_follows && ec.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				ec.NeedReturnLabel ();
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1628" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1940" endline="1973">
<![CDATA[
 
 		//
 		// Emits the code
 		// 
 		public void Emit (DeclSpace parent)
 		{
 			if (GenericMethod != null)
 				GenericMethod.EmitAttributes ();
 
 			var mc = (IMemberContext) method;
 
 			method.ParameterInfo.ApplyAttributes (mc, MethodBuilder);
 
 			SourceMethod source = SourceMethod.Create (parent, MethodBuilder, method.Block);
 
 			ToplevelBlock block = method.Block;
 			if (block != null) {
 				BlockContext bc = new BlockContext (mc, block, method.ReturnType);
 				if (block.Resolve (null, bc, method)) {
 					EmitContext ec = method.CreateEmitContext (MethodBuilder.GetILGenerator ());
 					if (!ec.HasReturnLabel && bc.HasReturnLabel) {
 						ec.ReturnLabel = bc.ReturnLabel;
 						ec.HasReturnLabel = true;
 					}
 
 					block.Emit (ec);
 				}
 			}
 
 			if (source != null) {
 				method.EmitExtraSymbolInfo (source);
 				source.CloseMethod ();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1629" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1346" endline="1435">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (base.DoResolve (ec) == null)
 				return null;
 
 			TypeSpec d = expr.Type;
 			bool d_is_nullable = false;
 
 			//
 			// If E is a method group or the null literal, or if the type of E is a reference
 			// type or a nullable type and the value of E is null, the result is false
 			//
 			if (expr.IsNull || expr.eclass == ExprClass.MethodGroup)
 				return CreateConstantResult (ec, false);
 
 			if (TypeManager.IsNullableType (d)) {
 				var ut = Nullable.NullableInfo.GetUnderlyingType (d);
 				if (!ut.IsGenericParameter) {
 					d = ut;
 					d_is_nullable = true;
 				}
 			}
 
 			type = TypeManager.bool_type;
 			eclass = ExprClass.Value;
 			TypeSpec t = probe_type_expr.Type;
 			bool t_is_nullable = false;
 			if (TypeManager.IsNullableType (t)) {
 				var ut = Nullable.NullableInfo.GetUnderlyingType (t);
 				if (!ut.IsGenericParameter) {
 					t = ut;
 					t_is_nullable = true;
 				}
 			}
 
 			if (TypeManager.IsStruct (t)) {
 				if (d == t) {
 					//
 					// D and T are the same value types but D can be null
 					//
 					if (d_is_nullable && !t_is_nullable) {
 						expr_unwrap = Nullable.Unwrap.Create (expr, false);
 						return this;
 					}
 					
 					//
 					// The result is true if D and T are the same value types
 					//
 					return CreateConstantResult (ec, true);
 				}
 
 				var tp = d as TypeParameterSpec;
 				if (tp != null)
 					return ResolveGenericParameter (ec, t, tp);
 
 				//
 				// An unboxing conversion exists
 				//
 				if (Convert.ExplicitReferenceConversionExists (d, t))
 					return this;
 			} else {
 				if (TypeManager.IsGenericParameter (t))
 					return ResolveGenericParameter (ec, d, (TypeParameterSpec) t);
 
 				if (t == InternalType.Dynamic) {
 					ec.Report.Warning (1981, 3, loc,
 						"Using `{0}' to test compatibility with `{1}' is identical to testing compatibility with `object'",
 						OperatorName, t.GetSignatureForError ());
 				}
 
 				if (TypeManager.IsStruct (d) && d != TypeManager.void_type) {
 					if (Convert.ImplicitBoxingConversion (null, d, t) != null)
 						return CreateConstantResult (ec, true);
 				} else {
 					if (TypeManager.IsGenericParameter (d))
 						return ResolveGenericParameter (ec, t, (TypeParameterSpec) d);
 
 					if (InflatedTypeSpec.ContainsTypeParameter (d))
 						return this;
 
 					if (Convert.ImplicitReferenceConversionExists (expr, t) ||
 						Convert.ExplicitReferenceConversionExists (d, t)) {
 						return this;
 					}
 				}
 			}
 
 			return CreateConstantResult (ec, false);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1630" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5507" endline="5538">
<![CDATA[
 
 		public abstract SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source);
 
 		protected abstract Expression OverloadResolve (ResolveContext rc, Expression right_side);
 
 		bool ResolveGetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasGet) {
 				if (InstanceExpression != EmptyExpression.Null) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate);
 					rc.Report.Error (154, loc, "The property or indexer `{0}' cannot be used in this context because it lacks the `get' accessor",
 						best_candidate.GetSignatureForError ());
 					return false;
 				}
 			} else if (!best_candidate.Get.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					rc.Report.Error (271, loc, "The property or indexer `{0}' cannot be used in this context because the get accessor is inaccessible",
 						TypeManager.CSharpSignature (best_candidate));
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					ErrorIsInaccesible (rc, best_candidate.Get.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility) {
 				CheckProtectedMemberAccess (rc, best_candidate.Get);
 			}
 
 			getter = CandidateToBaseOverride (rc, best_candidate.Get);
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1631" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="98" endline="136">
<![CDATA[
 		public Namespace (Namespace parent, string name)
 		{
 			// Expression members.
 			this.eclass = ExprClass.Namespace;
 			this.Type = InternalType.FakeInternalType;
 			this.loc = Location.Null;
 
 			this.parent = parent;
 
 			if (parent != null)
 				this.root = parent.root;
 			else
 				this.root = this as RootNamespace;
 
 			if (this.root == null)
 				throw new InternalErrorException ("Root namespaces must be created using RootNamespace");
 			
 			string pname = parent != null ? parent.fullname 
 				
 			if (pname == "")
 				fullname = name;
 			else
 				fullname = parent.fullname + "." + name;
 
 			if (fullname == null)
 				throw new InternalErrorException ("Namespace has a null fullname");
 
 			if (parent != null && parent.MemberName != MemberName.Null)
 				MemberName = new MemberName (parent.MemberName, name);
 			else if (name.Length == 0)
 				MemberName = MemberName.Null;
 			else
 				MemberName = new MemberName (name);
 
 			namespaces = new Dictionary<string, Namespace> ();
 			cached_types = new Dictionary<string, TypeExpr> ();
 
 			root.RegisterNamespace (this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1632" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3434" endline="3517">
<![CDATA[
 
 		//
 		// Performs user-operator overloading
 		//
 		protected virtual Expression ResolveUserOperator (ResolveContext ec, Expression left, Expression right)
 		{
 			var op = ConvertBinaryToUserOperator (oper);
 			var l = left.Type;
 			if (TypeManager.IsNullableType (l))
 				l = Nullable.NullableInfo.GetUnderlyingType (l);
 			var r = right.Type;
 			if (TypeManager.IsNullableType (r))
 				r = Nullable.NullableInfo.GetUnderlyingType (r);
 
 			IList<MemberSpec> left_operators = MemberCache.GetUserOperator (l, op, false);
 			IList<MemberSpec> right_operators = null;
 
 			if (l != r) {
 				right_operators = MemberCache.GetUserOperator (r, op, false);
 				if (right_operators == null && left_operators == null)
 					return null;
 			} else if (left_operators == null) {
 				return null;
 			}
 
 			Arguments args = new Arguments (2);
 			Argument larg = new Argument (left);
 			args.Add (larg);
 			Argument rarg = new Argument (right);
 			args.Add (rarg);
 
 			//
 			// User-defined operator implementations always take precedence
 			// over predefined operator implementations
 			//
 			if (left_operators != null && right_operators != null) {
 				left_operators = CombineUserOperators (left_operators, right_operators);
 			} else if (right_operators != null) {
 				left_operators = right_operators;
 			}
 
 			var res = new OverloadResolver (left_operators, OverloadResolver.Restrictions.ProbingOnly | 
 				OverloadResolver.Restrictions.NoBaseMembers | OverloadResolver.Restrictions.BaseMembersIncluded, loc);
 
 			var oper_method = res.ResolveOperator (ec, ref args);
 			if (oper_method == null)
 				return null;
 
 			var llifted = (state & State.LeftNullLifted) != 0;
 			var rlifted = (state & State.RightNullLifted) != 0;
 			if ((Oper & Operator.EqualityMask) != 0) {
 				var parameters = oper_method.Parameters;
 				// LAMESPEC
 				if ((left is Nullable.Unwrap || right is Nullable.Unwrap) && parameters.Types [0] != parameters.Types [1])
 					return null;
 
 				// Binary operation was lifted but we have found a user operator
 				// which requires value-type argument, we downgrade ourself back to
 				// binary operation
 				// LAMESPEC
 				// but compilation succeeds
 				if ((llifted && !parameters.Types[0].IsStruct) || (rlifted && !parameters.Types[1].IsStruct)) {
 					state &= ~(State.LeftNullLifted | State.RightNullLifted);
 				}
 			}
 
 			Expression oper_expr;
 
 			// TODO
 			if ((oper & Operator.LogicalMask) != 0) {
 				oper_expr = new ConditionalLogicalOperator (oper_method, args, CreateExpressionTree,
 					oper == Operator.LogicalAnd, loc).Resolve (ec);
 			} else {
 				oper_expr = new UserOperatorCall (oper_method, args, CreateExpressionTree, loc);
 			}
 
 			if (!llifted)
 				this.left = larg.Expr;
 
 			if (!rlifted)
 				this.right = rarg.Expr;
 
 			return oper_expr;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1633" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="3118" endline="3189">
<![CDATA[
 
 		//
 		// 26.3.3.6 Output Type Inference
 		//
 		public int OutputTypeInference (ResolveContext ec, Expression e, TypeSpec t)
 		{
 			// If e is a lambda or anonymous method with inferred return type
 			AnonymousMethodExpression ame = e as AnonymousMethodExpression;
 			if (ame != null) {
 				TypeSpec rt = ame.InferReturnType (ec, this, t);
 				var invoke = Delegate.GetInvokeMethod (ec.Compiler, t);
 
 				if (rt == null) {
 					AParametersCollection pd = invoke.Parameters;
 					return ame.Parameters.Count == pd.Count ? 1 
 				}
 
 				TypeSpec rtype = invoke.ReturnType;
 				return LowerBoundInference (rt, rtype) + 1;
 			}
 
 			//
 			// if E is a method group and T is a delegate type or expression tree type
 			// return type Tb with parameter types T1..Tk and return type Tb, and overload
 			// resolution of E with the types T1..Tk yields a single method with return type U,
 			// then a lower-bound inference is made from U for Tb.
 			//
 			if (e is MethodGroupExpr) {
 				if (!TypeManager.IsDelegateType (t)) {
 					if (TypeManager.expression_type == null || t.MemberDefinition != TypeManager.expression_type.MemberDefinition)
 						return 0;
 
 					t = TypeManager.GetTypeArguments (t)[0];
 				}
 
 				var invoke = Delegate.GetInvokeMethod (ec.Compiler, t);
 				TypeSpec rtype = invoke.ReturnType;
 
 				if (!rtype.IsGenericParameter && !TypeManager.IsGenericType (rtype))
 					return 0;
 
 				// LAMESPEC
 				// has to be fixed but it does not specify how to do recursive type inference
 				// either. We choose the simple option and infer return type only
 				// if all delegate generic arguments are fixed.
 				TypeSpec[] param_types = new TypeSpec [invoke.Parameters.Count];
 				for (int i = 0; i < param_types.Length; ++i) {
 					var inflated = InflateGenericArgument (invoke.Parameters.Types[i]);
 					if (inflated == null)
 						return 0;
 
 					if (IsUnfixed (inflated) >= 0)
 						return 0;
 
 					param_types[i] = inflated;
 				}
 				for (int i = 0; i < param_types.Length; ++i) {
 					var inflated = InflateGenericArgument (invoke.Parameters.Types[i]);
 					if (inflated == null)
 						return 0;
 
 					if (IsUnfixed (inflated) >= 0)
 						return 0;
 
 					param_types[i] = inflated;
 				}
 
 				MethodGroupExpr mg = (MethodGroupExpr) e;
 				Arguments args = DelegateCreation.CreateDelegateMethodArguments (invoke.Parameters, param_types, e.Location);
 				mg = mg.OverloadResolve (ec, ref args, null, OverloadResolver.Restrictions.CovariantDelegate | OverloadResolver.Restrictions.ProbingOnly);
 				if (mg == null)
 					return 0;
 
 				return LowerBoundInference (mg.BestCandidateReturnType, rtype) + 1;
 			}
 
 			//
 			// if e is an expression with type U, then
 			// a lower-bound inference is made from U for T
 			//
 			return LowerBoundInference (e.Type, t) * 2;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1634" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="186" endline="280">
<![CDATA[
 
 		void DefineAsyncMethods (CallingConventions cc)
 		{
 			var iasync_result = Module.PredefinedTypes.IAsyncResult;
 			var async_callback = Module.PredefinedTypes.AsyncCallback;
 
 			//
 			// It's ok when async types don't exist, the delegate will have Invoke method only
 			//
 			if (!iasync_result.Define () || !async_callback.Define ())
 				return;
 
 			//
 			// BeginInvoke
 			//
 			ParametersCompiled async_parameters;
 			if (Parameters.Count == 0) {
 				async_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 			} else {
 				var compiled = new Parameter[Parameters.Count];
 				for (int i = 0; i < compiled.Length; ++i) {
 					var p = parameters[i];
 					compiled[i] = new Parameter (new TypeExpression (parameters.Types[i], Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 				for (int i = 0; i < compiled.Length; ++i) {
 					var p = parameters[i];
 					compiled[i] = new Parameter (new TypeExpression (parameters.Types[i], Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 
 				async_parameters = new ParametersCompiled (compiled);
 			}
 
 			async_parameters = ParametersCompiled.MergeGenerated (Compiler, async_parameters, false,
 				new Parameter[] {
 					new Parameter (new TypeExpression (async_callback.TypeSpec, Location), "callback", Parameter.Modifier.NONE, null, Location),
 					new Parameter (new TypeExpression (TypeManager.object_type, Location), "object", Parameter.Modifier.NONE, null, Location)
 				},
 				new [] {
 					async_callback.TypeSpec,
 					TypeManager.object_type
 				}
 			);
 
 			BeginInvokeBuilder = new Method (this, null,
 				new TypeExpression (iasync_result.TypeSpec, Location), MethodModifiers,
 				new MemberName ("BeginInvoke"), async_parameters, null);
 			BeginInvokeBuilder.Define ();
 
 			//
 			// EndInvoke is a bit more interesting, all the parameters labeled as
 			// out or ref have to be duplicated here.
 			//
 
 			//
 			// Define parameters, and count out/ref parameters
 			//
 			ParametersCompiled end_parameters;
 			int out_params = 0;
 
 			foreach (Parameter p in Parameters.FixedParameters) {
 				if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 					++out_params;
 			}
 			foreach (Parameter p in Parameters.FixedParameters) {
 				if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 					++out_params;
 			}
 
 			if (out_params > 0) {
 				Parameter[] end_params = new Parameter[out_params];
 
 				int param = 0;
 				for (int i = 0; i < Parameters.FixedParameters.Length; ++i) {
 					Parameter p = parameters [i];
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) == 0)
 						continue;
 
 					end_params [param++] = new Parameter (new TypeExpression (p.Type, Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 				for (int i = 0; i < Parameters.FixedParameters.Length; ++i) {
 					Parameter p = parameters [i];
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) == 0)
 						continue;
 
 					end_params [param++] = new Parameter (new TypeExpression (p.Type, Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 
 				end_parameters = new ParametersCompiled (end_params);
 			} else {
 				end_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 			}
 
 			end_parameters = ParametersCompiled.MergeGenerated (Compiler, end_parameters, false,
 				new Parameter (
 					new TypeExpression (iasync_result.TypeSpec, Location),
 					"result", Parameter.Modifier.NONE, null, Location),
 				iasync_result.TypeSpec);
 
 			//
 			// Create method, define parameters, register parameters with type system
 			//
 			EndInvokeBuilder = new Method (this, null, ReturnType, MethodModifiers, new MemberName ("EndInvoke"), end_parameters, null);
 			EndInvokeBuilder.Define ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1635" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7800" endline="7870">
<![CDATA[
 
 		public FullNamedExpression ResolveNamespaceOrType (IMemberContext rc, bool silent)
 		{
 			FullNamedExpression expr_resolved = expr.ResolveAsTypeStep (rc, silent);
 
 			if (expr_resolved == null)
 				return null;
 
 			Namespace ns = expr_resolved as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					if (!silent)
 						ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 				} else if (HasTypeArguments) {
 					retval = new GenericTypeExpr (retval.Type, targs, loc).ResolveAsTypeStep (rc, silent);
 				}
 
 				return retval;
 			}
 
 			TypeExpr tnew_expr = expr_resolved.ResolveAsTypeTerminal (rc, false);
 			if (tnew_expr == null)
 				return null;
 
 			TypeSpec expr_type = tnew_expr.Type;
 			if (TypeManager.IsGenericParameter (expr_type)) {
 				rc.Compiler.Report.Error (704, loc, "A nested type cannot be specified through a type parameter `{0}'",
 					tnew_expr.GetSignatureForError ());
 				return null;
 			}
 
 			TypeSpec nested = null;
 			while (expr_type != null) {
 				nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 				if (nested == null) {
 					if (silent)
 						return null;
 
 					if (expr_type == tnew_expr.Type) {
 						Error_IdentifierNotFound (rc, expr_type, Name);
 						return null;
 					}
 
 					expr_type = tnew_expr.Type;
 					nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 					ErrorIsInaccesible (rc, nested.GetSignatureForError (), loc);
 					break;
 				}
 
 				if (nested.IsAccessible (rc.CurrentType))
 					break;
 
 				// Keep looking after inaccessible candidate
 				expr_type = nested.DeclaringType.BaseType;
 			}
 			while (expr_type != null) {
 				nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 				if (nested == null) {
 					if (silent)
 						return null;
 
 					if (expr_type == tnew_expr.Type) {
 						Error_IdentifierNotFound (rc, expr_type, Name);
 						return null;
 					}
 
 					expr_type = tnew_expr.Type;
 					nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 					ErrorIsInaccesible (rc, nested.GetSignatureForError (), loc);
 					break;
 				}
 
 				if (nested.IsAccessible (rc.CurrentType))
 					break;
 
 				// Keep looking after inaccessible candidate
 				expr_type = nested.DeclaringType.BaseType;
 			}
 			
 			TypeExpr texpr;
 			if (Arity > 0) {
 				if (HasTypeArguments) {
 					texpr = new GenericTypeExpr (nested, targs, loc);
 				} else {
 					texpr = new GenericOpenTypeExpr (nested, loc);
 				}
 			} else {
 				texpr = new TypeExpression (nested, loc);
 			}
 
 			return texpr.ResolveAsTypeStep (rc, false);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1636" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3192" endline="3322">
<![CDATA[
 
 		//
 		// 7.9.6 Reference type equality operators
 		//
 		Expression ResolveOperatorEquality (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			Expression result;
 			type = TypeManager.bool_type;
 
 			//
 			// a, Both operands are reference-type values or the value null
 			// b, One operand is a value of type T where T is a type-parameter and
 			// the other operand is the value null. Furthermore T does not have the
 			// value type constraint
 			//
 			// LAMESPEC
 			// reference like type-parameter is allowed
 			//
 			var tparam_l = l as TypeParameterSpec;
 			var tparam_r = r as TypeParameterSpec;
 			if (tparam_l != null) {
 				if (right is NullLiteral && !tparam_l.HasSpecialStruct) {
 					left = new BoxedCast (left, TypeManager.object_type);
 					return this;
 				}
 
 				if (!tparam_l.IsReferenceType)
 					return null;
 
 				l = tparam_l.GetEffectiveBase ();
 				left = new BoxedCast (left, l);
 			} else if (left is NullLiteral && tparam_r == null) {
 				if (!TypeManager.IsReferenceType (r) || r.Kind == MemberKind.InternalCompilerType)
 					return null;
 
 				return this;
 			}
 
 			if (tparam_r != null) {
 				if (left is NullLiteral && !tparam_r.HasSpecialStruct) {
 					right = new BoxedCast (right, TypeManager.object_type);
 					return this;
 				}
 
 				if (!tparam_r.IsReferenceType)
 					return null;
 
 				r = tparam_r.GetEffectiveBase ();
 				right = new BoxedCast (right, r);
 			} else if (right is NullLiteral) {
 				if (!TypeManager.IsReferenceType (l) || l.Kind == MemberKind.InternalCompilerType)
 					return null;
 
 				return this;
 			}
 
 			//
 			// LAMESPEC
 			//
 			if (l.IsDelegate) {
 				if (right.eclass == ExprClass.MethodGroup) {
 					result = Convert.ImplicitConversion (ec, right, l, loc);
 					if (result == null)
 						return null;
 
 					right = result;
 					r = l;
 				} else if (r.IsDelegate && l != r) {
 					return null;
 				}
 			} else if (left.eclass == ExprClass.MethodGroup && r.IsDelegate) {
 				result = Convert.ImplicitConversionRequired (ec, left, r, loc);
 				if (result == null)
 					return null;
 
 				left = result;
 				l = r;
 			}
 
 			//
 			// bool operator != (string a, string b)
 			// bool operator == (string a, string b)
 			//
 			// bool operator != (Delegate a, Delegate b)
 			// bool operator == (Delegate a, Delegate b)
 			//
 			// bool operator != (bool a, bool b)
 			// bool operator == (bool a, bool b)
 			//
 			// LAMESPEC
 			// they implement an implicit conversion to any of types above.
 			//
 			if (r != TypeManager.object_type && l != TypeManager.object_type) {
 				result = ResolveOperatorPredefined (ec, equality_operators, false, null);
 				if (result != null)
 					return result;
 			}
 
 			//
 			// bool operator != (object a, object b)
 			// bool operator == (object a, object b)
 			//
 			// An explicit reference conversion exists from the
 			// type of either operand to the type of the other operand.
 			//
 
 			// Optimize common path
 			if (l == r) {
 				return l.Kind == MemberKind.InternalCompilerType || l.Kind == MemberKind.Struct ? null 
 			}
 
 			if (!Convert.ExplicitReferenceConversionExists (l, r) &&
 				!Convert.ExplicitReferenceConversionExists (r, l))
 				return null;
 
 			// Reject allowed explicit conversions like int->object
 			if (!TypeManager.IsReferenceType (l) || !TypeManager.IsReferenceType (r))
 				return null;
 
 			if (l == TypeManager.string_type || l == TypeManager.delegate_type || MemberCache.GetUserOperator (l, CSharp.Operator.OpType.Equality, false) != null)
 				ec.Report.Warning (253, 2, loc,
 					"Possible unintended reference comparison. Consider casting the right side expression to type `{0}' to get value comparison",
 					l.GetSignatureForError ());
 
 			if (r == TypeManager.string_type || r == TypeManager.delegate_type || MemberCache.GetUserOperator (r, CSharp.Operator.OpType.Equality, false) != null)
 				ec.Report.Warning (252, 2, loc,
 					"Possible unintended reference comparison. Consider casting the left side expression to type `{0}' to get value comparison",
 					r.GetSignatureForError ());
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1637" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1056" endline="1152">
<![CDATA[
 
 		//
 		// Creates the type
 		//
 		public override bool Define ()
 		{
 			if (type_expr.Type == TypeManager.void_type && parameters.IsEmpty && MemberName.Arity == 0 && MemberName.Name == Destructor.MetadataName) {
 				Report.Warning (465, 1, Location, "Introducing `Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?");
 			}
 
 			if (!base.Define ())
 				return false;
 
 			if (partialMethodImplementation != null && IsPartialDefinition)
 				MethodBuilder = partialMethodImplementation.MethodBuilder;
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ReturnType)) {
 				Error1599 (Location, ReturnType, Report);
 				return false;
 			}
 
 			if (CurrentTypeParameters == null) {
 				if (base_method != null) {
 					if (parameters.Count == 1 && ParameterTypes[0] == TypeManager.object_type && Name == "Equals")
 						Parent.PartialContainer.Mark_HasEquals ();
 					else if (parameters.IsEmpty && Name == "GetHashCode")
 						Parent.PartialContainer.Mark_HasGetHashCode ();
 				}
 					
 			} else {
 				DefineTypeParameters ();
 			}
 
 			if (block != null && block.IsIterator) {
 				//
 				// Current method is turned into automatically generated
 				// wrapper which creates an instance of iterator
 				//
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 				ModFlags |= Modifiers.DEBUGGER_HIDDEN;
 			}
 
 			if ((ModFlags & Modifiers.STATIC) == 0)
 				return true;
 
 			if (parameters.HasExtensionMethodType) {
 				if (Parent.PartialContainer.IsStatic && !Parent.IsGeneric) {
 					if (!Parent.IsTopLevel)
 						Report.Error (1109, Location, "`{0}'
 							GetSignatureForError ());
 
 					PredefinedAttribute pa = Module.PredefinedAttributes.Extension;
 					if (!pa.IsDefined) {
 						Report.Error (1110, Location,
 							"`{0}'
 							GetSignatureForError ());
 					}
 
 					ModFlags |= Modifiers.METHOD_EXTENSION;
 					Parent.PartialContainer.ModFlags |= Modifiers.METHOD_EXTENSION;
 					Spec.DeclaringType.SetExtensionMethodContainer ();
 					Parent.Module.HasExtensionMethod = true;
 				} else {
 					Report.Error (1106, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			}
 
 			//
 			// This is used to track the Entry Point,
 			//
 			if (RootContext.NeedsEntryPoint &&
 				Name == "Main" &&
 				(RootContext.MainClass == null ||
 				RootContext.MainClass == Parent.TypeBuilder.FullName)){
 				if (IsEntryPoint ()) {
 
 					if (Parent.DeclaringAssembly.EntryPoint == null) {
 						if (Parent.IsGeneric || MemberName.IsGeneric) {
 							Report.Warning (402, 4, Location, "`{0}'
 								GetSignatureForError ());
 						} else {
 							SetIsUsed ();
 							Parent.DeclaringAssembly.EntryPoint = this;
 						}
 					} else {
 						Error_DuplicateEntryPoint (Parent.DeclaringAssembly.EntryPoint);
 						Error_DuplicateEntryPoint (this);
 					}
 				} else {
 					Report.Warning (28, 4, Location, "`{0}' has the wrong signature to be an entry point",
 						GetSignatureForError ());
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1638" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1027" endline="1155">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			
 			if (expr == null)
 				return null;
 
 			if (expr.Type == InternalType.Dynamic) {
 				//
 				// Handle postfix unary operators using local
 				// temporary variable
 				//
 				if ((mode & Mode.IsPost) != 0)
 					expr = new DynamicPostMutator (expr);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new SimpleAssign (expr, new DynamicUnaryConversion (GetOperatorExpressionTypeName (), args, loc)).Resolve (ec);
 			}
 
 			if (TypeManager.IsNullableType (expr.Type))
 				return new Nullable.LiftedUnaryMutator (mode, expr, loc).Resolve (ec);
 
 			eclass = ExprClass.Value;
 			type = expr.Type;
 
 			if (expr is RuntimeValueExpression) {
 				operation = expr;
 			} else {
 				// Use itself at the top of the stack
 				operation = new EmptyExpression (type);
 			}
 
 			//
 			// The operand of the prefix/postfix increment decrement operators
 			// should be an expression that is classified as a variable,
 			// a property access or an indexer access
 			//
 			// TODO
 			if (expr.eclass == ExprClass.Variable || expr.eclass == ExprClass.IndexerAccess || expr.eclass == ExprClass.PropertyAccess) {
 				expr = expr.ResolveLValue (ec, expr);
 			} else {
 				ec.Report.Error (1059, loc, "The operand of an increment or decrement operator must be a variable, property or indexer");
 			}
 
 			//
 			// Step 1
 			//
 			var user_op = IsDecrement ? Operator.OpType.Decrement 
 			var methods = MemberCache.GetUserOperator (type, user_op, false);
 
 			if (methods != null) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 
 				var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 				var method = res.ResolveOperator (ec, ref args);
 				if (method == null)
 					return null;
 
 				args[0].Expr = operation;
 				operation = new UserOperatorCall (method, args, null, loc);
 				operation = Convert.ImplicitConversionRequired (ec, operation, type, loc);
 				return this;
 			}
 
 			//
 			// Step 2
 			//
 			if (predefined == null)
 				CreatePredefinedOperators ();
 
 			// Predefined without user conversion first for speed-up
 			Expression source = null;
 			bool primitive_type = false;
 			foreach (var t in predefined) {
 				if (t == type) {
 					source = operation;
 					primitive_type = true;
 					break;
 				}
 			}
 			foreach (var t in predefined) {
 				if (t == type) {
 					source = operation;
 					primitive_type = true;
 					break;
 				}
 			}
 
 			// ++/-- on pointer variables of all types except void*
 			if (source == null && type.IsPointer) {
 				if (((PointerContainer) type).Element.BuildinType == BuildinTypeSpec.Type.Void) {
 					Error_VoidPointerOperation (ec);
 					return null;
 				}
 
 				source = operation;
 			}
 
 			if (source == null) {
 				// LAMESPEC
 				foreach (var t in predefined) {
 					source = Convert.ImplicitUserConversion (ec, operation, t, loc);
 					if (source != null) {
 						break;
 					}
 				}
 				foreach (var t in predefined) {
 					source = Convert.ImplicitUserConversion (ec, operation, t, loc);
 					if (source != null) {
 						break;
 					}
 				}
 			}
 
 			// ++/-- on enum types
 			if (source == null && type.IsEnum)
 				source = operation;
 
 			if (source == null) {
 				Unary.Error_OperatorCannotBeApplied (ec, loc, Operator.GetName (user_op), type);
 				return null;
 			}
 
 			var one = new IntConstant (1, loc);
 			var op = IsDecrement ? Binary.Operator.Subtraction 
 			operation = new Binary (op, source, one, loc);
 			operation = operation.Resolve (ec);
 			if (operation == null)
 				throw new NotImplementedException ("should not be reached");
 
 			if (operation.Type != type) {
 				if (primitive_type)
 					operation = Convert.ExplicitNumericConversion (operation, type);
 				else
 					operation = Convert.ImplicitConversionRequired (ec, operation, type, loc);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1639" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="133" endline="303">
<![CDATA[
 
 		//
 		// Resolve the constraints types with only possible early checks, return
 		// value `false' is reserved for recursive failure
 		//
 		public bool Resolve (IMemberContext context, TypeParameter tp)
 		{
 			if (resolved)
 				return true;
 
 			if (resolving)
 				return false;
 
 			resolving = true;
 			var spec = tp.Type;
 			List<TypeParameterSpec> tparam_types = null;
 			bool iface_found = false;
 
 			spec.BaseType = TypeManager.object_type;
 
 			for (int i = 0; i < constraints.Count; ++i) {
 				var constraint = constraints[i];
 
 				if (constraint is SpecialContraintExpr) {
 					spec.SpecialConstraint |= ((SpecialContraintExpr) constraint).Constraint;
 					if (spec.HasSpecialStruct)
 						spec.BaseType = TypeManager.value_type;
 
 					// Set to null as it does not have a type
 					constraints[i] = null;
 					continue;
 				}
 
 				var type_expr = constraints[i] = constraint.ResolveAsTypeTerminal (context, false);
 				if (type_expr == null)
 					continue;
 
 				var gexpr = type_expr as GenericTypeExpr;
 				if (gexpr != null && gexpr.HasDynamicArguments ()) {
 					context.Compiler.Report.Error (1968, constraint.Location,
 						"A constraint cannot be the dynamic type `{0}'", gexpr.GetSignatureForError ());
 					continue;
 				}
 
 				var type = type_expr.Type;
 
 				if (!context.CurrentMemberDefinition.IsAccessibleAs (type)) {
 					context.Compiler.Report.SymbolRelatedToPreviousError (type);
 					context.Compiler.Report.Error (703, loc,
 						"Inconsistent accessibility
 						type.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				if (type.IsInterface) {
 					if (!spec.AddInterface (type)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 					}
 
 					iface_found = true;
 					continue;
 				}
 
 
 				var constraint_tp = type as TypeParameterSpec;
 				if (constraint_tp != null) {
 					if (tparam_types == null) {
 						tparam_types = new List<TypeParameterSpec> (2);
 					} else if (tparam_types.Contains (constraint_tp)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 						continue;
 					}
 
 					//
 					// Checks whether each generic method parameter constraint type
 					// is valid with respect to T
 					//
 					if (tp.IsMethodTypeParameter) {
 						TypeManager.CheckTypeVariance (type, Variance.Contravariant, context);
 					}
 
 					var tp_def = constraint_tp.MemberDefinition as TypeParameter;
 					if (tp_def != null && !tp_def.ResolveConstraints (context)) {
 						context.Compiler.Report.Error (454, constraint.Location,
 							"Circular constraint dependency involving `{0}' and `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					//
 					// Checks whether there are no conflicts between type parameter constraints
 					//
 					// class Foo<T, U>
 					//      where T 
 					//      where U 
 					//
 					// A and B are not convertible and only 1 class constraint is allowed
 					//
 					if (constraint_tp.HasTypeConstraint) {
 						if (spec.HasTypeConstraint || spec.HasSpecialStruct) {
 							if (!CheckConflictingInheritedConstraint (spec, constraint_tp.BaseType, context, constraint.Location))
 								continue;
 						} else {
 							for (int ii = 0; ii < tparam_types.Count; ++ii) {
 								if (!tparam_types[ii].HasTypeConstraint)
 									continue;
 
 								if (!CheckConflictingInheritedConstraint (spec, tparam_types[ii].BaseType, constraint_tp.BaseType, context, constraint.Location))
 									break;
 							}
 							for (int ii = 0; ii < tparam_types.Count; ++ii) {
 								if (!tparam_types[ii].HasTypeConstraint)
 									continue;
 
 								if (!CheckConflictingInheritedConstraint (spec, tparam_types[ii].BaseType, constraint_tp.BaseType, context, constraint.Location))
 									break;
 							}
 						}
 					}
 
 					if (constraint_tp.HasSpecialStruct) {
 						context.Compiler.Report.Error (456, constraint.Location,
 							"Type parameter `{0}' has the `struct' constraint, so it cannot be used as a constraint for `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					tparam_types.Add (constraint_tp);
 					continue;
 				}
 
 				if (iface_found || spec.HasTypeConstraint) {
 					context.Compiler.Report.Error (406, constraint.Location,
 						"The class type constraint `{0}' must be listed before any other constraints. Consider moving type constraint to the beginning of the constraint list",
 						type.GetSignatureForError ());
 				}
 
 				if (spec.HasSpecialStruct || spec.HasSpecialClass) {
 					context.Compiler.Report.Error (450, type_expr.Location,
 						"`{0}'
 						type.GetSignatureForError ());
 				}
 
 				if (type == InternalType.Dynamic) {
 					context.Compiler.Report.Error (1967, constraint.Location, "A constraint cannot be the dynamic type");
 					continue;
 				}
 
 				if (type.IsSealed || !type.IsClass) {
 					context.Compiler.Report.Error (701, loc,
 						"`{0}' is not a valid constraint. A constraint must be an interface, a non-sealed class or a type parameter",
 						TypeManager.CSharpName (type));
 					continue;
 				}
 
 				if (type.IsStatic) {
 					context.Compiler.Report.Error (717, constraint.Location,
 						"`{0}' is not a valid constraint. Static classes cannot be used as constraints",
 						type.GetSignatureForError ());
 				} else if (type == TypeManager.array_type || type == TypeManager.delegate_type ||
 							type == TypeManager.enum_type || type == TypeManager.value_type ||
 							type == TypeManager.object_type || type == TypeManager.multicast_delegate_type) {
 					context.Compiler.Report.Error (702, constraint.Location,
 						"A constraint cannot be special class `{0}'", type.GetSignatureForError ());
 					continue;
 				}
 
 				spec.BaseType = type;
 			}
 			for (int i = 0; i < constraints.Count; ++i) {
 				var constraint = constraints[i];
 
 				if (constraint is SpecialContraintExpr) {
 					spec.SpecialConstraint |= ((SpecialContraintExpr) constraint).Constraint;
 					if (spec.HasSpecialStruct)
 						spec.BaseType = TypeManager.value_type;
 
 					// Set to null as it does not have a type
 					constraints[i] = null;
 					continue;
 				}
 
 				var type_expr = constraints[i] = constraint.ResolveAsTypeTerminal (context, false);
 				if (type_expr == null)
 					continue;
 
 				var gexpr = type_expr as GenericTypeExpr;
 				if (gexpr != null && gexpr.HasDynamicArguments ()) {
 					context.Compiler.Report.Error (1968, constraint.Location,
 						"A constraint cannot be the dynamic type `{0}'", gexpr.GetSignatureForError ());
 					continue;
 				}
 
 				var type = type_expr.Type;
 
 				if (!context.CurrentMemberDefinition.IsAccessibleAs (type)) {
 					context.Compiler.Report.SymbolRelatedToPreviousError (type);
 					context.Compiler.Report.Error (703, loc,
 						"Inconsistent accessibility
 						type.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				if (type.IsInterface) {
 					if (!spec.AddInterface (type)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 					}
 
 					iface_found = true;
 					continue;
 				}
 
 
 				var constraint_tp = type as TypeParameterSpec;
 				if (constraint_tp != null) {
 					if (tparam_types == null) {
 						tparam_types = new List<TypeParameterSpec> (2);
 					} else if (tparam_types.Contains (constraint_tp)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 						continue;
 					}
 
 					//
 					// Checks whether each generic method parameter constraint type
 					// is valid with respect to T
 					//
 					if (tp.IsMethodTypeParameter) {
 						TypeManager.CheckTypeVariance (type, Variance.Contravariant, context);
 					}
 
 					var tp_def = constraint_tp.MemberDefinition as TypeParameter;
 					if (tp_def != null && !tp_def.ResolveConstraints (context)) {
 						context.Compiler.Report.Error (454, constraint.Location,
 							"Circular constraint dependency involving `{0}' and `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					//
 					// Checks whether there are no conflicts between type parameter constraints
 					//
 					// class Foo<T, U>
 					//      where T 
 					//      where U 
 					//
 					// A and B are not convertible and only 1 class constraint is allowed
 					//
 					if (constraint_tp.HasTypeConstraint) {
 						if (spec.HasTypeConstraint || spec.HasSpecialStruct) {
 							if (!CheckConflictingInheritedConstraint (spec, constraint_tp.BaseType, context, constraint.Location))
 								continue;
 						} else {
 							for (int ii = 0; ii < tparam_types.Count; ++ii) {
 								if (!tparam_types[ii].HasTypeConstraint)
 									continue;
 
 								if (!CheckConflictingInheritedConstraint (spec, tparam_types[ii].BaseType, constraint_tp.BaseType, context, constraint.Location))
 									break;
 							}
 						}
 					}
 
 					if (constraint_tp.HasSpecialStruct) {
 						context.Compiler.Report.Error (456, constraint.Location,
 							"Type parameter `{0}' has the `struct' constraint, so it cannot be used as a constraint for `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					tparam_types.Add (constraint_tp);
 					continue;
 				}
 
 				if (iface_found || spec.HasTypeConstraint) {
 					context.Compiler.Report.Error (406, constraint.Location,
 						"The class type constraint `{0}' must be listed before any other constraints. Consider moving type constraint to the beginning of the constraint list",
 						type.GetSignatureForError ());
 				}
 
 				if (spec.HasSpecialStruct || spec.HasSpecialClass) {
 					context.Compiler.Report.Error (450, type_expr.Location,
 						"`{0}'
 						type.GetSignatureForError ());
 				}
 
 				if (type == InternalType.Dynamic) {
 					context.Compiler.Report.Error (1967, constraint.Location, "A constraint cannot be the dynamic type");
 					continue;
 				}
 
 				if (type.IsSealed || !type.IsClass) {
 					context.Compiler.Report.Error (701, loc,
 						"`{0}' is not a valid constraint. A constraint must be an interface, a non-sealed class or a type parameter",
 						TypeManager.CSharpName (type));
 					continue;
 				}
 
 				if (type.IsStatic) {
 					context.Compiler.Report.Error (717, constraint.Location,
 						"`{0}' is not a valid constraint. Static classes cannot be used as constraints",
 						type.GetSignatureForError ());
 				} else if (type == TypeManager.array_type || type == TypeManager.delegate_type ||
 							type == TypeManager.enum_type || type == TypeManager.value_type ||
 							type == TypeManager.object_type || type == TypeManager.multicast_delegate_type) {
 					context.Compiler.Report.Error (702, constraint.Location,
 						"A constraint cannot be special class `{0}'", type.GetSignatureForError ());
 					continue;
 				}
 
 				spec.BaseType = type;
 			}
 
 			if (tparam_types != null)
 				spec.TypeArguments = tparam_types.ToArray ();
 
 			resolving = false;
 			resolved = true;
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1640" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1781" endline="1971">
<![CDATA[
 
 		protected override bool DoDefineMembers ()
 		{
 			if (!base.DoDefineMembers ())
 				return false;
 
 			Location loc = Location;
 
 			var equals_parameters = ParametersCompiled.CreateFullyResolved (
 				new Parameter (new TypeExpression (TypeManager.object_type, loc), "obj", 0, null, loc),	TypeManager.object_type);
 
 			Method equals = new Method (this, null, new TypeExpression (TypeManager.bool_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN, new MemberName ("Equals", loc),
 				equals_parameters, null);
 
 			equals_parameters[0].Resolve (equals, 0);
 
 			Method tostring = new Method (this, null, new TypeExpression (TypeManager.string_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN, new MemberName ("ToString", loc),
 				Mono.CSharp.ParametersCompiled.EmptyReadOnlyParameters, null);
 
 			ToplevelBlock equals_block = new ToplevelBlock (Compiler, equals.ParameterInfo, loc);
 
 			TypeExpr current_type;
 			if (type_params != null) {
 				var targs = new TypeArguments ();
 				foreach (var type_param in type_params)
 					targs.Add (new TypeParameterExpr (type_param, type_param.Location));
 				foreach (var type_param in type_params)
 					targs.Add (new TypeParameterExpr (type_param, type_param.Location));
 
 				current_type = new GenericTypeExpr (Definition, targs, loc);
 			} else {
 				current_type = new TypeExpression (Definition, loc);
 			}
 
 			var li_other = LocalVariable.CreateCompilerGenerated (CurrentType, equals_block, loc);
 			equals_block.AddStatement (new BlockVariableDeclaration (new TypeExpression (li_other.Type, loc), li_other));
 			var other_variable = new LocalVariableReference (li_other, loc);
 
 			MemberAccess system_collections_generic = new MemberAccess (new MemberAccess (
 				new QualifiedAliasMember ("global", "System", loc), "Collections", loc), "Generic", loc);
 
 			Expression rs_equals = null;
 			Expression string_concat = new StringConstant ("{", loc);
 			Expression rs_hashcode = new IntConstant (-2128831035, loc);
 			for (int i = 0; i < parameters.Count; ++i) {
 				var p = parameters [i];
 				var f = Fields [i];
 
 				MemberAccess equality_comparer = new MemberAccess (new MemberAccess (
 					system_collections_generic, "EqualityComparer",
 						new TypeArguments (new SimpleName (CurrentTypeParameters [i].Name, loc)), loc),
 						"Default", loc);
 
 				Arguments arguments_equal = new Arguments (2);
 				arguments_equal.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				arguments_equal.Add (new Argument (new MemberAccess (other_variable, f.Name)));
 
 				Expression field_equal = new Invocation (new MemberAccess (equality_comparer,
 					"Equals", loc), arguments_equal);
 
 				Arguments arguments_hashcode = new Arguments (1);
 				arguments_hashcode.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				Expression field_hashcode = new Invocation (new MemberAccess (equality_comparer,
 					"GetHashCode", loc), arguments_hashcode);
 
 				IntConstant FNV_prime = new IntConstant (16777619, loc);				
 				rs_hashcode = new Binary (Binary.Operator.Multiply,
 					new Binary (Binary.Operator.ExclusiveOr, rs_hashcode, field_hashcode, loc),
 					FNV_prime, loc);
 
 				Expression field_to_string = new Conditional (new BooleanExpression (new Binary (Binary.Operator.Inequality,
 					new MemberAccess (new This (f.Location), f.Name), new NullLiteral (loc), loc)),
 					new Invocation (new MemberAccess (
 						new MemberAccess (new This (f.Location), f.Name), "ToString"), null),
 					new StringConstant (string.Empty, loc), loc);
 
 				if (rs_equals == null) {
 					rs_equals = field_equal;
 					string_concat = new Binary (Binary.Operator.Addition,
 						string_concat,
 						new Binary (Binary.Operator.Addition,
 							new StringConstant (" " + p.Name + " = ", loc),
 							field_to_string,
 							loc),
 						loc);
 					continue;
 				}
 
 				//
 				// Implementation of ToString () body using string concatenation
 				//				
 				string_concat = new Binary (Binary.Operator.Addition,
 					new Binary (Binary.Operator.Addition,
 						string_concat,
 						new StringConstant (", " + p.Name + " = ", loc),
 						loc),
 					field_to_string,
 					loc);
 
 				rs_equals = new Binary (Binary.Operator.LogicalAnd, rs_equals, field_equal, loc);
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				var p = parameters [i];
 				var f = Fields [i];
 
 				MemberAccess equality_comparer = new MemberAccess (new MemberAccess (
 					system_collections_generic, "EqualityComparer",
 						new TypeArguments (new SimpleName (CurrentTypeParameters [i].Name, loc)), loc),
 						"Default", loc);
 
 				Arguments arguments_equal = new Arguments (2);
 				arguments_equal.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				arguments_equal.Add (new Argument (new MemberAccess (other_variable, f.Name)));
 
 				Expression field_equal = new Invocation (new MemberAccess (equality_comparer,
 					"Equals", loc), arguments_equal);
 
 				Arguments arguments_hashcode = new Arguments (1);
 				arguments_hashcode.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				Expression field_hashcode = new Invocation (new MemberAccess (equality_comparer,
 					"GetHashCode", loc), arguments_hashcode);
 
 				IntConstant FNV_prime = new IntConstant (16777619, loc);				
 				rs_hashcode = new Binary (Binary.Operator.Multiply,
 					new Binary (Binary.Operator.ExclusiveOr, rs_hashcode, field_hashcode, loc),
 					FNV_prime, loc);
 
 				Expression field_to_string = new Conditional (new BooleanExpression (new Binary (Binary.Operator.Inequality,
 					new MemberAccess (new This (f.Location), f.Name), new NullLiteral (loc), loc)),
 					new Invocation (new MemberAccess (
 						new MemberAccess (new This (f.Location), f.Name), "ToString"), null),
 					new StringConstant (string.Empty, loc), loc);
 
 				if (rs_equals == null) {
 					rs_equals = field_equal;
 					string_concat = new Binary (Binary.Operator.Addition,
 						string_concat,
 						new Binary (Binary.Operator.Addition,
 							new StringConstant (" " + p.Name + " = ", loc),
 							field_to_string,
 							loc),
 						loc);
 					continue;
 				}
 
 				//
 				// Implementation of ToString () body using string concatenation
 				//				
 				string_concat = new Binary (Binary.Operator.Addition,
 					new Binary (Binary.Operator.Addition,
 						string_concat,
 						new StringConstant (", " + p.Name + " = ", loc),
 						loc),
 					field_to_string,
 					loc);
 
 				rs_equals = new Binary (Binary.Operator.LogicalAnd, rs_equals, field_equal, loc);
 			}
 
 			string_concat = new Binary (Binary.Operator.Addition,
 				string_concat,
 				new StringConstant (" }", loc),
 				loc);
 
 			//
 			// Equals (object obj) override
 			//		
 			var other_variable_assign = new TemporaryVariableReference (li_other, loc);
 			equals_block.AddStatement (new StatementExpression (
 				new SimpleAssign (other_variable_assign,
 					new As (equals_block.GetParameterReference (0, loc),
 						current_type, loc), loc)));
 
 			Expression equals_test = new Binary (Binary.Operator.Inequality, other_variable, new NullLiteral (loc), loc);
 			if (rs_equals != null)
 				equals_test = new Binary (Binary.Operator.LogicalAnd, equals_test, rs_equals, loc);
 			equals_block.AddStatement (new Return (equals_test, loc));
 
 			equals.Block = equals_block;
 			equals.Define ();
 			AddMethod (equals);
 
 			//
 			// GetHashCode () override
 			//
 			Method hashcode = new Method (this, null, new TypeExpression (TypeManager.int32_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN,
 				new MemberName ("GetHashCode", loc),
 				Mono.CSharp.ParametersCompiled.EmptyReadOnlyParameters, null);
 
 			//
 			// Modified FNV with good avalanche behavior and uniform
 			// distribution with larger hash sizes.
 			//
 			// const int FNV_prime = 16777619;
 			// int hash = (int) 2166136261;
 			// foreach (int d in data)
 			//     hash = (hash ^ d) * FNV_prime;
 			// hash += hash << 13;
 			// hash ^= hash >> 7;
 			// hash += hash << 3;
 			// hash ^= hash >> 17;
 			// hash += hash << 5;
 
 			ToplevelBlock hashcode_top = new ToplevelBlock (Compiler, loc);
 			Block hashcode_block = new Block (hashcode_top, loc, loc);
 			hashcode_top.AddStatement (new Unchecked (hashcode_block, loc));
 
 			var li_hash = LocalVariable.CreateCompilerGenerated (TypeManager.int32_type, hashcode_top, loc);
 			hashcode_block.AddStatement (new BlockVariableDeclaration (new TypeExpression (li_hash.Type, loc), li_hash));
 			LocalVariableReference hash_variable_assign = new LocalVariableReference (li_hash, loc);
 			hashcode_block.AddStatement (new StatementExpression (
 				new SimpleAssign (hash_variable_assign, rs_hashcode)));
 
 			var hash_variable = new LocalVariableReference (li_hash, loc);
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (13, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.ExclusiveOr, hash_variable,
 					new Binary (Binary.Operator.RightShift, hash_variable, new IntConstant (7, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (3, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.ExclusiveOr, hash_variable,
 					new Binary (Binary.Operator.RightShift, hash_variable, new IntConstant (17, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (5, loc), loc), loc)));
 
 			hashcode_block.AddStatement (new Return (hash_variable, loc));
 			hashcode.Block = hashcode_top;
 			hashcode.Define ();
 			AddMethod (hashcode);
 
 			//
 			// ToString () override
 			//
 
 			ToplevelBlock tostring_block = new ToplevelBlock (Compiler, loc);
 			tostring_block.AddStatement (new Return (string_concat, loc));
 			tostring.Block = tostring_block;
 			tostring.Define ();
 			AddMethod (tostring);
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1641" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1751" endline="1902">
<![CDATA[
 
 		public bool Define (DeclSpace parent, string method_full_name, Report Report)
 		{
 			TypeContainer container = parent.PartialContainer;
 
 			PendingImplementation pending = container.PendingImplementations;
 			if (pending != null){
 				implementing = pending.IsInterfaceMethod (method.MethodName, member.InterfaceType, this);
 
 				if (member.InterfaceType != null){
 					if (implementing == null){
 						if (member is PropertyBase) {
 							Report.Error (550, method.Location, "`{0}' is an accessor not found in interface member `{1}{2}'",
 								      method.GetSignatureForError (), TypeManager.CSharpName (member.InterfaceType),
 								      member.GetSignatureForError ().Substring (member.GetSignatureForError ().LastIndexOf ('.')));
 
 						} else {
 							Report.Error (539, method.Location,
 								      "`{0}.{1}' in explicit interface declaration is not a member of interface",
 								      TypeManager.CSharpName (member.InterfaceType), member.ShortName);
 						}
 						return false;
 					}
 					if (implementing.IsAccessor && !(method is AbstractPropertyEventMethod)) {
 						Report.SymbolRelatedToPreviousError (implementing);
 						Report.Error (683, method.Location, "`{0}' explicit method implementation cannot implement `{1}' because it is an accessor",
 							member.GetSignatureForError (), TypeManager.CSharpSignature (implementing));
 						return false;
 					}
 				} else {
 					if (implementing != null) {
 						AbstractPropertyEventMethod prop_method = method as AbstractPropertyEventMethod;
 						if (prop_method == null) {
 							if (implementing.IsAccessor) {
 								Report.SymbolRelatedToPreviousError (implementing);
 								Report.Error (470, method.Location, "Method `{0}' cannot implement interface accessor `{1}'",
 									method.GetSignatureForError (), TypeManager.CSharpSignature (implementing));
 							}
 						} else if (implementing.DeclaringType.IsInterface) {
 							if (!implementing.IsAccessor) {
 								Report.SymbolRelatedToPreviousError (implementing);
 								Report.Error (686, method.Location, "Accessor `{0}' cannot implement interface member `{1}' for type `{2}'. Use an explicit interface implementation",
 									method.GetSignatureForError (), TypeManager.CSharpSignature (implementing), container.GetSignatureForError ());
 							} else {
 								PropertyBase.PropertyMethod pm = prop_method as PropertyBase.PropertyMethod;
 								if (pm != null && pm.HasCustomAccessModifier && (pm.ModFlags & Modifiers.PUBLIC) == 0) {
 									Report.SymbolRelatedToPreviousError (implementing);
 									Report.Error (277, method.Location, "Accessor `{0}' must be declared public to implement interface member `{1}'",
 										method.GetSignatureForError (), implementing.GetSignatureForError ());
 								}
 							}
 						}
 					}
 				}
 			}
 
 			//
 			// For implicit implementations, make sure we are public, for
 			// explicit implementations, make sure we are private.
 			//
 			if (implementing != null){
 				//
 				// Setting null inside this block will trigger a more
 				// verbose error reporting for missing interface implementations
 				//
 				// The "candidate" function has been flagged already
 				// but it wont get cleared
 				//
 				if (member.IsExplicitImpl){
 					if (method.ParameterInfo.HasParams && !implementing.Parameters.HasParams) {
 						Report.SymbolRelatedToPreviousError (implementing);
 						Report.Error (466, method.Location, "`{0}'
 							method.GetSignatureForError ());
 					}
 				} else {
 					if (implementing.DeclaringType.IsInterface) {
 						//
 						// If this is an interface method implementation,
 						// check for public accessibility
 						//
 						if ((flags & MethodAttributes.MemberAccessMask) != MethodAttributes.Public)
 						{
 							implementing = null;
 						}
 					} else if ((flags & MethodAttributes.MemberAccessMask) == MethodAttributes.Private){
 						// We may never be private.
 						implementing = null;
 
 					} else if ((modifiers & Modifiers.OVERRIDE) == 0){
 						//
 						// We may be protected if we're overriding something.
 						//
 						implementing = null;
 					}
 				}
 					
 				//
 				// Static is not allowed
 				//
 				if ((modifiers & Modifiers.STATIC) != 0){
 					implementing = null;
 				}
 			}
 			
 			//
 			// If implementing is still valid, set flags
 			//
 			if (implementing != null){
 				//
 				// When implementing interface methods, set NewSlot
 				// unless, we are overwriting a method.
 				//
 				if (implementing.DeclaringType.IsInterface){
 					if ((modifiers & Modifiers.OVERRIDE) == 0)
 						flags |= MethodAttributes.NewSlot;
 				}
 
 				flags |= MethodAttributes.Virtual | MethodAttributes.HideBySig;
 
 				// Set Final unless we're virtual, abstract or already overriding a method.
 				if ((modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE)) == 0)
 					flags |= MethodAttributes.Final;
 
 				//
 				// clear the pending implementation flag (requires explicit methods to be defined first)
 				//
 				parent.PartialContainer.PendingImplementations.ImplementMethod (method.MethodName,
 					member.InterfaceType, this, member.IsExplicitImpl);
 
 				//
 				// Update indexer accessor name to match implementing abstract accessor
 				//
 				if (!implementing.DeclaringType.IsInterface && !member.IsExplicitImpl && implementing.IsAccessor)
 					method_full_name = implementing.MemberDefinition.Name;
 			}
 
 			DefineMethodBuilder (container, method_full_name, method.ParameterInfo);
 
 			if (builder == null)
 				return false;
 
 //			if (container.CurrentType != null)
 //				declaring_type = container.CurrentType;
 //			else
 				declaring_type = container.Definition;
 
 			if (implementing != null && member.IsExplicitImpl) {
 				container.TypeBuilder.DefineMethodOverride (builder, (MethodInfo) implementing.GetMetaInfo ());
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1642" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2728" endline="2880">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (left == null)
 				return null;
 
 			if ((oper == Operator.Subtraction) && (left is ParenthesizedExpression)) {
 				left = ((ParenthesizedExpression) left).Expr;
 				left = left.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 				if (left == null)
 					return null;
 
 				if (left.eclass == ExprClass.Type) {
 					ec.Report.Error (75, loc, "To cast a negative value, you must enclose the value in parentheses");
 					return null;
 				}
 			} else
 				left = left.Resolve (ec);
 
 			if (left == null)
 				return null;
 
 			Constant lc = left as Constant;
 
 			if (lc != null && lc.Type == TypeManager.bool_type &&
 				((oper == Operator.LogicalAnd && lc.IsDefaultValue) ||
 				 (oper == Operator.LogicalOr && !lc.IsDefaultValue))) {
 
 				// FIXME
 				// right.Resolve (ec);
 
 				ec.Report.Warning (429, 4, loc, "Unreachable expression code detected");
 				return left;
 			}
 
 			right = right.Resolve (ec);
 			if (right == null)
 				return null;
 
 			eclass = ExprClass.Value;
 			Constant rc = right as Constant;
 
 			// The conversion rules are ignored in enum context but why
 			if (!ec.HasSet (ResolveContext.Options.EnumScope) && lc != null && rc != null && (TypeManager.IsEnumType (left.Type) || TypeManager.IsEnumType (right.Type))) {
 				lc = EnumLiftUp (ec, lc, rc, loc);
 				if (lc != null)
 					rc = EnumLiftUp (ec, rc, lc, loc);
 			}
 
 			if (rc != null && lc != null) {
 				int prev_e = ec.Report.Errors;
 				Expression e = ConstantFold.BinaryFold (ec, oper, lc, rc, loc);
 				if (e != null)
 					e = e.Resolve (ec);
 
 				if (e != null || ec.Report.Errors != prev_e)
 					return e;
 			}
 
 			// Comparison warnings
 			if ((oper & Operator.ComparisonMask) != 0) {
 				if (left.Equals (right)) {
 					ec.Report.Warning (1718, 3, loc, "A comparison made to same variable. Did you mean to compare something else?");
 				}
 				CheckUselessComparison (ec, lc, right.Type);
 				CheckUselessComparison (ec, rc, left.Type);
 			}
 
 			if (left.Type == InternalType.Dynamic || right.Type == InternalType.Dynamic) {
 				var lt = left.Type;
 				var rt = right.Type;
 				if (lt == TypeManager.void_type || lt == InternalType.MethodGroup || lt == InternalType.AnonymousMethod ||
 					rt == TypeManager.void_type || rt == InternalType.MethodGroup || rt == InternalType.AnonymousMethod) {
 					Error_OperatorCannotBeApplied (ec, left, right);
 					return null;
 				}
 
 				Arguments args;
 
 				//
 				// Special handling for logical boolean operators which require rhs not to be
 				// evaluated based on lhs value
 				//
 				if ((oper & Operator.LogicalMask) != 0) {
 					Expression cond_left, cond_right, expr;
 
 					args = new Arguments (2);
 
 					if (lt == InternalType.Dynamic) {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (lt, ec.CurrentBlock, loc);
 
 						var cond_args = new Arguments (1);
 						cond_args.Add (new Argument (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left).Resolve (ec)));
 
 						//
 						// dynamic && bool => IsFalse (temp = left) ? temp 
 						// dynamic || bool => IsTrue (temp = left) ? temp 
 						//
 						left = temp.CreateReferenceExpression (ec, loc);
 						if (oper == Operator.LogicalAnd) {
 							expr = DynamicUnaryConversion.CreateIsFalse (cond_args, loc);
 							cond_left = left;
 						} else {
 							expr = DynamicUnaryConversion.CreateIsTrue (cond_args, loc);
 							cond_left = left;
 						}
 
 						args.Add (new Argument (left));
 						args.Add (new Argument (right));
 						cond_right = new DynamicExpressionStatement (this, args, loc);
 					} else {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (TypeManager.bool_type, ec.CurrentBlock, loc);
 
 						args.Add (new Argument (temp.CreateReferenceExpression (ec, loc).Resolve (ec)));
 						args.Add (new Argument (right));
 						right = new DynamicExpressionStatement (this, args, loc);
 
 						//
 						// bool && dynamic => (temp = left) ? temp && right 
 						// bool || dynamic => (temp = left) ? temp 
 						//
 						if (oper == Operator.LogicalAnd) {
 							cond_left = right;
 							cond_right = temp.CreateReferenceExpression (ec, loc);
 						} else {
 							cond_left = temp.CreateReferenceExpression (ec, loc);
 							cond_right = right;
 						}
 
 						expr = new BooleanExpression (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left));
 					}
 
 					return new Conditional (expr, cond_left, cond_right, loc).Resolve (ec);
 				}
 
 				args = new Arguments (2);
 				args.Add (new Argument (left));
 				args.Add (new Argument (right));
 				return new DynamicExpressionStatement (this, args, loc).Resolve (ec);
 			}
 
 			if (RootContext.Version >= LanguageVersion.ISO_2 &&
 				((TypeManager.IsNullableType (left.Type) && (right is NullLiteral || TypeManager.IsNullableType (right.Type) || TypeManager.IsValueType (right.Type))) ||
 				(TypeManager.IsValueType (left.Type) && right is NullLiteral) ||
 				(TypeManager.IsNullableType (right.Type) && (left is NullLiteral || TypeManager.IsNullableType (left.Type) || TypeManager.IsValueType (left.Type))) ||
 				(TypeManager.IsValueType (right.Type) && left is NullLiteral))) {
 				var lifted = new Nullable.LiftedBinaryOperator (oper, left, right, loc);
 				lifted.state = state;
 				return lifted.Resolve (ec);
 			}
 
 			return DoResolveCore (ec, left, right);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1643" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1319" endline="1365">
<![CDATA[
 
 		public AnonymousExpression Compatible (ResolveContext ec, AnonymousExpression ae)
 		{
 			if (block.Resolved)
 				return this;
 
 			// TODO
 			BlockContext aec = new BlockContext (ec, block, ReturnType);
 			aec.CurrentAnonymousMethod = ae;
 
 			ResolveContext.Options flags = 0;
 
 			var am = this as AnonymousMethodBody;
 
 			if (ec.HasSet (ResolveContext.Options.InferReturnType) && am != null) {
 				am.ReturnTypeInference = new TypeInferenceContext ();
 			}
 
 			if (ec.IsInProbingMode)
 				flags |= ResolveContext.Options.ProbingMode;
 
 			if (ec.HasSet (ResolveContext.Options.FieldInitializerScope))
 				flags |= ResolveContext.Options.FieldInitializerScope;
 
 			if (ec.HasSet (ResolveContext.Options.ExpressionTreeConversion))
 				flags |= ResolveContext.Options.ExpressionTreeConversion;
 
 			aec.Set (flags);
 
 			var errors = ec.Report.Errors;
 
 			bool res = Block.Resolve (ec.CurrentBranching, aec, null);
 
 			if (aec.HasReturnLabel)
 				return_label = aec.ReturnLabel;
 
 			if (am != null && am.ReturnTypeInference != null) {
 				am.ReturnTypeInference.FixAllTypes (ec);
 				ReturnType = am.ReturnTypeInference.InferredTypeArguments [0];
 				am.ReturnTypeInference = null;
 			}
 
 			if (res && errors != ec.Report.Errors)
 				return null;
 
 			return res ? this 
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1644" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="472" endline="530">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			if (InitStatement != null){
 				if (!InitStatement.Resolve (ec))
 					ok = false;
 			}
 
 			if (Test != null){
 				Test = Test.Resolve (ec);
 				if (Test == null)
 					ok = false;
 				else if (Test is Constant){
 					bool value = !((Constant) Test).IsDefaultValue;
 
 					if (value == false){
 						if (!Statement.ResolveUnreachable (ec, true))
 							return false;
 						if ((Increment != null) &&
 						    !Increment.ResolveUnreachable (ec, false))
 							return false;
 						empty = true;
 						return true;
 					} else
 						infinite = true;
 				}
 			} else
 				infinite = true;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 			if (!infinite)
 				ec.CurrentBranching.CreateSibling ();
 
 			bool was_unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!Statement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			if (Increment != null){
 				if (ec.CurrentBranching.CurrentUsageVector.IsUnreachable) {
 					if (!Increment.ResolveUnreachable (ec, !was_unreachable))
 						ok = false;
 				} else {
 					if (!Increment.Resolve (ec))
 						ok = false;
 				}
 			}
 
 			// There's no direct control flow from the end of the embedded statement to the end of the loop
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1645" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3162" endline="3195">
<![CDATA[
 
 		protected bool DefineParameters (ParametersCompiled parameters)
 		{
 			if (!parameters.Resolve (this))
 				return false;
 
 			bool error = false;
 			for (int i = 0; i < parameters.Count; ++i) {
 				Parameter p = parameters [i];
 
 				if (p.HasDefaultValue && (IsExplicitImpl || this is Operator || (this is Indexer && parameters.Count == 1)))
 					p.Warning_UselessOptionalParameter (Report);
 
 				if (p.CheckAccessibility (this))
 					continue;
 
 				TypeSpec t = parameters.Types [i];
 				Report.SymbolRelatedToPreviousError (t);
 				if (this is Indexer)
 					Report.Error (55, Location,
 						      "Inconsistent accessibility
 						      TypeManager.CSharpName (t), GetSignatureForError ());
 				else if (this is Operator)
 					Report.Error (57, Location,
 						      "Inconsistent accessibility
 						      TypeManager.CSharpName (t), GetSignatureForError ());
 				else
 					Report.Error (51, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (t), GetSignatureForError ());
 				error = true;
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				Parameter p = parameters [i];
 
 				if (p.HasDefaultValue && (IsExplicitImpl || this is Operator || (this is Indexer && parameters.Count == 1)))
 					p.Warning_UselessOptionalParameter (Report);
 
 				if (p.CheckAccessibility (this))
 					continue;
 
 				TypeSpec t = parameters.Types [i];
 				Report.SymbolRelatedToPreviousError (t);
 				if (this is Indexer)
 					Report.Error (55, Location,
 						      "Inconsistent accessibility
 						      TypeManager.CSharpName (t), GetSignatureForError ());
 				else if (this is Operator)
 					Report.Error (57, Location,
 						      "Inconsistent accessibility
 						      TypeManager.CSharpName (t), GetSignatureForError ());
 				else
 					Report.Error (51, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (t), GetSignatureForError ());
 				error = true;
 			}
 			return !error;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1646" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="902" endline="957">
<![CDATA[
 
 		protected bool VerifyParameterCompatibility (ResolveContext ec, TypeSpec delegate_type, AParametersCollection invoke_pd, bool ignore_errors)
 		{
 			if (Parameters.Count != invoke_pd.Count) {
 				if (ignore_errors)
 					return false;
 				
 				ec.Report.Error (1593, loc, "Delegate `{0}' does not take `{1}' arguments",
 					      TypeManager.CSharpName (delegate_type), Parameters.Count.ToString ());
 				return false;
 			}
 
 			bool has_implicit_parameters = !HasExplicitParameters;
 			bool error = false;
 
 			for (int i = 0; i < Parameters.Count; ++i) {
 				Parameter.Modifier p_mod = invoke_pd.FixedParameters [i].ModFlags;
 				if (Parameters.FixedParameters [i].ModFlags != p_mod && p_mod != Parameter.Modifier.PARAMS) {
 					if (ignore_errors)
 						return false;
 					
 					if (p_mod == Parameter.Modifier.NONE)
 						ec.Report.Error (1677, loc, "Parameter `{0}' should not be declared with the `{1}' keyword",
 							      (i + 1).ToString (), Parameter.GetModifierSignature (Parameters.FixedParameters [i].ModFlags));
 					else
 						ec.Report.Error (1676, loc, "Parameter `{0}' must be declared with the `{1}' keyword",
 							      (i+1).ToString (), Parameter.GetModifierSignature (p_mod));
 					error = true;
 				}
 
 				if (has_implicit_parameters)
 					continue;
 
 				TypeSpec type = invoke_pd.Types [i];
 				
 				// We assume that generic parameters are always inflated
 				if (TypeManager.IsGenericParameter (type))
 					continue;
 				
 				if (TypeManager.HasElementType (type) && TypeManager.IsGenericParameter (TypeManager.GetElementType (type)))
 					continue;
 				
 				if (!TypeSpecComparer.IsEqual (invoke_pd.Types [i], Parameters.Types [i])) {
 					if (ignore_errors)
 						return false;
 					
 					ec.Report.Error (1678, loc, "Parameter `{0}' is declared as type `{1}' but should be `{2}'",
 						      (i+1).ToString (),
 						      TypeManager.CSharpName (Parameters.Types [i]),
 						      TypeManager.CSharpName (invoke_pd.Types [i]));
 					error = true;
 				}
 			}
 			for (int i = 0; i < Parameters.Count; ++i) {
 				Parameter.Modifier p_mod = invoke_pd.FixedParameters [i].ModFlags;
 				if (Parameters.FixedParameters [i].ModFlags != p_mod && p_mod != Parameter.Modifier.PARAMS) {
 					if (ignore_errors)
 						return false;
 					
 					if (p_mod == Parameter.Modifier.NONE)
 						ec.Report.Error (1677, loc, "Parameter `{0}' should not be declared with the `{1}' keyword",
 							      (i + 1).ToString (), Parameter.GetModifierSignature (Parameters.FixedParameters [i].ModFlags));
 					else
 						ec.Report.Error (1676, loc, "Parameter `{0}' must be declared with the `{1}' keyword",
 							      (i+1).ToString (), Parameter.GetModifierSignature (p_mod));
 					error = true;
 				}
 
 				if (has_implicit_parameters)
 					continue;
 
 				TypeSpec type = invoke_pd.Types [i];
 				
 				// We assume that generic parameters are always inflated
 				if (TypeManager.IsGenericParameter (type))
 					continue;
 				
 				if (TypeManager.HasElementType (type) && TypeManager.IsGenericParameter (TypeManager.GetElementType (type)))
 					continue;
 				
 				if (!TypeSpecComparer.IsEqual (invoke_pd.Types [i], Parameters.Types [i])) {
 					if (ignore_errors)
 						return false;
 					
 					ec.Report.Error (1678, loc, "Parameter `{0}' is declared as type `{1}' but should be `{2}'",
 						      (i+1).ToString (),
 						      TypeManager.CSharpName (Parameters.Types [i]),
 						      TypeManager.CSharpName (invoke_pd.Types [i]));
 					error = true;
 				}
 			}
 
 			return !error;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1647" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9368" endline="9431">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			List<string> element_names = null;
 			for (int i = 0; i < initializers.Count; ++i) {
 				Expression initializer = initializers [i];
 				ElementInitializer element_initializer = initializer as ElementInitializer;
 
 				if (i == 0) {
 					if (element_initializer != null) {
 						element_names = new List<string> (initializers.Count);
 						element_names.Add (element_initializer.Name);
 					} else if (initializer is CompletingExpression){
 						initializer.Resolve (ec);
 						throw new InternalErrorException ("This line should never be reached");
 					} else {
 						var t = ec.CurrentInitializerVariable.Type;
 						// LAMESPEC
 						if (!t.ImplementsInterface (TypeManager.ienumerable_type, false) && t != InternalType.Dynamic) {
 							ec.Report.Error (1922, loc, "A field or property `{0}' cannot be initialized with a collection " +
 								"object initializer because type `{1}' does not implement `{2}' interface",
 								ec.CurrentInitializerVariable.GetSignatureForError (),
 								TypeManager.CSharpName (ec.CurrentInitializerVariable.Type),
 								TypeManager.CSharpName (TypeManager.ienumerable_type));
 							return null;
 						}
 						is_collection_initialization = true;
 					}
 				} else {
 					if (is_collection_initialization != (element_initializer == null)) {
 						ec.Report.Error (747, initializer.Location, "Inconsistent `{0}' member declaration",
 							is_collection_initialization ? "collection initializer" 
 						continue;
 					}
 
 					if (!is_collection_initialization) {
 						if (element_names.Contains (element_initializer.Name)) {
 							ec.Report.Error (1912, element_initializer.Location,
 								"An object initializer includes more than one member `{0}' initialization",
 								element_initializer.Name);
 						} else {
 							element_names.Add (element_initializer.Name);
 						}
 					}
 				}
 
 				Expression e = initializer.Resolve (ec);
 				if (e == EmptyExpressionStatement.Instance)
 					initializers.RemoveAt (i--);
 				else
 					initializers [i] = e;
 			}
 			for (int i = 0; i < initializers.Count; ++i) {
 				Expression initializer = initializers [i];
 				ElementInitializer element_initializer = initializer as ElementInitializer;
 
 				if (i == 0) {
 					if (element_initializer != null) {
 						element_names = new List<string> (initializers.Count);
 						element_names.Add (element_initializer.Name);
 					} else if (initializer is CompletingExpression){
 						initializer.Resolve (ec);
 						throw new InternalErrorException ("This line should never be reached");
 					} else {
 						var t = ec.CurrentInitializerVariable.Type;
 						// LAMESPEC
 						if (!t.ImplementsInterface (TypeManager.ienumerable_type, false) && t != InternalType.Dynamic) {
 							ec.Report.Error (1922, loc, "A field or property `{0}' cannot be initialized with a collection " +
 								"object initializer because type `{1}' does not implement `{2}' interface",
 								ec.CurrentInitializerVariable.GetSignatureForError (),
 								TypeManager.CSharpName (ec.CurrentInitializerVariable.Type),
 								TypeManager.CSharpName (TypeManager.ienumerable_type));
 							return null;
 						}
 						is_collection_initialization = true;
 					}
 				} else {
 					if (is_collection_initialization != (element_initializer == null)) {
 						ec.Report.Error (747, initializer.Location, "Inconsistent `{0}' member declaration",
 							is_collection_initialization ? "collection initializer" 
 						continue;
 					}
 
 					if (!is_collection_initialization) {
 						if (element_names.Contains (element_initializer.Name)) {
 							ec.Report.Error (1912, element_initializer.Location,
 								"An object initializer includes more than one member `{0}' initialization",
 								element_initializer.Name);
 						} else {
 							element_names.Add (element_initializer.Name);
 						}
 					}
 				}
 
 				Expression e = initializer.Resolve (ec);
 				if (e == EmptyExpressionStatement.Instance)
 					initializers.RemoveAt (i--);
 				else
 					initializers [i] = e;
 			}
 
 			type = ec.CurrentInitializerVariable.Type;
 			if (is_collection_initialization) {
 				if (TypeManager.HasElementType (type)) {
 					ec.Report.Error (1925, loc, "Cannot initialize object of type `{0}' with a collection initializer",
 						TypeManager.CSharpName (type));
 				}
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1648" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4531" endline="4686">
<![CDATA[
 
 		bool VerifyArguments (ResolveContext ec, ref Arguments args, MemberSpec member, IParametersMember pm, bool chose_params_expanded)
 		{
 			var pd = pm.Parameters;
 			TypeSpec[] ptypes = ((IParametersMember) member).Parameters.Types;
 
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 			int a_idx = 0, a_pos = 0;
 			Argument a = null;
 			ArrayInitializer params_initializers = null;
 			bool has_unsafe_arg = pm.MemberType.IsPointer;
 			int arg_count = args == null ? 0 
 
 			for (; a_idx < arg_count; a_idx++, ++a_pos) {
 				a = args[a_idx];
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = pd.FixedParameters[a_idx].ModFlags;
 					pt = ptypes[a_idx];
 					has_unsafe_arg |= pt.IsPointer;
 
 					if (p_mod == Parameter.Modifier.PARAMS) {
 						if (chose_params_expanded) {
 							params_initializers = new ArrayInitializer (arg_count - a_idx, a.Expr.Location);
 							pt = TypeManager.GetElementType (pt);
 						}
 					}
 				}
 
 				//
 				// Types have to be identical when ref or out modifer is used 
 				//
 				if (a.Modifier != 0 || (p_mod & ~Parameter.Modifier.PARAMS) != 0) {
 					if ((p_mod & ~Parameter.Modifier.PARAMS) != a.Modifier)
 						break;
 
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt))
 						continue;
 
 					break;
 				}
 
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int name_index = pd.GetParameterIndexByName (na.Name);
 					if (name_index < 0 || name_index >= pd.Count) {
 						if (IsDelegateInvoke) {
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 							ec.Report.Error (1746, na.Location,
 								"The delegate `{0}' does not contain a parameter named `{1}'",
 								DelegateType.GetSignatureForError (), na.Name);
 						} else {
 							ec.Report.SymbolRelatedToPreviousError (member);
 							ec.Report.Error (1739, na.Location,
 								"The best overloaded method match for `{0}' does not contain a parameter named `{1}'",
 								TypeManager.CSharpSignature (member), na.Name);
 						}
 					} else if (args[name_index] != a) {
 						if (IsDelegateInvoke)
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 						else
 							ec.Report.SymbolRelatedToPreviousError (member);
 
 						ec.Report.Error (1744, na.Location,
 							"Named argument `{0}' cannot be used for a parameter which has positional argument specified",
 							na.Name);
 					}
 				}
 				
 				if (a.Expr.Type == InternalType.Dynamic)
 					continue;
 
 				if ((restrictions & Restrictions.CovariantDelegate) != 0 && !Delegate.IsTypeCovariant (a.Expr, pt)) {
 					custom_errors.NoArgumentMatch (ec, member);
 					return false;
 				}
 
 				Expression conv = null;
 				if (a.ArgType == Argument.AType.ExtensionType) {
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt)) {
 						conv = a.Expr;
 					} else {
 						conv = Convert.ImplicitReferenceConversion (a.Expr, pt, false);
 						if (conv == null)
 							conv = Convert.ImplicitBoxingConversion (a.Expr, a.Expr.Type, pt);
 					}
 				} else {
 					conv = Convert.ImplicitConversion (ec, a.Expr, pt, loc);
 				}
 
 				if (conv == null)
 					break;
 
 				//
 				// Convert params arguments to an array initializer
 				//
 				if (params_initializers != null) {
 					// we choose to use 'a.Expr' rather than 'conv' so that
 					// we don't hide the kind of expression we have (esp. CompoundAssign.Helper)
 					params_initializers.Add (a.Expr);
 					args.RemoveAt (a_idx--);
 					--arg_count;
 					continue;
 				}
 
 				// Update the argument with the implicit conversion
 				a.Expr = conv;
 			}
 			for (; a_idx < arg_count; a_idx++, ++a_pos) {
 				a = args[a_idx];
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = pd.FixedParameters[a_idx].ModFlags;
 					pt = ptypes[a_idx];
 					has_unsafe_arg |= pt.IsPointer;
 
 					if (p_mod == Parameter.Modifier.PARAMS) {
 						if (chose_params_expanded) {
 							params_initializers = new ArrayInitializer (arg_count - a_idx, a.Expr.Location);
 							pt = TypeManager.GetElementType (pt);
 						}
 					}
 				}
 
 				//
 				// Types have to be identical when ref or out modifer is used 
 				//
 				if (a.Modifier != 0 || (p_mod & ~Parameter.Modifier.PARAMS) != 0) {
 					if ((p_mod & ~Parameter.Modifier.PARAMS) != a.Modifier)
 						break;
 
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt))
 						continue;
 
 					break;
 				}
 
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int name_index = pd.GetParameterIndexByName (na.Name);
 					if (name_index < 0 || name_index >= pd.Count) {
 						if (IsDelegateInvoke) {
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 							ec.Report.Error (1746, na.Location,
 								"The delegate `{0}' does not contain a parameter named `{1}'",
 								DelegateType.GetSignatureForError (), na.Name);
 						} else {
 							ec.Report.SymbolRelatedToPreviousError (member);
 							ec.Report.Error (1739, na.Location,
 								"The best overloaded method match for `{0}' does not contain a parameter named `{1}'",
 								TypeManager.CSharpSignature (member), na.Name);
 						}
 					} else if (args[name_index] != a) {
 						if (IsDelegateInvoke)
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 						else
 							ec.Report.SymbolRelatedToPreviousError (member);
 
 						ec.Report.Error (1744, na.Location,
 							"Named argument `{0}' cannot be used for a parameter which has positional argument specified",
 							na.Name);
 					}
 				}
 				
 				if (a.Expr.Type == InternalType.Dynamic)
 					continue;
 
 				if ((restrictions & Restrictions.CovariantDelegate) != 0 && !Delegate.IsTypeCovariant (a.Expr, pt)) {
 					custom_errors.NoArgumentMatch (ec, member);
 					return false;
 				}
 
 				Expression conv = null;
 				if (a.ArgType == Argument.AType.ExtensionType) {
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt)) {
 						conv = a.Expr;
 					} else {
 						conv = Convert.ImplicitReferenceConversion (a.Expr, pt, false);
 						if (conv == null)
 							conv = Convert.ImplicitBoxingConversion (a.Expr, a.Expr.Type, pt);
 					}
 				} else {
 					conv = Convert.ImplicitConversion (ec, a.Expr, pt, loc);
 				}
 
 				if (conv == null)
 					break;
 
 				//
 				// Convert params arguments to an array initializer
 				//
 				if (params_initializers != null) {
 					// we choose to use 'a.Expr' rather than 'conv' so that
 					// we don't hide the kind of expression we have (esp. CompoundAssign.Helper)
 					params_initializers.Add (a.Expr);
 					args.RemoveAt (a_idx--);
 					--arg_count;
 					continue;
 				}
 
 				// Update the argument with the implicit conversion
 				a.Expr = conv;
 			}
 
 			if (a_idx != arg_count) {
 				ReportArgumentMismatch (ec, a_pos, member, a, pd, pt);
 				return false;
 			}
 
 			//
 			// Fill not provided arguments required by params modifier
 			//
 			if (params_initializers == null && pd.HasParams && arg_count + 1 == pd.Count) {
 				if (args == null)
 					args = new Arguments (1);
 
 				pt = ptypes[pd.Count - 1];
 				pt = TypeManager.GetElementType (pt);
 				has_unsafe_arg |= pt.IsPointer;
 				params_initializers = new ArrayInitializer (0, loc);
 			}
 
 			//
 			// Append an array argument with all params arguments
 			//
 			if (params_initializers != null) {
 				args.Add (new Argument (
 					new ArrayCreation (new TypeExpression (pt, loc), params_initializers, loc).Resolve (ec)));
 				arg_count++;
 			}
 
 			if (has_unsafe_arg && !ec.IsUnsafe) {
 				Expression.UnsafeError (ec, loc);
 			}
 
 			//
 			// We could infer inaccesible type arguments
 			//
 			if (type_arguments == null && member.IsGeneric) {
 				var ms = (MethodSpec) member;
 				foreach (var ta in ms.TypeArguments) {
 					if (!ta.IsAccessible (ec.CurrentType)) {
 						ec.Report.SymbolRelatedToPreviousError (ta);
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						break;
 					}
 				}
 				foreach (var ta in ms.TypeArguments) {
 					if (!ta.IsAccessible (ec.CurrentType)) {
 						ec.Report.SymbolRelatedToPreviousError (ta);
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						break;
 					}
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1649" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="420" endline="475">
<![CDATA[
 
 		public static Expression ImplicitNulableConversion (ResolveContext ec, Expression expr, TypeSpec target_type)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			//
 			// From null to any nullable type
 			//
 			if (expr_type == InternalType.Null)
 				return ec == null ? EmptyExpression.Null 
 
 			// S -> T?
 			TypeSpec t_el = Nullable.NullableInfo.GetUnderlyingType (target_type);
 
 			// S? -> T?
 			if (TypeManager.IsNullableType (expr_type))
 				expr_type = Nullable.NullableInfo.GetUnderlyingType (expr_type);
 
 			//
 			// Predefined implicit identity or implicit numeric conversion
 			// has to exist between underlying type S and underlying type T
 			//
 
 			// conversion exists only mode
 			if (ec == null) {
 				if (TypeSpecComparer.IsEqual (expr_type, t_el))
 					return EmptyExpression.Null;
 
 				if (expr is Constant)
 					return ((Constant) expr).ConvertImplicitly (ec, t_el);
 
 				return ImplicitNumericConversion (null, expr_type, t_el);
 			}
 
 			Expression unwrap;
 			if (expr_type != expr.Type)
 				unwrap = Nullable.Unwrap.Create (expr);
 			else
 				unwrap = expr;
 
 			Expression conv = unwrap;
 			if (!TypeSpecComparer.IsEqual (expr_type, t_el)) {
 				if (conv is Constant)
 					conv = ((Constant)conv).ConvertImplicitly (ec, t_el);
 				else
 					conv = ImplicitNumericConversion (conv, expr_type, t_el);
 
 				if (conv == null)
 					return null;
 			}
 			
 			if (expr_type != expr.Type)
 				return new Nullable.Lifted (conv, unwrap, target_type).Resolve (ec);
 
 			return Nullable.Wrap.Create (conv, target_type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1650" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="69" endline="153">
<![CDATA[
 		public BuildinTypes ()
 		{
 			Object = new BuildinTypeSpec (MemberKind.Class, "System", "Object", BuildinTypeSpec.Type.Object);
 			ValueType = new BuildinTypeSpec (MemberKind.Class, "System", "ValueType", BuildinTypeSpec.Type.ValueType);
 			Attribute = new BuildinTypeSpec (MemberKind.Class, "System", "Attribute", BuildinTypeSpec.Type.Attribute);
 
 			Int = new BuildinTypeSpec (MemberKind.Struct, "System", "Int32", BuildinTypeSpec.Type.Int);
 			Long = new BuildinTypeSpec (MemberKind.Struct, "System", "Int64", BuildinTypeSpec.Type.Long);
 			UInt = new BuildinTypeSpec (MemberKind.Struct, "System", "UInt32", BuildinTypeSpec.Type.UInt);
 			ULong = new BuildinTypeSpec (MemberKind.Struct, "System", "UInt64", BuildinTypeSpec.Type.ULong);
 			Byte = new BuildinTypeSpec (MemberKind.Struct, "System", "Byte", BuildinTypeSpec.Type.Byte);
 			SByte = new BuildinTypeSpec (MemberKind.Struct, "System", "SByte", BuildinTypeSpec.Type.SByte);
 			Short = new BuildinTypeSpec (MemberKind.Struct, "System", "Int16", BuildinTypeSpec.Type.Short);
 			UShort = new BuildinTypeSpec (MemberKind.Struct, "System", "UInt16", BuildinTypeSpec.Type.UShort);
 
 			IEnumerator = new BuildinTypeSpec (MemberKind.Interface, "System.Collections", "IEnumerator", BuildinTypeSpec.Type.IEnumerator);
 			IEnumerable = new BuildinTypeSpec (MemberKind.Interface, "System.Collections", "IEnumerable", BuildinTypeSpec.Type.IEnumerable);
 			IDisposable = new BuildinTypeSpec (MemberKind.Interface, "System", "IDisposable", BuildinTypeSpec.Type.IDisposable);
 
 			Char = new BuildinTypeSpec (MemberKind.Struct, "System", "Char", BuildinTypeSpec.Type.Char);
 			String = new BuildinTypeSpec (MemberKind.Class, "System", "String", BuildinTypeSpec.Type.String);
 			Float = new BuildinTypeSpec (MemberKind.Struct, "System", "Single", BuildinTypeSpec.Type.Float);
 			Double = new BuildinTypeSpec (MemberKind.Struct, "System", "Double", BuildinTypeSpec.Type.Double);
 			Decimal = new BuildinTypeSpec (MemberKind.Struct, "System", "Decimal", BuildinTypeSpec.Type.Decimal);
 			Bool = new BuildinTypeSpec (MemberKind.Struct, "System", "Boolean", BuildinTypeSpec.Type.Bool);
 			IntPtr = new BuildinTypeSpec (MemberKind.Struct, "System", "IntPtr", BuildinTypeSpec.Type.IntPtr);
 			UIntPtr = new BuildinTypeSpec (MemberKind.Struct, "System", "UIntPtr", BuildinTypeSpec.Type.UIntPtr);
 
 			MulticastDelegate = new BuildinTypeSpec (MemberKind.Class, "System", "MulticastDelegate", BuildinTypeSpec.Type.MulticastDelegate);
 			Delegate = new BuildinTypeSpec (MemberKind.Class, "System", "Delegate", BuildinTypeSpec.Type.Delegate);
 			Enum = new BuildinTypeSpec (MemberKind.Class, "System", "Enum", BuildinTypeSpec.Type.Enum);
 			Array = new BuildinTypeSpec (MemberKind.Class, "System", "Array", BuildinTypeSpec.Type.Array);
 			Void = new BuildinTypeSpec (MemberKind.Struct, "System", "Void", BuildinTypeSpec.Type.Void);
 			Type = new BuildinTypeSpec (MemberKind.Class, "System", "Type", BuildinTypeSpec.Type.Type);
 			Exception = new BuildinTypeSpec (MemberKind.Class, "System", "Exception", BuildinTypeSpec.Type.Exception);
 			RuntimeFieldHandle = new BuildinTypeSpec (MemberKind.Struct, "System", "RuntimeFieldHandle", BuildinTypeSpec.Type.RuntimeFieldHandle);
 			RuntimeTypeHandle = new BuildinTypeSpec (MemberKind.Struct, "System", "RuntimeTypeHandle", BuildinTypeSpec.Type.RuntimeTypeHandle);
 
 			Dynamic = new BuildinTypeSpec ("dynamic", BuildinTypeSpec.Type.Dynamic);
 			Null = new BuildinTypeSpec ("null", BuildinTypeSpec.Type.Null);
 			Null.MemberCache = MemberCache.Empty;
 
 			types = new BuildinTypeSpec[] {
 				Object, ValueType, Attribute,
 				Int, UInt, Long, ULong, Float, Double, Char, Short, Decimal, Bool, SByte, Byte, UShort, String,
 				Enum, Delegate, MulticastDelegate, Void, Array, Type, IEnumerator, IEnumerable, IDisposable,
 				IntPtr, UIntPtr, RuntimeFieldHandle, RuntimeTypeHandle, Exception };
 
 			// Deal with obsolete static types
 			// TODO
 			TypeManager.object_type = Object;
 			TypeManager.value_type = ValueType;
 			TypeManager.string_type = String;
 			TypeManager.int32_type = Int;
 			TypeManager.uint32_type = UInt;
 			TypeManager.int64_type = Long;
 			TypeManager.uint64_type = ULong;
 			TypeManager.float_type = Float;
 			TypeManager.double_type = Double;
 			TypeManager.char_type = Char;
 			TypeManager.short_type = Short;
 			TypeManager.decimal_type = Decimal;
 			TypeManager.bool_type = Bool;
 			TypeManager.sbyte_type = SByte;
 			TypeManager.byte_type = Byte;
 			TypeManager.ushort_type = UShort;
 			TypeManager.enum_type = Enum;
 			TypeManager.delegate_type = Delegate;
 			TypeManager.multicast_delegate_type = MulticastDelegate; ;
 			TypeManager.void_type = Void;
 			TypeManager.array_type = Array; ;
 			TypeManager.runtime_handle_type = RuntimeTypeHandle;
 			TypeManager.type_type = Type;
 			TypeManager.ienumerator_type = IEnumerator;
 			TypeManager.ienumerable_type = IEnumerable;
 			TypeManager.idisposable_type = IDisposable;
 			TypeManager.intptr_type = IntPtr;
 			TypeManager.uintptr_type = UIntPtr;
 			TypeManager.runtime_field_handle_type = RuntimeFieldHandle;
 			TypeManager.attribute_type = Attribute;
 			TypeManager.exception_type = Exception;
 
 			InternalType.Dynamic = Dynamic;
 			InternalType.Null = Null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1651" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="176" endline="202">
<![CDATA[
     End Property
 
     Protected Sub FindDefaultConstructors()
         For i As Integer = 0 To Me.Members.Count - 1
             Dim member As IMember = Me.Members(i)
             Dim ctor As ConstructorDeclaration = TryCast(member, ConstructorDeclaration)
 
             If ctor Is Nothing Then Continue For
 
             Dim isdefault As Boolean
             isdefault = False
             If ctor.GetParameters.Length = 0 Then
                 isdefault = True
             Else
                 isdefault = ctor.GetParameters()(0).IsOptional
             End If
             If isdefault Then
                 If ctor.IsShared Then
                     Helper.Assert(m_DefaultSharedConstructor Is Nothing OrElse m_DefaultSharedConstructor Is ctor)
                     m_DefaultSharedConstructor = ctor
                 Else
                     Helper.Assert(m_DefaultInstanceConstructor Is Nothing OrElse m_DefaultInstanceConstructor Is ctor)
                     m_DefaultInstanceConstructor = ctor
                 End If
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="54" endline="93">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_InterfacesImplemented = False AndAlso m_TypeImplementsClauses IsNot Nothing Then
             result = m_TypeImplementsClauses.ResolveTypeReferences AndAlso result
             For i As Integer = 0 To m_TypeImplementsClauses.Clauses.Count - 1
                 AddInterface(m_TypeImplementsClauses.Clauses(i).ResolvedType)
             Next
             m_InterfacesImplemented = True
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If Me.IsPartial Then
             If PartialModifierFound = False Then
                 Dim first As PartialTypeDeclaration = Me
                 Compiler.Report.ShowMessage(Messages.VBNC30179, Me.Location, Me.DescriptiveType, Me.Name, Me.DescriptiveType, Me.Name, Me.Namespace, Me.Namespace)
                 result = False
             End If
             'TODO
             'If TypeOf Me Is ClassDeclaration Then
             '    Dim inheritedTypes() As Mono.Cecil.TypeReference
             '    inheritedTypes = GetInheritedTypes()
             '    If inheritedTypes.Length > 0 Then
             '        Dim tmpType As Mono.Cecil.TypeReference
             '        tmpType = CheckUniqueType(inheritedTypes)
             '        If tmpType Is Nothing Then
             '            Return Helper.AddError(Me, "Partial classes must inherit from only one base class.")
             '        Else
             '            BaseType = tmpType
             '        End If
             '    Else
             '        Helper.Assert(BaseType IsNot Nothing) 'Should already be set to System.Object.
             '    End If
             'End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1652" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" startline="176" endline="202">
<![CDATA[
     End Property
 
     Protected Sub FindDefaultConstructors()
         For i As Integer = 0 To Me.Members.Count - 1
             Dim member As IMember = Me.Members(i)
             Dim ctor As ConstructorDeclaration = TryCast(member, ConstructorDeclaration)
 
             If ctor Is Nothing Then Continue For
 
             Dim isdefault As Boolean
             isdefault = False
             If ctor.GetParameters.Length = 0 Then
                 isdefault = True
             Else
                 isdefault = ctor.GetParameters()(0).IsOptional
             End If
             If isdefault Then
                 If ctor.IsShared Then
                     Helper.Assert(m_DefaultSharedConstructor Is Nothing OrElse m_DefaultSharedConstructor Is ctor)
                     m_DefaultSharedConstructor = ctor
                 Else
                     Helper.Assert(m_DefaultInstanceConstructor Is Nothing OrElse m_DefaultInstanceConstructor Is ctor)
                     m_DefaultInstanceConstructor = ctor
                 End If
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" startline="124" endline="161">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         'TODO
         If m_ArgumentList IsNot Nothing Then
             result = m_ArgumentList.ResolveCode(Info) AndAlso result
         End If
 
         If m_TypeName IsNot Nothing Then
             UsingVariableType = m_TypeName.ResolvedType
             m_IsVariableDeclaration = True
             If m_IsNew Then
                 Dim grp As New MethodGroupClassification(Me, Nothing, Nothing, Nothing, CecilHelper.GetConstructors(CecilHelper.FindDefinition(m_TypeName.ResolvedType)))
                 result = grp.ResolveGroup(m_ArgumentList) AndAlso result
                 m_Constructor = grp.ResolvedConstructor
                 If m_Constructor Is Nothing Then
                     result = Helper.AddError(Me) AndAlso result
                 End If
             End If
         ElseIf m_VariableInitializer IsNot Nothing Then
             UsingVariableType = Compiler.TypeCache.System_Object
             m_IsVariableDeclaration = True
         Else
             Helper.Assert(m_ArgumentList Is Nothing)
             'Helper.Assert(m_Identifier IsNot Nothing)
             m_IsVariableDeclaration = False
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         If m_VariableInitializer IsNot Nothing Then
             Dim expInfo As ExpressionResolveInfo
             expInfo = New ExpressionResolveInfo(Compiler, UsingVariableType)
             result = m_VariableInitializer.ResolveCode(expInfo) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1653" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5765" endline="5802">
<![CDATA[
 
     ''' <summary>
     ''' ElseIfStatement  
     '''	   "ElseIf" BooleanExpression  [  Then  ]  StatementTerminator
     '''	        [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseElseIfStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ElseIfStatement
         Dim result As New ElseIfStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_Code As CodeBlock
 
         If tm.Accept(KS.Else) Then
             'This is not in the spec, but MS is accepting it anyway.
             'See test Bugs/aspnet2.vb for a test case.
             tm.AcceptIfNotInternalError(KS.If)
         Else
             tm.AcceptIfNotInternalError(KS.ElseIf)
         End If
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         'ElseIf cannot be a oneliner...
         tm.Accept(KS.Then) '"Then" is not required.
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If IsOneLiner Then
             Helper.AddError(Compiler, tm.CurrentLocation)
             'TODO
         End If
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_Condition)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1654" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6460" endline="6499">
<![CDATA[
 
     ''' <summary>
     ''' ModuleDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Module"  Identifier  StatementTerminator
     '''	[  ModuleMemberDeclaration+  ]
     '''	"End" "Module" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseModuleDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As ModuleDeclaration
         Dim result As ModuleDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Name As Identifier
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Module)
 
         m_Name = ParseIdentifier()
         If m_Name Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result = New ModuleDeclaration(Parent, [Namespace], m_Name)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Module) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result.CustomAttributes IsNot Nothing Then
             result.CustomAttributes.AddRange(Attributes)
         Else
             result.CustomAttributes = Attributes
         End If
         result.Modifiers = m_Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1655" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1739" endline="1771">
<![CDATA[
 
     ''' <summary>
     ''' ParametersOrType  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParametersOrType(ByVal Parent As ParsedObject) As ParametersOrType
         Dim result As New ParametersOrType(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ParameterList As ParameterList
 
         If tm.Accept(KS.As) Then
             m_NonArrayTypeName = ParseNonArrayTypeName(result)
             result.Init(m_NonArrayTypeName)
         Else
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.LParenthesis) Then
                 If tm.Accept(KS.RParenthesis) = False Then
                     If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
                     If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Else
                     m_ParameterList = New ParameterList(result)
                 End If
                 result.Init(m_ParameterList)
             Else
                 result.Init(m_ParameterList)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1656" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4322" endline="4370">
<![CDATA[
 
     ''' <summary>
     ''' FunctionDeclaration  
     '''	[  Attributes  ]  [  ProcedureModifier+  ]  "Function" FunctionSignature  [  HandlesOrImplements  ]
     '''		LineTerminator
     '''	Block
     '''	"End" "Function" StatementTerminator
     ''' 
     ''' MustOverrideFunctionDeclaration  
     '''	[  Attributes  ]  [  MustOverrideProcedureModifier+  ]  "Function" FunctionSignature
     '''		[  HandlesOrImplements  ]  StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As FunctionDeclaration
         Dim result As New FunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_HandlesOrImplements As HandlesOrImplements = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverrideProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.HandlesOrImplements.IsMe(tm) Then
             m_HandlesOrImplements = ParseHandlesOrImplements(result)
             If m_HandlesOrImplements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.MustOverride) = False Then
             m_Block = ParseCodeBlock(result, False)
             If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             If tm.AcceptIfNotError(KS.End, KS.Function) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_HandlesOrImplements, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1657" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1809" endline="1877">
<![CDATA[
 
     ''' <summary>
     ''' AddHandlerDeclaration  
     '''	[  Attributes  ]  "AddHandler" "(" ParameterList ")" LineTerminator
     '''	[  Block  ]
     '''	"End" "AddHandler" StatementTerminator
     ''' 
     ''' RemoveHandlerDeclaration  
     '''	[  Attributes  ]  "RemoveHandler" "("  ParameterList  ")"  LineTerminator
     '''	[  Block  ]
     '''	"End" "RemoveHandler" StatementTerminator
     ''' 
     ''' LAMESPEC
     ''' RemoveHandlerDeclaration  
     '''	[  Attributes  ]  "RemoveHandler" "("  [ ParameterList  ] ")"  LineTerminator
     '''	[  Block  ]
     '''	"End" "RemoveHandler" StatementTerminator
     ''' 
     ''' RaiseEventDeclaration  
     '''	[  Attributes  ]  "RaiseEvent" (  ParameterList  )  LineTerminator
     '''	[  Block  ]
     '''	"End" "RaiseEvent" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCustomEventHandlerDeclaration(ByVal Parent As EventDeclaration, ByVal Info As ParseAttributableInfo, ByVal EventName As Identifier, ByVal EventModifiers As Modifiers) As CustomEventHandlerDeclaration
         Dim result As New CustomEventHandlerDeclaration(Parent)
 
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Block As CodeBlock
         Dim m_HandlerType As KS
         Dim m_Modifiers As Modifiers
 
         If tm.CurrentToken.Equals(KS.AddHandler, KS.RemoveHandler, KS.RaiseEvent) Then
             m_HandlerType = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.RParenthesis) = False Then
             If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, m_HandlerType) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_ParameterList Is Nothing Then m_ParameterList = New ParameterList(result)
 
         If m_HandlerType = KS.RaiseEvent Then
             m_Modifiers = New Modifiers(ModifierMasks.Private)
         Else
             m_Modifiers = EventModifiers
         End If
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_ParameterList, m_Block, m_HandlerType, EventName)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1658" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6404" endline="6459">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Interface" Identifier  [  TypeParameters  ]  StatementTerminator
     '''	[  InterfaceBase+  ]
     '''	[  InterfaceMemberDeclaration+  ]
     '''	"End" "Interface" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As InterfaceDeclaration
         Dim result As InterfaceDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_GenericName As Identifier
         Dim m_TypeParameters As TypeParameters
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Interface)
 
         m_Identifier = ParseIdentifier()
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(Parent)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_GenericName = Helper.CreateGenericTypename(m_Identifier, m_TypeParameters)
         Else
             m_TypeParameters = Nothing
             m_GenericName = m_Identifier
         End If
 
         result = New InterfaceDeclaration(Parent, [Namespace], m_GenericName, m_TypeParameters)
 
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         If InterfaceBases.IsMe(tm) Then
             result.InterfaceBases = ParseInterfaceBases(result)
             If result.InterfaceBases Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If ParseInterfaceMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Interface) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = m_Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1659" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3700" endline="3734">
<![CDATA[
 
     ''' <summary>
     ''' PropertyGetDeclaration  
     '''	[  Attributes  ]  [  AccessModifier  ]  Get  LineTerminator
     '''	[  Block  ]
     '''	End  Get  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParsePropertyGetMember(ByVal Parent As PropertyDeclaration, ByVal Info As ParseAttributableInfo, ByVal ParentSignature As FunctionSignature, ByVal ParentImplements As MemberImplementsClause, ByVal ParentModifiers As ModifierMasks) As PropertyGetDeclaration
         Dim result As New PropertyGetDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.AccessModifiers)
         If m_Modifiers.Empty = False Then
             m_Modifiers.AddModifiers(ParentModifiers And (Not ModifierMasks.AccessModifiers))
         Else
             m_Modifiers.AddModifiers(ParentModifiers)
         End If
 
         tm.AcceptIfNotInternalError(KS.Get)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Get) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, ParentImplements, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1660" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6359" endline="6403">
<![CDATA[
 
     ''' <summary>
     ''' EnumDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Enum"  Identifier  [  "As"  IntegralTypeName  ]  StatementTerminator
     '''	   EnumMemberDeclaration+
     '''	"End" "Enum"  StatementTerminator
     ''' 
     ''' LAMESPEC
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As EnumDeclaration
         Dim result As EnumDeclaration
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_QualifiedName As KS = KS.Integer
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Enum)
 
         m_Identifier = ParseIdentifier()
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If tm.CurrentToken.Equals(Enums.IntegralTypeNames) Then
                 m_QualifiedName = tm.CurrentToken.Keyword
                 tm.NextToken()
             Else
                 Helper.AddError(Compiler, tm.CurrentLocation, "Enum type must be integral")
             End If
         End If
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result = New EnumDeclaration(Parent, [Namespace], m_Identifier, m_QualifiedName)
 
         If ParseEnumMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Enum) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = m_Modifiers
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1661" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3656" endline="3699">
<![CDATA[
 
     ''' <summary>
     ''' PropertySetDeclaration  
     '''	[  Attributes  ]  [  AccessModifier  ]  "Set" [  (  ParameterList  )  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Set" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParsePropertySetMember(ByVal Parent As PropertyDeclaration, ByVal Info As ParseAttributableInfo, ByVal ParentSignature As FunctionSignature, ByVal ParentImplements As MemberImplementsClause, ByVal ParentModifiers As ModifierMasks) As PropertySetDeclaration
         Dim result As New PropertySetDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.AccessModifiers)
         If m_Modifiers.Empty = False Then
             m_Modifiers.AddModifiers(ParentModifiers And (Not ModifierMasks.AccessModifiers))
         Else
             m_Modifiers.AddModifiers(ParentModifiers)
         End If
         tm.AcceptIfNotInternalError(KS.Set)
 
         If tm.Accept(KS.LParenthesis) Then
             If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Set) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, ParentImplements, m_Block, m_ParameterList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1662" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4614" endline="4681">
<![CDATA[
 
     ''' <summary>
     ''' ExternalFunctionDeclaration  
     '''	[  Attributes  ]  [  ExternalMethodModifier+  ]  "Declare" [  CharsetModifier  ] "Function" Identifier
     '''		LibraryClause  [  AliasClause  ]  [  (  [  ParameterList  ]  )  ]  [  As  [  Attributes  ]  TypeName  ]
     '''		StatementTerminator
     ''' 
     ''' CharsetModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExternalFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ExternalFunctionDeclaration
         Dim result As New ExternalFunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_CharsetModifier As KS = KS.None
         Dim m_Identifier As Identifier
         Dim m_LibraryClause As LibraryClause = Nothing
         Dim m_AliasClause As AliasClause = Nothing
         Dim m_ParameterList As ParameterList = Nothing
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_TypeName As TypeName = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ExternalMethodModifiers)
         tm.AcceptIfNotInternalError(KS.Declare)
 
         If tm.CurrentToken.Equals(ModifierMasks.CharSetModifiers) Then
             m_CharsetModifier = tm.CurrentToken.Keyword
             tm.NextToken()
         End If
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LibraryClause = ParseLibraryClause(result)
         If m_LibraryClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If AliasClause.IsMe(tm) Then
             m_AliasClause = ParseAliasClause(result)
             If m_AliasClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.Accept(KS.LParenthesis) Then
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_CharsetModifier, m_Identifier, m_LibraryClause, m_AliasClause, m_ParameterList, m_ReturnTypeAttributes, m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1663" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4555" endline="4613">
<![CDATA[
 
     ''' <summary>
     ''' ExternalSubDeclaration 
     ''' 	[  Attributes  ]  [  ExternalMethodModifier+  ] "Declare" [  CharsetModifier  ] "Sub" Identifier
     '''		LibraryClause  [  AliasClause  ]  [  (  [  ParameterList  ]  )  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExternalSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ExternalSubDeclaration
         Dim result As New ExternalSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_CharsetModifier As KS
         Dim m_Identifier As Identifier
         Dim m_LibraryClause As LibraryClause = Nothing
         Dim m_AliasClause As AliasClause = Nothing
         Dim m_ParameterList As ParameterList = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ExternalMethodModifiers)
 
         tm.AcceptIfNotInternalError(KS.Declare)
 
         If tm.CurrentToken.Equals(ModifierMasks.CharSetModifiers) Then
             m_CharsetModifier = tm.CurrentToken.Keyword
             tm.NextToken()
         End If
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_LibraryClause = ParseLibraryClause(result)
         If m_LibraryClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If AliasClause.IsMe(tm) Then
             m_AliasClause = ParseAliasClause(result)
             If m_AliasClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.LParenthesis) Then
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_CharsetModifier, m_Identifier, m_LibraryClause, m_AliasClause, m_ParameterList)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1664" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4240" endline="4321">
<![CDATA[
 
 
     ''' <summary>
     ''' BinaryOperatorDeclaration  
     '''	[  Attributes  ]  [  OperatorModifier+  ]  "Operator"  OverloadableBinaryOperator
     '''		"("  Operand  ","  Operand  ")"  [ "As"  [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' 
     ''' UnaryOperatorDeclaration  
     '''	[  Attributes  ]  [  OperatorModifier+  ]  "Operator" OverloadableUnaryOperator 
     '''     "("  Operand  ")" 		[  "As" [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' OverloadableUnaryOperator  
     ''' </summary>
     ''' <remarks></remarks>
 
     Private Function ParseOperatorDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As OperatorDeclaration
         Dim result As New OperatorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_OperatorSymbol As KS
         Dim m_OperatorIdentifier As String = Nothing
         Dim m_Operand1 As Operand
         Dim m_Operand2 As Operand
         Dim m_TypeName As TypeName
         Dim m_ReturnTypeAttributes As New Attributes(Parent)
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.OperatorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Operator)
 
         If vbnc.OperatorDeclaration.IsOverloadableOperator(tm.CurrentToken) Then
             If tm.CurrentToken.IsIdentifier Then
                 m_OperatorIdentifier = DirectCast(tm.Reader.TokenData, String)
             Else
                 m_OperatorSymbol = tm.CurrentToken.Symbol
             End If
             tm.NextToken()
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Operand1 = ParseOperand(result)
         If m_Operand1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) Then
             m_Operand2 = ParseOperand(result)
             If m_Operand2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Operand2 = Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Operator) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_OperatorIdentifier, m_OperatorSymbol, m_Operand1, m_Operand2, m_ReturnTypeAttributes, m_TypeName, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1665" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="6281" endline="6330">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="1650" endline="1708">
<![CDATA[
 
     ''' <summary>
     ''' CustomEventMemberDeclaration  
     '''	[  Attributes  ]  [  EventModifiers+  ]  "Custom" "Event" Identifier "As" TypeName  [  ImplementsClause  ]
     '''		StatementTerminator
     '''		EventAccessorDeclaration+
     '''	"End" "Event" StatementTerminator
     ''' 
     ''' LAMESPEC!!! Using the following
     ''' CustomEventMemberDeclaration  
     '''	[  Attributes  ]  [  EventModifiers+  ]  "Custom" "Event" Identifier "As" NonArrayTypeName  [  ImplementsClause  ]
     '''		StatementTerminator
     '''		EventAccessorDeclaration+
     '''	"End" "Event" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCustomEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As CustomEventDeclaration
         Dim result As New CustomEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeName As NonArrayTypeName
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
         Dim m_EventAccessorDeclarations As EventAccessorDeclarations = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError("Custom")
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_TypeName = ParseNonArrayTypeName(result)
         If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_EventAccessorDeclarations = ParseEventAccessorDeclarations(result, m_Identifier, m_Modifiers)
         If m_EventAccessorDeclarations Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Event) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_TypeName, m_ImplementsClause)
 
         result.AddMethod = m_EventAccessorDeclarations.AddHandler
         result.RemoveMethod = m_EventAccessorDeclarations.RemoveHandler
         result.RaiseMethod = m_EventAccessorDeclarations.RaiseEvent
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1666" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="766" endline="796">
<![CDATA[
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="86" endline="117">
<![CDATA[
 
 
     Public Overrides ReadOnly Property IsConstant() As Boolean
         Get
             If m_ConstantValue IsNot Nothing Then Return True
             If m_AscWExpression IsNot Nothing Then
                 If m_AscWExpression.IsConstant Then
                     m_ConstantValue = Microsoft.VisualBasic.AscW(CChar(m_AscWExpression.ConstantValue))
                     Return True
                 Else
                     Return False
                 End If
             End If
             If m_ArgumentList.Count <> 1 Then Return False
             If m_Expression.Classification.IsMethodGroupClassification Then
                 Dim param As Object
                 Dim mgc As MethodGroupClassification = m_Expression.Classification.AsMethodGroupClassification
                 If mgc.IsLateBound Then Return False
 
                 Dim mi As Mono.Cecil.MethodReference = mgc.ResolvedMethodInfo
 
                 If mi Is Nothing Then Return False
                 If Not (m_ArgumentList(0).Expression IsNot Nothing AndAlso m_ArgumentList(0).Expression.IsConstant) Then Return False
 
                 param = m_ArgumentList(0).Expression.ConstantValue
                 If Compiler.NameResolver.IsConstantMethod(mi, param, m_ConstantValue) = False Then Return False
 
                 Return True
             Else
                 Return False
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1667" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="766" endline="796">
<![CDATA[
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="819" endline="884">
<![CDATA[
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1668" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="829" endline="854">
<![CDATA[
 
 		public void MarkLabel(Label loc)
 		{
 			Debug.Assert(stackHeight == -1 || labelStackHeight[loc.Index] == -1 || stackHeight == labelStackHeight[loc.Index]);
 			labels[loc.Index] = code.Position;
 			if (labelStackHeight[loc.Index] == -1)
 			{
 				if (stackHeight == -1)
 				{
 					// We're at a location that can only be reached by a backward branch,
 					// so according to the "backward branch constraint" that must mean the stack is empty,
 					// but note that this may be an unused label followed by another label that is used and
 					// that does have a non-zero stack height, so we don't yet set stackHeight here.
 					labelStackHeight[loc.Index] = 0;
 				}
 				else
 				{
 					labelStackHeight[loc.Index] = stackHeight;
 				}
 			}
 			else
 			{
 				Debug.Assert(stackHeight == -1 || stackHeight == labelStackHeight[loc.Index]);
 				stackHeight = labelStackHeight[loc.Index];
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="490" endline="540">
<![CDATA[
 
 		public void Emit(OpCode opc, Label label)
 		{
 			// We need special stackHeight handling for unconditional branches,
 			// because the branch and next flows have differing stack heights.
 			// Note that this assumes that unconditional branches do not push/pop.
 			int flowStackHeight = this.stackHeight;
 			Emit(opc);
 			if (opc == OpCodes.Leave || opc == OpCodes.Leave_S)
 			{
 				flowStackHeight = 0;
 			}
 			else if (opc.FlowControl != FlowControl.Branch)
 			{
 				flowStackHeight = this.stackHeight;
 			}
 			// if the label has already been marked, we can emit the branch offset directly
 			if (labels[label.Index] != -1)
 			{
 				if (labelStackHeight[label.Index] != flowStackHeight && (labelStackHeight[label.Index] != 0 || flowStackHeight != -1))
 				{
 					// the "backward branch constraint" prohibits this, so we don't need to support it
 					throw new NotSupportedException("'Backward branch constraints' violated");
 				}
 				if (opc.OperandType == OperandType.ShortInlineBrTarget)
 				{
 					WriteByteBranchOffset(labels[label.Index] - (code.Position + 1));
 				}
 				else
 				{
 					code.Write(labels[label.Index] - (code.Position + 4));
 				}
 			}
 			else
 			{
 				Debug.Assert(labelStackHeight[label.Index] == -1 || labelStackHeight[label.Index] == flowStackHeight || (flowStackHeight == -1 && labelStackHeight[label.Index] == 0));
 				labelStackHeight[label.Index] = flowStackHeight;
 				LabelFixup fix = new LabelFixup();
 				fix.label = label.Index;
 				fix.offset = code.Position;
 				labelFixups.Add(fix);
 				if (opc.OperandType == OperandType.ShortInlineBrTarget)
 				{
 					code.Write((byte)1);
 				}
 				else
 				{
 					code.Write(4);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1669" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="460" endline="487">
<![CDATA[
 
 		private static void WriteGenericSignature(ModuleBuilder module, ByteBuffer bb, Type type)
 		{
 			Type[] typeArguments = type.GetGenericArguments();
 			Type[][] requiredCustomModifiers = type.__GetGenericArgumentsRequiredCustomModifiers();
 			Type[][] optionalCustomModifiers = type.__GetGenericArgumentsOptionalCustomModifiers();
 			if (!type.IsGenericTypeDefinition)
 			{
 				type = type.GetGenericTypeDefinition();
 			}
 			bb.Write(ELEMENT_TYPE_GENERICINST);
 			if (type.IsValueType)
 			{
 				bb.Write(ELEMENT_TYPE_VALUETYPE);
 			}
 			else
 			{
 				bb.Write(ELEMENT_TYPE_CLASS);
 			}
 			bb.WriteTypeDefOrRefEncoded(module.GetTypeToken(type).Token);
 			bb.WriteCompressedInt(typeArguments.Length);
 			for (int i = 0; i < typeArguments.Length; i++)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
 				WriteType(module, bb, typeArguments[i]);
 			}
 			for (int i = 0; i < typeArguments.Length; i++)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
 				WriteType(module, bb, typeArguments[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="427" endline="456">
<![CDATA[
 
 		public MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria)
 		{
 			List<MemberInfo> members = new List<MemberInfo>();
 			if ((memberType & MemberTypes.Constructor) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetConstructors(bindingAttr));
 			}
 			if ((memberType & MemberTypes.Method) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetMethods(bindingAttr));
 			}
 			if ((memberType & MemberTypes.Field) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetFields(bindingAttr));
 			}
 			if ((memberType & MemberTypes.Property) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetProperties(bindingAttr));
 			}
 			if ((memberType & MemberTypes.Event) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetEvents(bindingAttr));
 			}
 			if ((memberType & MemberTypes.NestedType) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetNestedTypes(bindingAttr));
 			}
 			return members.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1670" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="642" endline="662">
<![CDATA[
 
 		public override void Emit ()
 		{
 			CheckReservedNameConflict (GetMethod.Prefix, get == null ? null 
 			CheckReservedNameConflict (SetMethod.Prefix, set == null ? null 
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (member_type == InternalType.Dynamic) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (PropertyBuilder);
 			} else if (member_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (PropertyBuilder, member_type, Location);
 			}
 
 			first.Emit (Parent);
 			if (AccessorSecond != null)
 				AccessorSecond.Emit (Parent);
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="601" endline="637">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1671" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="989" endline="1017">
<![CDATA[
 
 		public static TypeParameterSpec[] InflateConstraints<T> (TypeParameterSpec[] tparams, Func<T, TypeParameterInflator> inflatorFactory, T arg)
 		{
 			TypeParameterSpec[] constraints = null;
 			TypeParameterInflator? inflator = null;
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 				if (tp.HasTypeConstraint || tp.Interfaces != null || tp.TypeArguments != null) {
 					if (constraints == null) {
 						constraints = new TypeParameterSpec[tparams.Length];
 						Array.Copy (tparams, constraints, constraints.Length);
 					}
 
 					//
 					// Using a factory to avoid possibly expensive inflator build up
 					//
 					if (inflator == null)
 						inflator = inflatorFactory (arg);
 
 					constraints[i] = (TypeParameterSpec) constraints[i].InflateMember (inflator.Value);
 				}
 			}
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 				if (tp.HasTypeConstraint || tp.Interfaces != null || tp.TypeArguments != null) {
 					if (constraints == null) {
 						constraints = new TypeParameterSpec[tparams.Length];
 						Array.Copy (tparams, constraints, constraints.Length);
 					}
 
 					//
 					// Using a factory to avoid possibly expensive inflator build up
 					//
 					if (inflator == null)
 						inflator = inflatorFactory (arg);
 
 					constraints[i] = (TypeParameterSpec) constraints[i].InflateMember (inflator.Value);
 				}
 			}
 
 			if (constraints == null)
 				constraints = tparams;
 
 			return constraints;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="849" endline="886">
<![CDATA[
 		}
 
 		public AParametersCollection Inflate (TypeParameterInflator inflator)
 		{
 			TypeSpec[] inflated_types = null;
 			bool default_value = false;
 
 			for (int i = 0; i < Count; ++i) {
 				var inflated_param = inflator.Inflate (types[i]);
 				if (inflated_types == null) {
 					if (inflated_param == types[i])
 						continue;
 
 					default_value |= FixedParameters[i] is DefaultValueExpression;
 					inflated_types = new TypeSpec[types.Length];
 					Array.Copy (types, inflated_types, types.Length);	
 				}
 
 				inflated_types[i] = inflated_param;
 			}
 			for (int i = 0; i < Count; ++i) {
 				var inflated_param = inflator.Inflate (types[i]);
 				if (inflated_types == null) {
 					if (inflated_param == types[i])
 						continue;
 
 					default_value |= FixedParameters[i] is DefaultValueExpression;
 					inflated_types = new TypeSpec[types.Length];
 					Array.Copy (types, inflated_types, types.Length);	
 				}
 
 				inflated_types[i] = inflated_param;
 			}
 
 			if (inflated_types == null)
 				return this;
 
 			var clone = (AParametersCollection) MemberwiseClone ();
 			clone.types = inflated_types;
 			if (default_value) {
 				for (int i = 0; i < Count; ++i) {
 					var dve = clone.FixedParameters[i] as DefaultValueExpression;
 					if (dve != null) {
 						throw new NotImplementedException ("net");
 						//	clone.FixedParameters [i].DefaultValue = new DefaultValueExpression ();
 					}
 				}
 				for (int i = 0; i < Count; ++i) {
 					var dve = clone.FixedParameters[i] as DefaultValueExpression;
 					if (dve != null) {
 						throw new NotImplementedException ("net");
 						//	clone.FixedParameters [i].DefaultValue = new DefaultValueExpression ();
 					}
 				}
 			}
 
 			return clone;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1672" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3792" endline="3823">
<![CDATA[
 
     ''' <summary>
     ''' FunctionSignature  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseFunctionSignature(ByVal Parent As ParsedObject) As FunctionSignature
         Dim result As New FunctionSignature(Parent)
 
         Dim m_Identifier As Identifier = Nothing
         Dim m_TypeParameters As TypeParameters = Nothing
         Dim m_ParameterList As New ParameterList(result)
         Dim m_ReturnTypeAttributes As New Attributes(result)
         Dim m_TypeName As TypeName = Nothing
 
         If ParseSubSignature(result, m_Identifier, m_TypeParameters, m_ParameterList) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.As) Then
             If Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_TypeParameters, m_ParameterList, m_ReturnTypeAttributes, m_TypeName, New Span(m_Identifier.Location, tm.CurrentLocation))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3931" endline="3974">
<![CDATA[
 
     ''' <summary>
     ''' Parameter            
     ''' ParameterModifier    
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameter(ByVal Parent As ParsedObject) As Parameter
         Helper.Assert(TypeOf Parent Is ParameterList)
         Dim result As New Parameter(DirectCast(Parent, ParameterList))
 
         Dim m_Attributes As New Attributes(result)
         Dim m_Modifiers As Modifiers
         Dim m_ParameterIdentifier As ParameterIdentifier
         Dim m_TypeName As TypeName
         Dim m_ConstantExpression As Expression
 
         If vbnc.Attributes.IsMe(tm) Then
             ParseAttributes(result, m_Attributes)
         End If
 
         m_Modifiers = ParseModifiers(ModifierMasks.ParameterModifiers)
 
         m_ParameterIdentifier = ParseParameterIdentifier(result)
         If m_ParameterIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         If tm.Accept(KS.Equals) Then
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         result.Init(m_Attributes, m_Modifiers, m_ParameterIdentifier, m_TypeName, m_ConstantExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1673" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1970" endline="1989">
<![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1990" endline="2009">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1674" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="524" endline="793">
<![CDATA[
 		
 		//
 		// Currently handles the Unix-like command line options, but will be
 		// deprecated in favor of the CSCParseOption, which will also handle the
 		// options that start with a dash in the future.
 		//
 		bool UnixParseOption (string arg, ref string [] args, ref int i)
 		{
 			switch (arg){
 			case "-v"
 				CSharpParser.yacc_verbose_flag++;
 				return true;
 
 			case "--version"
 				Version ();
 				return true;
 				
 			case "--parse"
 				RootContext.ParseOnly = true;
 				return true;
 				
 			case "--main"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.MainClass = args [++i];
 				return true;
 				
 			case "--unsafe"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.Unsafe = true;
 				return true;
 				
 			case "/?"
 			case "--help"
 				Usage ();
 				Environment.Exit (0);
 				return true;
 
 			case "--define"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.AddConditional (args [++i]);
 				return true;
 
 			case "--tokenize"
 				RootContext.TokenizeOnly = true;
 				return true;
 				
 			case "-o"
 			case "--output"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.OutputFile = args [++i];
 				return true;
 
 			case "--checked"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.Checked = true;
 				return true;
 				
 			case "--stacktrace"
 				Report.Printer.Stacktrace = true;
 				return true;
 				
 			case "--linkresource"
 			case "--linkres"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Report.Error (5, "Missing argument to --linkres"); 
 					Environment.Exit (1);
 				}
 
 				AddResource (new AssemblyResource (args[++i], args[i]));
 				return true;
 				
 			case "--resource"
 			case "--res"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Report.Error (5, "Missing argument to --resource"); 
 					Environment.Exit (1);
 				}
 
 				AddResource (new AssemblyResource (args[++i], args[i], true));
 				return true;
 				
 			case "--target"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Environment.Exit (1);
 					return true;
 				}
 				
 				string type = args [++i];
 				switch (type){
 				case "library"
 					RootContext.Target = Target.Library;
 					RootContext.TargetExt = ".dll";
 					break;
 					
 				case "exe"
 					RootContext.Target = Target.Exe;
 					break;
 					
 				case "winexe"
 					RootContext.Target = Target.WinExe;
 					break;
 					
 				case "module"
 					RootContext.Target = Target.Module;
 					RootContext.TargetExt = ".dll";
 					break;
 				default
 					TargetUsage ();
 					break;
 				}
 				return true;
 				
 			case "-r"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				
 				string val = args [++i];
 				int idx = val.IndexOf ('=');
 				if (idx > -1) {
 					string alias = val.Substring (0, idx);
 					string assembly = val.Substring (idx + 1);
 					AddAssemblyReference (alias, assembly);
 					return true;
 				}
 
 				AddAssemblyReference (val);
 				return true;
 				
 			case "-L"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();	
 					Environment.Exit (1);
 				}
 				RootContext.ReferencesLookupPaths.Add (args [++i]);
 				return true;
 
 			case "--lint"
 				RootContext.EnhancedWarnings = true;
 				return true;
 				
 			case "--nostdlib"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.StdLib = false;
 				return true;
 				
 			case "--nowarn"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				int warn = 0;
 				
 				try {
 					warn = Int32.Parse (args [++i]);
 				} catch {
 					Usage ();
 					Environment.Exit (1);
 				}
 				Report.SetIgnoreWarning (warn);
 				return true;
 
 			case "--wlevel"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Report.Error (
 						1900,
 						"--wlevel requires a value from 0 to 4");
 					Environment.Exit (1);
 				}
 
 				SetWarningLevel (args [++i]);
 				return true;
 
 			case "--mcs-debug"
 				if ((i + 1) >= args.Length){
 					Report.Error (5, "--mcs-debug requires an argument");
 					Environment.Exit (1);
 				}
 
 				try {
 					Report.DebugFlags = Int32.Parse (args [++i]);
 				} catch {
 					Report.Error (5, "Invalid argument to --mcs-debug");
 					Environment.Exit (1);
 				}
 				return true;
 				
 			case "--about"
 				About ();
 				return true;
 				
 			case "--recurse"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Report.Error (5, "--recurse requires an argument");
 					Environment.Exit (1);
 				}
 				ProcessSourceFiles (args [++i], true); 
 				return true;
 				
 			case "--timestamp"
 				timestamps = true;
 				return true;
 
 			case "--debug"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.GenerateDebugInfo = true;
 				return true;
 				
 			case "--noconfig"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.LoadDefaultReferences = false;
 				return true;
 
 			default
 				if (arg.StartsWith ("--fatal")){
 					if (arg.StartsWith ("--fatal=")){
 						if (!Int32.TryParse (arg.Substring (8), out fatal_errors))
 							fatal_errors = 1;
 					} else
 						fatal_errors = 1;
 					return true;
 				}
 				if (arg.StartsWith ("--runtime
 					string version = arg.Substring (10);
 
 					switch (version) {
 					case "v1"
 					case "V1"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v1;
 						break;
 					case "v2"
 					case "V2"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v2;
 						return true;
 					case "v4"
 					case "V4"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v4;
 						return true;
 					}
 					return true;
 				}
 
 				break;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="832" endline="1349">
<![CDATA[
 #endif
 
 		//
 		// This parses the -arg and /arg options to the compiler, even if the strings
 		// in the following text use "/arg" on the strings.
 		//
 		bool CSCParseOption (string option, ref string [] args)
 		{
 			int idx = option.IndexOf ('
 			string arg, value;
 
 			if (idx == -1){
 				arg = option;
 				value = "";
 			} else {
 				arg = option.Substring (0, idx);
 
 				value = option.Substring (idx + 1);
 			}
 
 			switch (arg.ToLowerInvariant ()){
 			case "/nologo"
 				return true;
 
 			case "/t"
 			case "/target"
 				switch (value){
 				case "exe"
 					RootContext.Target = Target.Exe;
 					break;
 
 				case "winexe"
 					RootContext.Target = Target.WinExe;
 					break;
 
 				case "library"
 					RootContext.Target = Target.Library;
 					RootContext.TargetExt = ".dll";
 					break;
 
 				case "module"
 					RootContext.Target = Target.Module;
 					RootContext.TargetExt = ".netmodule";
 					break;
 
 				default
 					TargetUsage ();
 					break;
 				}
 				return true;
 
 			case "/out"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				RootContext.OutputFile = value;
 				return true;
 
 			case "/o"
 			case "/o+"
 			case "/optimize"
 			case "/optimize+"
 				RootContext.Optimize = true;
 				return true;
 
 			case "/o-"
 			case "/optimize-"
 				RootContext.Optimize = false;
 				return true;
 
 			// TODO
 			case "/incremental"
 			case "/incremental+"
 			case "/incremental-"
 				// nothing.
 				return true;
 
 			case "/d"
 			case "/define"
 				if (value.Length == 0){
 					Usage ();
 					Environment.Exit (1);
 				}
 
 				foreach (string d in value.Split (argument_value_separator)) {
 					string conditional = d.Trim ();
 					if (!Tokenizer.IsValidIdentifier (conditional)) {
 						Report.Warning (2029, 1, "Invalid conditional define symbol `{0}'", conditional);
 						continue;
 					}
 					RootContext.AddConditional (conditional);
 				}
 				foreach (string d in value.Split (argument_value_separator)) {
 					string conditional = d.Trim ();
 					if (!Tokenizer.IsValidIdentifier (conditional)) {
 						Report.Warning (2029, 1, "Invalid conditional define symbol `{0}'", conditional);
 						continue;
 					}
 					RootContext.AddConditional (conditional);
 				}
 				return true;
 			}
 
 			case "/bugreport"
 				//
 				// We should collect data, runtime, etc and store in the file specified
 				//
 				Console.WriteLine ("To file bug reports, please visit
 				return true;
 #if !SMCS_SOURCE
 			case "/pkg"
 				string packages;
 
 				if (value.Length == 0){
 					Usage ();
 					Environment.Exit (1);
 				}
 				packages = String.Join (" ", value.Split (new Char [] { ';', ',', '\n', '\r'}));
 				string pkgout = GetPackageFlags (packages, true, Report);
 				
 				if (pkgout != null){
 					string [] xargs = pkgout.Trim (new Char [] {' ', '\n', '\r', '\t'}).
 						Split (new Char [] { ' ', '\t'});
 					args = AddArgs (args, xargs);
 				}
 				
 				return true;
 			}
 #endif
 			case "/linkres"
 			case "/linkresource"
 			case "/res"
 			case "/resource"
 				AssemblyResource res = null;			
 				string[] s = value.Split (argument_value_separator, StringSplitOptions.RemoveEmptyEntries);
 				switch (s.Length) {
 				case 1
 					if (s[0].Length == 0)
 						goto default;
 					res = new AssemblyResource (s [0], Path.GetFileName (s[0]));
 					break;
 				case 2
 					res = new AssemblyResource (s [0], s [1]);
 					break;
 				case 3
 					if (s [2] != "public" && s [2] != "private") {
 						Report.Error (1906, "Invalid resource visibility option `{0}'. Use either `public' or `private' instead", s [2]);
 						return true;
 					}
 					res = new AssemblyResource (s[0], s[1], s[2] == "private");
 					break;
 				default
 					Report.Error (-2005, "Wrong number of arguments for option `{0}'", option);
 					break;
 				}
 
 				if (res != null) {
 					res.IsEmbeded = arg [1] == 'r' || arg [1] == 'R';
 					AddResource (res);
 				}
 
 				return true;
 				
 			case "/recurse"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				ProcessSourceFiles (value, true); 
 				return true;
 
 			case "/r"
 			case "/reference"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				string[] refs = value.Split (argument_value_separator);
 				foreach (string r in refs){
 					if (r.Length == 0)
 						continue;
 
 					string val = r;
 					int index = val.IndexOf ('=');
 					if (index > -1) {
 						string alias = r.Substring (0, index);
 						string assembly = r.Substring (index + 1);
 						AddAssemblyReference (alias, assembly);
 						if (refs.Length != 1) {
 							Report.Error (2034, "Cannot specify multiple aliases using single /reference option");
 							break;
 						}
 					} else {
 						AddAssemblyReference (val);
 					}
 				}
 				foreach (string r in refs){
 					if (r.Length == 0)
 						continue;
 
 					string val = r;
 					int index = val.IndexOf ('=');
 					if (index > -1) {
 						string alias = r.Substring (0, index);
 						string assembly = r.Substring (index + 1);
 						AddAssemblyReference (alias, assembly);
 						if (refs.Length != 1) {
 							Report.Error (2034, "Cannot specify multiple aliases using single /reference option");
 							break;
 						}
 					} else {
 						AddAssemblyReference (val);
 					}
 				}
 				return true;
 			}
 			case "/addmodule"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				string[] refs = value.Split (argument_value_separator);
 				foreach (string r in refs){
 					RootContext.Modules.Add (r);
 				}
 				foreach (string r in refs){
 					RootContext.Modules.Add (r);
 				}
 				return true;
 			}
 			case "/win32res"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				
 				if (RootContext.Win32IconFile != null)
 					Report.Error (1565, "Cannot specify the `win32res' and the `win32ico' compiler option at the same time");
 
 				RootContext.Win32ResourceFile = value;
 				return true;
 			}
 			case "/win32icon"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				if (RootContext.Win32ResourceFile != null)
 					Report.Error (1565, "Cannot specify the `win32res' and the `win32ico' compiler option at the same time");
 
 				RootContext.Win32IconFile = value;
 				return true;
 			}
 			case "/doc"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				RootContext.Documentation = new Documentation (value);
 				return true;
 			}
 			case "/lib"
 				string [] libdirs;
 				
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				libdirs = value.Split (argument_value_separator);
 				foreach (string dir in libdirs)
 					RootContext.ReferencesLookupPaths.Add (dir);
 				foreach (string dir in libdirs)
 					RootContext.ReferencesLookupPaths.Add (dir);
 				return true;
 			}
 
 			case "/debug-"
 				RootContext.GenerateDebugInfo = false;
 				return true;
 				
 			case "/debug"
 				if (value == "full" || value == "")
 					RootContext.GenerateDebugInfo = true;
 
 				return true;
 				
 			case "/debug+"
 				RootContext.GenerateDebugInfo = true;
 				return true;
 
 			case "/checked"
 			case "/checked+"
 				RootContext.Checked = true;
 				return true;
 
 			case "/checked-"
 				RootContext.Checked = false;
 				return true;
 
 			case "/clscheck"
 			case "/clscheck+"
 				RootContext.VerifyClsCompliance = true;
 				return true;
 
 			case "/clscheck-"
 				RootContext.VerifyClsCompliance = false;
 				return true;
 
 			case "/unsafe"
 			case "/unsafe+"
 				RootContext.Unsafe = true;
 				return true;
 
 			case "/unsafe-"
 				RootContext.Unsafe = false;
 				return true;
 
 			case "/warnaserror"
 			case "/warnaserror+"
 				if (value.Length == 0) {
 					Report.WarningsAreErrors = true;
 				} else {
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.AddWarningAsError (wid);
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.AddWarningAsError (wid);
 				}
 				return true;
 
 			case "/warnaserror-"
 				if (value.Length == 0) {
 					Report.WarningsAreErrors = false;
 				} else {
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.RemoveWarningAsError (wid);
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.RemoveWarningAsError (wid);
 				}
 				return true;
 
 			case "/warn"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				SetWarningLevel (value);
 				return true;
 
 			case "/nowarn"
 				if (value.Length == 0){
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				var warns = value.Split (argument_value_separator);
 				foreach (string wc in warns){
 					try {
 						if (wc.Trim ().Length == 0)
 							continue;
 
 						int warn = Int32.Parse (wc);
 						if (warn < 1) {
 							throw new ArgumentOutOfRangeException("warn");
 						}
 						Report.SetIgnoreWarning (warn);
 					} catch {
 						Report.Error (1904, "`{0}' is not a valid warning number", wc);
 					}
 				}
 				foreach (string wc in warns){
 					try {
 						if (wc.Trim ().Length == 0)
 							continue;
 
 						int warn = Int32.Parse (wc);
 						if (warn < 1) {
 							throw new ArgumentOutOfRangeException("warn");
 						}
 						Report.SetIgnoreWarning (warn);
 					} catch {
 						Report.Error (1904, "`{0}' is not a valid warning number", wc);
 					}
 				}
 				return true;
 			}
 
 			case "/noconfig"
 				RootContext.LoadDefaultReferences = false;
 				return true;
 
 			case "/platform"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLower (CultureInfo.InvariantCulture)) {
 				case "anycpu"
 					RootContext.Platform = Platform.AnyCPU;
 					break;
 				case "x86"
 					RootContext.Platform = Platform.X86;
 					break;
 				case "x64"
 					RootContext.Platform = Platform.X64;
 					break;
 				case "itanium"
 					RootContext.Platform = Platform.IA64;
 					break;
 				default
 					Report.Error (1672, "Invalid platform type for -platform. Valid options are `anycpu', `x86', `x64' or `itanium'");
 					break;
 				}
 
 				return true;
 
 			case "/sdk"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLowerInvariant ()) {
 					case "2"
 						RootContext.SdkVersion = SdkVersion.v2;
 						break;
 					case "4"
 						RootContext.SdkVersion = SdkVersion.v4;
 						break;
 					default
 						Report.Error (-26, "Invalid sdk version name");
 						break;
 				}
 
 				return true;
 
 				// We just ignore this.
 			case "/errorreport"
 			case "/filealign"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				return true;
 				
 			case "/helpinternal"
 				OtherFlags ();
 				Environment.Exit(0);
 				return true;
 				
 			case "/help"
 			case "/?"
 				Usage ();
 				Environment.Exit (0);
 				return true;
 
 			case "/main"
 			case "/m"
 				if (value.Length == 0){
 					Error_RequiresArgument (option);
 					break;
 				}
 				RootContext.MainClass = value;
 				return true;
 
 			case "/nostdlib"
 			case "/nostdlib+"
 				RootContext.StdLib = false;
 				return true;
 
 			case "/nostdlib-"
 				RootContext.StdLib = true;
 				return true;
 
 			case "/fullpaths"
 				return true;
 
 			case "/keyfile"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				RootContext.StrongNameKeyFile = value;
 				return true;
 
 			case "/keycontainer"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				RootContext.StrongNameKeyContainer = value;
 				return true;
 			case "/delaysign+"
 			case "/delaysign"
 				RootContext.StrongNameDelaySign = true;
 				return true;
 			case "/delaysign-"
 				RootContext.StrongNameDelaySign = false;
 				return true;
 
 			case "/langversion"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLowerInvariant ()) {
 				case "iso-1"
 					RootContext.Version = LanguageVersion.ISO_1;
 					return true;	
 				case "default"
 					RootContext.Version = LanguageVersion.Default;
 					RootContext.AddConditional ("__V2__");
 					return true;
 				case "iso-2"
 					RootContext.Version = LanguageVersion.ISO_2;
 					return true;
 				case "3"
 					RootContext.Version = LanguageVersion.V_3;
 					return true;
 				case "future"
 					RootContext.Version = LanguageVersion.Future;
 					return true;
 				}
 
 				Report.Error (1617, "Invalid -langversion option `{0}'. It must be `ISO-1', `ISO-2', `3' or `Default'", value);
 				return true;
 
 			case "/codepage"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value) {
 				case "utf8"
 					RootContext.Encoding = new UTF8Encoding();
 					break;
 				case "reset"
 					RootContext.Encoding = Encoding.Default;
 					break;
 				default
 					try {
 						RootContext.Encoding = Encoding.GetEncoding (Int32.Parse (value));
 					} catch {
 						Report.Error (2016, "Code page `{0}' is invalid or not installed", value);
 					}
 					break;
 				}
 				return true;
 
 			default
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1675" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="257" endline="354">
<![CDATA[
 
     Function GenerateMyForms() As Boolean
         Dim result As Boolean = True
         Dim _MyFormsDefine As Define
         Dim _MyForms As Boolean
 
         _MyFormsDefine = Compiler.CommandLine.Define("_MYFORMS")
         If _MyFormsDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.WindowsFormsWithCustomSubMain, MyTypes.WindowsForms
                     _MyForms = True
                 Case Else
                     _MyForms = False
             End Select
         Else
             _MyForms = CBool(_MyFormsDefine.Value)
         End If
 
         If Not _MyForms Then Return True
 
         Compiler.CommandLine.References.Add("System.Windows.Forms.dll")
 
         Dim code As String = VB.vbNewLine & _
        "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "        <Global.Microsoft.VisualBasic.MyGroupCollection(""System.Windows.Forms.Form"", ""Create__Instance__"", ""Dispose__Instance__"", ""My.MyProject.Forms"")> _" & VB.vbNewLine & _
        "        Friend NotInheritable Class MyForms" & VB.vbNewLine & _
        "            <Global.System.ThreadStatic> _" & VB.vbNewLine & _
        "            Private Shared m_FormBeingCreated As Global.System.Collections.Hashtable" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Public Sub New()" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Shared Function Create__Instance__(Of T As {Global.System.Windows.Forms.Form, New})(ByVal Instance As T) As T" & VB.vbNewLine & _
        "                If Instance IsNot Nothing AndAlso Instance.IsDisposed = False" & VB.vbNewLine & _
        "                    Return Instance" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                Dim TType As Type = GetType(T)" & VB.vbNewLine & _
        "                If m_FormBeingCreated Is Nothing Then" & VB.vbNewLine & _
        "                    m_FormBeingCreated = New Global.System.Collections.Hashtable()" & VB.vbNewLine & _
        "                ElseIf m_FormBeingCreated.ContainsKey(TType) Then" & VB.vbNewLine & _
        "                    Throw New InvalidOperationException(""There is a reference to a default instance from the constructor of a form, which leads to infinite recursion. Please refer to the form itself using 'Me' from within the constructor."")" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                m_FormBeingCreated.Add(TType, Nothing)" & VB.vbNewLine & _
        "                Try" & VB.vbNewLine & _
        "                    Return Global.System.Activator.CreateInstance(Of T)()" & VB.vbNewLine & _
        "                Catch ex As Global.System.Reflection.TargetInvocationException" & VB.vbNewLine & _
        "                    Throw New Global.System.InvalidOperationException(""See inner exception"", ex.InnerException)" & VB.vbNewLine & _
        "                Finally" & VB.vbNewLine & _
        "                    m_FormBeingCreated.Remove(TType)" & VB.vbNewLine & _
        "                End Try" & VB.vbNewLine & _
        "                Return Nothing" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Sub Dispose__Instance__(Of T As Global.System.Windows.Forms.Form)(ByRef instance As T)" & VB.vbNewLine & _
        "                instance.Dispose()" & VB.vbNewLine & _
        "                instance = CType(Nothing, T)" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
        "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
        "             Return MyBase.GetHashCode" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
        "                Return GetType(MyForms)" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
        "                Return MyBase.ToString" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "        End Class" & VB.vbNewLine & _
        ""
         ProjectCode.Append(code)
 
         ProjectCode.AppendLine("        Private Shared m_MyFormsObjectProvider As ThreadSafeObjectProvider(Of MyForms) = New ThreadSafeObjectProvider(Of MyForms)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Forms"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Forms As MyForms")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_MyFormsObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="217" endline="256">
<![CDATA[
 
     Function GenerateMyUser() As Boolean
         Dim result As Boolean = True
         Dim _MyUserDefine As Define
         Dim _MyUser As String
 
         _MyUserDefine = Compiler.CommandLine.Define("_MYUSERTYPE")
         If _MyUserDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms
                     _MyUser = "Windows"
                 Case MyTypes.Web, MyTypes.WebControl
                     _MyUser = "Web"
                 Case Else
                     _MyUser = String.Empty
             End Select
         Else
             _MyUser = _MyUserDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyUser
             Case "Web"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WebUser"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.User"
             Case Else
                 Return True
         End Select
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_UserObjectProvider As ThreadSafeObjectProvider(Of Z) = New ThreadSafeObjectProvider(Of Z)".Replace("Z", baseClass))
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.User"")> _")
         ProjectCode.Append("        Friend Shared ReadOnly Property User As ") 
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_UserObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1676" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="257" endline="354">
<![CDATA[
 
     Function GenerateMyForms() As Boolean
         Dim result As Boolean = True
         Dim _MyFormsDefine As Define
         Dim _MyForms As Boolean
 
         _MyFormsDefine = Compiler.CommandLine.Define("_MYFORMS")
         If _MyFormsDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.WindowsFormsWithCustomSubMain, MyTypes.WindowsForms
                     _MyForms = True
                 Case Else
                     _MyForms = False
             End Select
         Else
             _MyForms = CBool(_MyFormsDefine.Value)
         End If
 
         If Not _MyForms Then Return True
 
         Compiler.CommandLine.References.Add("System.Windows.Forms.dll")
 
         Dim code As String = VB.vbNewLine & _
        "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "        <Global.Microsoft.VisualBasic.MyGroupCollection(""System.Windows.Forms.Form"", ""Create__Instance__"", ""Dispose__Instance__"", ""My.MyProject.Forms"")> _" & VB.vbNewLine & _
        "        Friend NotInheritable Class MyForms" & VB.vbNewLine & _
        "            <Global.System.ThreadStatic> _" & VB.vbNewLine & _
        "            Private Shared m_FormBeingCreated As Global.System.Collections.Hashtable" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Public Sub New()" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Shared Function Create__Instance__(Of T As {Global.System.Windows.Forms.Form, New})(ByVal Instance As T) As T" & VB.vbNewLine & _
        "                If Instance IsNot Nothing AndAlso Instance.IsDisposed = False" & VB.vbNewLine & _
        "                    Return Instance" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                Dim TType As Type = GetType(T)" & VB.vbNewLine & _
        "                If m_FormBeingCreated Is Nothing Then" & VB.vbNewLine & _
        "                    m_FormBeingCreated = New Global.System.Collections.Hashtable()" & VB.vbNewLine & _
        "                ElseIf m_FormBeingCreated.ContainsKey(TType) Then" & VB.vbNewLine & _
        "                    Throw New InvalidOperationException(""There is a reference to a default instance from the constructor of a form, which leads to infinite recursion. Please refer to the form itself using 'Me' from within the constructor."")" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                m_FormBeingCreated.Add(TType, Nothing)" & VB.vbNewLine & _
        "                Try" & VB.vbNewLine & _
        "                    Return Global.System.Activator.CreateInstance(Of T)()" & VB.vbNewLine & _
        "                Catch ex As Global.System.Reflection.TargetInvocationException" & VB.vbNewLine & _
        "                    Throw New Global.System.InvalidOperationException(""See inner exception"", ex.InnerException)" & VB.vbNewLine & _
        "                Finally" & VB.vbNewLine & _
        "                    m_FormBeingCreated.Remove(TType)" & VB.vbNewLine & _
        "                End Try" & VB.vbNewLine & _
        "                Return Nothing" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Sub Dispose__Instance__(Of T As Global.System.Windows.Forms.Form)(ByRef instance As T)" & VB.vbNewLine & _
        "                instance.Dispose()" & VB.vbNewLine & _
        "                instance = CType(Nothing, T)" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
        "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
        "             Return MyBase.GetHashCode" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
        "                Return GetType(MyForms)" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
        "                Return MyBase.ToString" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "        End Class" & VB.vbNewLine & _
        ""
         ProjectCode.Append(code)
 
         ProjectCode.AppendLine("        Private Shared m_MyFormsObjectProvider As ThreadSafeObjectProvider(Of MyForms) = New ThreadSafeObjectProvider(Of MyForms)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Forms"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Forms As MyForms")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_MyFormsObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" startline="508" endline="558">
<![CDATA[
 
     Function GenerateMyComputer() As Boolean
         Dim result As Boolean = True
         Dim _MyComputerDefine As Define
         Dim _MyComputer As String
 
         _MyComputerDefine = Compiler.CommandLine.Define("_MYCOMPUTERTYPE")
         If _MyComputerDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms
                     _MyComputer = "Windows"
                 Case MyTypes.Web, MyTypes.WebControl
                     _MyComputer = "Web"
                 Case Else
                     _MyComputer = String.Empty
             End Select
         Else
             _MyComputer = _MyComputerDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyComputer
             Case "Web"
                 baseClass = "Global.Microsoft.VisualBasic.Devices.ServerComputer"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.Devices.Computer"
             Case Else
                 Return True
         End Select
 
         Code.AppendLine("    <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
         Code.AppendLine("    Friend Class MyComputer")
         Code.Append("        Inherits ") 
         Code.AppendLine("        <Global.System.Diagnostics.DebuggerHidden()> _")
         Code.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("        Public Sub New()")
         Code.AppendLine("        End Sub")
         Code.AppendLine("    End Class")
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_ComputerObjectProvider As ThreadSafeObjectProvider(Of $GLOBALMY$.MyComputer) = New ThreadSafeObjectProvider(Of $GLOBALMY$.MyComputer)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Computer"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Computer As $GLOBALMY$.MyComputer")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_ComputerObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1677" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="95" endline="120">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customAttributeBuilder)
 		{
 			Universe u = moduleBuilder.universe;
 			if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_InAttribute)
 			{
 				flags |= (short)ParameterAttributes.In;
 			}
 			else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_OutAttribute)
 			{
 				flags |= (short)ParameterAttributes.Out;
 			}
 			else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_OptionalAttribute)
 			{
 				flags |= (short)ParameterAttributes.Optional;
 			}
 			else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_MarshalAsAttribute)
 			{
 				MarshalSpec.SetMarshalAsAttribute(moduleBuilder, PseudoToken, customAttributeBuilder);
 				flags |= (short)ParameterAttributes.HasFieldMarshal;
 			}
 			else
 			{
 				moduleBuilder.SetCustomAttribute(PseudoToken, customAttributeBuilder);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1678" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="648" endline="680">
<![CDATA[
 
 		public Type CreateType()
 		{
 			if ((typeFlags & TypeFlags.Baked) != 0)
 			{
 				// .NET allows multiple invocations (subsequent invocations return the same baked type)
 				throw new NotImplementedException();
 			}
 			typeFlags |= TypeFlags.Baked;
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.Bake();
 			}
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.Bake();
 			}
 			if (declarativeSecurity != null)
 			{
 				this.ModuleBuilder.AddDeclarativeSecurity(token, declarativeSecurity);
 			}
 			if (baseType != null)
 			{
 				extends = this.ModuleBuilder.GetTypeToken(baseType).Token;
 			}
 			if (interfaces != null)
 			{
 				foreach (Type interfaceType in interfaces)
 				{
 					InterfaceImplTable.Record rec = new InterfaceImplTable.Record();
 					rec.Class = token;
 					rec.Interface = this.ModuleBuilder.GetTypeToken(interfaceType).Token;
 					this.ModuleBuilder.InterfaceImpl.AddRecord(rec);
 				}
 				foreach (Type interfaceType in interfaces)
 				{
 					InterfaceImplTable.Record rec = new InterfaceImplTable.Record();
 					rec.Class = token;
 					rec.Interface = this.ModuleBuilder.GetTypeToken(interfaceType).Token;
 					this.ModuleBuilder.InterfaceImpl.AddRecord(rec);
 				}
 			}
 			return new BakedType(this);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1679" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="191" endline="220">
<![CDATA[
 
 		internal void Bake()
 		{
 			PropertyTable.Record rec = new PropertyTable.Record();
 			rec.Flags = (short)attributes;
 			rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
 			rec.Type = typeBuilder.ModuleBuilder.GetSignatureBlobIndex(sig);
 			int token = 0x17000000 | typeBuilder.ModuleBuilder.Property.AddRecord(rec);
 
 			if (lazyPseudoToken != 0)
 			{
 				typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
 			}
 
 			if (getter != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Getter, getter.MetadataToken, token);
 			}
 			if (setter != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Setter, setter.MetadataToken, token);
 			}
 			if (otherMethods != null)
 			{
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1680" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="739" endline="765">
<![CDATA[
 
 		public void EmitCall(OpCode opc, MethodInfo method, Type[] optionalParameterTypes)
 		{
 			if (optionalParameterTypes == null || optionalParameterTypes.Length == 0)
 			{
 				Emit(opc, method);
 			}
 			else
 			{
 				Emit(opc);
 				UpdateStack(opc, method.HasThis, method.ReturnType, method.ParameterCount + optionalParameterTypes.Length);
 				ByteBuffer sig = new ByteBuffer(16);
 				method.MethodSignature.WriteMethodRefSig(moduleBuilder, sig, optionalParameterTypes);
 				MemberRefTable.Record record = new MemberRefTable.Record();
 				if (method.Module == moduleBuilder)
 				{
 					record.Class = method.MetadataToken;
 				}
 				else
 				{
 					record.Class = moduleBuilder.GetTypeTokenForMemberRef(method.DeclaringType ?? method.Module.GetModuleType());
 				}
 				record.Name = moduleBuilder.Strings.Add(method.Name);
 				record.Signature = moduleBuilder.Blobs.Add(sig);
 				code.Write(0x0A000000 | moduleBuilder.MemberRef.FindOrAddRecord(record));
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1681" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="161" endline="195">
<![CDATA[
 		}
 
 		internal void Bake()
 		{
 			EventTable.Record rec = new EventTable.Record();
 			rec.EventFlags = (short)attributes;
 			rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
 			rec.EventType = eventtype;
 			int token = 0x14000000 | typeBuilder.ModuleBuilder.Event.AddRecord(rec);
 
 			if (lazyPseudoToken != 0)
 			{
 				typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
 			}
 
 			if (addOnMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.AddOn, addOnMethod.MetadataToken, token);
 			}
 			if (removeOnMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.RemoveOn, removeOnMethod.MetadataToken, token);
 			}
 			if (fireMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Fire, fireMethod.MetadataToken, token);
 			}
 			if (otherMethods != null)
 			{
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1682" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="54" endline="115">
<![CDATA[
 		private PEFileKinds fileKind = PEFileKinds.Dll;
 		private MethodInfo entryPoint;
 		private VersionInfo versionInfo;
 		private ResourceSection unmanagedResources;
 		private string imageRuntimeVersion;
 		internal int mdStreamVersion = 0x20000;
 		private Module pseudoManifestModule;
 		private readonly List<ResourceFile> resourceFiles = new List<ResourceFile>();
 		private readonly List<ModuleBuilder> modules = new List<ModuleBuilder>();
 		private readonly List<Module> addedModules = new List<Module>();
 		private readonly List<CustomAttributeBuilder> customAttributes = new List<CustomAttributeBuilder>();
 		private readonly List<CustomAttributeBuilder> declarativeSecurity = new List<CustomAttributeBuilder>();
 		private readonly List<Type> typeForwarders = new List<Type>();
 
 		private struct ResourceFile
 		{
 			internal string Name;
 			internal string FileName;
 			internal ResourceAttributes Attributes;
 		}
 
 		internal AssemblyBuilder(Universe universe, AssemblyName name, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 			
 		{
 			this.name = name.Name;
 			SetVersionHelper(name.Version);
 			if (name.CultureInfo != null && !string.IsNullOrEmpty(name.CultureInfo.Name))
 			{
 				this.culture = name.CultureInfo.Name;
 			}
 			this.flags = name.Flags;
 			this.hashAlgorithm = name.HashAlgorithm;
 			if (this.hashAlgorithm == AssemblyHashAlgorithm.None)
 			{
 				this.hashAlgorithm = AssemblyHashAlgorithm.SHA1;
 			}
 			this.keyPair = name.KeyPair;
 			if (this.keyPair != null)
 			{
 				this.publicKey = this.keyPair.PublicKey;
 			}
 			else
 			{
 				byte[] publicKey = name.GetPublicKey();
 				if (publicKey != null && publicKey.Length != 0)
 				{
 					this.publicKey = (byte[])publicKey.Clone();
 				}
 			}
 			this.dir = dir ?? ".";
 			this.requiredPermissions = requiredPermissions;
 			this.optionalPermissions = optionalPermissions;
 			this.refusedPermissions = refusedPermissions;
 			if (universe.HasMscorlib && universe.Mscorlib.ImageRuntimeVersion != null)
 			{
 				this.imageRuntimeVersion = universe.Mscorlib.ImageRuntimeVersion;
 			}
 			else
 			{
 				this.imageRuntimeVersion = typeof(object).Assembly.ImageRuntimeVersion;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1683" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="681" endline="706">
<![CDATA[
 
 		internal void PopulatePropertyAndEventTables()
 		{
 			if (properties != null)
 			{
 				PropertyMapTable.Record rec = new PropertyMapTable.Record();
 				rec.Parent = token;
 				rec.PropertyList = this.ModuleBuilder.Property.RowCount + 1;
 				this.ModuleBuilder.PropertyMap.AddRecord(rec);
 				foreach (PropertyBuilder pb in properties)
 				{
 					pb.Bake();
 				}
 				foreach (PropertyBuilder pb in properties)
 				{
 					pb.Bake();
 				}
 			}
 			if (events != null)
 			{
 				EventMapTable.Record rec = new EventMapTable.Record();
 				rec.Parent = token;
 				rec.EventList = this.ModuleBuilder.Event.RowCount + 1;
 				this.ModuleBuilder.EventMap.AddRecord(rec);
 				foreach (EventBuilder eb in events)
 				{
 					eb.Bake();
 				}
 				foreach (EventBuilder eb in events)
 				{
 					eb.Bake();
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1684" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="602" endline="635">
<![CDATA[
 
 		internal int ImportType(Type type)
 		{
 			int token;
 			if (!typeTokens.TryGetValue(type, out token))
 			{
 				if (type.HasElementType || (type.IsGenericType && !type.IsGenericTypeDefinition))
 				{
 					ByteBuffer spec = new ByteBuffer(5);
 					Signature.WriteTypeSpec(this, spec, type);
 					token = 0x1B000000 | this.TypeSpec.AddRecord(this.Blobs.Add(spec));
 				}
 				else
 				{
 					TypeRefTable.Record rec = new TypeRefTable.Record();
 					if (type.IsNested)
 					{
 						rec.ResolutionScope = GetTypeToken(type.DeclaringType).Token;
 						rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 						rec.TypeNameSpace = 0;
 					}
 					else
 					{
 						rec.ResolutionScope = ImportAssemblyRef(type.Assembly);
 						rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 						string ns = type.Namespace;
 						rec.TypeNameSpace = ns == null ? 0 
 					}
 					token = 0x01000000 | this.TypeRef.AddRecord(rec);
 				}
 				typeTokens.Add(type, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1685" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="323" endline="360">
<![CDATA[
 
 		private ExceptionBlock BeginFinallyFilterFaultBlock()
 		{
 			ExceptionBlock block = exceptionStack.Peek();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				Emit(OpCodes.Leave, block.labelEnd);
 			}
 			if (block.handlerOffset == 0)
 			{
 				block.tryLength = code.Position - block.tryOffset;
 			}
 			else
 			{
 				block.handlerLength = code.Position - block.handlerOffset;
 				Label labelEnd;
 				if (exceptionBlockAssistanceMode != EBAM_COMPAT)
 				{
 					labelEnd = block.labelEnd;
 				}
 				else
 				{
 					MarkLabel(block.labelEnd);
 					labelEnd = DefineLabel();
 					Emit(OpCodes.Leave, labelEnd);
 				}
 				exceptionStack.Pop();
 				ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
 				newBlock.labelEnd = labelEnd;
 				newBlock.tryOffset = block.tryOffset;
 				newBlock.tryLength = code.Position - block.tryOffset;
 				block = newBlock;
 				exceptions.Add(block);
 				exceptionStack.Push(block);
 			}
 			stackHeight = 0;
 			return block;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1686" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="255" endline="291">
<![CDATA[
 		}
 
 		public void BeginCatchBlock(Type exceptionType)
 		{
 			ExceptionBlock block = exceptionStack.Peek();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				if (exceptionType == null)
 				{
 					Emit(OpCodes.Endfilter);
 				}
 				else
 				{
 					Emit(OpCodes.Leave, block.labelEnd);
 				}
 			}
 			stackHeight = 0;
 			UpdateStack(1);
 			if (block.tryLength == 0)
 			{
 				block.tryLength = code.Position - block.tryOffset;
 			}
 			else if (exceptionType != null)
 			{
 				block.handlerLength = code.Position - block.handlerOffset;
 				exceptionStack.Pop();
 				ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
 				newBlock.labelEnd = block.labelEnd;
 				newBlock.tryOffset = block.tryOffset;
 				newBlock.tryLength = block.tryLength;
 				block = newBlock;
 				exceptions.Add(block);
 				exceptionStack.Push(block);
 			}
 			block.handlerOffset = code.Position;
 			block.exceptionType = exceptionType;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1687" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="85" endline="111">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.Module.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_FieldOffsetAttribute)
 			{
 				customBuilder = customBuilder.DecodeBlob(this.Module.Assembly);
 				SetOffset((int)customBuilder.GetConstructorArgument(0));
 			}
 			else if (customBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_MarshalAsAttribute)
 			{
 				MarshalSpec.SetMarshalAsAttribute(typeBuilder.ModuleBuilder, pseudoToken, customBuilder);
 				attribs |= FieldAttributes.HasFieldMarshal;
 			}
 			else if (customBuilder.Constructor.DeclaringType == u.System_NonSerializedAttribute)
 			{
 				attribs |= FieldAttributes.NotSerialized;
 			}
 			else if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attribs |= FieldAttributes.SpecialName;
 			}
 			else
 			{
 				typeBuilder.ModuleBuilder.SetCustomAttribute(pseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1688" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="41" endline="114">
<![CDATA[
 		private readonly Guid mvid = Guid.NewGuid();
 		private long imageBaseAddress = 0x00400000;
 		private readonly AssemblyBuilder asm;
 		internal readonly string moduleName;
 		internal readonly string fileName;
 		internal readonly ISymbolWriterImpl symbolWriter;
 		private readonly TypeBuilder moduleType;
 		private readonly List<TypeBuilder> types = new List<TypeBuilder>();
 		private readonly Dictionary<Type, int> typeTokens = new Dictionary<Type, int>();
 		private readonly Dictionary<Type, int> memberRefTypeTokens = new Dictionary<Type, int>();
 		private readonly Dictionary<string, TypeBuilder> fullNameToType = new Dictionary<string, TypeBuilder>();
 		internal readonly ByteBuffer methodBodies = new ByteBuffer(128 * 1024);
 		internal readonly List<int> tokenFixupOffsets = new List<int>();
 		internal readonly ByteBuffer initializedData = new ByteBuffer(512);
 		internal readonly ByteBuffer manifestResources = new ByteBuffer(512);
 		internal ResourceSection unmanagedResources;
 		private readonly Dictionary<MemberInfo, int> importedMembers = new Dictionary<MemberInfo, int>();
 		private readonly Dictionary<MemberRefKey, int> importedMemberRefs = new Dictionary<MemberRefKey, int>();
 		private readonly Dictionary<Assembly, int> referencedAssemblies = new Dictionary<Assembly, int>();
 		private List<AssemblyName> referencedAssemblyNames;
 		private int nextPseudoToken = -1;
 		private readonly List<int> resolvedTokens = new List<int>();
 		internal readonly TableHeap Tables = new TableHeap();
 		internal readonly StringHeap Strings = new StringHeap();
 		internal readonly UserStringHeap UserStrings = new UserStringHeap();
 		internal readonly GuidHeap Guids = new GuidHeap();
 		internal readonly BlobHeap Blobs = new BlobHeap();
 
 		struct MemberRefKey 
 		{
 			private readonly Type type;
 			private readonly string name;
 			private readonly Signature signature;
 
 			internal MemberRefKey(Type type, string name, Signature signature)
 			{
 				this.type = type;
 				this.name = name;
 				this.signature = signature;
 			}
 
 			public bool Equals(MemberRefKey other)
 			{
 				return other.type.Equals(type)
 					&& other.name == name
 					&& other.signature.Equals(signature);
 			}
 
 			public override bool Equals(object obj)
 			{
 				MemberRefKey? other = obj as MemberRefKey?;
 				return other != null && Equals(other);
 			}
 
 			public override int GetHashCode()
 			{
 				return type.GetHashCode() + name.GetHashCode() + signature.GetHashCode();
 			}
 		}
 
 		internal ModuleBuilder(AssemblyBuilder asm, string moduleName, string fileName, bool emitSymbolInfo)
 			
 		{
 			this.asm = asm;
 			this.moduleName = moduleName;
 			this.fileName = fileName;
 			if (emitSymbolInfo)
 			{
 				symbolWriter = SymbolSupport.CreateSymbolWriterFor(this);
 			}
 			// <Module> must be the first record in the TypeDef table
 			moduleType = new TypeBuilder(this, "<Module>", null, 0);
 			types.Add(moduleType);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1689" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="202" endline="245">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			Label false_target = ec.DefineLabel ();
 			Label end;
 
 			//
 			// If we're a boolean constant, Resolve() already
 			// eliminated dead code for us.
 			//
 			Constant c = expr as Constant;
 			if (c != null){
 				c.EmitSideEffect (ec);
 
 				if (!c.IsDefaultValue)
 					TrueStatement.Emit (ec);
 				else if (FalseStatement != null)
 					FalseStatement.Emit (ec);
 
 				return;
 			}			
 			
 			expr.EmitBranchable (ec, false_target, false);
 			
 			TrueStatement.Emit (ec);
 
 			if (FalseStatement != null){
 				bool branch_emitted = false;
 				
 				end = ec.DefineLabel ();
 				if (!is_true_ret){
 					ec.Emit (OpCodes.Br, end);
 					branch_emitted = true;
 				}
 
 				ec.MarkLabel (false_target);
 				FalseStatement.Emit (ec);
 
 				if (branch_emitted)
 					ec.MarkLabel (end);
 			} else {
 				ec.MarkLabel (false_target);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="894" endline="939">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				if (IsExplicitImpl) {
 					Error_ConditionalAttributeIsNotValid ();
 					return;
 				}
 
 				if ((ModFlags & Modifiers.OVERRIDE) != 0) {
 					Report.Error (243, Location, "Conditional not valid on `{0}' because it is an override method", GetSignatureForError ());
 					return;
 				}
 
 				if (ReturnType != TypeManager.void_type) {
 					Report.Error (578, Location, "Conditional not valid on `{0}' because its return type is not void", GetSignatureForError ());
 					return;
 				}
 
 				if (IsInterface) {
 					Report.Error (582, Location, "Conditional not valid on interface members");
 					return;
 				}
 
 				if (MethodData.implementing != null) {
 					Report.SymbolRelatedToPreviousError (MethodData.implementing.DeclaringType);
 					Report.Error (629, Location, "Conditional member `{0}' cannot implement interface member `{1}'",
 						GetSignatureForError (), TypeManager.CSharpSignature (MethodData.implementing));
 					return;
 				}
 
 				for (int i = 0; i < parameters.Count; ++i) {
 					if (parameters.FixedParameters [i].ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (685, Location, "Conditional method `{0}' cannot have an out parameter", GetSignatureForError ());
 						return;
 					}
 				}
 				for (int i = 0; i < parameters.Count; ++i) {
 					if (parameters.FixedParameters [i].ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (685, Location, "Conditional method `{0}' cannot have an out parameter", GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1690" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="202" endline="245">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			Label false_target = ec.DefineLabel ();
 			Label end;
 
 			//
 			// If we're a boolean constant, Resolve() already
 			// eliminated dead code for us.
 			//
 			Constant c = expr as Constant;
 			if (c != null){
 				c.EmitSideEffect (ec);
 
 				if (!c.IsDefaultValue)
 					TrueStatement.Emit (ec);
 				else if (FalseStatement != null)
 					FalseStatement.Emit (ec);
 
 				return;
 			}			
 			
 			expr.EmitBranchable (ec, false_target, false);
 			
 			TrueStatement.Emit (ec);
 
 			if (FalseStatement != null){
 				bool branch_emitted = false;
 				
 				end = ec.DefineLabel ();
 				if (!is_true_ret){
 					ec.Emit (OpCodes.Br, end);
 					branch_emitted = true;
 				}
 
 				ec.MarkLabel (false_target);
 				FalseStatement.Emit (ec);
 
 				if (branch_emitted)
 					ec.MarkLabel (end);
 			} else {
 				ec.MarkLabel (false_target);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="114" endline="156">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.FieldOffset) {
 				status |= Status.HAS_OFFSET;
 
 				if (!Parent.PartialContainer.HasExplicitLayout) {
 					Report.Error (636, Location, "The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)");
 					return;
 				}
 
 				if ((ModFlags & Modifiers.STATIC) != 0 || this is Const) {
 					Report.Error (637, Location, "The FieldOffset attribute is not allowed on static or const fields");
 					return;
 				}
 			}
 
 			if (a.Type == pa.FixedBuffer) {
 				Report.Error (1716, Location, "Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead");
 				return;
 			}
 
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					FieldBuilder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1691" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" startline="58" endline="104">
<![CDATA[
     End Property
 
     Function ResolveGroup(ByVal SourceParameters As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim destinationParameterTypes()() As Mono.Cecil.TypeReference
         Dim destinationParameters() As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim sourceParameterTypes() As Mono.Cecil.TypeReference
 
         ReDim destinationParameterTypes(m_Members.Count - 1)
         ReDim destinationParameters(m_Members.Count - 1)
         For i As Integer = 0 To m_Members.Count - 1
             destinationParameters(i) = m_Members(i).Parameters
             destinationParameterTypes(i) = Helper.GetTypes(destinationParameters(i))
         Next
 
         sourceParameterTypes = SourceParameters.ToTypes
 
         Dim resolvedGroup As New Generic.List(Of Mono.Cecil.MemberReference)
         Dim inputGroup As New Generic.List(Of Mono.Cecil.MemberReference)(m_Members.Count)
         For i As Integer = 0 To m_Members.Count - 1
             inputGroup.Add(DirectCast(m_Members(i), PropertyReference))
         Next
 
         If m_Resolver Is Nothing Then m_Resolver = New MethodResolver(Parent)
         m_Resolver.ShowErrors = False
         m_Resolver.Init(inputGroup, SourceParameters, Nothing)
         result = m_Resolver.Resolve AndAlso result
 
         If result Then
             If m_Resolver.IsLateBound = False Then
                 m_FinalSourceArguments = New ArgumentList(Me.Parent, m_Resolver.ResolvedCandidate.ExactArguments)
                 resolvedGroup.Add(m_Resolver.ResolvedMember)
             End If
         End If
 
         'result = Helper.ResolveGroup(Me.Parent, inputGroup, resolvedGroup, SourceParameters, Nothing, Nothing, False)
 
         If result Then
             m_ResolvedProperty = TryCast(resolvedGroup(0), Mono.Cecil.PropertyReference)
             result = m_ResolvedProperty IsNot Nothing AndAlso result
         End If
 
         m_Parameters = SourceParameters
         m_Resolved = True
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1692" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1433" endline="1467">
<![CDATA[
 
     Shared Function GetTypeOrTypeReference(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         If Type Is Nothing Then Return Nothing
         If TypeOf Type Is Mono.Cecil.GenericParameter Then Return Type
 
         If Compiler.Assembly.IsDefinedHere(Type) Then
             Return Type
         ElseIf TypeOf Type Is ByReferenceType Then
             Dim refType As ByReferenceType = DirectCast(Type, ByReferenceType)
             Dim elementType As Mono.Cecil.TypeReference
             elementType = GetTypeOrTypeReference(Compiler, refType.ElementType)
             If elementType Is refType.ElementType Then Return Type
             Return New ByReferenceType(elementType)
         ElseIf TypeOf Type Is Mono.Cecil.ArrayType Then
             Dim arrType As Mono.Cecil.ArrayType = DirectCast(Type, Mono.Cecil.ArrayType)
             Dim elementType As Mono.Cecil.TypeReference
             elementType = GetTypeOrTypeReference(Compiler, arrType.ElementType)
             If elementType Is arrType.ElementType Then Return Type
             Dim result As Mono.Cecil.ArrayType = New Mono.Cecil.ArrayType(elementType, arrType.Rank)
             For i As Integer = 0 To arrType.Rank - 1
                 result.Dimensions(i) = arrType.Dimensions(i)
             Next
             Return result
         ElseIf TypeOf Type Is Mono.Cecil.GenericInstanceType Then
             Dim git As Mono.Cecil.GenericInstanceType = DirectCast(Type, Mono.Cecil.GenericInstanceType)
             Dim elementType As Mono.Cecil.TypeReference = GetTypeOrTypeReference(Compiler, git.ElementType)
             Dim result As New Mono.Cecil.GenericInstanceType(elementType)
             For i As Integer = 0 To git.GenericArguments.Count - 1
                 result.GenericArguments.Add(GetTypeOrTypeReference(Compiler, git.GenericArguments(i)))
             Next
             Return result
         Else
             Return Compiler.AssemblyBuilderCecil.MainModule.Import(CecilHelper.FindDefinition(Type))
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1693" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="2929" endline="2960">
<![CDATA[
 
     Shared Function CompareMethod(ByVal m1 As Mono.Cecil.MethodReference, ByVal m2 As Mono.Cecil.MethodReference) As Boolean
         Dim g1 As Mono.Cecil.GenericInstanceMethod
         Dim g2 As Mono.Cecil.GenericInstanceMethod
 
         If m1 Is Nothing AndAlso m2 Is Nothing Then Return True
         If m1 Is Nothing Xor m2 Is Nothing Then Return False
 
         If m1 Is m2 Then Return True
         If Helper.CompareNameOrdinal(m1.Name, m2.Name) = False Then Return False
         If m1.Parameters.Count <> m2.Parameters.Count Then Return False
         If m1.GenericParameters.Count <> m2.GenericParameters.Count Then Return False
         If Helper.Compare(m1.DeclaringType, m2.DeclaringType) = False Then Return False
 
         For i As Integer = 0 To m1.Parameters.Count - 1
             If Helper.CompareType(m1.Parameters(i).ParameterType, m2.Parameters(i).ParameterType) = False Then Return False
         Next
 
         g1 = TryCast(m1, Mono.Cecil.GenericInstanceMethod)
         g2 = TryCast(m2, Mono.Cecil.GenericInstanceMethod)
 
         If g1 IsNot Nothing AndAlso g2 IsNot Nothing Then
             If g1.GenericArguments.Count <> g2.GenericArguments.Count Then Return False
             For i As Integer = 0 To g1.GenericArguments.Count - 1
                 If Helper.CompareType(g1.GenericArguments(i), g2.GenericArguments(i)) = False Then Return False
             Next
         ElseIf g1 IsNot Nothing Xor g2 IsNot Nothing Then
             Return False
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1694" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="158" endline="194">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As Mono.Cecil.TypeDefinition, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.GenericInstanceType = Nothing
         Dim args As New Generic.List(Of Mono.Cecil.TypeReference)
         Dim any_change As Boolean
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
 
         If genericType Is Nothing Then Return Member
 
         result = New Mono.Cecil.GenericInstanceType(Member)
         result.DeclaringType = FindDefinition(Type)
 
         Dim tGI As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         If Member.DeclaringType IsNot Nothing AndAlso tGI IsNot Nothing AndAlso Helper.CompareType(Member.DeclaringType, tGI.ElementType) Then
             'Nested generic type
             For i As Integer = 0 To tGI.GenericArguments.Count - 1
                 result.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, tGI.GenericArguments(i)))
             Next
             Return result
         End If
 
         For i As Integer = 0 To Member.GenericParameters.Count - 1
             Dim found As Boolean = False
             For j As Integer = 0 To genericType.ElementType.GenericParameters.Count - 1
                 If genericType.ElementType.GenericParameters(j).Name = Member.GenericParameters(i).Name Then
                     result.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, genericType.GenericArguments(j)))
                     found = True
                     any_change = True
                     Exit For
                 End If
             Next
 
             If Not found Then Throw New NotImplementedException
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1695" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="271" endline="358">
<![CDATA[
 
     Public Shared Function InflateType(ByVal original As TypeReference, ByVal container As TypeReference) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
         Dim originalDef As TypeDefinition = TryCast(original, TypeDefinition)
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim genericCollection As GenericInstanceType = TryCast(container, GenericInstanceType)
         Dim containerDef As TypeDefinition
 
         If genericCollection Is Nothing Then
             Return original
             Throw New ArgumentException("The type to inflate with isn't generic.")
         End If
 
         If originalDef IsNot Nothing Then
             If originalDef.GenericParameters.Count = 0 Then Return original
             Dim result As New GenericInstanceType(originalDef)
             For i As Integer = 0 To originalDef.GenericParameters.Count - 1
                 Dim tG As GenericParameter = originalDef.GenericParameters(i)
                 If tG.Owner Is originalDef Then
                     result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), container))
                 Else
                     result.GenericArguments.Add(originalDef.GenericParameters(i))
                 End If
             Next
             Return result
         End If
 
         containerDef = CecilHelper.FindDefinition(container)
 
         If containerDef IsNot Nothing Then
             parameters = containerDef.GenericParameters
         Else
             parameters = genericCollection.ElementType.GenericParameters
         End If
         arguments = genericCollection.GenericArguments
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         Dim genParam As GenericParameter = TryCast(original, GenericParameter)
         If genParam IsNot Nothing Then
             If Not TypeOf genParam.Owner Is TypeReference Then Return genParam
             Helper.Assert(genParam.Position < arguments.Count)
             Return arguments.Item(genParam.Position)
         End If
 
         If genericType IsNot Nothing Then
             Dim result As New GenericInstanceType(genericType.ElementType)
             'originalDef = CecilHelper.FindDefinition(original)
             'For i As Integer = 0 To originalDef.GenericParameters.Count - 1
             '    For j As Integer = 0 To parameters.Count - 1
             '        If parameters(j) Is originalDef.GenericParameters(i) Then
             '            result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), container))
             '            Exit For
             '        End If
             '    Next
             'Next
             For i As Integer = 0 To genericType.GenericArguments.Count - 1
                 result.GenericArguments.Add(InflateType(genericType.GenericArguments(i), container))
             Next
             'Helper.Assert(result.GenericArguments.Count = parameters.Count)
             Return result
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = InflateType(spec.ElementType, container)
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf reference IsNot Nothing Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         Else
             Return original
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1696" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="982" endline="1045">
<![CDATA[
 
     Public Shared Function GetInterfaces(ByVal Type As Mono.Cecil.TypeReference, ByVal checkBase As Boolean) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         Dim result As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tmp As Mono.Cecil.TypeReference
         Dim tD As Mono.Cecil.TypeDefinition
         Dim tG As Mono.Cecil.GenericParameter = TryCast(Type, Mono.Cecil.GenericParameter)
 
         If tG IsNot Nothing Then
             If tG.Constraints.Count = 0 Then Return Nothing
             result = New Mono.Collections.Generic.Collection(Of TypeReference)
             For i As Integer = 0 To tG.Constraints.Count - 1
                 For Each t As TypeReference In GetInterfaces(tG.Constraints(i), checkBase)
                     result.Add(t)
                 Next
             Next
             Return result
         End If
 
         Dim arrD As Mono.Cecil.ArrayType = TryCast(Type, Mono.Cecil.ArrayType)
         If arrD IsNot Nothing Then
             result = New Mono.Collections.Generic.Collection(Of TypeReference)
             For Each tp As TypeReference In GetInterfaces(BaseObject.m_Compiler.TypeCache.System_Array, False)
                 result.Add(tp)
             Next
             For Each tp As TypeDefinition In New TypeDefinition() {BaseObject.m_Compiler.TypeCache.System_Collections_Generic_ICollection1, BaseObject.m_Compiler.TypeCache.System_Collections_Generic_IEnumerable1, BaseObject.m_Compiler.TypeCache.System_Collections_Generic_IList1}
                 Dim newTP As New GenericInstanceType(tp)
                 newTP.GenericArguments.Add(arrD.ElementType)
                 result.Add(newTP)
             Next
             Return result
         End If
 
         tD = FindDefinition(Type)
 
         result = New Mono.Collections.Generic.Collection(Of TypeReference)
         For i As Integer = 0 To tD.Interfaces.Count - 1
             result.Add(InflateType(tD.Interfaces(i), Type))
         Next
 
         If genericType IsNot Nothing Then
             For i As Integer = 0 To result.Count - 1
                 tmp = CecilHelper.ResolveType(result(i), CecilHelper.FindDefinition(genericType).GenericParameters, genericType.GenericArguments)
                 result.Item(i) = tmp
             Next
         End If
 
         If checkBase Then
             Dim bT As Mono.Cecil.TypeReference
 
             bT = tD.BaseType
             If bT IsNot Nothing Then
                 If genericType IsNot Nothing Then
                     bT = CecilHelper.GetCorrectMember(bT, genericType)
                 End If
 
                 For Each t As Mono.Cecil.TypeReference In GetInterfaces(bT, checkBase)
                     result.Add(t)
                 Next
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1697" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="197" endline="233">
<![CDATA[
 
     Public Sub UpdateDefinition()
         Dim Parent As MethodBaseDeclaration = FindFirstParent(Of MethodBaseDeclaration)()
         Dim Builder As Mono.Cecil.MethodDefinition = Nothing
 
         If Parent IsNot Nothing Then
             Builder = Parent.CecilBuilder
         Else
             'Helper.StopIfDebugging()
         End If
 
         If m_ParameterBuilderCecil Is Nothing Then
             m_ParameterBuilderCecil = New Mono.Cecil.ParameterDefinition(Nothing)
             m_ParameterBuilderCecil.Sequence = -1
             m_ParameterBuilderCecil.Annotations.Add(Compiler, Me)
         End If
 
         m_ParameterBuilderCecil.Name = Name
         m_ParameterBuilderCecil.IsOptional = Modifiers.Is(ModifierMasks.Optional)
 
         If Builder IsNot Nothing AndAlso m_ParameterBuilderCecil.Sequence = -1 Then
             Builder.Parameters.Add(m_ParameterBuilderCecil)
         End If
 
         If Me.Modifiers.Is(ModifierMasks.ParamArray) AndAlso m_ParamArrayAttribute Is Nothing Then
             m_ParamArrayAttribute = New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_ParamArrayAttribute__ctor))
             m_ParameterBuilderCecil.CustomAttributes.Add(m_ParamArrayAttribute)
         End If
 
         If m_ParameterBuilderCecil.IsOptional Then
             'm_ParameterBuilderCecil.Constant = TypeConverter.ConvertTo(Compiler, m_ConstantValue, ParameterType)
             m_ParameterBuilderCecil.HasDefault = True
         End If
         If m_ParameterBuilderCecil.ParameterType Is Nothing Then
             m_ParameterBuilderCecil.ParameterType = Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void)
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1698" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1270" endline="1339">
<![CDATA[
 
 
     ''' <summary>
     ''' Returns true if the type has a default property
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function HasDefaultProperty(ByVal Context As BaseObject, ByVal tp As Mono.Cecil.TypeReference, ByRef properties As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim defaultName As String = Nothing
 
         If tp Is Nothing Then Return False
 
         If properties Is Nothing Then properties = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)
         members = Compiler.TypeManager.GetCache(tp).GetAllMembers()
 
         For i As Integer = 0 To members.Count - 1
             Dim p As Mono.Cecil.PropertyReference = TryCast(members(i), Mono.Cecil.PropertyReference)
             Dim pD As PropertyDeclaration
 
             If p Is Nothing Then Continue For
 
             If p.Annotations.Contains(Compiler) Then
                 pD = DirectCast(p.Annotations(Compiler), PropertyDeclaration)
                 If pD.Modifiers.Is(ModifierMasks.Default) Then
                     AddPropertyUnlessSignatureMatches(properties, p)
                 End If
                 Continue For
             End If
 
             Dim p2 As Mono.Cecil.PropertyReference = CecilHelper.FindDefinition(p)
             If p2.Annotations.Contains(Compiler) Then
                 pD = DirectCast(p2.Annotations(Compiler), PropertyDeclaration)
                 If pD.Modifiers.Is(ModifierMasks.Default) Then
                     AddPropertyUnlessSignatureMatches(properties, p)
                 End If
                 Continue For
             End If
 
             'OPTIMIZATION
             Dim pDef As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(p.DeclaringType)
             Dim defaultAttribute As Mono.Cecil.CustomAttribute = Helper.GetDefaultMemberAttribute(Compiler, pDef)
             If defaultAttribute Is Nothing Then Continue For
             If defaultAttribute.ConstructorArguments.Count <> 1 Then Continue For
             If TypeOf defaultAttribute.ConstructorArguments(0).Value Is String = False Then Continue For
             defaultName = DirectCast(defaultAttribute.ConstructorArguments(0).Value, String)
 
             If Helper.CompareNameOrdinal(p.Name, defaultName) Then
                 AddPropertyUnlessSignatureMatches(properties, p)
             End If
         Next
 
         If Helper.CompareType(Compiler.TypeCache.System_Object, tp) = False Then
             If CecilHelper.IsInterface(tp) Then
                 Dim interfaces As Mono.Collections.Generic.Collection(Of TypeReference) = CecilHelper.GetInterfaces(tp, False)
                 Dim result As Boolean
                 If interfaces IsNot Nothing Then
                     For i As Integer = 0 To interfaces.Count - 1
                         result = HasDefaultProperty(Context, interfaces(i), properties) OrElse result
                     Next
                 End If
                 Return properties.Count > 0
             Else
                 Return HasDefaultProperty(Context, CecilHelper.GetBaseType(tp), properties)
             End If
         End If
 
         Return properties.Count > 0
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1699" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="532" endline="574">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodDefinition, ByVal Arguments As Mono.Collections.Generic.Collection(Of TypeReference), Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter) = Member.GenericParameters
         Dim returnType As Mono.Cecil.TypeReference
         Dim reflectableMember As Mono.Cecil.MethodReference
 
         If Member.GenericParameters.Count = 0 Then Return Member
 
         returnType = CecilHelper.ResolveType(Member.ReturnType, parameters, Arguments)
         returnType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, returnType)
         result = New Mono.Cecil.MethodReference(Member.Name, Member.DeclaringType, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember = New Mono.Cecil.MethodReference(Member.Name, Member.DeclaringType, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember.OriginalMethod = Member
         result.OriginalMethod = Member
 
         For i As Integer = 0 To Member.GenericParameters.Count - 1
             result.GenericParameters.Add(Member.GenericParameters(i))
             reflectableMember.GenericParameters.Add(Member.GenericParameters(i))
         Next
 
         For i As Integer = 0 To Member.Parameters.Count - 1
             Dim pD As Mono.Cecil.ParameterDefinition = Member.Parameters(i)
             Dim pDType As Mono.Cecil.TypeReference
             pDType = InflateType(pD.ParameterType, parameters, Arguments)
             If pDType IsNot pD.ParameterType Then
                 Dim newPD As Mono.Cecil.ParameterDefinition
                 Dim pd2 As Mono.Cecil.TypeReference
                 pDType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pDType)
                 newPD = New ParameterDefinition(pD.Name, pD.Attributes, pDType)
                 result.Parameters.Add(newPD)
                 pd2 = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pD.ParameterType)
                 reflectableMember.Parameters.Add(New ParameterDefinition(pD.Name, pD.Attributes, pd2))
             Else
                 result.Parameters.Add(pD)
                 reflectableMember.Parameters.Add(pD)
             End If
         Next
 
         result.Annotations.Add("MemberInReflection", reflectableMember)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1700" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="575" endline="647">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodDefinition, ByVal Type As Mono.Cecil.TypeReference, Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
         Dim genericArguments As Mono.Collections.Generic.Collection(Of TypeReference) = Nothing
         Dim genericParameters As Mono.Collections.Generic.Collection(Of GenericParameter) = Nothing
         Dim returnType As Mono.Cecil.TypeReference
         Dim reflectableMember As Mono.Cecil.MethodReference
         Dim declType As TypeReference = Nothing
 
         GetGenericArgsAndParams(Type, genericParameters, genericArguments)
 
         'If genericType Is Nothing Then
         '    Dim declType As TypeReference = Type
         '    While declType.IsNested
         '        Dim genType As GenericInstanceType = TryCast(declType, Mono.Cecil.GenericInstanceType)
         '        If genType IsNot Nothing Then
         '            If genericArguments Is Nothing Then genericArguments = New GenericArgumentCollection(Nothing)
         '            For Each arg As TypeReference In genType.GenericArguments
         '                genericArguments.Add(arg)
         '            Next
         '        End If
         '    End While
         '    Return Member
         'Else
         '    genericArguments = genericType.GenericArguments
         '    genericParameters = tD.GenericParameters
         'End If
 
         If genericParameters Is Nothing AndAlso genericArguments Is Nothing AndAlso tD Is Type AndAlso tD.Module Is Compiler.CurrentCompiler.ModuleBuilderCecil Then
             Return Member
         End If
 
         If Emittable Then
             returnType = Member.ReturnType
         Else
             returnType = CecilHelper.InflateType(Member.ReturnType, genericParameters, genericArguments)
         End If
         result = New Mono.Cecil.MethodReference(Member.Name, Type, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember = New Mono.Cecil.MethodReference(Member.Name, Type, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember.OriginalMethod = Member
         result.OriginalMethod = Member
 
         'If Member.DeclaringType.GenericParameters.Count > 0 AndAlso Not False Then
         '    Dim tmp As New GenericInstanceType(Member.DeclaringType)
         '    For i As Integer = 0 To Member.DeclaringType.GenericParameters.Count - 1
         '        tmp.GenericArguments.Add(Member.DeclaringType.GenericParameters(i))
         '    Next
         '    result.DeclaringType = tmp
         'End If
 
         For i As Integer = 0 To Member.Parameters.Count - 1
             Dim pD As Mono.Cecil.ParameterDefinition = Member.Parameters(i)
             Dim pDType As Mono.Cecil.TypeReference
             pDType = InflateType(pD.ParameterType, genericParameters, genericArguments)
             If pDType IsNot pD.ParameterType Then
                 Dim newPD As Mono.Cecil.ParameterDefinition
                 Dim pd2 As Mono.Cecil.TypeReference
                 pDType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pDType)
                 newPD = New ParameterDefinition(pD.Name, pD.Attributes, pDType)
                 result.Parameters.Add(newPD)
                 pd2 = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pD.ParameterType)
                 reflectableMember.Parameters.Add(New ParameterDefinition(pD.Name, pD.Attributes, pd2))
             Else
                 result.Parameters.Add(pD)
                 reflectableMember.Parameters.Add(pD)
             End If
         Next
 
         result.Annotations.Add("MemberInReflection", reflectableMember)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1701" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="359" endline="427">
<![CDATA[
 
     Public Shared Function InflateType(ByVal original As TypeReference, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference)) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
         Dim originalDef As TypeDefinition = TryCast(original, TypeDefinition)
 
         If parameters Is Nothing AndAlso arguments Is Nothing Then Return original
 
         If originalDef IsNot Nothing Then
             If originalDef.GenericParameters.Count = 0 Then Return original
             Dim result As New GenericInstanceType(originalDef)
             For i As Integer = 0 To originalDef.GenericParameters.Count - 1
                 Dim tG As GenericParameter = originalDef.GenericParameters(i)
                 If tG.Owner Is originalDef Then
                     result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), parameters, arguments))
                 Else
                     result.GenericArguments.Add(originalDef.GenericParameters(i))
                 End If
             Next
             Return result
         End If
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         Dim genParam As GenericParameter = TryCast(original, GenericParameter)
         If genParam IsNot Nothing Then
             If Not TypeOf genParam.Owner Is TypeReference Then
                 For i As Integer = 0 To parameters.Count - 1
                     If parameters(i).Owner Is genParam.Owner AndAlso parameters(i).Position = genParam.Position Then
                         Return arguments(i)
                     End If
                 Next
                 Return genParam
             End If
             Helper.Assert(genParam.Position < arguments.Count)
             Return arguments.Item(genParam.Position)
         End If
 
         If genericType IsNot Nothing Then
             Dim result As New GenericInstanceType(CecilHelper.FindDefinition(genericType.ElementType))
             For i As Integer = 0 To result.ElementType.GenericParameters.Count - 1
                 result.GenericArguments.Add(InflateType(genericType.GenericArguments(i), parameters, arguments))
             Next
             Return result
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = InflateType(spec.ElementType, parameters, arguments)
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf reference IsNot Nothing Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         Else
             Return original
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1702" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="648" endline="723">
<![CDATA[
 
     Public Shared Function MakeEmittable(ByVal Method As MethodReference) As MethodReference
         Dim result As MethodReference
         Dim genM As GenericInstanceMethod = TryCast(Method, GenericInstanceMethod)
         Dim tG As GenericInstanceType = TryCast(Method.DeclaringType, GenericInstanceType)
 
         If genM Is Nothing AndAlso tG Is Nothing Then
             If Method.DeclaringType.GenericParameters.Count > 0 Then
                 tG = New GenericInstanceType(Method.DeclaringType)
                 For i As Integer = 0 To Method.DeclaringType.GenericParameters.Count - 1
                     tG.GenericArguments.Add(Method.DeclaringType.GenericParameters(i))
                 Next
 
                 Dim mR As New Mono.Cecil.MethodReference(Method.Name, tG, Method.ReturnType, Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
                 For i As Integer = 0 To Method.Parameters.Count - 1
                     Dim param As Mono.Cecil.ParameterDefinition
                     param = New Mono.Cecil.ParameterDefinition(Method.Parameters(i).ParameterType)
                     mR.Parameters.Add(param)
                 Next
                 Return mR
             End If
         End If
 
         Dim mD As MethodDefinition = FindDefinition(Method)
 
         If mD Is Nothing Then
             If TypeOf Method.DeclaringType Is ArrayType Then
                 Dim arrayType As TypeReference
                 arrayType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType)
                 result = New MethodReference(Method.Name, Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType), Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.ReturnType), Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
                 For i As Integer = 0 To Method.Parameters.Count - 1
                     Dim pType As Mono.Cecil.TypeReference
                     pType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.Parameters(i).ParameterType)
                     If pType Is Method.Parameters(i).ParameterType Then
                         result.Parameters.Add(Method.Parameters(i))
                     Else
                         result.Parameters.Add(New ParameterDefinition(pType))
                     End If
                 Next
                 Return result
             End If
             Helper.Assert(mD IsNot Nothing)
             Return Nothing
         End If
 
         If mD Is Method AndAlso mD.DeclaringType.Module Is Compiler.CurrentCompiler.ModuleBuilderCecil Then
             Return mD
         End If
 
         If genM IsNot Nothing Then
             Dim gimResult As New GenericInstanceMethod(Helper.GetMethodOrMethodReference(BaseObject.m_Compiler, mD))
             gimResult.OriginalMethod = mD
             gimResult.ReturnType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, mD.ReturnType)
             For i As Integer = 0 To genM.GenericArguments.Count - 1
                 gimResult.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, genM.GenericArguments(i)))
             Next
             Return gimResult
         End If
 
         result = New MethodReference(Method.Name, Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType), Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, mD.ReturnType), Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
         For i As Integer = 0 To mD.Parameters.Count - 1
             Dim pType As Mono.Cecil.TypeReference
             pType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, mD.Parameters(i).ParameterType)
             If pType Is mD.Parameters(i).ParameterType Then
                 result.Parameters.Add(mD.Parameters(i))
             Else
                 result.Parameters.Add(New ParameterDefinition(pType))
             End If
         Next
         If mD.GenericParameters IsNot Nothing AndAlso mD.GenericParameters.Count > 0 Then
             For i As Integer = 0 To mD.GenericParameters.Count - 1
                 result.GenericParameters.Add(mD.GenericParameters(i))
             Next
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1703" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="300" endline="325">
<![CDATA[
 
     Private Function Compile_CreateAssemblyAndModuleBuilders() As Boolean
         Dim kind As Mono.Cecil.ModuleKind
         Select Case CommandLine.Target
             Case vbnc.CommandLine.Targets.Console
                 kind = Mono.Cecil.ModuleKind.Console
             Case vbnc.CommandLine.Targets.Library
                 kind = Mono.Cecil.ModuleKind.Dll
             Case vbnc.CommandLine.Targets.Module
                 Report.ShowMessage(Messages.VBNC99999, Span.CommandLineSpan, "Compiling modules (-target
                 kind = Mono.Cecil.ModuleKind.NetModule
             Case vbnc.CommandLine.Targets.Winexe
                 kind = Mono.Cecil.ModuleKind.Windows
             Case Else
                 kind = Mono.Cecil.ModuleKind.Console
         End Select
 
         Dim an As AssemblyNameDefinition = New AssemblyNameDefinition("dummy", New Version())
         AssemblyBuilderCecil = AssemblyDefinition.CreateAssembly(an, IO.Path.GetFileNameWithoutExtension(OutFileName), kind)
         ModuleBuilderCecil = AssemblyBuilderCecil.MainModule
         ModuleBuilderCecil.Name = IO.Path.GetFileName(OutFileName)
         ModuleBuilderCecil.Runtime = TypeManager.Corlib.MainModule.Runtime
         ModuleBuilderCecil.AssemblyResolver = AssemblyResolver
         If CommandLine.Verbose Then Report.WriteLine(String.Format("Using runtime version
         Return Compiler.Report.Errors = 0
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1704" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="226" endline="270">
<![CDATA[
 
     Public Shared Sub GetGenericArgsAndParams(ByVal Type As TypeReference, ByRef GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByRef GenericArguments As Mono.Collections.Generic.Collection(Of TypeReference))
         Dim declType As TypeReference = Nothing
         Dim genericType As GenericInstanceType
         Dim genericTypeDefinition As TypeDefinition
         Dim cloned As Boolean
 
         Do
             If declType Is Nothing Then
                 declType = Type
             Else
                 declType = declType.DeclaringType
             End If
 
             genericType = TryCast(declType, Mono.Cecil.GenericInstanceType)
 
             If genericType IsNot Nothing Then
                 genericTypeDefinition = CecilHelper.FindDefinition(genericType)
 
                 Helper.Assert(genericType.GenericArguments.Count = genericTypeDefinition.GenericParameters.Count)
 
                 If GenericArguments Is Nothing Then
                     GenericArguments = genericType.GenericArguments
                     GenericParameters = genericTypeDefinition.GenericParameters
                 Else
                     If cloned = False Then
                         Dim tmp1 As New Mono.Collections.Generic.Collection(Of TypeReference)
                         Dim tmp2 As New Mono.Collections.Generic.Collection(Of GenericParameter)
                         For i As Integer = 0 To GenericArguments.Count - 1
                             tmp1.Add(GenericArguments(i))
                             tmp2.Add(GenericParameters(i))
                         Next
                         GenericArguments = tmp1
                         GenericParameters = tmp2
                         cloned = True
                     End If
 
                     For i As Integer = 0 To genericType.GenericArguments.Count - 1
                         GenericArguments.Insert(i, genericType.GenericArguments(i))
                         GenericParameters.Insert(i, genericTypeDefinition.GenericParameters(i))
                     Next
                 End If
             End If
         Loop While declType.IsNested
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1705" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="41" endline="94">
<![CDATA[
 
     Function DefineImplements(ByVal Declaration As EventDeclaration) As Boolean
         Dim result As Boolean = True
         Dim declType As Mono.Cecil.TypeDefinition
 
         Helper.Assert(Declaration IsNot Nothing)
 
         declType = Declaration.DeclaringType.CecilType
 
         For i As Integer = 0 To m_ImplementsList.Count - 1
             Dim ispec As InterfaceMemberSpecifier = m_ImplementsList(i)
             Dim eventI As Mono.Cecil.EventDefinition
 
             eventI = CecilHelper.FindDefinition(ispec.ResolvedEventInfo)
 
             Helper.Assert(eventI IsNot Nothing)
 
             Dim addMethodI, removeMethodI As Mono.Cecil.MethodReference
             Dim addMethod, removeMethod As Mono.Cecil.MethodReference
             Dim raiseMethod As Mono.Cecil.MethodReference = Nothing
             Dim raiseMethodI As Mono.Cecil.MethodReference = Nothing
 
             addMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.AddMethod)
             removeMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.RemoveMethod)
             If eventI.InvokeMethod IsNot Nothing Then
                 raiseMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.InvokeMethod)
             End If
 
             addMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.AddDefinition)
             removeMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.RemoveDefinition)
             If Declaration.RaiseDefinition IsNot Nothing Then
                 raiseMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.RaiseDefinition)
             End If
 
             Helper.Assert((addMethodI Is Nothing Xor addMethod Is Nothing) = False)
             Helper.Assert((removeMethodI Is Nothing Xor removeMethod Is Nothing) = False)
             Helper.Assert((raiseMethodI Is Nothing Xor raiseMethod Is Nothing) = False)
 
             If addMethod IsNot Nothing AndAlso addMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(addMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(addMethodI))
             End If
             If removeMethod IsNot Nothing AndAlso removeMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(removeMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(removeMethodI))
             End If
             If raiseMethod IsNot Nothing AndAlso raiseMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(raiseMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(raiseMethodI))
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1706" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="428" endline="479">
<![CDATA[
 
     Public Shared Function ResolveType(ByVal original As TypeReference, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference)) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = ResolveType(spec.ElementType, parameters, arguments)
 
             If genericType IsNot Nothing Then
                 Dim result As GenericInstanceType = New GenericInstanceType(genericType.ElementType)
                 For i As Integer = 0 To genericType.GenericArguments.Count - 1
                     Dim tg As Mono.Cecil.TypeReference = ResolveType(genericType.GenericArguments(i), parameters, arguments)
                     result.GenericArguments.Add(tg)
                 Next
                 Return result
             End If
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf (reference IsNot Nothing) Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         End If
 
         For i As Integer = 0 To parameters.Count - 1
             If parameters(i) Is original Then
                 Return arguments(i)
             End If
         Next
 
         If original.IsNested Then
             Dim parentType As TypeReference = InflateType(original.DeclaringType, parameters, arguments)
             If parentType IsNot original Then
                 Return Compiler.CurrentCompiler.ModuleBuilderCecil.Import(FindDefinition(original))
             End If
         End If
 
         Return original
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1707" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="69" endline="124">
<![CDATA[
 
     Public Shared Function GetMembers(ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of MemberReference)
         Dim tD As Mono.Cecil.TypeDefinition
         Dim result As Mono.Collections.Generic.Collection(Of MemberReference)
 
         Dim tG As Mono.Cecil.GenericParameter = TryCast(Type, GenericParameter)
         If tG IsNot Nothing Then Return GetMembers(tG)
 
         Dim arr As Mono.Cecil.ArrayType = TryCast(Type, ArrayType)
         If arr IsNot Nothing Then
             result = New Mono.Collections.Generic.Collection(Of MemberReference)()
             For Each member As MemberReference In GetMembers(BaseObject.m_Compiler.TypeCache.System_Array)
                 'result.Add(GetCorrectMember(member, Type))
                 result.Add(member)
             Next
             Return result
         End If
 
         tD = FindDefinition(Type)
 
         result = New Mono.Collections.Generic.Collection(Of MemberReference)(tD.Events.Count + tD.Methods.Count + tD.Properties.Count + tD.NestedTypes.Count + tD.Fields.Count)
 
         For i As Integer = 0 To tD.Events.Count - 1
             Dim item As EventDefinition = tD.Events(i)
             'I don't think events need to call GetCorrectMember
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.Methods.Count - 1
             Dim item As MethodReference = tD.Methods(i)
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(item, Type)
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.Properties.Count - 1
             Dim pd As PropertyDefinition = tD.Properties(i)
             Dim item As PropertyReference = pd
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(pd, Type)
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.NestedTypes.Count - 1
             Dim item As TypeReference = tD.NestedTypes(i)
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(item, Type)
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.Fields.Count - 1
             Dim fd As FieldDefinition = tD.Fields(i)
             Dim item As FieldReference = fd
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(fd, Type)
             result.Add(item)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1708" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="677" endline="705">
<![CDATA[
 
     ''' <summary>
     ''' Checks if the member is Friend (not Protected Friend)
     ''' </summary>
     ''' <param name="Member"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetAccessibility(ByVal Member As Mono.Cecil.MemberReference) As ModifierMasks
         Helper.Assert(Member IsNot Nothing)
         If TypeOf Member Is Mono.Cecil.MethodReference Then
             Return GetVisibility(CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).Attributes)
         ElseIf TypeOf Member Is Mono.Cecil.TypeReference Then
             Return GetVisibility(CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.TypeReference)).Attributes)
         ElseIf TypeOf Member Is Mono.Cecil.EventReference Then
             Dim eD As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference))
             If eD.AddMethod IsNot Nothing Then Return GetVisibility(eD.AddMethod.Attributes)
             If eD.RemoveMethod IsNot Nothing Then Return GetVisibility(eD.RemoveMethod.Attributes)
             If eD.InvokeMethod IsNot Nothing Then Return GetVisibility(eD.InvokeMethod.Attributes)
             Return 0
         ElseIf TypeOf Member Is Mono.Cecil.FieldReference Then
             Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.FieldReference))
             Return GetVisibility(fD.Attributes)
         ElseIf TypeOf Member Is Mono.Cecil.PropertyReference Then
             Dim pD As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
             Return GetVisibility(GetPropertyAccess(pD))
         Else
             Throw New NotImplementedException
         End If
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1709" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="341" endline="369">
<![CDATA[
 
     Private Sub CreateDefaultCtorCallCecil()
         Dim type As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim classtype As ClassDeclaration = TryCast(type, ClassDeclaration)
         Dim defaultctor As Mono.Cecil.MethodReference
         If classtype IsNot Nothing Then
             defaultctor = classtype.GetBaseDefaultConstructorCecil()
             If defaultctor IsNot Nothing AndAlso Helper.IsPrivate(defaultctor) = False Then
                 If Helper.IsPrivate(defaultctor) OrElse (Helper.IsFamilyOrAssembly(defaultctor) AndAlso defaultctor.DeclaringType.Module.Assembly IsNot Me.Compiler.AssemblyBuilderCecil) Then
                     Helper.AddError(Compiler, Location, "Base class does not have an accessible default constructor")
                 Else
                     m_DefaultBaseConstructorCecil = defaultctor
                     m_DefaultBaseConstructorCecil = Helper.GetMethodOrMethodReference(Compiler, m_DefaultBaseConstructorCecil)
 
 #If DEBUG Then
                     Try
                         For Each param As Mono.Cecil.ParameterDefinition In m_DefaultBaseConstructor.Parameters
                             Helper.Assert(param.IsOptional)
                         Next
                     Catch ex As Exception
                         Helper.Assert(False)
                     End Try
 #End If
                 End If
             Else
                 Helper.AddError(Compiler, Location, "Base class does not have a default constructor")
             End If
         End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1710" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" startline="228" endline="252">
<![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         If m_ConstantValue IsNot Nothing AndAlso m_ConstantValue IsNot DBNull.Value Then
             If Helper.CompareType(CecilHelper.GetType(Compiler, m_ConstantValue), Compiler.TypeCache.System_Decimal) Then
                 Dim value As Decimal = DirectCast(m_ConstantValue, Decimal)
                 Dim ctor As MethodDefinition = Compiler.TypeCache.System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_UInt32_UInt32_UInt32
                 Dim attrib As New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, ctor))
                 Dim params As Object() = New Emitter.DecimalFields(value).AsByte_Byte_UInt32_UInt32_UInt32()
                 For i As Integer = 0 To params.Length - 1
                     attrib.ConstructorArguments.Add(New CustomAttributeArgument(ctor.Parameters(i).ParameterType, params(i)))
                 Next
                 m_FieldBuilderCecil.CustomAttributes.Add(attrib)
             ElseIf Helper.CompareType(CecilHelper.GetType(Compiler, m_ConstantValue), Compiler.TypeCache.System_DateTime) Then
                 Dim attrib As New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor_Int64))
                 attrib.ConstructorArguments.Add(New CustomAttributeArgument(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int64), DirectCast(m_ConstantValue, Date).Ticks))
                 m_FieldBuilderCecil.CustomAttributes.Add(attrib)
             End If
         End If
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1711" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1375" endline="1396">
<![CDATA[
 
     Shared Function IsShared(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean = True
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).IsStatic
             Case MemberTypes.Property
                 Dim pInfo As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
                 Return CBool(Helper.GetPropertyAttributes(pInfo) And Mono.Cecil.MethodAttributes.Static)
             Case MemberTypes.Field
                 Dim fInfo As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.FieldReference))
                 Return fInfo.IsStatic
             Case MemberTypes.TypeInfo
                 Return False
             Case MemberTypes.NestedType
                 Return False
             Case MemberTypes.Event
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference)).AddMethod.IsStatic
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1712" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" startline="1173" endline="1202">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal type As TypeReference) As TypeDefinition
         If type Is Nothing Then Return Nothing
         Dim tD As TypeDefinition = TryCast(type, TypeDefinition)
         If tD IsNot Nothing Then Return tD
         type = type.GetElementType
         If TypeOf type Is TypeDefinition Then
             Return DirectCast(type, TypeDefinition)
         End If
         Dim reference As AssemblyNameReference = TryCast(type.Scope, AssemblyNameReference)
         If reference IsNot Nothing Then
             Dim assembly As AssemblyDefinition = FindDefinition(reference)
             If type.IsNested Then
                 Return assembly.MainModule.GetType(type.FullName)
             Else
                 Return assembly.MainModule.GetType(type.Namespace, type.Name)
             End If
         End If
         Dim moduledef As ModuleDefinition = TryCast(type.Scope, ModuleDefinition)
         If moduledef IsNot Nothing Then
             Dim fn As String
             If type.IsNested Then
                 fn = FindDefinition(type.DeclaringType).FullName + "/" + type.Name
                 Return moduledef.GetType(fn)
             Else
                 Return moduledef.GetType(type.Namespace, type.Name)
             End If
         End If
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1713" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1504" endline="1563">
<![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenType As Mono.Cecil.TypeReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Nothing
 
         If OpenType Is Nothing Then Return Nothing
 
         Helper.Assert(TypeParameters IsNot Nothing AndAlso TypeArguments IsNot Nothing)
         Helper.Assert(TypeParameters.Count = TypeArguments.Count)
 
         If CecilHelper.IsGenericParameter(OpenType) Then
             For i As Integer = 0 To TypeParameters.Count - 1
                 If Helper.CompareName(TypeParameters(i).Name, OpenType.Name) Then
                     result = TypeArguments(i)
                     Exit For
                 End If
             Next
             Helper.Assert(result IsNot Nothing)
         ElseIf CecilHelper.IsGenericType(OpenType) Then
             Dim typeParams As Mono.Collections.Generic.Collection(Of TypeReference)
             Dim typeArgs As New Mono.Collections.Generic.Collection(Of TypeReference)(Nothing)
 
             typeParams = CecilHelper.GetGenericArguments(OpenType)
 
             For i As Integer = 0 To typeParams.Count - 1
                 For j As Integer = 0 To TypeParameters.Count - 1
                     If Helper.CompareName(typeParams(i).Name, TypeParameters(j).Name) Then
                         typeArgs.Add(TypeArguments(j))
                         Exit For
                     End If
                 Next
                 If typeArgs.Count - 1 < i Then typeArgs.Add(typeParams(i))
             Next
 
             Helper.Assert(typeArgs.Count = typeParams.Count AndAlso typeArgs.Count > 0)
 
             result = Parent.Compiler.TypeManager.MakeGenericType(Parent, OpenType, typeArgs)
         ElseIf CecilHelper.IsGenericTypeDefinition(OpenType) Then
             Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         ElseIf CecilHelper.ContainsGenericParameters(OpenType) Then
             If CecilHelper.IsArray(OpenType) Then
                 Dim elementType As Mono.Cecil.TypeReference
                 elementType = CecilHelper.GetElementType(OpenType)
                 elementType = ApplyTypeArguments(Parent, elementType, TypeParameters, TypeArguments)
                 result = New Mono.Cecil.ArrayType(elementType, CecilHelper.GetArrayRank(OpenType))
             ElseIf CecilHelper.IsByRef(OpenType) Then
                 Dim elementType As Mono.Cecil.TypeReference
                 elementType = CecilHelper.GetElementType(OpenType)
                 elementType = ApplyTypeArguments(Parent, elementType, TypeParameters, TypeArguments)
                 result = Parent.Compiler.TypeManager.MakeByRefType(Parent, elementType)
             Else
                 Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         Else
             result = OpenType
         End If
 
         Helper.Assert(result IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1714" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="95" endline="140">
<![CDATA[
 
     Function DefineImplements(ByVal Method As Mono.Cecil.MethodDefinition) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Method IsNot Nothing)
 
         For i As Integer = 0 To m_ImplementsList.Count - 1
             Dim ispec As InterfaceMemberSpecifier = Me.m_ImplementsList(i)
             Dim methodI As Mono.Cecil.MethodReference = Nothing
             Dim propertyI As Mono.Cecil.PropertyReference = Nothing
             Dim propertyDef As Mono.Cecil.PropertyDefinition = Nothing
 
             If ispec.ResolvedMethodInfo IsNot Nothing Then
                 methodI = Helper.GetMethodOrMethodReference(Compiler, ispec.ResolvedMethodInfo)
             End If
 
             If ispec.ResolvedPropertyInfo IsNot Nothing Then
                 propertyI = Helper.GetPropertyOrPropertyBuilder(Compiler, ispec.ResolvedPropertyInfo)
                 propertyDef = CecilHelper.FindDefinition(propertyI)
             End If
 
             Helper.Assert(propertyI Is Nothing Xor methodI Is Nothing)
 
             If propertyI IsNot Nothing Then
                 'This is a property
                 If Method.Name.StartsWith("get_") Then
                     methodI = CecilHelper.GetCorrectMember(propertyDef.GetMethod, propertyI.DeclaringType)
                 ElseIf Method.Name.StartsWith("set_") Then
                     methodI = CecilHelper.GetCorrectMember(propertyDef.SetMethod, propertyI.DeclaringType)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                 End If
                 methodI = Helper.GetMethodOrMethodReference(Compiler, methodI)
             End If
 
 
             Helper.Assert(methodI IsNot Nothing)
 
             Method.Overrides.Add(CecilHelper.MakeEmittable(methodI))
 
 #If EXTENDEDDEBUG Then
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Defined method override '" & Builder.FullName & "
 #End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1715" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" startline="115" endline="141">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="90" endline="118">
<![CDATA[
 
     Overloads Function ResolveTypeReferences(ByVal AsAttributeTypeName As Boolean) As Boolean
         Dim result As Boolean = True
         If IsBuiltInTypeName Then
             'Not necessary.'result = AsBuiltInTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = AsBuiltInTypeName.ResolvedType
         ElseIf IsQualifiedIdentifier Then
             Dim tpParam As Mono.Cecil.GenericParameter
             result = AsQualifiedIdentifier.ResolveAsTypeName(AsAttributeTypeName) AndAlso result
             If result = False Then Return result
             m_ResolvedType = AsQualifiedIdentifier.ResolvedType
             tpParam = TryCast(m_ResolvedType, Mono.Cecil.GenericParameter)
             If tpParam IsNot Nothing Then
                 m_TypeParameter = DirectCast(tpParam.Annotations(Compiler), TypeParameter)
             End If
             If result = False Then Return result
             If Not TypeOf m_ResolvedType Is Mono.Cecil.GenericInstanceType AndAlso m_ResolvedType.GenericParameters.Count > 0 Then
                 Dim tmp As New Mono.Cecil.GenericInstanceType(m_ResolvedType)
                 For i As Integer = 0 To m_ResolvedType.GenericParameters.Count - 1
                     tmp.GenericArguments.Add(m_ResolvedType.GenericParameters(i))
                 Next
                 m_ResolvedType = tmp
             End If
         Else
             Throw New InternalException(Me)
         End If
         Return result
 
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1716" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="57" endline="75">
<![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If IsStatic Then
             If m_FieldBuilderStaticInit Is Nothing AndAlso HasInitializer Then
                 Dim staticName As String
                 Dim attr As Mono.Cecil.FieldAttributes = Mono.Cecil.FieldAttributes.Private
 
                 staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name & "$Init"
                 If DeclaringMethod.IsShared Then attr = attr Or Mono.Cecil.FieldAttributes.Static
 
                 m_FieldBuilderStaticInit = New Mono.Cecil.FieldDefinition(staticName, attr, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag))
                 DeclaringType.CecilType.Fields.Add(m_FieldBuilderStaticInit)
             End If
         Else
             'TODO
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" startline="450" endline="475">
<![CDATA[
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference 'Descriptor
         Get
             Dim result As Mono.Cecil.TypeReference
             If m_ExpressionType IsNot Nothing Then
                 result = m_ExpressionType
             ElseIf m_Method IsNot Nothing Then
                 result = m_Method.Signature.ReturnType
             ElseIf m_Variable IsNot Nothing Then
                 result = m_Variable.VariableType
             ElseIf m_FieldInfo IsNot Nothing Then
                 If Helper.IsEnum(Compiler, m_FieldInfo.DeclaringType) Then
                     result = m_FieldInfo.DeclaringType
                 Else
                     result = m_FieldInfo.FieldType
                 End If
             ElseIf m_Parameter IsNot Nothing Then
                 result = m_Parameter.ParameterType
             ElseIf m_ArrayVariable IsNot Nothing Then
                 result = CecilHelper.GetElementType(m_ArrayVariable.ExpressionType)
             Else
                 Throw New InternalException(Me)
             End If
             Helper.Assert(result IsNot Nothing)
             Return result
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1717" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="779" endline="809">
<![CDATA[
 
 		public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
 		{
 			List<PropertyInfo> list = new List<PropertyInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="479" endline="509">
<![CDATA[
 
 		public EventInfo[] GetEvents(BindingFlags bindingAttr)
 		{
 			List<EventInfo> list = new List<EventInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1718" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3042" endline="3076">
<![CDATA[
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="327" endline="349">
<![CDATA[
 
 		public void Error_TypeArgumentsCannotBeUsed (Report report, Location loc, MemberSpec member, int arity)
 		{
 			// Better message for possible generic expressions
 			if (member != null && (member.Kind & MemberKind.GenericMask) != 0) {
 				report.SymbolRelatedToPreviousError (member);
 				if (member is TypeSpec)
 					member = ((TypeSpec) member).GetDefinition ();
 				else
 					member = ((MethodSpec) member).GetGenericMethodDefinition ();
 
 				string name = member.Kind == MemberKind.Method ? "method" 
 				if (member.IsGeneric) {
 					report.Error (305, loc, "Using the generic {0} `{1}' requires `{2}' type argument(s)",
 						name, member.GetSignatureForError (), member.Arity.ToString ());
 				} else {
 					report.Error (308, loc, "The non-generic {0} `{1}' cannot be used with the type arguments",
 						name, member.GetSignatureForError ());
 				}
 			} else {
 				Error_TypeArgumentsCannotBeUsed (report, ExprClassName, GetSignatureForError (), loc);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1719" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3042" endline="3076">
<![CDATA[
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="904" endline="953">
<![CDATA[
 
 		//
 		// Identity type conversion
 		//
 		// Default reference comparison, it has to be used when comparing
 		// two possible dynamic/internal types
 		//
 		public static bool IsEqual (TypeSpec a, TypeSpec b)
 		{
 			if (a == b) {
 				// This also rejects dynamic == dynamic
 				return a.Kind != MemberKind.InternalCompilerType || a == InternalType.Dynamic;
 			}
 
 			//
 			// object and dynamic are considered equivalent there is an identity conversion
 			// between object and dynamic, and between constructed types that are the same
 			// when replacing all occurences of dynamic with object.
 			//
 			if (a == InternalType.Dynamic || b == InternalType.Dynamic)
 				return b == TypeManager.object_type || a == TypeManager.object_type;
 
 			if (a == null)
 				return false;
 
 			if (a.IsArray) {
 				var a_a = (ArrayContainer) a;
 				var b_a = b as ArrayContainer;
 				if (b_a == null)
 					return false;
 
 				return IsEqual (a_a.Element, b_a.Element) && a_a.Rank == b_a.Rank;
 			}
 
 			if (!a.IsGeneric || b == null || !b.IsGeneric)
 				return false;
 
 			if (a.MemberDefinition != b.MemberDefinition)
 				return false;
 
 			do {
 				if (!Equals (a.TypeArguments, b.TypeArguments))
 					return false;
 
 				a = a.DeclaringType;
 				b = b.DeclaringType;
 			} while (a != null);
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1720" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3042" endline="3076">
<![CDATA[
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="822" endline="876">
<![CDATA[
 
 		void SetEntryPoint ()
 		{
 			if (!RootContext.NeedsEntryPoint) {
 				if (RootContext.MainClass != null)
 					Report.Error (2017, "Cannot specify -main if building a module or library");
 
 				return;
 			}
 
 			PEFileKinds file_kind;
 
 			switch (RootContext.Target) {
 			case Target.Library
 			case Target.Module
 				file_kind = PEFileKinds.Dll;
 				break;
 			case Target.WinExe
 				file_kind = PEFileKinds.WindowApplication;
 				break;
 			default
 				file_kind = PEFileKinds.ConsoleApplication;
 				break;
 			}
 
 			if (entry_point == null) {
 				if (RootContext.MainClass != null) {
 					// TODO
 					DeclSpace main_cont = module.GetDefinition (RootContext.MainClass) as DeclSpace;
 					if (main_cont == null) {
 						Report.Error (1555, "Could not find `{0}' specified for Main method", RootContext.MainClass);
 						return;
 					}
 
 					if (!(main_cont is ClassOrStruct)) {
 						Report.Error (1556, "`{0}' specified for Main method must be a valid class or struct", RootContext.MainClass);
 						return;
 					}
 
 					Report.Error (1558, main_cont.Location, "`{0}' does not have a suitable static Main method", main_cont.GetSignatureForError ());
 					return;
 				}
 
 				if (Report.Errors == 0) {
 					string pname = file_name == null ? name 
 
 					Report.Error (5001, "Program `{0}' does not contain a static `Main' method suitable for an entry point",
 						pname);
 				}
 
 				return;
 			}
 
 			Builder.SetEntryPoint (entry_point.MethodBuilder, file_kind);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1721" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3042" endline="3076">
<![CDATA[
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="120" endline="155">
<![CDATA[
 
 		#region IEquatable<MemberSpec> Members
 
 		public bool Equals (MemberSpec other)
 		{
 			// Is the member of the correct type ?
 			// TODO
 			if ((other.Kind & Kind & MemberKind.MaskType) == 0)
 				return false;
 
 			// Check arity when not disabled
 			if (arity >= 0 && arity != other.Arity)
 				return false;
 
 			if (Parameters != null) {
 				if (other is IParametersMember) {
 					var other_param = ((IParametersMember) other).Parameters;
 					if (!TypeSpecComparer.Override.IsEqual (Parameters, other_param))
 						return false;
 				} else {
 					return false;
 				}
 			}
 
 			if (MemberType != null) {
 				if (other is IInterfaceMemberSpec) {
 					var other_type = ((IInterfaceMemberSpec) other).MemberType;
 					if (!TypeSpecComparer.Override.IsEqual (other_type, MemberType))
 						return false;
 				} else {
 					return false;
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1722" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3042" endline="3076">
<![CDATA[
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="720" endline="779">
<![CDATA[
 		}
 		#endregion
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			if (Expr == null) {
 				if (ec.ReturnType == TypeManager.void_type)
 					return true;
 
 				if (ec.CurrentIterator != null) {
 					Error_ReturnFromIterator (ec);
 				} else {
 					ec.Report.Error (126, loc,
 						"An object of a type convertible to `{0}' is required for the return statement",
 						ec.ReturnType.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			Expr = Expr.Resolve (ec);
 
 			AnonymousExpression am = ec.CurrentAnonymousMethod;
 			if (am == null) {
 				if (ec.ReturnType == TypeManager.void_type) {
 					ec.Report.Error (127, loc,
 						"`{0}'
 						ec.GetSignatureForError ());
 				}
 			} else {
 				if (am.IsIterator) {
 					Error_ReturnFromIterator (ec);
 					return false;
 				}
 
 				var l = am as AnonymousMethodBody;
 				if (l != null && l.ReturnTypeInference != null && Expr != null) {
 					l.ReturnTypeInference.AddCommonTypeBound (Expr.Type);
 					return true;
 				}
 			}
 
 			if (Expr == null)
 				return false;
 
 			if (Expr.Type != ec.ReturnType) {
 				Expr = Convert.ImplicitConversionRequired (ec, Expr, ec.ReturnType, loc);
 
 				if (Expr == null) {
 					if (am != null) {
 						ec.Report.Error (1662, loc,
 							"Cannot convert `{0}' to delegate type `{1}' because some of the return types in the block are not implicitly convertible to the delegate return type",
 							am.ContainerType, am.GetSignatureForError ());
 					}
 					return false;
 				}
 			}
 
 			return true;			
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1723" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3042" endline="3076">
<![CDATA[
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4403" endline="4452">
<![CDATA[
 
 		void ReportArgumentMismatch (ResolveContext ec, int idx, MemberSpec method,
 													Argument a, AParametersCollection expected_par, TypeSpec paramType)
 		{
 			if (custom_errors != null && custom_errors.ArgumentMismatch (ec, method, a, idx))
 				return;
 
 			if (a is CollectionElementInitializer.ElementInitializerArgument) {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				if ((expected_par.FixedParameters[idx].ModFlags & Parameter.Modifier.ISBYREF) != 0) {
 					ec.Report.Error (1954, loc, "The best overloaded collection initalizer method `{0}' cannot have 'ref', or `out' modifier",
 						TypeManager.CSharpSignature (method));
 					return;
 				}
 				ec.Report.Error (1950, loc, "The best overloaded collection initalizer method `{0}' has some invalid arguments",
 					  TypeManager.CSharpSignature (method));
 			} else if (IsDelegateInvoke) {
 				ec.Report.Error (1594, loc, "Delegate `{0}' has some invalid arguments",
 					DelegateType.GetSignatureForError ());
 			} else {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				ec.Report.Error (1502, loc, "The best overloaded method match for `{0}' has some invalid arguments",
 					method.GetSignatureForError ());
 			}
 
 			Parameter.Modifier mod = idx >= expected_par.Count ? 0 
 
 			string index = (idx + 1).ToString ();
 			if (((mod & (Parameter.Modifier.REF | Parameter.Modifier.OUT)) ^
 				(a.Modifier & (Parameter.Modifier.REF | Parameter.Modifier.OUT))) != 0) {
 				if ((mod & Parameter.Modifier.ISBYREF) == 0)
 					ec.Report.Error (1615, loc, "Argument `#{0}' does not require `{1}' modifier. Consider removing `{1}' modifier",
 						index, Parameter.GetModifierSignature (a.Modifier));
 				else
 					ec.Report.Error (1620, loc, "Argument `#{0}' is missing `{1}' modifier",
 						index, Parameter.GetModifierSignature (mod));
 			} else {
 				string p1 = a.GetSignatureForError ();
 				string p2 = TypeManager.CSharpName (paramType);
 
 				if (p1 == p2) {
 					ec.Report.ExtraInformation (loc, "(equally named types possibly from different assemblies in previous ");
 					ec.Report.SymbolRelatedToPreviousError (a.Expr.Type);
 					ec.Report.SymbolRelatedToPreviousError (paramType);
 				}
 
 				ec.Report.Error (1503, loc,
 					"Argument `#{0}' cannot convert `{1}' expression to type `{2}'", index, p1, p2);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1724" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\VariableExpression.vb" startline="35" endline="58">
<![CDATA[
 
     Shared Function Emit(ByVal Info As EmitInfo, ByVal LocalBuilder As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             Emitter.EmitLoadVariable(Info, LocalBuilder)
         Else
             Dim rInfo As EmitInfo = Info.Clone(Info.Context, True, False, LocalBuilder.VariableType)
 
             Helper.Assert(Info.RHSExpression IsNot Nothing, "RHSExpression Is Nothing!")
             Helper.Assert(Info.RHSExpression.Classification.IsValueClassification OrElse Info.RHSExpression.Classification.CanBeValueClassification)
             result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
 
             Emitter.EmitConversion(Info.RHSExpression.ExpressionType, LocalBuilder.VariableType, Info)
 
             If Helper.CompareType(LocalBuilder.VariableType, Info.Compiler.TypeCache.System_Object) AndAlso Helper.CompareType(Info.RHSExpression.ExpressionType, Info.Compiler.TypeCache.System_Object) Then
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
             End If
 
             Emitter.EmitStoreVariable(Info, LocalBuilder)
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" startline="47" endline="78">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Loads the method pointer onto the evalation stack.
     ''' Creates a new delegate of the specified type.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ResolvedMethod IsNot Nothing)
         Helper.Assert(m_DelegateType IsNot Nothing)
 
         If m_MethodGroup.InstanceExpression IsNot Nothing Then
             result = m_MethodGroup.InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, m_MethodGroup.InstanceExpression.ExpressionType)) AndAlso result
             Emitter.EmitDup(Info)
         Else
             Emitter.EmitLoadNull(Info.Clone(Parent, True, False, Compiler.TypeCache.System_Object))
         End If
 
         Emitter.EmitLoadVftn(Info, m_ResolvedMethod)
 
         Dim ctor As Mono.Cecil.MethodReference
         Dim dT As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(m_DelegateType)
         ctor = CecilHelper.FindConstructor(dT.Methods, False, New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Object, Compiler.TypeCache.System_IntPtr})
         ctor = CecilHelper.GetCorrectMember(ctor, m_DelegateType)
         Emitter.EmitNew(Info, ctor)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1725" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Field.cs" startline="80" endline="112">
<![CDATA[
 
 		public override void __GetDataFromRVA(byte[] data, int offset, int length)
 		{
 			int rid = index + 1;
 			// TODO binary search?
 			for (int i = 0; i < module.FieldRVA.records.Length; i++)
 			{
 				if (module.FieldRVA.records[i].Field == rid)
 				{
 					int rva = module.FieldRVA.records[i].RVA;
 					if (rva == 0)
 					{
 						// C++ assemblies can have fields that have an RVA that is zero
 						Array.Clear(data, offset, length);
 						return;
 					}
 					module.SeekRVA(rva);
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					return;
 				}
 			}
 			for (int i = 0; i < module.FieldRVA.records.Length; i++)
 			{
 				if (module.FieldRVA.records[i].Field == rid)
 				{
 					int rva = module.FieldRVA.records[i].RVA;
 					if (rva == 0)
 					{
 						// C++ assemblies can have fields that have an RVA that is zero
 						Array.Clear(data, offset, length);
 						return;
 					}
 					module.SeekRVA(rva);
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					return;
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="654" endline="701">
<![CDATA[
 
 		private sealed class GenericContext 
 		{
 			private readonly Type[] genericTypeArguments;
 			private readonly Type[] genericMethodArguments;
 
 			internal GenericContext(Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				this.genericTypeArguments = genericTypeArguments;
 				this.genericMethodArguments = genericMethodArguments;
 			}
 
 			public Type GetGenericTypeArgument(int index)
 			{
 				return genericTypeArguments[index];
 			}
 
 			public Type GetGenericMethodArgument(int index)
 			{
 				return genericMethodArguments[index];
 			}
 		}
 
 		public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if ((metadataToken >> 24) == MethodDefTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				return GetMethodAt(null, index);
 			}
 			else if ((metadataToken >> 24) == MemberRefTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				MethodBase method = GetMemberRef(index, genericTypeArguments, genericMethodArguments) as MethodBase;
 				if (method != null)
 				{
 					return method;
 				}
 			}
 			else if ((metadataToken >> 24) == MethodSpecTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				MethodInfo method = (MethodInfo)ResolveMethod(MethodSpec.records[index].Method, genericTypeArguments, genericMethodArguments);
 				ByteReader instantiation = ByteReader.FromBlob(blobHeap, MethodSpec.records[index].Instantiation);
 				return method.MakeGenericMethod(Signature.ReadMethodSpec(this, instantiation, new GenericContext(genericTypeArguments, genericMethodArguments)));
 			}
 			throw new ArgumentOutOfRangeException();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1726" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Field.cs" startline="80" endline="112">
<![CDATA[
 
 		public override void __GetDataFromRVA(byte[] data, int offset, int length)
 		{
 			int rid = index + 1;
 			// TODO binary search?
 			for (int i = 0; i < module.FieldRVA.records.Length; i++)
 			{
 				if (module.FieldRVA.records[i].Field == rid)
 				{
 					int rva = module.FieldRVA.records[i].RVA;
 					if (rva == 0)
 					{
 						// C++ assemblies can have fields that have an RVA that is zero
 						Array.Clear(data, offset, length);
 						return;
 					}
 					module.SeekRVA(rva);
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					return;
 				}
 			}
 			for (int i = 0; i < module.FieldRVA.records.Length; i++)
 			{
 				if (module.FieldRVA.records[i].Field == rid)
 				{
 					int rva = module.FieldRVA.records[i].RVA;
 					if (rva == 0)
 					{
 						// C++ assemblies can have fields that have an RVA that is zero
 						Array.Clear(data, offset, length);
 						return;
 					}
 					module.SeekRVA(rva);
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					return;
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="240" endline="270">
<![CDATA[
 
 		private void PopulateTypeDef()
 		{
 			if (typeDefs == null)
 			{
 				typeDefs = new TypeDefImpl[TypeDef.records.Length];
 				for (int i = 0; i < typeDefs.Length; i++)
 				{
 					TypeDefImpl type = new TypeDefImpl(this, i);
 					typeDefs[i] = type;
 					if (type.IsModulePseudoType)
 					{
 						moduleType = type;
 					}
 					else
 					{
 						types.Add(type.FullName, type);
 					}
 				}
 				for (int i = 0; i < typeDefs.Length; i++)
 				{
 					TypeDefImpl type = new TypeDefImpl(this, i);
 					typeDefs[i] = type;
 					if (type.IsModulePseudoType)
 					{
 						moduleType = type;
 					}
 					else
 					{
 						types.Add(type.FullName, type);
 					}
 				}
 				// add forwarded types to forwardedTypes dictionary (because Module.GetType(string) should return them)
 				for (int i = 0; i < ExportedType.records.Length; i++)
 				{
 					int implementation = ExportedType.records[i].Implementation;
 					if (implementation >> 24 == AssemblyRefTable.Index)
 					{
 						string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
 						forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
 					}
 				}
 				for (int i = 0; i < ExportedType.records.Length; i++)
 				{
 					int implementation = ExportedType.records[i].Implementation;
 					if (implementation >> 24 == AssemblyRefTable.Index)
 					{
 						string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
 						forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1727" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Field.cs" startline="80" endline="112">
<![CDATA[
 
 		public override void __GetDataFromRVA(byte[] data, int offset, int length)
 		{
 			int rid = index + 1;
 			// TODO binary search?
 			for (int i = 0; i < module.FieldRVA.records.Length; i++)
 			{
 				if (module.FieldRVA.records[i].Field == rid)
 				{
 					int rva = module.FieldRVA.records[i].RVA;
 					if (rva == 0)
 					{
 						// C++ assemblies can have fields that have an RVA that is zero
 						Array.Clear(data, offset, length);
 						return;
 					}
 					module.SeekRVA(rva);
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					return;
 				}
 			}
 			for (int i = 0; i < module.FieldRVA.records.Length; i++)
 			{
 				if (module.FieldRVA.records[i].Field == rid)
 				{
 					int rva = module.FieldRVA.records[i].RVA;
 					if (rva == 0)
 					{
 						// C++ assemblies can have fields that have an RVA that is zero
 						Array.Clear(data, offset, length);
 						return;
 					}
 					module.SeekRVA(rva);
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					return;
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="173" endline="193">
<![CDATA[
 
 		public override PropertyInfo[] __GetDeclaredProperties()
 		{
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.PropertyMap.records.Length; i++)
 			{
 				if (module.PropertyMap.records[i].Parent == token)
 				{
 					int property = module.PropertyMap.records[i].PropertyList - 1;
 					int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records[i + 1].PropertyList - 1 
 					PropertyInfo[] properties = new PropertyInfo[end - property];
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					return properties;
 				}
 			}
 			for (int i = 0; i < module.PropertyMap.records.Length; i++)
 			{
 				if (module.PropertyMap.records[i].Parent == token)
 				{
 					int property = module.PropertyMap.records[i].PropertyList - 1;
 					int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records[i + 1].PropertyList - 1 
 					PropertyInfo[] properties = new PropertyInfo[end - property];
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					return properties;
 				}
 			}
 			return Empty<PropertyInfo>.Array;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1728" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1989" endline="2027">
<![CDATA[
 	}
 
 	sealed class AssemblyRefTable 
 	{
 		internal const int Index = 0x23;
 
 		internal struct Record
 		{
 			internal ushort MajorVersion;
 			internal ushort MinorVersion;
 			internal ushort BuildNumber;
 			internal ushort RevisionNumber;
 			internal int Flags;
 			internal int PublicKeyOrToken;
 			internal int Name;
 			internal int Culture;
 			internal int HashValue;
 		}
 
 		internal int FindOrAddRecord(Record rec)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Name == rec.Name
 					&& records[i].MajorVersion == rec.MajorVersion
 					&& records[i].MinorVersion == rec.MinorVersion
 					&& records[i].BuildNumber == rec.BuildNumber
 					&& records[i].RevisionNumber == rec.RevisionNumber
 					&& records[i].Flags == rec.Flags
 					&& records[i].PublicKeyOrToken == rec.PublicKeyOrToken
 					&& records[i].Culture == rec.Culture
 					&& records[i].HashValue == rec.HashValue
 					)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Name == rec.Name
 					&& records[i].MajorVersion == rec.MajorVersion
 					&& records[i].MinorVersion == rec.MinorVersion
 					&& records[i].BuildNumber == rec.BuildNumber
 					&& records[i].RevisionNumber == rec.RevisionNumber
 					&& records[i].Flags == rec.Flags
 					&& records[i].PublicKeyOrToken == rec.PublicKeyOrToken
 					&& records[i].Culture == rec.Culture
 					&& records[i].HashValue == rec.HashValue
 					)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="892" endline="930">
<![CDATA[
 
 		public override AssemblyName[] __GetReferencedAssemblies()
 		{
 			List<AssemblyName> list = new List<AssemblyName>();
 			for (int i = 0; i < AssemblyRef.records.Length; i++)
 			{
 				AssemblyName name = new AssemblyName();
 				name.Name = GetString(AssemblyRef.records[i].Name);
 				name.Version = new Version(
 					AssemblyRef.records[i].MajorVersion,
 					AssemblyRef.records[i].MinorVersion,
 					AssemblyRef.records[i].BuildNumber,
 					AssemblyRef.records[i].RevisionNumber);
 				if (AssemblyRef.records[i].PublicKeyOrToken != 0)
 				{
 					byte[] keyOrToken = GetBlobCopy(AssemblyRef.records[i].PublicKeyOrToken);
 					const int PublicKey = 0x0001;
 					if ((AssemblyRef.records[i].Flags & PublicKey) != 0)
 					{
 						name.SetPublicKey(keyOrToken);
 					}
 					else
 					{
 						name.SetPublicKeyToken(keyOrToken);
 					}
 				}
 				if (AssemblyRef.records[i].Culture != 0)
 				{
 					name.CultureInfo = new System.Globalization.CultureInfo(GetString(AssemblyRef.records[i].Culture));
 				}
 				else
 				{
 					name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
 				}
 				name.Flags = (AssemblyNameFlags)AssemblyRef.records[i].Flags;
 				list.Add(name);
 			}
 			for (int i = 0; i < AssemblyRef.records.Length; i++)
 			{
 				AssemblyName name = new AssemblyName();
 				name.Name = GetString(AssemblyRef.records[i].Name);
 				name.Version = new Version(
 					AssemblyRef.records[i].MajorVersion,
 					AssemblyRef.records[i].MinorVersion,
 					AssemblyRef.records[i].BuildNumber,
 					AssemblyRef.records[i].RevisionNumber);
 				if (AssemblyRef.records[i].PublicKeyOrToken != 0)
 				{
 					byte[] keyOrToken = GetBlobCopy(AssemblyRef.records[i].PublicKeyOrToken);
 					const int PublicKey = 0x0001;
 					if ((AssemblyRef.records[i].Flags & PublicKey) != 0)
 					{
 						name.SetPublicKey(keyOrToken);
 					}
 					else
 					{
 						name.SetPublicKeyToken(keyOrToken);
 					}
 				}
 				if (AssemblyRef.records[i].Culture != 0)
 				{
 					name.CultureInfo = new System.Globalization.CultureInfo(GetString(AssemblyRef.records[i].Culture));
 				}
 				else
 				{
 					name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
 				}
 				name.Flags = (AssemblyNameFlags)AssemblyRef.records[i].Flags;
 				list.Add(name);
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1729" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1989" endline="2027">
<![CDATA[
 	}
 
 	sealed class AssemblyRefTable 
 	{
 		internal const int Index = 0x23;
 
 		internal struct Record
 		{
 			internal ushort MajorVersion;
 			internal ushort MinorVersion;
 			internal ushort BuildNumber;
 			internal ushort RevisionNumber;
 			internal int Flags;
 			internal int PublicKeyOrToken;
 			internal int Name;
 			internal int Culture;
 			internal int HashValue;
 		}
 
 		internal int FindOrAddRecord(Record rec)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Name == rec.Name
 					&& records[i].MajorVersion == rec.MajorVersion
 					&& records[i].MinorVersion == rec.MinorVersion
 					&& records[i].BuildNumber == rec.BuildNumber
 					&& records[i].RevisionNumber == rec.RevisionNumber
 					&& records[i].Flags == rec.Flags
 					&& records[i].PublicKeyOrToken == rec.PublicKeyOrToken
 					&& records[i].Culture == rec.Culture
 					&& records[i].HashValue == rec.HashValue
 					)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Name == rec.Name
 					&& records[i].MajorVersion == rec.MajorVersion
 					&& records[i].MinorVersion == rec.MinorVersion
 					&& records[i].BuildNumber == rec.BuildNumber
 					&& records[i].RevisionNumber == rec.RevisionNumber
 					&& records[i].Flags == rec.Flags
 					&& records[i].PublicKeyOrToken == rec.PublicKeyOrToken
 					&& records[i].Culture == rec.Culture
 					&& records[i].HashValue == rec.HashValue
 					)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="882" endline="908">
<![CDATA[
 
 		internal void ExportTypes(Type[] types, int fileToken)
 		{
 			Dictionary<Type, int> declaringTypes = new Dictionary<Type, int>();
 			foreach (Type type in types)
 			{
 				if (!type.IsModulePseudoType && IsVisible(type))
 				{
 					ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
 					rec.Flags = (int)type.Attributes;
 					rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
 					rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 					string ns = type.Namespace;
 					rec.TypeNamespace = ns == null ? 0 
 					if (type.IsNested)
 					{
 						rec.Implementation = declaringTypes[type.DeclaringType];
 					}
 					else
 					{
 						rec.Implementation = fileToken;
 					}
 					int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord(rec);
 					declaringTypes.Add(type, exportTypeToken);
 				}
 			}
 			foreach (Type type in types)
 			{
 				if (!type.IsModulePseudoType && IsVisible(type))
 				{
 					ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
 					rec.Flags = (int)type.Attributes;
 					rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
 					rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 					string ns = type.Namespace;
 					rec.TypeNamespace = ns == null ? 0 
 					if (type.IsNested)
 					{
 						rec.Implementation = declaringTypes[type.DeclaringType];
 					}
 					else
 					{
 						rec.Implementation = fileToken;
 					}
 					int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord(rec);
 					declaringTypes.Add(type, exportTypeToken);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1730" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="427" endline="478">
<![CDATA[
 
 		public void EmitInt (int i)
 		{
 			switch (i) {
 			case -1
 				ig.Emit (OpCodes.Ldc_I4_M1);
 				break;
 
 			case 0
 				ig.Emit (OpCodes.Ldc_I4_0);
 				break;
 
 			case 1
 				ig.Emit (OpCodes.Ldc_I4_1);
 				break;
 
 			case 2
 				ig.Emit (OpCodes.Ldc_I4_2);
 				break;
 
 			case 3
 				ig.Emit (OpCodes.Ldc_I4_3);
 				break;
 
 			case 4
 				ig.Emit (OpCodes.Ldc_I4_4);
 				break;
 
 			case 5
 				ig.Emit (OpCodes.Ldc_I4_5);
 				break;
 
 			case 6
 				ig.Emit (OpCodes.Ldc_I4_6);
 				break;
 
 			case 7
 				ig.Emit (OpCodes.Ldc_I4_7);
 				break;
 
 			case 8
 				ig.Emit (OpCodes.Ldc_I4_8);
 				break;
 
 			default
 				if (i >= -128 && i <= 127) {
 					ig.Emit (OpCodes.Ldc_I4_S, (sbyte) i);
 				} else
 					ig.Emit (OpCodes.Ldc_I4, i);
 				break;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="577" endline="645">
<![CDATA[
 
 		public void Emit(OpCode opc, LocalBuilder local)
 		{
 			if ((opc == OpCodes.Ldloc || opc == OpCodes.Ldloca || opc == OpCodes.Stloc) && local.LocalIndex < 256)
 			{
 				if (opc == OpCodes.Ldloc)
 				{
 					switch (local.LocalIndex)
 					{
 						case 0
 							Emit(OpCodes.Ldloc_0);
 							break;
 						case 1
 							Emit(OpCodes.Ldloc_1);
 							break;
 						case 2
 							Emit(OpCodes.Ldloc_2);
 							break;
 						case 3
 							Emit(OpCodes.Ldloc_3);
 							break;
 						default
 							Emit(OpCodes.Ldloc_S);
 							code.Write((byte)local.LocalIndex);
 							break;
 					}
 				}
 				else if (opc == OpCodes.Ldloca)
 				{
 					Emit(OpCodes.Ldloca_S);
 					code.Write((byte)local.LocalIndex);
 				}
 				else if (opc == OpCodes.Stloc)
 				{
 					switch (local.LocalIndex)
 					{
 						case 0
 							Emit(OpCodes.Stloc_0);
 							break;
 						case 1
 							Emit(OpCodes.Stloc_1);
 							break;
 						case 2
 							Emit(OpCodes.Stloc_2);
 							break;
 						case 3
 							Emit(OpCodes.Stloc_3);
 							break;
 						default
 							Emit(OpCodes.Stloc_S);
 							code.Write((byte)local.LocalIndex);
 							break;
 					}
 				}
 			}
 			else
 			{
 				Emit(opc);
 				switch (opc.OperandType)
 				{
 					case OperandType.InlineVar
 						code.Write((ushort)local.LocalIndex);
 						break;
 					case OperandType.ShortInlineVar
 						code.Write((byte)local.LocalIndex);
 						break;
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1731" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="554" endline="578">
<![CDATA[
 		}
 
 		public CompileUnitEntry GetCompileUnit (int index)
 		{
 			if ((index < 1) || (index > ot.CompileUnitCount))
 				throw new ArgumentException ();
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				CompileUnitEntry unit;
 				if (compile_unit_hash.TryGetValue (index, out unit))
 					return unit;
 
 				long old_pos = reader.BaseStream.Position;
 
 				reader.BaseStream.Position = ot.CompileUnitTableOffset +
 					CompileUnitEntry.Size * (index - 1);
 				unit = new CompileUnitEntry (this, reader);
 				compile_unit_hash.Add (index, unit);
 
 				reader.BaseStream.Position = old_pos;
 				return unit;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="511" endline="542">
<![CDATA[
 		}
 
 		internal int LineNumberCount = 0;
 		internal int LocalCount = 0;
 		internal int StringSize = 0;
 
 		internal int LineNumberSize = 0;
 		internal int ExtendedLineNumberSize = 0;
 
 		public SourceFileEntry GetSourceFile (int index)
 		{
 			if ((index < 1) || (index > ot.SourceCount))
 				throw new ArgumentException ();
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				SourceFileEntry source;
 				if (source_file_hash.TryGetValue (index, out source))
 					return source;
 
 				long old_pos = reader.BaseStream.Position;
 
 				reader.BaseStream.Position = ot.SourceTableOffset +
 					SourceFileEntry.Size * (index - 1);
 				source = new SourceFileEntry (this, reader);
 				source_file_hash.Add (index, source);
 
 				reader.BaseStream.Position = old_pos;
 				return source;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1732" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="186" endline="209">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ParametersOrType.ResolveTypeReferences AndAlso result
         If EventType IsNot Nothing Then
             'Nothing to do
         ElseIf Type IsNot Nothing Then
             Helper.Assert(EventType Is Nothing)
             EventType = Type.ResolvedType
         ElseIf Parameters IsNot Nothing Then
             Helper.Assert(EventType IsNot Nothing OrElse ImplementsClause IsNot Nothing)
         Else
             Throw New InternalException(Me)
         End If
 
         If m_ImplicitEventDelegate IsNot Nothing Then
             result = m_ImplicitEventDelegate.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="129" endline="160">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             m_ExceptionType = m_TypeName.ResolvedType
             Helper.Assert(m_ExceptionType IsNot Nothing)
             If Helper.CompareType(Compiler.TypeCache.System_Exception, m_ExceptionType) = False AndAlso Helper.IsSubclassOf(Compiler.TypeCache.System_Exception, m_ExceptionType) = False Then
                 Helper.AddError(Me, "Exception type does not inherit from System.Exception")
                 result = True
             End If
         ElseIf m_When Is Nothing Then
             m_ExceptionType = Compiler.TypeCache.System_Exception
         End If
         If m_Variable IsNot Nothing Then 'Token.IsSomething(m_Variable) Then
             m_VariableDeclaration = New LocalVariableDeclaration(Me, m_Variable, False, m_TypeName, Nothing, Nothing)
             result = m_VariableDeclaration.ResolveTypeReferences AndAlso result
             CodeBlock.Variables.Add(m_VariableDeclaration)
         End If
         If m_When IsNot Nothing Then result = m_When.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If m_When IsNot Nothing Then
             m_When = Helper.CreateTypeConversion(Me, m_When, Compiler.TypeCache.System_Boolean, result)
             If result = False Then
                 Helper.AddError(Me)
                 Return result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1733" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9550" endline="9586">
<![CDATA[
 
 		public override bool Emit (EmitContext ec, IMemoryLocation target)
 		{
 			bool left_on_stack = base.Emit (ec, target);
 
 			if (initializers.IsEmpty)
 				return left_on_stack;
 
 			LocalTemporary temp = target as LocalTemporary;
 			if (temp == null) {
 				if (!left_on_stack) {
 					VariableReference vr = target as VariableReference;
 					
 					// FIXME
 					if (vr != null && vr.IsRef)
 						target.AddressOf (ec, AddressOp.Load);
 
 					((Expression) target).Emit (ec);
 					left_on_stack = true;
 				}
 
 				temp = new LocalTemporary (type);
 			}
 
 			instance = temp;
 			if (left_on_stack)
 				temp.Store (ec);
 
 			initializers.Emit (ec);
 
 			if (left_on_stack) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 
 			return left_on_stack;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2328" endline="2356">
<![CDATA[
 		{
 			var tp = t as TypeParameterSpec;
 			if (tp != null) {
 				Variance v = tp.Variance;
 				if (expected == Variance.None && v != expected ||
 					expected == Variance.Covariant && v == Variance.Contravariant ||
 					expected == Variance.Contravariant && v == Variance.Covariant) {
 					((TypeParameter)tp.MemberDefinition).ErrorInvalidVariance (member, expected);
 				}
 
 				return expected;
 			}
 
 			if (t.TypeArguments.Length > 0) {
 				var targs_definition = t.MemberDefinition.TypeParameters;
 				TypeSpec[] targs = GetTypeArguments (t);
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 
 				return expected;
 			}
 
 			if (t.IsArray)
 				return CheckTypeVariance (GetElementType (t), expected, member);
 
 			return Variance.None;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1734" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9550" endline="9586">
<![CDATA[
 
 		public override bool Emit (EmitContext ec, IMemoryLocation target)
 		{
 			bool left_on_stack = base.Emit (ec, target);
 
 			if (initializers.IsEmpty)
 				return left_on_stack;
 
 			LocalTemporary temp = target as LocalTemporary;
 			if (temp == null) {
 				if (!left_on_stack) {
 					VariableReference vr = target as VariableReference;
 					
 					// FIXME
 					if (vr != null && vr.IsRef)
 						target.AddressOf (ec, AddressOp.Load);
 
 					((Expression) target).Emit (ec);
 					left_on_stack = true;
 				}
 
 				temp = new LocalTemporary (type);
 			}
 
 			instance = temp;
 			if (left_on_stack)
 				temp.Store (ec);
 
 			initializers.Emit (ec);
 
 			if (left_on_stack) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 
 			return left_on_stack;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="94" endline="150">
<![CDATA[
 
 		public static Expression ImplicitTypeParameterConversion (Expression expr, TypeSpec target_type)
 		{
 			var expr_type = (TypeParameterSpec) expr.Type;
 
 			//
 			// From T to a type parameter U, provided T depends on U
 			//
 			var ttype = target_type as TypeParameterSpec;
 			if (ttype != null) {
 				if (expr_type.TypeArguments != null) {
 					foreach (var targ in expr_type.TypeArguments) {
 						if (!TypeSpecComparer.Override.IsEqual (ttype, targ))
 							continue;
 
 						if (expr_type.IsReferenceType && !ttype.IsReferenceType)
 							return new BoxedCast (expr, target_type);
 
 						return new ClassCast (expr, target_type);
 					foreach (var targ in expr_type.TypeArguments) {
 						if (!TypeSpecComparer.Override.IsEqual (ttype, targ))
 							continue;
 
 						if (expr_type.IsReferenceType && !ttype.IsReferenceType)
 							return new BoxedCast (expr, target_type);
 
 						return new ClassCast (expr, target_type);
 					}
 				}
 
 				return null;
 			}
 
 			//
 			// LAMESPEC
 			//
 			if (target_type == InternalType.Dynamic) {
 				if (expr_type.IsReferenceType)
 					return new ClassCast (expr, target_type);
 
 				return new BoxedCast (expr, target_type);
 			}
 
 			//
 			// From T to its effective base class C
 			// From T to any base class of C (it cannot contain dynamic of be of dynamic type)
 			// From T to any interface implemented by C
 			//
 			var base_type = expr_type.GetEffectiveBase ();
 			if (base_type == target_type || TypeSpec.IsBaseClass (base_type, target_type, false) || base_type.ImplementsInterface (target_type, true)) {
 				if (expr_type.IsReferenceType)
 					return new ClassCast (expr, target_type);
 
 				return new BoxedCast (expr, target_type);
 			}
 
 			if (target_type.IsInterface && expr_type.IsConvertibleToInterface (target_type)) {
 				if (expr_type.IsReferenceType)
 					return new ClassCast (expr, target_type);
 
 				return new BoxedCast (expr, target_type);
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1735" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9550" endline="9586">
<![CDATA[
 
 		public override bool Emit (EmitContext ec, IMemoryLocation target)
 		{
 			bool left_on_stack = base.Emit (ec, target);
 
 			if (initializers.IsEmpty)
 				return left_on_stack;
 
 			LocalTemporary temp = target as LocalTemporary;
 			if (temp == null) {
 				if (!left_on_stack) {
 					VariableReference vr = target as VariableReference;
 					
 					// FIXME
 					if (vr != null && vr.IsRef)
 						target.AddressOf (ec, AddressOp.Load);
 
 					((Expression) target).Emit (ec);
 					left_on_stack = true;
 				}
 
 				temp = new LocalTemporary (type);
 			}
 
 			instance = temp;
 			if (left_on_stack)
 				temp.Store (ec);
 
 			initializers.Emit (ec);
 
 			if (left_on_stack) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 
 			return left_on_stack;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="373" endline="432">
<![CDATA[
 		}
 
 		public MethodSpec Resolve ()
 		{
 			if (resolve_error)
 				return null;
 
 			resolve_error = true;
 			arg_resolved = true;
 
 			if (Type == null) {
 				ResolveAttributeType ();
 				if (Type == null)
 					return null;
 			}
 
 			if (Type.IsAbstract) {
 				Report.Error (653, Location, "Cannot apply attribute class `{0}' because it is abstract", GetSignatureForError ());
 				return null;
 			}
 
 			ObsoleteAttribute obsolete_attr = Type.GetAttributeObsolete ();
 			if (obsolete_attr != null) {
 				AttributeTester.Report_ObsoleteMessage (obsolete_attr, TypeManager.CSharpName (Type), Location, Report);
 			}
 
 			MethodSpec ctor;
 			// Try if the attribute is simple has been resolved before
 			if (PosArguments == null && NamedArguments == null) {
 				if (att_cache.TryGetValue (Type, out ctor)) {
 					resolve_error = false;
 					return ctor;
 				}
 			}
 
 			ResolveContext rc = CreateResolveContext ();
 			ctor = ResolveConstructor (rc);
 			if (ctor == null) {
 				return null;
 			}
 
 			//
 			// Add [module
 			//
 			var module = context.Module;
 			// HACK
 			if (module.PredefinedAttributes == null)
 				return ctor;
 
 			if (Type == module.PredefinedAttributes.DllImport && module.HasDefaultCharSet) {
 				AddModuleCharSet (rc);
 			}
 
 			if (NamedArguments != null && !ResolveNamedArguments (rc)) {
 				return null;
 			}
 
 			resolve_error = false;
 			return ctor;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1736" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="3854" endline="3877">
<![CDATA[
 
     Shared Function GetOverloadableSignatures(ByVal Compiler As Compiler, ByVal Member As Mono.Cecil.MemberReference) As String()
         Dim result As New Generic.List(Of String)
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim types() As Mono.Cecil.TypeReference
         Dim sep As String = ""
 
         params = Helper.GetParameters(Compiler, Member)
         types = Helper.GetTypes(params)
 
         Dim signature As String = ""
         For i As Integer = 0 To types.Length - 1
             If CecilHelper.IsByRef(types(i)) Then types(i) = CecilHelper.GetElementType(types(i))
             If params(i).IsOptional Then
                 result.Add(Member.Name & "(" & signature & ")")
             End If
             signature &= sep & types(i).Namespace & "." & types(i).Name
             sep = ", "
         Next
 
         result.Add(Member.Name & "(" & signature & ")")
 
         Return result.ToArray
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" startline="252" endline="286">
<![CDATA[
 
     Private Sub Flatten(ByVal Name As String, ByVal base As MemberCache, ByVal Visibility As MemberVisibility)
         If base Is Nothing Then
             If Helper.IsInterface(Compiler, m_Type) AndAlso CecilHelper.IsGenericParameter(m_Type) = False Then
                 Dim ifaces As Mono.Collections.Generic.Collection(Of TypeReference)
                 Dim icaches() As MemberCache
 
                 ifaces = CecilHelper.GetInterfaces(m_Type, True)
 
                 ReDim icaches(ifaces.Count - 1)
                 m_ShadowedInterfaceMembers = New Generic.List(Of Mono.Cecil.MemberReference)
 
                 For i As Integer = 0 To ifaces.Count - 1
                     icaches(i) = m_Compiler.TypeManager.GetCache(ifaces(i))
                     icaches(i).Load(Nothing, Visibility)
                     m_ShadowedInterfaceMembers.AddRange(icaches(i).m_ShadowedInterfaceMembers)
                 Next
 
                 For i As Integer = 0 To ifaces.Count - 1
                     FlattenWith(Name, icaches(i), Visibility)
                 Next
                 Dim system_object As MemberCache = m_Compiler.TypeManager.GetCache(Compiler.TypeCache.System_Object)
                 system_object.Load(Name, Visibility)
                 FlattenWith(Name, system_object, Visibility)
             Else
                 m_FlattenedCacheInsensitive = m_CacheInsensitive
             End If
 
             Return
         End If
 
         base.Load(Name, Visibility)
 
         FlattenWith(Name, base, Visibility)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1737" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="44" endline="70">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime, TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1738" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="44" endline="70">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1739" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1740" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="44" endline="72">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1741" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1742" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1743" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1744" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1745" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="44" endline="74">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1746" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1747" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="101" endline="127">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="44" endline="73">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1748" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8232" endline="8261">
<![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			var ac = ea.Expr.Type as ArrayContainer;
 
 			if (prepared) {
 				ec.EmitLoadFromPtr (type);
 			} else {
 				if (prepared_arguments == null) {
 					LoadArrayAndArguments (ec);
 				} else {
 					expr_copy.Emit (ec);
 					LocalTemporary lt;
 					foreach (var expr in prepared_arguments) {
 						expr.Emit (ec);
 						lt = expr as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 					foreach (var expr in prepared_arguments) {
 						expr.Emit (ec);
 						lt = expr as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 				}
 
 				ec.EmitArrayLoad (ac);
 			}	
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temp = new LocalTemporary (this.type);
 				temp.Store (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1421" endline="1472">
<![CDATA[
 
 		TypeParameterInflator CreateLocalInflator ()
 		{
 			TypeParameterSpec[] tparams_full;
 			TypeSpec[] targs_full = targs;
 			if (IsNested) {
 				//
 				// Special case is needed when we are inflating an open type (nested type definition)
 				// on inflated parent. Consider following case
 				//
 				// Foo<T>.Bar<U> => Foo<string>.Bar<U>
 				//
 				// Any later inflation of Foo<string>.Bar<U> has to also inflate T if used inside Bar<U>
 				//
 				List<TypeSpec> merged_targs = null;
 				List<TypeParameterSpec> merged_tparams = null;
 
 				var type = DeclaringType;
 
 				do {
 					if (type.TypeArguments.Length > 0) {
 						if (merged_targs == null) {
 							merged_targs = new List<TypeSpec> ();
 							merged_tparams = new List<TypeParameterSpec> ();
 							if (targs.Length > 0) {
 								merged_targs.AddRange (targs);
 								merged_tparams.AddRange (open_type.MemberDefinition.TypeParameters);
 							}
 						}
 						merged_tparams.AddRange (type.MemberDefinition.TypeParameters);
 						merged_targs.AddRange (type.TypeArguments);
 					}
 					type = type.DeclaringType;
 				} while (type != null);
 
 				if (merged_targs != null) {
 					// Type arguments are not in the right order but it should not matter in this case
 					targs_full = merged_targs.ToArray ();
 					tparams_full = merged_tparams.ToArray ();
 				} else if (targs.Length == 0) {
 					tparams_full = TypeParameterSpec.EmptyTypes;
 				} else {
 					tparams_full = open_type.MemberDefinition.TypeParameters;
 				}
 			} else if (targs.Length == 0) {
 				tparams_full = TypeParameterSpec.EmptyTypes;
 			} else {
 				tparams_full = open_type.MemberDefinition.TypeParameters;
 			}
 
 			return new TypeParameterInflator (this, tparams_full, targs_full);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1749" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8232" endline="8261">
<![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			var ac = ea.Expr.Type as ArrayContainer;
 
 			if (prepared) {
 				ec.EmitLoadFromPtr (type);
 			} else {
 				if (prepared_arguments == null) {
 					LoadArrayAndArguments (ec);
 				} else {
 					expr_copy.Emit (ec);
 					LocalTemporary lt;
 					foreach (var expr in prepared_arguments) {
 						expr.Emit (ec);
 						lt = expr as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 					foreach (var expr in prepared_arguments) {
 						expr.Emit (ec);
 						lt = expr as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 				}
 
 				ec.EmitArrayLoad (ac);
 			}	
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temp = new LocalTemporary (this.type);
 				temp.Store (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="42" endline="83">
<![CDATA[
 
 		protected void CheckReservedNameConflict (string prefix, MethodSpec accessor)
 		{
 			string name;
 			AParametersCollection parameters;
 			if (accessor != null) {
 				name = accessor.Name;
 				parameters = accessor.Parameters;
 			} else {
 				name = prefix + ShortName;
 				if (IsExplicitImpl)
 					name = MemberName.Left + "." + name;
 
 				if (this is Indexer) {
 					parameters = ((Indexer) this).ParameterInfo;
 					if (prefix[0] == 's') {
 						var data = new IParameterData[parameters.Count + 1];
 						Array.Copy (parameters.FixedParameters, data, data.Length - 1);
 						data[data.Length - 1] = new ParameterData ("value", Parameter.Modifier.NONE);
 						var types = new TypeSpec[data.Length];
 						Array.Copy (parameters.Types, types, data.Length - 1);
 						types[data.Length - 1] = member_type;
 
 						parameters = new ParametersImported (data, types, false);
 					}
 				} else {
 					if (prefix[0] == 's')
 						parameters = ParametersCompiled.CreateFullyResolved (new[] { member_type });
 					else
 						parameters = ParametersCompiled.EmptyReadOnlyParameters;
 				}
 			}
 
 			var conflict = MemberCache.FindMember (Parent.Definition,
 				new MemberFilter (name, 0, MemberKind.Method, parameters, null),
 				BindingRestriction.DeclaredOnly | BindingRestriction.NoAccessors);
 
 			if (conflict != null) {
 				Report.SymbolRelatedToPreviousError (conflict);
 				Report.Error (82, Location, "A member `{0}' is already reserved", conflict.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1750" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="601" endline="626">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if the specified MethodInfo is a valid candidate to a Main function.
     ''' </summary>
     ''' <param name="method"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsMainMethod(ByVal method As Mono.Cecil.MethodDefinition) As Boolean
         'Only static methods
         If method.IsStatic = False Then Return False
         'Only non-private methods (or maybe only public?)
         If method.IsPrivate Then Return False
         'Only methods called 'Main'
         If vbnc.Helper.CompareName(method.Name, "Main") = False Then Return False
         'Only methods with no return type or Integer return type
         If Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Void) = False AndAlso Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Int32) = False Then Return False
 
         'Only methods with no parameters or methods with one String() parameter
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         params = method.Parameters
         If params.Count = 0 Then Return True
         If params.Count > 1 Then Return False
         If Helper.CompareType(params(0).ParameterType, Compiler.TypeCache.System_String_Array) AndAlso params(0).IsOptional = False AndAlso params(0).IsOut = False Then Return True
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="772" endline="806">
<![CDATA[
     End Property
 
     Private Function IsNarrowingInternal(ByVal ExceptObject As Boolean) As Boolean
         For j As Integer = 0 To InputParameters.Count - 1
             Dim arg As Argument
             Dim param As Mono.Cecil.ParameterDefinition
             Dim IsConvertible As Boolean
             Dim elementType As Mono.Cecil.TypeReference
             Dim initializer As Expression
 
             param = InputParameters(j)
             arg = ExactArguments(j)
 
             If ExceptObject AndAlso Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.System_Object) Then Continue For
 
             If m_IsParamArray AndAlso j = InputParameters.Count - 1 AndAlso ParamArrayExpression IsNot Nothing Then
                 'To match the automatically created array for the paramarray parameter each argument has to be 
                 'implicitly convertible to the element type of the paramarray parameter type.
                 IsConvertible = True
                 elementType = CType(param.ParameterType, Mono.Cecil.ArrayType).ElementType
                 For k As Integer = 0 To ParamArrayExpression.ArrayElementInitalizer.Initializers.Count - 1
                     initializer = ParamArrayExpression.ArrayElementInitalizer.Initializers(k).AsRegularInitializer
                     IsConvertible = IsConvertible AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(arg, initializer.ExpressionType, elementType)
                 Next
             Else
                 IsConvertible = Compiler.TypeResolution.IsImplicitlyConvertible(arg, arg.Expression.ExpressionType, param.ParameterType)
             End If
 
             If IsConvertible = False Then
                 Return True
             End If
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1751" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="601" endline="626">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if the specified MethodInfo is a valid candidate to a Main function.
     ''' </summary>
     ''' <param name="method"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsMainMethod(ByVal method As Mono.Cecil.MethodDefinition) As Boolean
         'Only static methods
         If method.IsStatic = False Then Return False
         'Only non-private methods (or maybe only public?)
         If method.IsPrivate Then Return False
         'Only methods called 'Main'
         If vbnc.Helper.CompareName(method.Name, "Main") = False Then Return False
         'Only methods with no return type or Integer return type
         If Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Void) = False AndAlso Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Int32) = False Then Return False
 
         'Only methods with no parameters or methods with one String() parameter
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         params = method.Parameters
         If params.Count = 0 Then Return True
         If params.Count > 1 Then Return False
         If Helper.CompareType(params(0).ParameterType, Compiler.TypeCache.System_String_Array) AndAlso params(0).IsOptional = False AndAlso params(0).IsOut = False Then Return True
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="106" endline="140">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences(ByVal ResolveTypeParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences(ResolveTypeParameters) AndAlso result
         If m_ReturnTypeAttributes IsNot Nothing Then result = m_ReturnTypeAttributes.ResolveTypeReferences AndAlso result
 
         If m_ReturnType Is Nothing Then
             If m_TypeName IsNot Nothing Then
                 result = m_TypeName.ResolveTypeReferences AndAlso result
                 If result = False Then Return result
                 m_ReturnType = m_TypeName.ResolvedType
             ElseIf Identifier.HasTypeCharacter Then
                 m_ReturnType = TypeCharacters.TypeCharacterToType(Compiler, Identifier.TypeCharacter)
             Else
                 If Me.Location.File(Compiler).IsOptionStrictOn Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30210, Me.Location) AndAlso result
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC42024, Me.Location) AndAlso result
                 End If
                 m_ReturnType = Compiler.TypeCache.System_Object
             End If
 
             If result AndAlso m_ReturnType.GenericParameters.Count > 0 Then
                 Dim tmp As New Mono.Cecil.GenericInstanceType(m_ReturnType)
                 For i As Integer = 0 To m_ReturnType.GenericParameters.Count - 1
                     tmp.GenericArguments.Add(m_ReturnType.GenericParameters(i))
                 Next
                 m_ReturnType = tmp
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1752" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="450" endline="492">
<![CDATA[
 
 		/// <summary>
 		///   Resolves an expression for LValue assignment
 		/// </summary>
 		///
 		/// <remarks>
 		///   Currently ResolveLValue wraps DoResolveLValue to perform sanity
 		///   checking and assertion checking on what we expect from Resolve
 		/// </remarks>
 		public Expression ResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			int errors = ec.Report.Errors;
 			bool out_access = right_side == EmptyExpression.OutAccess.Instance;
 
 			Expression e = DoResolveLValue (ec, right_side);
 
 			if (e != null && out_access && !(e is IMemoryLocation)) {
 				// FIXME
 				//        Enabling this 'throw' will "only" result in deleting useless code elsewhere,
 
 				//throw new InternalErrorException ("ResolveLValue didn't return an IMemoryLocation
 				//				  e.GetType () + " " + e.GetSignatureForError ());
 				e = null;
 			}
 
 			if (e == null) {
 				if (errors == ec.Report.Errors) {
 					if (out_access)
 						ec.Report.Error (1510, loc, "A ref or out argument must be an assignable variable");
 					else
 						Error_ValueAssignment (ec, loc);
 				}
 				return null;
 			}
 
 			if (e.eclass == ExprClass.Unresolved)
 				throw new Exception ("Expression " + e + " ExprClass is Invalid after resolve");
 
 			if ((e.type == null) && !(e is GenericTypeExpr))
 				throw new Exception ("Expression " + e + " did not set its type after Resolve");
 
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2885" endline="2924">
<![CDATA[
 		
 		//
 		// Uses inferred or partially infered types to inflate delegate type argument. Returns
 		// null when type parameter has not been fixed
 		//
 		public TypeSpec InflateGenericArgument (TypeSpec parameter)
 		{
 			var tp = parameter as TypeParameterSpec;
 			if (tp != null) {
 				//
 				// Type inference works on generic arguments (MVAR) only
 				//
 				if (!tp.IsMethodOwned)
 					return parameter;
 
 				//
 				// Ensure the type parameter belongs to same container
 				//
 				if (tp.DeclaredPosition < tp_args.Length && tp_args[tp.DeclaredPosition] == parameter)
 					return fixed_types[tp.DeclaredPosition] ?? parameter;
 
 				return parameter;
 			}
 
 			var gt = parameter as InflatedTypeSpec;
 			if (gt != null) {
 				var inflated_targs = new TypeSpec [gt.TypeArguments.Length];
 				for (int ii = 0; ii < inflated_targs.Length; ++ii) {
 					var inflated = InflateGenericArgument (gt.TypeArguments [ii]);
 					if (inflated == null)
 						return null;
 
 					inflated_targs[ii] = inflated;
 				}
 				for (int ii = 0; ii < inflated_targs.Length; ++ii) {
 					var inflated = InflateGenericArgument (gt.TypeArguments [ii]);
 					if (inflated == null)
 						return null;
 
 					inflated_targs[ii] = inflated;
 				}
 
 				return gt.GetDefinition ().MakeGenericType (inflated_targs);
 			}
 
 			return parameter;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1753" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="450" endline="492">
<![CDATA[
 
 		/// <summary>
 		///   Resolves an expression for LValue assignment
 		/// </summary>
 		///
 		/// <remarks>
 		///   Currently ResolveLValue wraps DoResolveLValue to perform sanity
 		///   checking and assertion checking on what we expect from Resolve
 		/// </remarks>
 		public Expression ResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			int errors = ec.Report.Errors;
 			bool out_access = right_side == EmptyExpression.OutAccess.Instance;
 
 			Expression e = DoResolveLValue (ec, right_side);
 
 			if (e != null && out_access && !(e is IMemoryLocation)) {
 				// FIXME
 				//        Enabling this 'throw' will "only" result in deleting useless code elsewhere,
 
 				//throw new InternalErrorException ("ResolveLValue didn't return an IMemoryLocation
 				//				  e.GetType () + " " + e.GetSignatureForError ());
 				e = null;
 			}
 
 			if (e == null) {
 				if (errors == ec.Report.Errors) {
 					if (out_access)
 						ec.Report.Error (1510, loc, "A ref or out argument must be an assignable variable");
 					else
 						Error_ValueAssignment (ec, loc);
 				}
 				return null;
 			}
 
 			if (e.eclass == ExprClass.Unresolved)
 				throw new Exception ("Expression " + e + " ExprClass is Invalid after resolve");
 
 			if ((e.type == null) && !(e is GenericTypeExpr))
 				throw new Exception ("Expression " + e + " did not set its type after Resolve");
 
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4092" endline="4130">
<![CDATA[
 
 		static TypeSpec MoreSpecific (TypeSpec p, TypeSpec q)
 		{
 			if (TypeManager.IsGenericParameter (p) && !TypeManager.IsGenericParameter (q))
 				return q;
 			if (!TypeManager.IsGenericParameter (p) && TypeManager.IsGenericParameter (q))
 				return p;
 
 			var ac_p = p as ArrayContainer;
 			if (ac_p != null) {
 				var ac_q = ((ArrayContainer) q);
 				TypeSpec specific = MoreSpecific (ac_p.Element, ac_q.Element);
 				if (specific == ac_p.Element)
 					return p;
 				if (specific == ac_q.Element)
 					return q;
 			} else if (TypeManager.IsGenericType (p)) {
 				var pargs = TypeManager.GetTypeArguments (p);
 				var qargs = TypeManager.GetTypeArguments (q);
 
 				bool p_specific_at_least_once = false;
 				bool q_specific_at_least_once = false;
 
 				for (int i = 0; i < pargs.Length; i++) {
 					TypeSpec specific = MoreSpecific (pargs[i], qargs[i]);
 					if (specific == pargs[i])
 						p_specific_at_least_once = true;
 					if (specific == qargs[i])
 						q_specific_at_least_once = true;
 				}
 				for (int i = 0; i < pargs.Length; i++) {
 					TypeSpec specific = MoreSpecific (pargs[i], qargs[i]);
 					if (specific == pargs[i])
 						p_specific_at_least_once = true;
 					if (specific == qargs[i])
 						q_specific_at_least_once = true;
 				}
 
 				if (p_specific_at_least_once && !q_specific_at_least_once)
 					return p;
 				if (!p_specific_at_least_once && q_specific_at_least_once)
 					return q;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1754" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="403" endline="441">
<![CDATA[
 		}
 	       
 		/// <summary>
 		///   Resolves an expression and performs semantic analysis on it.
 		/// </summary>
 		///
 		/// <remarks>
 		///   Currently Resolve wraps DoResolve to perform sanity
 		///   checking and assertion checking on what we expect from Resolve.
 		/// </remarks>
 		public Expression Resolve (ResolveContext ec, ResolveFlags flags)
 		{
 			if (eclass != ExprClass.Unresolved)
 				return this;
 			
 			Expression e;
 			try {
 				e = DoResolve (ec);
 
 				if (e == null)
 					return null;
 
 				if ((flags & e.ExprClassToResolveFlags) == 0) {
 					e.Error_UnexpectedKind (ec, flags, loc);
 					return null;
 				}
 
 				if (e.type == null)
 					throw new InternalErrorException ("Expression `{0}' didn't set its type in DoResolve", e.GetType ());
 
 				return e;
 			} catch (Exception ex) {
 				if (loc.IsNull || Report.DebugFlags > 0 || ex is CompletionResult || ec.Report.IsDisabled)
 					throw;
 
 				ec.Report.Error (584, loc, "Internal compiler error
 				return EmptyExpression.Null;	// TODO
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1153" endline="1203">
<![CDATA[
 
 		//
 		// Emits the code
 		// 
 		public override void Emit ()
 		{
 			try {
 				if (IsPartialDefinition) {
 					//
 					// Use partial method implementation builder for partial method declaration attributes
 					//
 					if (partialMethodImplementation != null) {
 						MethodBuilder = partialMethodImplementation.MethodBuilder;
 					}
 
 					return;
 				}
 				
 				if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.PartialDefinitionExists) == 0) {
 					Report.Error (759, Location, "A partial method `{0}' implementation is missing a partial method declaration",
 						GetSignatureForError ());
 				}
 
 				if (CurrentTypeParameters != null) {
 					var ge = type_expr as GenericTypeExpr;
 					if (ge != null)
 						ge.CheckConstraints (this);
 
 					foreach (Parameter p in parameters.FixedParameters) {
 						ge = p.TypeExpression as GenericTypeExpr;
 						if (ge != null)
 							ge.CheckConstraints (this);
 					}
 					foreach (Parameter p in parameters.FixedParameters) {
 						ge = p.TypeExpression as GenericTypeExpr;
 						if (ge != null)
 							ge.CheckConstraints (this);
 					}
 
 					for (int i = 0; i < CurrentTypeParameters.Length; ++i) {
 						var tp = CurrentTypeParameters [i];
 						tp.CheckGenericConstraints ();
 						tp.Emit ();
 					}
 					for (int i = 0; i < CurrentTypeParameters.Length; ++i) {
 						var tp = CurrentTypeParameters [i];
 						tp.CheckGenericConstraints ();
 						tp.Emit ();
 					}
 				}
 
 				base.Emit ();
 				
 				if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 					Module.PredefinedAttributes.Extension.EmitAttribute (MethodBuilder);
 			} catch {
 				Console.WriteLine ("Internal compiler error at {0}
 						   Location, MethodBuilder);
 				throw;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1755" nfragments="2" Csharpe_files="1" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="403" endline="441">
<![CDATA[
 		}
 	       
 		/// <summary>
 		///   Resolves an expression and performs semantic analysis on it.
 		/// </summary>
 		///
 		/// <remarks>
 		///   Currently Resolve wraps DoResolve to perform sanity
 		///   checking and assertion checking on what we expect from Resolve.
 		/// </remarks>
 		public Expression Resolve (ResolveContext ec, ResolveFlags flags)
 		{
 			if (eclass != ExprClass.Unresolved)
 				return this;
 			
 			Expression e;
 			try {
 				e = DoResolve (ec);
 
 				if (e == null)
 					return null;
 
 				if ((flags & e.ExprClassToResolveFlags) == 0) {
 					e.Error_UnexpectedKind (ec, flags, loc);
 					return null;
 				}
 
 				if (e.type == null)
 					throw new InternalErrorException ("Expression `{0}' didn't set its type in DoResolve", e.GetType ());
 
 				return e;
 			} catch (Exception ex) {
 				if (loc.IsNull || Report.DebugFlags > 0 || ex is CompletionResult || ec.Report.IsDisabled)
 					throw;
 
 				ec.Report.Error (584, loc, "Internal compiler error
 				return EmptyExpression.Null;	// TODO
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6172" endline="6206">
<![CDATA[
 
 public void parse ()
 {
 	eof_token = Token.EOF;
 	Tokenizer.LocatedToken.Initialize ();
 	
 	try {
 		if (yacc_verbose_flag > 1)
 			yyparse (lexer, new yydebug.yyDebugSimple ());
 		else
 			yyparse (lexer);
 			
 		Tokenizer tokenizer = lexer as Tokenizer;
 		tokenizer.cleanup ();		
 	} catch (Exception e){
 	  	if (e is yyParser.yyUnexpectedEof) {
 			Error_SyntaxError (yyToken);
 			UnexpectedEOF = true;
 			return;
 		}
 			
 		if (e is yyParser.yyException) {
 			Report.Error (-25, lexer.Location, "Parsing error");
 		} else {
 			// Used by compiler-tester to test internal errors
 			if (yacc_verbose_flag > 0)
 				throw;
 		
 			Report.Error (589, lexer.Location, "Internal compiler error during parsing");
 		}
 	}
 
 	if (RootContext.ToplevelTypes.NamespaceEntry != null)
 		throw new InternalErrorException ("who set it?");
 }
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1756" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" startline="23" endline="48">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Remainder_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ModObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" startline="24" endline="48">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitSubOrSubOvfOrSubOvfUn(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitSub(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Subtract_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__SubtractObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1757" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" startline="23" endline="48">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Remainder_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ModObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" startline="23" endline="48">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMultOrMultOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMult(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Multiply_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__MultiplyObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1758" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="430" endline="481">
<![CDATA[
 
     Private Function ParseAssemblyDeclaration(ByVal RootNamespace As String, ByVal assembly As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         Dim iLastLocation As Span
 
         Dim AssemblyAttributes As New Attributes(assembly)
 
         tm.NextToken() 'Goto the first token
 
         Do Until tm.CurrentToken.IsEndOfCode
 #If EXTENDEDDEBUG Then
             Dim iFileCount, iTotalFiles As Integer
             iFileCount += 1
             iTotalFiles = Me.Compiler.CommandLine.Files.Count
             Me.Compiler.Report.WriteLine(Report.ReportLevels.Debug, "Parsing file " & tm.CurrentToken.Location.File.FileName & " (" & iFileCount & " of " & iTotalFiles & " files)")
 #End If
             iLastLocation = tm.CurrentLocation
 
             While tm.AcceptNewLine
 
             End While
             While tm.AcceptNewLine
 
             End While
             '[  OptionStatement+  ]
             '[  ImportsStatement+  ]
 
             If Me.ParseFileHeader(tm.CurrentLocation.File(Compiler), assembly) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             ''	[  AttributesStatement+  ]
             'If vbnc.Attributes.IsMe(tm) Then
             '    If Me.ParseAttributes(result, AssemblyAttributes) = False Then
             '        Helper.ErrorRecoveryNot    Implemented()
             '    End If
             'End If
 
             '	[  NamespaceMemberDeclaration+  ]
             result = ParseAssemblyMembers(assembly, RootNamespace) AndAlso result
 
             While tm.AcceptNewLine
 
             End While
             While tm.AcceptNewLine
 
             End While
             tm.AcceptEndOfFile()
             If iLastLocation.Equals(tm.CurrentLocation) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation) AndAlso result
                 tm.GotoNewline(False)
             End If
         Loop
         Do Until tm.CurrentToken.IsEndOfCode
 #If EXTENDEDDEBUG Then
             Dim iFileCount, iTotalFiles As Integer
             iFileCount += 1
             iTotalFiles = Me.Compiler.CommandLine.Files.Count
             Me.Compiler.Report.WriteLine(Report.ReportLevels.Debug, "Parsing file " & tm.CurrentToken.Location.File.FileName & " (" & iFileCount & " of " & iTotalFiles & " files)")
 #End If
             iLastLocation = tm.CurrentLocation
 
             While tm.AcceptNewLine
 
             End While
             '[  OptionStatement+  ]
             '[  ImportsStatement+  ]
 
             If Me.ParseFileHeader(tm.CurrentLocation.File(Compiler), assembly) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             ''	[  AttributesStatement+  ]
             'If vbnc.Attributes.IsMe(tm) Then
             '    If Me.ParseAttributes(result, AssemblyAttributes) = False Then
             '        Helper.ErrorRecoveryNot    Implemented()
             '    End If
             'End If
 
             '	[  NamespaceMemberDeclaration+  ]
             result = ParseAssemblyMembers(assembly, RootNamespace) AndAlso result
 
             While tm.AcceptNewLine
 
             End While
             tm.AcceptEndOfFile()
             If iLastLocation.Equals(tm.CurrentLocation) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation) AndAlso result
                 tm.GotoNewline(False)
             End If
         Loop
 
         assembly.Init(AssemblyAttributes)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5551" endline="5607">
<![CDATA[
 
     ''' <summary>
     ''' DoLoopStatement  
     ''' DoTopLoopStatement  
     '''	   "Do" [  WhileOrUntil  BooleanExpression  ]  StatementTerminator
     '''	       [  Block  ]
     '''	   "Loop" StatementTerminator
     ''' DoBottomLoopStatement  
     '''	   "Do" StatementTerminator
     '''	       [  Block  ]
     '''	   "Loop" WhileOrUntil  BooleanExpression  StatementTerminator
     '''WhileOrUntil  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDoStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As DoStatement
         Dim result As New DoStatement(Parent)
 
         Dim m_PreCondition As Expression
         Dim m_PostCondition As Expression
         Dim m_IsWhile As Boolean
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Do)
         If tm.CurrentToken.Equals(KS.While, KS.Until) Then
             m_PreCondition = ParseDoStatementCondition(result, m_IsWhile)
             If m_PreCondition Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             End If
         Else
             m_PreCondition = Nothing
         End If
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Loop) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.CurrentToken.Equals(KS.While, KS.Until) Then
             m_PostCondition = ParseDoStatementCondition(result, m_IsWhile)
             If m_PostCondition Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             End If
         Else
             m_PostCondition = Nothing
         End If
 
         result.Init(m_PreCondition, m_PostCondition, m_IsWhile, m_Code)
 
         If m_PreCondition IsNot Nothing AndAlso m_PostCondition IsNot Nothing Then
             'helper.AddError "error BC30238
             Compiler.Report.ShowMessage(Messages.VBNC30238, tm.CurrentLocation)
             result.HasErrors = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1759" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="23" endline="45">
<![CDATA[
     Protected Overrides Function ResolveExpressions(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressions(Info) AndAlso result
 
         If result = False Then Return result
 
         Dim l, lS, r, rS As Boolean
         l = Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_DBNull)
         r = Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_DBNull)
         If l = False Then lS = Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_String)
         If r = False Then rS = Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_String)
 
         If (l AndAlso rS) Then 'DBNull + String
             m_LeftExpression = New NothingConstantExpression(Me)
             result = m_LeftExpression.ResolveExpression(Info) AndAlso result
         ElseIf (lS AndAlso r) Then 'String + DBNull
             m_RightExpression = New NothingConstantExpression(Me)
             result = m_RightExpression.ResolveExpression(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" startline="23" endline="58">
<![CDATA[
     Protected Overrides Function ResolveExpressions(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressions(Info) AndAlso result
 
         If result = False Then Return result
 
         Dim l, r, other As Boolean
         l = Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_DBNull)
         r = Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_DBNull)
         If l AndAlso r = False Then 'DBNull & whatever
             m_LeftExpression = New NothingConstantExpression(Me)
             result = m_LeftExpression.ResolveExpression(Info) AndAlso result
         ElseIf l = False AndAlso r Then 'whatever & DBNull
             m_RightExpression = New NothingConstantExpression(Me)
             result = m_RightExpression.ResolveExpression(Info) AndAlso result
         Else
             other = True
         End If
 
         If l = False Then
             If Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_Char_Array) Then
                 m_LeftExpression = New CStrExpression(Me, m_LeftExpression)
                 result = m_LeftExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If r = False Then
             If Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_Char_Array) Then
                 m_RightExpression = New CStrExpression(Me, m_RightExpression)
                 result = m_RightExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1760" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="82" endline="111">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim startFalse As Label = Emitter.DefineLabel(Info)
         EndLabel = Emitter.DefineLabel(Info)
 
         result = m_Condition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
 
         Emitter.EmitBranchIfFalse(Info, startFalse)
         'True code
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, EndLabel)
 
         'False code
         Emitter.MarkLabel(Info, startFalse)
         If m_ElseIfs IsNot Nothing Then
             For Each eif As ElseIfStatement In m_ElseIfs
                 result = eif.GenerateCode(Info) AndAlso result
             Next
         End If
 
         If m_FalseCode IsNot Nothing Then
             result = m_FalseCode.GenerateCode(Info) AndAlso result
         End If
         Emitter.MarkLabel(Info, EndLabel)
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" startline="73" endline="109">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim expInfo As ExpressionResolveInfo = TryCast(Info, ExpressionResolveInfo)
 
         result = m_Initializer.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         Dim initExp As Expression = TryCast(m_Initializer, Expression)
         If initExp IsNot Nothing Then
             If initExp.Classification.IsValueClassification = False Then
                 If initExp.Classification.IsMethodPointerClassification Then
                     Dim exp As ExpressionResolveInfo = TryCast(Info, ExpressionResolveInfo)
                     If exp IsNot Nothing AndAlso exp.LHSType IsNot Nothing Then
                         initExp = initExp.ReclassifyMethodPointerToValueExpression(exp.LHSType)
                     Else
                         initExp = initExp.ReclassifyToValueExpression
                     End If
                 Else
                     initExp = initExp.ReclassifyToValueExpression
                 End If
                 result = initExp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             End If
 
             If result = False Then Return result
 
             If expInfo IsNot Nothing Then
                 initExp = Helper.CreateTypeConversion(Me, initExp, expInfo.LHSType, result)
             Else
                 Helper.StopIfDebugging()
             End If
             m_Initializer = initExp
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1761" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.SByte
                     Return CSByte(originalValue) 'No range checking needed.
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New SByte
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CSByte(0)
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1762" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                     Return CULng(originalValue) 'No range checking needed.
                 Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New ULong
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New ULong
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1763" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt32
                     Return CLng(originalValue) 'No range checking needed.
                 Case TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Long
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Long
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1764" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="115" endline="137">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Decimal
                     Return CSng(originalValue) 'No range checking needed.
                 Case TypeCode.Double, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Single
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Single
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1765" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="125" endline="149">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte
                     Return CByte(originalValue) 'No range checking needed.
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CByte(0)
                     End If
                 Case TypeCode.DBNull
                     Return CByte(0)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CByte(0)
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1766" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16
                     Return CUShort(originalValue) 'No range checking needed.
                 Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New UShort
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New UShort
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1767" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="133" endline="155">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32
                     Return CUInt(originalValue) 'No range checking needed.
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New UInteger
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New UInteger
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1768" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="126" endline="148">
<![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16
                     Return CShort(originalValue) 'No range checking needed.
                 Case TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Short
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Short
             End Select
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1769" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="234" endline="273">
<![CDATA[
 
 		TypeParameterSpec[] CreateGenericParameters (MetaType type, TypeSpec declaringType)
 		{
 			var tparams = type.GetGenericArguments ();
 
 			int parent_owned_count;
 			if (type.IsNested) {
 				parent_owned_count = type.DeclaringType.GetGenericArguments ().Length;
 
 				//
 				// System.Reflection duplicates parent type parameters for each
 				// nested type with slightly modified properties (eg. different owner)
 				// This just makes things more complicated (think of cloned constraints)
 				// therefore we remap any nested type owned by parent using `type_cache'
 				// to the single TypeParameterSpec
 				//
 				if (declaringType != null && parent_owned_count > 0) {
 					int read_count = 0;
 					while (read_count != parent_owned_count) {
 						var tparams_count = declaringType.Arity;
 						if (tparams_count != 0) {
 							var parent_tp = declaringType.MemberDefinition.TypeParameters;
 							read_count += tparams_count;
 							for (int i = 0; i < tparams_count; i++) {
 								import_cache.Add (tparams[parent_owned_count - read_count + i], parent_tp[i]);
 							}
 							for (int i = 0; i < tparams_count; i++) {
 								import_cache.Add (tparams[parent_owned_count - read_count + i], parent_tp[i]);
 							}
 						}
 
 						declaringType = declaringType.DeclaringType;
 					}
 					while (read_count != parent_owned_count) {
 						var tparams_count = declaringType.Arity;
 						if (tparams_count != 0) {
 							var parent_tp = declaringType.MemberDefinition.TypeParameters;
 							read_count += tparams_count;
 							for (int i = 0; i < tparams_count; i++) {
 								import_cache.Add (tparams[parent_owned_count - read_count + i], parent_tp[i]);
 							}
 						}
 
 						declaringType = declaringType.DeclaringType;
 					}
 				}			
 			} else {
 				parent_owned_count = 0;
 			}
 
 			if (tparams.Length - parent_owned_count == 0)
 				return null;
 
 			return CreateGenericParameters (parent_owned_count, tparams);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="619" endline="651">
<![CDATA[
 
 		// managed calling convention
 		internal static void WriteStandAloneMethodSig(ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
 		{
 			byte flags = 0;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes.Length + optionalParameterTypes.Length);
 			WriteType(module, bb, returnType);
 			foreach (Type t in parameterTypes)
 			{
 				WriteType(module, bb, t);
 			}
 			foreach (Type t in parameterTypes)
 			{
 				WriteType(module, bb, t);
 			}
 			if (optionalParameterTypes.Length > 0)
 			{
 				bb.Write(SENTINEL);
 				foreach (Type t in optionalParameterTypes)
 				{
 					WriteType(module, bb, t);
 				}
 				foreach (Type t in optionalParameterTypes)
 				{
 					WriteType(module, bb, t);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1770" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="234" endline="273">
<![CDATA[
 
 		TypeParameterSpec[] CreateGenericParameters (MetaType type, TypeSpec declaringType)
 		{
 			var tparams = type.GetGenericArguments ();
 
 			int parent_owned_count;
 			if (type.IsNested) {
 				parent_owned_count = type.DeclaringType.GetGenericArguments ().Length;
 
 				//
 				// System.Reflection duplicates parent type parameters for each
 				// nested type with slightly modified properties (eg. different owner)
 				// This just makes things more complicated (think of cloned constraints)
 				// therefore we remap any nested type owned by parent using `type_cache'
 				// to the single TypeParameterSpec
 				//
 				if (declaringType != null && parent_owned_count > 0) {
 					int read_count = 0;
 					while (read_count != parent_owned_count) {
 						var tparams_count = declaringType.Arity;
 						if (tparams_count != 0) {
 							var parent_tp = declaringType.MemberDefinition.TypeParameters;
 							read_count += tparams_count;
 							for (int i = 0; i < tparams_count; i++) {
 								import_cache.Add (tparams[parent_owned_count - read_count + i], parent_tp[i]);
 							}
 							for (int i = 0; i < tparams_count; i++) {
 								import_cache.Add (tparams[parent_owned_count - read_count + i], parent_tp[i]);
 							}
 						}
 
 						declaringType = declaringType.DeclaringType;
 					}
 					while (read_count != parent_owned_count) {
 						var tparams_count = declaringType.Arity;
 						if (tparams_count != 0) {
 							var parent_tp = declaringType.MemberDefinition.TypeParameters;
 							read_count += tparams_count;
 							for (int i = 0; i < tparams_count; i++) {
 								import_cache.Add (tparams[parent_owned_count - read_count + i], parent_tp[i]);
 							}
 						}
 
 						declaringType = declaringType.DeclaringType;
 					}
 				}			
 			} else {
 				parent_owned_count = 0;
 			}
 
 			if (tparams.Length - parent_owned_count == 0)
 				return null;
 
 			return CreateGenericParameters (parent_owned_count, tparams);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="666" endline="704">
<![CDATA[
 
 		internal static void WritePropertySig(ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			byte flags = PROPERTY;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes == null ? 0 
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, returnTypeRequiredCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, returnTypeOptionalCustomModifiers);
 			WriteType(module, bb, returnType);
 			if (parameterTypes != null)
 			{
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterTypeRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
 					}
 					if (parameterTypeOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterTypeRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
 					}
 					if (parameterTypeOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1771" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="275" endline="299">
<![CDATA[
 
     Function Compile_CalculateOutputFilename() As Boolean
         If CommandLine.Out = "" Then
             'Get the first filename
             m_OutFilename = CommandLine.Files(0).FileName
             'Strip the extension
             m_OutFilename = m_OutFilename.Substring(0, m_OutFilename.Length - IO.Path.GetExtension(m_OutFilename).Length)
 
             If m_OutFilename.EndsWith(".") = False Then m_OutFilename &= "."
             'Put on the correct extension
             If CommandLine.Target = vbnc.CommandLine.Targets.Console OrElse CommandLine.Target = vbnc.CommandLine.Targets.Winexe Then
                 m_OutFilename &= "exe"
             ElseIf CommandLine.Target = vbnc.CommandLine.Targets.Library Then
                 m_OutFilename &= "dll"
             ElseIf CommandLine.Target = vbnc.CommandLine.Targets.Module Then
                 m_OutFilename &= "netmodule"
             Else
                 Throw New InternalException(Me)
             End If
         Else
             m_OutFilename = CommandLine.Out
         End If
         m_OutFilename = IO.Path.GetFullPath(m_OutFilename)
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="3398" endline="3438">
<![CDATA[
 
     Private Function ParseIfExpression(ByVal Parent As ParsedObject) As IfExpression
         Dim result As New IfExpression(Parent)
         Dim expressions As ExpressionList
 
         tm.AcceptIfNotInternalError(KS.If)
 
         If Not tm.Accept(KS.LParenthesis) Then
             Compiler.Report.ShowMessage(Messages.VBNC30199, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         If tm.Accept(KS.RParenthesis) Then
             Compiler.Report.ShowMessage(Messages.VBNC33104, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         expressions = ParseExpressionList(result)
 
         If expressions.Count < 2 OrElse expressions.Count > 3 Then
             Compiler.Report.ShowMessage(Messages.VBNC33104, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         If Not tm.Accept(KS.RParenthesis) Then
             Compiler.Report.ShowMessage(Messages.VBNC30198, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         result.Condition = expressions(0)
         result.SecondPart = expressions(1)
         If expressions.Count = 3 Then
             result.ThirdPart = expressions(2)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1772" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="275" endline="299">
<![CDATA[
 
     Function Compile_CalculateOutputFilename() As Boolean
         If CommandLine.Out = "" Then
             'Get the first filename
             m_OutFilename = CommandLine.Files(0).FileName
             'Strip the extension
             m_OutFilename = m_OutFilename.Substring(0, m_OutFilename.Length - IO.Path.GetExtension(m_OutFilename).Length)
 
             If m_OutFilename.EndsWith(".") = False Then m_OutFilename &= "."
             'Put on the correct extension
             If CommandLine.Target = vbnc.CommandLine.Targets.Console OrElse CommandLine.Target = vbnc.CommandLine.Targets.Winexe Then
                 m_OutFilename &= "exe"
             ElseIf CommandLine.Target = vbnc.CommandLine.Targets.Library Then
                 m_OutFilename &= "dll"
             ElseIf CommandLine.Target = vbnc.CommandLine.Targets.Module Then
                 m_OutFilename &= "netmodule"
             Else
                 Throw New InternalException(Me)
             End If
         Else
             m_OutFilename = CommandLine.Out
         End If
         m_OutFilename = IO.Path.GetFullPath(m_OutFilename)
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" startline="66" endline="101">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         If m_Value IsNot Nothing Then
             result = m_Value.GenerateCode(Info) AndAlso result
         ElseIf m_ConstantValue IsNot Nothing Then
             Emitter.EmitLoadValueConstantOrValueAddress(Info, m_ConstantValue)
         ElseIf m_Classification IsNot Nothing Then
             Select Case m_Classification.Classification
                 Case Classifications.Value
                     Throw New InternalException(Me)
                 Case Classifications.Variable
                     result = m_Classification.AsVariableClassification.GenerateCodeAsValue(Info) AndAlso result
                 Case Classifications.MethodPointer
                     If Info.DesiredType IsNot Nothing Then
                         result = m_Classification.AsMethodPointerClassification.GenerateCode(Info) AndAlso result
                     Else
                         Throw New InternalException(Me)
                     End If
                 Case Classifications.MethodGroup
                     result = m_Classification.AsMethodGroupClassification.GenerateCodeAsValue(Info) AndAlso result
                 Case Classifications.PropertyGroup
                     result = m_Classification.AsPropertyGroup.GenerateCodeAsValue(Info) AndAlso result
                 Case Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End Select
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1773" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1085" endline="1129">
<![CDATA[
 
 		//
 		// Is this member accessible from invocationType
 		//
 		public bool IsAccessible (TypeSpec invocationType)
 		{
 			var ma = Modifiers & Modifiers.AccessibilityMask;
 			if (ma == Modifiers.PUBLIC)
 				return true;
 
 			var parentType = /* this as TypeSpec ?? */ DeclaringType;
 
 			// It's null for module context
 			if (invocationType == null)
 				invocationType = InternalType.FakeInternalType;
 		
 			//
 			// If only accessible to the current class or children
 			//
 			if (ma == Modifiers.PRIVATE)
 				return invocationType.MemberDefinition == parentType.MemberDefinition ||
 					TypeManager.IsNestedChildOf (invocationType, parentType.MemberDefinition);
 
 			if ((ma & Modifiers.INTERNAL) != 0) {
 				bool b;
 				var assembly = invocationType == InternalType.FakeInternalType ?
 					RootContext.ToplevelTypes.DeclaringAssembly 
 					invocationType.MemberDefinition.DeclaringAssembly;
 
 				if (parentType == null) {
 					b = ((ITypeDefinition) MemberDefinition).IsInternalAsPublic (assembly);
 				} else {
 					b = DeclaringType.MemberDefinition.IsInternalAsPublic (assembly);
 				}
 
 				if (b || ma == Modifiers.INTERNAL)
 					return b;
 			}
 
 			// PROTECTED
 			if (!TypeManager.IsNestedFamilyAccessible (invocationType, parentType))
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2168" endline="2213">
<![CDATA[
 
 		bool HasDefaultConstructor (TypeSpec atype)
 		{
 			var tp = atype as TypeParameterSpec;
 			if (tp != null) {
 				return tp.HasSpecialConstructor || tp.HasSpecialStruct;
 			}
 
 			if (atype.IsStruct || atype.IsEnum)
 				return true;
 
 			if (atype.IsAbstract)
 				return false;
 
 			var tdef = atype.GetDefinition ();
 
 			//
 			// In some circumstances MemberCache is not yet populated and members
 			// cannot be defined yet (recursive type new constraints)
 			//
 			// class A<T> where T 
 			// class B<T> where T 
 			//
 			var tc = tdef.MemberDefinition as Class;
 			if (tc != null) {
 				if (tc.InstanceConstructors == null) {
 					// Default ctor will be generated later
 					return true;
 				}
 
 				foreach (var c in tc.InstanceConstructors) {
 					if (c.ParameterInfo.IsEmpty) {
 						if ((c.ModFlags & Modifiers.PUBLIC) != 0)
 							return true;
 					}
 				}
 				foreach (var c in tc.InstanceConstructors) {
 					if (c.ParameterInfo.IsEmpty) {
 						if ((c.ModFlags & Modifiers.PUBLIC) != 0)
 							return true;
 					}
 				}
 
 				return false;
 			}
 
 			var found = MemberCache.FindMember (tdef,
 				MemberFilter.Constructor (ParametersCompiled.EmptyReadOnlyParameters),
 				BindingRestriction.DeclaredOnly | BindingRestriction.InstanceOnly);
 
 			return found != null && (found.Modifiers & Modifiers.PUBLIC) != 0;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1774" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1537" endline="1561">
<![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             Dim emittableField As Mono.Cecil.FieldReference = Helper.GetFieldOrFieldReference(Info.Compiler, Variable.FieldInfo)
             If Variable.InstanceExpression IsNot Nothing Then
                 Dim result As Boolean
                 result = Variable.InstanceExpression.GenerateCode(Info)
                 Helper.Assert(result)
                 'Helper.Assert(Variable.FieldInfo.IsStatic = False)
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             Else
                 Helper.Assert(CecilHelper.IsStatic(Variable.FieldInfo))
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             End If
          ElseIf Variable.ParameterInfo IsNot Nothing Then
             Helper.Assert(Variable.InstanceExpression Is Nothing)
             EmitLoadParameterAddress(Info, Variable.ParameterInfo)
         ElseIf Variable.Method IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.Method.DefaultReturnVariable)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1115" endline="1145">
<![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As Integer, ByVal TypeToPushOnStack As Mono.Cecil.TypeReference)
         TypeToPushOnStack = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeToPushOnStack)
         Select Case I
             Case -1
                 Info.ILGen.Emit(OpCodes.Ldc_I4_M1)
             Case 0
                 Info.ILGen.Emit(OpCodes.Ldc_I4_0)
             Case 1
                 Info.ILGen.Emit(OpCodes.Ldc_I4_1)
             Case 2
                 Info.ILGen.Emit(OpCodes.Ldc_I4_2)
             Case 3
                 Info.ILGen.Emit(OpCodes.Ldc_I4_3)
             Case 4
                 Info.ILGen.Emit(OpCodes.Ldc_I4_4)
             Case 5
                 Info.ILGen.Emit(OpCodes.Ldc_I4_5)
             Case 6
                 Info.ILGen.Emit(OpCodes.Ldc_I4_6)
             Case 7
                 Info.ILGen.Emit(OpCodes.Ldc_I4_7)
             Case 8
                 Info.ILGen.Emit(OpCodes.Ldc_I4_8)
             Case SByte.MinValue To SByte.MaxValue
                 Dim sbit As SByte = CSByte(I)
                 Info.ILGen.Emit(OpCodes.Ldc_I4_S, sbit)
             Case Else
                 Info.ILGen.Emit(OpCodes.Ldc_I4, I)
         End Select
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1775" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1537" endline="1561">
<![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             Dim emittableField As Mono.Cecil.FieldReference = Helper.GetFieldOrFieldReference(Info.Compiler, Variable.FieldInfo)
             If Variable.InstanceExpression IsNot Nothing Then
                 Dim result As Boolean
                 result = Variable.InstanceExpression.GenerateCode(Info)
                 Helper.Assert(result)
                 'Helper.Assert(Variable.FieldInfo.IsStatic = False)
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             Else
                 Helper.Assert(CecilHelper.IsStatic(Variable.FieldInfo))
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             End If
          ElseIf Variable.ParameterInfo IsNot Nothing Then
             Helper.Assert(Variable.InstanceExpression Is Nothing)
             EmitLoadParameterAddress(Info, Variable.ParameterInfo)
         ElseIf Variable.Method IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.Method.DefaultReturnVariable)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1008" endline="1048">
<![CDATA[
 
 
     ''' <summary>
     ''' Type = the type of the element. (not of the array.)
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitStoreElement(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Int32, TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Stelem_I4)
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Stelem_I1)
             Case TypeCode.Int16, TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Stelem_I2)
             Case TypeCode.Int64, TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Stelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Stelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Stelem_R8)
             Case TypeCode.DateTime, TypeCode.Decimal
                 EmitStoreObject(Info, ElementType)
                 Return
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Stelem_Ref)
             Case TypeCode.Object
                 If CecilHelper.IsValueType(ElementType) Then
                     Info.ILGen.Emit(OpCodes.Stobj, ElementType)
                 ElseIf CecilHelper.IsGenericParameter(ElementType) Then
                     Info.ILGen.Emit(OpCodes.Stelem_Any, ElementType)
                 Else
                     Info.ILGen.Emit(OpCodes.Stelem_Ref)
                 End If
             Case Else
                 Helper.Stop()
         End Select
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1776" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1537" endline="1561">
<![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             Dim emittableField As Mono.Cecil.FieldReference = Helper.GetFieldOrFieldReference(Info.Compiler, Variable.FieldInfo)
             If Variable.InstanceExpression IsNot Nothing Then
                 Dim result As Boolean
                 result = Variable.InstanceExpression.GenerateCode(Info)
                 Helper.Assert(result)
                 'Helper.Assert(Variable.FieldInfo.IsStatic = False)
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             Else
                 Helper.Assert(CecilHelper.IsStatic(Variable.FieldInfo))
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             End If
          ElseIf Variable.ParameterInfo IsNot Nothing Then
             Helper.Assert(Variable.InstanceExpression Is Nothing)
             EmitLoadParameterAddress(Info, Variable.ParameterInfo)
         ElseIf Variable.Method IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.Method.DefaultReturnVariable)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" startline="94" endline="119">
<![CDATA[
 
     Private Function CreateAddHandlerCode(ByVal Info As EmitInfo) As Boolean
         Helper.Assert([EventParent].EventField IsNot Nothing)
         If Me.IsShared = False Then
             With Info.ILGen
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_1)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Combine), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         Else
             With Info.ILGen
                 .Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_0)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Combine), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         End If
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1777" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1537" endline="1561">
<![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             Dim emittableField As Mono.Cecil.FieldReference = Helper.GetFieldOrFieldReference(Info.Compiler, Variable.FieldInfo)
             If Variable.InstanceExpression IsNot Nothing Then
                 Dim result As Boolean
                 result = Variable.InstanceExpression.GenerateCode(Info)
                 Helper.Assert(result)
                 'Helper.Assert(Variable.FieldInfo.IsStatic = False)
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             Else
                 Helper.Assert(CecilHelper.IsStatic(Variable.FieldInfo))
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             End If
          ElseIf Variable.ParameterInfo IsNot Nothing Then
             Helper.Assert(Variable.InstanceExpression Is Nothing)
             EmitLoadParameterAddress(Info, Variable.ParameterInfo)
         ElseIf Variable.Method IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.Method.DefaultReturnVariable)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="942" endline="974">
<![CDATA[
 
     Shared Sub EmitLoadElement(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldelem_U1)
             Case TypeCode.SByte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldelem_I1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldelem_U2)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldelem_I2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldelem_U4)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldelem_I4)
             Case TypeCode.UInt64, TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldelem_R8)
             Case TypeCode.Object, TypeCode.String, TypeCode.DateTime, TypeCode.Decimal
                 If CecilHelper.IsValueType(ElementType) Then
                     Throw New InternalException("")
                 Else
                     Info.ILGen.Emit(OpCodes.Ldelem_Ref)
                 End If
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1778" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1537" endline="1561">
<![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             Dim emittableField As Mono.Cecil.FieldReference = Helper.GetFieldOrFieldReference(Info.Compiler, Variable.FieldInfo)
             If Variable.InstanceExpression IsNot Nothing Then
                 Dim result As Boolean
                 result = Variable.InstanceExpression.GenerateCode(Info)
                 Helper.Assert(result)
                 'Helper.Assert(Variable.FieldInfo.IsStatic = False)
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             Else
                 Helper.Assert(CecilHelper.IsStatic(Variable.FieldInfo))
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             End If
          ElseIf Variable.ParameterInfo IsNot Nothing Then
             Helper.Assert(Variable.InstanceExpression Is Nothing)
             EmitLoadParameterAddress(Info, Variable.ParameterInfo)
         ElseIf Variable.Method IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.Method.DefaultReturnVariable)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1682" endline="1732">
<![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified address.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ByRefType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadIndirect(ByVal Info As EmitInfo, ByVal ByRefType As Mono.Cecil.TypeReference)
         ByRefType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ByRefType)
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ByRefType)
         Select Case Helper.GetTypeCode(Info.Compiler, elementtype)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldind_U1)
             Case TypeCode.SByte
                 Info.ILGen.Emit(OpCodes.Ldind_I1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldind_U2)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldind_I2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldind_U4)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldind_I4)
             Case TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Ldind_I8)
             Case TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldind_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldind_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldind_R8)
             Case TypeCode.String, TypeCode.DBNull
                 Info.ILGen.Emit(OpCodes.Ldind_Ref)
             Case TypeCode.Object
                 If elementtype.IsValueType Then
                     Info.ILGen.Emit(OpCodes.Ldobj, elementtype)
                 Else
                     Info.ILGen.Emit(OpCodes.Ldind_Ref)
                 End If
             Case TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldind_I1)
             Case TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Ldobj, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal))
             Case Else
                 If elementtype.IsValueType Then
                     Info.ILGen.Emit(OpCodes.Ldobj, elementtype)
                 Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
                 End If
         End Select
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1779" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="46" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="23" endline="57">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo.Clone(Me, Compiler.TypeCache.System_Int32)) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte
                 Dim shift As Integer
                 Select Case OperandTypeCode
                     Case TypeCode.Byte, TypeCode.SByte
                         shift = 7
                     Case TypeCode.Int16, TypeCode.UInt16
                         shift = 15
                     Case TypeCode.Int32, TypeCode.UInt32
                         shift = 31
                     Case TypeCode.Int64, TypeCode.UInt64
                         shift = 63
                 End Select
                 Emitter.EmitLoadI4Value(Info, shift)
                 Emitter.EmitAnd(Info, Info.Compiler.TypeCache.System_Int32)
                 Emitter.EmitLShift(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__LeftShiftObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1780" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="46" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="23" endline="58">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo.Clone(Me, Compiler.TypeCache.System_Int32)) AndAlso result
 
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte
                 Dim shift As Integer
                 Select Case OperandTypeCode
                     Case TypeCode.Byte, TypeCode.SByte
                         shift = 7
                     Case TypeCode.Int16, TypeCode.UInt16
                         shift = 15
                     Case TypeCode.Int32, TypeCode.UInt32
                         shift = 31
                     Case TypeCode.Int64, TypeCode.UInt64
                         shift = 63
                 End Select
                 Emitter.EmitLoadI4Value(Info, shift)
                 Emitter.EmitAnd(Info, Info.Compiler.TypeCache.System_Int32)
                 Emitter.EmitRShift(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__RightShiftObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1781" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="46" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="23" endline="58">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Boolean, TypeCode.Char
                 Emitter.EmitNotEquals(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitNotEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitnotEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectNotEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitNotEquals(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1782" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="46" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLE(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitGE(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitGE_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectGreaterEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1783" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="46" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLT(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitGT(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitGT_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectGreater_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1784" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="46" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitGE(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitLE(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitLE_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectLessEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1785" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" startline="46" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" startline="23" endline="62">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitGT(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitLT(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitLT_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectLess_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1786" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3806" endline="3850">
<![CDATA[
 
 		protected virtual void EmitOperator (EmitContext ec, TypeSpec l)
 		{
 			//
 			// Handle short-circuit operators differently
 			// than the rest
 			//
 			if ((oper & Operator.LogicalMask) != 0) {
 				Label load_result = ec.DefineLabel ();
 				Label end = ec.DefineLabel ();
 
 				bool is_or = oper == Operator.LogicalOr;
 				left.EmitBranchable (ec, load_result, is_or);
 				right.Emit (ec);
 				ec.Emit (OpCodes.Br_S, end);
 				
 				ec.MarkLabel (load_result);
 				ec.Emit (is_or ? OpCodes.Ldc_I4_1 
 				ec.MarkLabel (end);
 				return;
 			}
 
 			//
 			// Optimize zero-based operations which cannot be optimized at expression level
 			//
 			if (oper == Operator.Subtraction) {
 				var lc = left as IntegralConstant;
 				if (lc != null && lc.IsDefaultValue) {
 					right.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 					return;
 				}
 			}
 
 			left.Emit (ec);
 			right.Emit (ec);
 			EmitOperatorOpcode (ec, oper, l);
 
 			//
 			// Nullable enum could require underlying type cast and we cannot simply wrap binary
 			// expression because that would wrap lifted binary operation
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="478" endline="525">
<![CDATA[
 
 		protected void EmitOperator (EmitContext ec, TypeSpec type)
 		{
 			switch (Oper) {
 			case Operator.UnaryPlus
 				Expr.Emit (ec);
 				break;
 				
 			case Operator.UnaryNegation
 				if (ec.HasSet (EmitContext.Options.CheckedScope) && !IsFloat (type)) {
 					ec.Emit (OpCodes.Ldc_I4_0);
 					if (type == TypeManager.int64_type)
 						ec.Emit (OpCodes.Conv_U8);
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Sub_Ovf);
 				} else {
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 				}
 				
 				break;
 				
 			case Operator.LogicalNot
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				ec.Emit (OpCodes.Ceq);
 				break;
 				
 			case Operator.OnesComplement
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Not);
 				break;
 				
 			case Operator.AddressOf
 				((IMemoryLocation)Expr).AddressOf (ec, AddressOp.LoadStore);
 				break;
 				
 			default
 				throw new Exception ("This should not happen
 						     + Oper.ToString ());
 			}
 
 			//
 			// Same trick as in Binary expression
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1787" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3806" endline="3850">
<![CDATA[
 
 		protected virtual void EmitOperator (EmitContext ec, TypeSpec l)
 		{
 			//
 			// Handle short-circuit operators differently
 			// than the rest
 			//
 			if ((oper & Operator.LogicalMask) != 0) {
 				Label load_result = ec.DefineLabel ();
 				Label end = ec.DefineLabel ();
 
 				bool is_or = oper == Operator.LogicalOr;
 				left.EmitBranchable (ec, load_result, is_or);
 				right.Emit (ec);
 				ec.Emit (OpCodes.Br_S, end);
 				
 				ec.MarkLabel (load_result);
 				ec.Emit (is_or ? OpCodes.Ldc_I4_1 
 				ec.MarkLabel (end);
 				return;
 			}
 
 			//
 			// Optimize zero-based operations which cannot be optimized at expression level
 			//
 			if (oper == Operator.Subtraction) {
 				var lc = left as IntegralConstant;
 				if (lc != null && lc.IsDefaultValue) {
 					right.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 					return;
 				}
 			}
 
 			left.Emit (ec);
 			right.Emit (ec);
 			EmitOperatorOpcode (ec, oper, l);
 
 			//
 			// Nullable enum could require underlying type cast and we cannot simply wrap binary
 			// expression because that would wrap lifted binary operation
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="531" endline="581">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (InitStatement != null)
 				InitStatement.Emit (ec);
 
 			if (empty) {
 				Test.EmitSideEffect (ec);
 				return;
 			}
 
 			Label old_begin = ec.LoopBegin;
 			Label old_end = ec.LoopEnd;
 			Label loop = ec.DefineLabel ();
 			Label test = ec.DefineLabel ();
 
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 
 			ec.Emit (OpCodes.Br, test);
 			ec.MarkLabel (loop);
 			Statement.Emit (ec);
 
 			ec.MarkLabel (ec.LoopBegin);
 			Increment.Emit (ec);
 
 			ec.MarkLabel (test);
 			//
 			// If test is null, there is no test, and we are just
 			// an infinite loop
 			//
 			if (Test != null){
 				//
 				// The Resolve code already catches the case for
 				// Test == Constant (false) so we know that
 				// this is true
 				//
 				if (Test is Constant) {
 					Test.EmitSideEffect (ec);
 					ec.Emit (OpCodes.Br, loop);
 				} else {
 					Test.EmitBranchable (ec, loop, true);
 				}
 				
 			} else
 				ec.Emit (OpCodes.Br, loop);
 			ec.MarkLabel (ec.LoopEnd);
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1788" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="162" endline="193">
<![CDATA[
 
  		protected override bool CheckBase ()
 		{
  			if (!base.CheckBase ())
  				return false;
 
 			MemberSpec candidate;
 			var conflict_symbol = MemberCache.FindBaseMember (this, out candidate);
 			if (conflict_symbol == null)
 				conflict_symbol = candidate;
 
  			if (conflict_symbol == null) {
  				if ((ModFlags & Modifiers.NEW) != 0) {
  					Report.Warning (109, 4, Location, "The member `{0}' does not hide an inherited member. The new keyword is not required",
 						GetSignatureForError ());
  				}
  			} else {
 				if ((ModFlags & (Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.BACKING_FIELD)) == 0) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Warning (108, 2, Location, "`{0}' hides inherited member `{1}'. Use the new keyword if hiding was intended",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 
 				if (conflict_symbol.IsAbstract) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Error (533, Location, "`{0}' hides inherited abstract member `{1}'",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 			}
  
  			return true;
  		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5462" endline="5495">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				// TODO
 				INamedBlockVariable variable = null;
 				if (best_candidate != null && ec.CurrentBlock.ParametersBlock.TopBlock.GetLocalName (best_candidate.Name, ec.CurrentBlock, ref variable) && variable is Linq.RangeVariable) {
 					ec.Report.Error (1939, loc, "A range variable `{0}' may not be passes as `ref' or `out' parameter",
 						best_candidate.Name);
 				} else {
 					right_side.DoResolveLValue (ec, this);
 				}
 				return null;
 			}
 
 			// if the property/indexer returns a value type, and we try to set a field in it
 			if (right_side == EmptyExpression.LValueMemberAccess || right_side == EmptyExpression.LValueMemberOutAccess) {
 				Error_CannotModifyIntermediateExpressionValue (ec);
 			}
 
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, right_side);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.ResolveLValue (ec, right_side);
 			}
 
 			if (!ResolveSetter (ec))
 				return null;
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1789" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="477" endline="507">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="540" endline="588">
<![CDATA[
 
 		public virtual void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			if (builder != null)
 				throw new InternalErrorException ("builder already exists");
 
 			var pattrs = ParametersCompiled.GetParameterAttribute (modFlags);
 			if (HasOptionalExpression)
 				pattrs |= ParameterAttributes.Optional;
 
 			if (mb == null)
 				builder = cb.DefineParameter (index, pattrs, Name);
 			else
 				builder = mb.DefineParameter (index, pattrs, Name);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (HasDefaultValue) {
 				//
 				// Emit constant values for true constants only, the other
 				// constant-like expressions will rely on default value expression
 				//
 				var def_value = DefaultValue;
 				Constant c = def_value != null ? def_value.Child as Constant 
 				if (c != null) {
 					if (default_expr.Type == TypeManager.decimal_type) {
 						pa.DecimalConstant.EmitAttribute (builder, (decimal) c.GetValue (), c.Location);
 					} else {
 						builder.SetConstant (c.GetValue ());
 					}
 				} else if (default_expr.Type.IsStruct) {
 					//
 					// Handles special case where default expression is used with value-type
 					//
 					// void Foo (S s = default (S)) {}
 					//
 					builder.SetConstant (null);
 				}
 			}
 
 			if (parameter_type != null) {
 				if (parameter_type == InternalType.Dynamic) {
 					pa.Dynamic.EmitAttribute (builder);
 				} else if (parameter_type.HasDynamicElement) {
 					pa.Dynamic.EmitAttribute (builder, parameter_type, Location);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1790" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="477" endline="507">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1738" endline="1775">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if (!IsTopLevel) {
 				MemberSpec candidate;
 				var conflict_symbol = MemberCache.FindBaseMember (this, out candidate);
 				if (conflict_symbol == null && candidate == null) {
 					if ((ModFlags & Modifiers.NEW) != 0)
 						Report.Warning (109, 4, Location, "The member `{0}' does not hide an inherited member. The new keyword is not required",
 							GetSignatureForError ());
 				} else {
 					if ((ModFlags & Modifiers.NEW) == 0) {
 						if (candidate == null)
 							candidate = conflict_symbol;
 
 						Report.SymbolRelatedToPreviousError (candidate);
 						Report.Warning (108, 2, Location, "`{0}' hides inherited member `{1}'. Use the new keyword if hiding was intended",
 							GetSignatureForError (), candidate.GetSignatureForError ());
 					}
 				}
 			}
 
 			if (all_tp_builders != null) {
 				int current_starts_index = CurrentTypeParametersStartIndex;
 				for (int i = 0; i < all_tp_builders.Length; i++) {
 					if (i < current_starts_index) {
 						TypeParameters[i].EmitConstraints (all_tp_builders [i]);
 					} else {
 						CurrentTypeParameters [i - current_starts_index].Emit ();
 					}
 				}
 				for (int i = 0; i < all_tp_builders.Length; i++) {
 					if (i < current_starts_index) {
 						TypeParameters[i].EmitConstraints (all_tp_builders [i]);
 					} else {
 						CurrentTypeParameters [i - current_starts_index].Emit ();
 					}
 				}
 			}
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (TypeBuilder);
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1791" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1700" endline="1716">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			Type[] int32 = new Type[] { this.Module.universe.System_Int32 };
 			List<MethodBase> list = new List<MethodBase>();
 			list.Add(new BuiltinArrayMethod(this.Module, this, "Set", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, new Type[] { this.Module.universe.System_Int32, elementType }));
 			list.Add(new BuiltinArrayMethod(this.Module, this, "Address", CallingConventions.Standard | CallingConventions.HasThis, elementType.MakeByRefType(), int32));
 			list.Add(new BuiltinArrayMethod(this.Module, this, "Get", CallingConventions.Standard | CallingConventions.HasThis, elementType, int32));
 			list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
 			for (Type type = elementType; type.__IsVector; type = type.GetElementType())
 			{
 				Array.Resize(ref int32, int32.Length + 1);
 				int32[int32.Length - 1] = int32[0];
 				list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
 			}
 			for (Type type = elementType; type.__IsVector; type = type.GetElementType())
 			{
 				Array.Resize(ref int32, int32.Length + 1);
 				int32[int32.Length - 1] = int32[0];
 				list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1777" endline="1800">
<![CDATA[
 		}
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			Type int32 = this.Module.universe.System_Int32;
 			Type[] setArgs = new Type[rank + 1];
 			Type[] getArgs = new Type[rank];
 			Type[] ctorArgs = new Type[rank * 2];
 			for (int i = 0; i < rank; i++)
 			{
 				setArgs[i] = int32;
 				getArgs[i] = int32;
 				ctorArgs[i * 2 + 0] = int32;
 				ctorArgs[i * 2 + 1] = int32;
 			}
 			for (int i = 0; i < rank; i++)
 			{
 				setArgs[i] = int32;
 				getArgs[i] = int32;
 				ctorArgs[i * 2 + 0] = int32;
 				ctorArgs[i * 2 + 1] = int32;
 			}
 			setArgs[rank] = elementType;
 			return new MethodBase[] {
 				new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, getArgs)),
 				new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, ctorArgs)),
 				new BuiltinArrayMethod(this.Module, this, "Set", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, setArgs),
 				new BuiltinArrayMethod(this.Module, this, "Address", CallingConventions.Standard | CallingConventions.HasThis, elementType.MakeByRefType(), getArgs),
 				new BuiltinArrayMethod(this.Module, this, "Get", CallingConventions.Standard | CallingConventions.HasThis, elementType, getArgs),
 			};
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1792" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1700" endline="1716">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			Type[] int32 = new Type[] { this.Module.universe.System_Int32 };
 			List<MethodBase> list = new List<MethodBase>();
 			list.Add(new BuiltinArrayMethod(this.Module, this, "Set", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, new Type[] { this.Module.universe.System_Int32, elementType }));
 			list.Add(new BuiltinArrayMethod(this.Module, this, "Address", CallingConventions.Standard | CallingConventions.HasThis, elementType.MakeByRefType(), int32));
 			list.Add(new BuiltinArrayMethod(this.Module, this, "Get", CallingConventions.Standard | CallingConventions.HasThis, elementType, int32));
 			list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
 			for (Type type = elementType; type.__IsVector; type = type.GetElementType())
 			{
 				Array.Resize(ref int32, int32.Length + 1);
 				int32[int32.Length - 1] = int32[0];
 				list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
 			}
 			for (Type type = elementType; type.__IsVector; type = type.GetElementType())
 			{
 				Array.Resize(ref int32, int32.Length + 1);
 				int32[int32.Length - 1] = int32[0];
 				list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="228" endline="295">
<![CDATA[
 
 		private static CustomAttributeTypedArgument ReadFixedArg(Assembly asm, ByteReader br, Type type)
 		{
 			Universe u = asm.universe;
 			if (type == u.System_String)
 			{
 				return new CustomAttributeTypedArgument(type, br.ReadString());
 			}
 			else if (type == u.System_Type)
 			{
 				return new CustomAttributeTypedArgument(type, ReadType(asm, br));
 			}
 			else if (type == u.System_Object)
 			{
 				return ReadFixedArg(asm, br, ReadFieldOrPropType(asm, br));
 			}
 			else if (type.IsArray)
 			{
 				int length = br.ReadInt32();
 				if (length == -1)
 				{
 					return new CustomAttributeTypedArgument(type, null);
 				}
 				Type elementType = type.GetElementType();
 				CustomAttributeTypedArgument[] array = new CustomAttributeTypedArgument[length];
 				for (int i = 0; i < length; i++)
 				{
 					array[i] = ReadFixedArg(asm, br, elementType);
 				}
 				for (int i = 0; i < length; i++)
 				{
 					array[i] = ReadFixedArg(asm, br, elementType);
 				}
 				return new CustomAttributeTypedArgument(type, array);
 			}
 			else if (type.IsEnum)
 			{
 				return new CustomAttributeTypedArgument(type, ReadFixedArg(asm, br, type.GetEnumUnderlyingTypeImpl()).Value);
 			}
 			else
 			{
 				switch (Type.GetTypeCode(type))
 				{
 					case TypeCode.Boolean
 						return new CustomAttributeTypedArgument(type, br.ReadByte() != 0);
 					case TypeCode.Char
 						return new CustomAttributeTypedArgument(type, br.ReadChar());
 					case TypeCode.Single
 						return new CustomAttributeTypedArgument(type, br.ReadSingle());
 					case TypeCode.Double
 						return new CustomAttributeTypedArgument(type, br.ReadDouble());
 					case TypeCode.SByte
 						return new CustomAttributeTypedArgument(type, br.ReadSByte());
 					case TypeCode.Int16
 						return new CustomAttributeTypedArgument(type, br.ReadInt16());
 					case TypeCode.Int32
 						return new CustomAttributeTypedArgument(type, br.ReadInt32());
 					case TypeCode.Int64
 						return new CustomAttributeTypedArgument(type, br.ReadInt64());
 					case TypeCode.Byte
 						return new CustomAttributeTypedArgument(type, br.ReadByte());
 					case TypeCode.UInt16
 						return new CustomAttributeTypedArgument(type, br.ReadUInt16());
 					case TypeCode.UInt32
 						return new CustomAttributeTypedArgument(type, br.ReadUInt32());
 					case TypeCode.UInt64
 						return new CustomAttributeTypedArgument(type, br.ReadUInt64());
 					default
 						throw new InvalidOperationException();
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1793" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="234" endline="264">
<![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="517" endline="547">
<![CDATA[
 
     Function RuleXor(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleOr_OrElse(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Xor)
             NextToken()
             RuleOr_OrElse(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             Else
                 LSide = op1 Xor op2
             End If
         End While
         While CurrentToken.Equals(KS.Xor)
             NextToken()
             RuleOr_OrElse(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             Else
                 LSide = op1 Xor op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1794" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="234" endline="264">
<![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="105" endline="135">
<![CDATA[
 
     Function RuleExponent(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIdentifier(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Power)
             NextToken()
             RuleIdentifier(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             Else
                 LSide = op1 ^ op2
             End If
         End While
         While CurrentToken.Equals(KS.Power)
             NextToken()
             RuleIdentifier(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             Else
                 LSide = op1 ^ op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1795" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="234" endline="264">
<![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="482" endline="516">
<![CDATA[
 
     Function RuleOr_OrElse(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleAnd_AndAlso(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Or, KS.OrElse)
             Dim DoElse As Boolean
             DoElse = CurrentToken.Equals(KS.OrElse)
             NextToken()
             RuleAnd_AndAlso(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoElse Then
                 LSide = op1 OrElse op2 'Since its a constant expression, there's no difference between Or & OrElse
             Else
                 LSide = op1 Or op2
             End If
         End While
         While CurrentToken.Equals(KS.Or, KS.OrElse)
             Dim DoElse As Boolean
             DoElse = CurrentToken.Equals(KS.OrElse)
             NextToken()
             RuleAnd_AndAlso(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoElse Then
                 LSide = op1 OrElse op2 'Since its a constant expression, there's no difference between Or & OrElse
             Else
                 LSide = op1 Or op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1796" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="234" endline="264">
<![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="447" endline="481">
<![CDATA[
 
     Function RuleAnd_AndAlso(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleNot(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim DoAlso As Boolean
             DoAlso = CurrentToken.Equals(KS.AndAlso)
             NextToken()
             RuleNot(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoAlso Then
                 LSide = op1 AndAlso op2 'Since its a constant expression, there's no difference between And & AndAlso
             Else
                 LSide = op1 And op2
             End If
         End While
         While CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim DoAlso As Boolean
             DoAlso = CurrentToken.Equals(KS.AndAlso)
             NextToken()
             RuleNot(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoAlso Then
                 LSide = op1 AndAlso op2 'Since its a constant expression, there's no difference between And & AndAlso
             Else
                 LSide = op1 And op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1797" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="234" endline="264">
<![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="159" endline="199">
<![CDATA[
 
     Function RuleMultiplicationAndRealDivision(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleUnaryNegation(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim DoMult As Boolean
             DoMult = CurrentToken.Equals(KS.Mult)
             NextToken()
 
             RuleUnaryNegation(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoMult Then
                 LSide = op1 * op2
             Else
                 If op2 = 0 Then
                     Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                     LSide = CDbl(0)
                 Else
                     LSide = op1 / op2
                 End If
             End If
         End While
         While CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim DoMult As Boolean
             DoMult = CurrentToken.Equals(KS.Mult)
             NextToken()
 
             RuleUnaryNegation(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoMult Then
                 LSide = op1 * op2
             Else
                 If op2 = 0 Then
                     Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                     LSide = CDbl(0)
                 Else
                     LSide = op1 / op2
                 End If
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1798" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="234" endline="264">
<![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" startline="346" endline="385">
<![CDATA[
 
     Function RuleArithmeticBitshift(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleStringConcat(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.ShiftLeft, KS.ShiftRight)
             Dim DoLeft As Boolean
             DoLeft = CurrentToken.Equals(KS.ShiftLeft)
             NextToken()
             RuleStringConcat(RSide)
 
             Dim op1 As Double, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Integer.ToString)
                 bErr = True
             End If
             If op1 < Long.MinValue OrElse op1 > Long.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Long.ToString)
             ElseIf op2 < Integer.MinValue OrElse op2 > Integer.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Integer.ToString)
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoLeft Then
                 LSide = CLng(op1) << CInt(op2)
             Else
                 LSide = CLng(op1) >> CInt(op2)
             End If
         End While
         While CurrentToken.Equals(KS.ShiftLeft, KS.ShiftRight)
             Dim DoLeft As Boolean
             DoLeft = CurrentToken.Equals(KS.ShiftLeft)
             NextToken()
             RuleStringConcat(RSide)
 
             Dim op1 As Double, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Integer.ToString)
                 bErr = True
             End If
             If op1 < Long.MinValue OrElse op1 > Long.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Long.ToString)
             ElseIf op2 < Integer.MinValue OrElse op2 > Integer.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Integer.ToString)
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoLeft Then
                 LSide = CLng(op1) << CInt(op2)
             Else
                 LSide = CLng(op1) >> CInt(op2)
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1799" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="291" endline="337">
<![CDATA[
 
     Public Shared Function EmitLateGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateGet
 
         If LateBoundAccess.InstanceExpression Is Nothing Then
             '1 - the instance expression (none in this case)
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
             '2 - Type 
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         Else
             '1 - the instance expression
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
             '2 - Type  - we have the instance, so no need to pass the type here.
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="406" endline="455">
<![CDATA[
 
     Public Shared Function EmitLateCall(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateCall
 
         '1 - the instance expression
         If LateBoundAccess.InstanceExpression IsNot Nothing Then
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Object))
         End If
 
         '2 - Type
         If LateBoundAccess.LateBoundType Is Nothing Then
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         Else
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         '8 - Ignore return
         Emitter.EmitLoadI4Value(Info, 1)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateCall_Object_Type_String_Array_Array_Array_Array_Boolean)
 
         Emitter.EmitPop(Info, Info.Compiler.TypeCache.System_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1800" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="291" endline="337">
<![CDATA[
 
     Public Shared Function EmitLateGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateGet
 
         If LateBoundAccess.InstanceExpression Is Nothing Then
             '1 - the instance expression (none in this case)
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
             '2 - Type 
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         Else
             '1 - the instance expression
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
             '2 - Type  - we have the instance, so no need to pass the type here.
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" startline="66" endline="112">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_When IsNot Nothing Then
             Dim EndWhen, DoWhenComparison As Label
             EndWhen = Emitter.DefineLabel(Info)
             DoWhenComparison = Emitter.DefineLabel(Info)
 
             Emitter.EmitBeginExceptionFilter(Info)
             'Check if the exception object is of type System.Exception.
             Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_Exception)
             Emitter.EmitDup(Info)
             'If True, do the comparison
             Emitter.EmitBranchIfTrue(Info, DoWhenComparison, Compiler.TypeCache.System_Exception)
             'Otherwise load a false value and go to the end of the filter.
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Exception)
             Emitter.EmitLoadValue(Info, False)
             Emitter.EmitBranch(Info, EndWhen)
 
             'Do the when clause.
             Emitter.MarkLabel(Info, DoWhenComparison)
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Exception)
             result = m_When.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.MarkLabel(Info, EndWhen)
             Emitter.EmitBeginCatch(Info, Nothing)
         Else
             Helper.Assert(m_ExceptionType IsNot Nothing)
             Emitter.EmitBeginCatch(Info, m_ExceptionType)
         End If
 
         If m_VariableDeclaration Is Nothing Then
             If m_ExceptionType Is Nothing Then
                 Emitter.EmitPop(Info, Compiler.TypeCache.System_Object)
             Else
                 Emitter.EmitPop(Info, m_ExceptionType)
             End If
         Else
             result = m_VariableDeclaration.GenerateCode(Info) AndAlso result
             Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, m_ExceptionType)
             Emitter.EmitStoreVariable(Info, m_VariableDeclaration.LocalBuilder)
         End If
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1801" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="385" endline="421">
<![CDATA[
 
 		public static MemberSpec FindMember (TypeSpec container, MemberFilter filter, BindingRestriction restrictions)
 		{
 			do {
 				IList<MemberSpec> applicable;
 				if (container.MemberCache.member_hash.TryGetValue (filter.Name, out applicable)) {
 					// Start from the end because interface members are in reverse order
 					for (int i = applicable.Count - 1; i >= 0; i--) {
 						var entry = applicable [i];
 
 						if ((restrictions & BindingRestriction.InstanceOnly) != 0 && entry.IsStatic)
 							continue;
 
 						if ((restrictions & BindingRestriction.NoAccessors) != 0 && entry.IsAccessor)
 							continue;
 
 						if ((restrictions & BindingRestriction.OverrideOnly) != 0 && (entry.Modifiers & Modifiers.OVERRIDE) == 0)
 							continue;
 
 						if (!filter.Equals (entry))
 							continue;
 
 						if ((restrictions & BindingRestriction.DeclaredOnly) != 0 && container.IsInterface && entry.DeclaringType != container)
 							continue;
 
 						return entry;
 					for (int i = applicable.Count - 1; i >= 0; i--) {
 						var entry = applicable [i];
 
 						if ((restrictions & BindingRestriction.InstanceOnly) != 0 && entry.IsStatic)
 							continue;
 
 						if ((restrictions & BindingRestriction.NoAccessors) != 0 && entry.IsAccessor)
 							continue;
 
 						if ((restrictions & BindingRestriction.OverrideOnly) != 0 && (entry.Modifiers & Modifiers.OVERRIDE) == 0)
 							continue;
 
 						if (!filter.Equals (entry))
 							continue;
 
 						if ((restrictions & BindingRestriction.DeclaredOnly) != 0 && container.IsInterface && entry.DeclaringType != container)
 							continue;
 
 						return entry;
 					}
 				}
 
 				if ((restrictions & BindingRestriction.DeclaredOnly) != 0)
 					break;
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1549" endline="1600">
<![CDATA[
 
 		//
 		// Accepts exactly count (4 or 8) hex, no more no less
 		//
 		int getHex (int count, out int surrogate, out bool error)
 		{
 			int i;
 			int total = 0;
 			int c;
 			int top = count != -1 ? count 
 			
 			get_char ();
 			error = false;
 			surrogate = 0;
 			for (i = 0; i < top; i++){
 				c = get_char ();
 
 				if (c >= '0' && c <= '9')
 					c = (int) c - (int) '0';
 				else if (c >= 'A' && c <= 'F')
 					c = (int) c - (int) 'A' + 10;
 				else if (c >= 'a' && c <= 'f')
 					c = (int) c - (int) 'a' + 10;
 				else {
 					error = true;
 					return 0;
 				}
 				
 				total = (total * 16) + c;
 				if (count == -1){
 					int p = peek_char ();
 					if (p == -1)
 						break;
 					if (!is_hex ((char)p))
 						break;
 				}
 			}
 			for (i = 0; i < top; i++){
 				c = get_char ();
 
 				if (c >= '0' && c <= '9')
 					c = (int) c - (int) '0';
 				else if (c >= 'A' && c <= 'F')
 					c = (int) c - (int) 'A' + 10;
 				else if (c >= 'a' && c <= 'f')
 					c = (int) c - (int) 'a' + 10;
 				else {
 					error = true;
 					return 0;
 				}
 				
 				total = (total * 16) + c;
 				if (count == -1){
 					int p = peek_char ();
 					if (p == -1)
 						break;
 					if (!is_hex ((char)p))
 						break;
 				}
 			}
 
 			if (top == 8) {
 				if (total > 0x0010FFFF) {
 					error = true;
 					return 0;
 				}
 
 				if (total >= 0x00010000) {
 					surrogate = ((total - 0x00010000) % 0x0400 + 0xDC00);					
 					total = ((total - 0x00010000) / 0x0400 + 0xD800);
 				}
 			}
 
 			return total;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1802" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="385" endline="421">
<![CDATA[
 
 		public static MemberSpec FindMember (TypeSpec container, MemberFilter filter, BindingRestriction restrictions)
 		{
 			do {
 				IList<MemberSpec> applicable;
 				if (container.MemberCache.member_hash.TryGetValue (filter.Name, out applicable)) {
 					// Start from the end because interface members are in reverse order
 					for (int i = applicable.Count - 1; i >= 0; i--) {
 						var entry = applicable [i];
 
 						if ((restrictions & BindingRestriction.InstanceOnly) != 0 && entry.IsStatic)
 							continue;
 
 						if ((restrictions & BindingRestriction.NoAccessors) != 0 && entry.IsAccessor)
 							continue;
 
 						if ((restrictions & BindingRestriction.OverrideOnly) != 0 && (entry.Modifiers & Modifiers.OVERRIDE) == 0)
 							continue;
 
 						if (!filter.Equals (entry))
 							continue;
 
 						if ((restrictions & BindingRestriction.DeclaredOnly) != 0 && container.IsInterface && entry.DeclaringType != container)
 							continue;
 
 						return entry;
 					for (int i = applicable.Count - 1; i >= 0; i--) {
 						var entry = applicable [i];
 
 						if ((restrictions & BindingRestriction.InstanceOnly) != 0 && entry.IsStatic)
 							continue;
 
 						if ((restrictions & BindingRestriction.NoAccessors) != 0 && entry.IsAccessor)
 							continue;
 
 						if ((restrictions & BindingRestriction.OverrideOnly) != 0 && (entry.Modifiers & Modifiers.OVERRIDE) == 0)
 							continue;
 
 						if (!filter.Equals (entry))
 							continue;
 
 						if ((restrictions & BindingRestriction.DeclaredOnly) != 0 && container.IsInterface && entry.DeclaringType != container)
 							continue;
 
 						return entry;
 					}
 				}
 
 				if ((restrictions & BindingRestriction.DeclaredOnly) != 0)
 					break;
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1750" endline="1779">
<![CDATA[
 
 		int TokenizePreprocessorIdentifier (out int c)
 		{
 			// skip over white space
 			do {
 				c = get_char ();
 			} while (c == '\r' || c == ' ' || c == '\t');
 
 
 			int pos = 0;
 			while (c != -1 && c >= 'a' && c <= 'z') {
 				id_builder[pos++] = (char) c;
 				c = get_char ();
 				if (c == '\\') {
 					int peek = peek_char ();
 					if (peek == 'U' || peek == 'u') {
 						int surrogate;
 						c = EscapeUnicode (c, out surrogate);
 						if (surrogate != 0) {
 							if (is_identifier_part_character ((char) c)) {
 								id_builder[pos++] = (char) c;
 							}
 							c = surrogate;
 						}
 					}
 				}
 			}
 			while (c != -1 && c >= 'a' && c <= 'z') {
 				id_builder[pos++] = (char) c;
 				c = get_char ();
 				if (c == '\\') {
 					int peek = peek_char ();
 					if (peek == 'U' || peek == 'u') {
 						int surrogate;
 						c = EscapeUnicode (c, out surrogate);
 						if (surrogate != 0) {
 							if (is_identifier_part_character ((char) c)) {
 								id_builder[pos++] = (char) c;
 							}
 							c = surrogate;
 						}
 					}
 				}
 			}
 
 			return pos;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1803" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="440" endline="482">
<![CDATA[
 
 		//
 		// Finds the nested type in container
 		//
 		public static TypeSpec FindNestedType (TypeSpec container, string name, int arity)
 		{
 			IList<MemberSpec> applicable;
 			TypeSpec best_match = null;
 			do {
 				// TODO
 				// When resolving base type of nested type, parent type must have
 				// base type resolved to scan full hierarchy correctly
 				// Similarly MemberCacheTypes will inflate BaseType and Interfaces
 				// based on type definition
 				var tc = container.MemberDefinition as TypeContainer;
 				if (tc != null)
 					tc.DefineType ();
 
 				if (container.MemberCacheTypes.member_hash.TryGetValue (name, out applicable)) {
 					for (int i = applicable.Count - 1; i >= 0; i--) {
 						var entry = applicable[i];
 						if ((entry.Kind & MemberKind.NestedMask) == 0)
 							continue;
 
 						var ts = (TypeSpec) entry;
 						if (arity == ts.Arity)
 							return ts;
 
 						if (arity < 0) {
 							if (best_match == null) {
 								best_match = ts;
 							} else if (System.Math.Abs (ts.Arity + arity) < System.Math.Abs (ts.Arity + arity)) {
 								best_match = ts;
 							}
 						}
 					}
 					for (int i = applicable.Count - 1; i >= 0; i--) {
 						var entry = applicable[i];
 						if ((entry.Kind & MemberKind.NestedMask) == 0)
 							continue;
 
 						var ts = (TypeSpec) entry;
 						if (arity == ts.Arity)
 							return ts;
 
 						if (arity < 0) {
 							if (best_match == null) {
 								best_match = ts;
 							} else if (System.Math.Abs (ts.Arity + arity) < System.Math.Abs (ts.Arity + arity)) {
 								best_match = ts;
 							}
 						}
 					}
 				}
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return best_match;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="830" endline="901">
<![CDATA[
 
 		//
 		// Returns all operators declared on container and its base types (until declaredOnly is used)
 		//
 		public static IList<MemberSpec> GetUserOperator (TypeSpec container, Operator.OpType op, bool declaredOnly)
 		{
 			IList<MemberSpec> found = null;
 
 			IList<MemberSpec> applicable;
 			do {
 				var mc = container.MemberCache;
 
 				if (((op == Operator.OpType.Implicit || op == Operator.OpType.Explicit) && (mc.state & StateFlags.HasConversionOperator) != 0) ||
 					 (mc.state & StateFlags.HasUserOperator) != 0) {
 
 					if (mc.member_hash.TryGetValue (Operator.GetMetadataName (op), out applicable)) {
 						int i;
 						for (i = 0; i < applicable.Count; ++i) {
 							if (applicable[i].Kind != MemberKind.Operator) {
 								break;
 							}
 						}
 						for (i = 0; i < applicable.Count; ++i) {
 							if (applicable[i].Kind != MemberKind.Operator) {
 								break;
 							}
 						}
 
 						//
 						// Handles very rare case where a method with same name as operator (op_xxxx) exists
 						// and we have to resize the applicable list
 						//
 						if (i != applicable.Count) {
 							for (i = 0; i < applicable.Count; ++i) {
 								if (applicable[i].Kind != MemberKind.Operator) {
 									continue;
 								}
 
 								if (found == null) {
 									found = new List<MemberSpec> ();
 									found.Add (applicable[i]);
 								} else {
 									var prev = found as List<MemberSpec>;
 									if (prev == null) {
 										prev = new List<MemberSpec> (found.Count + 1);
 										prev.AddRange (found);
 									}
 
 									prev.Add (applicable[i]);
 								}
 							}
 							for (i = 0; i < applicable.Count; ++i) {
 								if (applicable[i].Kind != MemberKind.Operator) {
 									continue;
 								}
 
 								if (found == null) {
 									found = new List<MemberSpec> ();
 									found.Add (applicable[i]);
 								} else {
 									var prev = found as List<MemberSpec>;
 									if (prev == null) {
 										prev = new List<MemberSpec> (found.Count + 1);
 										prev.AddRange (found);
 									}
 
 									prev.Add (applicable[i]);
 								}
 							}
 						} else {
 							if (found == null) {
 								found = applicable;
 							} else {
 								var merged = found as List<MemberSpec>;
 								if (merged == null) {
 									merged = new List<MemberSpec> (found.Count + applicable.Count);
 									merged.AddRange (found);
 									found = merged;
 								}
 
 								merged.AddRange (applicable);
 							}
 						}
 					}
 				}
 
 				// BaseType call can be expensive
 				if (declaredOnly)
 					break;
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return found;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1804" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5652" endline="5691">
<![CDATA[
 
     ''' <summary>
     ''' CatchStatement  
     '''	   "Catch" [  Identifier "As" NonArrayTypeName  ]  [ "When" BooleanExpression  ]  StatementTerminator
     '''	      [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCatchStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CatchStatement
         Dim result As New CatchStatement(Parent)
 
         Dim m_Code As CodeBlock
         Dim m_Variable As Identifier = Nothing
         Dim m_When As Expression = Nothing
         Dim m_TypeName As NonArrayTypeName = Nothing
 
         tm.AcceptIfNotInternalError(KS.Catch)
 
         If tm.AcceptEndOfStatement(IsOneLiner) = False Then
             m_Variable = ParseIdentifier(result)
             If m_Variable IsNot Nothing Then
                 If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_TypeName = ParseNonArrayTypeName(result)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.Accept(KS.When) Then
                 m_When = ParseExpression(result)
                 If m_When Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Variable, m_TypeName, m_When, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5390" endline="5445">
<![CDATA[
 
     ''' <summary>
     ''' Homebrew
     ''' UsingDeclarator 
     '''  Identifier  [  As  [  New  ]  NonArrayTypeName  [  (  ArgumentList  )  ]  ]  |
     '''  Identifier  [  As  NonArrayTypeName  ]  [  =  VariableInitializer  ]
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseUsingDeclarator(ByVal Parent As ParsedObject) As UsingDeclarator
         Dim result As New UsingDeclarator(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_IsNew As Boolean
         Dim m_IsVariableDeclaration As Boolean
         Dim m_TypeName As NonArrayTypeName
         Dim m_VariableInitializer As VariableInitializer = Nothing
         Dim m_ArgumentList As ArgumentList = Nothing
         Dim m_VariableDeclaration As LocalVariableDeclaration
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_IsVariableDeclaration = True
             m_IsNew = tm.Accept(KS.[New])
 
             m_TypeName = ParseNonArrayTypeName(result)
 
             If m_IsNew = False Then
                 If tm.Accept(KS.Equals) Then
                     m_VariableInitializer = ParseVariableInitializer(result)
                 End If
             Else
                 If tm.Accept(KS.LParenthesis) Then
                     If tm.Accept(KS.RParenthesis) = False Then
                         m_ArgumentList = ParseArgumentList(result)
                         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
                 End If
                 If m_ArgumentList Is Nothing Then m_ArgumentList = New ArgumentList(result)
             End If
 
             m_VariableDeclaration = New LocalVariableDeclaration(result, m_Identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
         Else
             m_VariableDeclaration = Nothing
             m_VariableInitializer = Nothing
             m_ArgumentList = Nothing
             m_TypeName = Nothing
         End If
 
 
         result.Init(m_Identifier, m_IsNew, m_TypeName, m_ArgumentList, m_VariableInitializer, m_IsVariableDeclaration, m_VariableDeclaration)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1805" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5652" endline="5691">
<![CDATA[
 
     ''' <summary>
     ''' CatchStatement  
     '''	   "Catch" [  Identifier "As" NonArrayTypeName  ]  [ "When" BooleanExpression  ]  StatementTerminator
     '''	      [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCatchStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CatchStatement
         Dim result As New CatchStatement(Parent)
 
         Dim m_Code As CodeBlock
         Dim m_Variable As Identifier = Nothing
         Dim m_When As Expression = Nothing
         Dim m_TypeName As NonArrayTypeName = Nothing
 
         tm.AcceptIfNotInternalError(KS.Catch)
 
         If tm.AcceptEndOfStatement(IsOneLiner) = False Then
             m_Variable = ParseIdentifier(result)
             If m_Variable IsNot Nothing Then
                 If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_TypeName = ParseNonArrayTypeName(result)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.Accept(KS.When) Then
                 m_When = ParseExpression(result)
                 If m_When Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Variable, m_TypeName, m_When, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5692" endline="5764">
<![CDATA[
     ''' <summary>
     ''' IfStatement  
     ''' BlockIfStatement  
     '''	   "If" BooleanExpression  [ "Then" ]  StatementTerminator
     '''	        [  Block  ]
     '''	   [  ElseIfStatement+  ]
     '''	   [  ElseStatement  ]
     '''	   "End" "If" StatementTerminator
     ''' ElseIfStatement  
     '''	   "ElseIf" BooleanExpression  [ "Then" ]  StatementTerminator
     '''	        [  Block  ]
     ''' ElseStatement  
     '''	   "Else" StatementTerminator
     '''	        [  Block  ]
     ''' LineIfThenStatement  
     '''	   "If" BooleanExpression "Then" Statements  [ "Else" Statements  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseIfStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As IfStatement
         Dim result As New IfStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_TrueCode As CodeBlock
         Dim m_FalseCode As CodeBlock
         Dim m_OneLiner As Boolean
         Dim m_ElseIfs As BaseObjects(Of ElseIfStatement)
 
         tm.AcceptIfNotInternalError(KS.If)
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Then) = False Then
             m_OneLiner = False 'Cannot be a oneliner if Then is not found.
             If IsOneLiner Then
                 Helper.AddError(Compiler, tm.CurrentLocation, "report error BC30081, 'if' must end with a matching 'end if'")
                 tm.GotoNewline(False)
             Else
                 tm.AcceptEndOfStatement(False, True)
             End If
         Else
             If IsOneLiner = False Then
                 m_OneLiner = Not tm.AcceptEndOfStatement(False, False)
             Else
                 m_OneLiner = True
             End If
         End If
 
         m_TrueCode = ParseCodeBlock(result, m_OneLiner)
         If m_TrueCode Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ElseIfs = New BaseObjects(Of ElseIfStatement)(result)
         While tm.CurrentToken = KS.ElseIf OrElse (m_OneLiner = False AndAlso tm.CurrentToken = KS.Else AndAlso tm.PeekToken = KS.If)
             Dim newElseIf As ElseIfStatement
             newElseIf = ParseElseIfStatement(result, m_OneLiner)
             m_ElseIfs.Add(newElseIf)
         End While
         While tm.CurrentToken = KS.ElseIf OrElse (m_OneLiner = False AndAlso tm.CurrentToken = KS.Else AndAlso tm.PeekToken = KS.If)
             Dim newElseIf As ElseIfStatement
             newElseIf = ParseElseIfStatement(result, m_OneLiner)
             m_ElseIfs.Add(newElseIf)
         End While
 
         If tm.Accept(KS.Else) Then
             If m_OneLiner = False Then
                 If tm.AcceptEndOfStatement(False, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_FalseCode = ParseCodeBlock(result, m_OneLiner)
             If m_FalseCode Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_FalseCode = Nothing
         End If
 
         If m_OneLiner = False Then tm.AcceptIfNotError(KS.End, KS.If)
 
         result.Init(m_Condition, m_FalseCode, m_TrueCode, m_OneLiner, m_ElseIfs)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1806" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1001" endline="1042">
<![CDATA[
 
 		//
 		// Returns non-zero value for equal CLS parameter signatures
 		//
 		public static int IsSameClsSignature (AParametersCollection a, AParametersCollection b)
 		{
 			int res = 0;
 
 			for (int i = 0; i < a.Count; ++i) {
 				var a_type = a.Types[i];
 				var b_type = b.Types[i];
 				if (TypeSpecComparer.Override.IsEqual (a_type, b_type)) {
 					const Parameter.Modifier ref_out = Parameter.Modifier.REF | Parameter.Modifier.OUT;
 					if ((a.FixedParameters[i].ModFlags & ref_out) != (b.FixedParameters[i].ModFlags & ref_out))
 						res |= 1;
 
 					continue;
 				}
 
 				var ac_a = a_type as ArrayContainer;
 				if (ac_a == null)
 					return 0;
 
 				var ac_b = b_type as ArrayContainer;
 				if (ac_b == null)
 					return 0;
 
 				if (ac_a.Element is ArrayContainer || ac_b.Element is ArrayContainer) {
 					res |= 2;
 					continue;
 				}
 
 				if (ac_a.Rank != ac_b.Rank && TypeSpecComparer.Override.IsEqual (ac_a.Element, ac_b.Element)) {
 					res |= 1;
 					continue;
 				}
 
 				return 0;
 			for (int i = 0; i < a.Count; ++i) {
 				var a_type = a.Types[i];
 				var b_type = b.Types[i];
 				if (TypeSpecComparer.Override.IsEqual (a_type, b_type)) {
 					const Parameter.Modifier ref_out = Parameter.Modifier.REF | Parameter.Modifier.OUT;
 					if ((a.FixedParameters[i].ModFlags & ref_out) != (b.FixedParameters[i].ModFlags & ref_out))
 						res |= 1;
 
 					continue;
 				}
 
 				var ac_a = a_type as ArrayContainer;
 				if (ac_a == null)
 					return 0;
 
 				var ac_b = b_type as ArrayContainer;
 				if (ac_b == null)
 					return 0;
 
 				if (ac_a.Element is ArrayContainer || ac_b.Element is ArrayContainer) {
 					res |= 2;
 					continue;
 				}
 
 				if (ac_a.Rank != ac_b.Rank && TypeSpecComparer.Override.IsEqual (ac_a.Element, ac_b.Element)) {
 					res |= 1;
 					continue;
 				}
 
 				return 0;
 			}
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="345" endline="381">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			string name;
 			if (IsConstructor) {
 				name = DeclaringType.GetSignatureForError () + "." + DeclaringType.Name;
 			} else if (Kind == MemberKind.Operator) {
 				var op = Operator.GetType (Name).Value;
 				if (op == Operator.OpType.Implicit || op == Operator.OpType.Explicit) {
 					name = DeclaringType.GetSignatureForError () + "." + Operator.GetName (op) + " operator " + returnType.GetSignatureForError ();
 				} else {
 					name = DeclaringType.GetSignatureForError () + ".operator " + Operator.GetName (op);
 				}
 			} else if (IsAccessor) {
 				int split = Name.IndexOf ('_');
 				name = Name.Substring (split + 1);
 				var postfix = Name.Substring (0, split);
 				if (split == 3) {
 					var pc = parameters.Count;
 					if (pc > 0 && postfix == "get") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc);
 					} else if (pc > 1 && postfix == "set") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc - 1);
 					}
 				}
 
 				return DeclaringType.GetSignatureForError () + "." + name + "." + postfix;
 			} else {
 				name = base.GetSignatureForError ();
 				if (targs != null)
 					name += "<" + TypeManager.CSharpName (targs) + ">";
 				else if (IsGeneric)
 					name += "<" + TypeManager.CSharpName (GenericDefinition.TypeParameters) + ">";
 			}
 
 			return name + parameters.GetSignatureForError ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1807" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3231" endline="3268">
<![CDATA[
 
 		int TokenizeBackslash ()
 		{
 			int c = get_char ();
 			tokens_seen = true;
 			if (c == '\'') {
 				val = new CharLiteral ((char) c, Location);
 				Report.Error (1011, Location, "Empty character literal");
 				return Token.LITERAL;
 			}
 
 			if (c == '\r' || c == '\n') {
 				Report.Error (1010, Location, "Newline in constant");
 				return Token.ERROR;
 			}
 
 			int d;
 			c = escape (c, out d);
 			if (c == -1)
 				return Token.ERROR;
 			if (d != 0)
 				throw new NotImplementedException ();
 
 			val = new CharLiteral ((char) c, Location);
 			c = get_char ();
 
 			if (c != '\'') {
 				Report.Error (1012, Location, "Too many characters in character literal");
 
 				// Try to recover, read until newline or next "'"
 				while ((c = get_char ()) != -1) {
 					if (c == '\n' || c == '\'')
 						break;
 				}
 				while ((c = get_char ()) != -1) {
 					if (c == '\n' || c == '\'')
 						break;
 				}
 			}
 
 			return Token.LITERAL;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1286" endline="1364">
<![CDATA[
 
 		int integer_type_suffix (ulong ul, int c)
 		{
 			bool is_unsigned = false;
 			bool is_long = false;
 
 			if (c != -1){
 				bool scanning = true;
 				do {
 					switch (c){
 					case 'U'
 						if (is_unsigned)
 							scanning = false;
 						is_unsigned = true;
 						get_char ();
 						break;
 
 					case 'l'
 						if (!is_unsigned){
 							//
 							// if we have not seen anything in between
 							// report this error
 							//
 							Report.Warning (78, 4, Location, "The 'l' suffix is easily confused with the digit '1' (use 'L' for clarity)");
 						}
 
 						goto case 'L';
 
 					case 'L'
 						if (is_long)
 							scanning = false;
 						is_long = true;
 						get_char ();
 						break;
 						
 					default
 						scanning = false;
 						break;
 					}
 					c = peek_char ();
 				} while (scanning);
 			}
 
 			if (is_long && is_unsigned){
 				val = new ULongLiteral (ul, Location);
 				return Token.LITERAL;
 			}
 			
 			if (is_unsigned){
 				// uint if possible, or ulong else.
 
 				if ((ul & 0xffffffff00000000) == 0)
 					val = new UIntLiteral ((uint) ul, Location);
 				else
 					val = new ULongLiteral (ul, Location);
 			} else if (is_long){
 				// long if possible, ulong otherwise
 				if ((ul & 0x8000000000000000) != 0)
 					val = new ULongLiteral (ul, Location);
 				else
 					val = new LongLiteral ((long) ul, Location);
 			} else {
 				// int, uint, long or ulong in that order
 				if ((ul & 0xffffffff00000000) == 0){
 					uint ui = (uint) ul;
 					
 					if ((ui & 0x80000000) != 0)
 						val = new UIntLiteral (ui, Location);
 					else
 						val = new IntLiteral ((int) ui, Location);
 				} else {
 					if ((ul & 0x8000000000000000) != 0)
 						val = new ULongLiteral (ul, Location);
 					else
 						val = new LongLiteral ((long) ul, Location);
 				}
 			}
 			return Token.LITERAL;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1808" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" startline="118" endline="362">
<![CDATA[
 
     Private Function GenerateCTypeCode(ByVal Info As EmitInfo, ByVal DestinationType As Mono.Cecil.TypeReference, ByVal SourceType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
 
         If m_IsStringToCharArray Then
             Return EmitStringToCharArray(Info) AndAlso result
         End If
 
         result = Expression.Classification.GenerateCode(Info.Clone(Me, DestinationType)) AndAlso result
 
         If Helper.CompareType(Compiler.TypeCache.Nothing, SourceType) Then
             'There is nothing to do here
         ElseIf CecilHelper.IsGenericParameter(SourceType) Then
             If CecilHelper.IsGenericParameter(DestinationType) Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             ElseIf CecilHelper.IsArray(DestinationType) Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             ElseIf CecilHelper.IsClass(DestinationType) Then
                 DestinationType = Helper.GetTypeOrTypeBuilder(Compiler, DestinationType)
                 If Helper.IsTypeConvertibleToAny(Helper.GetGenericParameterConstraints(Me, SourceType), DestinationType) Then
                     'Emitter.EmitUnbox_Any(Info, DestinationType)
                     Emitter.EmitBox(Info, SourceType)
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 Else
                     Helper.AddError(Me)
                 End If
             ElseIf CecilHelper.IsValueType(DestinationType) Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             ElseIf Helper.IsInterface(Compiler, DestinationType) Then
                 Emitter.EmitBox(Info, SourceType)
                 Emitter.EmitCastClass(Info, SourceType, DestinationType)
             Else
                 Throw New InternalException(Me)
             End If
         ElseIf CecilHelper.IsArray(SourceType) Then
             If CecilHelper.IsInterface(DestinationType) Then
                 If Helper.DoesTypeImplementInterface(Me, SourceType, DestinationType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf Helper.CompareType(SourceType, Compiler.TypeCache.System_Object_Array) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf CecilHelper.IsArray(DestinationType) AndAlso Helper.DoesTypeImplementInterface(Me, CecilHelper.GetElementType(SourceType), CecilHelper.GetElementType(DestinationType)) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Location, Helper.ToString(Expression, SourceType), Helper.ToString(Expression, DestinationType))
                     result = False
                 End If
             ElseIf Helper.CompareType(DestinationType, Compiler.TypeCache.System_Array) Then
                 Emitter.EmitCastClass(Info, SourceType, DestinationType)
             ElseIf CecilHelper.IsArray(DestinationType) = False Then
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Location, Helper.ToString(Expression, SourceType), Helper.ToString(Expression, DestinationType))
                 result = False
             ElseIf CecilHelper.GetArrayRank(SourceType) <> CecilHelper.GetArrayRank(DestinationType) Then
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Location, Helper.ToString(Expression, SourceType), Helper.ToString(Expression, DestinationType))
                 result = False
             Else
                 Dim SourceElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(SourceType)
                 Dim DestinationElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(DestinationType)
                 'For any two reference types A and B, if A is a derived type of B or implements B, 
                 'a conversion exists from an array of type A to a compatible array of type B.
                 'A compatible array is an array of the same rank and type. 
                 'This relationship is known as array covariance. 
                 'Array covariance in particular means that an element of an array whose element type is B 
                 'may actually be an element of an array whose element type is A, 
                 'provided that both A and B are reference types and that B is a base type of A or is implemented by A. 
                 If Helper.CompareType(Compiler.TypeCache.System_Object, SourceElementType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf Helper.CompareType(SourceElementType, DestinationElementType) OrElse Helper.IsSubclassOf(DestinationElementType, SourceElementType) OrElse Helper.IsSubclassOf(SourceElementType, DestinationElementType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf Helper.DoesTypeImplementInterface(Me, SourceElementType, DestinationElementType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf Helper.IsInterface(Info.Compiler, DestinationElementType) AndAlso Helper.CompareType(Compiler.TypeCache.System_Object, SourceElementType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf helper.IsEnum(compiler, sourceelementtype)AndAlso Helper.CompareType(Helper.GetEnumType(Compiler, SourceElementType), DestinationElementType) Then
                     'Conversions also exist between an array of an enumerated type and an array of the enumerated type's underlying type of the same rank.
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf CecilHelper.IsGenericParameter(SourceElementType) AndAlso Helper.IsTypeConvertibleToAny(Helper.GetGenericParameterConstraints(Me, SourceElementType), DestinationElementType) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 ElseIf CecilHelper.IsGenericParameter(DestinationElementType) AndAlso Helper.IsTypeConvertibleToAny(SourceElementType, Helper.GetGenericParameterConstraints(Me, DestinationElementType)) Then
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Me.Location, SourceType.Name, DestinationType.Name)
                     result = False
                 End If
 
             End If
         ElseIf CecilHelper.IsClass(SourceType) Then
             If CecilHelper.IsGenericParameter(DestinationType) Then
                 Dim methodD As New Mono.Cecil.GenericInstanceMethod(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.MS_VB_CS_Conversions__ToGenericParameter_Object))
                 methodD.GenericParameters.Add(DirectCast(CecilHelper.GetGenericArguments(Compiler.TypeCache.MS_VB_CS_Conversions__ToGenericParameter_Object)(0), Mono.Cecil.GenericParameter))
                 methodD.GenericArguments.Add(DestinationType)
 
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 Emitter.EmitCall(Info, methodD)
             ElseIf CecilHelper.IsClass(DestinationType) Then
                 Emitter.EmitCastClass(Info, SourceType, DestinationType)
             ElseIf CecilHelper.IsInterface(DestinationType) Then
                 Emitter.EmitCastClass(Info, SourceType, DestinationType)
             ElseIf CecilHelper.IsValueType(DestinationType) Then
                 Emitter.EmitUnbox(Info, DestinationType)
                 Emitter.EmitLdobj(Info, DestinationType)
             ElseIf Helper.IsEnum(Compiler, DestinationType) Then
                 Throw New InternalException(Me) 'This is an elemental conversion already covered.
             ElseIf CecilHelper.IsArray(DestinationType) Then
                 Throw New InternalException(Me) 'This is an IsClass case.
             Else
                 Throw New InternalException(Me)
             End If
         ElseIf CecilHelper.IsNullable(DestinationType) Then
             If CecilHelper.IsNullable(SourceType) Then
                 Dim nullable_src_type As GenericInstanceType
                 Dim nullable_dst_type As GenericInstanceType
                 Dim get_value As MethodReference
                 Dim has_value As MethodReference
                 Dim ctor As MethodReference
                 Dim localsrc, localdst As Mono.Cecil.Cil.VariableDefinition
                 Dim falseLabel As Label = Emitter.DefineLabel(Info)
                 Dim endLabel As Label = Emitter.DefineLabel(Info)
                 Dim vose As ValueOnStackExpression
                 Dim type_conversion As Expression
 
                 nullable_src_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_src_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(SourceType)))
                 has_value = New MethodReference("get_HasValue", nullable_src_type, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Boolean), True, False, MethodCallingConvention.Default)
                 get_value = New MethodReference("GetValueOrDefault", nullable_src_type, Compiler.TypeCache.System_Nullable1.GenericParameters(0), True, False, MethodCallingConvention.Default)
 
                 nullable_dst_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_dst_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(DestinationType)))
                 ctor = New MethodReference(".ctor", nullable_dst_type, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void), True, False, MethodCallingConvention.Default)
                 ctor.Parameters.Add(New ParameterDefinition(Compiler.TypeCache.System_Nullable1.GenericParameters(0)))
 
                 'store in local
                 localsrc = Emitter.DeclareLocal(Info, SourceType)
                 Emitter.EmitStoreVariable(Info, localsrc)
 
                 'call Nullable`1.HasValue to check the condition
                 Emitter.EmitLoadVariableLocation(Info, localsrc)
                 Emitter.EmitCall(Info, has_value)
                 Emitter.EmitBranchIfFalse(Info, falseLabel)
 
                 localdst = Emitter.DeclareLocal(Info, DestinationType)
 
                 'true branch
                 Emitter.EmitLoadVariableLocation(Info, localdst)
                 Emitter.EmitLoadVariableLocation(Info, localsrc)
                 Emitter.EmitCall(Info, get_value)
 
                 'convert value
                 vose = New ValueOnStackExpression(Me, CecilHelper.GetNulledType(SourceType))
                 type_conversion = Helper.CreateTypeConversion(Me, vose, CecilHelper.GetNulledType(DestinationType), result)
                 result = type_conversion.GenerateCode(Info) AndAlso result
 
                 Emitter.EmitCall(Info, ctor)
                 Emitter.EmitLoadVariable(Info, localdst)
                 Emitter.EmitBranch(Info, endLabel)
 
                 'false branch
                 Emitter.MarkLabel(Info, falseLabel)
                 Emitter.EmitLoadVariableLocation(Info, localdst)
                 Emitter.EmitInitObj(Info, localdst.VariableType)
                 Emitter.EmitLoadVariable(Info, localdst)
 
                 'end
                 Emitter.MarkLabel(Info, endLabel)
             Else
                 Dim nullable_dst_type As GenericInstanceType
                 Dim ctor As MethodReference
                 Dim localsrc, localdst As Mono.Cecil.Cil.VariableDefinition
                 Dim falseLabel As Label = Emitter.DefineLabel(Info)
                 Dim endLabel As Label = Emitter.DefineLabel(Info)
                 Dim vose As ValueOnStackExpression
                 Dim type_conversion As Expression
 
                 nullable_dst_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_dst_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(DestinationType)))
                 ctor = New MethodReference(".ctor", nullable_dst_type, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void), True, False, MethodCallingConvention.Default)
                 ctor.Parameters.Add(New ParameterDefinition(Compiler.TypeCache.System_Nullable1.GenericParameters(0)))
 
                 'store in local
                 localsrc = Emitter.DeclareLocal(Info, SourceType)
                 Emitter.EmitStoreVariable(Info, localsrc)
 
                 localdst = Emitter.DeclareLocal(Info, DestinationType)
 
                 Emitter.EmitLoadVariableLocation(Info, localdst)
                 Emitter.EmitLoadVariable(Info, localsrc)
 
                 'convert value
                 vose = New ValueOnStackExpression(Me, SourceType)
                 type_conversion = Helper.CreateTypeConversion(Me, vose, CecilHelper.GetNulledType(DestinationType), result)
                 result = type_conversion.GenerateCode(Info) AndAlso result
 
                 Emitter.EmitCall(Info, ctor)
                 Emitter.EmitLoadVariable(Info, localdst)
             End If
         ElseIf CecilHelper.IsValueType(SourceType) Then
             'A value type value can be converted to one of its base reference types or an interface type that it implements through a process called boxing
             If Helper.CompareType(DestinationType, Compiler.TypeCache.System_Object) Then
                 Throw New InternalException(Me) 'This is an elemental conversion already covered. 'Emitter.EmitBox(Info)
             ElseIf Helper.DoesTypeImplementInterface(Me, SourceType, DestinationType) Then
                 Emitter.EmitBox(Info, SourceType)
                 Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Object, DestinationType)
             ElseIf Helper.CompareType(DestinationType, Compiler.TypeCache.System_ValueType) Then
                 Emitter.EmitBox(Info, SourceType)
             ElseIf Helper.CompareType(CecilHelper.FindDefinition(SourceType).BaseType, DestinationType) Then
                 Emitter.EmitBox(Info, DestinationType)
             Else
                 Dim operators As Generic.List(Of Mono.Cecil.MethodReference)
                 operators = Helper.GetWideningConversionOperators(Info.Compiler, SourceType, DestinationType)
                 If operators Is Nothing OrElse operators.Count = 0 Then
                     Helper.AddWarning("using narrowing operators")
                     operators = Helper.GetNarrowingConversionOperators(Info.Compiler, SourceType, DestinationType)
                 End If
                 If operators IsNot Nothing AndAlso operators.Count > 0 Then
                     If operators.Count = 1 Then
                         Emitter.EmitCall(Info, operators(0))
                     Else
                         result = Compiler.Report.ShowMessage(Messages.VBNC30311, Me.Location, Expression.ExpressionType.FullName, ExpressionType.FullName) AndAlso result
                     End If
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC30311, Me.Location, Expression.ExpressionType.FullName, ExpressionType.FullName) AndAlso result
                 End If
             End If
         ElseIf Helper.IsInterface(Compiler, SourceType) Then
             If CecilHelper.IsGenericParameter(DestinationType) Then
                 Emitter.EmitUnbox_Any(Info, DestinationType)
             ElseIf Helper.DoesTypeImplementInterface(Me, DestinationType, SourceType) Then
                 If CecilHelper.IsValueType(DestinationType) Then
                     Emitter.EmitUnbox(Info, DestinationType)
                     Emitter.EmitLdobj(Info, DestinationType)
                 Else
                     Emitter.EmitCastClass(Info, SourceType, DestinationType)
                 End If
 
             ElseIf CecilHelper.IsClass(DestinationType) OrElse CecilHelper.IsInterface(DestinationType) Then
                 Emitter.EmitCastClass(Info, SourceType, DestinationType)
             Else
                 'However, classes that represent COM classes may have interface implementations that are not known until run time. Consequently, a class type may also be converted to an interface type that it does not implement, an interface type may be converted to a class type that does not implement it, and an interface type may be converted to another interface type with which it has no inheritance relationship
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="138" endline="230">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim falseLabel As Label = Emitter.DefineLabel(Info)
         Dim endLabel As Label = Emitter.DefineLabel(Info)
         Dim local As Mono.Cecil.Cil.VariableDefinition
         Dim vose As ValueOnStackExpression
         Dim type_conversion As Expression
         Dim nullable_type As GenericInstanceType = Nothing
         Dim has_value As MethodReference
         Dim get_value As MethodReference
         
         If ThirdPart IsNot Nothing Then
             result = Condition.GenerateCode(Info) AndAlso result
             Emitter.EmitBranchIfFalse(Info, falseLabel)
             result = SecondPart.GenerateCode(Info) AndAlso result
             Emitter.EmitBranch(Info, endLabel)
             Emitter.MarkLabel(Info, falseLabel)
             result = ThirdPart.GenerateCode(Info) AndAlso result
         Else
             'Emit condition, and store the result in a local variable
             local = Emitter.DeclareLocal(Info, Condition.ExpressionType)
             result = Condition.GenerateCode(Info) AndAlso result
             Emitter.EmitStoreVariable(Info, local)
 
             'If the first operand (condition) is nullable and the second is not, the result is the dominant type 
             'between the nulled type of the first operand and the type of the second operand.
             'This means that for this case
             ' - True condition
             ' - False condition
             'For the normal case
             ' - Both conditions
 
             'conditions
             If CecilHelper.IsNullable(Condition.ExpressionType) Then
                 nullable_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(Condition.ExpressionType)))
 
                 'Call Nullable`1.HasValue to check the condition
                 has_value = New MethodReference("get_HasValue", Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Boolean))
                 has_value.DeclaringType = nullable_type
                 has_value.HasThis = True
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitCall(Info, has_value)
                 Emitter.EmitBranchIfFalse(Info, falseLabel)
             Else
                 Emitter.EmitLoadVariable(Info, local)
                 Emitter.EmitBranchIfFalse(Info, falseLabel)
             End If
 
             'true branch
             If CecilHelper.IsNullable(Condition.ExpressionType) AndAlso CecilHelper.IsNullable(m_ExpressionType) = False Then
                 'denullify
                 get_value = New MethodReference("GetValueOrDefault", Compiler.TypeCache.System_Nullable1.GenericParameters(0))
                 get_value.DeclaringType = nullable_type
                 get_value.HasThis = True
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitCall(Info, get_value)
                 'convert to proper type
                 vose = New ValueOnStackExpression(Me, CecilHelper.GetNulledType(Condition.ExpressionType))
             Else
                 Emitter.EmitLoadVariable(Info, local)
                 vose = New ValueOnStackExpression(Me, Condition.ExpressionType)
             End If
             type_conversion = Helper.CreateTypeConversion(Me, vose, m_ExpressionType, result)
             result = type_conversion.GenerateCode(Info) AndAlso result
             Emitter.EmitBranch(Info, endLabel)
 
             'false branch
             Emitter.MarkLabel(Info, falseLabel)
             result = SecondPart.GenerateCode(Info) AndAlso result
             If CecilHelper.IsNullable(SecondPart.ExpressionType) AndAlso CecilHelper.IsNullable(m_ExpressionType) = False Then
                 nullable_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(SecondPart.ExpressionType)))
 
                 'denullify
                 get_value = New MethodReference("GetValueOrDefault", Compiler.TypeCache.System_Nullable1.GenericParameters(0))
                 get_value.DeclaringType = nullable_type
                 get_value.HasThis = True
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitCall(Info, get_value)
                 'convert to proper type
                 vose = New ValueOnStackExpression(Me, CecilHelper.GetNulledType(SecondPart.ExpressionType))
             Else
                 vose = New ValueOnStackExpression(Me, SecondPart.ExpressionType)
             End If
             type_conversion = Helper.CreateTypeConversion(Me, vose, m_ExpressionType, result)
             result = type_conversion.GenerateCode(Info) AndAlso result
         End If
         Emitter.MarkLabel(Info, endLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1809" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="246" endline="273">
<![CDATA[
 
     Public Sub EndExceptionBlockCecil()
         Log("EndExceptionBlock")
         Dim block As TryBlock = m_ExceptionBlocks.Pop
         If block.EndTry Is Nothing Then block.EndTry = CreateAndEmitNop()
 
         Dim TryStart As Mono.Cecil.Cil.Instruction
         TryStart = CilBody.Instructions(block.Start)
         If block.Handlers(block.Handlers.Count - 1).HandlerType = Mono.Cecil.Cil.ExceptionHandlerType.Finally Then
             CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Endfinally)
         End If
         For i As Integer = 0 To block.Handlers.Count - 1
             Dim handler As Mono.Cecil.Cil.ExceptionHandler
             handler = block.Handlers(i)
             handler.TryStart = TryStart
             If handler.TryEnd Is Nothing Then
                 handler.TryEnd = block.EndTry
             End If
             If handler.HandlerEnd Is Nothing Then
                 If handler.HandlerType <> Mono.Cecil.Cil.ExceptionHandlerType.Finally Then
                     CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
                 End If
                 handler.HandlerEnd = block.EndBlock
             End If
             CilBody.ExceptionHandlers.Add(handler)
         Next
         CilWorker.Append(block.EndBlock)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" startline="147" endline="198">
<![CDATA[
 
     Private Class TryBlock
         Public Start As Integer
         Public EndBlock As Mono.Cecil.Cil.Instruction
         Public EndTry As Mono.Cecil.Cil.Instruction
         Public Handlers As New Generic.List(Of Mono.Cecil.Cil.ExceptionHandler)
 
         ReadOnly Property CurrentHandler() As Mono.Cecil.Cil.ExceptionHandler
             Get
                 If Handlers.Count = 0 Then
                     Return Nothing
                 Else
                     Return Handlers(Handlers.Count - 1)
                 End If
             End Get
         End Property
     End Class
 
     Private m_ExceptionBlocks As Generic.Stack(Of TryBlock)
 
     Public Sub BeginCatchBlock(ByVal exceptionType As Mono.Cecil.TypeReference)
         Log("BeginCatchBlock")
         Helper.Assert(Helper.IsEmittableMember(m_Compiler, exceptionType))
 
         If exceptionType Is Nothing Then
             Dim block As TryBlock = m_ExceptionBlocks.Peek
             Dim ex As Mono.Cecil.Cil.ExceptionHandler = block.Handlers(block.Handlers.Count - 1)
             CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Endfilter)
             ex.FilterEnd = CreateAndEmitNop()
             ex.HandlerStart = ex.FilterEnd
         Else
             Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Catch)
             Dim block As TryBlock = m_ExceptionBlocks.Peek
             CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
             Dim handlerStart As Integer = CilBody.Instructions.Count
             If block.Handlers.Count = 0 Then
                 ex.TryEnd = CreateAndEmitNop()
             Else
                 ex.TryEnd = block.Handlers(0).TryEnd
                 CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Nop)
             End If
             If block.EndTry Is Nothing Then
                 block.EndTry = ex.TryEnd
             End If
             If block.Handlers.Count > 0 Then
                 block.Handlers(block.Handlers.Count - 1).HandlerEnd = CilBody.Instructions(CilBody.Instructions.Count - 1) 'CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Nop)
             End If
             ex.HandlerStart = CilBody.Instructions(handlerStart)
             ex.CatchType = exceptionType
             block.Handlers.Add(ex)
             End If
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1810" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="225" endline="297">
<![CDATA[
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   If the return value of this function is null,
 		///   this indicates that the parsing was complete.
 		///   If the return value is a string it indicates
 		///   that the input string was partial and that the
 		///   invoking code should provide more code before
 		///   the code can be successfully compiled.
 		///
 		///   If you know that you will always get full expressions or
 		///   statements and do not care about partial input, you can use
 		///   the other Compile overload. 
 		///
 		///   On success, in addition to returning null, the
 		///   compiled parameter will be set to the delegate
 		///   that can be invoked to execute the code.
 		///
 	        /// </remarks>
 		static public string Compile (string input, out CompiledMethod compiled)
 		{
 			if (input == null || input.Length == 0){
 				compiled = null;
 				return null;
 			}
 
 			lock (evaluator_lock){
 				if (!inited)
 					Init ();
 				else
 					ctx.Report.Printer.Reset ();
 
 			//	RootContext.ToplevelTypes = new ModuleContainer (ctx);
 
 				bool partial_input;
 				CSharpParser parser = ParseString (ParseMode.Silent, input, out partial_input);
 				if (parser == null){
 					compiled = null;
 					if (partial_input)
 						return input;
 					
 					ParseString (ParseMode.ReportErrors, input, out partial_input);
 					return null;
 				}
 				
 				object parser_result = parser.InteractiveResult;
 				
 				if (!(parser_result is Class)){
 					int errors = ctx.Report.Errors;
 
 					NamespaceEntry.VerifyAllUsing ();
 					if (errors == ctx.Report.Errors)
 						parser.CurrentNamespace.Extract (using_alias_list, using_list);
 					else
 						NamespaceEntry.Reset ();
 				}
 
 #if STATIC
 				throw new NotSupportedException ();
 #else
 				compiled = CompileBlock (parser_result as Class, parser.undo, ctx.Report);
 				return null;
 #endif
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2657" endline="2697">
<![CDATA[
 
 		bool CheckStructCycles (Struct s)
 		{
 			if (s.Fields == null)
 				return true;
 
 			if (s.InTransit)
 				return false;
 
 			s.InTransit = true;
 			foreach (FieldBase field in s.Fields) {
 				TypeSpec ftype = field.Spec.MemberType;
 				if (!ftype.IsStruct)
 					continue;
 
 				if (ftype is BuildinTypeSpec)
 					continue;
 
 				foreach (var targ in ftype.TypeArguments) {
 					if (!CheckFieldTypeCycle (targ)) {
 						Report.Error (523, field.Location,
 							"Struct member `{0}' of type `{1}' causes a cycle in the struct layout",
 							field.GetSignatureForError (), ftype.GetSignatureForError ());
 						break;
 					}
 				}
 				foreach (var targ in ftype.TypeArguments) {
 					if (!CheckFieldTypeCycle (targ)) {
 						Report.Error (523, field.Location,
 							"Struct member `{0}' of type `{1}' causes a cycle in the struct layout",
 							field.GetSignatureForError (), ftype.GetSignatureForError ());
 						break;
 					}
 				}
 
 				if ((field.IsStatic && (!ftype.IsGeneric || ftype == CurrentType)))
 					continue;
 
 				if (!CheckFieldTypeCycle (ftype)) {
 					Report.Error (523, field.Location,
 						"Struct member `{0}' of type `{1}' causes a cycle in the struct layout",
 						field.GetSignatureForError (), ftype.GetSignatureForError ());
 					break;
 				}
 			}
 			foreach (FieldBase field in s.Fields) {
 				TypeSpec ftype = field.Spec.MemberType;
 				if (!ftype.IsStruct)
 					continue;
 
 				if (ftype is BuildinTypeSpec)
 					continue;
 
 				foreach (var targ in ftype.TypeArguments) {
 					if (!CheckFieldTypeCycle (targ)) {
 						Report.Error (523, field.Location,
 							"Struct member `{0}' of type `{1}' causes a cycle in the struct layout",
 							field.GetSignatureForError (), ftype.GetSignatureForError ());
 						break;
 					}
 				}
 
 				if ((field.IsStatic && (!ftype.IsGeneric || ftype == CurrentType)))
 					continue;
 
 				if (!CheckFieldTypeCycle (ftype)) {
 					Report.Error (523, field.Location,
 						"Struct member `{0}' of type `{1}' causes a cycle in the struct layout",
 						field.GetSignatureForError (), ftype.GetSignatureForError ());
 					break;
 				}
 			}
 
 			s.InTransit = false;
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1811" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1472" endline="1511">
<![CDATA[
 		
 		//
 		// Creates the ConstructorBuilder
 		//
 		public override bool Define ()
 		{
 			if (ConstructorBuilder != null)
 				return true;
 
 			var ca = MethodAttributes.RTSpecialName | MethodAttributes.SpecialName;
 			
 			if ((ModFlags & Modifiers.STATIC) != 0) {
 				ca |= MethodAttributes.Static | MethodAttributes.Private;
 			} else {
 				ca |= ModifiersExtensions.MethodAttr (ModFlags);
 			}
 
 			if (!CheckAbstractAndExtern (block != null))
 				return false;
 			
 			// Check if arguments were correct.
 			if (!CheckBase ())
 				return false;
 
 			ConstructorBuilder = Parent.TypeBuilder.DefineConstructor (
 				ca, CallingConventions,
 				parameters.GetMetaInfo ());
 
 			spec = new MethodSpec (MemberKind.Constructor, Parent.Definition, this, TypeManager.void_type, ConstructorBuilder, parameters, ModFlags);
 			
 			Parent.MemberCache.AddMember (spec);
 			
 			// It's here only to report an error
 			if (block != null && block.IsIterator) {
 				member_type = TypeManager.void_type;
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5142" endline="5184">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			if ((mode & AddressOp.Store) != 0)
 				spec.MemberDefinition.SetIsAssigned ();
 			if ((mode & AddressOp.Load) != 0)
 				spec.MemberDefinition.SetIsUsed ();
 
 			//
 			// Handle initonly fields specially
 			// get the address of the copy.
 			//
 			bool need_copy;
 			if (spec.IsReadOnly){
 				need_copy = true;
 				if (ec.HasSet (EmitContext.Options.ConstructorScope) && spec.DeclaringType == ec.CurrentType) {
 					if (IsStatic){
 						if (ec.IsStatic)
 							need_copy = false;
 					} else
 						need_copy = false;
 				}
 			} else
 				need_copy = false;
 			
 			if (need_copy){
 				LocalBuilder local;
 				Emit (ec);
 				local = ec.DeclareLocal (type, false);
 				ec.Emit (OpCodes.Stloc, local);
 				ec.Emit (OpCodes.Ldloca, local);
 				return;
 			}
 
 
 			if (IsStatic){
 				ec.Emit (OpCodes.Ldsflda, spec);
 			} else {
 				if (!prepared)
 					EmitInstance (ec, false);
 				ec.Emit (OpCodes.Ldflda, spec);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1812" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1472" endline="1511">
<![CDATA[
 		
 		//
 		// Creates the ConstructorBuilder
 		//
 		public override bool Define ()
 		{
 			if (ConstructorBuilder != null)
 				return true;
 
 			var ca = MethodAttributes.RTSpecialName | MethodAttributes.SpecialName;
 			
 			if ((ModFlags & Modifiers.STATIC) != 0) {
 				ca |= MethodAttributes.Static | MethodAttributes.Private;
 			} else {
 				ca |= ModifiersExtensions.MethodAttr (ModFlags);
 			}
 
 			if (!CheckAbstractAndExtern (block != null))
 				return false;
 			
 			// Check if arguments were correct.
 			if (!CheckBase ())
 				return false;
 
 			ConstructorBuilder = Parent.TypeBuilder.DefineConstructor (
 				ca, CallingConventions,
 				parameters.GetMetaInfo ());
 
 			spec = new MethodSpec (MemberKind.Constructor, Parent.Definition, this, TypeManager.void_type, ConstructorBuilder, parameters, ModFlags);
 			
 			Parent.MemberCache.AddMember (spec);
 			
 			// It's here only to report an error
 			if (block != null && block.IsIterator) {
 				member_type = TypeManager.void_type;
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1947" endline="1992">
<![CDATA[
 
 		public static Expression ExplicitUnsafe (Expression expr, TypeSpec target_type)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			if (target_type.IsPointer){
 				if (expr_type.IsPointer)
 					return EmptyCast.Create (expr, target_type);
 
 				if (expr_type == TypeManager.sbyte_type ||
 					expr_type == TypeManager.short_type ||
 					expr_type == TypeManager.int32_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I);
 
 				if (expr_type == TypeManager.ushort_type ||
 					expr_type == TypeManager.uint32_type ||
 					expr_type == TypeManager.byte_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U);
 
 				if (expr_type == TypeManager.int64_type)
 					return new ConvCast (expr, target_type, ConvCast.Mode.I8_I);
 
 				if (expr_type == TypeManager.uint64_type)
 					return new ConvCast (expr, target_type, ConvCast.Mode.U8_I);
 			}
 
 			if (expr_type.IsPointer){
 				if (target_type == TypeManager.sbyte_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I1);
 				if (target_type == TypeManager.byte_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U1);
 				if (target_type == TypeManager.short_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I2);
 				if (target_type == TypeManager.ushort_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U2);
 				if (target_type == TypeManager.int32_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I4);
 				if (target_type == TypeManager.uint32_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U4);
 				if (target_type == TypeManager.int64_type)
 					return new ConvCast (expr, target_type, ConvCast.Mode.I_I8);
 				if (target_type == TypeManager.uint64_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U8);
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1813" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="71" endline="97">
<![CDATA[
 
     Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If m_CecilBuilder Is Nothing Then
             m_CecilBuilder = New Mono.Cecil.MethodDefinition(Name, 0, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void))
             m_CecilBuilder.Annotations.Add(Compiler, Me)
         End If
         m_CecilBuilder.Name = Name
         m_CecilBuilder.HasThis = Not Me.IsShared
 
         If Signature IsNot Nothing AndAlso Signature.Parameters IsNot Nothing Then
             ReturnType = m_Signature.ReturnType
             If Signature.Parameters IsNot Nothing Then
                 For i As Integer = 0 To Signature.Parameters.Count - 1
                     Signature.Parameters(i).UpdateDefinition()
                 Next
             End If
         End If
 
         MethodAttributes = Helper.GetAttributes(Me)
         If IsExternalDeclaration Then
             MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.PreserveSig
         Else
             MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" startline="272" endline="310">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_ConstantExpression, m_TypeName, m_ParameterIdentifier) AndAlso result
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         'If ParameterType Is Nothing Then
         If m_TypeName IsNot Nothing Then
             ParameterType = m_TypeName.ResolvedType
             If m_ParameterIdentifier.ArrayNameModifier IsNot Nothing Then
                 If m_TypeName.IsArrayTypeName Then
                     Helper.AddError(Me)
                 Else
                     ParameterType = m_ParameterIdentifier.ArrayNameModifier.CreateArrayType(ParameterType)
                 End If
             End If
         ElseIf m_ParameterIdentifier.Identifier.HasTypeCharacter Then
             ParameterType = TypeCharacters.TypeCharacterToType(Compiler, m_ParameterIdentifier.Identifier.TypeCharacter)
         ElseIf ParameterType Is Nothing OrElse Helper.CompareType(ParameterType, Compiler.TypeCache.System_Void) Then
             If Me.Location.File(Compiler).IsOptionStrictOn Then
                 Helper.AddError(Me, "Parameter type must be specified.")
             Else
                 Helper.AddWarning("Parameter type should be specified.")
             End If
             ParameterType = Compiler.TypeCache.System_Object
         End If
         'End If
         Helper.Assert(ParameterType IsNot Nothing)
         If m_Modifiers.Is(ModifierMasks.ByRef) Then
             ParameterType = Compiler.TypeManager.MakeByRefType(Me, ParameterType)
         End If
 
         UpdateDefinition()
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1814" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="71" endline="97">
<![CDATA[
 
     Overrides Sub UpdateDefinition()
         MyBase.UpdateDefinition()
 
         If m_CecilBuilder Is Nothing Then
             m_CecilBuilder = New Mono.Cecil.MethodDefinition(Name, 0, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void))
             m_CecilBuilder.Annotations.Add(Compiler, Me)
         End If
         m_CecilBuilder.Name = Name
         m_CecilBuilder.HasThis = Not Me.IsShared
 
         If Signature IsNot Nothing AndAlso Signature.Parameters IsNot Nothing Then
             ReturnType = m_Signature.ReturnType
             If Signature.Parameters IsNot Nothing Then
                 For i As Integer = 0 To Signature.Parameters.Count - 1
                     Signature.Parameters(i).UpdateDefinition()
                 Next
             End If
         End If
 
         MethodAttributes = Helper.GetAttributes(Me)
         If IsExternalDeclaration Then
             MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.PreserveSig
         Else
             MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="95" endline="133">
<![CDATA[
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Dim attrib As New Attribute(Me)
         attrib.ResolvedType = Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute
         attrib.AttributeArguments.PositionalArgumentList.Add(m_LibraryClause.StringLiteral.StringLiteral)
         If m_AliasClause IsNot Nothing Then
             attrib.AttributeArguments.VariablePropertyInitializerList.Add("EntryPoint", m_AliasClause.StringLiteral.LiteralValue)
         Else
             attrib.AttributeArguments.VariablePropertyInitializerList.Add("EntryPoint", Name)
         End If
         attrib.AttributeArguments.VariablePropertyInitializerList.Add("SetLastError", True)
         attrib.AttributeArguments.VariablePropertyInitializerList.Add("PreserveSig", True)
         Select Case m_CharsetModifier
             Case KS.Auto
                 attrib.AttributeArguments.VariablePropertyInitializerList.Add("CharSet", System.Runtime.InteropServices.CharSet.Auto)
             Case KS.Unicode
                 attrib.AttributeArguments.VariablePropertyInitializerList.Add("CharSet", System.Runtime.InteropServices.CharSet.Unicode)
             Case KS.Ansi, KS.None
                 attrib.AttributeArguments.VariablePropertyInitializerList.Add("CharSet", System.Runtime.InteropServices.CharSet.Ansi)
             Case Else
                 Throw New InternalException
         End Select
         Me.CustomAttributes.Add(attrib)
 
         For i As Integer = 0 To Signature.Parameters.Count - 1
             If Helper.CompareType(Signature.Parameters(i).ParameterType, Compiler.TypeCache.System_String) AndAlso Signature.Parameters(i).CustomAttributes.Count = 0 Then
                 Signature.Parameters(i).ParameterType = New ByReferenceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_String))
                 Signature.Parameters(i).CecilBuilder.MarshalInfo = New Mono.Cecil.MarshalInfo(Mono.Cecil.NativeType.ByValStr)
                 Signature.Parameters(i).CecilBuilder.Attributes = Signature.Parameters(i).CecilBuilder.Attributes Or Mono.Cecil.ParameterAttributes.HasFieldMarshal
             End If
         Next
 
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1815" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="198" endline="229">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LoopControlVariable.ResolveCode(Info) AndAlso result
         If m_LoopControlVariable.GetVariableDeclaration IsNot Nothing Then
             MyBase.CodeBlock.AddVariable(m_LoopControlVariable.GetVariableDeclaration)
         End If
 
         result = m_InExpression.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_InExpression, Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If m_NextExpression IsNot Nothing Then
             'TODO
             Dim sneNext As SimpleNameExpression = TryCast(m_NextExpression, SimpleNameExpression)
             If sneNext IsNot Nothing Then
                 If Helper.CompareName(sneNext.Identifier.Identifier, m_LoopControlVariable.Identifier.Identifier) = False Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30070, sneNext.Location, m_LoopControlVariable.Identifier.Identifier) AndAlso result
                 End If
             End If
         End If
 
         Compiler.Helper.AddCheck("It is not valid to branch into a For Each statement block from outside the block.")
         Compiler.Helper.AddCheck("The loop control variable is specified either through an identifier followed by an As clause or an expression. (...) In the case of an expression, the expression must be classified as a variable. ")
         Compiler.Helper.AddCheck("The enumerator expression must be classified as a value and its type must be a collection type or Object. ")
         Compiler.Helper.AddCheck("If the type of the enumerator expression is Object, then all processing is deferred until run-time. Otherwise, a conversion must exist from the element type of the collection to the type of the loop control variable")
         Compiler.Helper.AddCheck("The loop control variable cannot be used by another enclosing For Each statement. ")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" startline="112" endline="145">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
         If m_FalseCode IsNot Nothing Then result = m_FalseCode.ResolveCode(Info) AndAlso result
         If m_ElseIfs IsNot Nothing Then result = m_ElseIfs.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_Condition.Classification.IsValueClassification Then
             'nothing to do
         ElseIf m_Condition.Classification.CanBeValueClassification Then
             m_Condition = m_Condition.ReclassifyToValueExpression
             result = m_Condition.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
 
             If result = False Then
                 Helper.AddError(Me)
                 Return result
             End If
         Else
             Helper.AddError(Me, "Each expression in an If...Then...Else statement must be classified as a value and be implicitly convertible to Boolean")
         End If
 
         m_Condition = Helper.CreateTypeConversion(Me, m_Condition, Compiler.TypeCache.System_Boolean, result)
 
         If result = False Then
             Helper.AddError(Me)
             Return result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1816" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" startline="198" endline="229">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LoopControlVariable.ResolveCode(Info) AndAlso result
         If m_LoopControlVariable.GetVariableDeclaration IsNot Nothing Then
             MyBase.CodeBlock.AddVariable(m_LoopControlVariable.GetVariableDeclaration)
         End If
 
         result = m_InExpression.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_InExpression, Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If m_NextExpression IsNot Nothing Then
             'TODO
             Dim sneNext As SimpleNameExpression = TryCast(m_NextExpression, SimpleNameExpression)
             If sneNext IsNot Nothing Then
                 If Helper.CompareName(sneNext.Identifier.Identifier, m_LoopControlVariable.Identifier.Identifier) = False Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30070, sneNext.Location, m_LoopControlVariable.Identifier.Identifier) AndAlso result
                 End If
             End If
         End If
 
         Compiler.Helper.AddCheck("It is not valid to branch into a For Each statement block from outside the block.")
         Compiler.Helper.AddCheck("The loop control variable is specified either through an identifier followed by an As clause or an expression. (...) In the case of an expression, the expression must be classified as a variable. ")
         Compiler.Helper.AddCheck("The enumerator expression must be classified as a value and its type must be a collection type or Object. ")
         Compiler.Helper.AddCheck("If the type of the enumerator expression is Object, then all processing is deferred until run-time. Otherwise, a conversion must exist from the element type of the collection to the type of the loop control variable")
         Compiler.Helper.AddCheck("The loop control variable cannot be used by another enclosing For Each statement. ")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" startline="364" endline="397">
<![CDATA[
 
     Private Function Compile_Resolve() As Boolean
         Dim result As Boolean = True
 
         result = CommandLine.Imports.ResolveCode(ResolveInfo.Default(Me)) AndAlso result
         VerifyConsistency(result, "ResolveCode")
         If result = False Then Return result
 
         result = CommandLine.Files.Resolve(ResolveInfo.Default(Me)) AndAlso result
         VerifyConsistency(result, "Resolve")
         If result = False Then Return result
 
         result = theAss.CreateImplicitTypes AndAlso result
         VerifyConsistency(result, "CreateImplicitTypes")
         If result = False Then Return result
 
         result = theAss.ResolveTypeReferences AndAlso result
         VerifyConsistency(result, "ResolveTypeReferences")
         If result = False Then Return result
 
         m_TypeCache.InitInternalVBMembers()
 
         result = theAss.CreateImplicitMembers AndAlso result
         VerifyConsistency(result, "CreateImplicitMembers")
         If result = False Then Return result
 
         result = theAss.ResolveMembers AndAlso result
         VerifyConsistency(result, "ResolveMembers")
         result = theAss.ResolveCode(ResolveInfo.Default(Me)) AndAlso result
 
         VerifyConsistency(result, "FinishedResolve")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1817" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4795" endline="4824">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			// is out param
 			if (right_side == EmptyExpression.OutAccess.Instance)
 				local_info.SetIsUsed ();
 
 			if (local_info.IsReadonly && !ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.UsingInitializerScope)) {
 				int code;
 				string msg;
 				if (right_side == EmptyExpression.OutAccess.Instance) {
 					code = 1657; msg = "Cannot pass `{0}' as a ref or out argument because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberAccess) {
 					code = 1654; msg = "Cannot assign to members of `{0}' because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberOutAccess) {
 					code = 1655; msg = "Cannot pass members of `{0}' as ref or out arguments because it is a `{1}'";
 				} else if (right_side == EmptyExpression.UnaryAddress) {
 					code = 459; msg = "Cannot take the address of {1} `{0}'";
 				} else {
 					code = 1656; msg = "Cannot assign to `{0}' because it is a `{1}'";
 				}
 				ec.Report.Error (code, loc, msg, Name, local_info.GetReadOnlyContext ());
 			} else if (VariableInfo != null) {
 				VariableInfo.SetAssigned (ec);
 			}
 
 			DoResolveBase (ec);
 
 			return base.DoResolveLValue (ec, right_side);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1933" endline="2008">
<![CDATA[
 
 		//
 		// Performs the validation on a Method's modifiers (properties have
 		// the same properties).
 		//
 		// TODO
 		//
 		public bool MethodModifiersValid (MemberCore mc)
 		{
 			const Modifiers vao = (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE);
 			const Modifiers nv = (Modifiers.NEW | Modifiers.VIRTUAL);
 			bool ok = true;
 			var flags = mc.ModFlags;
 			
 			//
 			// At most one of static, virtual or override
 			//
 			if ((flags & Modifiers.STATIC) != 0){
 				if ((flags & vao) != 0){
 					Report.Error (112, mc.Location, "A static member `{0}' cannot be marked as override, virtual or abstract",
 						mc.GetSignatureForError ());
 					ok = false;
 				}
 			}
 
 			if ((flags & Modifiers.OVERRIDE) != 0 && (flags & nv) != 0){
 				Report.Error (113, mc.Location, "A member `{0}' marked as override cannot be marked as new or virtual",
 					mc.GetSignatureForError ());
 				ok = false;
 			}
 
 			//
 			// If the declaration includes the abstract modifier, then the
 			// declaration does not include static, virtual or extern
 			//
 			if ((flags & Modifiers.ABSTRACT) != 0){
 				if ((flags & Modifiers.EXTERN) != 0){
 					Report.Error (
 						180, mc.Location, "`{0}' cannot be both extern and abstract", mc.GetSignatureForError ());
 					ok = false;
 				}
 
 				if ((flags & Modifiers.SEALED) != 0) {
 					Report.Error (502, mc.Location, "`{0}' cannot be both abstract and sealed", mc.GetSignatureForError ());
 					ok = false;
 				}
 
 				if ((flags & Modifiers.VIRTUAL) != 0){
 					Report.Error (503, mc.Location, "The abstract method `{0}' cannot be marked virtual", mc.GetSignatureForError ());
 					ok = false;
 				}
 
 				if ((ModFlags & Modifiers.ABSTRACT) == 0){
 					Report.SymbolRelatedToPreviousError (this);
 					Report.Error (513, mc.Location, "`{0}' is abstract but it is declared in the non-abstract class `{1}'",
 						mc.GetSignatureForError (), GetSignatureForError ());
 					ok = false;
 				}
 			}
 
 			if ((flags & Modifiers.PRIVATE) != 0){
 				if ((flags & vao) != 0){
 					Report.Error (621, mc.Location, "`{0}'
 					ok = false;
 				}
 			}
 
 			if ((flags & Modifiers.SEALED) != 0){
 				if ((flags & Modifiers.OVERRIDE) == 0){
 					Report.Error (238, mc.Location, "`{0}' cannot be sealed because it is not an override", mc.GetSignatureForError ());
 					ok = false;
 				}
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1818" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3269" endline="3315">
<![CDATA[
 
 		int TokenizeLessThan ()
 		{
 			int d;
 			if (handle_typeof) {
 				PushPosition ();
 				if (parse_generic_dimension (out d)) {
 					val = d;
 					DiscardPosition ();
 					return Token.GENERIC_DIMENSION;
 				}
 				PopPosition ();
 			}
 
 			// Save current position and parse next token.
 			PushPosition ();
 			if (parse_less_than ()) {
 				if (parsing_generic_declaration && token () != Token.DOT) {
 					d = Token.OP_GENERICS_LT_DECL;
 				} else {
 					d = Token.OP_GENERICS_LT;
 				}
 				PopPosition ();
 				return d;
 			}
 
 			PopPosition ();
 			parsing_generic_less_than = 0;
 
 			d = peek_char ();
 			if (d == '<') {
 				get_char ();
 				d = peek_char ();
 
 				if (d == '=') {
 					get_char ();
 					return Token.OP_SHIFT_LEFT_ASSIGN;
 				}
 				return Token.OP_SHIFT_LEFT;
 			}
 
 			if (d == '=') {
 				get_char ();
 				return Token.OP_LE;
 			}
 			return Token.OP_LT;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1780" endline="1835">
<![CDATA[
 
 		PreprocessorDirective get_cmd_arg (out string arg)
 		{
 			int c;		
 
 			tokens_seen = false;
 			arg = "";
 
 			var cmd = GetPreprocessorDirective (id_builder, TokenizePreprocessorIdentifier (out c));
 
 			if ((cmd & PreprocessorDirective.CustomArgumentsParsing) != 0)
 				return cmd;
 
 			// skip over white space
 			while (c == '\r' || c == ' ' || c == '\t')
 				c = get_char ();
 			while (c == '\r' || c == ' ' || c == '\t')
 				c = get_char ();
 
 			static_cmd_arg.Length = 0;
 			int has_identifier_argument = (int)(cmd & PreprocessorDirective.RequiresArgument);
 
 			while (c != -1 && c != '\n' && c != '\r') {
 				if (c == '\\' && has_identifier_argument >= 0) {
 					if (has_identifier_argument != 0) {
 						has_identifier_argument = 1;
 
 						int peek = peek_char ();
 						if (peek == 'U' || peek == 'u') {
 							int surrogate;
 							c = EscapeUnicode (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									static_cmd_arg.Append ((char) c);
 								c = surrogate;
 							}
 						}
 					} else {
 						has_identifier_argument = -1;
 					}
 				}
 				static_cmd_arg.Append ((char) c);
 				c = get_char ();
 			}
 			while (c != -1 && c != '\n' && c != '\r') {
 				if (c == '\\' && has_identifier_argument >= 0) {
 					if (has_identifier_argument != 0) {
 						has_identifier_argument = 1;
 
 						int peek = peek_char ();
 						if (peek == 'U' || peek == 'u') {
 							int surrogate;
 							c = EscapeUnicode (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									static_cmd_arg.Append ((char) c);
 								c = surrogate;
 							}
 						}
 					} else {
 						has_identifier_argument = -1;
 					}
 				}
 				static_cmd_arg.Append ((char) c);
 				c = get_char ();
 			}
 
 			if (static_cmd_arg.Length != 0) {
 				arg = static_cmd_arg.ToString ();
 
 				// Eat any trailing whitespaces and single-line comments
 				if (arg.IndexOf ("//") != -1) {
 					arg = arg.Substring (0, arg.IndexOf ("//"));
 				}
 
 				arg = arg.Trim (simple_whitespaces);
 			}
 
 			return cmd;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1819" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3269" endline="3315">
<![CDATA[
 
 		int TokenizeLessThan ()
 		{
 			int d;
 			if (handle_typeof) {
 				PushPosition ();
 				if (parse_generic_dimension (out d)) {
 					val = d;
 					DiscardPosition ();
 					return Token.GENERIC_DIMENSION;
 				}
 				PopPosition ();
 			}
 
 			// Save current position and parse next token.
 			PushPosition ();
 			if (parse_less_than ()) {
 				if (parsing_generic_declaration && token () != Token.DOT) {
 					d = Token.OP_GENERICS_LT_DECL;
 				} else {
 					d = Token.OP_GENERICS_LT;
 				}
 				PopPosition ();
 				return d;
 			}
 
 			PopPosition ();
 			parsing_generic_less_than = 0;
 
 			d = peek_char ();
 			if (d == '<') {
 				get_char ();
 				d = peek_char ();
 
 				if (d == '=') {
 					get_char ();
 					return Token.OP_SHIFT_LEFT_ASSIGN;
 				}
 				return Token.OP_SHIFT_LEFT;
 			}
 
 			if (d == '=') {
 				get_char ();
 				return Token.OP_LE;
 			}
 			return Token.OP_LT;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2604" endline="2642">
<![CDATA[
 
 		private int consume_string (bool quoted)
 		{
 			int c;
 			string_builder.Length = 0;
 
 			while (true){
 				c = get_char ();
 				if (c == '"') {
 					if (quoted && peek_char () == '"') {
 						string_builder.Append ((char) c);
 						get_char ();
 						continue;
 					}
 
 					val = new StringLiteral (string_builder.ToString (), Location);
 					return Token.LITERAL;
 				}
 
 				if (c == '\n') {
 					if (!quoted)
 						Report.Error (1010, Location, "Newline in constant");
 				} else if (c == '\\' && !quoted) {
 					int surrogate;
 					c = escape (c, out surrogate);
 					if (c == -1)
 						return Token.ERROR;
 					if (surrogate != 0) {
 						string_builder.Append ((char) c);
 						c = surrogate;
 					}
 				} else if (c == -1) {
 					Report.Error (1039, Location, "Unterminated string literal");
 					return Token.EOF;
 				}
 
 				string_builder.Append ((char) c);
 			}
 			while (true){
 				c = get_char ();
 				if (c == '"') {
 					if (quoted && peek_char () == '"') {
 						string_builder.Append ((char) c);
 						get_char ();
 						continue;
 					}
 
 					val = new StringLiteral (string_builder.ToString (), Location);
 					return Token.LITERAL;
 				}
 
 				if (c == '\n') {
 					if (!quoted)
 						Report.Error (1010, Location, "Newline in constant");
 				} else if (c == '\\' && !quoted) {
 					int surrogate;
 					c = escape (c, out surrogate);
 					if (c == -1)
 						return Token.ERROR;
 					if (surrogate != 0) {
 						string_builder.Append ((char) c);
 						c = surrogate;
 					}
 				} else if (c == -1) {
 					Report.Error (1039, Location, "Unterminated string literal");
 					return Token.EOF;
 				}
 
 				string_builder.Append ((char) c);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1820" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" startline="23" endline="67">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadtrue, endexp As Label
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
           
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1821" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="540" endline="569">
<![CDATA[
 
 		//
 		// The stack contains the pointer and the value of type `type'
 		//
 		public void EmitStoreFromPtr (TypeSpec type)
 		{
 			if (type.IsEnum)
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.int32_type || type == TypeManager.uint32_type)
 				ig.Emit (OpCodes.Stind_I4);
 			else if (type == TypeManager.int64_type || type == TypeManager.uint64_type)
 				ig.Emit (OpCodes.Stind_I8);
 			else if (type == TypeManager.char_type || type == TypeManager.short_type ||
 				 type == TypeManager.ushort_type)
 				ig.Emit (OpCodes.Stind_I2);
 			else if (type == TypeManager.float_type)
 				ig.Emit (OpCodes.Stind_R4);
 			else if (type == TypeManager.double_type)
 				ig.Emit (OpCodes.Stind_R8);
 			else if (type == TypeManager.byte_type || type == TypeManager.sbyte_type ||
 				 type == TypeManager.bool_type)
 				ig.Emit (OpCodes.Stind_I1);
 			else if (type == TypeManager.intptr_type)
 				ig.Emit (OpCodes.Stind_I);
 			else if (TypeManager.IsStruct (type) || TypeManager.IsGenericParameter (type))
 				Emit (OpCodes.Stobj, type);
 			else
 				ig.Emit (OpCodes.Stind_Ref);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="385" endline="426">
<![CDATA[
 
 		//
 		// Emits the right opcode to store to an array
 		//
 		public void EmitArrayStore (ArrayContainer ac)
 		{
 			if (ac.Rank > 1) {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Call, ac.GetSetMethod ());
 				return;
 			}
 
 			var type = ac.Element;
 
 			if (type.IsEnum)
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.byte_type || type == TypeManager.sbyte_type || type == TypeManager.bool_type)
 				Emit (OpCodes.Stelem_I1);
 			else if (type == TypeManager.short_type || type == TypeManager.ushort_type || type == TypeManager.char_type)
 				Emit (OpCodes.Stelem_I2);
 			else if (type == TypeManager.int32_type || type == TypeManager.uint32_type)
 				Emit (OpCodes.Stelem_I4);
 			else if (type == TypeManager.int64_type || type == TypeManager.uint64_type)
 				Emit (OpCodes.Stelem_I8);
 			else if (type == TypeManager.float_type)
 				Emit (OpCodes.Stelem_R4);
 			else if (type == TypeManager.double_type)
 				Emit (OpCodes.Stelem_R8);
 			else if (type == TypeManager.intptr_type)
 				Emit (OpCodes.Stobj, type);
 			else if (TypeManager.IsStruct (type))
 				Emit (OpCodes.Stobj, type);
 			else if (type.IsGenericParameter)
 				Emit (OpCodes.Stelem, type);
 			else if (type.IsPointer)
 				Emit (OpCodes.Stelem_I);
 			else
 				Emit (OpCodes.Stelem_Ref);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1822" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="540" endline="569">
<![CDATA[
 
 		//
 		// The stack contains the pointer and the value of type `type'
 		//
 		public void EmitStoreFromPtr (TypeSpec type)
 		{
 			if (type.IsEnum)
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.int32_type || type == TypeManager.uint32_type)
 				ig.Emit (OpCodes.Stind_I4);
 			else if (type == TypeManager.int64_type || type == TypeManager.uint64_type)
 				ig.Emit (OpCodes.Stind_I8);
 			else if (type == TypeManager.char_type || type == TypeManager.short_type ||
 				 type == TypeManager.ushort_type)
 				ig.Emit (OpCodes.Stind_I2);
 			else if (type == TypeManager.float_type)
 				ig.Emit (OpCodes.Stind_R4);
 			else if (type == TypeManager.double_type)
 				ig.Emit (OpCodes.Stind_R8);
 			else if (type == TypeManager.byte_type || type == TypeManager.sbyte_type ||
 				 type == TypeManager.bool_type)
 				ig.Emit (OpCodes.Stind_I1);
 			else if (type == TypeManager.intptr_type)
 				ig.Emit (OpCodes.Stind_I);
 			else if (TypeManager.IsStruct (type) || TypeManager.IsGenericParameter (type))
 				Emit (OpCodes.Stobj, type);
 			else
 				ig.Emit (OpCodes.Stind_Ref);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="335" endline="384">
<![CDATA[
 
 		//
 		// Emits the right opcode to load from an array
 		//
 		public void EmitArrayLoad (ArrayContainer ac)
 		{
 			if (ac.Rank > 1) {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Call, ac.GetGetMethod ());
 				return;
 			}
 
 			var type = ac.Element;
 			if (TypeManager.IsEnumType (type))
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.byte_type || type == TypeManager.bool_type)
 				Emit (OpCodes.Ldelem_U1);
 			else if (type == TypeManager.sbyte_type)
 				Emit (OpCodes.Ldelem_I1);
 			else if (type == TypeManager.short_type)
 				Emit (OpCodes.Ldelem_I2);
 			else if (type == TypeManager.ushort_type || type == TypeManager.char_type)
 				Emit (OpCodes.Ldelem_U2);
 			else if (type == TypeManager.int32_type)
 				Emit (OpCodes.Ldelem_I4);
 			else if (type == TypeManager.uint32_type)
 				Emit (OpCodes.Ldelem_U4);
 			else if (type == TypeManager.uint64_type)
 				Emit (OpCodes.Ldelem_I8);
 			else if (type == TypeManager.int64_type)
 				Emit (OpCodes.Ldelem_I8);
 			else if (type == TypeManager.float_type)
 				Emit (OpCodes.Ldelem_R4);
 			else if (type == TypeManager.double_type)
 				Emit (OpCodes.Ldelem_R8);
 			else if (type == TypeManager.intptr_type)
 				Emit (OpCodes.Ldelem_I);
 			else if (TypeManager.IsStruct (type)) {
 				Emit (OpCodes.Ldelema, type);
 				Emit (OpCodes.Ldobj, type);
 			} else if (type.IsGenericParameter) {
 				Emit (OpCodes.Ldelem, type);
 			} else if (type.IsPointer)
 				Emit (OpCodes.Ldelem_I);
 			else
 				Emit (OpCodes.Ldelem_Ref);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1823" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="120" endline="156">
<![CDATA[
 
 		internal override void WriteSig(ModuleBuilder module, ByteBuffer bb)
 		{
 			byte flags = PROPERTY;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes == null ? 0 
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers);
 			WriteType(module, bb, propertyType);
 			if (parameterTypes != null)
 			{
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers[i]);
 					}
 					if (parameterOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers[i]);
 					}
 					if (parameterOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="370" endline="418">
<![CDATA[
 
 		private void WriteSigImpl(ModuleBuilder module, ByteBuffer bb, int parameterCount)
 		{
 			byte first;
 			if ((callingConvention & CallingConventions.Any) == CallingConventions.VarArgs)
 			{
 				Debug.Assert(genericParamCount == 0);
 				first = VARARG;
 			}
 			else if (genericParamCount > 0)
 			{
 				first = GENERIC;
 			}
 			else
 			{
 				first = DEFAULT;
 			}
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				first |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				first |= EXPLICITTHIS;
 			}
 			bb.Write(first);
 			if (genericParamCount > 0)
 			{
 				bb.WriteCompressedInt(genericParamCount);
 			}
 			bb.WriteCompressedInt(parameterCount);
 			// RetType
 			if (modifiers != null && modifiers[0] != null)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[0][0]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[0][1]);
 			}
 			WriteType(module, bb, returnType);
 			// Param
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (modifiers != null && modifiers[i + 1] != null)
 				{
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[i + 1][0]);
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[i + 1][1]);
 				}
 				WriteType(module, bb, parameterTypes[i]);
 			}
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (modifiers != null && modifiers[i + 1] != null)
 				{
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[i + 1][0]);
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[i + 1][1]);
 				}
 				WriteType(module, bb, parameterTypes[i]);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1824" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="120" endline="156">
<![CDATA[
 
 		internal override void WriteSig(ModuleBuilder module, ByteBuffer bb)
 		{
 			byte flags = PROPERTY;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes == null ? 0 
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers);
 			WriteType(module, bb, propertyType);
 			if (parameterTypes != null)
 			{
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers[i]);
 					}
 					if (parameterOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers[i]);
 					}
 					if (parameterOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1207" endline="1287">
<![CDATA[
 
 		public static TypeCode GetTypeCode(Type type)
 		{
 			if (type == null)
 			{
 				return TypeCode.Empty;
 			}
 			if (type.IsEnum)
 			{
 				type = type.GetEnumUnderlyingType();
 			}
 			Universe u = type.Module.universe;
 			if (type == u.System_Boolean)
 			{
 				return TypeCode.Boolean;
 			}
 			else if (type == u.System_Char)
 			{
 				return TypeCode.Char;
 			}
 			else if (type == u.System_SByte)
 			{
 				return TypeCode.SByte;
 			}
 			else if (type == u.System_Byte)
 			{
 				return TypeCode.Byte;
 			}
 			else if (type == u.System_Int16)
 			{
 				return TypeCode.Int16;
 			}
 			else if (type == u.System_UInt16)
 			{
 				return TypeCode.UInt16;
 			}
 			else if (type == u.System_Int32)
 			{
 				return TypeCode.Int32;
 			}
 			else if (type == u.System_UInt32)
 			{
 				return TypeCode.UInt32;
 			}
 			else if (type == u.System_Int64)
 			{
 				return TypeCode.Int64;
 			}
 			else if (type == u.System_UInt64)
 			{
 				return TypeCode.UInt64;
 			}
 			else if (type == u.System_Single)
 			{
 				return TypeCode.Single;
 			}
 			else if (type == u.System_Double)
 			{
 				return TypeCode.Double;
 			}
 			else if (type == u.System_DateTime)
 			{
 				return TypeCode.DateTime;
 			}
 			else if (type == u.System_DBNull)
 			{
 				return TypeCode.DBNull;
 			}
 			else if (type == u.System_Decimal)
 			{
 				return TypeCode.Decimal;
 			}
 			else if (type == u.System_String)
 			{
 				return TypeCode.String;
 			}
 			else
 			{
 				return TypeCode.Object;
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1825" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="843" endline="892">
<![CDATA[
 		}
 
 		public static void CreateIterator (IMethodData method, TypeContainer parent, Modifiers modifiers, CompilerContext ctx)
 		{
 			bool is_enumerable;
 			TypeSpec iterator_type;
 
 			TypeSpec ret = method.ReturnType;
 			if (ret == null)
 				return;
 
 			if (!CheckType (ret, out iterator_type, out is_enumerable)) {
 				ctx.Report.Error (1624, method.Location,
 					      "The body of `{0}' cannot be an iterator block " +
 					      "because `{1}' is not an iterator interface type",
 					      method.GetSignatureForError (),
 					      TypeManager.CSharpName (ret));
 				return;
 			}
 
 			ParametersCompiled parameters = method.ParameterInfo;
 			for (int i = 0; i < parameters.Count; i++) {
 				Parameter p = parameters [i];
 				Parameter.Modifier mod = p.ModFlags;
 				if ((mod & Parameter.Modifier.ISBYREF) != 0) {
 					ctx.Report.Error (1623, p.Location,
 						"Iterators cannot have ref or out parameters");
 					return;
 				}
 
 				if (p is ArglistParameter) {
 					ctx.Report.Error (1636, method.Location,
 						"__arglist is not allowed in parameter list of iterators");
 					return;
 				}
 
 				if (parameters.Types [i].IsPointer) {
 					ctx.Report.Error (1637, p.Location,
 							  "Iterators cannot have unsafe parameters or " +
 							  "yield types");
 					return;
 				}
 			}
 			for (int i = 0; i < parameters.Count; i++) {
 				Parameter p = parameters [i];
 				Parameter.Modifier mod = p.ModFlags;
 				if ((mod & Parameter.Modifier.ISBYREF) != 0) {
 					ctx.Report.Error (1623, p.Location,
 						"Iterators cannot have ref or out parameters");
 					return;
 				}
 
 				if (p is ArglistParameter) {
 					ctx.Report.Error (1636, method.Location,
 						"__arglist is not allowed in parameter list of iterators");
 					return;
 				}
 
 				if (parameters.Types [i].IsPointer) {
 					ctx.Report.Error (1637, p.Location,
 							  "Iterators cannot have unsafe parameters or " +
 							  "yield types");
 					return;
 				}
 			}
 
 			if ((modifiers & Modifiers.UNSAFE) != 0) {
 				ctx.Report.Error (1629, method.Location, "Unsafe code may not appear in iterators");
 			}
 
 			method.Block.WrapIntoIterator (method, parent, iterator_type, is_enumerable);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="939" endline="1009">
<![CDATA[
 
 		//
 		// Checks that some operators come in pairs
 		//  == and !=
 		// > and <
 		// >= and <=
 		// true and false
 		//
 		// They are matched based on the return type and the argument types
 		//
 		void CheckPairedOperators ()
 		{
 			bool has_equality_or_inequality = false;
 			var operators = this.operators.ToArray ();
 			bool[] has_pair = new bool[operators.Length];
 
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null)
 					continue;
 
 				Operator o_a = (Operator) operators[i];
 				Operator.OpType o_type = o_a.OperatorType;
 				if (o_type == Operator.OpType.Equality || o_type == Operator.OpType.Inequality)
 					has_equality_or_inequality = true;
 
 				Operator.OpType matching_type = o_a.GetMatchingOperator ();
 				if (matching_type == Operator.OpType.TOP) {
 					operators[i] = null;
 					continue;
 				}
 
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 			}
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null)
 					continue;
 
 				Operator o_a = (Operator) operators[i];
 				Operator.OpType o_type = o_a.OperatorType;
 				if (o_type == Operator.OpType.Equality || o_type == Operator.OpType.Inequality)
 					has_equality_or_inequality = true;
 
 				Operator.OpType matching_type = o_a.GetMatchingOperator ();
 				if (matching_type == Operator.OpType.TOP) {
 					operators[i] = null;
 					continue;
 				}
 
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 			}
 
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null || has_pair[i])
 					continue;
 
 				Operator o = (Operator) operators [i];
 				Report.Error (216, o.Location,
 					"The operator `{0}' requires a matching operator `{1}' to also be defined",
 					o.GetSignatureForError (), Operator.GetName (o.GetMatchingOperator ()));
 			}
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null || has_pair[i])
 					continue;
 
 				Operator o = (Operator) operators [i];
 				Report.Error (216, o.Location,
 					"The operator `{0}' requires a matching operator `{1}' to also be defined",
 					o.GetSignatureForError (), Operator.GetName (o.GetMatchingOperator ()));
 			}
 
 			if (has_equality_or_inequality) {
 				if (Methods == null || !HasEquals)
 					Report.Warning (660, 2, Location, "`{0}' defines operator == or operator != but does not override Object.Equals(object o)",
 						GetSignatureForError ());
 
 				if (Methods == null || !HasGetHashCode)
 					Report.Warning (661, 2, Location, "`{0}' defines operator == or operator != but does not override Object.GetHashCode()",
 						GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1826" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="741" endline="771">
<![CDATA[
 
 		private MemberInfo GetMemberRef(int index, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if (memberRefs == null)
 			{
 				memberRefs = new MemberInfo[MemberRef.records.Length];
 			}
 			if (memberRefs[index] == null)
 			{
 				int owner = MemberRef.records[index].Class;
 				int sig = MemberRef.records[index].Signature;
 				string name = GetString(MemberRef.records[index].Name);
 				switch (owner >> 24)
 				{
 					case MethodDefTable.Index
 						return GetMethodAt(null, (owner & 0xFFFFFF) - 1);
 					case ModuleRefTable.Index
 						memberRefs[index] = ResolveTypeMemberRef(ResolveModuleType(owner), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
 						break;
 					case TypeDefTable.Index
 					case TypeRefTable.Index
 						memberRefs[index] = ResolveTypeMemberRef(ResolveType(owner), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
 						break;
 					case TypeSpecTable.Index
 						return ResolveTypeMemberRef(ResolveType(owner, genericTypeArguments, genericMethodArguments), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
 					default
 						throw new BadImageFormatException();
 				}
 			}
 			return memberRefs[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="240" endline="332">
<![CDATA[
 
 		private void CreateDllImportPseudoCustomAttribute(List<CustomAttributeData> attribs)
 		{
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.ImplMap.records.Length; i++)
 			{
 				if (module.ImplMap.records[i].MemberForwarded == token)
 				{
 					const short NoMangle = 0x0001;
 					const short CharSetMask = 0x0006;
 					const short CharSetNotSpec = 0x0000;
 					const short CharSetAnsi = 0x0002;
 					const short CharSetUnicode = 0x0004;
 					const short CharSetAuto = 0x0006;
 					const short SupportsLastError = 0x0040;
 					const short CallConvMask = 0x0700;
 					const short CallConvWinapi = 0x0100;
 					const short CallConvCdecl = 0x0200;
 					const short CallConvStdcall = 0x0300;
 					const short CallConvThiscall = 0x0400;
 					const short CallConvFastcall = 0x0500;
 					// non-standard flags
 					const short BestFitOn = 0x0010;
 					const short BestFitOff = 0x0020;
 					const short CharMapErrorOn = 0x1000;
 					const short CharMapErrorOff = 0x2000;
 
 					Type type = module.universe.System_Runtime_InteropServices_DllImportAttribute;
 					ConstructorInfo constructor = type.GetConstructor(new Type[] { module.universe.System_String });
 					List<CustomAttributeNamedArgument> list = new List<CustomAttributeNamedArgument>();
 					int flags = module.ImplMap.records[i].MappingFlags;
 					string entryPoint = module.GetString(module.ImplMap.records[i].ImportName);
 					string dllName = module.GetString(module.ModuleRef.records[(module.ImplMap.records[i].ImportScope & 0xFFFFFF) - 1]);
 					System.Runtime.InteropServices.CharSet? charSet;
 					switch (flags & CharSetMask)
 					{
 						case CharSetAnsi
 							charSet = System.Runtime.InteropServices.CharSet.Ansi;
 							break;
 						case CharSetUnicode
 							charSet = System.Runtime.InteropServices.CharSet.Unicode;
 							break;
 						case CharSetAuto
 							charSet = System.Runtime.InteropServices.CharSet.Auto;
 							break;
 						case CharSetNotSpec
 						default
 							charSet = null;
 							break;
 					}
 					System.Runtime.InteropServices.CallingConvention callingConvention;
 					switch (flags & CallConvMask)
 					{
 						case CallConvCdecl
 							callingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
 							break;
 						case CallConvFastcall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
 							break;
 						case CallConvStdcall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
 							break;
 						case CallConvThiscall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
 							break;
 						case CallConvWinapi
 						default
 							callingConvention = System.Runtime.InteropServices.CallingConvention.Winapi;
 							break;
 					}
 					list.Add(MakeNamedArgument(type, "EntryPoint", entryPoint));
 					list.Add(MakeNamedArgument(type, "ExactSpelling", flags, NoMangle));
 					list.Add(MakeNamedArgument(type, "SetLastError", flags, SupportsLastError));
 					list.Add(MakeNamedArgument(type, "PreserveSig", (int)GetMethodImplementationFlags(), (int)MethodImplAttributes.PreserveSig));
 					list.Add(MakeNamedArgument(type, "CallingConvention", (int)callingConvention));
 					if (charSet.HasValue)
 					{
 						list.Add(MakeNamedArgument(type, "CharSet", (int)charSet.Value));
 					}
 					if ((flags & (BestFitOn | BestFitOff)) != 0)
 					{
 						list.Add(MakeNamedArgument(type, "BestFitMapping", flags, BestFitOn));
 					}
 					if ((flags & (CharMapErrorOn | CharMapErrorOff)) != 0)
 					{
 						list.Add(MakeNamedArgument(type, "ThrowOnUnmappableChar", flags, CharMapErrorOn));
 					}
 					attribs.Add(new CustomAttributeData(constructor, new object[] { dllName }, list));
 					return;
 				}
 			}
 			for (int i = 0; i < module.ImplMap.records.Length; i++)
 			{
 				if (module.ImplMap.records[i].MemberForwarded == token)
 				{
 					const short NoMangle = 0x0001;
 					const short CharSetMask = 0x0006;
 					const short CharSetNotSpec = 0x0000;
 					const short CharSetAnsi = 0x0002;
 					const short CharSetUnicode = 0x0004;
 					const short CharSetAuto = 0x0006;
 					const short SupportsLastError = 0x0040;
 					const short CallConvMask = 0x0700;
 					const short CallConvWinapi = 0x0100;
 					const short CallConvCdecl = 0x0200;
 					const short CallConvStdcall = 0x0300;
 					const short CallConvThiscall = 0x0400;
 					const short CallConvFastcall = 0x0500;
 					// non-standard flags
 					const short BestFitOn = 0x0010;
 					const short BestFitOff = 0x0020;
 					const short CharMapErrorOn = 0x1000;
 					const short CharMapErrorOff = 0x2000;
 
 					Type type = module.universe.System_Runtime_InteropServices_DllImportAttribute;
 					ConstructorInfo constructor = type.GetConstructor(new Type[] { module.universe.System_String });
 					List<CustomAttributeNamedArgument> list = new List<CustomAttributeNamedArgument>();
 					int flags = module.ImplMap.records[i].MappingFlags;
 					string entryPoint = module.GetString(module.ImplMap.records[i].ImportName);
 					string dllName = module.GetString(module.ModuleRef.records[(module.ImplMap.records[i].ImportScope & 0xFFFFFF) - 1]);
 					System.Runtime.InteropServices.CharSet? charSet;
 					switch (flags & CharSetMask)
 					{
 						case CharSetAnsi
 							charSet = System.Runtime.InteropServices.CharSet.Ansi;
 							break;
 						case CharSetUnicode
 							charSet = System.Runtime.InteropServices.CharSet.Unicode;
 							break;
 						case CharSetAuto
 							charSet = System.Runtime.InteropServices.CharSet.Auto;
 							break;
 						case CharSetNotSpec
 						default
 							charSet = null;
 							break;
 					}
 					System.Runtime.InteropServices.CallingConvention callingConvention;
 					switch (flags & CallConvMask)
 					{
 						case CallConvCdecl
 							callingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
 							break;
 						case CallConvFastcall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
 							break;
 						case CallConvStdcall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
 							break;
 						case CallConvThiscall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
 							break;
 						case CallConvWinapi
 						default
 							callingConvention = System.Runtime.InteropServices.CallingConvention.Winapi;
 							break;
 					}
 					list.Add(MakeNamedArgument(type, "EntryPoint", entryPoint));
 					list.Add(MakeNamedArgument(type, "ExactSpelling", flags, NoMangle));
 					list.Add(MakeNamedArgument(type, "SetLastError", flags, SupportsLastError));
 					list.Add(MakeNamedArgument(type, "PreserveSig", (int)GetMethodImplementationFlags(), (int)MethodImplAttributes.PreserveSig));
 					list.Add(MakeNamedArgument(type, "CallingConvention", (int)callingConvention));
 					if (charSet.HasValue)
 					{
 						list.Add(MakeNamedArgument(type, "CharSet", (int)charSet.Value));
 					}
 					if ((flags & (BestFitOn | BestFitOff)) != 0)
 					{
 						list.Add(MakeNamedArgument(type, "BestFitMapping", flags, BestFitOn));
 					}
 					if ((flags & (CharMapErrorOn | CharMapErrorOff)) != 0)
 					{
 						list.Add(MakeNamedArgument(type, "ThrowOnUnmappableChar", flags, CharMapErrorOn));
 					}
 					attribs.Add(new CustomAttributeData(constructor, new object[] { dllName }, list));
 					return;
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1827" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="741" endline="771">
<![CDATA[
 
 		private MemberInfo GetMemberRef(int index, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if (memberRefs == null)
 			{
 				memberRefs = new MemberInfo[MemberRef.records.Length];
 			}
 			if (memberRefs[index] == null)
 			{
 				int owner = MemberRef.records[index].Class;
 				int sig = MemberRef.records[index].Signature;
 				string name = GetString(MemberRef.records[index].Name);
 				switch (owner >> 24)
 				{
 					case MethodDefTable.Index
 						return GetMethodAt(null, (owner & 0xFFFFFF) - 1);
 					case ModuleRefTable.Index
 						memberRefs[index] = ResolveTypeMemberRef(ResolveModuleType(owner), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
 						break;
 					case TypeDefTable.Index
 					case TypeRefTable.Index
 						memberRefs[index] = ResolveTypeMemberRef(ResolveType(owner), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
 						break;
 					case TypeSpecTable.Index
 						return ResolveTypeMemberRef(ResolveType(owner, genericTypeArguments, genericMethodArguments), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
 					default
 						throw new BadImageFormatException();
 				}
 			}
 			return memberRefs[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="342" endline="427">
<![CDATA[
 
 		internal Type ResolveType(int metadataToken, IGenericContext context)
 		{
 			switch (metadataToken >> 24)
 			{
 				case TypeDefTable.Index
 					PopulateTypeDef();
 					return typeDefs[(metadataToken & 0xFFFFFF) - 1];
 				case TypeRefTable.Index
 					{
 						if (typeRefs == null)
 						{
 							typeRefs = new Type[TypeRef.records.Length];
 						}
 						int index = (metadataToken & 0xFFFFFF) - 1;
 						if (typeRefs[index] == null)
 						{
 							int scope = TypeRef.records[index].ResolutionScope;
 							switch (scope >> 24)
 							{
 								case AssemblyRefTable.Index
 									{
 										Assembly assembly = ResolveAssemblyRef((scope & 0xFFFFFF) - 1);
 										string typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
 										Type type = assembly.GetType(typeName);
 										if (type == null)
 										{
 											throw new TypeLoadException(String.Format("Type '{0}' not found in assembly '{1}'", typeName, assembly.FullName));
 										}
 										typeRefs[index] = type;
 										break;
 									}
 								case TypeRefTable.Index
 									{
 										Type outer = ResolveType(scope, null);
 										typeRefs[index] = outer.GetNestedType(GetString(TypeRef.records[index].TypeName), BindingFlags.Public | BindingFlags.NonPublic);
 										break;
 									}
 								case ModuleTable.Index
 									if (scope != 0 && scope != 1)
 									{
 										throw new NotImplementedException("self reference scope?");
 									}
 									typeRefs[index] = GetType(GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName));
 									break;
 								case ModuleRefTable.Index
 									{
 										Module module = ResolveModuleRef(ModuleRef.records[(scope & 0xFFFFFF) - 1]);
 										string typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
 										Type type = assembly.GetType(typeName);
 										if (type == null)
 										{
 											throw new TypeLoadException(String.Format("Type '{0}' not found in module '{1}'", typeName, module.Name));
 										}
 										typeRefs[index] = type;
 										break;
 									}
 								default
 									throw new NotImplementedException("ResolutionScope = " + scope.ToString("X"));
 							}
 						}
 						return typeRefs[index];
 					}
 				case TypeSpecTable.Index
 					{
 						if (typeSpecs == null)
 						{
 							typeSpecs = new Type[TypeSpec.records.Length];
 						}
 						int index = (metadataToken & 0xFFFFFF) - 1;
 						Type type = typeSpecs[index];
 						if (type == null)
 						{
 							TrackingGenericContext tc = context == null ? null 
 							type = Signature.ReadTypeSpec(this, ByteReader.FromBlob(blobHeap, TypeSpec.records[index]), tc);
 							if (tc == null || !tc.IsUsed)
 							{
 								typeSpecs[index] = type;
 							}
 						}
 						return type;
 					}
 				default
 					throw new NotImplementedException(String.Format("0x{0
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1828" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="172" endline="216">
<![CDATA[
 
 		internal static PropertySignature ReadSig(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			byte flags = br.ReadByte();
 			if ((flags & PROPERTY) == 0)
 			{
 				throw new BadImageFormatException();
 			}
 			CallingConventions callingConvention = CallingConventions.Standard;
 			if ((flags & HASTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.HasThis;
 			}
 			if ((flags & EXPLICITTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.ExplicitThis;
 			}
 			Type returnType;
 			Type[] returnTypeRequiredCustomModifiers;
 			Type[] returnTypeOptionalCustomModifiers;
 			Type[] parameterTypes;
 			Type[][] parameterRequiredCustomModifiers;
 			Type[][] parameterOptionalCustomModifiers;
 			int paramCount = br.ReadCompressedInt();
 			ReadCustomModifiers(module, br, context, out returnTypeRequiredCustomModifiers, out returnTypeOptionalCustomModifiers);
 			returnType = ReadRetType(module, br, context);
 			parameterTypes = new Type[paramCount];
 			parameterRequiredCustomModifiers = null;
 			parameterOptionalCustomModifiers = null;
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (IsCustomModifier(br.PeekByte()))
 				{
 					if (parameterOptionalCustomModifiers == null)
 					{
 						parameterOptionalCustomModifiers = new Type[parameterTypes.Length][];
 						parameterRequiredCustomModifiers = new Type[parameterTypes.Length][];
 					}
 					ReadCustomModifiers(module, br, context, out parameterRequiredCustomModifiers[i], out parameterOptionalCustomModifiers[i]);
 				}
 				parameterTypes[i] = ReadParam(module, br, context);
 			}
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (IsCustomModifier(br.PeekByte()))
 				{
 					if (parameterOptionalCustomModifiers == null)
 					{
 						parameterOptionalCustomModifiers = new Type[parameterTypes.Length][];
 						parameterRequiredCustomModifiers = new Type[parameterTypes.Length][];
 					}
 					ReadCustomModifiers(module, br, context, out parameterRequiredCustomModifiers[i], out parameterOptionalCustomModifiers[i]);
 				}
 				parameterTypes[i] = ReadParam(module, br, context);
 			}
 			return new PropertySignature(callingConvention, returnType, returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers,
 				parameterTypes, parameterOptionalCustomModifiers, parameterRequiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="148" endline="213">
<![CDATA[
 
 		internal static __StandAloneMethodSig ReadStandAloneMethodSig(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			CallingConventions callingConvention = 0;
 			System.Runtime.InteropServices.CallingConvention unmanagedCallingConvention = 0;
 			bool unmanaged;
 			byte flags = br.ReadByte();
 			switch (flags & 7)
 			{
 				case DEFAULT
 					callingConvention = CallingConventions.Standard;
 					unmanaged = false;
 					break;
 				case 0x01
 					unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
 					unmanaged = true;
 					break;
 				case 0x02
 					unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
 					unmanaged = true;
 					break;
 				case 0x03
 					unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
 					unmanaged = true;
 					break;
 				case 0x04
 					unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
 					unmanaged = true;
 					break;
 				case VARARG
 					callingConvention = CallingConventions.VarArgs;
 					unmanaged = false;
 					break;
 				default
 					throw new BadImageFormatException();
 			}
 			if ((flags & HASTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.HasThis;
 			}
 			if ((flags & EXPLICITTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.ExplicitThis;
 			}
 			if ((flags & GENERIC) != 0)
 			{
 				throw new BadImageFormatException();
 			}
 			int paramCount = br.ReadCompressedInt();
 			SkipCustomModifiers(br);
 			Type returnType = ReadRetType(module, br, context);
 			List<Type> parameterTypes = new List<Type>();
 			List<Type> optionalParameterTypes = new List<Type>();
 			List<Type> curr = parameterTypes;
 			for (int i = 0; i < paramCount; i++)
 			{
 				if (br.PeekByte() == SENTINEL)
 				{
 					br.ReadByte();
 					curr = optionalParameterTypes;
 				}
 				SkipCustomModifiers(br);
 				curr.Add(ReadParam(module, br, context));
 			}
 			for (int i = 0; i < paramCount; i++)
 			{
 				if (br.PeekByte() == SENTINEL)
 				{
 					br.ReadByte();
 					curr = optionalParameterTypes;
 				}
 				SkipCustomModifiers(br);
 				curr.Add(ReadParam(module, br, context));
 			}
 			return new __StandAloneMethodSig(unmanaged, unmanagedCallingConvention, callingConvention, returnType, parameterTypes.ToArray(), optionalParameterTypes.ToArray());
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1831" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="125" endline="157">
<![CDATA[
 
 		public override __MethodImplMap __GetMethodImplMap()
 		{
 			List<MethodInfo> bodies = new List<MethodInfo>();
 			List<List<MethodInfo>> declarations = new List<List<MethodInfo>>();
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.MethodImpl.records.Length; i++)
 			{
 				if (module.MethodImpl.records[i].Class == token)
 				{
 					MethodInfo body = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodBody, typeArgs, null);
 					int index = bodies.IndexOf(body);
 					if (index == -1)
 					{
 						index = bodies.Count;
 						bodies.Add(body);
 						declarations.Add(new List<MethodInfo>());
 					}
 					MethodInfo declaration = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodDeclaration, typeArgs, null);
 					declarations[index].Add(declaration);
 				}
 			}
 			for (int i = 0; i < module.MethodImpl.records.Length; i++)
 			{
 				if (module.MethodImpl.records[i].Class == token)
 				{
 					MethodInfo body = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodBody, typeArgs, null);
 					int index = bodies.IndexOf(body);
 					if (index == -1)
 					{
 						index = bodies.Count;
 						bodies.Add(body);
 						declarations.Add(new List<MethodInfo>());
 					}
 					MethodInfo declaration = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodDeclaration, typeArgs, null);
 					declarations[index].Add(declaration);
 				}
 			}
 			__MethodImplMap map = new __MethodImplMap();
 			map.TargetType = this;
 			map.MethodBodies = bodies.ToArray();
 			map.MethodDeclarations = new MethodInfo[declarations.Count][];
 			for (int i = 0; i < map.MethodDeclarations.Length; i++)
 			{
 				map.MethodDeclarations[i] = declarations[i].ToArray();
 			}
 			for (int i = 0; i < map.MethodDeclarations.Length; i++)
 			{
 				map.MethodDeclarations[i] = declarations[i].ToArray();
 			}
 			return map;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="132" endline="173">
<![CDATA[
 
 		internal static void ReadDeclarativeSecurity(Assembly asm, List<CustomAttributeData> list, int action, ByteReader br)
 		{
 			Universe u = asm.universe;
 			if (br.PeekByte() == '.')
 			{
 				br.ReadByte();
 				int count = br.ReadCompressedInt();
 				for (int j = 0; j < count; j++)
 				{
 					Type type = ReadType(asm, br);
 					ConstructorInfo constructor;
 					if (type == u.System_Security_Permissions_HostProtectionAttribute && action == (int)System.Security.Permissions.SecurityAction.LinkDemand)
 					{
 						constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null);
 					}
 					else
 					{
 						constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { u.System_Security_Permissions_SecurityAction }, null);
 					}
 					// LAMESPEC there is an additional length here (probably of the named argument list)
 					ByteReader slice = br.Slice(br.ReadCompressedInt());
 					// LAMESPEC the count of named arguments is a compressed integer (instead of UInt16 as NumNamed in custom attributes)
 					list.Add(new CustomAttributeData(constructor, action, ReadNamedArguments(asm, slice, slice.ReadCompressedInt(), type)));
 				}
 				for (int j = 0; j < count; j++)
 				{
 					Type type = ReadType(asm, br);
 					ConstructorInfo constructor;
 					if (type == u.System_Security_Permissions_HostProtectionAttribute && action == (int)System.Security.Permissions.SecurityAction.LinkDemand)
 					{
 						constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null);
 					}
 					else
 					{
 						constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { u.System_Security_Permissions_SecurityAction }, null);
 					}
 					// LAMESPEC there is an additional length here (probably of the named argument list)
 					ByteReader slice = br.Slice(br.ReadCompressedInt());
 					// LAMESPEC the count of named arguments is a compressed integer (instead of UInt16 as NumNamed in custom attributes)
 					list.Add(new CustomAttributeData(constructor, action, ReadNamedArguments(asm, slice, slice.ReadCompressedInt(), type)));
 				}
 			}
 			else
 			{
 				// .NET 1.x format (xml)
 				char[] buf = new char[br.Length / 2];
 				for (int i = 0; i < buf.Length; i++)
 				{
 					buf[i] = br.ReadChar();
 				}
 				for (int i = 0; i < buf.Length; i++)
 				{
 					buf[i] = br.ReadChar();
 				}
 				string xml = new String(buf);
 				ConstructorInfo constructor = u.System_Security_Permissions_PermissionSetAttribute.GetConstructor(new Type[] { u.System_Security_Permissions_SecurityAction });
 				List<CustomAttributeNamedArgument> args = new List<CustomAttributeNamedArgument>();
 				args.Add(new CustomAttributeNamedArgument(u.System_Security_Permissions_PermissionSetAttribute.GetProperty("XML"),
 					new CustomAttributeTypedArgument(u.System_String, xml)));
 				list.Add(new CustomAttributeData(constructor, action, args));
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1832" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="125" endline="157">
<![CDATA[
 
 		public override __MethodImplMap __GetMethodImplMap()
 		{
 			List<MethodInfo> bodies = new List<MethodInfo>();
 			List<List<MethodInfo>> declarations = new List<List<MethodInfo>>();
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.MethodImpl.records.Length; i++)
 			{
 				if (module.MethodImpl.records[i].Class == token)
 				{
 					MethodInfo body = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodBody, typeArgs, null);
 					int index = bodies.IndexOf(body);
 					if (index == -1)
 					{
 						index = bodies.Count;
 						bodies.Add(body);
 						declarations.Add(new List<MethodInfo>());
 					}
 					MethodInfo declaration = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodDeclaration, typeArgs, null);
 					declarations[index].Add(declaration);
 				}
 			}
 			for (int i = 0; i < module.MethodImpl.records.Length; i++)
 			{
 				if (module.MethodImpl.records[i].Class == token)
 				{
 					MethodInfo body = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodBody, typeArgs, null);
 					int index = bodies.IndexOf(body);
 					if (index == -1)
 					{
 						index = bodies.Count;
 						bodies.Add(body);
 						declarations.Add(new List<MethodInfo>());
 					}
 					MethodInfo declaration = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodDeclaration, typeArgs, null);
 					declarations[index].Add(declaration);
 				}
 			}
 			__MethodImplMap map = new __MethodImplMap();
 			map.TargetType = this;
 			map.MethodBodies = bodies.ToArray();
 			map.MethodDeclarations = new MethodInfo[declarations.Count][];
 			for (int i = 0; i < map.MethodDeclarations.Length; i++)
 			{
 				map.MethodDeclarations[i] = declarations[i].ToArray();
 			}
 			for (int i = 0; i < map.MethodDeclarations.Length; i++)
 			{
 				map.MethodDeclarations[i] = declarations[i].ToArray();
 			}
 			return map;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1292" endline="1339">
<![CDATA[
 		}
 
 		// note that interface/delegate co- and contravariance is not considered
 		public bool IsAssignableFrom(Type type)
 		{
 			if (this.Equals(type))
 			{
 				return true;
 			}
 			else if (type == null)
 			{
 				return false;
 			}
 			else if (this.IsArray && type.IsArray)
 			{
 				if (this.GetArrayRank() != type.GetArrayRank())
 				{
 					return false;
 				}
 				else if (this.__IsVector && !type.__IsVector)
 				{
 					return false;
 				}
 				Type e1 = this.GetElementType();
 				Type e2 = type.GetElementType();
 				return e1.IsValueType == e2.IsValueType && e1.IsAssignableFrom(e2);
 			}
 			else if (this.IsSealed)
 			{
 				return false;
 			}
 			else if (this.IsInterface)
 			{
 				return Array.IndexOf(type.GetInterfaces(), this) != -1;
 			}
 			else if (type.IsInterface)
 			{
 				return this == this.Module.universe.System_Object;
 			}
 			else if (type.IsPointer)
 			{
 				return this == this.Module.universe.System_Object || this == this.Module.universe.System_ValueType;
 			}
 			else
 			{
 				return type.IsSubclassOf(this);
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1833" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4625" endline="4669">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="340" endline="419">
<![CDATA[
 
 		public static Expression ImplicitBoxingConversion (Expression expr, TypeSpec expr_type, TypeSpec target_type)
 		{
 			//
 			// From any value-type to the type object.
 			//
 			if (target_type == TypeManager.object_type || target_type == InternalType.Dynamic) {
 				//
 				// A pointer type cannot be converted to object
 				//
 				if (expr_type.IsPointer)
 					return null;
 
 				if (!TypeManager.IsValueType (expr_type))
 					return null;
 
 				return expr == null ? EmptyExpression.Null 
 			}
 			
 			//
 			// From any value-type to the type System.ValueType.
 			//
 			if (target_type == TypeManager.value_type) {
 				if (!TypeManager.IsValueType (expr_type))
 					return null;
 
 				return expr == null ? EmptyExpression.Null 
 			}
 
 			if (target_type == TypeManager.enum_type) {
 				//
 				// From any enum-type to the type System.Enum.
 				//
 				if (TypeManager.IsEnumType (expr_type))
 					return expr == null ? EmptyExpression.Null 
 			}
 
 			//
 			// From a nullable-type to a reference type, if a boxing conversion exists from
 			// the underlying type to the reference type
 			//
 			if (TypeManager.IsNullableType (expr_type)) {
 				if (!TypeManager.IsReferenceType (target_type))
 					return null;
 
 				var res = ImplicitBoxingConversion (expr, Nullable.NullableInfo.GetUnderlyingType (expr_type), target_type);
 
 				// "cast" underlying type to target type to emit correct InvalidCastException when
 				// underlying hierarchy changes without recompilation
 				if (res != null && expr != null)
 					res = new UnboxCast (res, target_type);
 
 				return res;
 			}
 
 			if (TypeSpec.IsBaseClass (expr_type, target_type, false)) {
 				//
 				// Don't box same type arguments
 				//
 				if (TypeManager.IsGenericParameter (expr_type) && expr_type != target_type)
 					return expr == null ? EmptyExpression.Null 
 
 				return null;
 			}
 
 			// This code is kind of mirrored inside ImplicitStandardConversionExists
 			// with the small distinction that we only probe there
 			//
 			// Always ensure that the code here and there is in sync
 
 			// from any class-type S to any interface-type T.
 			if (target_type.IsInterface) {
 				if (expr_type.ImplementsInterface (target_type, true) &&
 					(TypeManager.IsGenericParameter (expr_type) || TypeManager.IsValueType (expr_type))) {
 					return expr == null ? EmptyExpression.Null 
 				}
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1834" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4625" endline="4669">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3547" endline="3599">
<![CDATA[
 
 		private void CheckUselessComparison (ResolveContext ec, Constant c, TypeSpec type)
 		{
 			if (c == null || !IsTypeIntegral (type)
 				|| c is StringConstant
 				|| c is BoolConstant
 				|| c is FloatConstant
 				|| c is DoubleConstant
 				|| c is DecimalConstant
 				)
 				return;
 
 			long value = 0;
 
 			if (c is ULongConstant) {
 				ulong uvalue = ((ULongConstant) c).Value;
 				if (uvalue > long.MaxValue) {
 					if (type == TypeManager.byte_type ||
 					    type == TypeManager.sbyte_type ||
 					    type == TypeManager.short_type ||
 					    type == TypeManager.ushort_type ||
 					    type == TypeManager.int32_type ||
 					    type == TypeManager.uint32_type ||
 					    type == TypeManager.int64_type ||
 						type == TypeManager.char_type)
 						WarnUselessComparison (ec, type);
 					return;
 				}
 				value = (long) uvalue;
 			}
 			else if (c is ByteConstant)
 				value = ((ByteConstant) c).Value;
 			else if (c is SByteConstant)
 				value = ((SByteConstant) c).Value;
 			else if (c is ShortConstant)
 				value = ((ShortConstant) c).Value;
 			else if (c is UShortConstant)
 				value = ((UShortConstant) c).Value;
 			else if (c is IntConstant)
 				value = ((IntConstant) c).Value;
 			else if (c is UIntConstant)
 				value = ((UIntConstant) c).Value;
 			else if (c is LongConstant)
 				value = ((LongConstant) c).Value;
 			else if (c is CharConstant)
 				value = ((CharConstant)c).Value;
 
 			if (value == 0)
 				return;
 
 			if (IsValueOutOfRange (value, type))
 				WarnUselessComparison (ec, type);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1835" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1568" endline="1612">
<![CDATA[
 		}
 
 		// <summary>
 		//   Performs an `or' operation on the bit vector.  The `new_vector' may have a
 		//   different size than the current one.
 		// </summary>
 		private MyBitVector Or (MyBitVector new_vector)
 		{
 			if (Count == 0 || new_vector.Count == 0)
 				return this;
 
 			var o = new_vector.vector != null ? new_vector.vector 
 
 			if (o == null) {
 				int n = new_vector.Count;
 				if (n < Count) {
 					for (int i = 0; i < n; ++i)
 						this [i] = true;
 					for (int i = 0; i < n; ++i)
 						this [i] = true;
 				} else {
 					SetAll (true);
 				}
 				return this;
 			}
 
 			if (Count == o.Count) {
 				if (vector == null) {
 					if (shared == null)
 						return this;
 					initialize_vector ();
 				}
 				vector.Or (o);
 				return this;
 			}
 
 			int min = o.Count;
 			if (Count < min)
 				min = Count;
 
 			for (int i = 0; i < min; i++) {
 				if (o [i])
 					this [i] = true;
 			}
 			for (int i = 0; i < min; i++) {
 				if (o [i])
 					this [i] = true;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1613" endline="1661">
<![CDATA[
 
 		// <summary>
 		//   Performs an `and' operation on the bit vector.  The `new_vector' may have
 		//   a different size than the current one.
 		// </summary>
 		private MyBitVector And (MyBitVector new_vector)
 		{
 			if (Count == 0)
 				return this;
 
 			var o = new_vector.vector != null ? new_vector.vector 
 
 			if (o == null) {
 				for (int i = new_vector.Count; i < Count; ++i)
 					this [i] = false;
 				for (int i = new_vector.Count; i < Count; ++i)
 					this [i] = false;
 				return this;
 			}
 
 			if (o.Count == 0) {
 				SetAll (false);
 				return this;
 			}
 
 			if (Count == o.Count) {
 				if (vector == null) {
 					if (shared == null) {
 						shared = new_vector.MakeShared (Count);
 						return this;
 					}
 					initialize_vector ();
 				}
 				vector.And (o);
 				return this;
 			}
 
 			int min = o.Count;
 			if (Count < min)
 				min = Count;
 
 			for (int i = 0; i < min; i++) {
 				if (! o [i])
 					this [i] = false;
 			}
 			for (int i = 0; i < min; i++) {
 				if (! o [i])
 					this [i] = false;
 			}
 
 			for (int i = min; i < Count; i++)
 				this [i] = false;
 			for (int i = min; i < Count; i++)
 				this [i] = false;
 
 			return this;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1836" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="542" endline="571">
<![CDATA[
 		}
 
 		#endregion
 
 		public override string GetSignatureForError ()
 		{
 			switch (Name) {
 			case "Int32"
 			case "Int64"
 			case "String"
 			case "Boolean"
 			case "Void"
 			case "Object"
 			case "UInt32"
 			case "Int16"
 			case "UInt16"
 			case "UInt64"
 			case "Single"
 			case "Double"
 			case "Decimal"
 			case "Char"
 			case "Byte"
 			case "SByte"
 			}
 
 			if (ns.Length == 0)
 				return name;
 
 			return FullName;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="704" endline="792">
<![CDATA[
 
 #if NET_2_0
 	void WriteGenericConstraints (Type [] args)
 	{
 
 		foreach (Type t in args) {
 			bool first = true;
 			Type[] ifaces = TypeGetInterfaces (t, true);
 			
 			GenericParameterAttributes attrs = t.GenericParameterAttributes & GenericParameterAttributes.SpecialConstraintMask;
 			GenericParameterAttributes [] interesting = {
 				GenericParameterAttributes.ReferenceTypeConstraint,
 				GenericParameterAttributes.NotNullableValueTypeConstraint,
 				GenericParameterAttributes.DefaultConstructorConstraint
 			};
 			
 			if (t.BaseType != typeof (object) || ifaces.Length != 0 || attrs != 0) {
 				o.Write (" where ");
 				o.Write (FormatType (t));
 				o.Write (" 
 			}
 
 			if (t.BaseType != typeof (object)) {
 				o.Write (FormatType (t.BaseType));
 				first = false;
 			}
 
 			foreach (Type iface in ifaces) {
 				if (!first)
 					o.Write (", ");
 				first = false;
 				
 				o.Write (FormatType (iface));
 			}
 
 			foreach (GenericParameterAttributes a in interesting) {
 				if ((attrs & a) == 0)
 					continue;
 				
 				if (!first)
 					o.Write (", ");
 				first = false;
 				
 				switch (a) {
 				case GenericParameterAttributes.ReferenceTypeConstraint
 					o.Write ("class");
 					break;
 				case GenericParameterAttributes.NotNullableValueTypeConstraint
 					o.Write ("struct");
 					break;
 				case GenericParameterAttributes.DefaultConstructorConstraint
 					o.Write ("new ()");
 					break;
 				}
 			}
 		}
 	}
 #endif
  
 	string OperatorFromName (string name)
 	{
 		switch (name) {
 		case "op_UnaryPlus"
 		case "op_UnaryNegation"
 		case "op_LogicalNot"
 		case "op_OnesComplement"
 		case "op_Increment"
 		case "op_Decrement"
 		case "op_True"
 		case "op_False"
 		case "op_Addition"
 		case "op_Subtraction"
 		case "op_Multiply"
 		case "op_Division"
 		case "op_Modulus"
 		case "op_BitwiseAnd"
 		case "op_BitwiseOr"
 		case "op_ExclusiveOr"
 		case "op_LeftShift"
 		case "op_RightShift"
 		case "op_Equality"
 		case "op_Inequality"
 		case "op_GreaterThan"
 		case "op_LessThan"
 		case "op_GreaterThanOrEqual"
 		case "op_LessThanOrEqual"
 		default
 		}
 	}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1837" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1050" endline="1088">
<![CDATA[
 
 		//
 		// Use this method when you merge compiler generated parameters with user parameters
 		//
 		public static ParametersCompiled MergeGenerated (CompilerContext ctx, ParametersCompiled userParams, bool checkConflicts, Parameter[] compilerParams, TypeSpec[] compilerTypes)
 		{
 			Parameter[] all_params = new Parameter [userParams.Count + compilerParams.Length];
 			userParams.FixedParameters.CopyTo(all_params, 0);
 
 			TypeSpec [] all_types;
 			if (userParams.types != null) {
 				all_types = new TypeSpec [all_params.Length];
 				userParams.Types.CopyTo (all_types, 0);
 			} else {
 				all_types = null;
 			}
 
 			int last_filled = userParams.Count;
 			int index = 0;
 			foreach (Parameter p in compilerParams) {
 				for (int i = 0; i < last_filled; ++i) {
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 				}
 				for (int i = 0; i < last_filled; ++i) {
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 				}
 				all_params [last_filled] = p;
 				if (all_types != null)
 					all_types [last_filled] = compilerTypes [index++];
 				++last_filled;
 			}
 			foreach (Parameter p in compilerParams) {
 				for (int i = 0; i < last_filled; ++i) {
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 				}
 				all_params [last_filled] = p;
 				if (all_types != null)
 					all_types [last_filled] = compilerTypes [index++];
 				++last_filled;
 			}
 			
 			ParametersCompiled parameters = new ParametersCompiled (all_params, all_types);
 			parameters.has_params = userParams.has_params;
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="540" endline="637">
<![CDATA[
 
 		//
 		// Checks whether the type P is as accessible as this member
 		//
 		public bool IsAccessibleAs (TypeSpec p)
 		{
 			//
 			// if M is private, its accessibility is the same as this declspace.
 			// we already know that P is accessible to T before this method, so we
 			// may return true.
 			//
 			if ((mod_flags & Modifiers.PRIVATE) != 0)
 				return true;
 
 			while (TypeManager.HasElementType (p))
 				p = TypeManager.GetElementType (p);
 			while (TypeManager.HasElementType (p))
 				p = TypeManager.GetElementType (p);
 
 			if (p.IsGenericParameter)
 				return true;
 
 			for (TypeSpec p_parent; p != null; p = p_parent) {
 				p_parent = p.DeclaringType;
 
 				if (p.IsGeneric) {
 					foreach (TypeSpec t in p.TypeArguments) {
 						if (!IsAccessibleAs (t))
 							return false;
 					}
 					foreach (TypeSpec t in p.TypeArguments) {
 						if (!IsAccessibleAs (t))
 							return false;
 					}
 				}
 
 				var pAccess = p.Modifiers & Modifiers.AccessibilityMask;
 				if (pAccess == Modifiers.PUBLIC)
 					continue;
 
 				bool same_access_restrictions = false;
 				for (MemberCore mc = this; !same_access_restrictions && mc != null && mc.Parent != null; mc = mc.Parent) {
 					var al = mc.ModFlags & Modifiers.AccessibilityMask;
 					switch (pAccess) {
 					case Modifiers.INTERNAL
 						if (al == Modifiers.PRIVATE || al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						
 						break;
 
 					case Modifiers.PROTECTED
 						if (al == Modifiers.PROTECTED) {
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent);
 							break;
 						}
 
 						if (al == Modifiers.PRIVATE) {
 							//
 							// When type is private and any of its parents derives from
 							// protected type then the type is accessible
 							//
 							while (mc.Parent != null) {
 								if (mc.Parent.IsBaseTypeDefinition (p_parent))
 									same_access_restrictions = true;
 								mc = mc.Parent; 
 							}
 							while (mc.Parent != null) {
 								if (mc.Parent.IsBaseTypeDefinition (p_parent))
 									same_access_restrictions = true;
 								mc = mc.Parent; 
 							}
 						}
 						
 						break;
 
 					case Modifiers.PROTECTED | Modifiers.INTERNAL
 						if (al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else if (al == (Modifiers.PROTECTED | Modifiers.INTERNAL))
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent) && p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else
 							goto case Modifiers.PROTECTED;
 
 						break;
 
 					case Modifiers.PRIVATE
 						//
 						// Both are private and share same parent
 						//
 						if (al == Modifiers.PRIVATE) {
 							var decl = mc.Parent;
 							do {
 								same_access_restrictions = decl.CurrentType == p_parent;
 							} while (!same_access_restrictions && !decl.IsTopLevel && (decl = decl.Parent) != null);
 						}
 						
 						break;
 						
 					default
 						throw new InternalErrorException (al.ToString ());
 					}
 				}
 				for (MemberCore mc = this; !same_access_restrictions && mc != null && mc.Parent != null; mc = mc.Parent) {
 					var al = mc.ModFlags & Modifiers.AccessibilityMask;
 					switch (pAccess) {
 					case Modifiers.INTERNAL
 						if (al == Modifiers.PRIVATE || al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						
 						break;
 
 					case Modifiers.PROTECTED
 						if (al == Modifiers.PROTECTED) {
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent);
 							break;
 						}
 
 						if (al == Modifiers.PRIVATE) {
 							//
 							// When type is private and any of its parents derives from
 							// protected type then the type is accessible
 							//
 							while (mc.Parent != null) {
 								if (mc.Parent.IsBaseTypeDefinition (p_parent))
 									same_access_restrictions = true;
 								mc = mc.Parent; 
 							}
 						}
 						
 						break;
 
 					case Modifiers.PROTECTED | Modifiers.INTERNAL
 						if (al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else if (al == (Modifiers.PROTECTED | Modifiers.INTERNAL))
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent) && p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else
 							goto case Modifiers.PROTECTED;
 
 						break;
 
 					case Modifiers.PRIVATE
 						//
 						// Both are private and share same parent
 						//
 						if (al == Modifiers.PRIVATE) {
 							var decl = mc.Parent;
 							do {
 								same_access_restrictions = decl.CurrentType == p_parent;
 							} while (!same_access_restrictions && !decl.IsTopLevel && (decl = decl.Parent) != null);
 						}
 						
 						break;
 						
 					default
 						throw new InternalErrorException (al.ToString ());
 					}
 				}
 				
 				if (!same_access_restrictions)
 					return false;
 			}
 			for (TypeSpec p_parent; p != null; p = p_parent) {
 				p_parent = p.DeclaringType;
 
 				if (p.IsGeneric) {
 					foreach (TypeSpec t in p.TypeArguments) {
 						if (!IsAccessibleAs (t))
 							return false;
 					}
 				}
 
 				var pAccess = p.Modifiers & Modifiers.AccessibilityMask;
 				if (pAccess == Modifiers.PUBLIC)
 					continue;
 
 				bool same_access_restrictions = false;
 				for (MemberCore mc = this; !same_access_restrictions && mc != null && mc.Parent != null; mc = mc.Parent) {
 					var al = mc.ModFlags & Modifiers.AccessibilityMask;
 					switch (pAccess) {
 					case Modifiers.INTERNAL
 						if (al == Modifiers.PRIVATE || al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						
 						break;
 
 					case Modifiers.PROTECTED
 						if (al == Modifiers.PROTECTED) {
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent);
 							break;
 						}
 
 						if (al == Modifiers.PRIVATE) {
 							//
 							// When type is private and any of its parents derives from
 							// protected type then the type is accessible
 							//
 							while (mc.Parent != null) {
 								if (mc.Parent.IsBaseTypeDefinition (p_parent))
 									same_access_restrictions = true;
 								mc = mc.Parent; 
 							}
 						}
 						
 						break;
 
 					case Modifiers.PROTECTED | Modifiers.INTERNAL
 						if (al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else if (al == (Modifiers.PROTECTED | Modifiers.INTERNAL))
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent) && p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else
 							goto case Modifiers.PROTECTED;
 
 						break;
 
 					case Modifiers.PRIVATE
 						//
 						// Both are private and share same parent
 						//
 						if (al == Modifiers.PRIVATE) {
 							var decl = mc.Parent;
 							do {
 								same_access_restrictions = decl.CurrentType == p_parent;
 							} while (!same_access_restrictions && !decl.IsTopLevel && (decl = decl.Parent) != null);
 						}
 						
 						break;
 						
 					default
 						throw new InternalErrorException (al.ToString ());
 					}
 				}
 				
 				if (!same_access_restrictions)
 					return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1838" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1050" endline="1088">
<![CDATA[
 
 		//
 		// Use this method when you merge compiler generated parameters with user parameters
 		//
 		public static ParametersCompiled MergeGenerated (CompilerContext ctx, ParametersCompiled userParams, bool checkConflicts, Parameter[] compilerParams, TypeSpec[] compilerTypes)
 		{
 			Parameter[] all_params = new Parameter [userParams.Count + compilerParams.Length];
 			userParams.FixedParameters.CopyTo(all_params, 0);
 
 			TypeSpec [] all_types;
 			if (userParams.types != null) {
 				all_types = new TypeSpec [all_params.Length];
 				userParams.Types.CopyTo (all_types, 0);
 			} else {
 				all_types = null;
 			}
 
 			int last_filled = userParams.Count;
 			int index = 0;
 			foreach (Parameter p in compilerParams) {
 				for (int i = 0; i < last_filled; ++i) {
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 				}
 				for (int i = 0; i < last_filled; ++i) {
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 				}
 				all_params [last_filled] = p;
 				if (all_types != null)
 					all_types [last_filled] = compilerTypes [index++];
 				++last_filled;
 			}
 			foreach (Parameter p in compilerParams) {
 				for (int i = 0; i < last_filled; ++i) {
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 				}
 				all_params [last_filled] = p;
 				if (all_types != null)
 					all_types [last_filled] = compilerTypes [index++];
 				++last_filled;
 			}
 			
 			ParametersCompiled parameters = new ParametersCompiled (all_params, all_types);
 			parameters.has_params = userParams.has_params;
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="415" endline="492">
<![CDATA[
 
 		//
 		// Imports System.Reflection parameters
 		//
 		AParametersCollection CreateParameters (TypeSpec parent, ParameterInfo[] pi, MethodBase method)
 		{
 			int varargs = method != null && (method.CallingConvention & CallingConventions.VarArgs) != 0 ? 1 
 
 			if (pi.Length == 0 && varargs == 0)
 				return ParametersCompiled.EmptyReadOnlyParameters;
 
 			TypeSpec[] types = new TypeSpec[pi.Length + varargs];
 			IParameterData[] par = new IParameterData[pi.Length + varargs];
 			bool is_params = false;
 			for (int i = 0; i < pi.Length; i++) {
 				ParameterInfo p = pi[i];
 				Parameter.Modifier mod = 0;
 				Expression default_value = null;
 				if (p.ParameterType.IsByRef) {
 					if ((p.Attributes & (ParameterAttributes.Out | ParameterAttributes.In)) == ParameterAttributes.Out)
 						mod = Parameter.Modifier.OUT;
 					else
 						mod = Parameter.Modifier.REF;
 
 					//
 					// Strip reference wrapping
 					//
 					var el = p.ParameterType.GetElementType ();
 					types[i] = ImportType (el, new DynamicTypeReader (p));	// TODO
 				} else if (i == 0 && method.IsStatic && parent.IsStatic && parent.MemberDefinition.DeclaringAssembly.HasExtensionMethod &&
 					HasAttribute (CustomAttributeData.GetCustomAttributes (method), "ExtensionAttribute", CompilerServicesNamespace)) {
 					mod = Parameter.Modifier.This;
 					types[i] = ImportType (p.ParameterType);
 				} else {
 					types[i] = ImportType (p.ParameterType, new DynamicTypeReader (p));
 
 					if (i >= pi.Length - 2 && types[i] is ArrayContainer) {
 						if (HasAttribute (CustomAttributeData.GetCustomAttributes (p), "ParamArrayAttribute", "System")) {
 							mod = Parameter.Modifier.PARAMS;
 							is_params = true;
 						}
 					}
 
 					if (!is_params && p.IsOptional) {
 						object value = p.RawDefaultValue;
 						var ptype = types[i];
 						if ((p.Attributes & ParameterAttributes.HasDefault) != 0 && ptype.Kind != MemberKind.TypeParameter && (value != null || TypeManager.IsReferenceType (ptype))) {
 							if (value == null) {
 								default_value = Constant.CreateConstant (null, ptype, null, Location.Null);
 							} else {
 								default_value = ImportParameterConstant (value).Resolve (null);
 
 								if (ptype.IsEnum) {
 									default_value = new EnumConstant ((Constant) default_value, ptype).Resolve (null);
 								}
 							}
 						} else if (value == Missing.Value) {
 							default_value = EmptyExpression.MissingValue;
 						} else if (value == null) {
 							default_value = new DefaultValueExpression (new TypeExpression (ptype, Location.Null), Location.Null);
 						} else if (ptype == TypeManager.decimal_type) {
 							default_value = ImportParameterConstant (value).Resolve (null);
 						}
 					}
 				}
 
 				par[i] = new ParameterData (p.Name, mod, default_value);
 			}
 			for (int i = 0; i < pi.Length; i++) {
 				ParameterInfo p = pi[i];
 				Parameter.Modifier mod = 0;
 				Expression default_value = null;
 				if (p.ParameterType.IsByRef) {
 					if ((p.Attributes & (ParameterAttributes.Out | ParameterAttributes.In)) == ParameterAttributes.Out)
 						mod = Parameter.Modifier.OUT;
 					else
 						mod = Parameter.Modifier.REF;
 
 					//
 					// Strip reference wrapping
 					//
 					var el = p.ParameterType.GetElementType ();
 					types[i] = ImportType (el, new DynamicTypeReader (p));	// TODO
 				} else if (i == 0 && method.IsStatic && parent.IsStatic && parent.MemberDefinition.DeclaringAssembly.HasExtensionMethod &&
 					HasAttribute (CustomAttributeData.GetCustomAttributes (method), "ExtensionAttribute", CompilerServicesNamespace)) {
 					mod = Parameter.Modifier.This;
 					types[i] = ImportType (p.ParameterType);
 				} else {
 					types[i] = ImportType (p.ParameterType, new DynamicTypeReader (p));
 
 					if (i >= pi.Length - 2 && types[i] is ArrayContainer) {
 						if (HasAttribute (CustomAttributeData.GetCustomAttributes (p), "ParamArrayAttribute", "System")) {
 							mod = Parameter.Modifier.PARAMS;
 							is_params = true;
 						}
 					}
 
 					if (!is_params && p.IsOptional) {
 						object value = p.RawDefaultValue;
 						var ptype = types[i];
 						if ((p.Attributes & ParameterAttributes.HasDefault) != 0 && ptype.Kind != MemberKind.TypeParameter && (value != null || TypeManager.IsReferenceType (ptype))) {
 							if (value == null) {
 								default_value = Constant.CreateConstant (null, ptype, null, Location.Null);
 							} else {
 								default_value = ImportParameterConstant (value).Resolve (null);
 
 								if (ptype.IsEnum) {
 									default_value = new EnumConstant ((Constant) default_value, ptype).Resolve (null);
 								}
 							}
 						} else if (value == Missing.Value) {
 							default_value = EmptyExpression.MissingValue;
 						} else if (value == null) {
 							default_value = new DefaultValueExpression (new TypeExpression (ptype, Location.Null), Location.Null);
 						} else if (ptype == TypeManager.decimal_type) {
 							default_value = ImportParameterConstant (value).Resolve (null);
 						}
 					}
 				}
 
 				par[i] = new ParameterData (p.Name, mod, default_value);
 			}
 
 			if (varargs != 0) {
 				par[par.Length - 1] = new ArglistParameter (Location.Null);
 				types[types.Length - 1] = InternalType.Arglist;
 			}
 
 			return method != null ?
 				new ParametersImported (par, types, varargs != 0, is_params) 
 				new ParametersImported (par, types, is_params);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1839" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1368" endline="1414">
<![CDATA[
 
 		public InterfaceMapping GetInterfaceMap(Type interfaceType)
 		{
 			CheckBaked();
 			InterfaceMapping map = new InterfaceMapping();
 			if (!IsDirectlyImplementedInterface(interfaceType))
 			{
 				Type baseType = this.BaseType;
 				if (baseType == null)
 				{
 					throw new ArgumentException();
 				}
 				else
 				{
 					map = baseType.GetInterfaceMap(interfaceType);
 				}
 			}
 			else
 			{
 				map.InterfaceMethods = interfaceType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
 				map.InterfaceType = interfaceType;
 				map.TargetMethods = new MethodInfo[map.InterfaceMethods.Length];
 				FillInExplicitInterfaceMethods(map.InterfaceMethods, map.TargetMethods);
 				MethodInfo[] methods = GetMethods(BindingFlags.Instance | BindingFlags.Public);
 				for (int i = 0; i < map.TargetMethods.Length; i++)
 				{
 					if (map.TargetMethods[i] == null)
 					{
 						// TODO use proper method resolution (also take into account that no implicit base class implementation is used across assembly boundaries)
 						for (int j = 0; j < methods.Length; j++)
 						{
 							if (methods[j].Name == map.InterfaceMethods[i].Name
 								&& methods[j].MethodSignature.Equals(map.InterfaceMethods[i].MethodSignature))
 							{
 								map.TargetMethods[i] = methods[j];
 							}
 						}
 						for (int j = 0; j < methods.Length; j++)
 						{
 							if (methods[j].Name == map.InterfaceMethods[i].Name
 								&& methods[j].MethodSignature.Equals(map.InterfaceMethods[i].MethodSignature))
 							{
 								map.TargetMethods[i] = methods[j];
 							}
 						}
 					}
 				}
 				for (int i = 0; i < map.TargetMethods.Length; i++)
 				{
 					if (map.TargetMethods[i] == null)
 					{
 						// TODO use proper method resolution (also take into account that no implicit base class implementation is used across assembly boundaries)
 						for (int j = 0; j < methods.Length; j++)
 						{
 							if (methods[j].Name == map.InterfaceMethods[i].Name
 								&& methods[j].MethodSignature.Equals(map.InterfaceMethods[i].MethodSignature))
 							{
 								map.TargetMethods[i] = methods[j];
 							}
 						}
 					}
 				}
 				for (Type baseType = this.BaseType; baseType != null && interfaceType.IsAssignableFrom(baseType); baseType = baseType.BaseType)
 				{
 					baseType.FillInExplicitInterfaceMethods(map.InterfaceMethods, map.TargetMethods);
 				}
 				for (Type baseType = this.BaseType; baseType != null && interfaceType.IsAssignableFrom(baseType); baseType = baseType.BaseType)
 				{
 					baseType.FillInExplicitInterfaceMethods(map.InterfaceMethods, map.TargetMethods);
 				}
 			}
 			map.TargetType = this;
 			return map;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="391" endline="437">
<![CDATA[
 		}
 
 		public override object RawDefaultValue
 		{
 			get
 			{
 				if ((this.Attributes & ParameterAttributes.HasDefault) != 0)
 				{
 					return this.Module.Constant.GetRawConstantValue(this.Module, this.MetadataToken);
 				}
 				Universe universe = this.Module.universe;
 				if (this.ParameterType == universe.System_Decimal)
 				{
 					Type attr = universe.System_Runtime_CompilerServices_DecimalConstantAttribute;
 					if (attr != null)
 					{
 						foreach (CustomAttributeData cad in GetCustomAttributesData(attr))
 						{
 							IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
 							if (args.Count == 5)
 							{
 								if (args[0].ArgumentType == universe.System_Byte
 									&& args[1].ArgumentType == universe.System_Byte
 									&& args[2].ArgumentType == universe.System_Int32
 									&& args[3].ArgumentType == universe.System_Int32
 									&& args[4].ArgumentType == universe.System_Int32)
 								{
 									return new Decimal((int)args[4].Value, (int)args[3].Value, (int)args[2].Value, (byte)args[1].Value != 0, (byte)args[0].Value);
 								}
 								else if (args[0].ArgumentType == universe.System_Byte
 									&& args[1].ArgumentType == universe.System_Byte
 									&& args[2].ArgumentType == universe.System_UInt32
 									&& args[3].ArgumentType == universe.System_UInt32
 									&& args[4].ArgumentType == universe.System_UInt32)
 								{
 									return new Decimal(unchecked((int)(uint)args[4].Value), unchecked((int)(uint)args[3].Value), unchecked((int)(uint)args[2].Value), (byte)args[1].Value != 0, (byte)args[0].Value);
 								}
 							}
 						}
 						foreach (CustomAttributeData cad in GetCustomAttributesData(attr))
 						{
 							IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
 							if (args.Count == 5)
 							{
 								if (args[0].ArgumentType == universe.System_Byte
 									&& args[1].ArgumentType == universe.System_Byte
 									&& args[2].ArgumentType == universe.System_Int32
 									&& args[3].ArgumentType == universe.System_Int32
 									&& args[4].ArgumentType == universe.System_Int32)
 								{
 									return new Decimal((int)args[4].Value, (int)args[3].Value, (int)args[2].Value, (byte)args[1].Value != 0, (byte)args[0].Value);
 								}
 								else if (args[0].ArgumentType == universe.System_Byte
 									&& args[1].ArgumentType == universe.System_Byte
 									&& args[2].ArgumentType == universe.System_UInt32
 									&& args[3].ArgumentType == universe.System_UInt32
 									&& args[4].ArgumentType == universe.System_UInt32)
 								{
 									return new Decimal(unchecked((int)(uint)args[4].Value), unchecked((int)(uint)args[3].Value), unchecked((int)(uint)args[2].Value), (byte)args[1].Value != 0, (byte)args[0].Value);
 								}
 							}
 						}
 					}
 				}
 				if ((this.Attributes & ParameterAttributes.Optional) != 0)
 				{
 					return Missing.Value;
 				}
 				return null;
 			}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1840" nfragments="2" Csharpe_files="1" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2052" endline="2110">
<![CDATA[
 
 		//
 		// When any element of the type is a dynamic type
 		//
 		// This method builds a transformation array for dynamic types
 		// used in places where DynamicAttribute cannot be applied to.
 		// It uses bool flag when type is of dynamic type and each
 		// section always starts with "false" for some reason.
 		//
 		// LAMESPEC
 		// 
 		// Example
 		// Transformation
 		//
 		static bool[] GetTransformationFlags (TypeSpec t)
 		{
 			bool[] element;
 			var ac = t as ArrayContainer;
 			if (ac != null) {
 				element = GetTransformationFlags (ac.Element);
 				if (element == null)
 					return null;
 
 				bool[] res = new bool[element.Length + 1];
 				res[0] = false;
 				Array.Copy (element, 0, res, 1, element.Length);
 				return res;
 			}
 
 			if (t == null)
 				return null;
 
 			if (t.IsGeneric) {
 				List<bool> transform = null;
 				var targs = t.TypeArguments;
 				for (int i = 0; i < targs.Length; ++i) {
 					element = GetTransformationFlags (targs[i]);
 					if (element != null) {
 						if (transform == null) {
 							transform = new List<bool> ();
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 						}
 
 						transform.AddRange (element);
 					} else if (transform != null) {
 						transform.Add (false);
 					}
 				}
 				for (int i = 0; i < targs.Length; ++i) {
 					element = GetTransformationFlags (targs[i]);
 					if (element != null) {
 						if (transform == null) {
 							transform = new List<bool> ();
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 						}
 
 						transform.AddRange (element);
 					} else if (transform != null) {
 						transform.Add (false);
 					}
 				}
 
 				if (transform != null)
 					return transform.ToArray ();
 			}
 
 			if (t == InternalType.Dynamic)
 				return new bool[] { true };
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6356" endline="6402">
<![CDATA[
 
 string GetExpecting ()
 {
 	int [] tokens = yyExpectingTokens (yyExpectingState);
 	var names = new List<string> (tokens.Length);
 	bool has_type = false;
 	bool has_identifier = false;
 	for (int i = 0; i < tokens.Length; i++){
 		int token = tokens [i];
 		has_identifier |= token == Token.IDENTIFIER;
 		
 		string name = GetTokenName (token);
 		if (name == "<internal>")
 			continue;
 			
 		has_type |= name == "type";
 		if (names.Contains (name))
 			continue;
 		
 		names.Add (name);
 	}
 	for (int i = 0; i < tokens.Length; i++){
 		int token = tokens [i];
 		has_identifier |= token == Token.IDENTIFIER;
 		
 		string name = GetTokenName (token);
 		if (name == "<internal>")
 			continue;
 			
 		has_type |= name == "type";
 		if (names.Contains (name))
 			continue;
 		
 		names.Add (name);
 	}
 
 	//
 	// Too many tokens to enumerate
 	//
 	if (names.Count > 8)
 		return null;
 
 	if (has_type && has_identifier)
 		names.Remove ("identifier");
 
 	if (names.Count == 1)
 		return "`" + GetTokenName (tokens [0]) + "'";
 	
 	StringBuilder sb = new StringBuilder ();
 	names.Sort ();
 	int count = names.Count;
 	for (int i = 0; i < count; i++){
 		bool last = i + 1 == count;
 		if (last)
 			sb.Append ("or ");
 		sb.Append ('`');
 		sb.Append (names [i]);
 		sb.Append (last ? "'" 
 	}
 	for (int i = 0; i < count; i++){
 		bool last = i + 1 == count;
 		if (last)
 			sb.Append ("or ");
 		sb.Append ('`');
 		sb.Append (names [i]);
 		sb.Append (last ? "'" 
 	}
 	return sb.ToString ();
 }
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1841" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1877" endline="1932">
<![CDATA[
 
 		public virtual void CloseType ()
 		{
 			if ((caching_flags & Flags.CloseTypeCreated) != 0)
 				return;
 
 			// Close base type container first to avoid TypeLoadException
 			if (spec.BaseType != null) {
 				var btype = spec.BaseType.MemberDefinition as TypeContainer;
 				if (btype != null) {
 					btype.CloseType ();
 
 					if ((caching_flags & Flags.CloseTypeCreated) != 0)
 						return;
 				}
 			}
 
 			try {
 				caching_flags |= Flags.CloseTypeCreated;
 				TypeBuilder.CreateType ();
 			} catch (TypeLoadException){
 				//
 				// This is fine, the code still created the type
 				//
 //				Report.Warning (-20, "Exception while creating class
 //				Console.WriteLine (e.Message);
 			} catch (Exception e) {
 				throw new InternalErrorException (this, e);
 			}
 			
 			if (Types != null){
 				foreach (TypeContainer tc in Types)
 					tc.CloseType ();
 				foreach (TypeContainer tc in Types)
 					tc.CloseType ();
 			}
 
 			if (compiler_generated != null)
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 			
 			types = null;
 			fields = null;
 			initialized_fields = null;
 			initialized_static_fields = null;
 			constants = null;
 			ordered_explicit_member_list = null;
 			ordered_member_list = null;
 			methods = null;
 			events = null;
 			indexers = null;
 			operators = null;
 			compiler_generated = null;
 			default_constructor = null;
 			default_static_constructor = null;
 			type_bases = null;
 			OptAttributes = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1812" endline="1876">
<![CDATA[
 
 		/// <summary>
 		///   Emits the code, this step is performed after all
 		///   the types, enumerations, constructors
 		/// </summary>
 		public virtual void EmitType ()
 		{
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			Emit ();
 
 			EmitConstructors ();
 
 			if (constants != null)
 				foreach (Const con in constants)
 					con.Emit ();
 				foreach (Const con in constants)
 					con.Emit ();
 
 			if (default_static_constructor != null)
 				default_static_constructor.Emit ();
 			
 			if (operators != null)
 				foreach (Operator o in operators)
 					o.Emit ();
 				foreach (Operator o in operators)
 					o.Emit ();
 
 			if (properties != null)
 				foreach (Property p in properties)
 					p.Emit ();
 				foreach (Property p in properties)
 					p.Emit ();
 
 			if (indexers != null) {
 				foreach (Indexer indx in indexers)
 					indx.Emit ();
 				foreach (Indexer indx in indexers)
 					indx.Emit ();
 				EmitIndexerName ();
 			}
 
 			if (events != null){
 				foreach (Event e in Events)
 					e.Emit ();
 				foreach (Event e in Events)
 					e.Emit ();
 			}
 
 			if (methods != null) {
 				for (int i = 0; i < methods.Count; ++i)
 					((MethodOrOperator) methods [i]).Emit ();
 				for (int i = 0; i < methods.Count; ++i)
 					((MethodOrOperator) methods [i]).Emit ();
 			}
 			
 			if (fields != null)
 				foreach (FieldBase f in fields)
 					f.Emit ();
 				foreach (FieldBase f in fields)
 					f.Emit ();
 
 			if (types != null) {
 				foreach (TypeContainer t in types)
 					t.EmitType ();
 				foreach (TypeContainer t in types)
 					t.EmitType ();
 			}
 
 			if (pending != null)
 				pending.VerifyPendingMethods (Report);
 
 			if (Report.Errors > 0)
 				return;
 
 			if (compiler_generated != null) {
 				for (int i = 0; i < compiler_generated.Count; ++i)
 					compiler_generated [i].EmitType ();
 				for (int i = 0; i < compiler_generated.Count; ++i)
 					compiler_generated [i].EmitType ();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1842" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1877" endline="1932">
<![CDATA[
 
 		public virtual void CloseType ()
 		{
 			if ((caching_flags & Flags.CloseTypeCreated) != 0)
 				return;
 
 			// Close base type container first to avoid TypeLoadException
 			if (spec.BaseType != null) {
 				var btype = spec.BaseType.MemberDefinition as TypeContainer;
 				if (btype != null) {
 					btype.CloseType ();
 
 					if ((caching_flags & Flags.CloseTypeCreated) != 0)
 						return;
 				}
 			}
 
 			try {
 				caching_flags |= Flags.CloseTypeCreated;
 				TypeBuilder.CreateType ();
 			} catch (TypeLoadException){
 				//
 				// This is fine, the code still created the type
 				//
 //				Report.Warning (-20, "Exception while creating class
 //				Console.WriteLine (e.Message);
 			} catch (Exception e) {
 				throw new InternalErrorException (this, e);
 			}
 			
 			if (Types != null){
 				foreach (TypeContainer tc in Types)
 					tc.CloseType ();
 				foreach (TypeContainer tc in Types)
 					tc.CloseType ();
 			}
 
 			if (compiler_generated != null)
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 			
 			types = null;
 			fields = null;
 			initialized_fields = null;
 			initialized_static_fields = null;
 			constants = null;
 			ordered_explicit_member_list = null;
 			ordered_member_list = null;
 			methods = null;
 			events = null;
 			indexers = null;
 			operators = null;
 			compiler_generated = null;
 			default_constructor = null;
 			default_static_constructor = null;
 			type_bases = null;
 			OptAttributes = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1226" endline="1263">
<![CDATA[
 
 		public virtual void DefineConstants ()
 		{
 			if (constants != null) {
 				foreach (Const c in constants) {
 					c.DefineValue ();
 				}
 				foreach (Const c in constants) {
 					c.DefineValue ();
 				}
 			}
 
 			if (instance_constructors != null) {
 				foreach (MethodCore m in instance_constructors) {
 					var p = m.ParameterInfo;
 					if (!p.IsEmpty) {
 						p.ResolveDefaultValues (m);
 					}
 				}
 				foreach (MethodCore m in instance_constructors) {
 					var p = m.ParameterInfo;
 					if (!p.IsEmpty) {
 						p.ResolveDefaultValues (m);
 					}
 				}
 			}
 
 			if (methods != null) {
 				foreach (MethodCore m in methods) {
 					var p = m.ParameterInfo;
 					if (!p.IsEmpty) {
 						p.ResolveDefaultValues (m);
 					}
 				}
 				foreach (MethodCore m in methods) {
 					var p = m.ParameterInfo;
 					if (!p.IsEmpty) {
 						p.ResolveDefaultValues (m);
 					}
 				}
 			}
 
 			if (indexers != null) {
 				foreach (Indexer i in indexers) {
 					i.ParameterInfo.ResolveDefaultValues (i);
 				}
 				foreach (Indexer i in indexers) {
 					i.ParameterInfo.ResolveDefaultValues (i);
 				}
 			}
 
 			if (types != null) {
 				foreach (var t in types)
 					t.DefineConstants ();
 				foreach (var t in types)
 					t.DefineConstants ();
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1843" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5446" endline="5503">
<![CDATA[
 
     ''' <summary>
     ''' UsingStatement  
     '''	"Using" UsingResources  StatementTerminator
     '''		[  Block  ]
     '''	"End" "Using" StatementTerminator
     ''' 
     ''' UsingResources  
     ''' 
     ''' LAMESPEC!?
     ''' I'm using this
     ''' UsingResources 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseUsingStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As UsingStatement
         Dim result As New UsingStatement(Parent)
 
         Dim m_UsingResources As ParsedObject
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Using)
 
         Dim newDecls As UsingDeclarators = Nothing
         If tm.CurrentToken.IsIdentifier AndAlso tm.PeekToken.Equals(KS.Equals, KS.As) Then
             'This is a variable declaration
             newDecls = New UsingDeclarators(result)
             If ParseList(Of UsingDeclarator)(newDecls, New ParseDelegate_Parent(Of UsingDeclarator)(AddressOf ParseUsingDeclarator), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_UsingResources = newDecls
         Else
             'This is an expression
             Dim exp As Expression = Nothing
             exp = ParseExpression(result)
             If exp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_UsingResources = exp
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If newDecls IsNot Nothing Then
             For Each decl As UsingDeclarator In newDecls
                 If decl.IsVariableDeclaration Then
                     m_Code.Variables.Add(decl.VariableDeclaration)
                 End If
                 decl.Parent = m_Code
             Next
         End If
 
         If tm.Accept(KS.End, KS.Using) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_UsingResources, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5060" endline="5109">
<![CDATA[
 
     ''' <summary>
     ''' OnErrorStatement  
     ''' ErrorClause  
     '''	   "GoTo"  "-"  "1" |
     '''	   "GoTo"  "0"  |
     '''	   GotoStatement  |
     '''	   "Resume" "Next"
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOnErrorStatement(ByVal Parent As ParsedObject) As OnErrorStatement
         Dim m_IsResumeNext As Boolean
         Dim m_Label As Token = Nothing
         Dim m_IsGotoMinusOne As Boolean
         Dim m_IsGotoZero As Boolean
 
         tm.AcceptIfNotInternalError(KS.On)
         If tm.Accept(KS.Error) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.Accept(KS.Resume) Then
             If tm.Accept(KS.Next) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_IsResumeNext = True
         Else
             If tm.Accept(KS.GoTo) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.CurrentToken.IsIntegerLiteral Then
                 If tm.CurrentToken.IntegralLiteral = 0 Then
                     m_IsGotoZero = True
                 Else
                     m_Label = tm.CurrentToken
                 End If
                 tm.NextToken()
             ElseIf tm.CurrentToken = KS.Minus AndAlso tm.PeekToken.IsIntegerLiteral Then
                 If tm.PeekToken.IntegralLiteral = 1 Then
                     m_IsGotoMinusOne = True
                     tm.NextToken(2)
                 Else
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     Compiler.Report.ShowMessage(Messages.VBNC90011, tm.CurrentLocation, "-1")
                 End If
             ElseIf tm.CurrentToken.IsIdentifier Then
                 m_Label = tm.CurrentToken
                 tm.NextToken()
             Else
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
                 Return Nothing
             End If
         End If
 
         Return New OnErrorStatement(Parent, m_IsResumeNext, m_Label, m_IsGotoMinusOne, m_IsGotoZero)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1844" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="5446" endline="5503">
<![CDATA[
 
     ''' <summary>
     ''' UsingStatement  
     '''	"Using" UsingResources  StatementTerminator
     '''		[  Block  ]
     '''	"End" "Using" StatementTerminator
     ''' 
     ''' UsingResources  
     ''' 
     ''' LAMESPEC!?
     ''' I'm using this
     ''' UsingResources 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseUsingStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As UsingStatement
         Dim result As New UsingStatement(Parent)
 
         Dim m_UsingResources As ParsedObject
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Using)
 
         Dim newDecls As UsingDeclarators = Nothing
         If tm.CurrentToken.IsIdentifier AndAlso tm.PeekToken.Equals(KS.Equals, KS.As) Then
             'This is a variable declaration
             newDecls = New UsingDeclarators(result)
             If ParseList(Of UsingDeclarator)(newDecls, New ParseDelegate_Parent(Of UsingDeclarator)(AddressOf ParseUsingDeclarator), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_UsingResources = newDecls
         Else
             'This is an expression
             Dim exp As Expression = Nothing
             exp = ParseExpression(result)
             If exp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_UsingResources = exp
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If newDecls IsNot Nothing Then
             For Each decl As UsingDeclarator In newDecls
                 If decl.IsVariableDeclaration Then
                     m_Code.Variables.Add(decl.VariableDeclaration)
                 End If
                 decl.Parent = m_Code
             Next
         End If
 
         If tm.Accept(KS.End, KS.Using) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_UsingResources, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" startline="4878" endline="4944">
<![CDATA[
 
     ''' <summary>
     ''' VariableDeclarator  
     '''  	VariableIdentifiers  [  As  [  New  ]  TypeName  [  (  ArgumentList  )  ]  ]  |
     '''     VariableIdentifier   [  As  TypeName  ]  [  =  VariableInitializer  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo, ByVal result As IList, ByVal local As Boolean) As Boolean
         Dim m_VariableIdentifiers As VariableIdentifiers
         Dim m_IsNew As Boolean
         Dim m_TypeName As TypeName
         Dim m_VariableInitializer As VariableInitializer
         Dim m_ArgumentList As ArgumentList
 
         m_VariableIdentifiers = ParseVariableIdentifiers(Parent)
         If m_VariableIdentifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_IsNew = tm.Accept(KS.[New])
             If m_IsNew Then
                 'Arrays not allowed.
                 Dim m_NonArrayTypeName As NonArrayTypeName
                 m_NonArrayTypeName = ParseNonArrayTypeName(Parent)
                 If m_NonArrayTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_TypeName = New TypeName(Parent, m_NonArrayTypeName)
             Else
                 'Arrays allowed.
                 m_TypeName = ParseTypeName(Parent)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         Else
             m_TypeName = Nothing
         End If
 
         If tm.Accept(KS.Equals) Then
             m_VariableInitializer = ParseVariableInitializer(Parent)
             If m_VariableInitializer Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30201, tm.CurrentLocation)
             m_ArgumentList = Nothing
         ElseIf tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_ArgumentList = ParseArgumentList(Parent)
                 If m_ArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_ArgumentList = New ArgumentList(Parent)
             End If
             m_VariableInitializer = Nothing
         Else
             m_VariableInitializer = Nothing
             m_ArgumentList = Nothing
         End If
 
         'result Dim result As New Generic.List(Of VariableDeclaration)
         For Each identifier As VariableIdentifier In m_VariableIdentifiers
             Dim varD As VariableDeclaration
             If local Then
                 varD = New LocalVariableDeclaration(Parent, Modifiers, identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
             Else
                 varD = New TypeVariableDeclaration(Parent, Modifiers, identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
             End If
             varD.Location = identifier.Location
             varD.CustomAttributes = Info.Attributes
             result.Add(varD)
         Next
 
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1845" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2659" endline="2716">
<![CDATA[
 
 		public override void AddLocalName (string name, INamedBlockVariable li)
 		{
 			if (names == null)
 				names = new Dictionary<string, object> ();
 
 			object value;
 			if (!names.TryGetValue (name, out value)) {
 				names.Add (name, li);
 				return;
 			}
 
 			INamedBlockVariable existing = value as INamedBlockVariable;
 			List<INamedBlockVariable> existing_list;
 			if (existing != null) {
 				existing_list = new List<INamedBlockVariable> ();
 				existing_list.Add (existing);
 				names[name] = existing_list;
 			} else {
 				existing_list = (List<INamedBlockVariable>) value;
 			}
 
 			//
 			// A collision checking between local names
 			//
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (li.Block == b) {
 					li.Block.Error_AlreadyDeclared (name, li);
 					break;
 				}
 
 				// Collision with parent
 				b = li.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "parent or current");
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "parent or current");
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (li.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "child");
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (li.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "child");
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (li.Block == b) {
 					li.Block.Error_AlreadyDeclared (name, li);
 					break;
 				}
 
 				// Collision with parent
 				b = li.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "parent or current");
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (li.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "child");
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 
 			existing_list.Add (li);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2717" endline="2777">
<![CDATA[
 
 		public void AddLabel (string name, LabeledStatement label)
 		{
 			if (labels == null)
 				labels = new Dictionary<string, object> ();
 
 			object value;
 			if (!labels.TryGetValue (name, out value)) {
 				labels.Add (name, label);
 				return;
 			}
 
 			LabeledStatement existing = value as LabeledStatement;
 			List<LabeledStatement> existing_list;
 			if (existing != null) {
 				existing_list = new List<LabeledStatement> ();
 				existing_list.Add (existing);
 				labels[name] = existing_list;
 			} else {
 				existing_list = (List<LabeledStatement>) value;
 			}
 
 			//
 			// A collision checking between labels
 			//
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (label.Block == b) {
 					Report.SymbolRelatedToPreviousError (existing.loc, name);
 					Report.Error (140, label.loc, "The label `{0}' is a duplicate", name);
 					break;
 				}
 
 				// Collision with parent
 				b = label.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (label.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (label.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (label.Block == b) {
 					Report.SymbolRelatedToPreviousError (existing.loc, name);
 					Report.Error (140, label.loc, "The label `{0}' is a duplicate", name);
 					break;
 				}
 
 				// Collision with parent
 				b = label.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (label.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 
 			existing_list.Add (label);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1846" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="173" endline="211">
<![CDATA[
 
     Shared Function BuiltInTypeToTypeCode(ByVal Type As BuiltInDataTypes) As TypeCode
         Select Case Type
             Case BuiltInDataTypes.Boolean
                 Return TypeCode.Boolean
             Case BuiltInDataTypes.Byte
                 Return TypeCode.Byte
             Case BuiltInDataTypes.Char
                 Return TypeCode.Char
             Case BuiltInDataTypes.Date
                 Return TypeCode.DateTime
             Case BuiltInDataTypes.Decimal
                 Return TypeCode.Decimal
             Case BuiltInDataTypes.Double
                 Return TypeCode.Double
             Case BuiltInDataTypes.Integer
                 Return TypeCode.Int32
             Case BuiltInDataTypes.Long
                 Return TypeCode.Int64
             Case BuiltInDataTypes.Object
                 Return TypeCode.Object
             Case BuiltInDataTypes.SByte
                 Return TypeCode.SByte
             Case BuiltInDataTypes.Short
                 Return TypeCode.Int16
             Case BuiltInDataTypes.Single
                 Return TypeCode.Single
             Case BuiltInDataTypes.String
                 Return TypeCode.String
             Case BuiltInDataTypes.UInteger
                 Return TypeCode.UInt32
             Case BuiltInDataTypes.ULong
                 Return TypeCode.UInt64
             Case BuiltInDataTypes.UShort
                 Return TypeCode.UInt16
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" startline="298" endline="336">
<![CDATA[
 
     Shared Function KeywordToTypeCode(ByVal Keyword As KS) As TypeCode
         Select Case Keyword
             Case KS.Boolean
                 Return TypeCode.Boolean
             Case KS.Byte
                 Return TypeCode.Byte
             Case KS.Char
                 Return TypeCode.Char
             Case KS.Date
                 Return TypeCode.DateTime
             Case KS.Decimal
                 Return TypeCode.Decimal
             Case KS.Double
                 Return TypeCode.Double
             Case KS.Integer
                 Return TypeCode.Int32
             Case KS.Long
                 Return TypeCode.Int64
             Case KS.Object
                 Return TypeCode.Object
             Case KS.Single
                 Return TypeCode.Single
             Case KS.Short
                 Return TypeCode.Int16
             Case KS.String
                 Return TypeCode.String
             Case KS.SByte
                 Return TypeCode.SByte
             Case KS.UShort
                 Return TypeCode.UInt16
             Case KS.UInteger
                 Return TypeCode.UInt32
             Case KS.ULong
                 Return TypeCode.UInt64
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1847" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="477" endline="533">
<![CDATA[
 
 		static public DSA FromCapiPublicKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			try {
 				if ((blob [offset] != 0x06) ||				// PUBLICKEYBLOB (0x06)
 				    (blob [offset + 1] != 0x02) ||			// Version (0x02)
 				    (blob [offset + 2] != 0x00) ||			// Reserved (word)
 				    (blob [offset + 3] != 0x00) ||
 				    (ToUInt32LE (blob, offset + 8) != 0x31535344))	// DWORD magic
 					throw new CryptographicException ("Invalid blob header");
 
 				int bitlen = ToInt32LE (blob, offset + 12);
 				DSAParameters dsap = new DSAParameters ();
 				int bytelen = bitlen >> 3;
 				int pos = offset + 16;
 
 				dsap.P = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
 				Array.Reverse (dsap.P);
 				pos += bytelen;
 
 				dsap.Q = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
 				Array.Reverse (dsap.Q);
 				pos += 20;
 
 				dsap.G = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
 				Array.Reverse (dsap.G);
 				pos += bytelen;
 
 				dsap.Y = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.Y, 0, bytelen);
 				Array.Reverse (dsap.Y);
 				pos += bytelen;
 
 				dsap.Counter = ToInt32LE (blob, pos);
 				pos += 4;
 
 				dsap.Seed = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
 				Array.Reverse (dsap.Seed);
 				pos += 20;
 
 				DSA dsa = (DSA)DSA.Create ();
 				dsa.ImportParameters (dsap);
 				return dsa;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="201" endline="280">
<![CDATA[
 
 		static public DSA FromCapiPrivateKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			DSAParameters dsap = new DSAParameters ();
 			try {
 				if ((blob [offset] != 0x07) ||				// PRIVATEKEYBLOB (0x07)
 				    (blob [offset + 1] != 0x02) ||			// Version (0x02)
 				    (blob [offset + 2] != 0x00) ||			// Reserved (word)
 				    (blob [offset + 3] != 0x00) ||
 				    (ToUInt32LE (blob, offset + 8) != 0x32535344))	// DWORD magic
 					throw new CryptographicException ("Invalid blob header");
 
 				int bitlen = ToInt32LE (blob, offset + 12);
 				int bytelen = bitlen >> 3;
 				int pos = offset + 16;
 
 				dsap.P = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
 				Array.Reverse (dsap.P);
 				pos += bytelen;
 
 				dsap.Q = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
 				Array.Reverse (dsap.Q);
 				pos += 20;
 
 				dsap.G = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
 				Array.Reverse (dsap.G);
 				pos += bytelen;
 
 				dsap.X = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.X, 0, 20);
 				Array.Reverse (dsap.X);
 				pos += 20;
 
 				dsap.Counter = ToInt32LE (blob, pos);
 				pos += 4;
 
 				dsap.Seed = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
 				Array.Reverse (dsap.Seed);
 				pos += 20;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 
 #if NET_2_1
 			DSA dsa = (DSA)DSA.Create ();
 			dsa.ImportParameters (dsap);
 #else
 			DSA dsa = null;
 			try {
 				dsa = (DSA)DSA.Create ();
 				dsa.ImportParameters (dsap);
 			}
 			catch (CryptographicException ce) {
 				// this may cause problem when this code is run under
 				// the SYSTEM identity on Windows (e.g. ASP.NET). See
 				// http
 				try {
 					CspParameters csp = new CspParameters ();
 					csp.Flags = CspProviderFlags.UseMachineKeyStore;
 					dsa = new DSACryptoServiceProvider (csp);
 					dsa.ImportParameters (dsap);
 				}
 				catch {
 					// rethrow original, not the later, exception if this fails
 					throw ce;
 				}
 			}
 #endif
 			return dsa;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1848" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="619" endline="695">
<![CDATA[
 		
 		//
 		// Parses the string @input and returns a CSharpParser if succeeful.
 		//
 		// if @silent is set to true then no errors are
 		// reported to the user.  This is used to do various calls to the
 		// parser and check if the expression is parsable.
 		//
 		// @partial_input
 		// parsed expression was partial, and more data is needed
 		//
 		static CSharpParser ParseString (ParseMode mode, string input, out bool partial_input)
 		{
 			partial_input = false;
 			Reset ();
 			queued_fields.Clear ();
 			Tokenizer.LocatedToken.Initialize ();
 
 			Stream s = new MemoryStream (Encoding.Default.GetBytes (input));
 			SeekableStreamReader seekable = new SeekableStreamReader (s, Encoding.Default);
 
 			InputKind kind = ToplevelOrStatement (seekable);
 			if (kind == InputKind.Error){
 				if (mode == ParseMode.ReportErrors)
 					ctx.Report.Error (-25, "Detection Parsing Error");
 				partial_input = false;
 				return null;
 			}
 
 			if (kind == InputKind.EOF){
 				if (mode == ParseMode.ReportErrors)
 					Console.Error.WriteLine ("Internal error
 				partial_input = true;
 				return null;
 				
 			}
 			seekable.Position = 0;
 
 			CSharpParser parser = new CSharpParser (seekable, Location.SourceFiles [0], RootContext.ToplevelTypes);
 
 			if (kind == InputKind.StatementOrExpression){
 				parser.Lexer.putback_char = Tokenizer.EvalStatementParserCharacter;
 				RootContext.StatementMode = true;
 			} else {
 				//
 				// Do not activate EvalCompilationUnitParserCharacter until
 				// I have figured out all the limitations to invoke methods
 				// in the generated classes.  See repl.txt
 				//
 				parser.Lexer.putback_char = Tokenizer.EvalUsingDeclarationsParserCharacter;
 				//parser.Lexer.putback_char = Tokenizer.EvalCompilationUnitParserCharacter;
 				RootContext.StatementMode = false;
 			}
 
 			if (mode == ParseMode.GetCompletions)
 				parser.Lexer.CompleteOnEOF = true;
 
 			ReportPrinter old_printer = null;
 			if ((mode == ParseMode.Silent || mode == ParseMode.GetCompletions) && CSharpParser.yacc_verbose_flag == 0)
 				old_printer = SetPrinter (new StreamReportPrinter (TextWriter.Null));
 
 			try {
 				parser.parse ();
 			} finally {
 				if (ctx.Report.Errors != 0){
 					if (mode != ParseMode.ReportErrors  && parser.UnexpectedEOF)
 						partial_input = true;
 
 					parser.undo.ExecuteUndo ();
 					parser = null;
 				}
 
 				if (old_printer != null)
 					SetPrinter (old_printer);
 			}
 			return parser;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2653" endline="2756">
<![CDATA[
 
 		int consume_identifier (int c, bool quoted) 
 		{
 			//
 			// This method is very performance sensitive. It accounts
 			// for approximately 25% of all parser time
 			//
 
 			int pos = 0;
 			int column = col;
 
 			if (c == '\\') {
 				int surrogate;
 				c = escape (c, out surrogate);
 				if (surrogate != 0) {
 					id_builder [pos++] = (char) c;
 					c = surrogate;
 				}
 			}
 
 			id_builder [pos++] = (char) c;
 
 			try {
 				while (true) {
 					c = reader.Read ();
 
 					if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9')) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					if (c < 0x80) {
 						if (c == '\\') {
 							int surrogate;
 							c = escape (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									id_builder[pos++] = (char) c;
 								c = surrogate;
 							}
 
 							continue;
 						}
 					} else if (Char.IsLetter ((char) c) || Char.GetUnicodeCategory ((char) c) == UnicodeCategory.ConnectorPunctuation) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					putback_char = c;
 					break;
 				while (true) {
 					c = reader.Read ();
 
 					if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9')) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					if (c < 0x80) {
 						if (c == '\\') {
 							int surrogate;
 							c = escape (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									id_builder[pos++] = (char) c;
 								c = surrogate;
 							}
 
 							continue;
 						}
 					} else if (Char.IsLetter ((char) c) || Char.GetUnicodeCategory ((char) c) == UnicodeCategory.ConnectorPunctuation) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					putback_char = c;
 					break;
 				}
 			} catch (IndexOutOfRangeException) {
 				Report.Error (645, Location, "Identifier too long (limit is 512 chars)");
 				--pos;
 				col += pos;
 			}
 
 			col += pos - 1;
 
 			//
 			// Optimization
 			// on uppercase letters
 			//
 			if (id_builder [0] >= '_' && !quoted) {
 				int keyword = GetKeyword (id_builder, pos);
 				if (keyword != -1) {
 					val = LocatedToken.Create (null, ref_line, column);
 					return keyword;
 				}
 			}
 
 			//
 			// Keep identifiers in an array of hashtables to avoid needless
 			// allocations
 			//
 			var identifiers_group = identifiers [pos];
 			string s;
 			if (identifiers_group != null) {
 				if (identifiers_group.TryGetValue (id_builder, out s)) {
 					val = LocatedToken.Create (s, ref_line, column);
 					if (quoted)
 						AddEscapedIdentifier (((LocatedToken) val).Location);
 					return Token.IDENTIFIER;
 				}
 			} else {
 				// TODO
 				// corlib compilation peaks at 1000 and System.Core at 150
 				int capacity = pos > 20 ? 10 
 				identifiers_group = new Dictionary<char[],string> (capacity, new IdentifiersComparer (pos));
 				identifiers [pos] = identifiers_group;
 			}
 
 			char [] chars = new char [pos];
 			Array.Copy (id_builder, chars, pos);
 
 			s = new string (id_builder, 0, pos);
 			identifiers_group.Add (chars, s);
 
 			val = LocatedToken.Create (s, ref_line, column);
 			if (quoted)
 				AddEscapedIdentifier (((LocatedToken) val).Location);
 
 			return Token.IDENTIFIER;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1849" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="416" endline="475">
<![CDATA[
 
 		public void Emit ()
 		{
 			if (RootContext.Target == Target.Module) {
 				module_target_attrs = new AssemblyAttributesPlaceholder (module, name);
 				module_target_attrs.CreateType ();
 				module_target_attrs.DefineType ();
 				module_target_attrs.Define ();
 				module.AddCompilerGeneratedClass (module_target_attrs);
 			} else if (added_modules != null) {
 				ReadModulesAssemblyAttributes ();
 			}
 
 			if (RootContext.GenerateDebugInfo) {
 				symbol_writer = new MonoSymbolWriter (file_name);
 
 				// TODO
 				Location.DefineSymbolDocuments (symbol_writer);
 				SymbolWriter.symwriter = symbol_writer;
 			}
 
 			module.Emit ();
 
 			if (module.HasExtensionMethod) {
 				var pa = module.PredefinedAttributes.Extension;
 				if (pa.IsDefined) {
 					SetCustomAttribute (pa.Constructor, AttributeEncoder.Empty);
 				}
 			}
 
 			if (!wrap_non_exception_throws_custom) {
 				PredefinedAttribute pa = module.PredefinedAttributes.RuntimeCompatibility;
 				if (pa.IsDefined && pa.ResolveBuilder ()) {
 					var prop = pa.GetProperty ("WrapNonExceptionThrows", TypeManager.bool_type, Location.Null);
 					if (prop != null) {
 						AttributeEncoder encoder = new AttributeEncoder ();
 						encoder.EncodeNamedPropertyArgument (prop, new BoolLiteral (true, Location.Null));
 						SetCustomAttribute (pa.Constructor, encoder.ToArray ());
 					}
 				}
 			}
 
 			if (declarative_security != null) {
 #if STATIC
 				foreach (var entry in declarative_security) {
 					Builder.__AddDeclarativeSecurity (entry);
 				}
 				foreach (var entry in declarative_security) {
 					Builder.__AddDeclarativeSecurity (entry);
 				}
 #else
 				var args = new PermissionSet[3];
 				declarative_security.TryGetValue (SecurityAction.RequestMinimum, out args[0]);
 				declarative_security.TryGetValue (SecurityAction.RequestOptional, out args[1]);
 				declarative_security.TryGetValue (SecurityAction.RequestRefuse, out args[2]);
 				builder_extra.AddPermissionRequests (args);
 #endif
 			}
 
 			CheckReferencesPublicToken ();
 
 			SetEntryPoint ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1398" endline="1457">
<![CDATA[
 
 		public virtual void SetParameterInfo (List<Constraints> constraints_list)
 		{
 			if (!is_generic) {
 				if (constraints_list != null) {
 					Report.Error (
 						80, Location, "Constraints are not allowed " +
 						"on non-generic declarations");
 				}
 
 				return;
 			}
 
 			TypeParameterName[] names = MemberName.TypeArguments.GetDeclarations ();
 			type_params = new TypeParameter [names.Length];
 
 			//
 			// Register all the names
 			//
 			for (int i = 0; i < type_params.Length; i++) {
 				TypeParameterName name = names [i];
 
 				Constraints constraints = null;
 				if (constraints_list != null) {
 					int total = constraints_list.Count;
 					for (int ii = 0; ii < total; ++ii) {
 						Constraints constraints_at = (Constraints)constraints_list[ii];
 						// TODO
 						if (constraints_at == null) {
 							constraints_list.RemoveAt (ii);
 							--total;
 							continue;
 						}
 						if (constraints_at.TypeParameter.Value == name.Name) {
 							constraints = constraints_at;
 							constraints_list.RemoveAt(ii);
 							break;
 						}
 					}
 					for (int ii = 0; ii < total; ++ii) {
 						Constraints constraints_at = (Constraints)constraints_list[ii];
 						// TODO
 						if (constraints_at == null) {
 							constraints_list.RemoveAt (ii);
 							--total;
 							continue;
 						}
 						if (constraints_at.TypeParameter.Value == name.Name) {
 							constraints = constraints_at;
 							constraints_list.RemoveAt(ii);
 							break;
 						}
 					}
 				}
 
 				Variance variance = name.Variance;
 				if (name.Variance != Variance.None && !(this is Delegate || this is Interface)) {
 					Report.Error (1960, name.Location, "Variant type parameters can only be used with interfaces and delegates");
 					variance = Variance.None;
 				}
 
 				type_params [i] = new TypeParameter (
 					Parent, i, new MemberName (name.Name, Location), constraints, name.OptAttributes, variance);
 
 				AddToContainer (type_params [i], name.Name);
 			}
 			for (int i = 0; i < type_params.Length; i++) {
 				TypeParameterName name = names [i];
 
 				Constraints constraints = null;
 				if (constraints_list != null) {
 					int total = constraints_list.Count;
 					for (int ii = 0; ii < total; ++ii) {
 						Constraints constraints_at = (Constraints)constraints_list[ii];
 						// TODO
 						if (constraints_at == null) {
 							constraints_list.RemoveAt (ii);
 							--total;
 							continue;
 						}
 						if (constraints_at.TypeParameter.Value == name.Name) {
 							constraints = constraints_at;
 							constraints_list.RemoveAt(ii);
 							break;
 						}
 					}
 				}
 
 				Variance variance = name.Variance;
 				if (name.Variance != Variance.None && !(this is Delegate || this is Interface)) {
 					Report.Error (1960, name.Location, "Variant type parameters can only be used with interfaces and delegates");
 					variance = Variance.None;
 				}
 
 				type_params [i] = new TypeParameter (
 					Parent, i, new MemberName (name.Name, Location), constraints, name.OptAttributes, variance);
 
 				AddToContainer (type_params [i], name.Name);
 			}
 
 			if (constraints_list != null && constraints_list.Count > 0) {
 				foreach (Constraints constraint in constraints_list) {
 					Report.Error(699, constraint.Location, "`{0}'
 						GetSignatureForError (), constraint.TypeParameter.Value);
 				}
 				foreach (Constraints constraint in constraints_list) {
 					Report.Error(699, constraint.Location, "`{0}'
 						GetSignatureForError (), constraint.TypeParameter.Value);
 				}
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1850" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="450" endline="483">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short) Value, Location);
 			if (target_type == TypeManager.ushort_type)
 				return new UShortConstant ((ushort) Value, Location);
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type)
 				return new CharConstant ((char) Value, Location);
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1082" endline="1125">
<![CDATA[
 
 		/// <summary>
 		///   Attempts to perform an implicit constant conversion of the IntConstant
 		///   into a different data type using casts (See Implicit Constant
 		///   Expression Conversions)
 		/// </summary>
 		Constant TryImplicitIntConversion (TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type) {
 				if (Value >= SByte.MinValue && Value <= SByte.MaxValue)
 					return new SByteConstant ((sbyte) Value, loc);
 			} 
 			else if (target_type == TypeManager.byte_type) {
 				if (Value >= Byte.MinValue && Value <= Byte.MaxValue)
 					return new ByteConstant ((byte) Value, loc);
 			} 
 			else if (target_type == TypeManager.short_type) {
 				if (Value >= Int16.MinValue && Value <= Int16.MaxValue)
 					return new ShortConstant ((short) Value, loc);
 			} 
 			else if (target_type == TypeManager.ushort_type) {
 				if (Value >= UInt16.MinValue && Value <= UInt16.MaxValue)
 					return new UShortConstant ((ushort) Value, loc);
 			} 
 			else if (target_type == TypeManager.uint32_type) {
 				if (Value >= 0)
 					return new UIntConstant ((uint) Value, loc);
 			} 
 			else if (target_type == TypeManager.uint64_type) {
 				//
 				// we can optimize this case
 				// always fits on a uint64.  But we need an opcode
 				// to do it.
 				//
 				if (Value >= 0)
 					return new ULongConstant ((ulong) Value, loc);
 			} 
 			else if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, loc);
 			else if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, loc);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1851" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="450" endline="483">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short) Value, Location);
 			if (target_type == TypeManager.ushort_type)
 				return new UShortConstant ((ushort) Value, Location);
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type)
 				return new CharConstant ((char) Value, Location);
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="566" endline="607">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}					
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1852" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1171" endline="1221">
<![CDATA[
 
     ''' <summary>
     ''' Loads an value of the desired type onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Integer) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         Dim tmp As EmitInfo = Info
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
 
         Select Case DesiredTypeCode
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Boolean
                 EmitLoadI4Value(Info, Value, Info.DesiredType)
                 Return True
             Case TypeCode.Int64
                 EmitLoadI8Value(Info, Value, Info.DesiredType)
                 Return True
             Case TypeCode.Byte, TypeCode.UInt16
                 EmitLoadI4Value(Info, CUInt(Value), Info.DesiredType)
                 Return True
             Case TypeCode.UInt32
                 If Value <= UInteger.MaxValue AndAlso Value >= UInteger.MinValue Then
                     EmitLoadI4Value(Info, CUInt(Value), Info.DesiredType)
                     Return True
                 End If
             Case TypeCode.UInt64
                 If Value <= ULong.MaxValue AndAlso Value >= ULong.MinValue Then
                     EmitLoadValue(tmp, CULng(Value))
                     Return True
                 End If
             Case TypeCode.Single
                 EmitLoadR4Value(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadR8Value(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadDecimalValue(tmp, CDec(Value))
                 Return True
             Case TypeCode.Object
                 EmitLoadI4Value(tmp, Value)
                 'EmitBox(Info, Info.Compiler.TypeCache.System_Int32)
                 Return True
         End Select
         Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="74" endline="120">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Double
                 'Nothing to do
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToDouble_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1853" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" startline="1171" endline="1221">
<![CDATA[
 
     ''' <summary>
     ''' Loads an value of the desired type onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Integer) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         Dim tmp As EmitInfo = Info
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
 
         Select Case DesiredTypeCode
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Boolean
                 EmitLoadI4Value(Info, Value, Info.DesiredType)
                 Return True
             Case TypeCode.Int64
                 EmitLoadI8Value(Info, Value, Info.DesiredType)
                 Return True
             Case TypeCode.Byte, TypeCode.UInt16
                 EmitLoadI4Value(Info, CUInt(Value), Info.DesiredType)
                 Return True
             Case TypeCode.UInt32
                 If Value <= UInteger.MaxValue AndAlso Value >= UInteger.MinValue Then
                     EmitLoadI4Value(Info, CUInt(Value), Info.DesiredType)
                     Return True
                 End If
             Case TypeCode.UInt64
                 If Value <= ULong.MaxValue AndAlso Value >= ULong.MinValue Then
                     EmitLoadValue(tmp, CULng(Value))
                     Return True
                 End If
             Case TypeCode.Single
                 EmitLoadR4Value(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadR8Value(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadDecimalValue(tmp, CDec(Value))
                 Return True
             Case TypeCode.Object
                 EmitLoadI4Value(tmp, Value)
                 'EmitBox(Info, Info.Compiler.TypeCache.System_Int32)
                 Return True
         End Select
         Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="74" endline="125">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I8(Info, expType)
             Case TypeCode.Int64
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I8_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I8_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I8_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I8_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt64_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1854" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="71" endline="114">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Single
                 'Nothing to do
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToSingle_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="71" endline="123">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Boolean)
             Case TypeCode.Decimal
                 'Nothing to do
             Case TypeCode.DateTime, TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16
                 Emitter.EmitConv_I4_Overflow(Info, expType)
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int32)
             Case TypeCode.Int32
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int32)
             Case TypeCode.Int64
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int64)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_U8_Overflow_Underflow(Info, expType)
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_UInt64)
             Case TypeCode.Double
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Double)
             Case TypeCode.Single
                 If Expression.IsConstant Then
                     'VBC BUG? This seems to be a bug in vbc.exe.
                     Emitter.EmitLoadDecimalValue(Info, New Decimal(CDbl(Expression.ConstantValue)))
                 Else
                     'CORRECT CODE.
                     Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Single)
                 End If
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1855" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="71" endline="114">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Single
                 'Nothing to do
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToSingle_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="34" endline="88">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 'Nothing to do
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.SByte, TypeCode.Int16, TypeCode.Int32
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.Int64
                 Emitter.EmitLoadI8Value(Info, 0L, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.UInt64
                 Emitter.EmitLoadI8Value(Info, 0UL, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitLoadR8Value(Info, 0.0, expType)
                 Emitter.EmitEquals(Info, expType)
                 Emitter.EmitLoadI4Value(Info, 0I, Info.Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Info.Compiler.TypeCache.System_Boolean)
             Case TypeCode.Single
                 Emitter.EmitLoadR4Value(Info, 0.0!, expType)
                 Emitter.EmitEquals(Info, expType)
                 Emitter.EmitLoadI4Value(Info, 0I, Info.Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Info.Compiler.TypeCache.System_Boolean)
             Case TypeCode.Object
                 Helper.Assert(Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object IsNot Nothing, "MS_VB_CS_Conversions_ToBoolean__Object Is Nothing")
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Helper.Assert(Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_String IsNot Nothing, "MS_VB_CS_Conversions_ToBoolean__String Is Nothing")
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_String)
             Case TypeCode.Decimal
                 Helper.Assert(Info.Compiler.TypeCache.System_Convert__ToBoolean_Decimal IsNot Nothing, "System_Convert_ToBoolean__Decimal Is Nothing")
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToBoolean_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1856" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" startline="84" endline="135">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim shifts As Integer 'This needs to be an integer.
                 Dim tmpShifts As Object = Nothing
                 If Compiler.TypeResolution.CheckNumericRange(rvalue, tmpShifts, Compiler.TypeCache.System_Int32) = False Then
                     Helper.Stop() 'Add error.
                 Else
                     shifts = CInt(tmpShifts)
                 End If
 
                 Dim tlvalue As Mono.Cecil.TypeReference
                 Dim clvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
 
                 Select Case clvalue
                     Case TypeCode.Byte
                         Return CByte(lvalue) >> shifts
                     Case TypeCode.SByte
                         Return CSByte(lvalue) >> shifts
                     Case TypeCode.Int16
                         Return CShort(lvalue) >> shifts
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) >> shifts
                     Case TypeCode.Int32
                         Return CInt(lvalue) >> shifts
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) >> shifts
                     Case TypeCode.Int64
                         Return CLng(lvalue) >> shifts
                     Case TypeCode.UInt64
                         Return CULng(lvalue) >> shifts
                     Case TypeCode.Double
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" startline="83" endline="134">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim shifts As Integer 'This needs to be an integer.
                 Dim tmpShifts As Object = Nothing
                 If Compiler.TypeResolution.CheckNumericRange(rvalue, tmpShifts, Compiler.TypeCache.System_Int32) = False Then
                     Helper.Stop() 'Add error.
                 Else
                     shifts = CInt(tmpShifts)
                 End If
 
                 Dim tlvalue As Mono.Cecil.TypeReference
                 Dim clvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
 
                 Select Case clvalue
                     Case TypeCode.Byte
                         Return CByte(lvalue) << shifts
                     Case TypeCode.SByte
                         Return CSByte(lvalue) << shifts
                     Case TypeCode.Int16
                         Return CShort(lvalue) << shifts
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) << shifts
                     Case TypeCode.Int32
                         Return CInt(lvalue) << shifts
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) << shifts
                     Case TypeCode.Int64
                         Return CLng(lvalue) << shifts
                     Case TypeCode.UInt64
                         Return CULng(lvalue) << shifts
                     Case TypeCode.Double
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1857" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="687" endline="729">
<![CDATA[
 
 		public void EmitDispose (EmitContext ec)
 		{
 			Label end = ec.DefineLabel ();
 
 			Label [] labels = null;
 			int n_resume_points = resume_points == null ? 0 
 			for (int i = 0; i < n_resume_points; ++i) {
 				ResumableStatement s = (ResumableStatement) resume_points [i];
 				Label ret = s.PrepareForDispose (ec, end);
 				if (ret.Equals (end) && labels == null)
 					continue;
 				if (labels == null) {
 					labels = new Label [resume_points.Count + 1];
 					for (int j = 0; j <= i; ++j)
 						labels [j] = end;
 					for (int j = 0; j <= i; ++j)
 						labels [j] = end;
 				}
 				labels [i+1] = ret;
 			}
 			for (int i = 0; i < n_resume_points; ++i) {
 				ResumableStatement s = (ResumableStatement) resume_points [i];
 				Label ret = s.PrepareForDispose (ec, end);
 				if (ret.Equals (end) && labels == null)
 					continue;
 				if (labels == null) {
 					labels = new Label [resume_points.Count + 1];
 					for (int j = 0; j <= i; ++j)
 						labels [j] = end;
 				}
 				labels [i+1] = ret;
 			}
 
 			if (labels != null) {
 				current_pc = ec.GetTemporaryLocal (TypeManager.uint32_type);
 				ec.Emit (OpCodes.Ldarg_0);
 				ec.Emit (OpCodes.Ldfld, IteratorHost.PC.Spec);
 				ec.Emit (OpCodes.Stloc, current_pc);
 			}
 
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.EmitInt ((int) State.After);
 			ec.Emit (OpCodes.Stfld, IteratorHost.PC.Spec);
 
 			if (labels != null) {
 				//SymbolWriter.StartIteratorDispatcher (ec.ig);
 				ec.Emit (OpCodes.Ldloc, current_pc);
 				ec.Emit (OpCodes.Switch, labels);
 				//SymbolWriter.EndIteratorDispatcher (ec.ig);
 
 				foreach (ResumableStatement s in resume_points)
 					s.EmitForDispose (ec, this, end, true);
 				foreach (ResumableStatement s in resume_points)
 					s.EmitForDispose (ec, this, end, true);
 			}
 
 			ec.MarkLabel (end);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4034" endline="4093">
<![CDATA[
 
 		public override void EmitForDispose (EmitContext ec, Iterator iterator, Label end, bool have_dispatcher)
 		{
 			if (emitted_dispose)
 				return;
 
 			emitted_dispose = true;
 
 			Label end_of_try = ec.DefineLabel ();
 
 			// Ensure that the only way we can get into this code is through a dispatcher
 			if (have_dispatcher)
 				ec.Emit (OpCodes.Br, end);
 
 			ec.BeginExceptionBlock ();
 
 			ec.MarkLabel (dispose_try_block);
 
 			Label [] labels = null;
 			for (int i = 0; i < resume_points.Count; ++i) {
 				ResumableStatement s = (ResumableStatement) resume_points [i];
 				Label ret = s.PrepareForDispose (ec, end_of_try);
 				if (ret.Equals (end_of_try) && labels == null)
 					continue;
 				if (labels == null) {
 					labels = new Label [resume_points.Count];
 					for (int j = 0; j < i; ++j)
 						labels [j] = end_of_try;
 					for (int j = 0; j < i; ++j)
 						labels [j] = end_of_try;
 				}
 				labels [i] = ret;
 			}
 			for (int i = 0; i < resume_points.Count; ++i) {
 				ResumableStatement s = (ResumableStatement) resume_points [i];
 				Label ret = s.PrepareForDispose (ec, end_of_try);
 				if (ret.Equals (end_of_try) && labels == null)
 					continue;
 				if (labels == null) {
 					labels = new Label [resume_points.Count];
 					for (int j = 0; j < i; ++j)
 						labels [j] = end_of_try;
 				}
 				labels [i] = ret;
 			}
 
 			if (labels != null) {
 				int j;
 				for (j = 1; j < labels.Length; ++j)
 					if (!labels [0].Equals (labels [j]))
 						break;
 				for (j = 1; j < labels.Length; ++j)
 					if (!labels [0].Equals (labels [j]))
 						break;
 				bool emit_dispatcher = j < labels.Length;
 
 				if (emit_dispatcher) {
 					//SymbolWriter.StartIteratorDispatcher (ec.ig);
 					ec.Emit (OpCodes.Ldloc, iterator.CurrentPC);
 					ec.EmitInt (first_resume_pc);
 					ec.Emit (OpCodes.Sub);
 					ec.Emit (OpCodes.Switch, labels);
 					//SymbolWriter.EndIteratorDispatcher (ec.ig);
 				}
 
 				foreach (ResumableStatement s in resume_points)
 					s.EmitForDispose (ec, iterator, end_of_try, emit_dispatcher);
 				foreach (ResumableStatement s in resume_points)
 					s.EmitForDispose (ec, iterator, end_of_try, emit_dispatcher);
 			}
 
 			ec.MarkLabel (end_of_try);
 
 			ec.BeginFinallyBlock ();
 
 			EmitFinallyBody (ec);
 
 			ec.EndExceptionBlock ();
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1858" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2426" endline="2486">
<![CDATA[
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="220" endline="339">
<![CDATA[
 
 		//
 		// 6.1.6 Implicit reference conversions
 		//
 		public static bool ImplicitReferenceConversionExists (Expression expr, TypeSpec target_type)
 		{
 			if (TypeManager.IsStruct (target_type))
 				return false;
 
 			TypeSpec expr_type = expr.Type;
 
 			// from the null type to any reference-type.
 			if (expr_type == InternalType.Null)
 				return target_type != InternalType.AnonymousMethod;
 
 			if (TypeManager.IsGenericParameter (expr_type))
 				return ImplicitTypeParameterConversion (expr, target_type) != null;
 
 			// This code is kind of mirrored inside ImplicitStandardConversionExists
 			// with the small distinction that we only probe there
 			//
 			// Always ensure that the code here and there is in sync
 
 			// from any class-type S to any interface-type T.
 			if (target_type.IsInterface) {
 				if (expr_type.ImplementsInterface (target_type, true)){
 					return !TypeManager.IsValueType (expr_type);
 				}
 			}
 
 			//
 			// Implicit reference conversions (no-boxing) to object or dynamic
 			//
 			if (target_type == TypeManager.object_type || target_type == InternalType.Dynamic) {
 				switch (expr_type.Kind) {
 				case MemberKind.Class
 				case MemberKind.Interface
 				case MemberKind.Delegate
 				case MemberKind.ArrayType
 					return true;
 				}
 
 				return expr_type == InternalType.Dynamic;
 			}
 
 			if (target_type == TypeManager.value_type) {
 				return expr_type == TypeManager.enum_type;
 			} else if (expr_type == target_type || TypeSpec.IsBaseClass (expr_type, target_type, true)) {
 				//
 				// Special case
 				// System.Enum is not a value type, it is a class, so we need
 				// a boxing conversion
 				//
 				if (target_type == TypeManager.enum_type || TypeManager.IsGenericParameter (expr_type))
 					return false;
 
 				if (TypeManager.IsValueType (expr_type))
 					return false;
 
 				// Array type variance conversion
 				//if (target_type.IsArray != expr_type.IsArray)
 				//	return false;
 
 				return true;
 			}
 
 			var expr_type_array = expr_type as ArrayContainer;
 			if (expr_type_array != null) {
 				var target_type_array = target_type as ArrayContainer;
 				// from an array-type S to an array-type of type T
 				if (target_type_array != null && expr_type_array.Rank == target_type_array.Rank) {
 
 					//
 					// Both SE and TE are reference-types
 					//
 					TypeSpec expr_element_type = expr_type_array.Element;
 					if (!TypeManager.IsReferenceType (expr_element_type))
 						return false;
 
 					TypeSpec target_element_type = target_type_array.Element;
 					if (!TypeManager.IsReferenceType (target_element_type))
 						return false;
 
 					if (MyEmptyExpr == null)
 						MyEmptyExpr = new EmptyExpression (expr_element_type);
 					else
 						MyEmptyExpr.SetType (expr_element_type);
 
 					return ImplicitStandardConversionExists (MyEmptyExpr, target_element_type);
 				}
 
 				// from an array-type to System.Array
 				if (target_type == TypeManager.array_type)
 					return true;
 
 				// from an array-type of type T to IList<T>
 				if (ArrayToIList (expr_type_array, target_type, false))
 					return true;
 
 				return false;
 			}
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type))
 				return true;
 
 			if (TypeSpecComparer.Variant.IsEqual (expr_type, target_type))
 				return true;
 
 			// from any interface type S to interface-type T.
 			if (expr_type.IsInterface && target_type.IsInterface) {
 				return expr_type.ImplementsInterface (target_type, true);
 			}
 
 			// from any delegate type to System.Delegate
 			if (target_type == TypeManager.delegate_type &&
 				(expr_type == TypeManager.delegate_type || expr_type.IsDelegate))
 				return true;
 
 			return false;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1859" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2426" endline="2486">
<![CDATA[
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1247" endline="1381">
<![CDATA[
 
 		static Expression ImplicitConversionStandard (ResolveContext ec, Expression expr, TypeSpec target_type, Location loc, bool explicit_cast)
 		{
 			if (expr.eclass == ExprClass.MethodGroup){
 				if (!TypeManager.IsDelegateType (target_type)){
 					return null;
 				}
 
 				//
 				// Only allow anonymous method conversions on post ISO_1
 				//
 				if (RootContext.Version != LanguageVersion.ISO_1){
 					MethodGroupExpr mg = expr as MethodGroupExpr;
 					if (mg != null)
 						return ImplicitDelegateCreation.Create (
 							ec, mg, target_type, loc);
 				}
 			}
 
 			TypeSpec expr_type = expr.Type;
 			Expression e;
 
 			if (expr_type == target_type) {
 				if (expr_type != InternalType.Null && expr_type != InternalType.AnonymousMethod)
 					return expr;
 				return null;
 			}
 
 			if (expr_type == InternalType.Dynamic) {
 				switch (target_type.Kind) {
 				case MemberKind.ArrayType
 				case MemberKind.Class
 					if (target_type == TypeManager.object_type)
 						return EmptyCast.Create (expr, target_type);
 
 					goto case MemberKind.Struct;
 				case MemberKind.Struct
 					// TODO
 					if (target_type == TypeManager.void_type)
 						return null;
 
 					goto case MemberKind.Enum;
 				case MemberKind.Delegate
 				case MemberKind.Enum
 				case MemberKind.Interface
 				case MemberKind.TypeParameter
 					Arguments args = new Arguments (1);
 					args.Add (new Argument (expr));
 					return new DynamicConversion (target_type, explicit_cast ? CSharpBinderFlags.ConvertExplicit 
 				}
 
 				return null;
 			}
 
 			if (TypeManager.IsNullableType (target_type))
 				return ImplicitNulableConversion (ec, expr, target_type);
 
 			//
 			// Attempt to do the implicit constant expression conversions
 			//
 			Constant c = expr as Constant;
 			if (c != null) {
 				try {
 					c = c.ConvertImplicitly (ec, target_type);
 				} catch {
 					Console.WriteLine ("Conversion error happened in line {0}", loc);
 					throw;
 				}
 				if (c != null)
 					return c;
 			}
 
 			e = ImplicitNumericConversion (expr, expr_type, target_type);
 			if (e != null)
 				return e;
 
 			e = ImplicitReferenceConversion (expr, target_type, explicit_cast);
 			if (e != null)
 				return e;
 
 			if (expr is IntegralConstant && TypeManager.IsEnumType (target_type)){
 				var i = (IntegralConstant) expr;
 				//
 				// LAMESPEC
 				//
 				// An implicit enumeration conversion permits the decimal-integer-literal 0
 				// to be converted to any enum-type and to any nullable-type whose underlying
 				// type is an enum-type
 				//
 				if (i.IsZeroInteger) {
 					// Recreate 0 literal to remove any collected conversions
 					return new EnumConstant (new IntLiteral (0, i.Location), target_type).Resolve (ec);
 				}
 			}
 
 			if (ec.IsUnsafe) {
 				var target_pc = target_type as PointerContainer;
 				if (target_pc != null) {
 					if (expr_type.IsPointer) {
 						//
 						// Pointer types are same when they have same element types
 						//
 						if (expr_type == target_pc)
 							return expr;
 
 						if (target_pc.Element.BuildinType == BuildinTypeSpec.Type.Void)
 							return EmptyCast.Create (expr, target_type);
 
 						//return null;
 					}
 
 					if (expr_type == InternalType.Null)
 						return EmptyCast.Create (new NullPointer (loc), target_type);
 				}
 			}
 
 			if (expr_type == InternalType.AnonymousMethod){
 				AnonymousMethodExpression ame = (AnonymousMethodExpression) expr;
 				Expression am = ame.Compatible (ec, target_type);
 				if (am != null)
 					return am.Resolve (ec);
 			}
 
 			if (expr_type == InternalType.Arglist && target_type == TypeManager.arg_iterator_type)
 				return expr;
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type)) {
 				if (expr_type == target_type)
 					return expr;
 
 				return EmptyCast.Create (expr, target_type);
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1860" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2426" endline="2486">
<![CDATA[
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="211" endline="305">
<![CDATA[
 
 		/// <remarks>
 		///   If a method in Type `t' (or null to look in all interfaces
 		///   and the base abstract class) with name `Name', return type `ret_type' and
 		///   arguments `args' implements an interface, this method will
 		///   return the MethodInfo that this method implements.
 		///
 		///   If `name' is null, we operate solely on the method's signature.  This is for
 		///   instance used when implementing indexers.
 		///
 		///   The `Operation op' controls whether to lookup, clear the pending bit, or clear
 		///   all the methods with the given signature.
 		///
 		///   The `MethodInfo need_proxy' is used when we're implementing an interface's
 		///   indexer in a class.  If the new indexer's IndexerName does not match the one
 		///   that was used in the interface, then we always need to create a proxy for it.
 		///
 		/// </remarks>
 		public MethodSpec InterfaceMethod (MemberName name, TypeSpec iType, MethodData method, Operation op)
 		{
 			if (pending_implementations == null)
 				return null;
 
 			TypeSpec ret_type = method.method.ReturnType;
 			ParametersCompiled args = method.method.ParameterInfo;
 			bool is_indexer = method.method is Indexer.SetIndexerMethod || method.method is Indexer.GetIndexerMethod;
 
 			foreach (TypeAndMethods tm in pending_implementations){
 				if (!(iType == null || tm.type == iType))
 					continue;
 
 				int method_count = tm.methods.Count;
 				MethodSpec m;
 				for (int i = 0; i < method_count; i++){
 					m = tm.methods [i];
 
 					if (m == null)
 						continue;
 
 					if (is_indexer) {
 						if (!m.IsAccessor || m.Parameters.IsEmpty)
 							continue;
 					} else {
 						if (name.Name != m.Name)
 							continue;
 
 						if (m.Arity != name.Arity)
 							continue;
 					}
 
 					if (!TypeSpecComparer.Override.IsEqual (m.Parameters, args))
 						continue;
 
 					if (!TypeSpecComparer.Override.IsEqual (m.ReturnType, ret_type)) {
 						tm.found[i] = method;
 						continue;
 					}
 
 					//
 					// `need_proxy' is not null when we're implementing an
 					// interface indexer and this is Clear(One/All) operation.
 					//
 					// If `name' is null, then we do a match solely based on the
 					// signature and not on the name (this is done in the Lookup
 					// for an interface indexer).
 					//
 					if (op != Operation.Lookup) {
 						// If `t != null', then this is an explicitly interface
 						// implementation and we can always clear the method.
 						// `need_proxy' is not null if we're implementing an
 						// interface indexer.  In this case, we need to create
 						// a proxy if the implementation's IndexerName doesn't
 						// match the IndexerName in the interface.
 						if (m.DeclaringType.IsInterface && iType == null && name.Name != m.Name) {	// TODO
 							tm.need_proxy[i] = method.method.Spec;
 						} else {
 							tm.methods[i] = null;
 						}
 					} else {
 						tm.found [i] = method;
 					}
 
 					//
 					// Lookups and ClearOne return
 					//
 					if (op != Operation.ClearAll)
 						return m;
 				}
 				for (int i = 0; i < method_count; i++){
 					m = tm.methods [i];
 
 					if (m == null)
 						continue;
 
 					if (is_indexer) {
 						if (!m.IsAccessor || m.Parameters.IsEmpty)
 							continue;
 					} else {
 						if (name.Name != m.Name)
 							continue;
 
 						if (m.Arity != name.Arity)
 							continue;
 					}
 
 					if (!TypeSpecComparer.Override.IsEqual (m.Parameters, args))
 						continue;
 
 					if (!TypeSpecComparer.Override.IsEqual (m.ReturnType, ret_type)) {
 						tm.found[i] = method;
 						continue;
 					}
 
 					//
 					// `need_proxy' is not null when we're implementing an
 					// interface indexer and this is Clear(One/All) operation.
 					//
 					// If `name' is null, then we do a match solely based on the
 					// signature and not on the name (this is done in the Lookup
 					// for an interface indexer).
 					//
 					if (op != Operation.Lookup) {
 						// If `t != null', then this is an explicitly interface
 						// implementation and we can always clear the method.
 						// `need_proxy' is not null if we're implementing an
 						// interface indexer.  In this case, we need to create
 						// a proxy if the implementation's IndexerName doesn't
 						// match the IndexerName in the interface.
 						if (m.DeclaringType.IsInterface && iType == null && name.Name != m.Name) {	// TODO
 							tm.need_proxy[i] = method.method.Spec;
 						} else {
 							tm.methods[i] = null;
 						}
 					} else {
 						tm.found [i] = method;
 					}
 
 					//
 					// Lookups and ClearOne return
 					//
 					if (op != Operation.ClearAll)
 						return m;
 				}
 
 				// If a specific type was requested, we can stop now.
 				if (tm.type == iType)
 					return null;
 			}
 			foreach (TypeAndMethods tm in pending_implementations){
 				if (!(iType == null || tm.type == iType))
 					continue;
 
 				int method_count = tm.methods.Count;
 				MethodSpec m;
 				for (int i = 0; i < method_count; i++){
 					m = tm.methods [i];
 
 					if (m == null)
 						continue;
 
 					if (is_indexer) {
 						if (!m.IsAccessor || m.Parameters.IsEmpty)
 							continue;
 					} else {
 						if (name.Name != m.Name)
 							continue;
 
 						if (m.Arity != name.Arity)
 							continue;
 					}
 
 					if (!TypeSpecComparer.Override.IsEqual (m.Parameters, args))
 						continue;
 
 					if (!TypeSpecComparer.Override.IsEqual (m.ReturnType, ret_type)) {
 						tm.found[i] = method;
 						continue;
 					}
 
 					//
 					// `need_proxy' is not null when we're implementing an
 					// interface indexer and this is Clear(One/All) operation.
 					//
 					// If `name' is null, then we do a match solely based on the
 					// signature and not on the name (this is done in the Lookup
 					// for an interface indexer).
 					//
 					if (op != Operation.Lookup) {
 						// If `t != null', then this is an explicitly interface
 						// implementation and we can always clear the method.
 						// `need_proxy' is not null if we're implementing an
 						// interface indexer.  In this case, we need to create
 						// a proxy if the implementation's IndexerName doesn't
 						// match the IndexerName in the interface.
 						if (m.DeclaringType.IsInterface && iType == null && name.Name != m.Name) {	// TODO
 							tm.need_proxy[i] = method.method.Spec;
 						} else {
 							tm.methods[i] = null;
 						}
 					} else {
 						tm.found [i] = method;
 					}
 
 					//
 					// Lookups and ClearOne return
 					//
 					if (op != Operation.ClearAll)
 						return m;
 				}
 
 				// If a specific type was requested, we can stop now.
 				if (tm.type == iType)
 					return null;
 			}
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1861" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2426" endline="2486">
<![CDATA[
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="578" endline="671">
<![CDATA[
 
 		[Flags]
 		public enum MemberLookupRestrictions
 		{
 			None = 0,
 			InvocableOnly = 1,
 			ExactArity = 1 << 2,
 			ReadAccess = 1 << 3
 		}
 
 		//
 		// Lookup type `queried_type' for code in class `container_type' with a qualifier of
 		// `qualifier_type' or null to lookup members in the current class.
 		//
 		public static Expression MemberLookup (ResolveContext rc, TypeSpec currentType, TypeSpec queried_type, string name, int arity, MemberLookupRestrictions restrictions, Location loc)
 		{
 			var members = MemberCache.FindMembers (queried_type, name, false);
 			if (members == null)
 				return null;
 
 			MemberSpec non_method = null;
 			MemberSpec ambig_non_method = null;
 			currentType = currentType ?? InternalType.FakeInternalType;
 			do {
 				for (int i = 0; i < members.Count; ++i) {
 					var member = members[i];
 
 					// HACK
 					if ((member.Modifiers & Modifiers.OVERRIDE) != 0 && member.Kind != MemberKind.Event)
 						continue;
 
 					if ((arity > 0 || (restrictions & MemberLookupRestrictions.ExactArity) != 0) && member.Arity != arity)
 						continue;
 
 					if (rc != null) {
 						if (!member.IsAccessible (currentType))
 							continue;
 
 						//
 						// With runtime binder we can have a situation where queried type is inaccessible
 						// because it came via dynamic object, the check about inconsisted accessibility
 						// had no effect as the type was unknown during compilation
 						//
 						// class A {
 						//		private class N { }
 						//
 						//		public dynamic Foo ()
 						//		{
 						//			return new N ();
 						//		}
 						//	}
 						//
 						if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (currentType))
 							continue;
 					}
 
 					if ((restrictions & MemberLookupRestrictions.InvocableOnly) != 0) {
 						if (member is MethodSpec)
 							return new MethodGroupExpr (members, queried_type, loc);
 
 						if (!Invocation.IsMemberInvocable (member))
 							continue;
 					}
 
 					if (non_method == null || member is MethodSpec) {
 						non_method = member;
 					} else if (currentType != null) {
 						ambig_non_method = member;
 					}
 				}
 				for (int i = 0; i < members.Count; ++i) {
 					var member = members[i];
 
 					// HACK
 					if ((member.Modifiers & Modifiers.OVERRIDE) != 0 && member.Kind != MemberKind.Event)
 						continue;
 
 					if ((arity > 0 || (restrictions & MemberLookupRestrictions.ExactArity) != 0) && member.Arity != arity)
 						continue;
 
 					if (rc != null) {
 						if (!member.IsAccessible (currentType))
 							continue;
 
 						//
 						// With runtime binder we can have a situation where queried type is inaccessible
 						// because it came via dynamic object, the check about inconsisted accessibility
 						// had no effect as the type was unknown during compilation
 						//
 						// class A {
 						//		private class N { }
 						//
 						//		public dynamic Foo ()
 						//		{
 						//			return new N ();
 						//		}
 						//	}
 						//
 						if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (currentType))
 							continue;
 					}
 
 					if ((restrictions & MemberLookupRestrictions.InvocableOnly) != 0) {
 						if (member is MethodSpec)
 							return new MethodGroupExpr (members, queried_type, loc);
 
 						if (!Invocation.IsMemberInvocable (member))
 							continue;
 					}
 
 					if (non_method == null || member is MethodSpec) {
 						non_method = member;
 					} else if (currentType != null) {
 						ambig_non_method = member;
 					}
 				}
 
 				if (non_method != null) {
 					if (ambig_non_method != null && rc != null) {
 						rc.Report.SymbolRelatedToPreviousError (non_method);
 						rc.Report.SymbolRelatedToPreviousError (ambig_non_method);
 						rc.Report.Error (229, loc, "Ambiguity between `{0}' and `{1}'",
 							non_method.GetSignatureForError (), ambig_non_method.GetSignatureForError ());
 					}
 
 					if (non_method is MethodSpec)
 						return new MethodGroupExpr (members, queried_type, loc);
 
 					return ExprClassFromMemberInfo (non_method, loc);
 				}
 
 				if (members[0].DeclaringType.BaseType == null)
 					members = null;
 				else
 					members = MemberCache.FindMembers (members[0].DeclaringType.BaseType, name, false);
 
 			} while (members != null);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1862" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2426" endline="2486">
<![CDATA[
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="515" endline="609">
<![CDATA[
 
 		//
 		// Returns base members of @member member if no exact match is found @bestCandidate returns
 		// the best match
 		//
 		public static MemberSpec FindBaseMember (MemberCore member, out MemberSpec bestCandidate)
 		{
 			bestCandidate = null;
 			var container = member.Parent.PartialContainer.Definition;
 			if (!container.IsInterface) {
 				container = container.BaseType;
 
 				// It can happen for a user definition of System.Object
 				if (container == null)
 					return null;
 			}
 
 			string name = GetLookupName (member);
 			IList<MemberSpec> applicable;
 			var member_param = member is IParametersMember ? ((IParametersMember) member).Parameters 
 
 			var mkind = GetMemberCoreKind (member);
 			bool member_with_accessors = mkind == MemberKind.Indexer || mkind == MemberKind.Property;
 
 			do {
 				if (container.MemberCache.member_hash.TryGetValue (name, out applicable)) {
 					for (int i = 0; i < applicable.Count; ++i) {
 						var entry = applicable [i];
 
 						if ((entry.Modifiers & Modifiers.PRIVATE) != 0)
 							continue;
 
 						if ((entry.Modifiers & Modifiers.AccessibilityMask) == Modifiers.INTERNAL &&
 							!entry.DeclaringType.MemberDefinition.IsInternalAsPublic (member.Module.DeclaringAssembly))
 							continue;
 
 						//
 						// Is the member of same kind ?
 						//
 						if ((entry.Kind & ~MemberKind.Destructor & mkind & MemberKind.MaskType) == 0) {
 							// Destructors are ignored as they cannot be overridden by user
 							if ((entry.Kind & MemberKind.Destructor) != 0)
 								continue;
 
 							// A method with different arity does not hide base member
 							if (mkind != MemberKind.Method && member.MemberName.Arity != entry.Arity)
 								continue;
 
 							bestCandidate = entry;
 							return null;
 						}
 
 						//
 						// Same kind of different arity is valid
 						//
 						if (member.MemberName.Arity != entry.Arity) {
 							continue;
 						}
 
 						if ((entry.Kind & mkind & (MemberKind.Method | MemberKind.Indexer)) != 0) {
 							if (entry.IsAccessor != member is AbstractPropertyEventMethod)
 								continue;
 
 							var pm = entry as IParametersMember;
 							if (!TypeSpecComparer.Override.IsEqual (pm.Parameters, member_param))
 								continue;
 						}
 
 						//
 						// Skip override members with accessors they may not fully implement the base member
 						//
 						if (member_with_accessors) {
 							if ((entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.SEALED)) == Modifiers.OVERRIDE) {
 								//
 								// Set candidate to member override to flag we found an implementation
 								//
 								bestCandidate = entry;
 								continue;
 							}
 						} else {
 							bestCandidate = null;
 						}
 
 						return entry;
 					for (int i = 0; i < applicable.Count; ++i) {
 						var entry = applicable [i];
 
 						if ((entry.Modifiers & Modifiers.PRIVATE) != 0)
 							continue;
 
 						if ((entry.Modifiers & Modifiers.AccessibilityMask) == Modifiers.INTERNAL &&
 							!entry.DeclaringType.MemberDefinition.IsInternalAsPublic (member.Module.DeclaringAssembly))
 							continue;
 
 						//
 						// Is the member of same kind ?
 						//
 						if ((entry.Kind & ~MemberKind.Destructor & mkind & MemberKind.MaskType) == 0) {
 							// Destructors are ignored as they cannot be overridden by user
 							if ((entry.Kind & MemberKind.Destructor) != 0)
 								continue;
 
 							// A method with different arity does not hide base member
 							if (mkind != MemberKind.Method && member.MemberName.Arity != entry.Arity)
 								continue;
 
 							bestCandidate = entry;
 							return null;
 						}
 
 						//
 						// Same kind of different arity is valid
 						//
 						if (member.MemberName.Arity != entry.Arity) {
 							continue;
 						}
 
 						if ((entry.Kind & mkind & (MemberKind.Method | MemberKind.Indexer)) != 0) {
 							if (entry.IsAccessor != member is AbstractPropertyEventMethod)
 								continue;
 
 							var pm = entry as IParametersMember;
 							if (!TypeSpecComparer.Override.IsEqual (pm.Parameters, member_param))
 								continue;
 						}
 
 						//
 						// Skip override members with accessors they may not fully implement the base member
 						//
 						if (member_with_accessors) {
 							if ((entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.SEALED)) == Modifiers.OVERRIDE) {
 								//
 								// Set candidate to member override to flag we found an implementation
 								//
 								bestCandidate = entry;
 								continue;
 							}
 						} else {
 							bestCandidate = null;
 						}
 
 						return entry;
 					}
 				}
 
 				if (container.IsInterface)
 					break;
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1863" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2426" endline="2486">
<![CDATA[
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2756" endline="2884">
<![CDATA[
 
 		//
 		// 26.3.3.10 Fixing
 		//
 		public bool FixType (ResolveContext ec, int i)
 		{
 			// It's already fixed
 			if (fixed_types[i] != null)
 				throw new InternalErrorException ("Type argument has been already fixed");
 
 			if (failed)
 				return false;
 
 			var candidates = bounds [i];
 			if (candidates == null)
 				return false;
 
 			if (candidates.Count == 1) {
 				TypeSpec t = candidates[0].Type;
 				if (t == InternalType.Null)
 					return false;
 
 				fixed_types [i] = t;
 				return true;
 			}
 
 			//
 			// Determines a unique type from which there is
 			// a standard implicit conversion to all the other
 			// candidate types.
 			//
 			TypeSpec best_candidate = null;
 			int cii;
 			int candidates_count = candidates.Count;
 			for (int ci = 0; ci < candidates_count; ++ci) {
 				BoundInfo bound = candidates [ci];
 				for (cii = 0; cii < candidates_count; ++cii) {
 					if (cii == ci)
 						continue;
 
 					BoundInfo cbound = candidates[cii];
 					
 					// Same type parameters with different bounds
 					if (cbound.Type == bound.Type) {
 						if (bound.Kind != BoundKind.Exact)
 							bound = cbound;
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Exact || cbound.Kind == BoundKind.Exact) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						if (cbound.Kind == BoundKind.Upper) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						
 						if (bound.Kind != BoundKind.Exact) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 							continue;
 						}
 						
 						break;
 					}
 
 					if (bound.Kind == BoundKind.Lower) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 						} else {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 						}
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Upper) {
 						if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 							break;
 						}
 					} else {
 						throw new NotImplementedException ("variance conversion");
 					}
 				}
 				for (cii = 0; cii < candidates_count; ++cii) {
 					if (cii == ci)
 						continue;
 
 					BoundInfo cbound = candidates[cii];
 					
 					// Same type parameters with different bounds
 					if (cbound.Type == bound.Type) {
 						if (bound.Kind != BoundKind.Exact)
 							bound = cbound;
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Exact || cbound.Kind == BoundKind.Exact) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						if (cbound.Kind == BoundKind.Upper) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						
 						if (bound.Kind != BoundKind.Exact) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 							continue;
 						}
 						
 						break;
 					}
 
 					if (bound.Kind == BoundKind.Lower) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 						} else {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 						}
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Upper) {
 						if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 							break;
 						}
 					} else {
 						throw new NotImplementedException ("variance conversion");
 					}
 				}
 
 				if (cii != candidates_count)
 					continue;
 
 				//
 				// We already have the best candidate, break if thet are different
 				//
 				// Dynamic is never ambiguous as we prefer dynamic over other best candidate types
 				//
 				if (best_candidate != null) {
 
 					if (best_candidate == InternalType.Dynamic)
 						continue;
 
 					if (bound.Type != InternalType.Dynamic && best_candidate != bound.Type)
 						return false;
 				}
 
 				best_candidate = bound.Type;
 			}
 			for (int ci = 0; ci < candidates_count; ++ci) {
 				BoundInfo bound = candidates [ci];
 				for (cii = 0; cii < candidates_count; ++cii) {
 					if (cii == ci)
 						continue;
 
 					BoundInfo cbound = candidates[cii];
 					
 					// Same type parameters with different bounds
 					if (cbound.Type == bound.Type) {
 						if (bound.Kind != BoundKind.Exact)
 							bound = cbound;
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Exact || cbound.Kind == BoundKind.Exact) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						if (cbound.Kind == BoundKind.Upper) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						
 						if (bound.Kind != BoundKind.Exact) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 							continue;
 						}
 						
 						break;
 					}
 
 					if (bound.Kind == BoundKind.Lower) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 						} else {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 						}
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Upper) {
 						if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 							break;
 						}
 					} else {
 						throw new NotImplementedException ("variance conversion");
 					}
 				}
 
 				if (cii != candidates_count)
 					continue;
 
 				//
 				// We already have the best candidate, break if thet are different
 				//
 				// Dynamic is never ambiguous as we prefer dynamic over other best candidate types
 				//
 				if (best_candidate != null) {
 
 					if (best_candidate == InternalType.Dynamic)
 						continue;
 
 					if (bound.Type != InternalType.Dynamic && best_candidate != bound.Type)
 						return false;
 				}
 
 				best_candidate = bound.Type;
 			}
 
 			if (best_candidate == null)
 				return false;
 
 			fixed_types[i] = best_candidate;
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1864" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2426" endline="2486">
<![CDATA[
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1050" endline="1205">
<![CDATA[
 
 		//
 		// User-defined conversions
 		//
 		static Expression UserDefinedConversion (ResolveContext ec, Expression source, TypeSpec target, bool implicitOnly, Location loc)
 		{
 			List<MethodSpec> candidates = null;
 
 			//
 			// If S or T are nullable types, source_type and target_type are their underlying types
 			// otherwise source_type and target_type are equal to S and T respectively.
 			//
 			TypeSpec source_type = source.Type;
 			TypeSpec target_type = target;
 			Expression source_type_expr;
 
 			if (TypeManager.IsNullableType (source_type)) {
 				// No implicit conversion S? -> T for non-reference types
 				if (implicitOnly && !TypeManager.IsReferenceType (target_type) && !TypeManager.IsNullableType (target_type))
 					return null;
 
 				source_type_expr = Nullable.Unwrap.Create (source);
 				source_type = source_type_expr.Type;
 			} else {
 				source_type_expr = source;
 			}
 
 			if (TypeManager.IsNullableType (target_type))
 				target_type = Nullable.NullableInfo.GetUnderlyingType (target_type);
 
 			// Only these containers can contain a user defined implicit or explicit operators
 			const MemberKind user_conversion_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.TypeParameter;
 
 			if ((source_type.Kind & user_conversion_kinds) != 0 && source_type != TypeManager.decimal_type) {
 				bool declared_only = source_type.IsStruct;
 
 				var operators = MemberCache.GetUserOperator (source_type, Operator.OpType.Implicit, declared_only);
 				if (operators != null) {
 					FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, implicitOnly, ref candidates);
 				}
 
 				if (!implicitOnly) {
 					operators = MemberCache.GetUserOperator (source_type, Operator.OpType.Explicit, declared_only);
 					if (operators != null) {
 						FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, false, ref candidates);
 					}
 				}
 			}
 
 			if ((target.Kind & user_conversion_kinds) != 0 && target_type != TypeManager.decimal_type) {
 				bool declared_only = target.IsStruct || implicitOnly;
 
 				var operators = MemberCache.GetUserOperator (target_type, Operator.OpType.Implicit, declared_only);
 				if (operators != null) {
 					FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, implicitOnly, ref candidates);
 				}
 
 				if (!implicitOnly) {
 					operators = MemberCache.GetUserOperator (target_type, Operator.OpType.Explicit, declared_only);
 					if (operators != null) {
 						FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, false, ref candidates);
 					}
 				}
 			}
 
 			if (candidates == null)
 				return null;
 
 			//
 			// Find the most specific conversion operator
 			//
 			MethodSpec most_specific_operator;
 			TypeSpec s_x, t_x;
 			if (candidates.Count == 1) {
 				most_specific_operator = candidates[0];
 				s_x = most_specific_operator.Parameters.Types[0];
 				t_x = most_specific_operator.ReturnType;
 			} else {
 				//
 				// Pass original source type to find the best match against input type and
 				// not the unwrapped expression
 				//
 				s_x = FindMostSpecificSource (candidates, source.Type, source_type_expr, !implicitOnly);
 				if (s_x == null)
 					return null;
 
 				t_x = FindMostSpecificTarget (candidates, target, !implicitOnly);
 				if (t_x == null)
 					return null;
 
 				most_specific_operator = null;
 				for (int i = 0; i < candidates.Count; ++i) {
 					if (candidates[i].ReturnType == t_x && candidates[i].Parameters.Types[0] == s_x) {
 						most_specific_operator = candidates[i];
 						break;
 					}
 				}
 				for (int i = 0; i < candidates.Count; ++i) {
 					if (candidates[i].ReturnType == t_x && candidates[i].Parameters.Types[0] == s_x) {
 						most_specific_operator = candidates[i];
 						break;
 					}
 				}
 
 				if (most_specific_operator == null) {
 					MethodSpec ambig_arg = null;
 					foreach (var candidate in candidates) {
 						if (candidate.ReturnType == t_x)
 							most_specific_operator = candidate;
 						else if (candidate.Parameters.Types[0] == s_x)
 							ambig_arg = candidate;
 					}
 					foreach (var candidate in candidates) {
 						if (candidate.ReturnType == t_x)
 							most_specific_operator = candidate;
 						else if (candidate.Parameters.Types[0] == s_x)
 							ambig_arg = candidate;
 					}
 
 					ec.Report.Error (457, loc,
 						"Ambiguous user defined operators `{0}' and `{1}' when converting from `{2}' to `{3}'",
 						ambig_arg.GetSignatureForError (), most_specific_operator.GetSignatureForError (),
 						source.Type.GetSignatureForError (), target.GetSignatureForError ());
 				}
 			}
 
 			//
 			// Convert input type when it's different to best operator argument
 			//
 			if (s_x != source_type)
 				source = implicitOnly ?
 					ImplicitConversionStandard (ec, source_type_expr, s_x, loc) 
 					ExplicitConversionStandard (ec, source_type_expr, s_x, loc);
 			else {
 				source = source_type_expr;
 			}
 
 			source = new UserCast (most_specific_operator, source, loc).Resolve (ec);
 
 			//
 			// Convert result type when it's different to best operator return type
 			//
 			if (t_x != target_type) {
 				//
 				// User operator is of T?, no need to lift it
 				//
 				if (TypeManager.IsNullableType (t_x) && t_x == target)
 					return source;
 
 				source = implicitOnly ?
 					ImplicitConversionStandard (ec, source, target_type, loc) 
 					ExplicitConversionStandard (ec, source, target_type, loc);
 
 				if (source == null)
 					return null;
 			}
 
 			//
 			// Source expression is of nullable type, lift the result in the case it's null and
 			// not nullable/lifted user operator is used
 			//
 			if (source_type_expr is Nullable.Unwrap && !TypeManager.IsNullableType (s_x) && (TypeManager.IsReferenceType (target) || target_type != target))
 				source = new Nullable.Lifted (source, source_type_expr, target).Resolve (ec);
 			else if (target_type != target)
 				source = Nullable.Wrap.Create (source, target);
 
 			return source;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1865" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2426" endline="2486">
<![CDATA[
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1858" endline="1946">
<![CDATA[
 
 		/// <summary>
 		///   Performs an explicit conversion of the expression `expr' whose
 		///   type is expr.Type to `target_type'.
 		/// </summary>
 		static public Expression ExplicitConversionCore (ResolveContext ec, Expression expr,
 								 TypeSpec target_type, Location loc)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			// Explicit conversion includes implicit conversion and it used for enum underlying types too
 			Expression ne = ImplicitConversionStandard (ec, expr, target_type, loc, true);
 			if (ne != null)
 				return ne;
 
 			if (TypeManager.IsEnumType (expr_type)) {
 				TypeSpec real_target = TypeManager.IsEnumType (target_type) ? EnumSpec.GetUnderlyingType (target_type) 
 				Expression underlying = EmptyCast.Create (expr, EnumSpec.GetUnderlyingType (expr_type));
 				if (underlying.Type == real_target)
 					ne = underlying;
 
 				if (ne == null)
 					ne = ImplicitNumericConversion (underlying, real_target);
 
 				if (ne == null)
 					ne = ExplicitNumericConversion (underlying, real_target);
 
 				//
 				// LAMESPEC
 				//
 				if (ne == null && (real_target == TypeManager.intptr_type || real_target == TypeManager.uintptr_type))
 					ne = ExplicitUserConversion (ec, underlying, real_target, loc);
 
 				return ne != null ? EmptyCast.Create (ne, target_type) 
 			}
 
 			if (TypeManager.IsEnumType (target_type)) {
 				//
 				// System.Enum can be unboxed to any enum-type
 				//
 				if (expr_type == TypeManager.enum_type)
 					return new UnboxCast (expr, target_type);
 
 				TypeSpec real_target = TypeManager.IsEnumType (target_type) ? EnumSpec.GetUnderlyingType (target_type) 
 
 				if (expr_type == real_target)
 					return EmptyCast.Create (expr, target_type);
 
 				ne = ImplicitNumericConversion (expr, real_target);
 				if (ne != null)
 					return EmptyCast.Create (ne, target_type);
 
 				ne = ExplicitNumericConversion (expr, real_target);
 				if (ne != null)
 					return EmptyCast.Create (ne, target_type);
 
 				//
 				// LAMESPEC
 				//
 				if (expr_type == TypeManager.intptr_type || expr_type == TypeManager.uintptr_type) {
 					ne = ExplicitUserConversion (ec, expr, real_target, loc);
 					if (ne != null)
 						return ExplicitConversionCore (ec, ne, target_type, loc);
 				}
 			} else {
 				ne = ExplicitNumericConversion (expr, target_type);
 				if (ne != null)
 					return ne;
 			}
 
 			//
 			// Skip the ExplicitReferenceConversion because we can not convert
 			// from Null to a ValueType, and ExplicitReference wont check against
 			// null literal explicitly
 			//
 			if (expr_type != InternalType.Null) {
 				ne = ExplicitReferenceConversion (expr, expr_type, target_type);
 				if (ne != null)
 					return ne;
 			}
 
 			if (ec.IsUnsafe){
 				ne = ExplicitUnsafe (expr, target_type);
 				if (ne != null)
 					return ne;
 			}
 			
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1866" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="78" endline="136">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) AndAlso CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) And CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) And CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) And CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) And CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) And CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) And CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) And CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) And CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) And CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) And CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) And CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" startline="78" endline="135">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) OrElse CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) Or CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) Or CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) Or CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) Or CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) Or CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) Or CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) Or CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) Or CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) Or CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) Or CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) Or CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1867" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="78" endline="136">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) AndAlso CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) And CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) And CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) And CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) And CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) And CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) And CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) And CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) And CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) And CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) And CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) And CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" startline="60" endline="118">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) Xor CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) Xor CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) Xor CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) Xor CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) Xor CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) Xor CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) Xor CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) Xor CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) Xor CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) xor CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) xor CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) Xor CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1868" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" startline="78" endline="136">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) AndAlso CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) And CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) And CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) And CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) And CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) And CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) And CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) And CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) And CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) And CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) And CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) And CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" startline="60" endline="135">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
                 If CDbl(rvalue) = 0 Then
                     Helper.Stop() 'TODO
                 End If
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) \ CByte(rvalue)
                     Case TypeCode.SByte
                         If CSByte(lvalue) = SByte.MinValue AndAlso CSByte(rvalue) = -1 Then
                             Return CShort(lvalue) \ CShort(rvalue)
                         Else
                             Return CSByte(lvalue) \ CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         If CShort(lvalue) = Short.MinValue AndAlso CShort(rvalue) = -1 Then
                             Return CInt(lvalue) \ CInt(rvalue)
                         Else
                             Return CShort(lvalue) \ CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) \ CUShort(rvalue)
                     Case TypeCode.Int32
                         If CInt(lvalue) = Integer.MinValue AndAlso CInt(rvalue) = -1 Then
                             Return CLng(lvalue) \ CLng(rvalue)
                         Else
                             Return CInt(lvalue) \ CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) / CUInt(rvalue)
                     Case TypeCode.Int64
                         If CLng(lvalue) = Long.MinValue AndAlso CLng(rvalue) = -1 Then
                             'Return CDec(lvalue) \ CDec(rvalue)
                             Throw New InternalException(Me)
                         Else
                             Return CLng(lvalue) \ CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         Return CULng(lvalue) \ CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) \ CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) \ CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) \ CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1869" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1063" endline="1107">
<![CDATA[
 
     Shared Function EmitLoadArrayElement(ByVal Info As EmitInfo, ByVal ArrayVariable As Expression, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim ArrayType As Mono.Cecil.TypeReference = ArrayVariable.ExpressionType
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim isNonPrimitiveValueType As Boolean = CecilHelper.IsPrimitive(Info.Compiler, ElementType) = False AndAlso CecilHelper.IsValueType(ElementType)
         Dim isArrayGetValue As Boolean = CecilHelper.GetArrayRank(ArrayType) > 1
 
         result = ArrayVariable.GenerateCode(Info) AndAlso result
 
         If isArrayGetValue Then
             result = Arguments.GenerateCode(Info, Helper.CreateArray(Of Mono.Cecil.TypeReference)(Info.Compiler.TypeCache.System_Int32, Arguments.Length)) AndAlso result
             'result = EmitIntegerArray(Info, Arguments) AndAlso result
             Dim getMethod As Mono.Cecil.MethodReference
             getMethod = ArrayElementInitializer.GetGetMethod(Info.Compiler, ArrayType)
             Helper.Assert(getMethod IsNot Nothing, "getMethod for type " & ArrayType.FullName & " could not be found (" & ArrayType.GetType.Name & ")")
             Emitter.EmitCallVirt(Info, getMethod)
             'Emitter.EmitCallOrCallVirt(Info, Info.Compiler.TypeCache.Array_GetValue)
             'If ElementType.IsValueType Then
             '    Emitter.EmitUnbox(Info, ElementType)
             'Else
             '    Emitter.EmitCastClass(Info, Info.Compiler.TypeCache.Object, ElementType)
             'End If
         Else
             Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32)
             Dim methodtypes(Arguments.Count - 1) As Mono.Cecil.TypeReference
             For i As Integer = 0 To Arguments.Count - 1
                 Dim exp As Expression = Arguments(i).Expression
                 If Info.Compiler.TypeResolution.IsImplicitlyConvertible(Compiler.m_Compiler, exp.ExpressionType, Info.Compiler.TypeCache.System_Int32) = False Then
                     'TODO
                     exp = New CIntExpression(exp, exp)
                 End If
                 result = exp.GenerateCode(elementInfo) AndAlso result
                 methodtypes(i) = Info.Compiler.TypeCache.System_Int32
             Next
 
             If isNonPrimitiveValueType Then
                 Emitter.EmitLoadElementAddress(Info, ElementType, ArrayType)
                 Emitter.EmitLoadObject(Info, ElementType)
             Else
                 Emitter.EmitLoadElement(Info, ArrayType)
             End If
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1019" endline="1062">
<![CDATA[
 
     Shared Function EmitStoreArrayElement(ByVal Info As EmitInfo, ByVal ArrayVariable As Expression, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim ArrayType As Mono.Cecil.TypeReference = ArrayVariable.ExpressionType
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim isNonPrimitiveValueType As Boolean = CecilHelper.IsPrimitive(Info.Compiler, ElementType) = False AndAlso CecilHelper.IsValueType(ElementType)
         Dim isArraySetValue As Boolean = CecilHelper.GetArrayRank(ArrayType) > 1
         Dim newValue As Expression = Info.RHSExpression
 
         Helper.Assert(newValue IsNot Nothing)
         Helper.Assert(newValue.Classification.IsValueClassification)
 
         result = ArrayVariable.GenerateCode(Info.Clone(Info.Context, True, False, ArrayType)) AndAlso result
 
         If isArraySetValue Then
             result = newValue.GenerateCode(Info.Clone(Info.Context, True, False, ElementType)) AndAlso result
             If CecilHelper.IsValueType(ElementType) Then
                 Emitter.EmitBox(Info, ElementType)
             End If
             result = EmitIntegerArray(Info, Arguments) AndAlso result
             Emitter.EmitCallOrCallVirt(Info, Info.Compiler.TypeCache.System_Array__SetValue)
         Else
             Dim methodtypes As New Generic.List(Of Mono.Cecil.TypeReference)
             Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32)
             For i As Integer = 0 To Arguments.Count - 1
                 result = Arguments(i).GenerateCode(elementInfo) AndAlso result
                 Emitter.EmitConversion(Arguments(i).Expression.ExpressionType, Info.Compiler.TypeCache.System_Int32, Info)
                 methodtypes.Add(Info.Compiler.TypeCache.System_Int32)
             Next
 
             Dim rInfo As EmitInfo = Info.Clone(Info.Context, True, False, ElementType)
             methodtypes.Add(ElementType)
 
             If isNonPrimitiveValueType Then
                 Emitter.EmitLoadElementAddress(Info, ElementType, ArrayType)
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                 Emitter.EmitStoreObject(Info, ElementType)
             Else
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                 Emitter.EmitStoreElement(Info, ElementType, ArrayType)
             End If
         End If
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1870" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" startline="156" endline="736">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         '---------------------------------------------------------------------------------------------------------
         'A member access expression is used to access a member of an entity. A member access of the form E.I, 
         'where E is an expression, a built-in type, the keyword Global, or omitted and I is an identifier with an 
         'optional type argument list, is evaluated and classified as follows
         '---------------------------------------------------------------------------------------------------------
         '* If E is omitted, then the expression from the immediately containing With statement is substituted for 
         '  E and the member access is performed. If there is no containing With statement, a compile-time 
         '  error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* If E is a type parameter, then a compile-time error results.
         '---------------------------------------------------------------------------------------------------------
         '* If E is the keyword Global, and I is the name of an accessible type in the global namespace, 
         '  then the result is that type.
         '---------------------------------------------------------------------------------------------------------
         '* If E is classified as a namespace and I is the name of an accessible member of that namespace, 
         '  then the result is that member. The result is classified as a namespace or a type depending on the member.
         '---------------------------------------------------------------------------------------------------------
         '* If E is a built-in type or an expression classified as a type, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New, then a compile-time error occurs.
         '** If I identifies a type, then the result is that type.
         '** If I identifies one or more methods, then the result is a method group with the associated 
         '   type argument list and no associated instance expression.
         '** If I identifies one or more properties, then the result is a property group with no associated 
         '   instance expression.
         '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
         '   outside the shared constructor of the type in which the variable is declared, then the result is the 
         '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
         '** If I identifies a shared event, the result is an event access with no associated instance expression.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* If E is classified as a variable or value, the type of which is T, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
         '   a method group representing the instance constructors of the type of E with an associated 
         '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
         '** If I identifies one or more methods, then the result is a method group with the associated type 
         '   argument list and an associated instance expression of E.
         '** If I identifies one or more properties, then the result is a property group with an 
         '   associated instance expression of E.
         '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
         '   and the reference occurs outside a constructor of the class in which the variable is declared 
         '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
         '   variable I in the object referenced by E. If T is a reference type, then the result is the variable 
         '   I in the object referenced by E. Otherwise, if T is a value type and the expression E is classified 
         '   as a variable, the result is a variable; otherwise the result is a value.
         '** If I identifies an event, the result is an event access with an associated instance expression of E.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
         '   with an associated instance expression of E.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         'If the member access expression includes a type argument list, then only types or methods 
         'with the same arity as the type argument list are considered.
         'When a member access expression begins with the keyword Global, the keyword represents the outermost 
         'unnamed namespace, which is useful in situations where a declaration shadows an enclosing namespace. The 
         'Global keyword allows "escaping" out to the outermost namespace in that situation. 
         '---------------------------------------------------------------------------------------------------------
 
         Dim Name As String = m_Second.Name
         Dim typeArguments As TypeArgumentList = Nothing
 
         Dim iokwta As IdentifierOrKeywordWithTypeArguments = TryCast(m_Second, IdentifierOrKeywordWithTypeArguments)
         If iokwta IsNot Nothing Then
             typeArguments = iokwta.TypeArguments
         End If
         
         Helper.Assert(Name IsNot Nothing AndAlso Name <> "")
 
         If m_First IsNot Nothing Then
             result = m_First.ResolveExpression(New ResolveInfo(Info.Compiler, False, Info.CanFail, Info.CanBeImplicitSimpleName)) AndAlso result
         Else
             '* If E is omitted, then the expression from the immediately containing With statement is substituted for
             '  E and the member access is performed. If there is no containing With statement, a compile-time 
             '  error occurs.
             m_WithStatement = Me.FindFirstParentOfCodeBlock(Of WithStatement)()
             If m_WithStatement Is Nothing Then
                 Helper.AddError(Me)
                 Return False
             Else
                 m_First = m_WithStatement.WithVariableExpression
                 ' Helper.Assert(m_First.IsResolved)
             End If
         End If
 
         If result = False Then Return result
 
         '* If E is a type parameter, then a compile-time error results.
         If m_First.Classification.IsTypeClassification AndAlso m_First.Classification.AsTypeClassification.IsTypeParameter Then
             result = Compiler.Report.ShowMessage(Messages.VBNC32098, Me.Location) AndAlso result
             If result = False Then Return result
         End If
 
         '* If E is the keyword Global, and I is the name of an accessible type in the global namespace, 
         '  then the result is that type.
         If TypeOf m_First Is GlobalExpression Then
             Dim foundType As Mono.Cecil.TypeReference
             foundType = Compiler.TypeManager.GetTypesByNamespace("").Item(Name)
             If foundType IsNot Nothing Then
                 Classification = New TypeClassification(Me, foundType)
                 Return True
             ElseIf Compiler.TypeManager.Namespaces.ContainsKey(Name) Then
                 Classification = New NamespaceClassification(Me, Compiler.TypeManager.Namespaces(Name))
                 Return True
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC30456, Location, Name, "<Default>") AndAlso result
             End If
         End If
 
         '* If E is classified as a namespace and I is the name of an accessible member of that namespace, 
         '  then the result is that member. The result is classified as a namespace or a type depending on the member.
         If m_First.Classification.IsNamespaceClassification Then
             Dim nstypes As Generic.List(Of Mono.Cecil.TypeReference) = Nothing
             Dim ns As [Namespace] = m_First.Classification.AsNamespaceClassification.Namespace
             Dim nsname As String = ns.Name
             Dim foundns As [Namespace]
             Dim foundType As Mono.Cecil.TypeReference
 
             foundns = Compiler.TypeManager.Namespaces.Item(ns, Name)
             foundType = Compiler.TypeManager.TypesByNamespace(nsname).Item(Name)
 
             If foundns IsNot Nothing AndAlso foundType Is Nothing Then
                 Classification = New NamespaceClassification(Me, foundns)
                 Return True
             ElseIf foundns Is Nothing AndAlso foundType IsNot Nothing Then
                 Classification = New TypeClassification(Me, foundType)
                 Return True
             ElseIf foundns IsNot Nothing AndAlso nstypes IsNot Nothing Then
                 Helper.AddError(Me, "Found a namespace and a type with the same name.")
             End If
 
             'TODO
             Dim modules As TypeDictionary = Compiler.TypeManager.GetModulesByNamespace(ns.ToString)
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Helper.GetMembersOfTypes(Compiler, modules, Name)
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 Dim first As Object = members(0)
                 If Helper.IsMethodDeclaration(first) Then
                     Classification = New MethodGroupClassification(Me, Nothing, typeArguments, Nothing, members)
                     Return True
                 ElseIf Helper.IsTypeDeclaration(first) Then
                     If members.Count = 1 Then
                         Classification = New TypeClassification(Me, first)
                         Return True
                     Else
                         Helper.AddError(Me)
                     End If
                 ElseIf Helper.IsFieldDeclaration(first) Then
                     If members.Count = 1 Then
                         Classification = New VariableClassification(Me, DirectCast(first, Mono.Cecil.FieldReference), Nothing)
                         Return True
                     Else
                         Helper.AddError(Me)
                     End If
                 ElseIf Helper.IsPropertyDeclaration(first) Then
                     Classification = New PropertyGroupClassification(Me, Nothing, members)
                     Return True
                 Else
                     Helper.Stop()
                 End If
             End If
         End If
 
         '* If E is a built-in type or an expression classified as a type, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New, then a compile-time error occurs.
         '** If I identifies a type, then the result is that type.
         '** If I identifies one or more methods, then the result is a method group with the associated 
         '   type argument list and no associated instance expression.
         '** If I identifies one or more properties, then the result is a property group with no associated 
         '   instance expression.
         '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
         '   outside the shared constructor of the type in which the variable is declared, then the result is the 
         '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
         '** If I identifies a shared event, the result is an event access with no associated instance expression.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         If m_First.Classification.IsTypeClassification Then
             'If m_Second.IsKeyword AndAlso m_Second.Keyword = KS.New Then
             '    '** If I is the keyword New, then a compile-time error occurs.
             '    Helper.AddError(Me)
             'End If
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
             Dim entry As MemberCacheEntry
             'members = Helper.FilterByName(Helper.GetMembers(Compiler, m_First.Classification.AsTypeClassification.Type), Name)
             'members = Helper.FilterByName(Compiler.TypeManager.GetCache(m_First.Classification.AsTypeClassification.Type).FlattenedCache.GetAllMembers.ToArray, Name)
             entry = Compiler.TypeManager.GetCache(m_First.Classification.AsTypeClassification.Type).LookupFlattened(Name)
 
             If entry Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, m_First.Classification.AsTypeClassification.Type.FullName)
                 Return False
             End If			
 
             If entry IsNot Nothing Then
                 members = entry.Members
                 If typeArguments IsNot Nothing Then
                     members = Helper.FilterByTypeArguments(members, typeArguments)
                     'For i As Integer = 0 To members.Count - 1
                     '    Dim mR As Mono.Cecil.MethodReference = TryCast(members(i), Mono.Cecil.MethodReference)
                     '    If mR Is Nothing Then
                     '        Helper.StopIfDebugging()
                     '        Continue For
                     '    End If
                     '    members(i) = CecilHelper.GetCorrectMember(mR, withTypeArgs.TypeArguments.ArgumentCollection)
                     'Next
                 End If
                 members = Helper.FilterExternalInaccessible(Me.Compiler, members)
             End If
 
             Helper.StopIfDebugging(members Is Nothing OrElse members.Count = 0)
 
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 Dim first As Object = members(0)
                 '** If I identifies one or more methods, then the result is a method group with the associated 
                 '   type argument list and no associated instance expression.
                 If Helper.IsMethodDeclaration(first) Then
                     Classification = New MethodGroupClassification(Me, Nothing, typeArguments, Nothing, members)
                     Return True
                 End If
                 '** If I identifies one or more properties, then the result is a property group with no associated 
                 '   instance expression.
                 If Helper.IsPropertyDeclaration(first) Then
                     Dim instanceExpression As Expression = Nothing
                     If m_First.Classification.AsTypeClassification.CanBeExpression Then
                         'Ignore failures here, not sure if failures can actually happen for valid code
                         m_First.Classification.AsTypeClassification.CreateAliasExpression(m_First, instanceExpression)
                     End If
                     Classification = New PropertyGroupClassification(Me, instanceExpression, members)
                     Return True
                 End If
 
                 If members.Count > 1 Then Helper.Stop()
 
                 '** If I identifies a type, then the result is that type.
                 If Helper.IsTypeDeclaration(first) Then
                     Classification = New TypeClassification(Me, first)
                     Return True
                 End If
 
                 '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
                 '   outside the shared constructor of the type in which the variable is declared, then the result is the 
                 '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
                 If Helper.IsFieldDeclaration(first) Then
                     Dim fld As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
                     If fld Is Nothing Then
                         Dim var As TypeVariableDeclaration = TryCast(first, TypeVariableDeclaration)
                         Helper.Assert(var IsNot Nothing)
                         fld = var.FieldBuilder
                     End If
                     Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
                     Dim instanceExpression As Expression = Nothing
 
                     If Not CecilHelper.IsStatic(fld) AndAlso m_First.Classification.IsTypeClassification AndAlso m_First.Classification.AsTypeClassification.CanBeExpression Then
                         result = m_First.Classification.AsTypeClassification.CreateAliasExpression(m_First, instanceExpression) AndAlso result
                     End If
 
                     If Helper.IsShared(fld) AndAlso CBool(CecilHelper.FindDefinition(fld).Attributes And Mono.Cecil.FieldAttributes.InitOnly) AndAlso (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) = False) Then
                         Classification = New ValueClassification(Me, fld, Nothing)
                         Return True
                     Else
                         Classification = New VariableClassification(Me, fld, instanceExpression)
                         Return True
                     End If
                 End If
 
                 '** If I identifies a shared event, the result is an event access with no associated instance expression.
                 If Helper.IsEventDeclaration(first) Then
                     Dim red As EventDeclaration = TryCast(first, EventDeclaration)
                     Dim red2 As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(TryCast(first, Mono.Cecil.EventReference))
                     If red IsNot Nothing AndAlso red.Modifiers.Is(ModifierMasks.Shared) Then
                         Classification = New EventAccessClassification(Me, red.EventDescriptor, Nothing)
                         Return True
                     ElseIf red2 IsNot Nothing AndAlso red2.AddMethod.IsStatic Then
                         Classification = New EventAccessClassification(Me, red2, Nothing)
                         Return True
                     End If
                 End If
 
                 '** If I identifies a constant, then the result is the value of that constant.
                 Dim c As ConstantDeclaration = TryCast(first, ConstantDeclaration)
                 If c IsNot Nothing Then
                     Classification = New ValueClassification(Me, c)
                     Return True
                 End If
 
                 '** If I identifies an enumeration member, then the result is the value of that enumeration member.
                 Dim enummember As EnumMemberDeclaration = TryCast(first, EnumMemberDeclaration)
                 If enummember IsNot Nothing Then
                     Classification = New ValueClassification(Me, enummember)
                     Return True
                 End If
 
                 '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
                 'Now we need to check for default instances
                 If m_First.Classification.AsTypeClassification.CanBeExpression Then
                     Dim aliasExpression As Expression = Nothing
                     m_First.Classification.AsTypeClassification.CreateAliasExpression(m_First, aliasExpression)
                     m_First = aliasExpression
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30469, Me.Location)
                 End If
             Else
                 Helper.AddError(Me, "Could not resolve name '" & Name & "'" & "," & Me.Location.ToString(Compiler))
             End If
         End If
 
 
         '* If E is classified as a variable or value, the type of which is T, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
         '   a method group representing the instance constructors of the type of E with an associated 
         '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
         '** If I identifies one or more methods, then the result is a method group with the associated type 
         '   argument list and an associated instance expression of E.
         '** If I identifies one or more properties, then the result is a property group with an 
         '   associated instance expression of E.
         '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
         '   and the reference occurs outside a constructor of the class in which the variable is declared 
         '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
         '   variable I in the object referenced by E. If T is a reference type, then the result is the variable 
         '   I in the object referenced by E. Otherwise, if T is a value type and the expression E is classified 
         '   as a variable, the result is a variable; otherwise the result is a value.
         '** If I identifies an event, the result is an event access with an associated instance expression of E.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
         '   with an associated instance expression of E.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         If m_First.Classification.IsValueClassification OrElse m_First.Classification.IsVariableClassification OrElse m_First.Classification.CanBeValueClassification Then
             Dim T As Mono.Cecil.TypeReference 'Descriptor
 
             If m_First.Classification.IsValueClassification Then
                 T = m_First.Classification.AsValueClassification.Type
             ElseIf m_First.Classification.IsVariableClassification Then
                 T = m_First.Classification.AsVariableClassification.Type
             ElseIf m_First.Classification.CanBeValueClassification Then
                 m_First = m_First.ReclassifyToValueExpression
                 result = m_First.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                 If result = False Then
                     If Info.IsEventResolution Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30506, Location)
                     Else
                         Helper.AddError(Compiler, Location, "Huh?")
                     End If
                 End If
                 Helper.Assert(m_First.Classification IsNot Nothing)
                 Helper.Assert(m_First.Classification.AsValueClassification IsNot Nothing)
                 T = m_First.Classification.AsValueClassification.Type
             Else
                 Throw New InternalException(Me)
             End If
 
             If CecilHelper.IsByRef(T) Then
                 m_First = m_First.DereferenceByRef()
                 T = m_First.ExpressionType
             End If
 
             '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
             '   a method group representing the instance constructors of the type of E with an associated 
             '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
             If m_Second.IsKeyword AndAlso m_Second.Keyword = KS.New Then
                 If TypeOf m_First Is InstanceExpression Then
                     Classification = New MethodGroupClassification(Me, m_First, typeArguments, Nothing, Helper.GetInstanceConstructors(T))
                     Return True
                 Else
                     Helper.AddError(Me)
                 End If
             End If
 
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             Dim member As MemberCacheEntry
 
             member = Compiler.TypeManager.GetCache(T).LookupFlattened(Name, Me.FindFirstParent_IType.CecilType)
             If member Is Nothing Then
                 If Me.File.IsOptionStrictOn = False AndAlso Helper.CompareType(T, Compiler.TypeCache.System_Object) Then
                     Classification = New LateBoundAccessClassification(Me, m_First, Nothing, Name)
                     Return True
                 End If
 
                 member = Compiler.TypeManager.GetCache(T).LookupFlattened(Name, MemberVisibility.All)
                 If member Is Nothing OrElse member.Members.Count = 0 Then
                     If Helper.CompareType(T, Compiler.TypeCache.System_Object) Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30574, Me.Location) AndAlso result
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName) AndAlso result
                     End If
                 ElseIf member.Members.Count = 1 Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30390, Me.Location, Name, T.FullName, Helper.GetVisibilityString(member.Members(0))) AndAlso result
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30517, Me.Location, Name) AndAlso result
                 End If
             End If
 
             members = member.Members
             Dim withTypeArgs As IdentifierOrKeywordWithTypeArguments
             withTypeArgs = TryCast(m_Second, IdentifierOrKeywordWithTypeArguments)
             If withTypeArgs IsNot Nothing Then
                 members = Helper.FilterByTypeArguments(members, withTypeArgs.TypeArguments)
             End If
             members = Helper.FilterExternalInaccessible(Me.Compiler, members)
 
             If members.Count = 0 Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName) AndAlso result
                 If result = False Then Return result
             End If
 
             If members.Count > 0 Then
                 Dim first As Object = members(0)
                 '** If I identifies one or more methods, then the result is a method group with the associated type 
                 '   argument list and an associated instance expression of E.
                 If Helper.IsMethodDeclaration(first) Then
                     m_First = m_First.GetObjectReference
                     Classification = New MethodGroupClassification(Me, m_First, typeArguments, Nothing, members)
                     Return True
                 End If
                 '** If I identifies one or more properties, then the result is a property group with an 
                 '   associated instance expression of E.
                 If Helper.IsPropertyDeclaration(first) Then
                     m_First = m_First.GetObjectReference
                     Classification = New PropertyGroupClassification(Me, m_First, members)
                     Return True
                 End If
 
                 If members.Count > 1 Then Throw New InternalException(Me)
 
                 '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
                 '   and the reference occurs outside a constructor of the class in which the variable is declared 
                 '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
                 '   variable I in the object referenced by E. 
                 '   If T is a reference type, then the result is the variable I in the object referenced by E. 
                 '   Otherwise, if T is a value type and the expression E is classified as a variable, the result is 
                 '   a variable; otherwise the result is a value.
                 Dim var As VariableDeclaration = TryCast(first, VariableDeclaration)
                 Dim fld As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
 
                 If var IsNot Nothing Then
                     Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
 
                     If var.Modifiers.Is(ModifierMasks.ReadOnly) AndAlso (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) <> var.Modifiers.Is(ModifierMasks.Shared)) Then
                         Classification = New ValueClassification(Me, var)
                         Return True
                     ElseIf CecilHelper.IsClass(T) Then
                         Classification = New VariableClassification(Me, var)
                         Return True
                     ElseIf CecilHelper.IsValueType(T) Then
                         If m_First.Classification.IsVariableClassification Then
                             Classification = New VariableClassification(Me, var)
                             Return True
                         ElseIf m_First.Classification.IsValueClassification Then
                             Classification = New ValueClassification(Me, var)
                             Return True
                         Else
                             Throw New InternalException(Me)
                         End If
                     Else
                         Throw New InternalException(Me)
                     End If
                 ElseIf fld IsNot Nothing Then
                     Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(fld)
                     If Helper.IsAccessible(Me, fD.Attributes, fld.DeclaringType, Me.FindFirstParent_IType.CecilType) = False Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30390, Location, fld.DeclaringType.FullName, fld.Name, Helper.ToString(fD.Attributes))
                     End If
 
                     Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
                     If fD.IsInitOnly AndAlso (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) <> fD.IsStatic) Then
                         If fD.IsStatic Then
                             Classification = New ValueClassification(Me, fld, Nothing)
                         Else
                             Classification = New ValueClassification(Me, fld, m_First)
                         End If
                         Return True
                     ElseIf CecilHelper.IsClass(T) Then
                         If fD.IsStatic Then
                             Classification = New VariableClassification(Me, fld, Nothing)
                         Else
                             Classification = New VariableClassification(Me, fld, m_First)
                         End If
                         Return True
                     ElseIf CecilHelper.IsValueType(T) Then
                         If m_First.Classification.IsVariableClassification Then
                             If Not TypeOf m_First Is InstanceExpression Then
                                 m_First = m_First.GetObjectReference
                             End If
                             If fD.IsStatic Then
                                 Classification = New VariableClassification(Me, fld, Nothing)
                             Else
                                 Classification = New VariableClassification(Me, fld, m_First)
                             End If
                             Return True
                         ElseIf m_First.Classification.IsValueClassification Then
                             If fD.IsStatic Then
                                 Classification = New ValueClassification(Me, fld, Nothing)
                             Else
                                 Classification = New ValueClassification(Me, fld, m_First)
                             End If
                             Return True
                         ElseIf m_First.Classification.CanBeValueClassification Then
                             m_First = m_First.ReclassifyToValueExpression
                             result = m_First.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
                             If fD.IsStatic Then
                                 Classification = New ValueClassification(Me, fld, Nothing)
                             Else
                                 Classification = New ValueClassification(Me, fld, m_First)
                             End If
                             Return True
                         Else
                             Throw New InternalException(Me)
                         End If
                     Else
                         Throw New InternalException(Me)
                     End If
                 End If
 
                 '** If I identifies an event, the result is an event access with an associated instance expression of E.
                 If Helper.IsEventDeclaration(first) Then
                     Dim red As EventDeclaration = TryCast(first, EventDeclaration)
                     If red Is Nothing AndAlso TypeOf first Is Mono.Cecil.EventReference Then
                         red = DirectCast(CecilHelper.FindDefinition(DirectCast(first, Mono.Cecil.EventReference)).Annotations(Compiler), EventDeclaration)
                     End If
                     If red IsNot Nothing Then
                         Classification = New EventAccessClassification(Me, red.EventDescriptor, m_First)
                         Return True
                     End If
                     Dim eInfo As Mono.Cecil.EventReference = TryCast(first, Mono.Cecil.EventReference)
                     If eInfo IsNot Nothing Then
                         Classification = New EventAccessClassification(Me, eInfo, m_First)
                         Return True
                     End If
                 End If
 
                 '** If I identifies a constant, then the result is the value of that constant.
                 Dim constant As ConstantDeclaration = TryCast(first, ConstantDeclaration)
                 If constant IsNot Nothing Then
                     Classification = New ValueClassification(Me, constant)
                     Return True
                 End If
 
                 '** If I identifies an enumeration member, then the result is the value of that enumeration member.
                 If Helper.IsEnumFieldDeclaration(Compiler, first) Then
                     Dim em As EnumMemberDeclaration = TryCast(first, EnumMemberDeclaration)
                     Dim emfld As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
                     If em IsNot Nothing Then
                         Classification = New ValueClassification(Me, em)
                         Return True
                     ElseIf emfld IsNot Nothing Then
                         Classification = New ValueClassification(Me, emfld, Nothing)
                         Return True
                     End If
                 End If
 
                 '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
                 '   with an associated instance expression of E.
                 If T IsNot Nothing Then
                     'Dim td As TypeDescriptor = TryCast(T, TypeDescriptor)
                     Dim compresult As Boolean = Helper.CompareType(T, Compiler.TypeCache.System_Object)
                     If compresult Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 End If
                 '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
                 Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName)
                 result = False
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName)
                 result = False
             End If
         End If
 
         Compiler.Report.ShowMessage(Messages.VBNC30456, Location, Name, m_First.AsString)
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="178" endline="300">
<![CDATA[
 
     Private Function ResolveInternal() As Boolean
         Log("There are " & CandidatesLeft & " candidates left.")
 
         m_IsLateBound = False
 
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, "No candidates
         End If
 
         RemoveInaccessible()
         Log("After removing inaccessible candidates, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             If m_InitialCandidates.Length = 1 Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC30390, Parent.Location, m_InitialCandidates(0).Member.DeclaringType.Name, m_InitialCandidates(0).Member.Name, Helper.GetMethodAccessibilityString(Helper.GetMethodAttributes(m_InitialCandidates(0).Member)))
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC30517, Parent.Location, m_InitialCandidates(0).Member.Name)
             End If
         End If
 
         ExpandParamArrays()
         Log("After expanding paramarrays, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Throw New InternalException("Expanding paramarrays resulted in fewer candidates
         End If
 
         RemoveInapplicable()
         Log("After removing inapplicable candidates, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             If m_InitialCandidates.Length = 1 Then
                 Dim argsGiven, argsRequired As Integer
                 Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
                 params = Helper.GetParameters(Compiler, m_InitialCandidates(0).Member)
                 argsRequired = params.Count
                 argsGiven = m_Arguments.Length
                 If argsGiven >= argsRequired Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30057, Parent.Location, m_InitialCandidates(0).ToString())
                 Else
                     For i As Integer = argsGiven To argsRequired - 1
                         Compiler.Report.ShowMessage(Messages.VBNC30455, Parent.Location, params(i).Name, m_InitialCandidates(0).ToString())
                     Next
                     Return False
                 End If
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC30516, Parent.Location, MethodName)
             End If
         End If
 
         InferTypeArguments()
         Log("After inferring type arguments, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 0 Then
             'Type infer code shows the error message if it's supposed to show errors
             Return False
         End If
 
         If CandidatesLeft <= 1 Then Return CandidatesLeft = 1
 
         RemoveNarrowingExceptObject()
         Log("After removing narrowing (except object) candidates, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, String.Format("After removing narrowing (except object) candidates for method '{0}', nothing was found", Me.m_InitialCandidates(0).Member.Name))
             Helper.AddError(Me.m_Parent, String.Format("Tried to select using invocation list
             Dim reported As Integer = 0
             For i As Integer = 0 To m_InitialCandidates.Length - 1
                 reported += 1
                 Dim mi As Mono.Cecil.MemberReference = m_InitialCandidates(i).Member
                 Helper.AddError(Me.m_Parent, String.Format("Candidate #{0}
             Next
         End If
 
         If CandidatesLeft <= 1 Then Return CandidatesLeft = 1
 
         RemoveNarrowing()
         Log("After removing narrowing candidates, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 1 Then
             Return True
         ElseIf CandidatesLeft = 0 Then
             If Parent.Location.File(Compiler).IsOptionStrictOn = False Then
                 m_IsLateBound = True
                 Return True
             End If
         End If
 
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, "No non-narrowing
         End If
 
         SelectMostApplicable()
         Log("After selecting the most applicable candidates, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, "No most applicable
         End If
 
         If CandidatesLeft = 1 Then
             Return True
         End If
 
         SelectLessGeneric()
         Log("After selecting the less generic candidates, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 1 Then
             Return True
         End If
 
         RemoveInvalid()
 
         If ShowErrors AndAlso CandidatesLeft <> 1 Then
             If CandidatesLeft > 1 Then
                 Helper.AddError(Me.m_Parent, String.Format("After selecting the less generic method for method '{0}', there are still {1} candidates left", Me.m_InitialCandidates(0).Member.Name, CandidatesLeft))
                 Helper.AddError(Me.m_Parent, String.Format("Tried to select using invocation list
                 Dim reported As Integer = 0
                 For i As Integer = 0 To m_Candidates.Count - 1
                     If m_Candidates(i) Is Nothing Then Continue For
                     reported += 1
                     Dim mi As Mono.Cecil.MemberReference = m_InitialCandidates(i).Member
                     Helper.AddError(Me.m_Parent, String.Format("Candidate #{0}
                 Next
             Else
                 Helper.AddError(Me.m_Parent, String.Format("After selecting the less generic method for method '{0}', nothing was found", Me.m_InitialCandidates(0).Member.Name))
             End If
         End If
 
         Return CandidatesLeft = 1
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1871" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="55" endline="92">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Target.Classification.IsVariableClassification OrElse m_Target.Classification.IsPropertyAccessClassification)
         Helper.Assert(m_Start.Classification.CanBeValueClassification)
         Helper.Assert(m_Length Is Nothing OrElse m_Length.Classification.CanBeValueClassification)
         Helper.Assert(m_Source.Classification.CanBeValueClassification)
 
         Dim tmpLocal As Mono.Cecil.Cil.VariableDefinition = Nothing
         If m_Target.Classification.IsPropertyAccessClassification Then
             tmpLocal = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_String, "MidTmp" & ObjectID.ToString)
             result = m_Target.GenerateCode(Info.Clone(Me, True, False, tmpLocal.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, tmpLocal)
             Emitter.EmitLoadVariableLocation(Info, tmpLocal)
         Else
             result = m_Target.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_String_ByRef)) AndAlso result
         End If
 
         result = m_Start.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
         Emitter.EmitConversion(m_Start.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         If m_Length IsNot Nothing Then
             result = m_Length.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
             Emitter.EmitConversion(m_Length.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         Else
             Emitter.EmitLoadI4Value(Info, Integer.MaxValue)
         End If
         result = m_Source.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_String)) AndAlso result
         Emitter.EmitConversion(m_Source.ExpressionType, Compiler.TypeCache.System_String, Info)
 
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_StringType__MidStmtStr_String_Int32_Int32_String)
 
         If m_Target.Classification.IsPropertyAccessClassification Then
             result = m_Target.GenerateCode(Info.Clone(Me, New LoadLocalExpression(Me, tmpLocal))) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" startline="77" endline="145">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LSide.ResolveExpression(Info) AndAlso result
         result = m_RSide.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If TypeOf m_LSide Is InstanceExpression Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30062, Location) AndAlso result
         End If
 
         If RSide.Classification.IsValueClassification Then
             'do nothing
         ElseIf RSide.Classification.IsMethodPointerClassification Then
             ''result = RSide.ResolveAddressOfExpression(m_LSide.ExpressionType) AndAlso result
             'If result Then
             m_RSide = m_RSide.ReclassifyMethodPointerToValueExpression(m_LSide.ExpressionType)
             result = m_RSide.ResolveExpression(Info) AndAlso result
             'End If
         ElseIf RSide.Classification.CanBeValueClassification Then
             RSide = RSide.ReclassifyToValueExpression()
             result = RSide.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             If result AndAlso RSide.Classification.IsPropertyGroupClassification Then
                 RSide = RSide.ReclassifyToPropertyAccessExpression
                 result = RSide.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             End If
         Else
             Helper.ShowClassificationError(Compiler, RSide.Location, RSide.Classification, "expression")
             result = False
         End If
 
         If result = False Then Return result
 
         If LSide.Classification.IsVariableClassification OrElse LSide.Classification.IsPropertyAccessClassification Then
             'do nothing
         ElseIf LSide.Classification.CanBePropertyAccessClassification Then
             m_LSide = LSide.ReclassifyToPropertyAccessExpression
             result = LSide.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             If result = False Then
                 result = Helper.AddError(Me) AndAlso result
                 Return result
             End If
         Else
             Helper.ShowClassificationError(Compiler, LSide.Location, LSide.Classification, "expression")
             result = False
         End If
 
         If result = False Then Return result
 
         If CecilHelper.IsGenericType(m_LSide.ExpressionType) AndAlso Helper.CompareType(Compiler.TypeCache.System_Nullable1, CecilHelper.GetGenericTypeDefinition(m_LSide.ExpressionType)) Then
             Dim lTypeArg As Mono.Collections.Generic.Collection(Of Mono.Cecil.TypeReference)
             lTypeArg = CecilHelper.GetGenericArguments(m_LSide.ExpressionType)
             If lTypeArg.Count = 1 AndAlso Helper.CompareType(lTypeArg(0), m_RSide.ExpressionType) Then
                 Dim objCreation As DelegateOrObjectCreationExpression
                 objCreation = New DelegateOrObjectCreationExpression(Me)
                 objCreation.Init(m_LSide.ExpressionType, New ArgumentList(objCreation, m_RSide))
                 result = objCreation.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                 m_RSide = objCreation
             End If
         End If
 
         If result = False Then Return result
 
         result = CreateTypeConversion() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1872" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1170" endline="1214">
<![CDATA[
 
     Public Shared Function ConvertToInt16(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "Short"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CShort(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0S
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1215" endline="1259">
<![CDATA[
 
     Public Shared Function ConvertToInt32(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "Integer"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CInt(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0I
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1873" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1469" endline="1548">
<![CDATA[
 
 		//
 		// Invoked if we know we have .digits or digits
 		//
 		int is_number (int c)
 		{
 			bool is_real = false;
 
 			number_pos = 0;
 
 			if (c >= '0' && c <= '9'){
 				if (c == '0'){
 					int peek = peek_char ();
 
 					if (peek == 'x' || peek == 'X')
 						return handle_hex ();
 				}
 				decimal_digits (c);
 				c = get_char ();
 			}
 
 			//
 			// We need to handle the case of
 			// "1.1" vs "1.string" (LITERAL_FLOAT vs NUMBER DOT IDENTIFIER)
 			//
 			if (c == '.'){
 				if (decimal_digits ('.')){
 					is_real = true;
 					c = get_char ();
 				} else {
 					putback ('.');
 					number_pos--;
 					return adjust_int (-1);
 				}
 			}
 			
 			if (c == 'e' || c == 'E'){
 				is_real = true;
 				if (number_pos == max_number_size)
 					Error_NumericConstantTooLong ();
 				number_builder [number_pos++] = 'e';
 				c = get_char ();
 				
 				if (c == '+'){
 					if (number_pos == max_number_size)
 						Error_NumericConstantTooLong ();
 					number_builder [number_pos++] = '+';
 					c = -1;
 				} else if (c == '-') {
 					if (number_pos == max_number_size)
 						Error_NumericConstantTooLong ();
 					number_builder [number_pos++] = '-';
 					c = -1;
 				} else {
 					if (number_pos == max_number_size)
 						Error_NumericConstantTooLong ();
 					number_builder [number_pos++] = '+';
 				}
 					
 				decimal_digits (c);
 				c = get_char ();
 			}
 
 			var type = real_type_suffix (c);
 			if (type == TypeCode.Empty && !is_real){
 				putback (c);
 				return adjust_int (c);
 			}
 
 			is_real = true;
 
 			if (type == TypeCode.Empty){
 				putback (c);
 			}
 			
 			if (is_real)
 				return adjust_real (type);
 
 			throw new Exception ("Is Number should never reach this point");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="858" endline="983">
<![CDATA[
 
 		//
 		// Constraints have to match by using same set of types, used by
 		// implicit interface implementation
 		//
 		public bool HasSameConstraintsImplementation (TypeParameterSpec other)
 		{
 			if (spec != other.spec)
 				return false;
 
 			//
 			// It can be same base type or inflated type parameter
 			//
 			// interface I<T> { void Foo<U> where U 
 			// class A 
 			//
 			bool found;
 			if (!TypeSpecComparer.Override.IsEqual (BaseType, other.BaseType)) {
 				if (other.targs == null)
 					return false;
 
 				found = false;
 				foreach (var otarg in other.targs) {
 					if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 						found = true;
 						break;
 					}
 				}
 				foreach (var otarg in other.targs) {
 					if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 						found = true;
 						break;
 					}
 				}
 
 				if (!found)
 					return false;
 			}
 
 			// Check interfaces implementation -> definition
 			if (InterfacesDefined != null) {
 				foreach (var iface in InterfacesDefined) {
 					found = false;
 					if (other.InterfacesDefined != null) {
 						foreach (var oiface in other.InterfacesDefined) {
 							if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 								found = true;
 								break;
 							}
 						}
 						foreach (var oiface in other.InterfacesDefined) {
 							if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (found)
 						continue;
 
 					if (other.targs != null) {
 						foreach (var otarg in other.targs) {
 							if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 								found = true;
 								break;
 							}
 						}
 						foreach (var otarg in other.targs) {
 							if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 				foreach (var iface in InterfacesDefined) {
 					found = false;
 					if (other.InterfacesDefined != null) {
 						foreach (var oiface in other.InterfacesDefined) {
 							if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (found)
 						continue;
 
 					if (other.targs != null) {
 						foreach (var otarg in other.targs) {
 							if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check interfaces implementation <- definition
 			if (other.InterfacesDefined != null) {
 				if (InterfacesDefined == null)
 					return false;
 
 				foreach (var oiface in other.InterfacesDefined) {
 					found = false;
 					foreach (var iface in InterfacesDefined) {
 						if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 							found = true;
 							break;
 						}
 					}
 					foreach (var iface in InterfacesDefined) {
 						if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 				foreach (var oiface in other.InterfacesDefined) {
 					found = false;
 					foreach (var iface in InterfacesDefined) {
 						if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check type parameters implementation -> definition
 			if (targs != null) {
 				if (other.targs == null)
 					return false;
 
 				foreach (var targ in targs) {
 					found = false;
 					foreach (var otarg in other.targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 					foreach (var otarg in other.targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 				foreach (var targ in targs) {
 					found = false;
 					foreach (var otarg in other.targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check type parameters implementation <- definition
 			if (other.targs != null) {
 				foreach (var otarg in other.targs) {
 					// Ignore inflated type arguments, were checked above
 					if (!otarg.IsGenericParameter)
 						continue;
 
 					if (targs == null)
 						return false;
 
 					found = false;
 					foreach (var targ in targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 					foreach (var targ in targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}				
 				foreach (var otarg in other.targs) {
 					// Ignore inflated type arguments, were checked above
 					if (!otarg.IsGenericParameter)
 						continue;
 
 					if (targs == null)
 						return false;
 
 					found = false;
 					foreach (var targ in targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}				
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1874" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1469" endline="1548">
<![CDATA[
 
 		//
 		// Invoked if we know we have .digits or digits
 		//
 		int is_number (int c)
 		{
 			bool is_real = false;
 
 			number_pos = 0;
 
 			if (c >= '0' && c <= '9'){
 				if (c == '0'){
 					int peek = peek_char ();
 
 					if (peek == 'x' || peek == 'X')
 						return handle_hex ();
 				}
 				decimal_digits (c);
 				c = get_char ();
 			}
 
 			//
 			// We need to handle the case of
 			// "1.1" vs "1.string" (LITERAL_FLOAT vs NUMBER DOT IDENTIFIER)
 			//
 			if (c == '.'){
 				if (decimal_digits ('.')){
 					is_real = true;
 					c = get_char ();
 				} else {
 					putback ('.');
 					number_pos--;
 					return adjust_int (-1);
 				}
 			}
 			
 			if (c == 'e' || c == 'E'){
 				is_real = true;
 				if (number_pos == max_number_size)
 					Error_NumericConstantTooLong ();
 				number_builder [number_pos++] = 'e';
 				c = get_char ();
 				
 				if (c == '+'){
 					if (number_pos == max_number_size)
 						Error_NumericConstantTooLong ();
 					number_builder [number_pos++] = '+';
 					c = -1;
 				} else if (c == '-') {
 					if (number_pos == max_number_size)
 						Error_NumericConstantTooLong ();
 					number_builder [number_pos++] = '-';
 					c = -1;
 				} else {
 					if (number_pos == max_number_size)
 						Error_NumericConstantTooLong ();
 					number_builder [number_pos++] = '+';
 				}
 					
 				decimal_digits (c);
 				c = get_char ();
 			}
 
 			var type = real_type_suffix (c);
 			if (type == TypeCode.Empty && !is_real){
 				putback (c);
 				return adjust_int (c);
 			}
 
 			is_real = true;
 
 			if (type == TypeCode.Empty){
 				putback (c);
 			}
 			
 			if (is_real)
 				return adjust_real (type);
 
 			throw new Exception ("Is Number should never reach this point");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="493" endline="609">
<![CDATA[
 
 		//
 		// Returns null when the property is not valid C# property
 		//
 		public PropertySpec CreateProperty (PropertyInfo pi, TypeSpec declaringType, MethodSpec get, MethodSpec set)
 		{
 			Modifiers mod = 0;
 			AParametersCollection param = null;
 			TypeSpec type = null;
 			if (get != null) {
 				mod = get.Modifiers;
 				param = get.Parameters;
 				type = get.ReturnType;
 			}
 
 			bool is_valid_property = true;
 			if (set != null) {
 				if (set.ReturnType != TypeManager.void_type)
 					is_valid_property = false;
 
 				var set_param_count = set.Parameters.Count - 1;
 
 				if (set_param_count < 0) {
 					set_param_count = 0;
 					is_valid_property = false;
 				}
 
 				var set_type = set.Parameters.Types[set_param_count];
 
 				if (mod == 0) {
 					AParametersCollection set_based_param;
 
 					if (set_param_count == 0) {
 						set_based_param = ParametersCompiled.EmptyReadOnlyParameters;
 					} else {
 						//
 						// Create indexer parameters based on setter method parameters (the last parameter has to be removed)
 						//
 						var data = new IParameterData[set_param_count];
 						var types = new TypeSpec[set_param_count];
 						Array.Copy (set.Parameters.FixedParameters, data, set_param_count);
 						Array.Copy (set.Parameters.Types, types, set_param_count);
 						set_based_param = new ParametersImported (data, types, set.Parameters.HasParams);
 					}
 
 					mod = set.Modifiers;
 					param = set_based_param;
 					type = set_type;
 				} else {
 					if (set_param_count != get.Parameters.Count)
 						is_valid_property = false;
 
 					if (get.ReturnType != set_type)
 						is_valid_property = false;
 
 					// Possible custom accessor modifiers
 					if ((mod & Modifiers.AccessibilityMask) != (set.Modifiers & Modifiers.AccessibilityMask)) {
 						var get_acc = mod & Modifiers.AccessibilityMask;
 						if (get_acc != Modifiers.PUBLIC) {
 							var set_acc = set.Modifiers & Modifiers.AccessibilityMask;
 							// If the accessor modifiers are not same, do extra restriction checks
 							if (get_acc != set_acc) {
 								var get_restr = ModifiersExtensions.IsRestrictedModifier (get_acc, set_acc);
 								var set_restr = ModifiersExtensions.IsRestrictedModifier (set_acc, get_acc);
 								if (get_restr && set_restr) {
 									is_valid_property = false; // Neither is more restrictive
 								}
 
 								if (get_restr) {
 									mod &= ~Modifiers.AccessibilityMask;
 									mod |= set_acc;
 								}
 							}
 						}
 					}
 				}
 			}
 
 			PropertySpec spec = null;
 			if (!param.IsEmpty) {
 				var index_name = declaringType.MemberDefinition.GetAttributeDefaultMember ();
 				if (index_name == null) {
 					is_valid_property = false;
 				} else {
 					if (get != null) {
 						if (get.IsStatic)
 							is_valid_property = false;
 						if (get.Name.IndexOf (index_name, StringComparison.Ordinal) != 4)
 							is_valid_property = false;
 					}
 					if (set != null) {
 						if (set.IsStatic)
 							is_valid_property = false;
 						if (set.Name.IndexOf (index_name, StringComparison.Ordinal) != 4)
 							is_valid_property = false;
 					}
 				}
 
 				if (is_valid_property)
 					spec = new IndexerSpec (declaringType, new ImportedParameterMemberDefinition (pi, type, param, this), type, param, pi, mod);
 			}
 
 			if (spec == null)
 				spec = new PropertySpec (MemberKind.Property, declaringType, new ImportedMemberDefinition (pi, type, this), type, pi, mod);
 
 			if (!is_valid_property) {
 				spec.IsNotRealProperty = true;
 				return spec;
 			}
 
 			if (set != null)
 				spec.Set = set;
 			if (get != null)
 				spec.Get = get;
 
 			return spec;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1875" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="896" endline="944">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1451" endline="1503">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value > Byte.MaxValue)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context && Value > ((ulong) SByte.MaxValue))
 					throw new OverflowException ();
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context && Value > ((ulong) Int16.MaxValue))
 					throw new OverflowException ();
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value > UInt16.MaxValue)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if  (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context && Value > Int64.MaxValue)
 					throw new OverflowException ();
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value > Char.MaxValue)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1876" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="896" endline="944">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1189" endline="1247">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1877" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="896" endline="944">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1312" endline="1378">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < Int32.MinValue || Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue || Value > UInt32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1878" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="561" endline="611">
<![CDATA[
 
     Shared Function GetBinaryResultType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatResultType(op1, op2)
             Case KS.GE
                 Return GetGEResultType(op1, op2)
             Case KS.GT
                 Return GetGTResultType(op1, op2)
             Case KS.LE
                 Return GetLEResultType(op1, op2)
             Case KS.LT
                 Return GetLTResultType(op1, op2)
             Case KS.Equals
                 Return GetEqualsResultType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsResultType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeResultType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotResultType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="724" endline="774">
<![CDATA[
 
     Private Shared Function GetBinaryOperandType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatOperandType(op1, op2)
             Case KS.GE
                 Return GetGEOperandType(op1, op2)
             Case KS.GT
                 Return GetGTOperandType(op1, op2)
             Case KS.LE
                 Return GetLEOperandType(op1, op2)
             Case KS.LT
                 Return GetLTOperandType(op1, op2)
             Case KS.Equals
                 Return GetEqualsOperandType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsOperandType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeOperandType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotOperandType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1879" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="778" endline="831">
<![CDATA[
 		}		
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1008" endline="1069">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1880" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="778" endline="831">
<![CDATA[
 		}		
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1676" endline="1749">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (double) char.MinValue || Value > (double) char.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1881" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="75" endline="136">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) <> CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) <> CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) <> CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 End If
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetNotEqualsOperandType(clvalue, crvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) <> CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) <> CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) <> CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) <> CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) <> CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) <> CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) <> CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) <> CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) <> CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) <> CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) <> CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\EqualsExpression.vb" startline="80" endline="144">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) = CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) = CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) = CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) = CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) = CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) = CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) = CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) = CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) = CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) = CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) = CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) = CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) = CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) = CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) = CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) = CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1882" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="75" endline="136">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) <> CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) <> CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) <> CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 End If
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetNotEqualsOperandType(clvalue, crvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) <> CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) <> CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) <> CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) <> CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) <> CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) <> CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) <> CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) <> CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) <> CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) <> CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) <> CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" startline="78" endline="142">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) >= CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) >= CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) >= CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) >= CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) >= CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) >= CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) >= CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) >= CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) >= CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) >= CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) >= CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) >= CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) >= CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) >= CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) >= CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) >= CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1883" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" startline="75" endline="136">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) <> CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) <> CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) <> CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 End If
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetNotEqualsOperandType(clvalue, crvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) <> CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) <> CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) <> CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) <> CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) <> CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) <> CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) <> CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) <> CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) <> CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) <> CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) <> CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" startline="84" endline="148">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) <= CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) <= CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) <= CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <= CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <= CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) <= CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) <= CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) <= CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) <= CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) <= CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) <= CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) <= CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) <= CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) <= CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) <= CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) <= CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1884" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" startline="77" endline="165">
<![CDATA[
 
     ''' <summary>
     ''' Creates an object array (always).
     ''' - initializes it with the arguments (if any). 
     ''' - adds the rhs expression (if supplied).
     ''' Leaves a reference to the object array on the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="LateBoundAccess"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Shared Function EmitArguments(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification, ByRef arguments As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
 
         Dim argCount As Integer
         Dim elementCount As Integer
         Dim args As ArgumentList
 
         Dim namedCount As Integer
 
         args = LateBoundAccess.Arguments
         If args IsNot Nothing Then argCount = args.Count
 
         elementCount = argCount
         If Info.RHSExpression IsNot Nothing Then elementCount += 1
 
         arguments = Emitter.DeclareLocal(Info, Info.Compiler.TypeCache.System_Object_Array)
 
         Emitter.EmitLoadI4Value(Info, elementCount)
         Emitter.EmitNewArr(Info, Info.Compiler.TypeCache.System_Object)
 
         Emitter.EmitStoreVariable(Info, arguments)
 
         For i As Integer = 0 To argCount - 1
             Dim arg As Argument = args.Arguments(i)
             If TypeOf arg Is NamedArgument Then namedCount += 1
             Emitter.EmitLoadVariable(Info, arguments)
             Emitter.EmitLoadI4Value(Info, i)
             If arg.Expression Is Nothing Then
                 Emitter.EmitLoadVariable(Info, Info.Compiler.TypeCache.System_Reflection_Missing__Value)
             Else
                 result = arg.GenerateCode(Info.Clone(Info.Context, True, False, arg.Expression.ExpressionType)) AndAlso result
                 If CecilHelper.IsValueType(arg.Expression.ExpressionType) Then
                     Emitter.EmitBox(Info, arg.Expression.ExpressionType)
                 End If
             End If
             Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_Object, Info.Compiler.TypeCache.System_Object_Array)
         Next
 
         If elementCount <> argCount Then
             Emitter.EmitLoadVariable(Info, arguments)
             Emitter.EmitLoadI4Value(Info, elementCount - 1)
             result = Info.RHSExpression.GenerateCode(Info.Clone(Info.Context, True, False, Info.RHSExpression.ExpressionType)) AndAlso result
             If CecilHelper.IsValueType(Info.RHSExpression.ExpressionType) Then
                 Emitter.EmitBox(Info, Info.RHSExpression.ExpressionType)
             End If
             Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_Object, Info.Compiler.TypeCache.System_Object_Array)
         End If
 
         Emitter.EmitLoadVariable(Info, arguments)
 
         If namedCount > 0 Then
             Dim namedArguments As Mono.Cecil.Cil.VariableDefinition
             namedArguments = Emitter.DeclareLocal(Info, Info.Compiler.TypeCache.System_String_Array)
             Emitter.EmitLoadI4Value(Info, namedCount)
             Emitter.EmitNewArr(Info, Info.Compiler.TypeCache.System_String)
             Emitter.EmitStoreVariable(Info, namedArguments)
 
             Dim iNamed As Integer
             For i As Integer = 0 To argCount - 1
                 Dim arg As NamedArgument = TryCast(args.Arguments(i), NamedArgument)
                 If arg Is Nothing Then Continue For
 
                 Emitter.EmitLoadVariable(Info, namedArguments)
                 Emitter.EmitLoadI4Value(Info, iNamed)
                 Emitter.EmitLoadValue(Info, arg.Name)
                 Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_String, Info.Compiler.TypeCache.System_String_Array)
 
                 iNamed += 1
             Next
 
             Emitter.EmitLoadVariable(Info, namedArguments)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_String_Array))
         End If
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" startline="295" endline="407">
<![CDATA[
 
     Private Function GenerateUnstructuredEnd(ByVal Method As IMethod, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim retvar As Mono.Cecil.Cil.VariableDefinition = Method.DefaultReturnVariable
 
         'Add a label to the end of the code as the last item in the switch.
 
         If retvar IsNot Nothing Then
             Emitter.EmitLeave(Info, Me.EndMethodLabel)
         Else
             Emitter.EmitLeave(Info, Me.EndMethodLabel)
         End If
 
         Me.UnstructuredExceptionLabels.Add(UnstructuredSwitchHandlerEnd)
 
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Int32)
         If Me.HasResume Then
             'Increment the instruction pointer index with one, then jump to the switch
             Emitter.MarkLabel(Info, ResumeNextExceptionHandler)
             Emitter.EmitLoadI4Value(Info, -1)
             Emitter.EmitStoreVariable(Info, VB_ResumeTarget)
             Emitter.EmitLoadVariable(Info, VB_CurrentInstruction)
             Emitter.EmitLoadI4Value(Info, 1)
             Emitter.EmitAdd(Info, Compiler.TypeCache.System_Int32)
             Emitter.EmitStoreVariable(Info, tmpVar)
             Emitter.EmitLeave(Info, UnstructuredResumeHandler)
         End If
 
         'Emit the actual handler 
         Emitter.MarkLabel(Info, UnstructuredResumeNextHandler)
         Emitter.EmitLoadI4Value(Info, -1)
         Emitter.EmitStoreVariable(Info, VB_ActiveHandler)
         Emitter.EmitLoadVariable(Info, VB_ResumeTarget)
         Emitter.EmitStoreVariable(Info, tmpVar)
         Emitter.MarkLabel(Info, UnstructuredResumeHandler)
         Emitter.EmitLoadI4Value(Info, 0)
         Emitter.EmitStoreVariable(Info, VB_ResumeTarget)
         Emitter.EmitLoadVariable(Info, tmpVar)
         Emitter.EmitSwitch(Info, UnstructuredExceptionLabels.ToArray)
 
         Emitter.MarkLabel(Info, UnstructuredSwitchHandlerEnd)
         Emitter.EmitLeave(Info, EndMethodLabel)
 
         'Emit the handler selector
         Dim handlers() As Label = UnstructuredExceptionHandlers.ToArray
         Dim endHandlers As Label = Emitter.DefineLabel(Info)
         Dim removedLabel As Label = handlers(0)
         handlers(0) = endHandlers
         Emitter.MarkLabel(Info, VB_ActiveHandlerLabel)
 
         If VB_CurrentInstruction IsNot Nothing Then
             Emitter.EmitLoadVariable(Info, VB_CurrentInstruction)
             Emitter.EmitStoreVariable(Info, VB_ResumeTarget)
         End If
         Emitter.EmitLoadVariable(Info, VB_ActiveHandler)
         Emitter.EmitSwitch(Info, handlers)
         Emitter.EmitLeave(Info, EndMethodLabel)
         Emitter.MarkLabel(Info, endHandlers)
         Emitter.EmitLeave(Info, removedLabel)
 
         'Catch the exception
 
         'create a filter, only handle the exception if it is of type Exception, 
         'if it was not raised when in the unstructured handler and if there actually
         'is a registered exception handler.
         Info.ILGen.BeginExceptFilterBlock()
         Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_Exception)
         Emitter.EmitLoadNull(Info.Clone(Me, True, False, Compiler.TypeCache.System_Exception))
         Emitter.EmitGT_Un(Info, Compiler.TypeCache.System_Exception) 'TypeOf ... Is System.Exception
 
         Emitter.EmitLoadVariable(Info, Me.VB_ActiveHandler)
         Emitter.EmitLoadI4Value(Info, 0)
         Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32) 'if a handler is registered.
         Emitter.EmitAnd(Info, Compiler.TypeCache.System_Boolean)
 
         Emitter.EmitLoadVariable(Info, Me.VB_ResumeTarget)
         Emitter.EmitLoadI4Value(Info, 0)
         Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32) 'if code is in a unstructured handler or not
         Emitter.EmitAnd(Info, Compiler.TypeCache.System_Boolean)
 
         'create the catch block
         Info.ILGen.BeginCatchBlock(CType(Nothing, Mono.Cecil.TypeReference))
         Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_Exception)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__SetProjectError_Exception)
         Emitter.EmitLeave(Info, VB_ActiveHandlerLabel)
 
         Info.ILGen.EndExceptionBlock()
 
         'Create an internal exception if the code gets here.
         Emitter.MarkLabel(Info, m_InternalExceptionLocation)
         Emitter.EmitLoadI4Value(Info, -2146828237)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Emitter.MarkLabel(Info, EndMethodLabel)
 
         Dim veryMethodEnd As Label = Emitter.DefineLabel(Info)
         Emitter.EmitLoadVariable(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean), VB_ResumeTarget)
         Emitter.EmitBranchIfFalse(Info, veryMethodEnd)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
         Emitter.MarkLabel(Info, veryMethodEnd)
 
         If retvar IsNot Nothing Then
             Emitter.MarkLabel(Info, m_EndOfMethodLabel.Value)
             Emitter.EmitLoadVariable(Info, retvar)
             Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Ret)
         Else
             Emitter.MarkLabel(Info, m_EndOfMethodLabel.Value)
             Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Ret)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1885" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1137" endline="1225">
<![CDATA[
 
 		bool DefineBaseTypes ()
 		{
 			iface_exprs = ResolveBaseTypes (out base_type_expr);
 			if (partial_parts != null) {
 				iface_exprs = GetNormalPartialBases ();
 			}
 
 			var cycle = CheckRecursiveDefinition (this);
 			if (cycle != null) {
 				Report.SymbolRelatedToPreviousError (cycle);
 				if (this is Interface) {
 					Report.Error (529, Location,
 						"Inherited interface `{0}' causes a cycle in the interface hierarchy of `{1}'",
 					    GetSignatureForError (), cycle.GetSignatureForError ());
 
 					iface_exprs = null;
 				} else {
 					Report.Error (146, Location,
 						"Circular base class dependency involving `{0}' and `{1}'",
 						GetSignatureForError (), cycle.GetSignatureForError ());
 
 					base_type = null;
 				}
 			}
 
 			if (iface_exprs != null) {
 				foreach (TypeExpr iface in iface_exprs) {
 					// Prevents a crash, the interface might not have been resolved
 					if (iface == null)
 						continue;
 					
 					var iface_type = iface.Type;
 
 					if (!spec.AddInterface (iface_type))
 						continue;
 
 					if (iface_type.IsGeneric && spec.Interfaces != null) {
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 					}
 
 					TypeBuilder.AddInterfaceImplementation (iface_type.GetMetaInfo ());
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null) {
 						// TODO
 						compiled_iface.DefineType ();
 					}
 
 					if (iface_type.Interfaces != null) {
 						var base_ifaces = new List<TypeSpec> (iface_type.Interfaces);
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 					}
 				}
 				foreach (TypeExpr iface in iface_exprs) {
 					// Prevents a crash, the interface might not have been resolved
 					if (iface == null)
 						continue;
 					
 					var iface_type = iface.Type;
 
 					if (!spec.AddInterface (iface_type))
 						continue;
 
 					if (iface_type.IsGeneric && spec.Interfaces != null) {
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 					}
 
 					TypeBuilder.AddInterfaceImplementation (iface_type.GetMetaInfo ());
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null) {
 						// TODO
 						compiled_iface.DefineType ();
 					}
 
 					if (iface_type.Interfaces != null) {
 						var base_ifaces = new List<TypeSpec> (iface_type.Interfaces);
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 					}
 				}
 			}
 
 			if (Kind == MemberKind.Interface) {
 				spec.BaseType = TypeManager.object_type;
 				return true;
 			}
 
 			if (base_type != null) {
 				spec.BaseType = base_type;
 
 				// Set base type after type creation
 				TypeBuilder.SetParent (base_type.GetMetaInfo ());
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2346" endline="2484">
<![CDATA[
 		
 		public override bool Define ()
 		{
 			const Modifiers RequiredModifiers = Modifiers.PUBLIC | Modifiers.STATIC;
 			if ((ModFlags & RequiredModifiers) != RequiredModifiers){
 				Report.Error (558, Location, "User-defined operator `{0}' must be declared static and public", GetSignatureForError ());
 			}
 
 			if (!base.Define ())
 				return false;
 
 			if (block != null && block.IsIterator) {
 				//
 				// Current method is turned into automatically generated
 				// wrapper which creates an instance of iterator
 				//
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 				ModFlags |= Modifiers.DEBUGGER_HIDDEN;
 			}
 
 			// imlicit and explicit operator of same types are not allowed
 			if (OperatorType == OpType.Explicit)
 				Parent.MemberCache.CheckExistingMembersOverloads (this, GetMetadataName (OpType.Implicit), parameters);
 			else if (OperatorType == OpType.Implicit)
 				Parent.MemberCache.CheckExistingMembersOverloads (this, GetMetadataName (OpType.Explicit), parameters);
 
 			TypeSpec declaring_type = Parent.CurrentType;
 			TypeSpec return_type = MemberType;
 			TypeSpec first_arg_type = ParameterTypes [0];
 			
 			TypeSpec first_arg_type_unwrap = first_arg_type;
 			if (TypeManager.IsNullableType (first_arg_type))
 				first_arg_type_unwrap = TypeManager.GetTypeArguments (first_arg_type) [0];
 			
 			TypeSpec return_type_unwrap = return_type;
 			if (TypeManager.IsNullableType (return_type))
 				return_type_unwrap = TypeManager.GetTypeArguments (return_type) [0];
 
 			//
 			// Rules for conversion operators
 			//
 			if (OperatorType == OpType.Implicit || OperatorType == OpType.Explicit) {
 				if (first_arg_type_unwrap == return_type_unwrap && first_arg_type_unwrap == declaring_type) {
 					Report.Error (555, Location,
 						"User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type");
 					return false;
 				}
 
 				TypeSpec conv_type;
 				if (declaring_type == return_type || declaring_type == return_type_unwrap) {
 					conv_type = first_arg_type;
 				} else if (declaring_type == first_arg_type || declaring_type == first_arg_type_unwrap) {
 					conv_type = return_type;
 				} else {
 					Report.Error (556, Location,
 						"User-defined conversion must convert to or from the enclosing type");
 					return false;
 				}
 
 				if (conv_type == InternalType.Dynamic) {
 					Report.Error (1964, Location,
 						"User-defined conversion `{0}' cannot convert to or from the dynamic type",
 						GetSignatureForError ());
 
 					return false;
 				}
 
 				if (conv_type.IsInterface) {
 					Report.Error (552, Location, "User-defined conversion `{0}' cannot convert to or from an interface type",
 						GetSignatureForError ());
 					return false;
 				}
 
 				if (conv_type.IsClass) {
 					if (TypeSpec.IsBaseClass (declaring_type, conv_type, true)) {
 						Report.Error (553, Location, "User-defined conversion `{0}' cannot convert to or from a base class",
 							GetSignatureForError ());
 						return false;
 					}
 
 					if (TypeSpec.IsBaseClass (conv_type, declaring_type, false)) {
 						Report.Error (554, Location, "User-defined conversion `{0}' cannot convert to or from a derived class",
 							GetSignatureForError ());
 						return false;
 					}
 				}
 			} else if (OperatorType == OpType.LeftShift || OperatorType == OpType.RightShift) {
 				if (first_arg_type != declaring_type || parameters.Types[1] != TypeManager.int32_type) {
 					Report.Error (564, Location, "Overloaded shift operator must have the type of the first operand be the containing type, and the type of the second operand must be int");
 					return false;
 				}
 			} else if (parameters.Count == 1) {
 				// Checks for Unary operators
 
 				if (OperatorType == OpType.Increment || OperatorType == OpType.Decrement) {
 					if (return_type != declaring_type && !TypeSpec.IsBaseClass (return_type, declaring_type, false)) {
 						Report.Error (448, Location,
 							"The return type for ++ or -- operator must be the containing type or derived from the containing type");
 						return false;
 					}
 					if (first_arg_type != declaring_type) {
 						Report.Error (
 							559, Location, "The parameter type for ++ or -- operator must be the containing type");
 						return false;
 					}
 				}
 
 				if (first_arg_type_unwrap != declaring_type) {
 					Report.Error (562, Location,
 						"The parameter type of a unary operator must be the containing type");
 					return false;
 				}
 
 				if (OperatorType == OpType.True || OperatorType == OpType.False) {
 					if (return_type != TypeManager.bool_type) {
 						Report.Error (
 							215, Location,
 							"The return type of operator True or False " +
 							"must be bool");
 						return false;
 					}
 				}
 
 			} else if (first_arg_type_unwrap != declaring_type) {
 				// Checks for Binary operators
 
 				var second_arg_type = ParameterTypes[1];
 				if (TypeManager.IsNullableType (second_arg_type))
 					second_arg_type = TypeManager.GetTypeArguments (second_arg_type)[0];
 
 				if (second_arg_type != declaring_type) {
 					Report.Error (563, Location,
 						"One of the parameters of a binary operator must be the containing type");
 					return false;
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1886" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RealDivisionExpression.vb" startline="62" endline="132">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetRealDivResultType(clvalue, crvalue)
 
                 If CDbl(rvalue) = 0 Then
                     Helper.AddError(Me, "Divide by zero")
                     Return Double.NaN
                 End If
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) / CByte(rvalue)
                     Case TypeCode.SByte
                         If CSByte(lvalue) = SByte.MinValue AndAlso CSByte(rvalue) = -1 Then
                             Return CShort(lvalue) / CShort(rvalue)
                         Else
                             Return CSByte(lvalue) / CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         If CShort(lvalue) = Short.MinValue AndAlso CShort(rvalue) = -1 Then
                             Return CInt(lvalue) / CInt(rvalue)
                         Else
                             Return CShort(lvalue) / CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) / CUShort(rvalue)
                     Case TypeCode.Int32
                         If CInt(lvalue) = Integer.MinValue AndAlso CInt(rvalue) = -1 Then
                             Return CLng(lvalue) / CLng(rvalue)
                         Else
                             Return CInt(lvalue) / CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) / CUInt(rvalue)
                     Case TypeCode.Int64
                         If CLng(lvalue) = Long.MinValue AndAlso CLng(rvalue) = -1 Then
                             Return CDec(lvalue) / CDec(rvalue)
                         Else
                             Return CLng(lvalue) / CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         Return CULng(lvalue) / CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) / CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) / CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) / CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" startline="64" endline="156">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim lvalue, rvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing OrElse rvalue Is Nothing Then
                 Return Nothing
             Else
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, tlvalue, trvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Dim tmp As UShort = CUShort(lvalue) * CUShort(rvalue)
                         If tmp < Byte.MinValue OrElse tmp > Byte.MaxValue Then
                             Return tmp
                         Else
                             Return CByte(lvalue) * CByte(rvalue)
                         End If
                     Case TypeCode.SByte
                         Dim tmp As Short = CShort(lvalue) * CShort(rvalue)
                         If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                             Return tmp
                         Else
                             Return CSByte(lvalue) * CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         Dim tmp As Integer = CInt(lvalue) * CInt(rvalue)
                         If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                             Return tmp
                         Else
                             Return CShort(lvalue) * CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Dim tmp As UInteger = CUInt(lvalue) * CUInt(rvalue)
                         If tmp > UShort.MaxValue Then
                             Return tmp
                         Else
                             Return CUShort(lvalue) * CUShort(rvalue)
                         End If
                     Case TypeCode.Int32
                         Dim tmp As Long = CLng(lvalue) * CLng(rvalue)
                         If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                             Return tmp
                         Else
                             Return CInt(lvalue) * CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Dim tmp As ULong = CULng(lvalue) * CULng(rvalue)
                         If tmp > UInteger.MaxValue Then
                             Return tmp
                         Else
                             Return CUInt(lvalue) * CUInt(rvalue)
                         End If
                     Case TypeCode.Int64
                         Dim tmp As Double
                         If CLng(rvalue) < 0 Then
                             tmp = Long.MaxValue / -CLng(rvalue)
                         Else
                             tmp = Long.MaxValue / CLng(rvalue)
                         End If
                         If CLng(lvalue) < 0 AndAlso -CLng(lvalue) > tmp OrElse CLng(lvalue) > tmp Then
                             Return CDec(lvalue) * CDec(rvalue)
                         Else
                             Return CLng(lvalue) * CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         If CULng(lvalue) > ULong.MaxValue / CULng(rvalue) Then
                             Return CDec(lvalue) * CDec(rvalue)
                         Else
                             Return CULng(lvalue) * CULng(rvalue)
                         End If
                     Case TypeCode.Double
                         Return CDbl(lvalue) * CDbl(rvalue) 'No overflow possible
                     Case TypeCode.Single
                         Return CSng(lvalue) * CSng(rvalue) 'No overflow possible
                     Case TypeCode.Decimal
                         Return CDec(lvalue) * CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1887" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1512" endline="1600">
<![CDATA[
 
 		//
 		// Emits the code
 		//
 		public override void Emit ()
 		{
 			if (Parent.PartialContainer.IsComImport) {
 				if (!IsDefault ()) {
 					Report.Error (669, Location, "`{0}'
 						Parent.GetSignatureForError ());
 				}
 
 				// Set as internal implementation and reset block data
 				// to ensure no IL is generated
 				ConstructorBuilder.SetImplementationFlags (MethodImplAttributes.InternalCall);
 				block = null;
 			}
 
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (ConstructorBuilder);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			base.Emit ();
 
 			//
 			// If we use a "this (...)" constructor initializer, then
 			// do not emit field initializers, they are initialized in the other constructor
 			//
 			bool emit_field_initializers = ((ModFlags & Modifiers.STATIC) != 0) ||
 				!(Initializer is ConstructorThisInitializer);
 
 			BlockContext bc = new BlockContext (this, block, TypeManager.void_type);
 			bc.Set (ResolveContext.Options.ConstructorScope);
 
 			if (emit_field_initializers)
 				Parent.PartialContainer.ResolveFieldInitializers (bc);
 
 			if (block != null) {
 				// If this is a non-static `struct' constructor and doesn't have any
 				// initializer, it must initialize all of the struct's fields.
 				if ((Parent.PartialContainer.Kind == MemberKind.Struct) &&
 					((ModFlags & Modifiers.STATIC) == 0) && (Initializer == null))
 					block.AddThisVariable (bc, Parent, Location);
 
 				if (block != null && (ModFlags & Modifiers.STATIC) == 0){
 					if (Parent.PartialContainer.Kind == MemberKind.Class && Initializer == null)
 						Initializer = new GeneratedBaseInitializer (Location);
 
 					if (Initializer != null) {
 						block.AddScopeStatement (new StatementExpression (Initializer));
 					}
 				}
 			}
 
 			parameters.ApplyAttributes (this, ConstructorBuilder);
 
 			SourceMethod source = SourceMethod.Create (Parent, ConstructorBuilder, block);
 
 			if (block != null) {
 				if (block.Resolve (null, bc, this)) {
 					EmitContext ec = new EmitContext (this, ConstructorBuilder.GetILGenerator (), bc.ReturnType);
 					ec.With (EmitContext.Options.ConstructorScope, true);
 
 					if (!ec.HasReturnLabel && bc.HasReturnLabel) {
 						ec.ReturnLabel = bc.ReturnLabel;
 						ec.HasReturnLabel = true;
 					}
 
 					block.Emit (ec);
 				}
 			}
 
 			if (source != null)
 				source.CloseMethod ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					ConstructorBuilder.__AddDeclarativeSecurity (de);
 #else
 					ConstructorBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					ConstructorBuilder.__AddDeclarativeSecurity (de);
 #else
 					ConstructorBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			block = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="182" endline="350">
<![CDATA[
 
 		public void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Type == pa.AssemblyCulture) {
 				string value = a.GetString ();
 				if (value == null || value.Length == 0)
 					return;
 
 				if (RootContext.Target == Target.Exe) {
 					a.Error_AttributeEmitError ("The executables cannot be satelite assemblies, remove the attribute or keep it empty");
 					return;
 				}
 
 				if (value == "neutral")
 					value = "";
 
 				if (RootContext.Target == Target.Module) {
 					SetCustomAttribute (ctor, cdata);
 				} else {
 					builder_extra.SetCulture (value, a.Location);
 				}
 
 				return;
 			}
 
 			if (a.Type == pa.AssemblyVersion) {
 				string value = a.GetString ();
 				if (value == null || value.Length == 0)
 					return;
 
 				var vinfo = IsValidAssemblyVersion (value, true);
 				if (vinfo == null) {
 					a.Error_AttributeEmitError (string.Format ("Specified version `{0}' is not valid", value));
 					return;
 				}
 
 				if (RootContext.Target == Target.Module) {
 					SetCustomAttribute (ctor, cdata);
 				} else {
 					builder_extra.SetVersion (vinfo, a.Location);
 				}
 
 				return;
 			}
 
 			if (a.Type == pa.AssemblyAlgorithmId) {
 				const int pos = 2; // skip CA header
 				uint alg = (uint) cdata [pos];
 				alg |= ((uint) cdata [pos + 1]) << 8;
 				alg |= ((uint) cdata [pos + 2]) << 16;
 				alg |= ((uint) cdata [pos + 3]) << 24;
 
 				if (RootContext.Target == Target.Module) {
 					SetCustomAttribute (ctor, cdata);
 				} else {
 					builder_extra.SetAlgorithmId (alg, a.Location);
 				}
 
 				return;
 			}
 
 			if (a.Type == pa.AssemblyFlags) {
 				const int pos = 2; // skip CA header
 				uint flags = (uint) cdata[pos];
 				flags |= ((uint) cdata [pos + 1]) << 8;
 				flags |= ((uint) cdata [pos + 2]) << 16;
 				flags |= ((uint) cdata [pos + 3]) << 24;
 
 				// Ignore set PublicKey flag if assembly is not strongnamed
 				if ((flags & (uint) AssemblyNameFlags.PublicKey) != 0 && public_key == null)
 					flags &= ~(uint) AssemblyNameFlags.PublicKey;
 
 				if (RootContext.Target == Target.Module) {
 					SetCustomAttribute (ctor, cdata);
 				} else {
 					builder_extra.SetFlags (flags, a.Location);
 				}
 
 				return;
 			}
 
 			if (a.Type == pa.TypeForwarder) {
 				TypeSpec t = a.GetArgumentType ();
 				if (t == null || TypeManager.HasElementType (t)) {
 					Report.Error (735, a.Location, "Invalid type specified as an argument for TypeForwardedTo attribute");
 					return;
 				}
 
 				if (emitted_forwarders == null) {
 					emitted_forwarders = new Dictionary<ITypeDefinition, Attribute> ();
 				} else if (emitted_forwarders.ContainsKey (t.MemberDefinition)) {
 					Report.SymbolRelatedToPreviousError (emitted_forwarders[t.MemberDefinition].Location, null);
 					Report.Error (739, a.Location, "A duplicate type forward of type `{0}'",
 						TypeManager.CSharpName (t));
 					return;
 				}
 
 				emitted_forwarders.Add (t.MemberDefinition, a);
 
 				if (t.MemberDefinition.DeclaringAssembly == this) {
 					Report.SymbolRelatedToPreviousError (t);
 					Report.Error (729, a.Location, "Cannot forward type `{0}' because it is defined in this assembly",
 						TypeManager.CSharpName (t));
 					return;
 				}
 
 				if (t.IsNested) {
 					Report.Error (730, a.Location, "Cannot forward type `{0}' because it is a nested type",
 						TypeManager.CSharpName (t));
 					return;
 				}
 
 				builder_extra.AddTypeForwarder (t.GetDefinition (), a.Location);
 				return;
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			if (a.Type == pa.InternalsVisibleTo) {
 				string assembly_name = a.GetString ();
 				if (assembly_name.Length == 0)
 					return;
 
 				AssemblyName aname = null;
 				try {
 					aname = new AssemblyName (assembly_name);
 				} catch (Exception) {
 					Report.Warning (1700, 3, a.Location, "Assembly reference `{0}' is invalid and cannot be resolved",
 						assembly_name);
 					return;
 				}
 
 				if (aname.Version != null || aname.CultureInfo != null || aname.ProcessorArchitecture != ProcessorArchitecture.None) {
 					Report.Error (1725, a.Location,
 						"Friend assembly reference `{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture or processor architecture specified",
 						assembly_name);
 
 					return;
 				}
 
 				// TODO
 				if (public_key != null && aname.GetPublicKey () == null) {
 					Report.Error (1726, a.Location,
 						"Friend assembly reference `{0}' is invalid. Strong named assemblies must specify a public key in their InternalsVisibleTo declarations",
 						assembly_name);
 					return;
 				}
 			} else if (a.Type == pa.RuntimeCompatibility) {
 				wrap_non_exception_throws_custom = true;
 			} else if (a.Type == pa.AssemblyFileVersion) {
 				string value = a.GetString ();
 				if (string.IsNullOrEmpty (value) || IsValidAssemblyVersion (value, false) == null) {
 					Report.Warning (1607, 1, a.Location, "The version number `{0}' specified for `{1}' is invalid",
 						value, a.Name);
 					return;
 				}
 			}
 
 
 			SetCustomAttribute (ctor, cdata);
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1888" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" startline="500" endline="579">
<![CDATA[
 
     Private Function ResolveMethodInvocation() As Boolean
         Dim result As Boolean = True
         Dim mgc As MethodGroupClassification = m_Expression.Classification.AsMethodGroupClassification
 
         'If the method group only contains one method and that method takes no arguments and is a function, 
         'then the method group is interpreted as an invocation expression 
         'with an empty argument list and the result is used as the target of an index expression.
 
         Dim reclassifyToIndex As Boolean
         If mgc.Group.Count = 1 AndAlso m_ArgumentList.Count > 0 Then
             Dim method As Mono.Cecil.MethodReference = TryCast(mgc.Group(0), Mono.Cecil.MethodReference)
 
             reclassifyToIndex = method IsNot Nothing
             reclassifyToIndex = reclassifyToIndex AndAlso method.ReturnType IsNot Nothing
             reclassifyToIndex = reclassifyToIndex AndAlso Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Void) = False
             reclassifyToIndex = reclassifyToIndex AndAlso Helper.GetParameters(Compiler, method).Count = 0
 
         End If
 
         If reclassifyToIndex Then
             Return ResolveReclassifyToValueThenIndex()
         Else
             result = mgc.ResolveGroup(m_ArgumentList)
             If result Then
                 If mgc.IsLateBound = False Then
                     m_ArgumentList.ReplaceAndVerifyArguments(mgc.FinalArguments, mgc.ResolvedMethod)
                 End If
                 result = mgc.VerifyConstraints AndAlso result
                 If result = False Then Return False
             Else
                 mgc.ResolveGroup(m_ArgumentList, True)
                 Return False
             End If
         End If
 
         Helper.StopIfDebugging(result = False)
 
         If mgc.IsLateBound Then
             Dim lba As LateBoundAccessClassification = New LateBoundAccessClassification(Me, mgc.InstanceExpression, Nothing, mgc.Resolver.MethodName)
             lba.LateBoundType = mgc.Resolver.MethodDeclaringType
             lba.Arguments = m_ArgumentList
             Classification = lba
         ElseIf mgc.ResolvedMethodInfo IsNot Nothing Then
             Dim methodInfo As Mono.Cecil.MethodReference = mgc.ResolvedMethodInfo
 
             If String.IsNullOrEmpty(Compiler.CommandLine.VBRuntime) AndAlso Compiler.Assembly.IsDefinedHere(methodInfo) AndAlso CecilHelper.FindDefinition(methodInfo).IsStatic AndAlso Helper.CompareName(methodInfo.Name, "AscW") Then
                 Dim methodParameters As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetParameters(Compiler, methodInfo)
 
                 If methodParameters.Count <> 0 AndAlso Helper.CompareType(methodParameters(0).ParameterType, Compiler.TypeCache.System_Char) Then
                     m_AscWExpression = ArgumentList(0).Expression
                     m_ExpressionType = Compiler.TypeCache.System_Int32
                     Classification = New ValueClassification(Me, m_ExpressionType)
 
                     Return result
                 End If
             End If
 
             If mgc.InstanceExpression Is Nothing AndAlso CecilHelper.IsStatic(methodInfo) = False Then
                 Dim mae As MemberAccessExpression = TryCast(m_Expression, MemberAccessExpression)
                 If mae IsNot Nothing AndAlso mae.FirstExpression.Classification.IsTypeClassification AndAlso mae.FirstExpression.Classification.AsTypeClassification.CanBeExpression Then
                     Dim exp As Expression = Nothing
                     result = mae.FirstExpression.Classification.AsTypeClassification.CreateAliasExpression(mae.FirstExpression, exp) AndAlso result
                     mgc.InstanceExpression = exp
                 End If
             End If
 
             If methodInfo.ReturnType Is Nothing OrElse Helper.CompareType(methodInfo.ReturnType, Compiler.TypeCache.System_Void) Then
                 Classification = New VoidClassification(Me)
             Else
                 Classification = New ValueClassification(Me, methodInfo.ReturnType)
             End If
         ElseIf mgc.ResolvedConstructor IsNot Nothing Then
             Classification = New VoidClassification(Me)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" startline="1108" endline="1240">
<![CDATA[
 
     ''' <summary>
     ''' Emits the instanceexpression (if any), the arguments (if any), the optional arguments (if any) and then calls the method (virt or not).
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="InstanceExpression"></param>
     ''' <param name="Arguments"></param>
     ''' <param name="Method"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitArgumentsAndCallOrCallVirt(ByVal Info As EmitInfo, ByVal InstanceExpression As Expression, ByVal Arguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
         Dim needsConstrained As Boolean
         Dim constrainedLocal As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         needsConstrained = InstanceExpression IsNot Nothing AndAlso CecilHelper.IsGenericParameter(InstanceExpression.ExpressionType)
 
         Helper.Assert(Method IsNot Nothing)
 
         If InstanceExpression IsNot Nothing AndAlso CecilHelper.FindDefinition(Method).IsStatic = False Then
             Dim ieDesiredType As Mono.Cecil.TypeReference
             Dim ieInfo As EmitInfo
 
             If needsConstrained Then
                 ieDesiredType = InstanceExpression.ExpressionType
             Else
                 ieDesiredType = Method.DeclaringType
                 If CecilHelper.IsValueType(ieDesiredType) Then
                     ieDesiredType = Info.Compiler.TypeManager.MakeByRefType(CType(Info.Method, ParsedObject), ieDesiredType)
                 End If
             End If
 
             ieInfo = Info.Clone(Info.Context, True, False, ieDesiredType)
 
             Dim derefExp As DeRefExpression = TryCast(InstanceExpression, DeRefExpression)
             If needsConstrained AndAlso derefExp IsNot Nothing Then
                 result = derefExp.Expression.GenerateCode(Info.Clone(Info.Context, True, False, derefExp.Expression.ExpressionType)) AndAlso result
             Else
                 Dim getRef As GetRefExpression = TryCast(InstanceExpression, GetRefExpression)
                 If getRef IsNot Nothing AndAlso CecilHelper.IsValueType(getRef.Expression.ExpressionType) AndAlso Helper.CompareType(Method.DeclaringType, Info.Compiler.TypeCache.System_Object) Then
                     result = getRef.Expression.GenerateCode(ieInfo) AndAlso result
                     Emitter.EmitBox(Info, getRef.Expression.ExpressionType)
                 Else
                     result = InstanceExpression.GenerateCode(ieInfo) AndAlso result
                 End If
 
                 If needsConstrained Then
                     constrainedLocal = Emitter.DeclareLocal(Info, InstanceExpression.ExpressionType)
                     Emitter.EmitStoreVariable(Info, constrainedLocal)
                     Emitter.EmitLoadVariableLocation(Info, constrainedLocal)
                 End If
             End If
 
         End If
 
         Dim copyBacksA As Generic.List(Of Mono.Cecil.Cil.VariableDefinition) = Nothing
         Dim copyBacksB As Generic.List(Of Expression) = Nothing
 
         If Arguments IsNot Nothing Then
             Dim methodParameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)
             methodParameters = Helper.GetParameters(Info.Compiler, Method)
 
             For i As Integer = 0 To methodParameters.Count - 1
                 Dim arg As Argument
                 Dim exp As Expression
                 Dim local As Mono.Cecil.Cil.VariableDefinition
                 Dim propAccess As PropertyAccessClassification
 
                 If CecilHelper.IsByRef(methodParameters(i).ParameterType) = False Then Continue For
 
                 arg = Arguments.Arguments(i)
                 exp = arg.Expression
 
                 If exp Is Nothing Then Continue For
 
                 If exp.Classification Is Nothing Then Continue For
                 If exp.Classification.IsPropertyAccessClassification = False Then Continue For
 
                 propAccess = exp.Classification.AsPropertyAccess
 
                 If copyBacksA Is Nothing Then
                     copyBacksA = New Generic.List(Of Mono.Cecil.Cil.VariableDefinition)
                     copyBacksB = New Generic.List(Of Expression)
                 End If
                 local = Emitter.DeclareLocal(Info, CecilHelper.GetElementType(methodParameters(i).ParameterType))
                 copyBacksA.Add(local)
                 If CecilHelper.FindDefinition(propAccess.Property).SetMethod Is Nothing Then
                     copyBacksB.Add(Nothing)
                 Else
                     copyBacksB.Add(exp)
                 End If
 
                 result = arg.GenerateCode(Info, methodParameters(i)) AndAlso result
                 Emitter.EmitStoreVariable(Info, local)
                 arg.Expression = New LoadLocalExpression(arg, local)
             Next
 
             result = Arguments.GenerateCode(Info, methodParameters) AndAlso result
         End If
 
         If needsConstrained Then
             Emitter.EmitConstrainedCallVirt(Info, Method, InstanceExpression.ExpressionType)
         ElseIf InstanceExpression IsNot Nothing AndAlso (TypeOf InstanceExpression Is MyClassExpression OrElse TypeOf InstanceExpression Is MyBaseExpression) Then
             Emitter.EmitCall(Info, Method)
         Else
             Emitter.EmitCallOrCallVirt(Info, Method)
         End If
 
         If copyBacksA IsNot Nothing Then
             For i As Integer = 0 To copyBacksA.Count - 1
                 Dim local As Mono.Cecil.Cil.VariableDefinition = copyBacksA(i)
                 Dim exp As Expression = copyBacksB(i)
 
                 If exp Is Nothing Then Continue For
 
                 result = exp.GenerateCode(Info.Clone(Info.Context, New LoadLocalExpression(exp, local))) AndAlso result
             Next
         End If
 
         If constrainedLocal IsNot Nothing Then
             Emitter.FreeLocal(constrainedLocal)
         End If
 
         If Info.DesiredType IsNot Nothing AndAlso CecilHelper.IsByRef(Info.DesiredType) Then
             Dim tmp As Mono.Cecil.Cil.VariableDefinition
             tmp = Emitter.DeclareLocal(Info, CecilHelper.GetElementType(Info.DesiredType))
             Emitter.EmitStoreVariable(Info, tmp)
             Emitter.EmitLoadVariableLocation(Info, tmp)
             Emitter.FreeLocal(tmp)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1889" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="93" endline="177">
<![CDATA[
 
     ''' <summary>
     ''' This function only verifies the expression type of the argument,
     ''' it does not expand paramarray arguments nor optional arguments
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function VerifyArguments(ByVal parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         Dim result As Boolean = True
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(Me.Location.ToString & "
 #End If
         For i As Integer = 0 To m_Arguments.Count - 1
             Dim exp As Expression
             Dim arg As Argument = m_Arguments(i)
             Dim par As Mono.Cecil.ParameterDefinition = parameters(i)
 
             If Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.DelegateUnresolvedType) Then
                 Dim aoe As AddressOfExpression = TryCast(arg.Expression, AddressOfExpression)
                 Dim delegateType As Mono.Cecil.TypeReference = par.ParameterType
 
                 Helper.Assert(aoe IsNot Nothing)
                 Helper.Assert(delegateType IsNot Nothing)
 
                 result = aoe.Resolve(delegateType) AndAlso result
 
                 Dim del As DelegateOrObjectCreationExpression
                 del = New DelegateOrObjectCreationExpression(Me)
                 del.Init(delegateType, New ArgumentList(del, aoe))
                 result = del.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
                 m_Arguments(i).Expression = del
             End If
 
             If CecilHelper.IsByRef(par.ParameterType) AndAlso CecilHelper.IsByRef(arg.Expression.ExpressionType) = False AndAlso CecilHelper.IsValueType(CecilHelper.GetElementType(par.ParameterType)) = False Then
                 If arg.Expression.Classification.IsPropertyAccessClassification Then
                     Dim propRef As PropertyReference = arg.Expression.Classification.AsPropertyAccess.Property
                     Dim propDef As PropertyDefinition = CecilHelper.FindDefinition(propRef)
                     If propDef.GetMethod Is Nothing Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC30524, m_Arguments(i).Location, propDef.Name)
                     End If
                     exp = arg.Expression
                 ElseIf Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.Nothing) = False Then
                     exp = New GetRefExpression(Me, arg.Expression)
                 Else
                     exp = arg.Expression
                 End If
             ElseIf CecilHelper.IsByRef(par.ParameterType) AndAlso CecilHelper.IsByRef(arg.Expression.ExpressionType) AndAlso Helper.CompareType(CecilHelper.GetElementType(par.ParameterType), CecilHelper.GetElementType(arg.Expression.ExpressionType)) Then
                 exp = arg.Expression
             ElseIf CecilHelper.IsByRef(par.ParameterType) AndAlso Helper.CompareType(arg.Expression.ExpressionType, CecilHelper.GetElementType(par.ParameterType)) = False AndAlso (arg.Expression.Classification.IsVariableClassification OrElse arg.Expression.Classification.IsPropertyAccessClassification) Then
                 Dim varTmp As LocalVariableDeclaration
                 Dim assignA, assignB As AssignmentStatement
                 Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
                 Dim thisStatement As Statement = Me.FindFirstParent(Of Statement)()
 
                 varTmp = New LocalVariableDeclaration(Me.Parent)
                 varTmp.Init(Nothing, "VB$tmp", CecilHelper.GetElementType(par.ParameterType))
                 'result = varTmp.ResolveMember(ResolveInfo.Default(Compiler)) AndAlso result
 
                 assignA = New AssignmentStatement(Me.Parent)
                 assignA.Init(New VariableExpression(assignA, varTmp), arg.Expression)
                 result = assignA.ResolveStatement(ResolveInfo.Default(Compiler)) AndAlso result
 
                 assignB = New AssignmentStatement(Me.Parent)
                 assignB.Init(arg.Expression, New VariableExpression(assignB, varTmp))
                 result = assignB.ResolveStatement(ResolveInfo.Default(Compiler)) AndAlso result
 
                 block.AddVariable(varTmp)
                 block.AddStatementBefore(assignA, thisStatement)
                 block.AddStatementAfter(assignB, thisStatement)
 
                 exp = New GetRefExpression(Me, New VariableExpression(Me, varTmp))
             Else
 #If EXTENDEDDEBUG Then
                 Compiler.Report.WriteLine("VerifyArguments, needs convertion from " & arg.Expression.ExpressionType.FullName & " to " & par.ParameterType.FullName)
 #End If
                 exp = Helper.CreateTypeConversion(arg, arg.Expression, par.ParameterType, result)
             End If
                 If exp IsNot arg.Expression Then
                     m_Arguments(i) = New PositionalArgument(Me, i, exp)
                 End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="1231" endline="1462">
<![CDATA[
 
     Function DefineApplicability() As Boolean
         Dim matchedParameters As Generic.List(Of Mono.Cecil.ParameterReference)
         Dim exactArguments As Generic.List(Of Argument)
         Dim method As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         Dim prop As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
 
         Dim isLastParamArray As Boolean
         Dim paramArrayExpression As ArrayCreationExpression = Nothing
         Dim inputParametersCount As Integer = InputParameters.Count
 
         isLastParamArray = m_IsParamArray
 
         '(if there are more arguments than parameters and the last parameter is not a 
         'paramarray parameter the method should not be applicable)
         If Arguments.Count > InputParameters.Count Then
             If InputParameters.Count < 1 Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
             If isLastParamArray = False Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
         End If
 
         matchedParameters = New Generic.List(Of Mono.Cecil.ParameterReference)
         exactArguments = New Generic.List(Of Argument)(Helper.CreateArray(Of Argument)(Nothing, inputParametersCount))
 
         ReDim m_TypesInInvokedOrder(Math.Max(Arguments.Count - 1, inputParametersCount - 1))
 
         If isLastParamArray Then
             Dim paramArrayArg As New PositionalArgument(Parent)
 
             Helper.Assert(paramArrayExpression Is Nothing)
             paramArrayExpression = New ArrayCreationExpression(paramArrayArg)
             paramArrayExpression.Init(ParamArrayParameter.ParameterType, New Expression() {})
 
             paramArrayArg.Init(ParamArrayParameter.Sequence, paramArrayExpression)
             exactArguments(inputParametersCount - 1) = paramArrayArg
 
             m_TypesInInvokedOrder(inputParametersCount - 1) = ParamArrayParameter.ParameterType
         End If
 
         Dim firstNamedArgument As Integer = Arguments.Count + 1
         For i As Integer = 0 To Arguments.Count - 1
             'First, match each positional argument in order to the list of method parameters. 
             'If there are more positional arguments than parameters and the last parameter 
             'is not a paramarray, the method is not applicable. Otherwise, the paramarray parameter 
             'is expanded with parameters of the paramarray element type to match the number
             'of positional arguments. If a positional argument is omitted, the method is not applicable.
             If Arguments(i).IsNamedArgument Then
                 firstNamedArgument = i
                 Exit For '(No more positional arguments)
             End If
 
             If inputParametersCount - 1 < i Then
                 '(more positional arguments than parameters)
                 If isLastParamArray = False Then '(last parameter is not a paramarray)
                     'LogResolutionMessage(Parent.Compiler, "N/A
                     Return False
                 End If
 
                 'Add the additional expressions to the param array creation expression.
                 Helper.Assert(paramArrayExpression.ArrayElementInitalizer.Initializers.Count = 1)
                 For j As Integer = i To Arguments.Count - 1
                     'A paramarray element has to be specified.
                     If Arguments(j).Expression Is Nothing Then
                         'LogResolutionMessage(Parent.Compiler, "N/A
                         Return False
                     End If
                     paramArrayExpression.ArrayElementInitalizer.AddInitializer(Arguments(j).Expression)
 
                     Helper.Assert(m_TypesInInvokedOrder(j) Is Nothing)
                     m_TypesInInvokedOrder(j) = CecilHelper.GetElementType(ParamArrayParameter.ParameterType)
                 Next
                 Exit For
             Else
                 matchedParameters.Add(InputParameters(i))
 
                 'Helper.Assert(m_TypesInInvokedOrder(i) Is Nothing)
                 m_TypesInInvokedOrder(i) = InputParameters(i).ParameterType
 
                 'Get the default value of the parameter if the specified argument has no expression.
                 Dim arg As Argument = Nothing
                 If Arguments(i).Expression Is Nothing Then
                     If InputParameters(i).IsOptional = False Then
                         Helper.Assert(False)
                     Else
                         Dim exp As Expression
                         Dim pArg As New PositionalArgument(Parent)
                         exp = Helper.GetOptionalValueExpression(pArg, InputParameters(i))
                         pArg.Init(InputParameters(i).Sequence, exp)
                         arg = pArg
                     End If
                 Else
                     arg = Arguments(i)
                 End If
 
                 If isLastParamArray = False Then exactArguments(i) = arg
                 If isLastParamArray AndAlso inputParametersCount - 1 = i Then
                     Helper.Assert(paramArrayExpression.ArrayElementInitalizer.Initializers.Count = 0)
                     paramArrayExpression.ArrayElementInitalizer.AddInitializer(arg.Expression)
                     'Helper.Assert(m_TypesInInvokedOrder(i) Is Nothing)
                     m_TypesInInvokedOrder(i) = CecilHelper.GetElementType(ParamArrayParameter.ParameterType)
                 Else
                     If isLastParamArray Then exactArguments(i) = arg
                 End If
             End If
             '??? If a positional argument is omitted, the method is not applicable.
         Next
 
 
         For i As Integer = firstNamedArgument To Arguments.Count - 1
             Helper.Assert(Arguments(i).IsNamedArgument)
 
             'Next, match each named argument to a parameter with the given name. 
             'If one of the named arguments fails to match, matches a paramarray parameter, 
             'or matches an argument already matched with another positional or named argument,
             'the method is not applicable.
 
             Dim namedArgument As NamedArgument = DirectCast(Arguments(i), NamedArgument)
 
             Dim matched As Boolean = False
             For j As Integer = 0 To inputParametersCount - 1
                 'Next, match each named argument to a parameter with the given name. 
                 Dim inputParam As Mono.Cecil.ParameterReference = InputParameters(j)
                 If Helper.CompareName(inputParam.Name, namedArgument.Name) Then
                     If matchedParameters.Contains(inputParam) Then
                         'If one of the named arguments (...) matches an argument already matched with 
                         'another positional or named argument, the method is not applicable
                         'LogResolutionMessage(Parent.Compiler, "N/A
                         Return False
                     ElseIf Helper.IsParamArrayParameter(Parent.Compiler, inputParam) Then
                         'If one of the named arguments (...) matches a paramarray parameter, 
                         '(...) the method is not applicable.
                         'LogResolutionMessage(Parent.Compiler, "N/A
                         Return False
                     Else
                         matchedParameters.Add(inputParam)
                         exactArguments(j) = Arguments(i)
 
                         Helper.Assert(m_TypesInInvokedOrder(j) Is Nothing)
                         m_TypesInInvokedOrder(j) = inputParam.ParameterType
                         matched = True
                         Exit For
                     End If
                 End If
             Next
             'If one of the named arguments fails to match (...) the method is not applicable
             If matched = False Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
         Next
 
         'Next, if parameters that have not been matched are not optional, 
         'the method is not applicable. If optional parameters remain, the default value 
         'specified in the optional parameter declaration is matched to the parameter. 
         'If an Object parameter does not specify a default value, then the expression 
         'System.Reflection.Missing.Value is used. If an optional Integer parameter 
         'has the Microsoft.VisualBasic.CompilerServices.OptionCompareAttribute attribute, 
         'then the literal 1 is supplied for text comparisons and the literal 0 otherwise.
 
         For i As Integer = 0 To inputParametersCount - 1
             If matchedParameters.Contains(InputParameters(i)) = False Then
                 'if parameters that have not been matched are not optional, the method is not applicable
                 If isLastParamArray = False AndAlso Helper.IsParamArrayParameter(Compiler, InputParameters(i)) Then
                     Return False
                 End If
                 If InputParameters(i).IsOptional = False AndAlso InputParameters(i) Is ParamArrayParameter = False Then
                     'LogResolutionMessage(Parent.Compiler, "N/A
                     Return False
                 End If
 
                 Dim exp As Expression
                 Dim arg As New PositionalArgument(Parent)
                 exp = Helper.GetOptionalValueExpression(arg, InputParameters(i))
                 arg.Init(InputParameters(i).Sequence, exp)
                 If isLastParamArray = False Then
                     Helper.Assert(m_TypesInInvokedOrder(i) Is Nothing)
                     m_TypesInInvokedOrder(i) = InputParameters(i).ParameterType
                     exactArguments(i) = arg
                 End If
                 If Helper.IsParamArrayParameter(Parent.Compiler, InputParameters(i)) = False Then
                     'he arraycreation has already been created and added to the exactArguments(1).
                     If isLastParamArray Then exactArguments(i) = arg
                 End If
             End If
         Next
 
         'Finally, if type arguments have been specified, they are matched against
         'the type parameter list. If the two lists do not have the same number of elements, 
         'the method is not applicable, unless the type argument list is empty. If the 
         'type argument list is empty, type inferencing is used to try and infer 
         'the type argument list. If type inferencing fails, the method is not applicable.
         'Otherwise, the type arguments are filled in the place of the 
         'type parameters in the signature.
         Dim genericTypeArgumentCount As Integer
         Dim genericTypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)
         If method IsNot Nothing AndAlso CecilHelper.IsGenericMethod(method) Then
             genericTypeArguments = CecilHelper.GetGenericArguments(method)
             genericTypeArgumentCount = genericTypeArguments.Count
         ElseIf prop IsNot Nothing Then
             'property cannot be generic.
         End If
 
         If genericTypeArgumentCount > 0 AndAlso (TypeArguments Is Nothing OrElse TypeArguments.List.Count = 0) Then
             'If the Then type argument list is empty, type inferencing is used to try and infer 
             'the type argument list.
             'Helper.NotImplementedYet("Type argument inference")
         ElseIf TypeArguments IsNot Nothing AndAlso TypeArguments.List.Count > 0 Then
             'If the two lists do not have the same number of elements, the method is not applicable
             If TypeArguments.List.Count <> genericTypeArgumentCount Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
 
             'Return m_Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Parent.Location)
             'Helper.NotImplemented("Type argument matching")
         End If
 
         m_ExactArguments = exactArguments
 
         Helper.AssertNotNothing(m_TypesInInvokedOrder)
 
         If ResolveUnresolvedExpressions() = False Then
             Return False
         End If
 
         Return True 'Method is applicable!!
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1890" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="93" endline="177">
<![CDATA[
 
     ''' <summary>
     ''' This function only verifies the expression type of the argument,
     ''' it does not expand paramarray arguments nor optional arguments
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function VerifyArguments(ByVal parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         Dim result As Boolean = True
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(Me.Location.ToString & "
 #End If
         For i As Integer = 0 To m_Arguments.Count - 1
             Dim exp As Expression
             Dim arg As Argument = m_Arguments(i)
             Dim par As Mono.Cecil.ParameterDefinition = parameters(i)
 
             If Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.DelegateUnresolvedType) Then
                 Dim aoe As AddressOfExpression = TryCast(arg.Expression, AddressOfExpression)
                 Dim delegateType As Mono.Cecil.TypeReference = par.ParameterType
 
                 Helper.Assert(aoe IsNot Nothing)
                 Helper.Assert(delegateType IsNot Nothing)
 
                 result = aoe.Resolve(delegateType) AndAlso result
 
                 Dim del As DelegateOrObjectCreationExpression
                 del = New DelegateOrObjectCreationExpression(Me)
                 del.Init(delegateType, New ArgumentList(del, aoe))
                 result = del.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
                 m_Arguments(i).Expression = del
             End If
 
             If CecilHelper.IsByRef(par.ParameterType) AndAlso CecilHelper.IsByRef(arg.Expression.ExpressionType) = False AndAlso CecilHelper.IsValueType(CecilHelper.GetElementType(par.ParameterType)) = False Then
                 If arg.Expression.Classification.IsPropertyAccessClassification Then
                     Dim propRef As PropertyReference = arg.Expression.Classification.AsPropertyAccess.Property
                     Dim propDef As PropertyDefinition = CecilHelper.FindDefinition(propRef)
                     If propDef.GetMethod Is Nothing Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC30524, m_Arguments(i).Location, propDef.Name)
                     End If
                     exp = arg.Expression
                 ElseIf Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.Nothing) = False Then
                     exp = New GetRefExpression(Me, arg.Expression)
                 Else
                     exp = arg.Expression
                 End If
             ElseIf CecilHelper.IsByRef(par.ParameterType) AndAlso CecilHelper.IsByRef(arg.Expression.ExpressionType) AndAlso Helper.CompareType(CecilHelper.GetElementType(par.ParameterType), CecilHelper.GetElementType(arg.Expression.ExpressionType)) Then
                 exp = arg.Expression
             ElseIf CecilHelper.IsByRef(par.ParameterType) AndAlso Helper.CompareType(arg.Expression.ExpressionType, CecilHelper.GetElementType(par.ParameterType)) = False AndAlso (arg.Expression.Classification.IsVariableClassification OrElse arg.Expression.Classification.IsPropertyAccessClassification) Then
                 Dim varTmp As LocalVariableDeclaration
                 Dim assignA, assignB As AssignmentStatement
                 Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
                 Dim thisStatement As Statement = Me.FindFirstParent(Of Statement)()
 
                 varTmp = New LocalVariableDeclaration(Me.Parent)
                 varTmp.Init(Nothing, "VB$tmp", CecilHelper.GetElementType(par.ParameterType))
                 'result = varTmp.ResolveMember(ResolveInfo.Default(Compiler)) AndAlso result
 
                 assignA = New AssignmentStatement(Me.Parent)
                 assignA.Init(New VariableExpression(assignA, varTmp), arg.Expression)
                 result = assignA.ResolveStatement(ResolveInfo.Default(Compiler)) AndAlso result
 
                 assignB = New AssignmentStatement(Me.Parent)
                 assignB.Init(arg.Expression, New VariableExpression(assignB, varTmp))
                 result = assignB.ResolveStatement(ResolveInfo.Default(Compiler)) AndAlso result
 
                 block.AddVariable(varTmp)
                 block.AddStatementBefore(assignA, thisStatement)
                 block.AddStatementAfter(assignB, thisStatement)
 
                 exp = New GetRefExpression(Me, New VariableExpression(Me, varTmp))
             Else
 #If EXTENDEDDEBUG Then
                 Compiler.Report.WriteLine("VerifyArguments, needs convertion from " & arg.Expression.ExpressionType.FullName & " to " & par.ParameterType.FullName)
 #End If
                 exp = Helper.CreateTypeConversion(arg, arg.Expression, par.ParameterType, result)
             End If
                 If exp IsNot arg.Expression Then
                     m_Arguments(i) = New PositionalArgument(Me, i, exp)
                 End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" startline="853" endline="1092">
<![CDATA[
 
     Function InferTypeArguments() As Boolean
         Dim GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim methodDef As MethodDefinition = TryCast(m_Member, MethodDefinition)
         Dim methodRef As MethodReference
 
         If methodDef Is Nothing Then
             methodRef = TryCast(m_Member, MethodReference)
             If methodRef IsNot Nothing Then
                 methodDef = CecilHelper.FindDefinition(methodRef)
             End If
         End If
 
         If methodDef IsNot Nothing Then
             If Not methodDef.HasGenericParameters Then Return True
             GenericParameters = methodDef.GenericParameters
         Else
             Return True
         End If
 
         If DefinedParameters.Count <> Arguments.Count Then
             If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location)
             Return False
         End If
 
         '* Generate a dependency graph *
         ' Given a set of arguments A1, A2, ?, AN, a set of matching parameters P1, P2, ?, PN and a set of method type parameters 
         ' T1, T2, ?, TN, the dependencies between the arguments and method type parameters are first collected as follows
 
         Dim A_deps() As Generic.List(Of GenericParameter) = Nothing
         Dim A_dep As Generic.List(Of GenericParameter)
 
         For i As Integer = 0 To Arguments.Count - 1
             Dim An As Argument = Arguments(i)
             Dim Pn As ParameterDefinition = m_DefinedParameters(i)
             Dim git As GenericInstanceType
             Dim gp As GenericParameter
 
             '?	If AN is the Nothing literal, no dependencies are generated.
             If TypeOf An.Expression Is NothingConstantExpression Then Continue For
 
             git = TryCast(Pn.ParameterType, GenericInstanceType)
             gp = TryCast(Pn.ParameterType, GenericParameter)
 
             '?	If AN is a lambda method and the type of PN is a constructed delegate type 
             '   or System.Linq.Expressions.Expression(Of T), where T is a constructed delegate type,
             '   ?	If the type of a lambda method parameter will be inferred from the type of the corresponding parameter PN, and the type of the parameter depends on a method type parameter TN, then AN has a dependency on TN.
             '   ?	If the type of a lambda method parameter is specified and the type of the corresponding parameter PN depends on a method type parameter TN, then TN has a dependency on AN.
             '   ?	If the return type of PN depends on a method type parameter TN, then TN has a dependency on AN.
             '* Lambda methods haven't been implemented yet *
 
             '?	If AN is a method pointer and the type of PN is a constructed delegate type,
             '   ?	If the return type of PN depends on a method type parameter TN, then TN has a dependency on AN.
             If An.Expression.Classification.IsMethodPointerClassification AndAlso Helper.IsDelegate(Compiler, Pn.ParameterType) AndAlso git IsNot Nothing Then
                 Dim invokeMethod As MethodReference = Helper.GetInvokeMethod(Compiler, Pn.ParameterType)
                 A_dep = Nothing
                 CollectGenericParameters(TryCast(invokeMethod.ReturnType, GenericInstanceType), GenericParameters, A_dep)
                 If A_dep IsNot Nothing Then
                     If A_deps Is Nothing Then ReDim A_deps(Arguments.Count - 1)
                     A_deps(i) = A_dep
                 End If
                 Continue For
             End If
 
             '?	If PN is a constructed type and the type of PN depends on a method type parameter TN, then TN has a dependency on AN.
             If git IsNot Nothing Then
                 A_dep = Nothing
                 CollectGenericParameters(git, GenericParameters, A_dep)
                 If A_dep IsNot Nothing Then
                     If A_deps Is Nothing Then ReDim A_deps(Arguments.Count - 1)
                     A_deps(i) = A_dep
                 End If
                 Continue For
             ElseIf gp IsNot Nothing AndAlso GenericParameters.Contains(gp) Then
                 If A_deps Is Nothing Then ReDim A_deps(Arguments.Count - 1)
                 A_dep = New Generic.List(Of GenericParameter)
                 A_dep.Add(gp)
                 A_deps(i) = A_dep
                 Continue For
             End If
 
             '?	Otherwise, no dependency is generated.
         Next
 
         ' After collecting dependencies, any arguments that have no dependencies are eliminated.
         '* eliminated arguments are represented by null entries in the A_deps array
 
         ' If any method type parameters have no outgoing dependencies (i.e. the method type parameter does not depend on an argument), then type inference fails. 
         If A_deps Is Nothing Then
             If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC32050, Me.Parent.Location, GenericParameters(0).Name, Helper.ToString(Compiler, m_Member))
             Return False '* No dependencies at all
         End If
         For i As Integer = 0 To GenericParameters.Count - 1
             Dim found As Boolean = False
             For a As Integer = 0 To A_deps.Length - 1
                 If A_deps(a) Is Nothing Then Continue For
                 If A_deps(a).Contains(GenericParameters(i)) Then
                     found = True
                     Exit For
                 End If
             Next
             If Not found Then
                 If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC32050, Me.Parent.Location, GenericParameters(i).Name, Helper.ToString(Compiler, m_Member))
                 Return False '* GenericParameter(i) does not have a dependency
             End If
         Next
 
         Dim hints As TypeHints()
         ReDim hints(GenericParameters.Count - 1)
 
         ' Otherwise, the remaining arguments and method type parameters are grouped into strongly connected components.
         ' A strongly connected component is a set of arguments and method type parameters,
         ' where any element in the component is reachable via dependencies on other elements.
         ' The strongly connected components are then topologically sorted and processed in topological order
         '* Since we don't have lambda methods yet, we only have a tree of dependencies (method type parameters on arguments)
         '* We'll always have one element in each the stronly connected component, so just look over each argument and each method type parameter
 
         '?	If the strongly typed component contains only one element,
         '   ?	If the element has already been marked complete, skip it.
         '   ?	If the element is an argument, then add type hints from the argument to the method type parameters 
         '       that depend on it and mark the element as complete. If the argument is a lambda method with parameters 
         '       that still need inferred types, then infer Object for the types of those parameters.
         For i As Integer = 0 To A_deps.Length - 1
             Dim Ta As TypeReference
             Dim Tp As TypeReference
             If A_deps(i) Is Nothing Then Continue For
 
             Ta = Arguments(i).Expression.ExpressionType
             Tp = DefinedParameters(i).ParameterType
             For a As Integer = 0 To A_deps(i).Count - 1
                 Dim Tg As GenericParameter = A_deps(i)(a)
                 Dim aI As Integer = GenericParameters.IndexOf(Tg)
                 Dim hint As TypeHints = hints(aI)
 
                 If hints(aI) Is Nothing Then
                     hint = New TypeHints(Me)
                     hints(aI) = hint
                 End If
 
                 If hint.GenerateHint(GenericParameters, Ta, DefinedParameters(i)) = False Then
                     If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location)
                     Return False
                 End If
 
             Next
             '       If the argument is a lambda method with parameters 
             '       that still need inferred types, then infer Object for the types of those parameters.
             '* no lambda method support yet *
         Next
 
         '   ?	If the element is a method type parameter, then infer the method type parameter to be the dominant
         '       type among the argument type hints and mark the element as complete. If a type hint has an array element 
         '       restriction on it, then only conversions that are valid between arrays of the given type are considered 
         '       (i.e. covariant and intrinsic array conversions). If a type hint has a generic argument restriction on it, 
         '       then only identity conversions are considered. If no dominant type can be chosen, inference fails. 
         '       If any lambda method argument types depend on this method type parameter, the type is propagated to the lambda method.
         Dim m_InferredTypeArguments As New Mono.Collections.Generic.Collection(Of TypeReference)(GenericParameters.Count)
         For i As Integer = 0 To GenericParameters.Count - 1
             Dim hint As TypeHints = hints(i)
             Dim types As Generic.List(Of TypeReference)
             Dim dominantType As TypeReference
             Dim generic_argument_restriction As Boolean
             Dim array_element_restriction As Boolean
             types = New Generic.List(Of TypeReference)(hint.Hints.Count)
 
             For h As Integer = 0 To hint.Hints.Count - 1
                 Dim hi As TypeHint = hint.Hints(h)
                 If hi.GenericArgumentRestriction Then
                     generic_argument_restriction = True
                 ElseIf hi.ArrayElementRestriction Then
                     array_element_restriction = True
                 End If
 
                 Dim found As Boolean
                 For t As Integer = 0 To types.Count - 1
                     If Helper.CompareType(types(t), hi.Hint) Then
                         found = True
                         Exit For
                     End If
                 Next
                 If Not found Then types.Add(hi.Hint)
             Next
 
             If types.Count = 0 Then
                 If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location)
                 Return False
             End If
 
             If generic_argument_restriction Then
                 'all types must be identical
                 dominantType = types(0)
                 For t As Integer = 1 To types.Count - 1
                     If Helper.CompareType(types(t), dominantType) = False Then
                         If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC36657, Me.Parent.Location, Helper.ToString(Compiler, m_Member))
                         Return False
                     End If
                 Next
             ElseIf array_element_restriction Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location, "Type argument inference with array element restriction")
             Else
                 dominantType = Helper.GetDominantType(Compiler, types)
             End If
 
             If dominantType Is Nothing Then
                 If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC36651, Me.Parent.Location, Helper.ToString(Compiler, m_Member))
                 Return False
             End If
             m_InferredTypeArguments.Add(dominantType)
         Next
 
         '?	If the strongly typed component contains more than one element, then the component contains a cycle.
         '   ?	For each method type parameter that is an element in the component, if the method type parameter depends
         '       on an argument that is not marked complete, convert that dependency into an assertion that will be 
         '       checked at the end of the inference process.
         '   ?	Restart the inference process at the point at which the strongly typed components were determined.
         '* This can't happen until lambda methods have been implemented, since only lambda methods can have a dependency 
         '* from method type parameters to arguments, so until then this is just a tree of arguments to method type parameters, 
         '* not a cyclic graph *
 
         'If type inference succeeds for all of the method type parameters, then any dependencies that were changed 
         'into assertions are checked. An assertion succeeds if the type of the argument is implicitly convertible 
         'to the inferred type of the method type parameter. If an assertion fails, then type argument inference fails.
         '* no assertions are added until lambda support has been implemented, so nothing to do here for now *
 
         '* type inference succeeded, inflate our method *
         Dim inflated_method As MethodReference = CecilHelper.GetCorrectMember(methodDef, m_InferredTypeArguments)
         Dim gim As New GenericInstanceMethod(inflated_method)
         gim.GenericArguments.AddRange(m_InferredTypeArguments)
         m_Member = gim
         m_DefinedParameters = Nothing
         m_DefinedParametersTypes = Nothing
         m_TypesInInvokedOrder = Nothing
 
         If DefineApplicability() = False Then
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location, "Applicability changed after inferring type arguments")
         End If
 
         'The success of type inference does not, in and of itself, guarantee that the method is applicable.
         Return True
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1891" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4217" endline="4319">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			TypeSpec op_type = left.Type;
 			
 			// It must be either array or fixed buffer
 			TypeSpec element;
 			if (TypeManager.HasElementType (op_type)) {
 				element = TypeManager.GetElementType (op_type);
 			} else {
 				FieldExpr fe = left as FieldExpr;
 				if (fe != null)
 					element = ((FixedFieldSpec) (fe.Spec)).ElementType;
 				else
 					element = op_type;
 			}
 
 			int size = GetTypeSize (element);
 			TypeSpec rtype = right.Type;
 			
 			if ((op & Binary.Operator.SubtractionMask) != 0 && rtype.IsPointer){
 				//
 				// handle (pointer - pointer)
 				//
 				left.Emit (ec);
 				right.Emit (ec);
 				ec.Emit (OpCodes.Sub);
 
 				if (size != 1){
 					if (size == 0)
 						ec.Emit (OpCodes.Sizeof, element);
 					else 
 						ec.EmitInt (size);
 					ec.Emit (OpCodes.Div);
 				}
 				ec.Emit (OpCodes.Conv_I8);
 			} else {
 				//
 				// handle + and - on (pointer op int)
 				//
 				Constant left_const = left as Constant;
 				if (left_const != null) {
 					//
 					// Optimize ((T*)null) pointer operations
 					//
 					if (left_const.IsDefaultValue) {
 						left = EmptyExpression.Null;
 					} else {
 						left_const = null;
 					}
 				}
 
 				left.Emit (ec);
 
 				var right_const = right as Constant;
 				if (right_const != null) {
 					//
 					// Optimize 0-based arithmetic
 					//
 					if (right_const.IsDefaultValue)
 						return;
 
 					if (size != 0)
 						right = new IntConstant (size, right.Location);
 					else
 						right = new SizeOf (new TypeExpression (element, right.Location), right.Location);
 					
 					// TODO
 					ResolveContext rc = new ResolveContext (ec.MemberContext, ResolveContext.Options.UnsafeScope);
 					right = new Binary (Binary.Operator.Multiply, right, right_const, loc).Resolve (rc);
 					if (right == null)
 						return;
 				}
 
 				right.Emit (ec);
 				if (rtype == TypeManager.sbyte_type || rtype == TypeManager.byte_type ||
 					rtype == TypeManager.short_type || rtype == TypeManager.ushort_type) {
 					ec.Emit (OpCodes.Conv_I);
 				} else if (rtype == TypeManager.uint32_type) {
 					ec.Emit (OpCodes.Conv_U);
 				}
 
 				if (right_const == null && size != 1){
 					if (size == 0)
 						ec.Emit (OpCodes.Sizeof, element);
 					else 
 						ec.EmitInt (size);
 					if (rtype == TypeManager.int64_type || rtype == TypeManager.uint64_type)
 						ec.Emit (OpCodes.Conv_I8);
 
 					Binary.EmitOperatorOpcode (ec, Binary.Operator.Multiply, rtype);
 				}
 
 				if (left_const == null) {
 					if (rtype == TypeManager.int64_type)
 						ec.Emit (OpCodes.Conv_I);
 					else if (rtype == TypeManager.uint64_type)
 						ec.Emit (OpCodes.Conv_U);
 
 					Binary.EmitOperatorOpcode (ec, op, op_type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3640" endline="3800">
<![CDATA[
 
 		/// <remarks>
 		///   EmitBranchable is called from Statement.EmitBoolExpression in the
 		///   context of a conditional bool expression.  This function will return
 		///   false if it is was possible to use EmitBranchable, or true if it was.
 		///
 		///   The expression's code is generated, and we will generate a branch to `target'
 		///   if the resulting expression value is equal to isTrue
 		/// </remarks>
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			//
 			// This is more complicated than it looks, but its just to avoid
 			// duplicated tests
 			// but on top of that we want for == and != to use a special path
 			// if we are comparing against null
 			//
 			if ((oper & Operator.EqualityMask) != 0 && (left is Constant || right is Constant)) {
 				bool my_on_true = oper == Operator.Inequality ? on_true 
 				
 				//
 				// put the constant on the rhs, for simplicity
 				//
 				if (left is Constant) {
 					Expression swap = right;
 					right = left;
 					left = swap;
 				}
 				
 				//
 				// brtrue/brfalse works with native int only
 				//
 				if (((Constant) right).IsZeroInteger && right.Type != TypeManager.int64_type && right.Type != TypeManager.uint64_type) {
 					left.EmitBranchable (ec, target, my_on_true);
 					return;
 				}
 				if (right.Type == TypeManager.bool_type) {
 					// right is a boolean, and it's not 'false' => it is 'true'
 					left.EmitBranchable (ec, target, !my_on_true);
 					return;
 				}
 
 			} else if (oper == Operator.LogicalAnd) {
 
 				if (on_true) {
 					Label tests_end = ec.DefineLabel ();
 					
 					left.EmitBranchable (ec, tests_end, false);
 					right.EmitBranchable (ec, target, true);
 					ec.MarkLabel (tests_end);					
 				} else {
 					//
 					// This optimizes code like this 
 					// if (true && i > 4)
 					//
 					if (!(left is Constant))
 						left.EmitBranchable (ec, target, false);
 
 					if (!(right is Constant)) 
 						right.EmitBranchable (ec, target, false);
 				}
 				
 				return;
 				
 			} else if (oper == Operator.LogicalOr){
 				if (on_true) {
 					left.EmitBranchable (ec, target, true);
 					right.EmitBranchable (ec, target, true);
 					
 				} else {
 					Label tests_end = ec.DefineLabel ();
 					left.EmitBranchable (ec, tests_end, true);
 					right.EmitBranchable (ec, target, false);
 					ec.MarkLabel (tests_end);
 				}
 				
 				return;
 
 			} else if ((oper & Operator.ComparisonMask) == 0) {
 				base.EmitBranchable (ec, target, on_true);
 				return;
 			}
 			
 			left.Emit (ec);
 			right.Emit (ec);
 
 			TypeSpec t = left.Type;
 			bool is_float = IsFloat (t);
 			bool is_unsigned = is_float || IsUnsigned (t);
 			
 			switch (oper){
 			case Operator.Equality
 				if (on_true)
 					ec.Emit (OpCodes.Beq, target);
 				else
 					ec.Emit (OpCodes.Bne_Un, target);
 				break;
 
 			case Operator.Inequality
 				if (on_true)
 					ec.Emit (OpCodes.Bne_Un, target);
 				else
 					ec.Emit (OpCodes.Beq, target);
 				break;
 
 			case Operator.LessThan
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Blt_Un, target);
 					else
 						ec.Emit (OpCodes.Blt, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Bge_Un, target);
 					else
 						ec.Emit (OpCodes.Bge, target);
 				break;
 
 			case Operator.GreaterThan
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Bgt_Un, target);
 					else
 						ec.Emit (OpCodes.Bgt, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Ble_Un, target);
 					else
 						ec.Emit (OpCodes.Ble, target);
 				break;
 
 			case Operator.LessThanOrEqual
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Ble_Un, target);
 					else
 						ec.Emit (OpCodes.Ble, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Bgt_Un, target);
 					else
 						ec.Emit (OpCodes.Bgt, target);
 				break;
 
 
 			case Operator.GreaterThanOrEqual
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Bge_Un, target);
 					else
 						ec.Emit (OpCodes.Bge, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Blt_Un, target);
 					else
 						ec.Emit (OpCodes.Blt, target);
 				break;
 			default
 				throw new InternalErrorException (oper.ToString ());
 			}
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1892" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4217" endline="4319">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			TypeSpec op_type = left.Type;
 			
 			// It must be either array or fixed buffer
 			TypeSpec element;
 			if (TypeManager.HasElementType (op_type)) {
 				element = TypeManager.GetElementType (op_type);
 			} else {
 				FieldExpr fe = left as FieldExpr;
 				if (fe != null)
 					element = ((FixedFieldSpec) (fe.Spec)).ElementType;
 				else
 					element = op_type;
 			}
 
 			int size = GetTypeSize (element);
 			TypeSpec rtype = right.Type;
 			
 			if ((op & Binary.Operator.SubtractionMask) != 0 && rtype.IsPointer){
 				//
 				// handle (pointer - pointer)
 				//
 				left.Emit (ec);
 				right.Emit (ec);
 				ec.Emit (OpCodes.Sub);
 
 				if (size != 1){
 					if (size == 0)
 						ec.Emit (OpCodes.Sizeof, element);
 					else 
 						ec.EmitInt (size);
 					ec.Emit (OpCodes.Div);
 				}
 				ec.Emit (OpCodes.Conv_I8);
 			} else {
 				//
 				// handle + and - on (pointer op int)
 				//
 				Constant left_const = left as Constant;
 				if (left_const != null) {
 					//
 					// Optimize ((T*)null) pointer operations
 					//
 					if (left_const.IsDefaultValue) {
 						left = EmptyExpression.Null;
 					} else {
 						left_const = null;
 					}
 				}
 
 				left.Emit (ec);
 
 				var right_const = right as Constant;
 				if (right_const != null) {
 					//
 					// Optimize 0-based arithmetic
 					//
 					if (right_const.IsDefaultValue)
 						return;
 
 					if (size != 0)
 						right = new IntConstant (size, right.Location);
 					else
 						right = new SizeOf (new TypeExpression (element, right.Location), right.Location);
 					
 					// TODO
 					ResolveContext rc = new ResolveContext (ec.MemberContext, ResolveContext.Options.UnsafeScope);
 					right = new Binary (Binary.Operator.Multiply, right, right_const, loc).Resolve (rc);
 					if (right == null)
 						return;
 				}
 
 				right.Emit (ec);
 				if (rtype == TypeManager.sbyte_type || rtype == TypeManager.byte_type ||
 					rtype == TypeManager.short_type || rtype == TypeManager.ushort_type) {
 					ec.Emit (OpCodes.Conv_I);
 				} else if (rtype == TypeManager.uint32_type) {
 					ec.Emit (OpCodes.Conv_U);
 				}
 
 				if (right_const == null && size != 1){
 					if (size == 0)
 						ec.Emit (OpCodes.Sizeof, element);
 					else 
 						ec.EmitInt (size);
 					if (rtype == TypeManager.int64_type || rtype == TypeManager.uint64_type)
 						ec.Emit (OpCodes.Conv_I8);
 
 					Binary.EmitOperatorOpcode (ec, Binary.Operator.Multiply, rtype);
 				}
 
 				if (left_const == null) {
 					if (rtype == TypeManager.int64_type)
 						ec.Emit (OpCodes.Conv_I);
 					else if (rtype == TypeManager.uint64_type)
 						ec.Emit (OpCodes.Conv_U);
 
 					Binary.EmitOperatorOpcode (ec, op, op_type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="487" endline="630">
<![CDATA[
 
 		static Expression ImplicitNumericConversion (Expression expr, TypeSpec expr_type, TypeSpec target_type)
 		{
 			if (expr_type == TypeManager.sbyte_type){
 				//
 				// From sbyte to short, int, long, float, double, decimal
 				//
 				if (target_type == TypeManager.int32_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.int64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.double_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.float_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.short_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.decimal_type)
 					return expr == null ? EmptyExpression.Null 
 			} else if (expr_type == TypeManager.byte_type){
 				//
 				// From byte to short, ushort, int, uint, long, ulong, float, double, decimal
 				//
 				if (target_type == TypeManager.int32_type || target_type == TypeManager.uint32_type ||
 				    target_type == TypeManager.short_type || target_type == TypeManager.ushort_type)
 					return expr == null ? EmptyExpression.Null 
 
 				if (target_type == TypeManager.uint64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.int64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.float_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.double_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.decimal_type)
 					return expr == null ? EmptyExpression.Null 
 
 			} else if (expr_type == TypeManager.short_type){
 				//
 				// From short to int, long, float, double, decimal
 				//
 				if (target_type == TypeManager.int32_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.int64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.double_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.float_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.decimal_type)
 					return expr == null ? EmptyExpression.Null 
 
 			} else if (expr_type == TypeManager.ushort_type){
 				//
 				// From ushort to int, uint, long, ulong, float, double, decimal
 				//
 				if (target_type == TypeManager.int32_type || target_type == TypeManager.uint32_type)
 					return expr == null ? EmptyExpression.Null 
 				
 				if (target_type == TypeManager.uint64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.int64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.double_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.float_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.decimal_type)
 					return expr == null ? EmptyExpression.Null 
 			} else if (expr_type == TypeManager.int32_type){
 				//
 				// From int to long, float, double, decimal
 				//
 				if (target_type == TypeManager.int64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.double_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.float_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.decimal_type)
 					return expr == null ? EmptyExpression.Null 
 			} else if (expr_type == TypeManager.uint32_type){
 				//
 				// From uint to long, ulong, float, double, decimal
 				//
 				if (target_type == TypeManager.int64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.uint64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.double_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.float_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.decimal_type)
 					return expr == null ? EmptyExpression.Null 
 			} else if (expr_type == TypeManager.int64_type){
 				//
 				// From long/ulong to float, double
 				//
 				if (target_type == TypeManager.double_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.float_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.decimal_type)
 					return expr == null ? EmptyExpression.Null 
 			} else if (expr_type == TypeManager.uint64_type){
 				//
 				// From ulong to float, double
 				//
 				if (target_type == TypeManager.double_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.float_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.decimal_type)
 					return expr == null ? EmptyExpression.Null 
 			} else if (expr_type == TypeManager.char_type){
 				//
 				// From char to ushort, int, uint, long, ulong, float, double, decimal
 				//
 				if ((target_type == TypeManager.ushort_type) ||
 				    (target_type == TypeManager.int32_type) ||
 				    (target_type == TypeManager.uint32_type))
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.uint64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.int64_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.float_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.double_type)
 					return expr == null ? EmptyExpression.Null 
 				if (target_type == TypeManager.decimal_type)
 					return expr == null ? EmptyExpression.Null 
 			} else if (expr_type == TypeManager.float_type){
 				//
 				// float to double
 				//
 				if (target_type == TypeManager.double_type)
 					return expr == null ? EmptyExpression.Null 
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1893" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1057" endline="1096">
<![CDATA[
 
     Public Shared Function ConvertToDateTime(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Boolean", "Date")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Byte", "Date")
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Date")
             Case TypeCode.DateTime
                 result = Source
                 Return True
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Decimal", "Date")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30533, Context.Location)
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Short", "Date")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Integer", "Date")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Long", "Date")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "SByte", "Date")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Single", "Date")
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Date")
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "UShort", "Date")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "UInteger", "Date")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "ULong", "Date")
             Case TypeCode.DBNull
                 result = New Date()
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Date")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" startline="1423" endline="1463">
<![CDATA[
 
     Public Shared Function ConvertToString(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Boolean", "String")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.Char
                 result = CStr(DirectCast(Source, Char))
                 Return True
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Date", "String")
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Decimal", "String")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Double", "String")
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Short", "String")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Integer", "String")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Long", "String")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "SByte", "String")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Single", "String")
             Case TypeCode.String
                 result = Source
                 Return True
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "UShort", "String")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "UInteger", "String")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "ULong", "String")
             Case TypeCode.DBNull
                 result = Nothing
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "String")
     End Function
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1894" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="225" endline="497">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim argList As ArgumentList
 
         If m_IsResolved Then Return result
 
         If m_AttributeArguments IsNot Nothing Then
             Helper.Assert(m_Arguments Is Nothing)
             Helper.Assert(m_Fields Is Nothing)
             Helper.Assert(m_FieldValues Is Nothing)
             Helper.Assert(m_Properties Is Nothing)
             Helper.Assert(m_PropertyValues Is Nothing)
 
             result = m_AttributeArguments.ResolveCode(Info) AndAlso result
 
             If m_AttributeArguments.PositionalArgumentList IsNot Nothing Then
                 argList = New ArgumentList(Me, m_AttributeArguments.PositionalArgumentList.AsExpressions)
             Else
                 argList = New ArgumentList(Me)
             End If
 
             If m_AttributeArguments.VariablePropertyInitializerList IsNot Nothing Then
                 Dim cache As MemberCache
 
                 cache = Info.Compiler.TypeManager.GetCache(m_ResolvedType)
 
                 For Each item As VariablePropertyInitializer In m_AttributeArguments.VariablePropertyInitializerList
                     Dim name As String
                     Dim member As Mono.Cecil.MemberReference
                     Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
                     name = item.Identifier
                     members = cache.LookupFlattenedMembers(name)
                     members = Helper.FilterExternalInaccessible(Info.Compiler, members)
                     If members.Count <> 1 Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                     member = members(0)
                     If TypeOf member Is Mono.Cecil.FieldReference Then
                         Dim field As Mono.Cecil.FieldReference
                         field = DirectCast(member, Mono.Cecil.FieldReference)
 
                         If m_Fields Is Nothing Then m_Fields = New Generic.List(Of Mono.Cecil.FieldReference)
                         If m_FieldValues Is Nothing Then m_FieldValues = New Generic.List(Of Object)
                         m_Fields.Add(field)
                         m_FieldValues.Add(item.AttributeArgumentExpression.Expression.ConstantValue)
                     ElseIf TypeOf member Is Mono.Cecil.PropertyReference Then
                         Dim prop As Mono.Cecil.PropertyReference
                         prop = DirectCast(member, Mono.Cecil.PropertyReference)
                         If m_Properties Is Nothing Then m_Properties = New Generic.List(Of Mono.Cecil.PropertyReference)
                         If m_PropertyValues Is Nothing Then m_PropertyValues = New Generic.List(Of Object)
                         m_Properties.Add(prop)
                         m_PropertyValues.Add(item.AttributeArgumentExpression.Expression.ConstantValue)
                         'm_PropertyValues.add(item.
                     Else
                         Helper.AddError(Me, "Invalid member type for attribute value.")
                     End If
                 Next
             End If
 
         ElseIf m_Arguments IsNot Nothing Then
             argList = New ArgumentList(Me)
             For i As Integer = 0 To m_Arguments.Length - 1
                 argList.Arguments.Add(New PositionalArgument(argList, argList.Count, New ConstantExpression(argList, m_Arguments(i), CecilHelper.GetType(Compiler, m_Arguments(i)))))
             Next
         Else
             argList = New ArgumentList(Me)
         End If
 
         If m_Arguments Is Nothing Then m_Arguments = New Object() {}
         If m_Fields Is Nothing Then m_Fields = New Generic.List(Of Mono.Cecil.FieldReference)
         If m_FieldValues Is Nothing Then m_FieldValues = New Generic.List(Of Object)
         If m_Properties Is Nothing Then m_Properties = New Generic.List(Of Mono.Cecil.PropertyReference)
         If m_PropertyValues Is Nothing Then m_PropertyValues = New Generic.List(Of Object)
 
         Dim ctors As Mono.Collections.Generic.Collection(Of MethodReference)
         Dim parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         ctors = CecilHelper.GetConstructors(m_ResolvedType)
 
         Dim groupClassification As New MethodGroupClassification(Me, Nothing, Nothing, Nothing, ctors)
         result = groupClassification.ResolveGroup(argList) AndAlso result
         m_ResolvedTypeConstructor = groupClassification.ResolvedConstructor
         result = m_ResolvedTypeConstructor IsNot Nothing AndAlso result
         result = argList.FillWithOptionalParameters(m_ResolvedTypeConstructor) AndAlso result
 
         parameters = Helper.GetParameters(Me, m_ResolvedTypeConstructor)
 
         ReDim m_Arguments(argList.Count - 1)
         For i As Integer = 0 To m_Arguments.Length - 1
             m_Arguments(i) = argList(i).Expression.ConstantValue
             If TypeOf m_Arguments(i) Is DBNull Then
                 m_Arguments(i) = Nothing
             End If
         Next
 
         m_IsResolved = result
 
         If result Then
             For i As Integer = 0 To m_Arguments.Length - 1
                 Dim value As Object = Nothing
                 If TypeOf m_Arguments(i) Is TypeReference Then Continue For
                 result = TypeConverter.ConvertTo(Me, m_Arguments(i), parameters(i).ParameterType, value)
                 If result Then m_Arguments(i) = value
             Next
             For i As Integer = 0 To m_FieldValues.Count - 1
                 Dim value As Object = Nothing
                 'TypeConverter.ConvertTo will report any errors
                 result = TypeConverter.ConvertTo(Me, m_FieldValues(i), m_Fields(i).FieldType, value)
                 If result Then m_FieldValues(i) = value
             Next
             For i As Integer = 0 To m_PropertyValues.Count - 1
                 Dim value As Object = Nothing
                 'TypeConverter.ConvertTo will report any errors
                 result = TypeConverter.ConvertTo(Me, m_PropertyValues(i), m_Properties(i).PropertyType, value)
                 If result Then m_PropertyValues(i) = value
             Next
         End If
 
         m_CecilBuilder = GetAttributeBuilderCecil()
 
         If m_IsAssembly Then
             Me.Compiler.AssemblyBuilderCecil.CustomAttributes.Add(CecilBuilder)
         ElseIf m_IsModule Then
             Me.Compiler.ModuleBuilderCecil.CustomAttributes.Add(CecilBuilder)
         Else
             Dim memberparent As IAttributableDeclaration = Me.FindFirstParent(Of IAttributableDeclaration)()
             If memberparent IsNot Nothing Then
                 Dim tp As TypeDeclaration = TryCast(memberparent, TypeDeclaration)
                 Dim mthd As IMethod = TryCast(memberparent, IMethod)
                 Dim ctro As IConstructorMember = TryCast(memberparent, IConstructorMember)
                 Dim fld As IFieldMember = TryCast(memberparent, IFieldMember)
                 Dim prop As PropertyDeclaration = TryCast(memberparent, PropertyDeclaration)
                 Dim param As Parameter = TryCast(memberparent, Parameter)
                 Dim evt As EventDeclaration = TryCast(memberparent, EventDeclaration)
 
                 If ctro IsNot Nothing Then mthd = Nothing
                 Helper.Assert(tp IsNot Nothing Xor mthd IsNot Nothing Xor ctro IsNot Nothing Xor fld IsNot Nothing Xor prop IsNot Nothing Xor param IsNot Nothing OrElse evt IsNot Nothing)
 
                 If tp IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_SerializableAttribute) Then
                         tp.Serializable = True
                     ElseIf Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_StructLayoutAttribute) Then
                         Dim layout As System.Runtime.InteropServices.LayoutKind
                         layout = CType(CecilBuilder.ConstructorArguments(0).Value, System.Runtime.InteropServices.LayoutKind)
                         Select Case layout
                             Case Runtime.InteropServices.LayoutKind.Auto
                                 tp.CecilType.IsAutoLayout = True
                             Case Runtime.InteropServices.LayoutKind.Explicit
                                 tp.CecilType.IsExplicitLayout = True
                             Case Runtime.InteropServices.LayoutKind.Sequential
                                 tp.CecilType.IsSequentialLayout = True
                             Case Else
                                 Compiler.Report.ShowMessage(Messages.VBNC30127, Me.Location, CecilBuilder.Constructor.DeclaringType.FullName, "Invalid argument.")
                                 Return False
                         End Select
                     Else
                         tp.CecilType.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf mthd IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then
                         Dim values As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttributeNamedArgument) = CecilBuilder.Fields
                         Dim modRef As Mono.Cecil.ModuleReference = Nothing
                         Dim modRefName As String = DirectCast(CecilBuilder.ConstructorArguments(0).Value, String)
                         Dim entry As String = Nothing
                         Dim charSetField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim entryPointField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim callingConventionField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim setLastErrorField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
 
                         For i As Integer = 0 To values.Count - 1
                             If Helper.CompareNameOrdinal(values(i).Name, "CharSet") Then
                                 charSetField = values(i)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "EntryPoint") Then
                                 entryPointField = values(i)
                                 entry = DirectCast(entryPointField.Value.Argument.Value, String)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "CallingConvention") Then
                                 callingConventionField = values(i)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "SetLastError") Then
                                 setLastErrorField = values(i)
                             End If
                         Next
 
                         If entry = String.Empty Then entry = mthd.Name
                         For i As Integer = 0 To Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences.Count - 1
                             If Helper.CompareNameOrdinal(Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences(i).Name, modRefName) Then
                                 modRef = Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences(i)
                                 Exit For
                             End If
                         Next
                         If modRef Is Nothing Then
                             modRef = New Mono.Cecil.ModuleReference(modRefName)
                             Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences.Add(modRef)
                         End If
                         mthd.CecilBuilder.PInvokeInfo = New Mono.Cecil.PInvokeInfo(0, entry, modRef)
 
                         Dim charset As System.Runtime.InteropServices.CharSet
                         If charSetField.HasValue Then
                             charset = DirectCast(charSetField.Value.Argument.Value, System.Runtime.InteropServices.CharSet)
                         Else
                             charset = Runtime.InteropServices.CharSet.Auto
                         End If
                         Select Case charset
                             Case Runtime.InteropServices.CharSet.Ansi
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetAnsi = True
                             Case Runtime.InteropServices.CharSet.Auto
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetAuto = True
                             Case Runtime.InteropServices.CharSet.None
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetNotSpec = True
                             Case Runtime.InteropServices.CharSet.Unicode
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetUnicode = True
                             Case Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Invalid charset
                         End Select
 
                         Dim callingconv As System.Runtime.InteropServices.CallingConvention
                         If callingConventionField.HasValue Then
                             callingconv = DirectCast(callingConventionField.Value.Argument.Value, System.Runtime.InteropServices.CallingConvention)
                         Else
                             callingconv = Runtime.InteropServices.CallingConvention.Winapi
                         End If
                         Select Case callingconv
                             Case Runtime.InteropServices.CallingConvention.Cdecl
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvCdecl = True
                             Case Runtime.InteropServices.CallingConvention.FastCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvFastcall = True
                             Case Runtime.InteropServices.CallingConvention.StdCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvStdCall = True
                             Case Runtime.InteropServices.CallingConvention.ThisCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvThiscall = True
                             Case Runtime.InteropServices.CallingConvention.Winapi
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvWinapi = True
                             Case Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Invalid calling convention
                         End Select
 
                         Dim setlasterror As Boolean = True
                         If setLastErrorField.HasValue Then
                             setlasterror = DirectCast(setLastErrorField.Value.Argument.Value, Boolean)
                         End If
                         mthd.CecilBuilder.PInvokeInfo.SupportsLastError = setlasterror
                         mthd.CecilBuilder.PInvokeInfo.IsNoMangle = True
                     Else
                         mthd.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf ctro IsNot Nothing Then
                     ctro.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf fld IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_MarshalAsAttribute) Then
                         fld.FieldBuilder.MarshalInfo = New MarshalInfo(CType(CecilBuilder.ConstructorArguments(0).Value, Mono.Cecil.NativeType))
                         fld.FieldBuilder.Attributes = fld.FieldBuilder.Attributes Or Mono.Cecil.FieldAttributes.HasFieldMarshal
                     ElseIf Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_FieldOffsetAttribute) Then
                         fld.FieldBuilder.Offset = CType(CecilBuilder.ConstructorArguments(0).Value, Integer)
                     Else
                         fld.FieldBuilder.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf prop IsNot Nothing Then
                     prop.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf param IsNot Nothing Then
                     param.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf evt IsNot Nothing Then
                     evt.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 End If
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="874" endline="984">
<![CDATA[
 
     Public Overrides Sub InitInternalVBMembers()
         MS_VB_Information__IsNumeric = GetMethod(MS_VB_Information, "IsNumeric", System_Object)
         MS_VB_Information__SystemTypeName = GetMethod(MS_VB_Information, "SystemTypeName", System_String)
         MS_VB_Information__TypeName = GetMethod(MS_VB_Information, "TypeName", System_Object)
         MS_VB_Information__VbTypeName = GetMethod(MS_VB_Information, "VbTypeName", System_String)
         MS_VB_Interaction__CallByName = GetMethod(MS_VB_Interaction, "CallByName", System_Object, System_String, MS_VB_CallType, System_Object_Array)
         MS_VB_CS_Versioned__IsNumeric = GetMethod(MS_VB_CS_Versioned, "IsNumeric", System_Object)
         MS_VB_CS_Versioned__SystemTypeName = GetMethod(MS_VB_CS_Versioned, "SystemTypeName", System_String)
         MS_VB_CS_Versioned__TypeName = GetMethod(MS_VB_CS_Versioned, "TypeName", System_Object)
         MS_VB_CS_Versioned__VbTypeName = GetMethod(MS_VB_CS_Versioned, "VbTypeName", System_String)
         MS_VB_CS_Versioned__CallByName = GetMethod(MS_VB_CS_Versioned, "CallByName", System_Object, System_String, MS_VB_CallType, System_Object_Array)
         MS_VB_CS_StaticLocalInitFlag__State = GetField(MS_VB_CS_StaticLocalInitFlag, "State")
         MS_VB_CS_StaticLocalInitFlag__ctor = GetConstructor(MS_VB_CS_StaticLocalInitFlag)
         MS_VB_CS_IncompleteInitialization__ctor = GetConstructor(MS_VB_CS_IncompleteInitialization)
         MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateGet", System_Object, System_Type, System_String, System_Object_Array, System_String_Array, System_Type_Array, System_Boolean_Array)
         MS_VB_CS_NewLateBinding__LateSet_Object_Type_String_Array_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateSet", System_Object, System_Type, System_String, System_Object_Array, System_String_Array, System_Type_Array)
         MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateIndexGet", System_Object, System_Object_Array, System_String_Array)
         MS_VB_CS_NewLateBinding__LateIndexSet_Object_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateIndexSet", System_Object, System_Object_Array, System_String_Array)
         MS_VB_CS_NewLateBinding__LateCall_Object_Type_String_Array_Array_Array_Array_Boolean = GetMethod(MS_VB_CS_NewLateBinding, "LateCall", System_Object, System_Type, System_String, System_Object_Array, System_String_Array, System_Type_Array, System_Boolean_Array, System_Boolean)
         MS_VB_CS_ProjectData__EndApp = GetMethod(MS_VB_CS_ProjectData, "EndApp")
         MS_VB_CS_ProjectData__CreateProjectError_Int32 = GetMethod(MS_VB_CS_ProjectData, "CreateProjectError", System_Int32)
         MS_VB_CS_ProjectData__ClearProjectError = GetMethod(MS_VB_CS_ProjectData, "ClearProjectError")
         MS_VB_CS_ProjectData__SetProjectError_Exception = GetMethod(MS_VB_CS_ProjectData, "SetProjectError", System_Exception)
         MS_VB_CS_ProjectData__SetProjectError_Exception_Int32 = GetMethod(MS_VB_CS_ProjectData, "SetProjectError", System_Exception, System_Int32)
         MS_VB_CS_Conversions__ToBoolean_Object = GetMethod(MS_VB_CS_Conversions, "ToBoolean", System_Object)
         MS_VB_CS_Conversions__ToChar_Object = GetMethod(MS_VB_CS_Conversions, "ToChar", System_Object)
         MS_VB_CS_Conversions__ToDate_Object = GetMethod(MS_VB_CS_Conversions, "ToDate", System_Object)
         MS_VB_CS_Conversions__ToByte_Object = GetMethod(MS_VB_CS_Conversions, "ToByte", System_Object)
         MS_VB_CS_Conversions__ToSByte_Object = GetMethod(MS_VB_CS_Conversions, "ToSByte", System_Object)
         MS_VB_CS_Conversions__ToShort_Object = GetMethod(MS_VB_CS_Conversions, "ToShort", System_Object)
         MS_VB_CS_Conversions__ToUShort_Object = GetMethod(MS_VB_CS_Conversions, "ToUShort", System_Object)
         MS_VB_CS_Conversions__ToInteger_Object = GetMethod(MS_VB_CS_Conversions, "ToInteger", System_Object)
         MS_VB_CS_Conversions__ToUInteger_Object = GetMethod(MS_VB_CS_Conversions, "ToUInteger", System_Object)
         MS_VB_CS_Conversions__ToLong_Object = GetMethod(MS_VB_CS_Conversions, "ToLong", System_Object)
         MS_VB_CS_Conversions__ToULong_Object = GetMethod(MS_VB_CS_Conversions, "ToULong", System_Object)
         MS_VB_CS_Conversions__ToSingle_Object = GetMethod(MS_VB_CS_Conversions, "ToSingle", System_Object)
         MS_VB_CS_Conversions__ToDouble_Object = GetMethod(MS_VB_CS_Conversions, "ToDouble", System_Object)
         MS_VB_CS_Conversions__ToDecimal_Object = GetMethod(MS_VB_CS_Conversions, "ToDecimal", System_Object)
         MS_VB_CS_Conversions__ToBoolean_String = GetMethod(MS_VB_CS_Conversions, "ToBoolean", System_String)
         MS_VB_CS_Conversions__ToChar_String = GetMethod(MS_VB_CS_Conversions, "ToChar", System_String)
         MS_VB_CS_Conversions__ToDate_String = GetMethod(MS_VB_CS_Conversions, "ToDate", System_String)
         MS_VB_CS_Conversions__ToByte_String = GetMethod(MS_VB_CS_Conversions, "ToByte", System_String)
         MS_VB_CS_Conversions__ToSByte_String = GetMethod(MS_VB_CS_Conversions, "ToSByte", System_String)
         MS_VB_CS_Conversions__ToShort_String = GetMethod(MS_VB_CS_Conversions, "ToShort", System_String)
         MS_VB_CS_Conversions__ToUShort_String = GetMethod(MS_VB_CS_Conversions, "ToUShort", System_String)
         MS_VB_CS_Conversions__ToInteger_String = GetMethod(MS_VB_CS_Conversions, "ToInteger", System_String)
         MS_VB_CS_Conversions__ToUInteger_String = GetMethod(MS_VB_CS_Conversions, "ToUInteger", System_String)
         MS_VB_CS_Conversions__ToLong_String = GetMethod(MS_VB_CS_Conversions, "ToLong", System_String)
         MS_VB_CS_Conversions__ToULong_String = GetMethod(MS_VB_CS_Conversions, "ToULong", System_String)
         MS_VB_CS_Conversions__ToSingle_String = GetMethod(MS_VB_CS_Conversions, "ToSingle", System_String)
         MS_VB_CS_Conversions__ToDouble_String = GetMethod(MS_VB_CS_Conversions, "ToDouble", System_String)
         MS_VB_CS_Conversions__ToDecimal_String = GetMethod(MS_VB_CS_Conversions, "ToDecimal", System_String)
         MS_VB_CS_Conversions__ToDecimal_Boolean = GetMethod(MS_VB_CS_Conversions, "ToDecimal", System_Boolean)
         MS_VB_CS_Conversions__ToString_Decimal = GetMethod(MS_VB_CS_Conversions, "ToString", System_Decimal)
         MS_VB_CS_Conversions__ToString_Boolean = GetMethod(MS_VB_CS_Conversions, "ToString", System_Boolean)
         MS_VB_CS_Conversions__ToString_Char = GetMethod(MS_VB_CS_Conversions, "ToString", System_Char)
         MS_VB_CS_Conversions__ToString_DateTime = GetMethod(MS_VB_CS_Conversions, "ToString", System_DateTime)
         MS_VB_CS_Conversions__ToString_Byte = GetMethod(MS_VB_CS_Conversions, "ToString", System_Byte)
         MS_VB_CS_Conversions__ToString_Int32 = GetMethod(MS_VB_CS_Conversions, "ToString", System_Int32)
         MS_VB_CS_Conversions__ToString_UInt32 = GetMethod(MS_VB_CS_Conversions, "ToString", System_UInt32)
         MS_VB_CS_Conversions__ToString_Int64 = GetMethod(MS_VB_CS_Conversions, "ToString", System_Int64)
         MS_VB_CS_Conversions__ToString_UInt64 = GetMethod(MS_VB_CS_Conversions, "ToString", System_UInt64)
         MS_VB_CS_Conversions__ToString_Single = GetMethod(MS_VB_CS_Conversions, "ToString", System_Single)
         MS_VB_CS_Conversions__ToString_Double = GetMethod(MS_VB_CS_Conversions, "ToString", System_Double)
         MS_VB_CS_Conversions__ToString_Object = GetMethod(MS_VB_CS_Conversions, "ToString", System_Object)
         MS_VB_CS_Conversions__ToGenericParameter_Object = GetMethod(MS_VB_CS_Conversions, "ToGenericParameter", System_Object)
         MS_VB_CS_Conversions__ChangeType_Object_Type = GetMethod(MS_VB_CS_Conversions, "ChangeType", System_Object, System_Type)
         MS_VB_CS_Conversions__ToCharArrayRankOne_String = GetMethod(MS_VB_CS_Conversions, "ToCharArrayRankOne", System_String)
         MS_VB_CS_LikeOperator__LikeString_String_String_CompareMethod = GetMethod(MS_VB_CS_LikeOperator, "LikeString", System_String, System_String, MS_VB_CompareMethod)
         MS_VB_CS_LikeOperator__LikeObject_Object_Object_CompareMethod = GetMethod(MS_VB_CS_LikeOperator, "LikeObject", System_Object, System_Object, MS_VB_CompareMethod)
         MS_VB_CS_StringType__MidStmtStr_String_Int32_Int32_String = GetMethod(MS_VB_CS_StringType, "MidStmtStr", System_String_ByRef, System_Int32, System_Int32, System_String)
         MS_VB_CS_ObjectFlowControl__CheckForSyncLockOnValueType_Object = GetMethod(MS_VB_CS_ObjectFlowControl, "CheckForSyncLockOnValueType", System_Object)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForLoopInitObj_Object_Object_Object_Object_Object_Object = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForLoopInitObj", System_Object, System_Object, System_Object, System_Object, System_Object_ByRef, System_Object_ByRef)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckDec_Decimal_Decimal_Decimal = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckDec", System_Decimal, System_Decimal, System_Decimal)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckObj_Object_Object_Object = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckObj", System_Object, System_Object, System_Object_ByRef)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckR4_Single_Single_Single = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckR4", System_Single, System_Single, System_Single)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckR8_Double_Double_Double = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckR8", System_Double, System_Double, System_Double)
         MS_VB_CS_Utils__CopyArray_Array_Array = GetMethod(MS_VB_CS_Utils, "CopyArray", System_Array, System_Array)
         MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectNotEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectNotEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectGreater_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectGreater", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectGreaterEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectGreaterEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectLess_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectLess", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectLessEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectLessEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareString_String_String_Boolean = GetMethod(MS_VB_CS_Operators, "CompareString", System_String, System_String, System_Boolean)
         MS_VB_CS_Operators__ConcatenateObject_Object_Object = GetMethod(MS_VB_CS_Operators, "ConcatenateObject", System_Object, System_Object)
         MS_VB_CS_Operators__AddObject_Object_Object = GetMethod(MS_VB_CS_Operators, "AddObject", System_Object, System_Object)
         MS_VB_CS_Operators__AndObject_Object_Object = GetMethod(MS_VB_CS_Operators, "AndObject", System_Object, System_Object)
         MS_VB_CS_Operators__DivideObject_Object_Object = GetMethod(MS_VB_CS_Operators, "DivideObject", System_Object, System_Object)
         MS_VB_CS_Operators__ExponentObject_Object_Object = GetMethod(MS_VB_CS_Operators, "ExponentObject", System_Object, System_Object)
         MS_VB_CS_Operators__IntDivideObject_Object_Object = GetMethod(MS_VB_CS_Operators, "IntDivideObject", System_Object, System_Object)
         MS_VB_CS_Operators__LeftShiftObject_Object_Object = GetMethod(MS_VB_CS_Operators, "LeftShiftObject", System_Object, System_Object)
         MS_VB_CS_Operators__ModObject_Object_Object = GetMethod(MS_VB_CS_Operators, "ModObject", System_Object, System_Object)
         MS_VB_CS_Operators__MultiplyObject_Object_Object = GetMethod(MS_VB_CS_Operators, "MultiplyObject", System_Object, System_Object)
         MS_VB_CS_Operators__NegateObject_Object = GetMethod(MS_VB_CS_Operators, "NegateObject", System_Object)
         MS_VB_CS_Operators__NotObject_Object = GetMethod(MS_VB_CS_Operators, "NotObject", System_Object)
         MS_VB_CS_Operators__OrObject_Object_Object = GetMethod(MS_VB_CS_Operators, "OrObject", System_Object, System_Object)
         MS_VB_CS_Operators__PlusObject_Object = GetMethod(MS_VB_CS_Operators, "PlusObject", System_Object)
         MS_VB_CS_Operators__RightShiftObject_Object_Object = GetMethod(MS_VB_CS_Operators, "RightShiftObject", System_Object, System_Object)
         MS_VB_CS_Operators__SubtractObject_Object_Object = GetMethod(MS_VB_CS_Operators, "SubtractObject", System_Object, System_Object)
         MS_VB_CS_Operators__XorObject_Object_Object = GetMethod(MS_VB_CS_Operators, "XorObject", System_Object, System_Object)
         MS_VB_CS_Operators__LikeObject_Object_Object_CompareMethod = GetMethod(MS_VB_CS_Operators, "LikeObject", System_Object, System_Object, MS_VB_CompareMethod)
         MS_VB_CS_Operators__LikeString_String_String_CompareMethod = GetMethod(MS_VB_CS_Operators, "LikeString", System_String, System_String, MS_VB_CompareMethod)
         MS_VB_CS_Operators__CompareObjectEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectNotEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectNotEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectGreater_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectGreater", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectGreaterEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectGreaterEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectLess_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectLess", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectLessEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectLessEqual", System_Object, System_Object, System_Boolean)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1895" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attribute.vb" startline="225" endline="497">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim argList As ArgumentList
 
         If m_IsResolved Then Return result
 
         If m_AttributeArguments IsNot Nothing Then
             Helper.Assert(m_Arguments Is Nothing)
             Helper.Assert(m_Fields Is Nothing)
             Helper.Assert(m_FieldValues Is Nothing)
             Helper.Assert(m_Properties Is Nothing)
             Helper.Assert(m_PropertyValues Is Nothing)
 
             result = m_AttributeArguments.ResolveCode(Info) AndAlso result
 
             If m_AttributeArguments.PositionalArgumentList IsNot Nothing Then
                 argList = New ArgumentList(Me, m_AttributeArguments.PositionalArgumentList.AsExpressions)
             Else
                 argList = New ArgumentList(Me)
             End If
 
             If m_AttributeArguments.VariablePropertyInitializerList IsNot Nothing Then
                 Dim cache As MemberCache
 
                 cache = Info.Compiler.TypeManager.GetCache(m_ResolvedType)
 
                 For Each item As VariablePropertyInitializer In m_AttributeArguments.VariablePropertyInitializerList
                     Dim name As String
                     Dim member As Mono.Cecil.MemberReference
                     Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
                     name = item.Identifier
                     members = cache.LookupFlattenedMembers(name)
                     members = Helper.FilterExternalInaccessible(Info.Compiler, members)
                     If members.Count <> 1 Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                     member = members(0)
                     If TypeOf member Is Mono.Cecil.FieldReference Then
                         Dim field As Mono.Cecil.FieldReference
                         field = DirectCast(member, Mono.Cecil.FieldReference)
 
                         If m_Fields Is Nothing Then m_Fields = New Generic.List(Of Mono.Cecil.FieldReference)
                         If m_FieldValues Is Nothing Then m_FieldValues = New Generic.List(Of Object)
                         m_Fields.Add(field)
                         m_FieldValues.Add(item.AttributeArgumentExpression.Expression.ConstantValue)
                     ElseIf TypeOf member Is Mono.Cecil.PropertyReference Then
                         Dim prop As Mono.Cecil.PropertyReference
                         prop = DirectCast(member, Mono.Cecil.PropertyReference)
                         If m_Properties Is Nothing Then m_Properties = New Generic.List(Of Mono.Cecil.PropertyReference)
                         If m_PropertyValues Is Nothing Then m_PropertyValues = New Generic.List(Of Object)
                         m_Properties.Add(prop)
                         m_PropertyValues.Add(item.AttributeArgumentExpression.Expression.ConstantValue)
                         'm_PropertyValues.add(item.
                     Else
                         Helper.AddError(Me, "Invalid member type for attribute value.")
                     End If
                 Next
             End If
 
         ElseIf m_Arguments IsNot Nothing Then
             argList = New ArgumentList(Me)
             For i As Integer = 0 To m_Arguments.Length - 1
                 argList.Arguments.Add(New PositionalArgument(argList, argList.Count, New ConstantExpression(argList, m_Arguments(i), CecilHelper.GetType(Compiler, m_Arguments(i)))))
             Next
         Else
             argList = New ArgumentList(Me)
         End If
 
         If m_Arguments Is Nothing Then m_Arguments = New Object() {}
         If m_Fields Is Nothing Then m_Fields = New Generic.List(Of Mono.Cecil.FieldReference)
         If m_FieldValues Is Nothing Then m_FieldValues = New Generic.List(Of Object)
         If m_Properties Is Nothing Then m_Properties = New Generic.List(Of Mono.Cecil.PropertyReference)
         If m_PropertyValues Is Nothing Then m_PropertyValues = New Generic.List(Of Object)
 
         Dim ctors As Mono.Collections.Generic.Collection(Of MethodReference)
         Dim parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         ctors = CecilHelper.GetConstructors(m_ResolvedType)
 
         Dim groupClassification As New MethodGroupClassification(Me, Nothing, Nothing, Nothing, ctors)
         result = groupClassification.ResolveGroup(argList) AndAlso result
         m_ResolvedTypeConstructor = groupClassification.ResolvedConstructor
         result = m_ResolvedTypeConstructor IsNot Nothing AndAlso result
         result = argList.FillWithOptionalParameters(m_ResolvedTypeConstructor) AndAlso result
 
         parameters = Helper.GetParameters(Me, m_ResolvedTypeConstructor)
 
         ReDim m_Arguments(argList.Count - 1)
         For i As Integer = 0 To m_Arguments.Length - 1
             m_Arguments(i) = argList(i).Expression.ConstantValue
             If TypeOf m_Arguments(i) Is DBNull Then
                 m_Arguments(i) = Nothing
             End If
         Next
 
         m_IsResolved = result
 
         If result Then
             For i As Integer = 0 To m_Arguments.Length - 1
                 Dim value As Object = Nothing
                 If TypeOf m_Arguments(i) Is TypeReference Then Continue For
                 result = TypeConverter.ConvertTo(Me, m_Arguments(i), parameters(i).ParameterType, value)
                 If result Then m_Arguments(i) = value
             Next
             For i As Integer = 0 To m_FieldValues.Count - 1
                 Dim value As Object = Nothing
                 'TypeConverter.ConvertTo will report any errors
                 result = TypeConverter.ConvertTo(Me, m_FieldValues(i), m_Fields(i).FieldType, value)
                 If result Then m_FieldValues(i) = value
             Next
             For i As Integer = 0 To m_PropertyValues.Count - 1
                 Dim value As Object = Nothing
                 'TypeConverter.ConvertTo will report any errors
                 result = TypeConverter.ConvertTo(Me, m_PropertyValues(i), m_Properties(i).PropertyType, value)
                 If result Then m_PropertyValues(i) = value
             Next
         End If
 
         m_CecilBuilder = GetAttributeBuilderCecil()
 
         If m_IsAssembly Then
             Me.Compiler.AssemblyBuilderCecil.CustomAttributes.Add(CecilBuilder)
         ElseIf m_IsModule Then
             Me.Compiler.ModuleBuilderCecil.CustomAttributes.Add(CecilBuilder)
         Else
             Dim memberparent As IAttributableDeclaration = Me.FindFirstParent(Of IAttributableDeclaration)()
             If memberparent IsNot Nothing Then
                 Dim tp As TypeDeclaration = TryCast(memberparent, TypeDeclaration)
                 Dim mthd As IMethod = TryCast(memberparent, IMethod)
                 Dim ctro As IConstructorMember = TryCast(memberparent, IConstructorMember)
                 Dim fld As IFieldMember = TryCast(memberparent, IFieldMember)
                 Dim prop As PropertyDeclaration = TryCast(memberparent, PropertyDeclaration)
                 Dim param As Parameter = TryCast(memberparent, Parameter)
                 Dim evt As EventDeclaration = TryCast(memberparent, EventDeclaration)
 
                 If ctro IsNot Nothing Then mthd = Nothing
                 Helper.Assert(tp IsNot Nothing Xor mthd IsNot Nothing Xor ctro IsNot Nothing Xor fld IsNot Nothing Xor prop IsNot Nothing Xor param IsNot Nothing OrElse evt IsNot Nothing)
 
                 If tp IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_SerializableAttribute) Then
                         tp.Serializable = True
                     ElseIf Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_StructLayoutAttribute) Then
                         Dim layout As System.Runtime.InteropServices.LayoutKind
                         layout = CType(CecilBuilder.ConstructorArguments(0).Value, System.Runtime.InteropServices.LayoutKind)
                         Select Case layout
                             Case Runtime.InteropServices.LayoutKind.Auto
                                 tp.CecilType.IsAutoLayout = True
                             Case Runtime.InteropServices.LayoutKind.Explicit
                                 tp.CecilType.IsExplicitLayout = True
                             Case Runtime.InteropServices.LayoutKind.Sequential
                                 tp.CecilType.IsSequentialLayout = True
                             Case Else
                                 Compiler.Report.ShowMessage(Messages.VBNC30127, Me.Location, CecilBuilder.Constructor.DeclaringType.FullName, "Invalid argument.")
                                 Return False
                         End Select
                     Else
                         tp.CecilType.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf mthd IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then
                         Dim values As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttributeNamedArgument) = CecilBuilder.Fields
                         Dim modRef As Mono.Cecil.ModuleReference = Nothing
                         Dim modRefName As String = DirectCast(CecilBuilder.ConstructorArguments(0).Value, String)
                         Dim entry As String = Nothing
                         Dim charSetField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim entryPointField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim callingConventionField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim setLastErrorField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
 
                         For i As Integer = 0 To values.Count - 1
                             If Helper.CompareNameOrdinal(values(i).Name, "CharSet") Then
                                 charSetField = values(i)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "EntryPoint") Then
                                 entryPointField = values(i)
                                 entry = DirectCast(entryPointField.Value.Argument.Value, String)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "CallingConvention") Then
                                 callingConventionField = values(i)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "SetLastError") Then
                                 setLastErrorField = values(i)
                             End If
                         Next
 
                         If entry = String.Empty Then entry = mthd.Name
                         For i As Integer = 0 To Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences.Count - 1
                             If Helper.CompareNameOrdinal(Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences(i).Name, modRefName) Then
                                 modRef = Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences(i)
                                 Exit For
                             End If
                         Next
                         If modRef Is Nothing Then
                             modRef = New Mono.Cecil.ModuleReference(modRefName)
                             Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences.Add(modRef)
                         End If
                         mthd.CecilBuilder.PInvokeInfo = New Mono.Cecil.PInvokeInfo(0, entry, modRef)
 
                         Dim charset As System.Runtime.InteropServices.CharSet
                         If charSetField.HasValue Then
                             charset = DirectCast(charSetField.Value.Argument.Value, System.Runtime.InteropServices.CharSet)
                         Else
                             charset = Runtime.InteropServices.CharSet.Auto
                         End If
                         Select Case charset
                             Case Runtime.InteropServices.CharSet.Ansi
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetAnsi = True
                             Case Runtime.InteropServices.CharSet.Auto
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetAuto = True
                             Case Runtime.InteropServices.CharSet.None
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetNotSpec = True
                             Case Runtime.InteropServices.CharSet.Unicode
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetUnicode = True
                             Case Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Invalid charset
                         End Select
 
                         Dim callingconv As System.Runtime.InteropServices.CallingConvention
                         If callingConventionField.HasValue Then
                             callingconv = DirectCast(callingConventionField.Value.Argument.Value, System.Runtime.InteropServices.CallingConvention)
                         Else
                             callingconv = Runtime.InteropServices.CallingConvention.Winapi
                         End If
                         Select Case callingconv
                             Case Runtime.InteropServices.CallingConvention.Cdecl
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvCdecl = True
                             Case Runtime.InteropServices.CallingConvention.FastCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvFastcall = True
                             Case Runtime.InteropServices.CallingConvention.StdCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvStdCall = True
                             Case Runtime.InteropServices.CallingConvention.ThisCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvThiscall = True
                             Case Runtime.InteropServices.CallingConvention.Winapi
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvWinapi = True
                             Case Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Invalid calling convention
                         End Select
 
                         Dim setlasterror As Boolean = True
                         If setLastErrorField.HasValue Then
                             setlasterror = DirectCast(setLastErrorField.Value.Argument.Value, Boolean)
                         End If
                         mthd.CecilBuilder.PInvokeInfo.SupportsLastError = setlasterror
                         mthd.CecilBuilder.PInvokeInfo.IsNoMangle = True
                     Else
                         mthd.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf ctro IsNot Nothing Then
                     ctro.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf fld IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_MarshalAsAttribute) Then
                         fld.FieldBuilder.MarshalInfo = New MarshalInfo(CType(CecilBuilder.ConstructorArguments(0).Value, Mono.Cecil.NativeType))
                         fld.FieldBuilder.Attributes = fld.FieldBuilder.Attributes Or Mono.Cecil.FieldAttributes.HasFieldMarshal
                     ElseIf Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_FieldOffsetAttribute) Then
                         fld.FieldBuilder.Offset = CType(CecilBuilder.ConstructorArguments(0).Value, Integer)
                     Else
                         fld.FieldBuilder.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf prop IsNot Nothing Then
                     prop.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf param IsNot Nothing Then
                     param.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf evt IsNot Nothing Then
                     evt.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 End If
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeCache.vb" startline="406" endline="840">
<![CDATA[
 
 End Class
 
 'START SRE
 '' 
 ' Visual Basic.Net Compiler
 ' Copyright (C) 2004 - 2010 Rolf Bjarne Kvinge, RKvinge@novell.com
 ' 
 ' This library is free software; you can redistribute it and/or
 ' modify it under the terms of the GNU Lesser General Public
 ' License as published by the Free Software Foundation; either
 ' version 2.1 of the License, or (at your option) any later version.
 ' 
 ' This library is distributed in the hope that it will be useful,
 ' but WITHOUT ANY WARRANTY; without even the implied warranty of
 ' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ' Lesser General Public License for more details.
 ' 
 ' You should have received a copy of the GNU Lesser General Public
 ' License along with this library; if not, write to the Free Software
 ' Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 ' 
 Public Partial Class CecilTypeCache
     Public System_Boolean As Mono.Cecil.TypeDefinition
     Public System_Boolean_Array As Mono.Cecil.TypeReference
     Public System_Byte As Mono.Cecil.TypeDefinition
     Public System_Byte_Array As Mono.Cecil.TypeReference
     Public System_Char As Mono.Cecil.TypeDefinition
     Public System_Char_Array As Mono.Cecil.TypeReference
     Public System_DateTime As Mono.Cecil.TypeDefinition
     Public System_Decimal As Mono.Cecil.TypeDefinition
     Public System_Double As Mono.Cecil.TypeDefinition
     Public System_Int32 As Mono.Cecil.TypeDefinition
     Public System_Int64 As Mono.Cecil.TypeDefinition
     Public System_Object As Mono.Cecil.TypeDefinition
     Public System_Object_Array As Mono.Cecil.TypeReference
     Public System_Object_ByRef As Mono.Cecil.TypeReference
     Public System_Int16 As Mono.Cecil.TypeDefinition
     Public System_Single As Mono.Cecil.TypeDefinition
     Public System_String As Mono.Cecil.TypeDefinition
     Public System_String_ByRef As Mono.Cecil.TypeReference
     Public System_String_Array As Mono.Cecil.TypeReference
     Public System_String__ctor_Array As Mono.Cecil.MethodDefinition
     Public System_SByte As Mono.Cecil.TypeDefinition
     Public System_UInt16 As Mono.Cecil.TypeDefinition
     Public System_UInt32 As Mono.Cecil.TypeDefinition
     Public System_UInt64 As Mono.Cecil.TypeDefinition
     Public System_Int32_Array As Mono.Cecil.TypeReference
     Public System_Enum As Mono.Cecil.TypeDefinition
     Public System_ValueType As Mono.Cecil.TypeDefinition
     Public System_Delegate As Mono.Cecil.TypeDefinition
     Public System_MulticastDelegate As Mono.Cecil.TypeDefinition
     Public System_AsyncCallback As Mono.Cecil.TypeDefinition
     Public System_IAsyncResult As Mono.Cecil.TypeDefinition
     Public System_Collections_IEnumerator As Mono.Cecil.TypeDefinition
     Public System_Collections_IEnumerator__get_Current As Mono.Cecil.MethodDefinition
     Public System_Collections_IEnumerator__MoveNext As Mono.Cecil.MethodDefinition
     Public System_Collections_IEnumerable As Mono.Cecil.TypeDefinition
     Public System_Collections_IEnumerable__GetEnumerator As Mono.Cecil.MethodDefinition
     Public System_IDisposable As Mono.Cecil.TypeDefinition
     Public System_IDisposable__Dispose As Mono.Cecil.MethodDefinition
     Public System_RuntimeTypeHandle As Mono.Cecil.TypeDefinition
     Public System_Type As Mono.Cecil.TypeDefinition
     Public System_Type_Array As Mono.Cecil.TypeReference
     Public System_Type__GetTypeFromHandle_RuntimeTypeHandle As Mono.Cecil.MethodDefinition
     Public System_Void As Mono.Cecil.TypeDefinition
     Public System_Exception As Mono.Cecil.TypeDefinition
     Public System_Array As Mono.Cecil.TypeDefinition
     Public System_DBNull As Mono.Cecil.TypeDefinition
     Public System_SerializableAttribute As Mono.Cecil.TypeDefinition
     Public System_Array__SetValue As Mono.Cecil.MethodDefinition
     Public System_Array__GetValue As Mono.Cecil.MethodDefinition
     Public System_Array__CreateInstance As Mono.Cecil.MethodDefinition
     Public System_Activator As Mono.Cecil.TypeDefinition
     Public System_Activator__CreateInstance As Mono.Cecil.MethodDefinition
     Public System_ArgumentException As Mono.Cecil.TypeDefinition
     Public System_Collections_Generic_IList1 As Mono.Cecil.TypeDefinition
     Public System_Collections_Generic_ICollection1 As Mono.Cecil.TypeDefinition
     Public System_Collections_Generic_IEnumerable1 As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyVersionAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyProductAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyCompanyAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyCopyrightAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyTrademarkAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyKeyNameAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyKeyFileAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_AssemblyDelaySignAttribute As Mono.Cecil.TypeDefinition
     Public System_Diagnostics_ConditionalAttribute As Mono.Cecil.TypeDefinition
     Public System_Diagnostics_DebuggableAttribute As Mono.Cecil.TypeDefinition
     Public System_Diagnostics_DebuggableAttribute_DebuggingModes As Mono.Cecil.TypeDefinition
     Public System_Diagnostics_DebuggableAttribute__ctor_DebuggingModes As Mono.Cecil.MethodDefinition
     Public System_ParamArrayAttribute As Mono.Cecil.TypeDefinition
     Public System_ParamArrayAttribute__ctor As Mono.Cecil.MethodDefinition
     Public System_Nullable1 As Mono.Cecil.TypeDefinition
     Public System_Nullable1__get_HasValue As Mono.Cecil.MethodDefinition
     Public System_Nullable1__GetValueOrDefault As Mono.Cecil.MethodDefinition
     Public System_Runtime_CompilerServices_RuntimeHelpers As Mono.Cecil.TypeDefinition
     Public System_STAThreadAttribute As Mono.Cecil.TypeDefinition
     Public System_STAThreadAttribute__ctor As Mono.Cecil.MethodDefinition
     Public System_IntPtr As Mono.Cecil.TypeDefinition
     Public System_Runtime_CompilerServices_DateTimeConstantAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor_Int64 As Mono.Cecil.MethodDefinition
     Public System_DateTime__ctor_Int64 As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_Int32 As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_Int64 As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_Double As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_Single As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_UInt64 As Mono.Cecil.MethodDefinition
     Public System_Decimal__ctor_Int32_Int32_Int32_Boolean_Byte As Mono.Cecil.MethodDefinition
     Public System_Decimal__Zero As Mono.Cecil.FieldDefinition
     Public System_Decimal__One As Mono.Cecil.FieldDefinition
     Public System_Decimal__MinusOne As Mono.Cecil.FieldDefinition
     Public System_Runtime_CompilerServices_DecimalConstantAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_UInt32_UInt32_UInt32 As Mono.Cecil.MethodDefinition
     Public System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_Int32_Int32_Int32 As Mono.Cecil.MethodDefinition
     Public System_Runtime_CompilerServices_AccessedThroughPropertyAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_CompilerServices_AccessedThroughPropertyAttribute__ctor_String As Mono.Cecil.MethodDefinition
     Public System_Decimal__Compare_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_DateTime__Compare_DateTime_DateTime As Mono.Cecil.MethodDefinition
     Public System_Decimal__Add_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_Decimal__Subtract_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_Decimal__Divide_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_Decimal__Multiply_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_Decimal__Remainder_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public System_Decimal__Negate_Decimal As Mono.Cecil.MethodDefinition
     Public System_Reflection_DefaultMemberAttribute As Mono.Cecil.TypeDefinition
     Public System_Reflection_DefaultMemberAttribute__ctor_String As Mono.Cecil.MethodDefinition
     Public System_Convert As Mono.Cecil.TypeDefinition
     Public System_Convert__ToSingle_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToDouble_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToBoolean_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToByte_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToSByte_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToInt16_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToUInt16_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToInt32_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToUInt32_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToInt64_Decimal As Mono.Cecil.MethodDefinition
     Public System_Convert__ToUInt64_Decimal As Mono.Cecil.MethodDefinition
     Public System_String__Concat_String_String As Mono.Cecil.MethodDefinition
     Public System_Diagnostics_Debugger As Mono.Cecil.TypeDefinition
     Public System_Diagnostics_Debugger__Break As Mono.Cecil.MethodDefinition
     Public System_Reflection_Missing As Mono.Cecil.TypeDefinition
     Public System_Reflection_Missing__Value As Mono.Cecil.FieldDefinition
     Public System_Threading_Monitor As Mono.Cecil.TypeDefinition
     Public System_Threading_Monitor__Enter_Object As Mono.Cecil.MethodDefinition
     Public System_Threading_Monitor__Exit_Object As Mono.Cecil.MethodDefinition
     Public System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object As Mono.Cecil.MethodDefinition
     Public System_Math As Mono.Cecil.TypeDefinition
     Public System_Math__Round_Double As Mono.Cecil.MethodDefinition
     Public System_Math__Pow_Double_Double As Mono.Cecil.MethodDefinition
     Public System_Runtime_InteropServices_DllImportAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_InteropServices_MarshalAsAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_InteropServices_StructLayoutAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_InteropServices_FieldOffsetAttribute As Mono.Cecil.TypeDefinition
     Public System_Runtime_InteropServices_CoClassAttribute As Mono.Cecil.TypeDefinition
     Public System_Security_Permissions_SecurityAttribute As Mono.Cecil.TypeDefinition
     Public System_Windows_Forms_Form As Mono.Cecil.TypeDefinition
     Public System_Windows_Forms_Application As Mono.Cecil.TypeDefinition
     Public System_Windows_Forms_Application__Run As Mono.Cecil.MethodDefinition
     Public System_Delegate__Combine As Mono.Cecil.MethodDefinition
     Public System_Delegate__Remove As Mono.Cecil.MethodDefinition
     Public MS_VB_CompareMethod As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_Conversions As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_ProjectData As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_LikeOperator As Mono.Cecil.TypeDefinition
     Public MS_VB_Strings As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_StringType As Mono.Cecil.TypeDefinition
     Public MS_VB_MyGroupCollectionAttribute As Mono.Cecil.TypeDefinition
     Public MS_VB_CallType As Mono.Cecil.TypeDefinition
     Public MS_VB_Information As Mono.Cecil.TypeDefinition
     Public MS_VB_Information__IsNumeric As Mono.Cecil.MethodDefinition
     Public MS_VB_Information__SystemTypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_Information__TypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_Information__VbTypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_Interaction As Mono.Cecil.TypeDefinition
     Public MS_VB_Interaction__CallByName As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Versioned As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_Versioned__IsNumeric As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Versioned__SystemTypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Versioned__TypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Versioned__VbTypeName As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Versioned__CallByName As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_StandardModuleAttribute As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_Operators As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_ObjectFlowControl As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_Utils As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_OptionCompareAttribute As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_OptionTextAttribute As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_StaticLocalInitFlag As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_StaticLocalInitFlag__State As Mono.Cecil.FieldDefinition
     Public MS_VB_CS_StaticLocalInitFlag__ctor As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_DesignerGeneratedAttribute As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_IncompleteInitialization As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_NewLateBinding As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_LateBinding As Mono.Cecil.TypeDefinition
     Public MS_VB_CS_IncompleteInitialization__ctor As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_NewLateBinding__LateSet_Object_Type_String_Array_Array_Array As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_NewLateBinding__LateIndexSet_Object_Array_Array As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_NewLateBinding__LateCall_Object_Type_String_Array_Array_Array_Array_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ProjectData__EndApp As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ProjectData__CreateProjectError_Int32 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ProjectData__ClearProjectError As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ProjectData__SetProjectError_Exception As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ProjectData__SetProjectError_Exception_Int32 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToBoolean_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToChar_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDate_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToByte_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToSByte_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToShort_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToUShort_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToInteger_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToUInteger_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToLong_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToULong_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToSingle_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDouble_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDecimal_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToBoolean_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToChar_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDate_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToByte_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToSByte_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToShort_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToUShort_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToInteger_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToUInteger_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToLong_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToULong_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToSingle_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDouble_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDecimal_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToDecimal_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Decimal As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Char As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_DateTime As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Byte As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Int32 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_UInt32 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Int64 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_UInt64 As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Single As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Double As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToString_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToGenericParameter_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ChangeType_Object_Type As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Conversions__ToCharArrayRankOne_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_LikeOperator__LikeString_String_String_CompareMethod As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_LikeOperator__LikeObject_Object_Object_CompareMethod As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_StringType__MidStmtStr_String_Int32_Int32_String As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl__CheckForSyncLockOnValueType_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl__ForLoopInitObj_Object_Object_Object_Object_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckDec_Decimal_Decimal_Decimal As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckObj_Object_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckR4_Single_Single_Single As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckR8_Double_Double_Double As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Utils__CopyArray_Array_Array As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectNotEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectGreater_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectGreaterEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectLess_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConditionalCompareObjectLessEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareString_String_String_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ConcatenateObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__AddObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__AndObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__DivideObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ExponentObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__IntDivideObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__LeftShiftObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__ModObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__MultiplyObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__NegateObject_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__NotObject_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__OrObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__PlusObject_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__RightShiftObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__SubtractObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__XorObject_Object_Object As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__LikeObject_Object_Object_CompareMethod As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__LikeString_String_String_CompareMethod As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectNotEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectGreater_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectGreaterEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectLess_Object_Object_Boolean As Mono.Cecil.MethodDefinition
     Public MS_VB_CS_Operators__CompareObjectLessEqual_Object_Object_Boolean As Mono.Cecil.MethodDefinition
 
     Protected Overrides Sub InitInternal ()
         System_Boolean = [GetType](mscorlib, "System.Boolean")
         System_Boolean_Array = GetArrayType(System_Boolean)
         System_Byte = [GetType](mscorlib, "System.Byte")
         System_Byte_Array = GetArrayType(System_Byte)
         System_Char = [GetType](mscorlib, "System.Char")
         System_Char_Array = GetArrayType(System_Char)
         System_DateTime = [GetType](mscorlib, "System.DateTime")
         System_Decimal = [GetType](mscorlib, "System.Decimal")
         System_Double = [GetType](mscorlib, "System.Double")
         System_Int32 = [GetType](mscorlib, "System.Int32")
         System_Int64 = [GetType](mscorlib, "System.Int64")
         System_Object = [GetType](mscorlib, "System.Object")
         System_Object_Array = GetArrayType(System_Object)
         System_Object_ByRef = GetByRefType(System_Object)
         System_Int16 = [GetType](mscorlib, "System.Int16")
         System_Single = [GetType](mscorlib, "System.Single")
         System_String = [GetType](mscorlib, "System.String")
         System_String_ByRef = GetByRefType(System_String)
         System_String_Array = GetArrayType(System_String)
         System_String__ctor_Array = GetConstructor(System_String, System_Char_Array)
         System_SByte = [GetType](mscorlib, "System.SByte")
         System_UInt16 = [GetType](mscorlib, "System.UInt16")
         System_UInt32 = [GetType](mscorlib, "System.UInt32")
         System_UInt64 = [GetType](mscorlib, "System.UInt64")
         System_Int32_Array = GetArrayType(System_Int32)
         System_Enum = [GetType](mscorlib, "System.Enum")
         System_ValueType = [GetType](mscorlib, "System.ValueType")
         System_Delegate = [GetType](mscorlib, "System.Delegate")
         System_MulticastDelegate = [GetType](mscorlib, "System.MulticastDelegate")
         System_AsyncCallback = [GetType](mscorlib, "System.AsyncCallback")
         System_IAsyncResult = [GetType](mscorlib, "System.IAsyncResult")
         System_Collections_IEnumerator = [GetType](mscorlib, "System.Collections.IEnumerator")
         System_Collections_IEnumerator__get_Current = GetMethod(System_Collections_IEnumerator, "get_Current")
         System_Collections_IEnumerator__MoveNext = GetMethod(System_Collections_IEnumerator, "MoveNext")
         System_Collections_IEnumerable = [GetType](mscorlib, "System.Collections.IEnumerable")
         System_Collections_IEnumerable__GetEnumerator = GetMethod(System_Collections_IEnumerable, "GetEnumerator")
         System_IDisposable = [GetType](mscorlib, "System.IDisposable")
         System_IDisposable__Dispose = GetMethod(System_IDisposable, "Dispose")
         System_RuntimeTypeHandle = [GetType](mscorlib, "System.RuntimeTypeHandle")
         System_Type = [GetType](mscorlib, "System.Type")
         System_Type_Array = GetArrayType(System_Type)
         System_Type__GetTypeFromHandle_RuntimeTypeHandle = GetMethod(System_Type, "GetTypeFromHandle", System_RuntimeTypeHandle)
         System_Void = [GetType](mscorlib, "System.Void")
         System_Exception = [GetType](mscorlib, "System.Exception")
         System_Array = [GetType](mscorlib, "System.Array")
         System_DBNull = [GetType](mscorlib, "System.DBNull")
         System_SerializableAttribute = [GetType](mscorlib, "System.SerializableAttribute")
         System_Array__SetValue = GetMethod(System_Array, "SetValue", System_Object, System_Int32_Array)
         System_Array__GetValue = GetMethod(System_Array, "GetValue", System_Int32_Array)
         System_Array__CreateInstance = GetMethod(System_Array, "CreateInstance", System_Type, System_Int32_Array)
         System_Activator = [GetType](mscorlib, "System.Activator")
         System_Activator__CreateInstance = GetMethod(System_Activator, "CreateInstance")
         System_ArgumentException = [GetType](mscorlib, "System.ArgumentException")
         System_Collections_Generic_IList1 = [GetType](mscorlib, "System.Collections.Generic.IList`1")
         System_Collections_Generic_ICollection1 = [GetType](mscorlib, "System.Collections.Generic.ICollection`1")
         System_Collections_Generic_IEnumerable1 = [GetType](mscorlib, "System.Collections.Generic.IEnumerable`1")
         System_Reflection_AssemblyVersionAttribute = [GetType](mscorlib, "System.Reflection.AssemblyVersionAttribute")
         System_Reflection_AssemblyProductAttribute = [GetType](mscorlib, "System.Reflection.AssemblyProductAttribute")
         System_Reflection_AssemblyCompanyAttribute = [GetType](mscorlib, "System.Reflection.AssemblyCompanyAttribute")
         System_Reflection_AssemblyCopyrightAttribute = [GetType](mscorlib, "System.Reflection.AssemblyCopyrightAttribute")
         System_Reflection_AssemblyTrademarkAttribute = [GetType](mscorlib, "System.Reflection.AssemblyTrademarkAttribute")
         System_Reflection_AssemblyKeyNameAttribute = [GetType](mscorlib, "System.Reflection.AssemblyKeyNameAttribute")
         System_Reflection_AssemblyKeyFileAttribute = [GetType](mscorlib, "System.Reflection.AssemblyKeyFileAttribute")
         System_Reflection_AssemblyDelaySignAttribute = [GetType](mscorlib, "System.Reflection.AssemblyDelaySignAttribute")
         System_Diagnostics_ConditionalAttribute = [GetType](mscorlib, "System.Diagnostics.ConditionalAttribute")
         System_Diagnostics_DebuggableAttribute = [GetType](mscorlib, "System.Diagnostics.DebuggableAttribute")
         System_Diagnostics_DebuggableAttribute_DebuggingModes = [GetType](System_Diagnostics_DebuggableAttribute, "DebuggingModes")
         System_Diagnostics_DebuggableAttribute__ctor_DebuggingModes = GetConstructor(System_Diagnostics_DebuggableAttribute, System_Diagnostics_DebuggableAttribute_DebuggingModes)
         System_ParamArrayAttribute = [GetType](mscorlib, "System.ParamArrayAttribute")
         System_ParamArrayAttribute__ctor = GetConstructor(System_ParamArrayAttribute)
         System_Nullable1 = [GetType](mscorlib, "System.Nullable`1")
         System_Nullable1__get_HasValue = GetMethod(System_Nullable1, "get_HasValue")
         System_Nullable1__GetValueOrDefault = GetMethod(System_Nullable1, "GetValueOrDefault")
         System_Runtime_CompilerServices_RuntimeHelpers = [GetType](mscorlib, "System.Runtime.CompilerServices.RuntimeHelpers")
         System_STAThreadAttribute = [GetType](mscorlib, "System.STAThreadAttribute")
         System_STAThreadAttribute__ctor = GetConstructor(System_STAThreadAttribute)
         System_IntPtr = [GetType](mscorlib, "System.IntPtr")
         System_Runtime_CompilerServices_DateTimeConstantAttribute = [GetType](mscorlib, "System.Runtime.CompilerServices.DateTimeConstantAttribute")
         System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor_Int64 = GetConstructor(System_Runtime_CompilerServices_DateTimeConstantAttribute, System_Int64)
         System_DateTime__ctor_Int64 = GetConstructor(System_DateTime, System_Int64)
         System_Decimal__ctor_Int32 = GetConstructor(System_Decimal, System_Int32)
         System_Decimal__ctor_Int64 = GetConstructor(System_Decimal, System_Int64)
         System_Decimal__ctor_Double = GetConstructor(System_Decimal, System_Double)
         System_Decimal__ctor_Single = GetConstructor(System_Decimal, System_Single)
         System_Decimal__ctor_UInt64 = GetConstructor(System_Decimal, System_UInt64)
         System_Decimal__ctor_Int32_Int32_Int32_Boolean_Byte = GetConstructor(System_Decimal, System_Int32, System_Int32, System_Int32, System_Boolean, System_Byte)
         System_Decimal__Zero = GetField(System_Decimal, "Zero")
         System_Decimal__One = GetField(System_Decimal, "One")
         System_Decimal__MinusOne = GetField(System_Decimal, "MinusOne")
         System_Runtime_CompilerServices_DecimalConstantAttribute = [GetType](mscorlib, "System.Runtime.CompilerServices.DecimalConstantAttribute")
         System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_UInt32_UInt32_UInt32 = GetConstructor(System_Runtime_CompilerServices_DecimalConstantAttribute, System_Byte, System_Byte, System_UInt32, System_UInt32, System_UInt32)
         System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_Int32_Int32_Int32 = GetConstructor(System_Runtime_CompilerServices_DecimalConstantAttribute, System_Byte, System_Byte, System_Int32, System_Int32, System_Int32)
         System_Runtime_CompilerServices_AccessedThroughPropertyAttribute = [GetType](mscorlib, "System.Runtime.CompilerServices.AccessedThroughPropertyAttribute")
         System_Runtime_CompilerServices_AccessedThroughPropertyAttribute__ctor_String = GetConstructor(System_Runtime_CompilerServices_AccessedThroughPropertyAttribute, System_String)
         System_Decimal__Compare_Decimal_Decimal = GetMethod(System_Decimal, "Compare", System_Decimal, System_Decimal)
         System_DateTime__Compare_DateTime_DateTime = GetMethod(System_DateTime, "Compare", System_DateTime, System_DateTime)
         System_Decimal__Add_Decimal_Decimal = GetMethod(System_Decimal, "Add", System_Decimal, System_Decimal)
         System_Decimal__Subtract_Decimal_Decimal = GetMethod(System_Decimal, "Subtract", System_Decimal, System_Decimal)
         System_Decimal__Divide_Decimal_Decimal = GetMethod(System_Decimal, "Divide", System_Decimal, System_Decimal)
         System_Decimal__Multiply_Decimal_Decimal = GetMethod(System_Decimal, "Multiply", System_Decimal, System_Decimal)
         System_Decimal__Remainder_Decimal_Decimal = GetMethod(System_Decimal, "Remainder", System_Decimal, System_Decimal)
         System_Decimal__Negate_Decimal = GetMethod(System_Decimal, "Negate", System_Decimal)
         System_Reflection_DefaultMemberAttribute = [GetType](mscorlib, "System.Reflection.DefaultMemberAttribute")
         System_Reflection_DefaultMemberAttribute__ctor_String = GetConstructor(System_Reflection_DefaultMemberAttribute, System_String)
         System_Convert = [GetType](mscorlib, "System.Convert")
         System_Convert__ToSingle_Decimal = GetMethod(System_Convert, "ToSingle", System_Decimal)
         System_Convert__ToDouble_Decimal = GetMethod(System_Convert, "ToDouble", System_Decimal)
         System_Convert__ToBoolean_Decimal = GetMethod(System_Convert, "ToBoolean", System_Decimal)
         System_Convert__ToByte_Decimal = GetMethod(System_Convert, "ToByte", System_Decimal)
         System_Convert__ToSByte_Decimal = GetMethod(System_Convert, "ToSByte", System_Decimal)
         System_Convert__ToInt16_Decimal = GetMethod(System_Convert, "ToInt16", System_Decimal)
         System_Convert__ToUInt16_Decimal = GetMethod(System_Convert, "ToUInt16", System_Decimal)
         System_Convert__ToInt32_Decimal = GetMethod(System_Convert, "ToInt32", System_Decimal)
         System_Convert__ToUInt32_Decimal = GetMethod(System_Convert, "ToUInt32", System_Decimal)
         System_Convert__ToInt64_Decimal = GetMethod(System_Convert, "ToInt64", System_Decimal)
         System_Convert__ToUInt64_Decimal = GetMethod(System_Convert, "ToUInt64", System_Decimal)
         System_String__Concat_String_String = GetMethod(System_String, "Concat", System_String, System_String)
         System_Diagnostics_Debugger = [GetType](mscorlib, "System.Diagnostics.Debugger")
         System_Diagnostics_Debugger__Break = GetMethod(System_Diagnostics_Debugger, "Break")
         System_Reflection_Missing = [GetType](mscorlib, "System.Reflection.Missing")
         System_Reflection_Missing__Value = GetField(System_Reflection_Missing, "Value")
         System_Threading_Monitor = [GetType](mscorlib, "System.Threading.Monitor")
         System_Threading_Monitor__Enter_Object = GetMethod(System_Threading_Monitor, "Enter", System_Object)
         System_Threading_Monitor__Exit_Object = GetMethod(System_Threading_Monitor, "Exit", System_Object)
         System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object = GetMethod(System_Runtime_CompilerServices_RuntimeHelpers, "GetObjectValue", System_Object)
         System_Math = [GetType](mscorlib, "System.Math")
         System_Math__Round_Double = GetMethod(System_Math, "Round", System_Double)
         System_Math__Pow_Double_Double = GetMethod(System_Math, "Pow", System_Double, System_Double)
         System_Runtime_InteropServices_DllImportAttribute = [GetType](mscorlib, "System.Runtime.InteropServices.DllImportAttribute")
         System_Runtime_InteropServices_MarshalAsAttribute = [GetType](mscorlib, "System.Runtime.InteropServices.MarshalAsAttribute")
         System_Runtime_InteropServices_StructLayoutAttribute = [GetType](mscorlib, "System.Runtime.InteropServices.StructLayoutAttribute")
         System_Runtime_InteropServices_FieldOffsetAttribute = [GetType](mscorlib, "System.Runtime.InteropServices.FieldOffsetAttribute")
         System_Runtime_InteropServices_CoClassAttribute = [GetType](mscorlib, "System.Runtime.InteropServices.CoClassAttribute")
         System_Security_Permissions_SecurityAttribute = [GetType](mscorlib, "System.Security.Permissions.SecurityAttribute")
         System_Windows_Forms_Form = [GetType](winforms, "System.Windows.Forms.Form")
         System_Windows_Forms_Application = [GetType](winforms, "System.Windows.Forms.Application")
         System_Windows_Forms_Application__Run = GetMethod(System_Windows_Forms_Application, "Run", System_Windows_Forms_Form)
         System_Delegate__Combine = GetMethod(System_Delegate, "Combine", System_Delegate, System_Delegate)
         System_Delegate__Remove = GetMethod(System_Delegate, "Remove", System_Delegate, System_Delegate)
     End Sub
]]>
</clone_fragment>
</clone_pair>
<clone_pair groupid="1896" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="970" endline="1108">
<![CDATA[
 
 		private int WriteFatHeaderAndCode(ByteBuffer bb, ref int localVarSigTok, bool initLocals)
 		{
 			// fat headers require 4-byte alignment
 			bb.Align(4);
 			int rva = bb.Position;
 
 			if (locals.Count != 0)
 			{
 				ByteBuffer localVarSig = new ByteBuffer(locals.Count + 2);
 				Signature.WriteLocalVarSig(moduleBuilder, localVarSig, locals);
 				localVarSigTok = 0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(localVarSig));
 			}
 
 			const byte CorILMethod_FatFormat = 0x03;
 			const byte CorILMethod_MoreSects = 0x08;
 			const byte CorILMethod_InitLocals = 0x10;
 
 			short flagsAndSize = (short)(CorILMethod_FatFormat | (3 << 12));
 			if (initLocals)
 			{
 				flagsAndSize |= CorILMethod_InitLocals;
 			}
 
 			if (exceptions.Count > 0)
 			{
 				flagsAndSize |= CorILMethod_MoreSects;
 			}
 
 			bb.Write(flagsAndSize);
 			bb.Write(maxStack);
 			bb.Write(code.Length);
 			bb.Write(localVarSigTok);
 
 			WriteCode(bb);
 
 			if (exceptions.Count > 0)
 			{
 				bb.Align(4);
 
 				bool fat = false;
 				foreach (ExceptionBlock block in exceptions)
 				{
 					if (block.tryOffset > 65535 || block.tryLength > 255 || block.handlerOffset > 65535 || block.handlerLength > 255)
 					{
 						fat = true;
 						break;
 					}
 				}
 				foreach (ExceptionBlock block in exceptions)
 				{
 					if (block.tryOffset > 65535 || block.tryLength > 255 || block.handlerOffset > 65535 || block.handlerLength > 255)
 					{
 						fat = true;
 						break;
 					}
 				}
 				exceptions.Sort(exceptions[0]);
 				if (exceptions.Count * 12 + 4 > 255)
 				{
 					fat = true;
 				}
 				const byte CorILMethod_Sect_EHTable = 0x1;
 				const byte CorILMethod_Sect_FatFormat = 0x40;
 				const short COR_ILEXCEPTION_CLAUSE_EXCEPTION = 0x0000;
 				const short COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001;
 				const short COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002;
 				const short COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004;
 
 				if (fat)
 				{
 					bb.Write((byte)(CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat));
 					int dataSize = exceptions.Count * 24 + 4;
 					bb.Write((byte)dataSize);
 					bb.Write((short)(dataSize >> 8));
 					foreach (ExceptionBlock block in exceptions)
 					{
 						if (block.exceptionType == FAULT)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FAULT);
 						}
 						else if (block.filterOffset != 0)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FILTER);
 						}
 						else if (block.exceptionType != null)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_EXCEPTION);
 						}
 						else
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FINALLY);
 						}
 						bb.Write(block.tryOffset);
 						bb.Write(block.tryLength);
 						bb.Write(block.handlerOffset);
 						bb.Write(block.handlerLength);
 						if (block.exceptionType != null && block.exceptionType != FAULT)
 						{
 							bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
 						}
 						else
 						{
 							bb.Write(block.filterOffset);
 						}
 					}
 					foreach (ExceptionBlock block in exceptions)
 					{
 						if (block.exceptionType == FAULT)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FAULT);
 						}
 						else if (block.filterOffset != 0)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FILTER);
 						}
 						else if (block.exceptionType != null)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_EXCEPTION);
 						}
 						else
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FINALLY);
 						}
 						bb.Write(block.tryOffset);
 						bb.Write(block.tryLength);
 						bb.Write(block.handlerOffset);
 						bb.Write(block.handlerLength);
 						if (block.exceptionType != null && block.exceptionType != FAULT)
 						{
 							bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
 						}
 						else
 						{
 							bb.Write(block.filterOffset);
 						}
 					}
 				}
 				else
 				{
 					bb.Write(CorILMethod_Sect_EHTable);
 					bb.Write((byte)(exceptions.Count * 12 + 4));
 					bb.Write((short)0);
 					foreach (ExceptionBlock block in exceptions)
 					{
 						if (block.exceptionType == FAULT)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FAULT);
 						}
 						else if (block.filterOffset != 0)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FILTER);
 						}
 						else if (block.exceptionType != null)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_EXCEPTION);
 						}
 						else
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FINALLY);
 						}
 						bb.Write((short)block.tryOffset);
 						bb.Write((byte)block.tryLength);
 						bb.Write((short)block.handlerOffset);
 						bb.Write((byte)block.handlerLength);
 						if (block.exceptionType != null && block.exceptionType != FAULT)
 						{
 							bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
 						}
 						else
 						{
 							bb.Write(block.filterOffset);
 						}
 					}
 					foreach (ExceptionBlock block in exceptions)
 					{
 						if (block.exceptionType == FAULT)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FAULT);
 						}
 						else if (block.filterOffset != 0)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FILTER);
 						}
 						else if (block.exceptionType != null)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_EXCEPTION);
 						}
 						else
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FINALLY);
 						}
 						bb.Write((short)block.tryOffset);
 						bb.Write((byte)block.tryLength);
 						bb.Write((short)block.handlerOffset);
 						bb.Write((byte)block.handlerLength);
 						if (block.exceptionType != null && block.exceptionType != FAULT)
 						{
 							bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
 						}
 						else
 						{
 							bb.Write(block.filterOffset);
 						}
 					}
 				}
 			}
 			return rva;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="260" endline="402">
<![CDATA[
 
 		public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
 		{
 			ModuleBuilder manifestModule = null;
 
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.PopulatePropertyAndEventTables();
 
 				if (manifestModule == null
 					&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
 				{
 					manifestModule = moduleBuilder;
 				}
 			}
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.PopulatePropertyAndEventTables();
 
 				if (manifestModule == null
 					&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
 				{
 					manifestModule = moduleBuilder;
 				}
 			}
 
 			if (manifestModule == null)
 			{
 				manifestModule = DefineDynamicModule("RefEmit_OnDiskManifestModule", assemblyFileName, false);
 			}
 
 			AssemblyTable.Record assemblyRecord = new AssemblyTable.Record();
 			assemblyRecord.HashAlgId = (int)hashAlgorithm;
 			assemblyRecord.Name = manifestModule.Strings.Add(name);
 			assemblyRecord.MajorVersion = majorVersion;
 			assemblyRecord.MinorVersion = minorVersion;
 			assemblyRecord.BuildNumber = buildVersion;
 			assemblyRecord.RevisionNumber = revisionVersion;
 			if (publicKey != null)
 			{
 				assemblyRecord.PublicKey = manifestModule.Blobs.Add(ByteBuffer.Wrap(publicKey));
 				assemblyRecord.Flags = (int)(flags | AssemblyNameFlags.PublicKey);
 			}
 			else
 			{
 				assemblyRecord.Flags = (int)(flags & ~AssemblyNameFlags.PublicKey);
 			}
 			if (culture != null)
 			{
 				assemblyRecord.Culture = manifestModule.Strings.Add(culture);
 			}
 			int token = 0x20000000 + manifestModule.AssemblyTable.AddRecord(assemblyRecord);
 
 #pragma warning disable 618
 			// this values are obsolete, but we already know that so we disable the warning
 			System.Security.Permissions.SecurityAction requestMinimum = System.Security.Permissions.SecurityAction.RequestMinimum;
 			System.Security.Permissions.SecurityAction requestOptional = System.Security.Permissions.SecurityAction.RequestOptional;
 			System.Security.Permissions.SecurityAction requestRefuse = System.Security.Permissions.SecurityAction.RequestRefuse;
 #pragma warning restore 618
 			if (requiredPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestMinimum, requiredPermissions);
 			}
 			if (optionalPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestOptional, optionalPermissions);
 			}
 			if (refusedPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestRefuse, refusedPermissions);
 			}
 
 			if (versionInfo != null)
 			{
 				versionInfo.SetName(GetName());
 				versionInfo.SetFileName(assemblyFileName);
 				foreach (CustomAttributeBuilder cab in customAttributes)
 				{
 					// .NET doesn't support copying blob custom attributes into the version info
 					if (!cab.HasBlob)
 					{
 						versionInfo.SetAttribute(cab);
 					}
 				}
 				foreach (CustomAttributeBuilder cab in customAttributes)
 				{
 					// .NET doesn't support copying blob custom attributes into the version info
 					if (!cab.HasBlob)
 					{
 						versionInfo.SetAttribute(cab);
 					}
 				}
 				ByteBuffer versionInfoData = new ByteBuffer(512);
 				versionInfo.Write(versionInfoData);
 				if (unmanagedResources == null)
 				{
 					unmanagedResources = new ResourceSection();
 				}
 				unmanagedResources.AddVersionInfo(versionInfoData);
 			}
 
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				// we intentionally don't filter out the version info (pseudo) custom attributes (to be compatible with .NET)
 				manifestModule.SetCustomAttribute(0x20000001, cab);
 			}
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				// we intentionally don't filter out the version info (pseudo) custom attributes (to be compatible with .NET)
 				manifestModule.SetCustomAttribute(0x20000001, cab);
 			}
 
 			manifestModule.AddDeclarativeSecurity(0x20000001, declarativeSecurity);
 
 			foreach (Type type in typeForwarders)
 			{
 				manifestModule.AddTypeForwarder(type);
 			}
 			foreach (Type type in typeForwarders)
 			{
 				manifestModule.AddTypeForwarder(type);
 			}
 
 			foreach (ResourceFile resfile in resourceFiles)
 			{
 				int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
 				ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
 				rec.Offset = 0;
 				rec.Flags = (int)resfile.Attributes;
 				rec.Name = manifestModule.Strings.Add(resfile.Name);
 				rec.Implementation = fileToken;
 				manifestModule.ManifestResource.AddRecord(rec);
 			}
 			foreach (ResourceFile resfile in resourceFiles)
 			{
 				int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
 				ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
 				rec.Offset = 0;
 				rec.Flags = (int)resfile.Attributes;
 				rec.Name = manifestModule.Strings.Add(resfile.Name);
 				rec.Implementation = fileToken;
 				manifestModule.ManifestResource.AddRecord(rec);
 			}
 
 			int entryPointToken = 0;
 
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.FillAssemblyRefTable();
 				if (moduleBuilder != manifestModule)
 				{
 					int fileToken;
 					if (entryPoint != null && entryPoint.Module == moduleBuilder)
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
 						entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					else
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
 						fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					moduleBuilder.ExportTypes(fileToken, manifestModule);
 				}
 			}
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.FillAssemblyRefTable();
 				if (moduleBuilder != manifestModule)
 				{
 					int fileToken;
 					if (entryPoint != null && entryPoint.Module == moduleBuilder)
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
 						entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					else
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
 						fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					moduleBuilder.ExportTypes(fileToken, manifestModule);
 				}
 			}
 
 			foreach (Module module in addedModules)
 			{
 				int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
 				module.ExportTypes(fileToken, manifestModule);
 			}
 			foreach (Module module in addedModules)
 			{
 				int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
 				module.ExportTypes(fileToken, manifestModule);
 			}
 
 			if (entryPointToken == 0 && entryPoint != null)
 			{
 				entryPointToken = entryPoint.MetadataToken;
 			}
 
 			// finally, write the manifest module
 			ModuleWriter.WriteModule(keyPair, publicKey, manifestModule, fileKind, portableExecutableKind, imageFileMachine, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken);
 		}
]]>
</clone_fragment>
</clone_pair>
</clones>
